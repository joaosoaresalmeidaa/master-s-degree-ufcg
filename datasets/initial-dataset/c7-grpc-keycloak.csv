user_id,user_login,pull_request_url,comment_id,created_at,path,diff_hunk,content,codesmell
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/33360,1224484635,2023-06-09T15:54:54Z,tools/run_tests/xds_k8s_test_driver/framework/xds_k8s_testcase.py,"@@ -301,55 +301,66 @@ def assertRpcStatusCodes(self,                              method: str,                              stray_rpc_limit: int = 0) -> None:         """"""Assert all RPCs for a method are completing with a certain status.""""""+        expected_status_int: int = expected_status.value[0]+        expected_status_fmt: str = helpers_grpc.status_pretty(expected_status)+         # Sending with pre-set QPS for a period of time         before_stats = test_client.get_load_balancer_accumulated_stats()+        before_stats_fmt: str = self._pretty_accumulated_stats(before_stats)         logging.debug(","I agree that not having the test failure in-line with the logs is unfortunate. Ordinarily for python testing there's not as much teardown and teardown logging as we do, so it makes sense to be a gap. If you think about JUnit, it doesn't include the test failure in-line either (although there's some Java issues that contribute to that as well).I'd be quite fine with having the framework log an error. From a ""ctrl-f to find the log"" perspective, I don't know if it'd be best to duplicate the message or have a generic ""THE TEST FAILED HERE"", simply because there's two copies of the error on the sponge page already. But whatever, all that seems fine.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33386,1224593757,2023-06-09T17:50:51Z,src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc,"@@ -268,15 +268,15 @@ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Lifeguard::     MaybeStartNewThread();   }   lifeguard_running_ = false;-  lifeguard_shutdown_cv_.Signal();+  lifeguard_is_shut_down_cv_.Signal(); }  void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Lifeguard::     BlockUntilShutdown() {   grpc_core::MutexLock lock(&lifeguard_shutdown_mu_);   while (lifeguard_running_) {-    lifeguard_shutdown_cv_.Signal();-    lifeguard_shutdown_cv_.WaitWithTimeout(+    lifeguard_should_shut_down_cv_.Signal();","If we only signal once, I think it's possible for the lifeguard main loop to miss it and wait longer than necessary (whatever the current backoff time is). This repeated signalling was a benchmark-driven optimization as well.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1224596900,2023-06-09T17:54:59Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -336,6 +329,12 @@ absl::Status PickFirst::UpdateLocked(UpdateArgs args) {           DisableOutlierDetectionAttribute::kName,           std::make_unique<DisableOutlierDetectionAttribute>()));     }+    if (args.config != nullptr) {","This condition should always be true, so there's no need to check it.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33386,1224651591,2023-06-09T18:56:40Z,src/core/lib/event_engine/thread_pool/work_stealing_thread_pool.cc,"@@ -268,15 +268,15 @@ void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Lifeguard::     MaybeStartNewThread();   }   lifeguard_running_ = false;-  lifeguard_shutdown_cv_.Signal();+  lifeguard_is_shut_down_cv_.Signal(); }  void WorkStealingThreadPool::WorkStealingThreadPoolImpl::Lifeguard::     BlockUntilShutdown() {   grpc_core::MutexLock lock(&lifeguard_shutdown_mu_);   while (lifeguard_running_) {-    lifeguard_shutdown_cv_.Signal();-    lifeguard_shutdown_cv_.WaitWithTimeout(+    lifeguard_should_shut_down_cv_.Signal();","I think this bit needs to be fixed prior to de-experimentalizing: this wakeup ought to be possible with a single signal when the flag changes.That we need a loop here will likely lead to some wildly varying and load-dependent shutdown times.(it may be that we need to accept a small perf regression here to achieve that, and I think the robustness improvement will be worth it)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1224653415,2023-06-09T18:58:21Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -39,6 +49,70 @@ class PickFirstTest : public LoadBalancingPolicyTest {  protected:   PickFirstTest() : lb_policy_(MakeLbPolicy(""pick_first"")) {} +  static RefCountedPtr<LoadBalancingPolicy::Config> MakePickFirstConfig(+      bool shuffle_address_list) {+    return MakeConfig(Json::FromArray({Json::FromObject({{+        ""pick_first"",+        Json::FromObject(+            {{""shuffleAddressList"", Json::FromBool(shuffle_address_list)}}),+    }})}));+  }++  // Gets order the addresses are being picked. Return type is void so+  // assertions can be used+  void GetOrderAddressesArePicked(+      absl::Span<const absl::string_view> addresses,+      std::vector<absl::string_view>* out_address_order) {+    // Construct a map of subchannel to address.+    // We will remove entries as each subchannel starts to connect.+    std::map<SubchannelState*, absl::string_view> subchannels;+    for (auto address : addresses) {+      auto* subchannel = FindSubchannel(+          address, ChannelArgs().Set(GRPC_ARG_INHIBIT_HEALTH_CHECKING, true));+      ASSERT_NE(subchannel, nullptr);+      subchannels.emplace(subchannel, address);+    }+    // Now process each subchannel in the order in which pick_first tries it.+    while (!subchannels.empty()) {+      // Find the subchannel that is being attempted.+      SubchannelState* subchannel = nullptr;+      for (const auto& p : subchannels) {+        if (p.first->ConnectionRequested()) {+          out_address_order->push_back(p.second);+          subchannel = p.first;+          break;+        }+      }+      ASSERT_NE(subchannel, nullptr);+      // The subchannel reports CONNECTING.+      subchannel->SetConnectivityState(GRPC_CHANNEL_CONNECTING);+      // If this is the first subchannel being attempted, expect a CONNECTING+      // update.+      if (subchannels.size() == addresses.size()) {+        ExpectConnectingUpdate();+      }+      if (subchannels.size() > 1) {+        // Not the last subchannel in the list.  Connection attempt should fail.+        subchannel->SetConnectivityState(+            GRPC_CHANNEL_TRANSIENT_FAILURE,+            absl::UnavailableError(""failed to connect""));+        subchannel->SetConnectivityState(GRPC_CHANNEL_IDLE);+      } else {","I don't think this is going to work reliably.  The test is going to be flaky.The problem is that when we call `ExpectStateAndQueuingPicker(GRPC_CHANNEL_IDLE)` for the last subchannel, doing the pick will trigger the LB policy to exit idle state and start trying to connect again.  It will start with the first subchannel in the *current* order of the addresses, so `ConnectionRequested()` will return true for that subchannel even before we send a new address list update to the LB policy, which will cause it to shuffle again.  So the next time we call `GetOrderAddressesArePicked()`, we may see the connection attempts in a different order than the new shuffled order.For example, consider the following sequence of events:1. We send the LB policy an address update containing [A, B, C].  The LB policy shuffles to the order [C, B, A].1. On the first call to `GetOrderAddressesArePicked()`, we see the shuffled order [C, B, A].  We fail the connection attempts to C and B, and then we succeed connecting to A.  Then we have A report IDLE, which causes the policy to report IDLE.  Now we request a pick, which triggers the policy to start trying to connect again.  It will request a connection on C, since that's the first address in the current order.  At this point, the subchannel for C will return true for `ConnectionRequested()`, but we haven't yet checked it.2. Now we send the LB policy a new address list update.  This time, it shuffles the addresses into order [B, A, C].  It will now immediately drop the old subchannel list and switch to the new one, and it will start connecting to address B.  This means the subchannel for B will return true for `ConnectionRequested()`.6. In the test, we now call `GetOrderAddressesArePicked()` again.  At this point, the subchannels for both addresses B and C will return true for `ConnectionRequested()`.  We want the test to see B first, since that's the first entry in the shuffled address list, but it may happen to see C first instead, thus returning a different order than what the LB policy is actually using.  (The order in which we check the addresses here depends on the addresses that happen to be used to allocate the `SubchannelState` objects, since that address is the key of the map on line 69.)To solve this, I think you need to add a parameter to this function indicating whether we want to finish the connection attempt pass.  In the case where we are going to send another address update after this one, we should avoid doing a pick after the LB policy reports IDLE, so that it does not start trying to connect again.  In other words, we want something like this on line 110:```if (exit_idle_after_connection_fails) {  ExpectStateAndQueuingPicker(GRPC_CHANNEL_IDLE);} else {  ExpectState(GRPC_CHANNEL_IDLE);}```But this also means that we need to trigger the LB policy to exit idle *after* we deliver the subsequent address list update to it.  So we'll probably need to add code at the top of this function to hop into the `WorkSerializer` and call the LB policy's `ExitIdleLocked()` method.",
30379873,carlocab,https://api.github.com/repos/grpc/grpc/pulls/32988,1224695751,2023-06-09T19:40:08Z,cmake/protobuf.cmake,"@@ -90,6 +86,6 @@ elseif(gRPC_PROTOBUF_PROVIDER STREQUAL ""package"")         set(_gRPC_PROTOBUF_PROTOC_EXECUTABLE ${PROTOBUF_PROTOC_EXECUTABLE})       endif()     endif()-    set(_gRPC_FIND_PROTOBUF ""if(NOT Protobuf_FOUND AND NOT PROTOBUF_FOUND)\n  find_package(Protobuf ${gRPC_PROTOBUF_PACKAGE_TYPE})\nendif()"")+    set(_gRPC_FIND_PROTOBUF ""if(NOT Protobuf_FOUND AND NOT PROTOBUF_FOUND)\n  find_package(Protobuf CONFIG)\nendif()"")",You need to `include(CMakeFindDependencyMacro)` to use `find_dependency`. #33361,
122473768,alto-ruby,https://api.github.com/repos/grpc/grpc/pulls/33400,1225683048,2023-06-11T02:38:04Z,src/core/lib/gpr/log.cc,"@@ -109,6 +110,8 @@ static gpr_atm parse_log_severity(absl::string_view str, gpr_atm error_value) { }  void gpr_log_verbosity_init() {+  absl::InitializeLog();",Can you try doing this in [Init_grpc_c](https://github.com/grpc/grpc/blob/master/src/ruby/ext/grpc/rb_grpc.c#L306)?,X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/33254,1226969497,2023-06-12T17:01:13Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -254,45 +255,45 @@ TEST_F(PickFirstTest, GoesIdleWhenConnectionFailsThenCanReconnect) { TEST_F(PickFirstTest, WithShuffle) {   testing::ScopedExperimentalEnvVar env_var(       ""GRPC_EXPERIMENTAL_PICKFIRST_LB_CONFIG"");-  // 6 addresses have 6! = 720 permutations or 0.1% chance that the shuffle-  // returns initial sequence   constexpr std::array<absl::string_view, 6> kAddresses = {       ""ipv4:127.0.0.1:443"", ""ipv4:127.0.0.1:444"", ""ipv4:127.0.0.1:445"",       ""ipv4:127.0.0.1:446"", ""ipv4:127.0.0.1:447"", ""ipv4:127.0.0.1:448""};-  absl::Status status = ApplyUpdate(-      BuildUpdate(kAddresses, MakePickFirstConfig(true)), lb_policy_.get());-  EXPECT_TRUE(status.ok()) << status;-  std::vector<absl::string_view> prev_attempt_connect_order;-  GetOrderAddressesArePicked(kAddresses, &prev_attempt_connect_order);-  // There is 0.1% chance this check fails by design. Not an assert to prevent-  // flake-  if (absl::MakeConstSpan(prev_attempt_connect_order) ==-      absl::MakeConstSpan(kAddresses)) {-    gpr_log(GPR_INFO, ""Address order did not change"");-  }-  constexpr size_t kMaxAttempts = 5;-  bool shuffled = false;-  for (size_t attempt = 0; attempt < kMaxAttempts; ++attempt) {-    std::vector<absl::string_view> address_order;-    GetOrderAddressesArePicked(kAddresses, &address_order);-    if (address_order != prev_attempt_connect_order) {-      shuffled = true;+  // 6 addresses have 6! = 720 permutations or roughly 0.14% chance that+  // the shuffle returns same permutation. We allow for several tries to+  // prevent flake test.+  constexpr size_t kMaxTries = 10;+  std::vector<absl::string_view> addresses_after_update;+  for (size_t i = 0; i < kMaxTries; i++) {+    absl::Status status = ApplyUpdate(+        BuildUpdate(kAddresses, MakePickFirstConfig(true)), lb_policy_.get());+    EXPECT_TRUE(status.ok()) << status;+    GetOrderAddressesArePicked(kAddresses, &addresses_after_update);+    if (absl::MakeConstSpan(addresses_after_update) !=+        absl::MakeConstSpan(kAddresses)) {       break;     }-    prev_attempt_connect_order = std::move(address_order);   }-  ASSERT_TRUE(shuffled) << ""Addresses are not reshuffled"";+  // Same elements, different order+  ASSERT_THAT(addresses_after_update,","The goal hear is to check that all addresses are there, no duplicates - and order is different.",
963826,stanhu,https://api.github.com/repos/grpc/grpc/pulls/33400,1227011529,2023-06-12T17:26:20Z,src/core/lib/gpr/log.cc,"@@ -109,6 +110,8 @@ static gpr_atm parse_log_severity(absl::string_view str, gpr_atm error_value) { }  void gpr_log_verbosity_init() {+  absl::InitializeLog();","Yes, that seems to work, though calling `absl::InitializeLog()` twice causes the library to fail the seoncd time.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1229734882,2023-06-14T14:41:08Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -121,7 +128,8 @@ TEST_F(PickFirstTest, FirstAddressWorks) {   // Send an update containing two addresses.   constexpr std::array<absl::string_view, 2> kAddresses = {       ""ipv4:127.0.0.1:443"", ""ipv4:127.0.0.1:444""};-  absl::Status status = ApplyUpdate(BuildUpdate(kAddresses), lb_policy_.get());+  absl::Status status = ApplyUpdate(+      BuildUpdate(kAddresses, MakePickFirstConfig(false)), lb_policy_.get());","If we are going to pass in a config that explicitly sets ""shuffleAddressList"" to false instead of just leaving that field unset, then that means that we have no test coverage to verify that if the field is unset it defaults to false.I suggest the following:- Change the `shuffle_address_list` parameter to `MakePickFirstConfig()` to be `absl::optional<bool>` and have it default to `absl::nullopt`.  If it does not have a value, then we leave the field unset in the config.- For all tests except `WithShuffle` and `ShufflingDisabled`, leave the parameter unset.  Those two tests will set the parameter to true.- Add a new test `ShufflingDisabledInConfig` that is the same as `ShufflingDisabled`, except that (a) it sets the env var to enable the feature and (b) it explicitly passes false to `MakePickFirstConfig()`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1229778987,2023-06-14T15:06:31Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -292,10 +308,12 @@ TEST_F(PickFirstTest, ShufflingDisabled) {   constexpr static size_t kMaxAttempts = 5;   for (size_t attempt = 0; attempt < kMaxAttempts; ++attempt) {     absl::Status status = ApplyUpdate(-        BuildUpdate(kAddresses, MakePickFirstConfig(true)), lb_policy_.get());+        BuildUpdate(kAddresses, MakePickFirstConfig(false)), lb_policy_.get());","This needs to pass `true` to `MakePickFirstConfig()`.  The goal of this test is to show that if the env var is not set, then the config parameter is ignored.Please rename the test to `ShufflingDisabledViaEnvVar` to make this clear.  Also, please add a TODO indicating that this test should be removed when the env var protection is removed.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1229789517,2023-06-14T15:13:37Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -292,10 +308,12 @@ TEST_F(PickFirstTest, ShufflingDisabled) {   constexpr static size_t kMaxAttempts = 5;   for (size_t attempt = 0; attempt < kMaxAttempts; ++attempt) {     absl::Status status = ApplyUpdate(-        BuildUpdate(kAddresses, MakePickFirstConfig(true)), lb_policy_.get());+        BuildUpdate(kAddresses, MakePickFirstConfig(false)), lb_policy_.get());+    work_serializer_->Run([&]() { lb_policy_->ExitIdleLocked(); },+                          DEBUG_LOCATION);     EXPECT_TRUE(status.ok()) << status;     std::vector<absl::string_view> address_order;-    GetOrderAddressesArePicked(kAddresses, &address_order);+    GetOrderAddressesArePicked(kAddresses, true, &address_order);","We need to set `exit_idle_after_connection_fails` to false here.  It always needs to be set to false if we're going to do another pass after the current one.If this is going to be too error prone, maybe we should just remove the `exit_idle_after_connection_fails` parameter and always use `ExpectState(GRPC_CHANNEL_IDLE)` instead of `ExpectStateAndQueueingPicker(GRPC_CHANNEL_IDLE)`.  That will skip checking the picker, but maybe that's okay in this case, since we already cover that case in the `GoesIdleWhenConnectionFailsThenCanReconnect` test.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1229793674,2023-06-14T15:16:00Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -263,26 +275,30 @@ TEST_F(PickFirstTest, WithShuffle) {   // prevent flake test.   constexpr size_t kMaxTries = 10;   std::vector<absl::string_view> addresses_after_update;-  for (size_t i = 0; i < kMaxTries; i++) {+  bool shuffled = false;+  for (size_t i = 0; i < kMaxTries; ++i) {     absl::Status status = ApplyUpdate(         BuildUpdate(kAddresses, MakePickFirstConfig(true)), lb_policy_.get());+    work_serializer_->Run([&]() { lb_policy_->ExitIdleLocked(); },","Suggest moving this inside of `GetOrderAddressesArePicked()`, so that we don't need to duplicate it in 3 places.",X
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/33436,1231259765,2023-06-15T16:19:22Z,grpc.gemspec,"@@ -43,7 +43,7 @@ Gem::Specification.new do |s|   s.add_development_dependency 'rspec',              '~> 3.6'   s.add_development_dependency 'rubocop',            '~> 1.41.0'   s.add_development_dependency 'signet',             '~> 0.7'-  s.add_development_dependency 'googleauth',         '>= 0.5.1', '< 0.10'+  s.add_development_dependency 'googleauth',         '~> 1.0'","this is actually generated from https://github.com/grpc/grpc/blob/133640507bc6191ee74bf76602b64ee5631c96b6/templates/grpc.gemspec.template#L48Because we're just changing one line, you can just make the exact same change in that line of the template file -- can you please do that?",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33257,1231420781,2023-06-15T18:53:40Z,src/core/lib/transport/promise_endpoint.h,"@@ -0,0 +1,305 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H+#define GRPC_SRC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <stddef.h>+#include <stdint.h>++#include <functional>+#include <initializer_list>+#include <limits>+#include <memory>+#include <utility>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/slice_buffer.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""++namespace grpc_core {++class PromiseEndpoint {+ public:+  PromiseEndpoint(+      std::unique_ptr<grpc_event_engine::experimental::EventEngine::Endpoint>+          endpoint,+      SliceBuffer already_received);+  ~PromiseEndpoint();++  // Returns a promise that resolves to a `absl::Status` indicating the result+  // of the write operation.+  //+  // Concurrent writes are not supported, which means callers should not call+  // `Write()` before the previous write finishes. Doing that results in+  // undefined behavior.+  auto Write(SliceBuffer data) {+    {+      MutexLock lock(&write_mutex_);++      // Previous write result has not been polled.+      GPR_ASSERT(!write_result_.has_value());++      // TODO(ladynana): Replace this with `SliceBufferCast<>` when it is+      // available.+      grpc_slice_buffer_swap(write_buffer_.c_slice_buffer(),+                             data.c_slice_buffer());+    }++    // If `Write()` returns true immediately, the callback will not be called.+    // We still need to call our callback to pick up the result.+    if (endpoint_->Write(std::bind(&PromiseEndpoint::WriteCallback, this,+                                   std::placeholders::_1),+                         &write_buffer_,+                         nullptr /* uses default arguments */)) {+      WriteCallback(absl::OkStatus());+    }++    return [this]() -> Poll<absl::Status> {+      MutexLock lock(&write_mutex_);+      if (!write_result_.has_value()) {+        write_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else {+        const auto ret = *write_result_;+        write_result_.reset();+        return ret;+      }+    };+  }++  // Returns a promise that resolves to `SliceBuffer` with+  // `num_bytes` bytes.+  //+  // Concurrent reads are not supported, which means callers should not call+  // `Read()` before the previous read finishes. Doing that results in+  // undefined behavior.+  auto Read(size_t num_bytes) {+    ReleasableMutexLock lock(&read_mutex_);++    // Previous read result has not been polled.+    GPR_ASSERT(!read_result_.has_value());++    // Should not have pending reads.+    GPR_ASSERT(pending_read_buffer_.Count() == 0u);++    if (read_buffer_.Length() < num_bytes) {+      lock.Release();+      // If `Read()` returns true immediately, the callback will not be+      // called. We still need to call our callback to pick up the result and+      // maybe do further reads.+      if (endpoint_->Read(std::bind(&PromiseEndpoint::ReadCallback, this,+                                    std::placeholders::_1, num_bytes,+                                    absl::nullopt /* uses default arguments */),+                          &pending_read_buffer_,+                          nullptr /* uses default arguments */)) {+        ReadCallback(absl::OkStatus(), num_bytes, absl::nullopt);+      }+    } else {+      read_result_ = absl::OkStatus();+    }++    return [this, num_bytes]() -> Poll<absl::StatusOr<SliceBuffer>> {+      MutexLock lock(&read_mutex_);+      if (!read_result_.has_value()) {+        read_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else if (!read_result_->ok()) {+        const absl::Status ret = *read_result_;+        read_result_.reset();+        return ret;+      } else {+        SliceBuffer ret;+        grpc_slice_buffer_move_first(read_buffer_.c_slice_buffer(), num_bytes,+                                     ret.c_slice_buffer());++        read_result_.reset();+        return std::move(ret);+      }+    };+  }++  // Returns a promise that resolves to `Slice` with at least+  // `num_bytes` bytes which should be less than INT64_MAX bytes.+  //+  // Concurrent reads are not supported, which means callers should not call+  // `ReadSlice()` before the previous read finishes. Doing that results in+  // undefined behavior.+  auto ReadSlice(size_t num_bytes) {+    ReleasableMutexLock lock(&read_mutex_);+    if (num_bytes >= static_cast<size_t>(std::numeric_limits<int64_t>::max())) {+      read_result_ = absl::Status(+          absl::StatusCode::kInvalidArgument,+          absl::StrFormat(+              ""Requested size is bigger than the maximum supported size %lld."",+              std::numeric_limits<int64_t>::max()));+    } else {+      // Previous read result has not been polled.+      GPR_ASSERT(!read_result_.has_value());++      // Should not have pending reads.+      GPR_ASSERT(pending_read_buffer_.Count() == 0u);++      if (read_buffer_.Length() < num_bytes) {+        lock.Release();+        const struct grpc_event_engine::experimental::EventEngine::Endpoint::+            ReadArgs read_args = {static_cast<int64_t>(num_bytes)};++        // If `Read()` returns true immediately, the callback will not be+        // called. We still need to call our callback to pick up the result+        // and maybe do further reads.+        if (endpoint_->Read(+                std::bind(&PromiseEndpoint::ReadCallback, this,+                          std::placeholders::_1, num_bytes, read_args),+                &pending_read_buffer_, &read_args)) {+          ReadCallback(absl::OkStatus(), num_bytes, read_args);+        }+      } else {+        read_result_ = absl::OkStatus();+      }+    }++    return [this, num_bytes]() -> Poll<absl::StatusOr<Slice>> {+      MutexLock lock(&read_mutex_);+      if (!read_result_.has_value()) {+        read_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else if (!read_result_->ok()) {+        const auto ret = *read_result_;+        read_result_.reset();+        return ret;+      } else if (read_buffer_.RefSlice(0).size() == num_bytes) {+        read_result_.reset();+        return Slice(read_buffer_.TakeFirst().TakeCSlice());+      } else {+        MutableSlice ret = MutableSlice::CreateUninitialized(num_bytes);+        read_buffer_.MoveFirstNBytesIntoBuffer(num_bytes, ret.data());++        read_result_.reset();+        return Slice(std::move(ret));+      }+    };+  }++  // Returns a promise that resolves to a byte with type `uint8_t`.+  auto ReadByte() {+    ReleasableMutexLock lock(&read_mutex_);++    // Previous read result has not been polled.+    GPR_ASSERT(!read_result_.has_value());++    // Should not have pending reads.+    GPR_ASSERT(pending_read_buffer_.Count() == 0u);++    if (read_buffer_.Length() == 0u) {+      lock.Release();++      // If `Read()` returns true immediately, the callback will not be called.+      // We still need to call our callback to pick up the result and maybe do+      // further reads.+      if (endpoint_->Read(std::bind(&PromiseEndpoint::ReadByteCallback, this,+                                    std::placeholders::_1),+                          &pending_read_buffer_, nullptr)) {+        ReadByteCallback(absl::OkStatus());+      }+    } else {+      read_result_ = absl::OkStatus();+    }++    return [this]() -> Poll<absl::StatusOr<uint8_t>> {+      MutexLock lock(&read_mutex_);+      if (!read_result_.has_value()) {+        read_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else if (!read_result_->ok()) {+        const auto ret = *read_result_;+        read_result_.reset();+        return ret;+      } else {+        uint8_t ret = 0u;+        read_buffer_.MoveFirstNBytesIntoBuffer(1, &ret);++        read_result_.reset();+        return ret;+      }+    };+  }++  const grpc_event_engine::experimental::EventEngine::ResolvedAddress&+  GetPeerAddress() const;+  const grpc_event_engine::experimental::EventEngine::ResolvedAddress&+  GetLocalAddress() const;++ private:+  std::unique_ptr<grpc_event_engine::experimental::EventEngine::Endpoint>+      endpoint_;++  // Data used for writes.+  Mutex write_mutex_;+  // Write buffer used for `EventEngine::Endpoint::Write()` to ensure the+  // memory behind the buffer is not lost.+  grpc_event_engine::experimental::SliceBuffer write_buffer_;+  // Used for store the result from `EventEngine::Endpoint::Write()`.+  // `write_result_.has_value() == true` means the value has not been polled+  // yet.+  absl::optional<absl::Status> write_result_ ABSL_GUARDED_BY(write_mutex_);+  Waker write_waker_ ABSL_GUARDED_BY(write_mutex_);++  // Callback function used for `EventEngine::Endpoint::Write()`.+  void WriteCallback(absl::Status status);++  // Data used for reads+  Mutex read_mutex_;",(a similar scheme would work for writes),
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33257,1231431977,2023-06-15T19:06:19Z,test/core/transport/promise_endpoint_test.cc,"@@ -0,0 +1,1389 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/transport/promise_endpoint.h""++// IWYU pragma: no_include <sys/socket.h>++#include <algorithm>+#include <cstring>+#include <functional>+#include <memory>+#include <queue>+#include <string>+#include <tuple>++#include ""absl/functional/any_invocable.h""+#include ""absl/types/optional.h""+#include ""gmock/gmock.h""+#include ""gtest/gtest.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/port.h>  // IWYU pragma: keep+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/support/log.h>++#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/detail/basic_join.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/slice/slice_internal.h""+#include ""test/core/promise/test_wakeup_schedulers.h""++using testing::MockFunction;+using testing::StrictMock;++namespace grpc_core {+namespace testing {++class MockEndpoint","It's unclear to me what we're gaining by this being a mock.At present (though I could be convinced otherwise) I think we'd be better off having a `FakeEndpoint` - still deriving from `grpc_event_engine::experimental::EventEngine::Endpoint` but directly implementing Read, Write, etc.The rest of the classes working would be the same, but we'd drop a bunch of the expect calls in tests and end up with a more readable thing.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1231492686,2023-06-15T20:16:06Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -292,10 +308,12 @@ TEST_F(PickFirstTest, ShufflingDisabled) {   constexpr static size_t kMaxAttempts = 5;   for (size_t attempt = 0; attempt < kMaxAttempts; ++attempt) {     absl::Status status = ApplyUpdate(-        BuildUpdate(kAddresses, MakePickFirstConfig(true)), lb_policy_.get());+        BuildUpdate(kAddresses, MakePickFirstConfig(false)), lb_policy_.get());+    work_serializer_->Run([&]() { lb_policy_->ExitIdleLocked(); },+                          DEBUG_LOCATION);     EXPECT_TRUE(status.ok()) << status;     std::vector<absl::string_view> address_order;-    GetOrderAddressesArePicked(kAddresses, &address_order);+    GetOrderAddressesArePicked(kAddresses, true, &address_order);","The parameter still needs to be set to false.The problem here is not instability, it's that the test is not actually covering what it should.  The reason that you're not seeing any flakiness is that the first subchannel that the LB policy tries to connect when we exit idle is the same one that it will always try first after the next address list update.  But if the LB policy failed to try that particular address first after the update, the test could still pass, and in that case we would not want it to.At this point, I think it's clear that we should remove the `exit_idle_after_connection_fails` parameter and always use `ExpectState(GRPC_CHANNEL_IDLE)` instead of `ExpectStateAndQueueingPicker(GRPC_CHANNEL_IDLE)`.  And we should add a comment indicating that we're explicitly *not* using the latter, because we don't want to trigger exiting idle until after the next address list update, if any.  Otherwise, the subtleties of the behavior here are going to be very unclear to future engineers who look at this code.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1232266548,2023-06-16T13:38:06Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -114,11 +112,8 @@ class PickFirstTest : public LoadBalancingPolicyTest {         // Then it should become disconnected.         subchannel->SetConnectivityState(GRPC_CHANNEL_IDLE);         ExpectReresolutionRequest();-        if (exit_idle_after_connection_fails) {-          ExpectStateAndQueuingPicker(GRPC_CHANNEL_IDLE);-        } else {-          ExpectState(GRPC_CHANNEL_IDLE);-        }+        // Do not trigger exit idle.","This comment isn't sufficiently clear.  I suggest the following wording:""""""We would normally call ExpectStateAndQueueingPicker() here instead of just ExpectState().  However, calling the picker would also trigger exiting IDLE, which we don't want here, because if the test is going to send an address list update and call GetOrderAddressesArePicked() again, we don't want to trigger a connection attempt on any subchannel until after that next address list update is processed.""""""",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33254,1232266676,2023-06-16T13:38:12Z,test/core/client_channel/lb_policy/pick_first_test.cc,"@@ -313,8 +305,7 @@ TEST_F(PickFirstTest, ShufflingDisabled) {         BuildUpdate(kAddresses, MakePickFirstConfig(false)), lb_policy_.get());     EXPECT_TRUE(status.ok()) << status;     std::vector<absl::string_view> address_order;-    GetOrderAddressesArePicked(kAddresses, true, &address_order);-    EXPECT_THAT(address_order, ::testing::ElementsAreArray(kAddresses));","This expectation is still needed.  The whole point of this test is to verify that the address list was *not* shuffled.  Without this expectation, the test is not doing that.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33458,1232439151,2023-06-16T16:04:58Z,src/core/ext/filters/client_channel/resolver/polling_resolver.h,"@@ -69,6 +69,7 @@ class PollingResolver : public Resolver {   const std::string& name_to_resolve() const { return name_to_resolve_; }   grpc_pollset_set* interested_parties() const { return interested_parties_; }   const ChannelArgs& channel_args() const { return channel_args_; }+  std::shared_ptr<WorkSerializer> work_serializer() { return work_serializer_; }","I think this should return a raw pointer, not a `shared_ptr<>`.  The subclass is not going to need to take its own ref.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33459,1232480524,2023-06-16T16:30:57Z,include/grpc/event_engine/event_engine.h,"@@ -321,6 +321,11 @@ class EventEngine : public std::enable_shared_from_this<EventEngine> {   /// called.   virtual bool CancelConnect(ConnectionHandle handle) = 0;   /// Provides asynchronous resolution.+  ///+  /// gRPC requires this object to have a destruction-is-cancellation semantic.","Suggest wording this as ""This object has a destruction-is-cancellation semantic.""  It's not really a gRPC requirement; it's a requirement of this API contract.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/33461,1232572841,2023-06-16T18:05:42Z,src/core/ext/filters/logging/logging_filter.cc,"@@ -256,21 +256,19 @@ class CallData {   void LogServerHeader(bool is_client, CallTracerAnnotationInterface* tracer,                        const ServerMetadata* metadata) {     LoggingSink::Entry entry;-    if (metadata != nullptr) {",are we sure that metadata will not be nullptr?,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33459,1235476550,2023-06-20T15:54:01Z,include/grpc/event_engine/event_engine.h,"@@ -363,37 +368,26 @@ class EventEngine : public std::enable_shared_from_this<EventEngine> {     /// \a default_port may be a non-numeric named service port, and will only     /// be used if \a address does not already contain a port component.     ///-    /// When the lookup is complete, the \a on_resolve callback will be invoked-    /// with a status indicating the success or failure of the lookup.-    /// Implementations should pass the appropriate statuses to the callback.-    /// For example, callbacks might expect to receive DEADLINE_EXCEEDED or+    /// When the lookup is complete or cancelled, the \a on_resolve callback+    /// will be invoked with a status indicating the success or failure of the+    /// lookup. Implementations should pass the appropriate statuses to the+    /// callback. For example, callbacks might expect to receive CANCELLED or     /// NOT_FOUND.-    ///-    /// If cancelled, \a on_resolve will not be executed.-    virtual LookupTaskHandle LookupHostname(LookupHostnameCallback on_resolve,","Github UI won't let me comment on the relevant lines, but the `LookupTaskHandle` type is now unused and should be deleted. Same for the `LookupTaskHandleSet` and the overloads for handle-to-string conversions. Do you plan to do that cleanup in a separate step, and is so, what's the reasoning?",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33479,1235488132,2023-06-20T16:03:39Z,src/core/ext/filters/client_channel/retry_filter.h,"@@ -19,12 +19,98 @@  #include <grpc/support/port_platform.h> +#include <limits.h>+#include <stddef.h>++#include <new>++#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/client_channel.h""+#include ""src/core/ext/filters/client_channel/retry_service_config.h""+#include ""src/core/ext/filters/client_channel/retry_throttle.h""+#include ""src/core/lib/channel/channel_args.h"" #include ""src/core/lib/channel/channel_fwd.h"" #include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gpr/useful.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/transport/transport.h""++extern grpc_core::TraceFlag grpc_retry_trace;  namespace grpc_core { -extern const grpc_channel_filter kRetryFilterVtable;+class RetryFilter {+ public:+  static const grpc_channel_filter kVtable;++  static grpc_error_handle Init(grpc_channel_element* elem,","I'd prefer not to expose anything outside of this class that we don't actually need to.  I think basically everything except `kVtable` can be private.Note that the `RetryFilterLegacyCallData` class can still be nested inside of this class and be private, even if it's defined in a separate file.  That should eliminate the need for many of the new accessor methods here.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33479,1235494061,2023-06-20T16:08:39Z,src/core/ext/filters/client_channel/retry_filter.cc,,"I think this method should stay in this file, since it's part of the `RetryFilter` class, not the call data class.  (I'm not sure why it was in this position in the file to begin with -- it should have been somewhere else.)",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33257,1235516447,2023-06-20T16:28:52Z,test/core/transport/promise_endpoint_test.cc,"@@ -0,0 +1,1389 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include ""src/core/lib/transport/promise_endpoint.h""++// IWYU pragma: no_include <sys/socket.h>++#include <algorithm>+#include <cstring>+#include <functional>+#include <memory>+#include <queue>+#include <string>+#include <tuple>++#include ""absl/functional/any_invocable.h""+#include ""absl/types/optional.h""+#include ""gmock/gmock.h""+#include ""gtest/gtest.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/port.h>  // IWYU pragma: keep+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/support/log.h>++#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/detail/basic_join.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/seq.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/slice/slice_internal.h""+#include ""test/core/promise/test_wakeup_schedulers.h""++using testing::MockFunction;+using testing::StrictMock;++namespace grpc_core {+namespace testing {++class MockEndpoint",I think we want the opposite: removal of the mock parts of this class and less expect calls.,X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33459,1235596173,2023-06-20T17:34:52Z,include/grpc/event_engine/event_engine.h,"@@ -363,37 +368,26 @@ class EventEngine : public std::enable_shared_from_this<EventEngine> {     /// \a default_port may be a non-numeric named service port, and will only     /// be used if \a address does not already contain a port component.     ///-    /// When the lookup is complete, the \a on_resolve callback will be invoked-    /// with a status indicating the success or failure of the lookup.-    /// Implementations should pass the appropriate statuses to the callback.-    /// For example, callbacks might expect to receive DEADLINE_EXCEEDED or+    /// When the lookup is complete or cancelled, the \a on_resolve callback+    /// will be invoked with a status indicating the success or failure of the+    /// lookup. Implementations should pass the appropriate statuses to the+    /// callback. For example, callbacks might expect to receive CANCELLED or     /// NOT_FOUND.-    ///-    /// If cancelled, \a on_resolve will not be executed.-    virtual LookupTaskHandle LookupHostname(LookupHostnameCallback on_resolve,",The `LookupTaskHandle` type is still used in the iomgr DNSResolver interface: https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/resolve_address.h#L46-L47The `LookupTaskHandleSet` type is used in the ares implementation of that interface (aka `AresDNSResolver`): https://github.com/grpc/grpc/blob/master/src/core/ext/filters/client_channel/resolver/dns/c_ares/dns_resolver_ares.cc#L709Looks like `HandleToString` is also part of the iomgr DNSResolver interface. I think we can remove these when we remove the iomgr DNSResolver?,X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33459,1235627694,2023-06-20T18:00:57Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -272,24 +272,27 @@ void EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::   {     MutexLock lock(&on_resolved_mu_);     orphaned_ = true;-    // Event if cancellation fails here, OnResolvedLocked will return early, and-    // the resolver will never see a completed request.-    if (hostname_handle_.has_value()) {-      event_engine_resolver_->CancelLookup(*hostname_handle_);-    }-    if (srv_handle_.has_value()) {-      event_engine_resolver_->CancelLookup(*srv_handle_);-    }-    for (const auto& handle : balancer_hostname_handles_) {-      event_engine_resolver_->CancelLookup(handle);-    }-    if (txt_handle_.has_value()) {-      event_engine_resolver_->CancelLookup(*txt_handle_);+    if (timeout_handle_.has_value()) {+      resolver_->event_engine_->Cancel(*timeout_handle_);+      timeout_handle_.reset();     }+    // Even if cancellation fails here, OnResolvedLocked will return early, and","Yes, I think it still apply. This part of the code hasn't been changed: https://github.com/grpc/grpc/blob/master/src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc#L475And I think it's still the case that the resolver will not see a complete result after ee_client_channel_resolver is Orphaned.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33384,1235627845,2023-06-20T18:01:07Z,src/python/grpcio_observability/grpc_observability/_measures.py,"@@ -0,0 +1,91 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++from opencensus.stats import measure as measure_module",Just curious: Why are we renaming to `measure_module`?,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33384,1235630292,2023-06-20T18:03:34Z,src/python/grpcio_observability/grpc_observability/_open_census_exporter.py,"@@ -12,23 +12,275 @@ # See the License for the specific language governing permissions and # limitations under the License. -import logging-from typing import List+from datetime import datetime+import os+from typing import Any, List, Mapping, Optional, Tuple +from google.rpc import code_pb2 from grpc_observability import _observability  # pytype: disable=pyi-error+from grpc_observability import _views+from opencensus.ext.stackdriver import stats_exporter+from opencensus.ext.stackdriver import trace_exporter+from opencensus.stats import stats as stats_module+from opencensus.stats.measurement_map import MeasurementMap+from opencensus.tags.tag_key import TagKey+from opencensus.tags.tag_map import TagMap+from opencensus.tags.tag_value import TagValue+from opencensus.trace import execution_context+from opencensus.trace import samplers+from opencensus.trace import span+from opencensus.trace import span_context as span_context_module+from opencensus.trace import span_data as span_data_module+from opencensus.trace import status+from opencensus.trace import time_event+from opencensus.trace import trace_options as trace_options_module+from opencensus.trace import tracer -logger = logging.getLogger(__name__)+_gcp_observability = Any  # grpc_observability.py imports this module.++# 60s is the default time for open census to call export.","60 seconds seems quite long to me. Is this number based on anything in particular?Any data not already exported by the process at the time of a crash will be lost, so we need to be thinking about how much time is acceptable for data loss. 60 seconds seems kind of long. Since our primary motivation here was to not require us to unnecessarily acquire the GIL, I think something more like 5-10 seconds makes more sense there.We should also consider that we have two different numbers controlling export of data: maximum time and maximum buffer size. Depending on the QPS, we may find that the buffer size is so small that we consistently only hit that condition for export rather than the maximum time.According to our benchmarks, our maximum throughput on an 8 core machine is ~3500 QPS. Given our current buffer size, we would be hitting the maximum buffer condition every 0.02 seconds.How about we make the default maximum buffer size 10000 and the default maximum time 10 seconds?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33479,1235767772,2023-06-20T20:00:59Z,src/core/ext/filters/client_channel/retry_filter.h,"@@ -19,12 +19,98 @@  #include <grpc/support/port_platform.h> +#include <limits.h>+#include <stddef.h>++#include <new>++#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/client_channel.h""+#include ""src/core/ext/filters/client_channel/retry_service_config.h""+#include ""src/core/ext/filters/client_channel/retry_throttle.h""+#include ""src/core/lib/channel/channel_args.h"" #include ""src/core/lib/channel/channel_fwd.h"" #include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gpr/useful.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/transport/transport.h""++extern grpc_core::TraceFlag grpc_retry_trace;  namespace grpc_core { -extern const grpc_channel_filter kRetryFilterVtable;+class RetryFilter {+ public:+  static const grpc_channel_filter kVtable;++  static grpc_error_handle Init(grpc_channel_element* elem,","I know it's possible to have a nested class defined in a separate file, but it irks me: I really like to see all of each top level class defined in one .cc file, and doing otherwise seems like it needs a stronger justification.So I'd like to keep the accessors as is, but move some of these statics privately.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33479,1235913822,2023-06-20T21:29:46Z,src/core/ext/filters/client_channel/retry_filter.h,"@@ -19,12 +19,98 @@  #include <grpc/support/port_platform.h> +#include <limits.h>+#include <stddef.h>++#include <new>++#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/client_channel.h""+#include ""src/core/ext/filters/client_channel/retry_service_config.h""+#include ""src/core/ext/filters/client_channel/retry_throttle.h""+#include ""src/core/lib/channel/channel_args.h"" #include ""src/core/lib/channel/channel_fwd.h"" #include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gpr/useful.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/transport/transport.h""++extern grpc_core::TraceFlag grpc_retry_trace;  namespace grpc_core { -extern const grpc_channel_filter kRetryFilterVtable;+class RetryFilter {+ public:+  static const grpc_channel_filter kVtable;++  static grpc_error_handle Init(grpc_channel_element* elem,","I'm really not comfortable with exposing all of these internal implementation details; I think exposing them is more likely to cause problems than having them in another file.  I understand the desire to not split a class between two files, but we don't actually have any requirement to do that in the first place.  If you want to split it, I'm fine with that, as long as we keep the internal implementation details private.  If you're not comfortable with that, then I'd prefer to just keep everything in one file the way it is now.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33479,1235959425,2023-06-20T22:25:52Z,src/core/ext/filters/client_channel/retry_filter.h,"@@ -19,12 +19,98 @@  #include <grpc/support/port_platform.h> +#include <limits.h>+#include <stddef.h>++#include <new>++#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/client_channel.h""+#include ""src/core/ext/filters/client_channel/retry_service_config.h""+#include ""src/core/ext/filters/client_channel/retry_throttle.h""+#include ""src/core/lib/channel/channel_args.h"" #include ""src/core/lib/channel/channel_fwd.h"" #include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gpr/useful.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/transport/transport.h""++extern grpc_core::TraceFlag grpc_retry_trace;  namespace grpc_core { -extern const grpc_channel_filter kRetryFilterVtable;+class RetryFilter {+ public:+  static const grpc_channel_filter kVtable;++  static grpc_error_handle Init(grpc_channel_element* elem,","I think that if a class exposes a bunch of state, a reviewer can reasonably assume that it was intentional, and they may not realize that it's not a good idea to use that state externally.  I think it's a more obvious red flag if a PR is changing a class to expose state that was not previously exposed.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33479,1235963018,2023-06-20T22:31:23Z,src/core/ext/filters/client_channel/retry_filter.h,"@@ -19,12 +19,98 @@  #include <grpc/support/port_platform.h> +#include <limits.h>+#include <stddef.h>++#include <new>++#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/client_channel.h""+#include ""src/core/ext/filters/client_channel/retry_service_config.h""+#include ""src/core/ext/filters/client_channel/retry_throttle.h""+#include ""src/core/lib/channel/channel_args.h"" #include ""src/core/lib/channel/channel_fwd.h"" #include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/channel/context.h""+#include ""src/core/lib/debug/trace.h""+#include ""src/core/lib/gpr/useful.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/transport/transport.h""++extern grpc_core::TraceFlag grpc_retry_trace;  namespace grpc_core { -extern const grpc_channel_filter kRetryFilterVtable;+class RetryFilter {+ public:+  static const grpc_channel_filter kVtable;++  static grpc_error_handle Init(grpc_channel_element* elem,","So my thinking is maybe a comment `TODO(xxx): these methods public to support the transition from filter stack -> promises, cleanup after`, coupled with the large amount of work that's required to go dig the retry filter out of a channel stack to call it (that loop should always be a red flag) probably solves this?",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33459,1235998183,2023-06-20T23:22:15Z,include/grpc/event_engine/event_engine.h,"@@ -363,37 +368,26 @@ class EventEngine : public std::enable_shared_from_this<EventEngine> {     /// \a default_port may be a non-numeric named service port, and will only     /// be used if \a address does not already contain a port component.     ///-    /// When the lookup is complete, the \a on_resolve callback will be invoked-    /// with a status indicating the success or failure of the lookup.-    /// Implementations should pass the appropriate statuses to the callback.-    /// For example, callbacks might expect to receive DEADLINE_EXCEEDED or+    /// When the lookup is complete or cancelled, the \a on_resolve callback","I'm on the fence on this. Since we don't have an explicit Cancel API now, adding the note here seems a bit out of context. I added the following note to the DNSResolver class declaration:```  /// Note: in the gRPC implementation, cancellation (through destruction) is  /// ""best effort"" as if the request has completed during the cancellation, the  /// result might still be reported through its callback.```PTAL. Thanks!",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33502,1237193416,2023-06-21T15:24:36Z,src/core/lib/iomgr/error.cc,"@@ -70,12 +70,42 @@ absl::Status grpc_os_error(const grpc_core::DebugLocation& location, int err, }  #ifdef GPR_WINDOWS+std::string WSAErrorToShortDescription(int err) {",Does Windows not provide a function that does this already?  I would have expected that it would.  Posix has had `strerror()` for a long time.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33502,1237259552,2023-06-21T16:12:46Z,src/core/lib/iomgr/error.cc,"@@ -70,12 +70,42 @@ absl::Status grpc_os_error(const grpc_core::DebugLocation& location, int err, }  #ifdef GPR_WINDOWS+std::string WSAErrorToShortDescription(int err) {","We use `FormatMessage` in `gpr_format_message`, but it produces longer messages. For example, for the `WSAECONNRESET` error, FormatMessage produces ""An existing connection was forcibly closed by the remote host"", but for a top-level Status summary (which becomes the error strings that clients receive), something like ""Connection reset"" will do. The short version seems friendlier.Here is an example error:> D0620 18:33:23.211000000 15608 src/core/ext/transport/chttp2/transport/chttp2_transport.cc:2198] MARK_STREAM_CLOSED: t=000001946F442850 s=000001946F441290(id=1) read+write [UNKNOWN:Endpoint read failed {occurred_during_write:0, created_time:""2023-06-21T01:33:23.210383893+00:00"", file_line:2534, file:""src/core/ext/transport/chttp2/transport/chttp2_transport.cc"", children:[UNAVAILABLE:Connection Reset {file:""src/core/lib/iomgr/tcp_windows.cc"", file_line:189, created_time:""2023-06-21T01:33:23.2102455+00:00"", wsa_error:10054, grpc_status:14, os_error:""An existing connection was forcibly closed by the remote host.\r\n"", syscall:""IOCP/Socket""}]}]This propagates to the surface as an error with status `GRPC_STATUS_UNAVAILABLE` and message ""Connection Reset"".Edit: adding linebreaks in the example for readabilityEdit: Replaced the Cancel pings log with a ""mark stream closed"" log, which is actually what propagates up.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33334,1237694358,2023-06-21T21:03:35Z,test/core/experiments/BUILD,"@@ -0,0 +1,57 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++load(""//bazel:grpc_build_system.bzl"", ""grpc_cc_test"", ""grpc_cc_library"")++grpc_cc_library(+    name = ""test_experiments_lib"",+    srcs = [+        ""test_experiments.cc"",+        ""//src/core:lib/experiments/config.cc"",+    ],+    hdrs = [+        ""test_experiments.h"",+        ""//src/core:lib/experiments/config.h"",+    ],+    defines = select({+        ""//:grpc_experiments_are_final"": [+            ""GRPC_EXPERIMENTS_ARE_FINAL"",+            ""GRPC_EXPERIMENTS_TEST_FIXTURE""","nit: since this define is present in all configuration, you can do:```    defines = [""GRPC_EXPERIMENTS_TEST_FIXTURE""] + select({        ""//:grpc_experiments_are_final"": [""GRPC_EXPERIMENTS_ARE_FINAL"",],        ""//conditions:default"": [],    })```",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33334,1237703400,2023-06-21T21:11:51Z,tools/codegen/core/gen_experiments.py,"@@ -57,6 +57,25 @@ }  +def _UnionExperimentAttrs(used_experiment_attrs, test_experiment_attrs):",This appears to be unused.,X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33334,1237721841,2023-06-21T21:24:28Z,tools/codegen/core/gen_experiments.py,"@@ -85,19 +104,38 @@ def ParseCommandLineArguments(args):         help=""If specified, disables generation of experiments source files"",     )     flag_parser.add_argument(-        ""--disable_gen_bzl"",-        action=""store_true"",-        help=""If specified, disables generation of experiments.bzl file"",+        '--gen_only_test',+        action='store_true',+        help='If specified, only generates experiments test files',+    )+    flag_parser.add_argument(+        '--disable_gen_bzl',","Is this used internally? It appears unused otherwise - it's never set, anyway, though I suppose a manual run could use it. I'm not sure why I'd want to.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1237827910,2023-06-21T23:42:32Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1037 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include <iterator>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;",This is done in the new implementation. I still need to port the equivalent of `probe_ipv6_once` in `iomgr/socket_windows.cc` to event_engine (I shouldn't use the one in iomgr): https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/socket_windows.cc#L215-L233I will do that when implementing the Windows EE DNSResolver next.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33334,1237838406,2023-06-22T00:03:48Z,src/core/lib/experiments/config.cc,"@@ -31,7 +31,11 @@ #include <grpc/support/log.h>  #include ""src/core/lib/config/config_vars.h""+#ifndef GRPC_EXPERIMENTS_TEST_FIXTURE #include ""src/core/lib/experiments/experiments.h""+#else+#include ""test/core/experiments/test_experiments.h""","I don't think this is the right solution, `#include`ing a singular, fixed test file in production code. What we need here is a way to inject configuration into the configuration parser ... some way to separate the loading of config data, from config processing & accessing.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1238008966,2023-06-22T05:27:01Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1037 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include <iterator>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++absl::Status AresStatusToAbslStatus(int status, const std::string& error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::Status(absl::StatusCode::kCancelled, error_msg);+    case ARES_ENOTIMP:+      return absl::Status(absl::StatusCode::kUnimplemented, error_msg);+    case ARES_ENOTFOUND:+      return absl::Status(absl::StatusCode::kNotFound, error_msg);+    default:+      return absl::Status(absl::StatusCode::kUnknown, error_msg);+  }+}++}  // namespace++GrpcAresRequest::~GrpcAresRequest() {+  GPR_ASSERT(fd_node_list_.empty());+  if (initialized_) {+    ares_destroy(channel_);+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu());+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      timeout_(timeout),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(event_engine) {}++void GrpcAresRequest::Work() {+  FdNodeList new_list;+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == std::end(fd_node_list_)) {+          new_list.emplace_back(new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i])));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this, socks[i]);+        } else {+          new_list.splice(new_list.end(), fd_node_list_, iter);+        }+        FdNode* fd_node = new_list.back().get();+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnReadable(fd_node, status);+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_.empty()) {+    FdNode* fd_node = fd_node_list_.front().get();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node_list_.pop_front();+    } else {+      new_list.splice(new_list.end(), fd_node_list_, fd_node_list_.begin());+    }+  }+  fd_node_list_ = std::move(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %zu ms"", this,+                              Milliseconds(timeout));++  query_timeout_handle_ = event_engine_->RunAfter(+      timeout,+      [self = Ref(DEBUG_LOCATION, ""StartTimers"")] { self->OnQueryTimeout(); });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration,+                              [self = Ref(DEBUG_LOCATION, ""StartTimers"")]() {+                                self->OnAresBackupPollAlarm();+                              });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    event_engine_->Cancel(*query_timeout_handle_);+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::StatusOr<std::string> GrpcAresRequest::ParseNameToResolve()+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  std::string port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    return absl::Status(absl::StatusCode::kInvalidArgument,+                        absl::StrCat(""Unparseable name: "", name_));+  }+  return port;+}++absl::Status GrpcAresRequest::InitializeAresOptions(+    absl::string_view dns_server) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  absl::Status error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return absl::Status(absl::StatusCode::kInvalidArgument,+                          absl::StrCat(""Cannot parse authority: "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return AresStatusToAbslStatus(+          status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                               ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  mu().Lock();+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  PrintCurrentStackTrace();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());","Thanks for bringing this up. Is it because our poller (especially epoll1 based poller) is level-triggered so that we need this loop here otherwise we may risk not getting notified again and being stucked?If having this loop here is essential, then I agree that we should fix this potential issue, maybe something like:```fd_set read_fds;fd_set write_fds;FD_SET(fd_node->as, &read_fds);do {  ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);  ares_fds(channel_, &read_fds, &write_fds);} while (FD_ISSET(fd_node->as, &read_fds) && fd_node->polled_fd->IsFdStillReadableLocked());```In this case the fd_set semantic seems to be easier to work with than `ares_getsock`. WDYT?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33334,1238718759,2023-06-22T15:44:26Z,tools/codegen/core/gen_experiments.py,"@@ -85,19 +104,38 @@ def ParseCommandLineArguments(args):         help=""If specified, disables generation of experiments source files"",     )     flag_parser.add_argument(-        ""--disable_gen_bzl"",-        action=""store_true"",-        help=""If specified, disables generation of experiments.bzl file"",+        '--gen_only_test',+        action='store_true',+        help='If specified, only generates experiments test files',+    )+    flag_parser.add_argument(+        '--disable_gen_bzl',+        action='store_true',+        help='If specified, disables generation of experiments.bzl file',     )     return flag_parser.parse_args(args)   args = ParseCommandLineArguments(sys.argv[1:]) -with open(""src/core/lib/experiments/experiments.yaml"") as f:+_EXPERIMENTS_DEFS = ""src/core/lib/experiments/experiments.yaml""+_EXPERIMENTS_ROLLOUTS = ""src/core/lib/experiments/rollouts.yaml""+_EXPERIMENTS_HDR_FILE = ""src/core/lib/experiments/experiments.h""+_EXPERIMENTS_SRC_FILE = ""src/core/lib/experiments/experiments.cc""++if args.gen_only_test:+    _EXPERIMENTS_DEFS = ""test/core/experiments/test_experiments.yaml""","Suggest keeping the generated experiment config source code inside `fixtures/` alongside their yaml SoT. That way, the tests are in the main folder, and the configuration under test is grouped together as part of a fixture.",X
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/33430,1238761921,2023-06-22T16:18:16Z,src/core/lib/event_engine/forkable.cc,"@@ -43,6 +44,9 @@ Forkable::~Forkable() { StopManagingForkable(this); }  void RegisterForkHandlers() {   grpc_core::MutexLock lock(g_mu.get());+#ifdef GRPC_ONLY_REGISTER_PTHREAD_ATFORK_WITH_ENV_VAR+  if (!grpc_core::ConfigVars::Get().EnableForkSupport()) return;","> Why is runtime configuration necessary here? Mainly because you want to produce a single binary that can run in both modes?Yes we do ship pre-compiled binaries that need to work with and without fork support.But essentially, enabling fork support in gRPC/Ruby constitutes a breaking change. So it needs to use some explicit opt-in (I'm using the environment variable for that here).Reason it's a breaking change is because, today, before this PR, people can spawn child processes from gRPC/Ruby processes without issue (i.e. fork-with-immediate-exec poses no problems with gRPC/Ruby today).But as soon as we register C-core's `pthread_atfork` handlers, we can no longer spawn such child processes without calling `GRPC.prefork` before and `GRPC.postfork_parent` afterwards (the ruby API: `GRPC.prefork` is needed to shutdown gRPC/Ruby background threads, which would otherwise prevent C-core's `pthread_atfork` handlers from working properly, because there's otherwise a possibility that the ruby background threads could still be calling into C-core at the time of fork).Correct me if I'm wrong @gnossen, but my understanding from our chat so far was that python needs the `pthread_atfork` handlers to always be registered, because python users can expect to be able to fork-without-exec *without specifying an env var*, i.e. if we guarded this by an env var then we could break python users.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/32701,1238834864,2023-06-22T17:30:08Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1037 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include <iterator>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++absl::Status AresStatusToAbslStatus(int status, const std::string& error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::Status(absl::StatusCode::kCancelled, error_msg);+    case ARES_ENOTIMP:+      return absl::Status(absl::StatusCode::kUnimplemented, error_msg);+    case ARES_ENOTFOUND:+      return absl::Status(absl::StatusCode::kNotFound, error_msg);+    default:+      return absl::Status(absl::StatusCode::kUnknown, error_msg);+  }+}++}  // namespace++GrpcAresRequest::~GrpcAresRequest() {+  GPR_ASSERT(fd_node_list_.empty());+  if (initialized_) {+    ares_destroy(channel_);+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu());+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      timeout_(timeout),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(event_engine) {}++void GrpcAresRequest::Work() {+  FdNodeList new_list;+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == std::end(fd_node_list_)) {+          new_list.emplace_back(new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i])));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this, socks[i]);+        } else {+          new_list.splice(new_list.end(), fd_node_list_, iter);+        }+        FdNode* fd_node = new_list.back().get();+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnReadable(fd_node, status);+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_.empty()) {+    FdNode* fd_node = fd_node_list_.front().get();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node_list_.pop_front();+    } else {+      new_list.splice(new_list.end(), fd_node_list_, fd_node_list_.begin());+    }+  }+  fd_node_list_ = std::move(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %zu ms"", this,+                              Milliseconds(timeout));++  query_timeout_handle_ = event_engine_->RunAfter(+      timeout,+      [self = Ref(DEBUG_LOCATION, ""StartTimers"")] { self->OnQueryTimeout(); });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration,+                              [self = Ref(DEBUG_LOCATION, ""StartTimers"")]() {+                                self->OnAresBackupPollAlarm();+                              });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    event_engine_->Cancel(*query_timeout_handle_);+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::StatusOr<std::string> GrpcAresRequest::ParseNameToResolve()+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  std::string port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    return absl::Status(absl::StatusCode::kInvalidArgument,+                        absl::StrCat(""Unparseable name: "", name_));+  }+  return port;+}++absl::Status GrpcAresRequest::InitializeAresOptions(+    absl::string_view dns_server) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  absl::Status error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return absl::Status(absl::StatusCode::kInvalidArgument,+                          absl::StrCat(""Cannot parse authority: "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return AresStatusToAbslStatus(+          status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                               ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  mu().Lock();+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  PrintCurrentStackTrace();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());","Yes, but the loop is needed because otherwise *edge*-triggered pollers won't notice if there are still un-read bytes following `ares_process_fd`.The `ares_fds` approach looks promising. I think we need to use the `big_fd_set` types that c-ares exposes, for that, though?",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1238870313,2023-06-22T18:06:10Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1037 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include <iterator>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++absl::Status AresStatusToAbslStatus(int status, const std::string& error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::Status(absl::StatusCode::kCancelled, error_msg);+    case ARES_ENOTIMP:+      return absl::Status(absl::StatusCode::kUnimplemented, error_msg);+    case ARES_ENOTFOUND:+      return absl::Status(absl::StatusCode::kNotFound, error_msg);+    default:+      return absl::Status(absl::StatusCode::kUnknown, error_msg);+  }+}++}  // namespace++GrpcAresRequest::~GrpcAresRequest() {+  GPR_ASSERT(fd_node_list_.empty());+  if (initialized_) {+    ares_destroy(channel_);+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu());+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      timeout_(timeout),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(event_engine) {}++void GrpcAresRequest::Work() {+  FdNodeList new_list;+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == std::end(fd_node_list_)) {+          new_list.emplace_back(new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i])));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this, socks[i]);+        } else {+          new_list.splice(new_list.end(), fd_node_list_, iter);+        }+        FdNode* fd_node = new_list.back().get();+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnReadable(fd_node, status);+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_.empty()) {+    FdNode* fd_node = fd_node_list_.front().get();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node_list_.pop_front();+    } else {+      new_list.splice(new_list.end(), fd_node_list_, fd_node_list_.begin());+    }+  }+  fd_node_list_ = std::move(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %zu ms"", this,+                              Milliseconds(timeout));++  query_timeout_handle_ = event_engine_->RunAfter(+      timeout,+      [self = Ref(DEBUG_LOCATION, ""StartTimers"")] { self->OnQueryTimeout(); });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration,+                              [self = Ref(DEBUG_LOCATION, ""StartTimers"")]() {+                                self->OnAresBackupPollAlarm();+                              });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    event_engine_->Cancel(*query_timeout_handle_);+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::StatusOr<std::string> GrpcAresRequest::ParseNameToResolve()+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  std::string port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    return absl::Status(absl::StatusCode::kInvalidArgument,+                        absl::StrCat(""Unparseable name: "", name_));+  }+  return port;+}++absl::Status GrpcAresRequest::InitializeAresOptions(+    absl::string_view dns_server) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  absl::Status error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return absl::Status(absl::StatusCode::kInvalidArgument,+                          absl::StrCat(""Cannot parse authority: "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return AresStatusToAbslStatus(+          status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                               ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  mu().Lock();+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  PrintCurrentStackTrace();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());","Oh sorry, ours use edge-triggered. I got mixed-up with the term. Yes, it seems like we need to use `big_fd_set` and include <selectbridge.h>.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1238902444,2023-06-22T18:39:34Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -0,0 +1,1037 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/grpc_ares_wrapper.h""++#include <iterator>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include <address_sorting/address_sorting.h>++#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/nameser.h""  // IWYU pragma: keep+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/examine_stack.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/gprpp/status_helper.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_wrapper_address_sorting(+    false, ""ares_wrapper_address_sorting"");++grpc_core::TraceFlag grpc_trace_ares_wrapper_stacktrace(+    false, ""ares_wrapper_stacktrace"");++void PrintCurrentStackTrace() {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper_stacktrace)) {+    absl::optional<std::string> stacktrace = grpc_core::GetCurrentStackTrace();+    if (stacktrace.has_value()) {+      gpr_log(GPR_DEBUG, ""%s"", stacktrace->c_str());+    } else {+      gpr_log(GPR_DEBUG, ""stacktrace unavailable"");+    }+  }+}++grpc_core::TraceFlag grpc_trace_ares_wrapper(false,+                                             ""event_engine_ares_wrapper"");++namespace {++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return false;+#else+#error ""Unsupported platform""+#endif+}++struct HostbynameArg {+  GrpcAresHostnameRequest* request;+  const char* qtype;+};++absl::Status AresStatusToAbslStatus(int status, const std::string& error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::Status(absl::StatusCode::kCancelled, error_msg);+    case ARES_ENOTIMP:+      return absl::Status(absl::StatusCode::kUnimplemented, error_msg);+    case ARES_ENOTFOUND:+      return absl::Status(absl::StatusCode::kNotFound, error_msg);+    default:+      return absl::Status(absl::StatusCode::kUnknown, error_msg);+  }+}++}  // namespace++GrpcAresRequest::~GrpcAresRequest() {+  GPR_ASSERT(fd_node_list_.empty());+  if (initialized_) {+    ares_destroy(channel_);+  }+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);+}++bool GrpcAresRequest::Cancel() {+  grpc_core::MutexLock lock(&mu());+  if (std::exchange(shutting_down_, true)) {+    // Already shutting down, maybe resolved, cancelled or timed-out.+    return false;+  }+  cancelled_ = true;+  CancelTimers();+  ShutdownPolledFdsLocked(grpc_core::StatusCreate(+      absl::StatusCode::kCancelled, ""Cancel"", DEBUG_LOCATION, {}));+  return true;+}++GrpcAresRequest::GrpcAresRequest(+    absl::string_view name, EventEngine::Duration timeout,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    EventEngine* event_engine)+    : grpc_core::InternallyRefCounted<GrpcAresRequest>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_wrapper) ? ""GrpcAresRequest""+                                                           : nullptr),+      name_(name),+      timeout_(timeout),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(event_engine) {}++void GrpcAresRequest::Work() {+  FdNodeList new_list;+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == std::end(fd_node_list_)) {+          new_list.emplace_back(new FdNode(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i])));+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p new fd: %d"", this, socks[i]);+        } else {+          new_list.splice(new_list.end(), fd_node_list_, iter);+        }+        FdNode* fd_node = new_list.back().get();+        // Register read_closure if the socket is readable and read_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                      fd_node->as);+          fd_node->readable_registered = true;+          fd_node->polled_fd->RegisterForOnReadableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnReadable(fd_node, status);+              });+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                      fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""Work""),+               fd_node](absl::Status status) mutable {+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_.empty()) {+    FdNode* fd_node = fd_node_list_.front().get();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                  fd_node->polled_fd->GetName());+      fd_node_list_.pop_front();+    } else {+      new_list.splice(new_list.end(), fd_node_list_, fd_node_list_.begin());+    }+  }+  fd_node_list_ = std::move(new_list);+}++void GrpcAresRequest::StartTimers() {+  // Initialize overall DNS resolution timeout alarm+  EventEngine::Duration timeout =+      timeout_.count() == 0 ? EventEngine::Duration::max() : timeout_;+  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p StartTimers timeout in %zu ms"", this,+                              Milliseconds(timeout));++  query_timeout_handle_ = event_engine_->RunAfter(+      timeout,+      [self = Ref(DEBUG_LOCATION, ""StartTimers"")] { self->OnQueryTimeout(); });++  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_WRAPPER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ =+      event_engine_->RunAfter(next_ares_backup_poll_alarm_duration,+                              [self = Ref(DEBUG_LOCATION, ""StartTimers"")]() {+                                self->OnAresBackupPollAlarm();+                              });+}++void GrpcAresRequest::CancelTimers() {+  if (query_timeout_handle_.has_value()) {+    event_engine_->Cancel(*query_timeout_handle_);+    query_timeout_handle_.reset();+  }+  if (ares_backup_poll_alarm_handle_.has_value()) {+    event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+    ares_backup_poll_alarm_handle_.reset();+  }+}++absl::StatusOr<std::string> GrpcAresRequest::ParseNameToResolve()+    ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  std::string port;+  // parse name, splitting it into host and port parts+  grpc_core::SplitHostPort(name_, &host_, &port);+  absl::Status error;+  if (host_.empty()) {+    return absl::Status(absl::StatusCode::kInvalidArgument,+                        absl::StrCat(""Unparseable name: "", name_));+  }+  return port;+}++absl::Status GrpcAresRequest::InitializeAresOptions(+    absl::string_view dns_server) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  GPR_DEBUG_ASSERT(!initialized_);+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  int status = ares_init_options(&channel_, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel_);+  // If dns_server is specified, use it.+  absl::Status error = SetRequestDNSServer(dns_server);+  if (!error.ok()) {+    ares_destroy(channel_);+    return error;+  }+  initialized_ = true;+  return absl::OkStatus();+}++absl::Status GrpcAresRequest::SetRequestDNSServer(+    absl::string_view dns_server) {+  if (!dns_server.empty()) {+    GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p Using DNS server %s"", this,+                                dns_server.data());+    grpc_resolved_address addr;+    struct ares_addr_port_node dns_server_addr;+    if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET;+      struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr4, &in->sin_addr,+             sizeof(struct in_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                        /*log_errors=*/false)) {+      dns_server_addr.family = AF_INET6;+      struct sockaddr_in6* in6 =+          reinterpret_cast<struct sockaddr_in6*>(addr.addr);+      memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+             sizeof(struct in6_addr));+      dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+      dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+    } else {+      return absl::Status(absl::StatusCode::kInvalidArgument,+                          absl::StrCat(""Cannot parse authority: "", dns_server));+    }+    // Prevent an uninitialized variable.+    dns_server_addr.next = nullptr;+    int status = ares_set_servers_ports(channel_, &dns_server_addr);+    if (status != ARES_SUCCESS) {+      return AresStatusToAbslStatus(+          status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                               ares_strerror(status)));+    }+  }+  return absl::OkStatus();+}++void GrpcAresRequest::OnReadable(FdNode* fd_node, absl::Status status) {+  mu().Lock();+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_WRAPPER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                              fd_node->as, this, status.ToString().c_str());+  PrintCurrentStackTrace();+  if (status.ok() && !shutting_down_) {+    do {+      ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+    } while (fd_node->polled_fd->IsFdStillReadableLocked());+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  Work();","In the new implementation, this part is simplified and the code after `Work` is no longer needed. The user callback is already triggered in the respective ares_callback.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1238917200,2023-06-22T18:55:10Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -589,166 +443,247 @@ void GrpcAresRequest::OnAresBackupPollAlarm() {           calculate_next_ares_backup_poll_alarm_duration();       ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(           next_ares_backup_poll_alarm_duration,-          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() mutable {-            grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;-            grpc_core::ExecCtx exec_ctx;+          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() {             self->OnAresBackupPollAlarm();           });     }     Work();+    if (shutting_down_) {+      OnResolveLockedAndUnlock();+      return;+    }   }+  mu().Unlock(); } -// TODO(yijiem): Consider report this status or as part of the result when-// calling on_resolve_. This status is received in OnReadable/OnWritable. void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {-  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {-    if (!(*it)->already_shutdown) {+  for (const auto& fd_node : fd_node_list_) {+    if (!fd_node->already_shutdown) {       GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,-                                  (*it)->polled_fd->GetName());-      (*it)->polled_fd->ShutdownLocked(status);-      (*it)->already_shutdown = true;+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(status);+      fd_node->already_shutdown = true;     }   } } -GrpcAresHostnameRequest::GrpcAresHostnameRequest(+absl::StatusOr<GrpcAresHostnameRequest*> GrpcAresHostnameRequest::Create(     absl::string_view name, absl::string_view default_port,-    EventEngine::Duration timeout,+    absl::string_view dns_server, EventEngine::Duration timeout,     std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,-    EventEngine* event_engine)-    : GrpcAresRequest(name, timeout, std::move(polled_fd_factory),-                      event_engine),-      default_port_(default_port) {}--GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {-  // Destruction of on_resolve_ may trigger a chain of destruction that may-  // require ExecCtx in the current thread.-  grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;-  grpc_core::ExecCtx exec_ctx;-  { auto c = std::move(on_resolve_); }-  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);-}--void GrpcAresHostnameRequest::Start(-    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {-  // Holds a ref across this function since OnResolve might be called inline-  // inside ares_gethostbyname and we might be done in that case. This ref needs-  // to be taken outside of the lock to prevent UAF during unlock if the-  // destruction of the ref triggers the destruction of the request itself.-  auto self = Ref(DEBUG_LOCATION, ""Start"");-  grpc_core::MutexLock lock(&mu_);-  GPR_ASSERT(initialized_);-  on_resolve_ = std::move(on_resolve);-  GRPC_ARES_WRAPPER_TRACE_LOG(-      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""-      ""default_port=%s"",-      this, name_.c_str(), default_port_.c_str());-  // Early out if the target is an ipv4 or ipv6 literal.-  if (ResolveAsIPLiteralLocked()) {-    return;-  }-  // TODO(yijiem): Early out if the target is localhost and we're on Windows.--  // We add up pending_queries_ here since ares_gethostbyname may directly-  // invoke the callback inline e.g. if there is any error with the input. The-  // callback will invoke OnResolve with an error status and may start the-  // shutdown process too early (before the second ares_gethostbyname) if we-  // haven't added up here.-  ++pending_queries_;+    EventEngine* event_engine) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  auto* request = new GrpcAresHostnameRequest(+      name, default_port, timeout, std::move(polled_fd_factory), event_engine);+  absl::StatusOr<std::string> result = request->ParseNameToResolve();","In the new implementation, this part is exactly what you are purposing. We don't need to save `name_` or `default_port_` as data member (though we do save `name` and `port` through QueryArg for constructing the `ResolvedAddress` and for logging purpose). The parsing happens in the `AresResolver::LookupHostname` method:```void AresResolver::LookupHostname(    absl::string_view name, absl::string_view default_port,    EventEngine::DNSResolver::LookupHostnameCallback callback) {  absl::string_view host;  absl::string_view port_s;  if (!grpc_core::SplitHostPort(name, &host, &port_s)) {    event_engine_->Run(        [callback = std::move(callback),         status = absl::InvalidArgumentError(absl::StrCat(             ""Unparseable name: "", name))]() mutable { callback(status); });    return;  }  GPR_ASSERT(!host.empty());  if (port_s.empty()) {    if (default_port.empty()) {      event_engine_->Run([callback = std::move(callback),                          status = absl::InvalidArgumentError(absl::StrFormat(                              ""No port in name %s or default_port argument"",                              name.data()))]() mutable { callback(status); });      return;    }    port_s = default_port;  }  int port = 0;  if (port_s == ""http"") {    port = 80;  } else if (port_s == ""https"") {    port = 443;  } else if (!absl::SimpleAtoi(port_s, &port)) {    event_engine_->Run([callback = std::move(callback),                        status = absl::InvalidArgumentError(absl::StrCat(                            ""Failed to parse port in name: "",                            name))]() mutable { callback(status); });    return;  }  // TODO(yijiem): Change this when refactoring code in  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.  grpc_resolved_address addr;  const std::string hostport = grpc_core::JoinHostPort(host, port);  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,                               false /* log errors */) ||      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,                               false /* log errors */)) {    // Early out if the target is an ipv4 or ipv6 literal.    std::vector<EventEngine::ResolvedAddress> result;    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);    event_engine_->Run(        [callback = std::move(callback), result = std::move(result)]() mutable {          callback(std::move(result));        });    return;  }  grpc_core::MutexLock lock(&mutex_);  callback_map_.emplace(++id_, std::move(callback));  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);  if (IsIpv6LoopbackAvailable()) {    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,                       &AresResolver::OnHostbynameDoneLocked,                       static_cast<void*>(resolver_arg));  } else {    ares_gethostbyname(channel_, std::string(host).c_str(), AF_INET,                       &AresResolver::OnHostbynameDoneLocked,                       static_cast<void*>(resolver_arg));  }  CheckSocketsLocked();  MaybeStartTimerLocked();}```",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1238929601,2023-06-22T19:09:58Z,src/core/lib/event_engine/grpc_ares_wrapper.cc,"@@ -589,166 +443,247 @@ void GrpcAresRequest::OnAresBackupPollAlarm() {           calculate_next_ares_backup_poll_alarm_duration();       ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(           next_ares_backup_poll_alarm_duration,-          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() mutable {-            grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;-            grpc_core::ExecCtx exec_ctx;+          [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() {             self->OnAresBackupPollAlarm();           });     }     Work();+    if (shutting_down_) {+      OnResolveLockedAndUnlock();+      return;+    }   }+  mu().Unlock(); } -// TODO(yijiem): Consider report this status or as part of the result when-// calling on_resolve_. This status is received in OnReadable/OnWritable. void GrpcAresRequest::ShutdownPolledFdsLocked(absl::Status status) {-  for (auto it = fd_node_list_->begin(); it != fd_node_list_->end(); it++) {-    if (!(*it)->already_shutdown) {+  for (const auto& fd_node : fd_node_list_) {+    if (!fd_node->already_shutdown) {       GRPC_ARES_WRAPPER_TRACE_LOG(""request: %p shutdown fd: %s"", this,-                                  (*it)->polled_fd->GetName());-      (*it)->polled_fd->ShutdownLocked(status);-      (*it)->already_shutdown = true;+                                  fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(status);+      fd_node->already_shutdown = true;     }   } } -GrpcAresHostnameRequest::GrpcAresHostnameRequest(+absl::StatusOr<GrpcAresHostnameRequest*> GrpcAresHostnameRequest::Create(     absl::string_view name, absl::string_view default_port,-    EventEngine::Duration timeout,+    absl::string_view dns_server, EventEngine::Duration timeout,     std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,-    EventEngine* event_engine)-    : GrpcAresRequest(name, timeout, std::move(polled_fd_factory),-                      event_engine),-      default_port_(default_port) {}--GrpcAresHostnameRequest::~GrpcAresHostnameRequest() {-  // Destruction of on_resolve_ may trigger a chain of destruction that may-  // require ExecCtx in the current thread.-  grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;-  grpc_core::ExecCtx exec_ctx;-  { auto c = std::move(on_resolve_); }-  GRPC_ARES_WRAPPER_TRACE_LOG(""request:%p destructor"", this);-}--void GrpcAresHostnameRequest::Start(-    absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve) {-  // Holds a ref across this function since OnResolve might be called inline-  // inside ares_gethostbyname and we might be done in that case. This ref needs-  // to be taken outside of the lock to prevent UAF during unlock if the-  // destruction of the ref triggers the destruction of the request itself.-  auto self = Ref(DEBUG_LOCATION, ""Start"");-  grpc_core::MutexLock lock(&mu_);-  GPR_ASSERT(initialized_);-  on_resolve_ = std::move(on_resolve);-  GRPC_ARES_WRAPPER_TRACE_LOG(-      ""request:%p c-ares GrpcAresHostnameRequest::Start name=%s, ""-      ""default_port=%s"",-      this, name_.c_str(), default_port_.c_str());-  // Early out if the target is an ipv4 or ipv6 literal.-  if (ResolveAsIPLiteralLocked()) {-    return;-  }-  // TODO(yijiem): Early out if the target is localhost and we're on Windows.--  // We add up pending_queries_ here since ares_gethostbyname may directly-  // invoke the callback inline e.g. if there is any error with the input. The-  // callback will invoke OnResolve with an error status and may start the-  // shutdown process too early (before the second ares_gethostbyname) if we-  // haven't added up here.-  ++pending_queries_;+    EventEngine* event_engine) ABSL_NO_THREAD_SAFETY_ANALYSIS {+  auto* request = new GrpcAresHostnameRequest(","In the new implementation, this part is no longer needed. (responding ahead of time since the next update will make this comment outdated)",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1238959130,2023-06-22T19:45:29Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -121,95 +141,64 @@ class GrpcAresRequest   // close the socket (possibly through ares_destroy).   struct FdNode {     FdNode() = default;-    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd);+    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)+        : as(as), polled_fd(polled_fd) {}     ares_socket_t as;     std::unique_ptr<GrpcPolledFd> polled_fd;-    // next fd node-    FdNode* next = nullptr;     // true if the readable closure has been registered     bool readable_registered = false;     // true if the writable closure has been registered     bool writable_registered = false;     bool already_shutdown = false;   };+  using FdNodeList = std::list<std::unique_ptr<FdNode>>; -  // A linked-list of FdNodes. Support operations such as pop a FdNode which has-  // a specific socket/fd that c-ares owns.-  class FdNodeList {-   public:-    class FdNodeListIterator {-     public:-      bool operator!=(const FdNodeListIterator& other) {-        return node_ != other.node_;-      }-      bool operator==(const FdNodeListIterator& other) {-        return node_ == other.node_;-      }-      FdNodeListIterator& operator++(int) {-        node_ = node_->next;-        return *this;-      }-      FdNode* operator*() { return node_; }-      static FdNodeListIterator universal_end() {-        return FdNodeListIterator(nullptr);-      }--     private:-      friend class FdNodeList;-      explicit FdNodeListIterator(FdNode* node) : node_(node) {}-      FdNode* node_;-    };-    using Iterator = FdNodeListIterator;--    ~FdNodeList() { GPR_ASSERT(IsEmpty()); }--    Iterator begin() { return Iterator(head_); }-    Iterator end() { return Iterator::universal_end(); }--    bool IsEmpty() const { return head_ == nullptr; }--    void PushFdNode(FdNode* fd_node) ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_) {-      fd_node->next = head_;-      head_ = fd_node;-    }--    FdNode* PopFdNode() ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_) {-      GPR_ASSERT(!IsEmpty());-      FdNode* ret = head_;-      head_ = head_->next;-      return ret;-    }--    // Search for as in the FdNode list. This is an O(n) search, the max-    // possible value of n is ARES_GETSOCK_MAXNUM (16). n is typically 1 - 2-    // in our tests.-    FdNode* PopFdNode(ares_socket_t as) ABSL_EXCLUSIVE_LOCKS_REQUIRED(&mu_);--   private:-    FdNode* head_ = nullptr;-  };   friend class GrpcPolledFdFactory; +  // Requires mu_ to be locked before calling.+  // Unlock mu_ before returns.+  //+  // Ideally this could take a lock object by reference or something like a+  // std::unique_ptr<grpc_core::ReleasableMutexLock>. But Thread Safety Analysis+  // does not work in these scenarios, see for example:+  // https://github.com/llvm/llvm-project/issues/59662.+  virtual void OnResolveLockedAndUnlock() ABSL_UNLOCK_FUNCTION(mu()) = 0;+   absl::Status SetRequestDNSServer(absl::string_view dns_server)-      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());   void OnReadable(FdNode* fd_node, absl::Status status)-      ABSL_LOCKS_EXCLUDED(mu_);+      ABSL_LOCKS_EXCLUDED(mu());   void OnWritable(FdNode* fd_node, absl::Status status)-      ABSL_LOCKS_EXCLUDED(mu_);-  void OnHandleDestroyed(FdNode* fd_node, absl::Status status)-      ABSL_LOCKS_EXCLUDED(mu_);-  void OnQueryTimeout() ABSL_LOCKS_EXCLUDED(mu_);-  void OnAresBackupPollAlarm() ABSL_LOCKS_EXCLUDED(mu_);+      ABSL_LOCKS_EXCLUDED(mu());+  void OnQueryTimeout() ABSL_LOCKS_EXCLUDED(mu());+  void OnAresBackupPollAlarm() ABSL_LOCKS_EXCLUDED(mu());   void ShutdownPolledFdsLocked(absl::Status status)-      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu()); -  const EventEngine::Duration timeout_ ABSL_GUARDED_BY(mu_);-  std::unique_ptr<FdNodeList> fd_node_list_ ABSL_GUARDED_BY(mu_);+  mutable grpc_core::Mutex mu_;+  bool initialized_ ABSL_GUARDED_BY(mu()) = false;+  // ares channel+  ares_channel channel_ ABSL_GUARDED_BY(mu()) = nullptr;+  // name to resolve+  const std::string name_ ABSL_GUARDED_BY(mu());",These are not data members anymore. (responding ahead of time since the next push will make this comment outdated),
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1238959617,2023-06-22T19:45:58Z,src/core/lib/event_engine/grpc_ares_wrapper.h,"@@ -242,23 +231,28 @@ class GrpcAresHostnameRequest final : public GrpcAresRequest {       EventEngine* event_engine);   ~GrpcAresHostnameRequest() override; -  bool ResolveAsIPLiteralLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+  void AddError(absl::Status error) override+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());+  void OnResolveLockedAndUnlock() override ABSL_UNLOCK_FUNCTION(mu());++  bool ResolveAsIPLiteralLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());   void LogResolvedAddressesListLocked(absl::string_view input_output_str)-      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);-  void SortResolvedAddressesLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);-  void OnResolveLocked(absl::StatusOr<Result> result)-      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);+      ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());+  void SortResolvedAddressesLocked() ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu());   // This method is deliberately thread-unsafe and should only be called in   // Create as part of initialization.   absl::Status ParsePort(absl::string_view port);    // port, parsed from name_ or default_port_-  int port_ ABSL_GUARDED_BY(mu_) = 0;-  const std::string default_port_ ABSL_GUARDED_BY(mu_);-  size_t pending_queries_ ABSL_GUARDED_BY(mu_) = 0;-  absl::StatusOr<Result> result_ ABSL_GUARDED_BY(mu_);+  int port_ ABSL_GUARDED_BY(mu()) = 0;+  const std::string default_port_ ABSL_GUARDED_BY(mu());+  size_t pending_queries_ ABSL_GUARDED_BY(mu()) = 0;+  absl::StatusOr<Result> result_ ABSL_GUARDED_BY(mu());   absl::AnyInvocable<void(absl::StatusOr<Result>)> on_resolve_-      ABSL_GUARDED_BY(mu_);+      ABSL_GUARDED_BY(mu());+  bool resolved_ ABSL_GUARDED_BY(mu()) = false;++  EventEngine* event_engine_;",No subclass needed anymore. (responding ahead of time since the next push will make this comment outdated),X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1238976084,2023-06-22T20:03:09Z,src/core/lib/event_engine/posix_engine/posix_engine.h,"@@ -138,6 +138,11 @@ class PosixEventEngine final : public PosixEventEngineWithFdSupport,  public:   class PosixDNSResolver : public EventEngine::DNSResolver {    public:+#if GRPC_ARES == 1 && defined(GRPC_POSIX_SOCKET_TCP)+    PosixDNSResolver(const ResolverOptions& options,+                     PosixEnginePollerManager* poller_manager,+                     std::shared_ptr<EventEngine> event_engine);+#endif  // GRPC_ARES == 1 && defined(GRPC_POSIX_SOCKET_TCP)     ~PosixDNSResolver() override;     LookupTaskHandle LookupHostname(LookupHostnameCallback on_resolve,","Hmmm, looks like we use `on_resolve` in the event_engine API: https://github.com/grpc/grpc/blob/master/include/grpc/event_engine/event_engine.h#L369I would prefer to keep it consistent, if we decide to change here, we should also change the naming in `event_engine.h`.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33430,1240368166,2023-06-23T20:42:56Z,src/core/lib/event_engine/forkable.cc,"@@ -43,6 +44,9 @@ Forkable::~Forkable() { StopManagingForkable(this); }  void RegisterForkHandlers() {   grpc_core::MutexLock lock(g_mu.get());+#ifdef GRPC_ONLY_REGISTER_PTHREAD_ATFORK_WITH_ENV_VAR+  if (!grpc_core::ConfigVars::Get().EnableForkSupport()) return;","I think reintroducing an env-var in Forkable is probably the right thing here, presuming both wrapped languages expect most fork operations to be fork+exec. The gRPC Python community already expects to have to use the env var, so it's not a big change. However, I'm not sure the Python build is doing this correctly today. See analysis below.@apolcyn I'm not sure how deeply Ruby can reach into core, but `ConfigVars::SetOverrides` exists if you want to override fork support programatically.----IIUC, non-windows Python builds enable fork support by default in core, so the env var is redundant _in core_ unless you're using it to turn fork support off. https://github.com/grpc/grpc/blob/1bf3f56c9798e8e162ffe1383bcef22580e1defb/setup.py#L459-L462pthread support is then enabled for all linux & darwin systemshttps://github.com/grpc/grpc/blob/1bf3f56c9798e8e162ffe1383bcef22580e1defb/setup.py#L479-L485gRPC Python code, by default, does not engage its own fork handlers unless the env var is present. https://github.com/grpc/grpc/blob/1bf3f56c9798e8e162ffe1383bcef22580e1defb/src/python/grpcio/grpc/_cython/_cygrpc/fork_posix.pyx.pxi#L32-L34@gnossen the question then becomes: what are the scenarios in which you want to disable fork support in Python, while core is still using pthread fork handlers? I believe that is what's happening by default in both iomgr & EventEngine fork support today.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33384,1240473742,2023-06-23T22:40:47Z,src/python/grpcio_observability/grpc_observability/_open_census_exporter.py,"@@ -12,23 +12,293 @@ # See the License for the specific language governing permissions and # limitations under the License. -import logging-from typing import List+from datetime import datetime+import os+from typing import Any, List, Mapping, Optional, Tuple +from google.rpc import code_pb2 from grpc_observability import _observability  # pytype: disable=pyi-error+from grpc_observability import _views+from opencensus.common.transports import async_+from opencensus.ext.stackdriver import stats_exporter+from opencensus.ext.stackdriver import trace_exporter+from opencensus.stats import stats as stats_module+from opencensus.stats.stats_recorder import StatsRecorder+from opencensus.stats.view_manager import ViewManager+from opencensus.tags.tag_key import TagKey+from opencensus.tags.tag_map import TagMap+from opencensus.tags.tag_value import TagValue+from opencensus.trace import execution_context+from opencensus.trace import samplers+from opencensus.trace import span+from opencensus.trace import span_context as span_context_module+from opencensus.trace import span_data as span_data_module+from opencensus.trace import status+from opencensus.trace import time_event+from opencensus.trace import trace_options as trace_options_module+from opencensus.trace import tracer -logger = logging.getLogger(__name__)+_gcp_observability = Any  # grpc_observability.py imports this module.++# 60s is the default time for open census to call export.+CENSUS_UPLOAD_INTERVAL_SECS = int(+    os.environ.get(""GRPC_PYTHON_CENSUS_EXPORT_UPLOAD_INTERVAL_SECS"", 20)+)+++class StackDriverAsyncTransport(async_.AsyncTransport):+    """"""Wrapper class used to pass wait_period.++    This is required because current StackDriver Tracing Exporter doesn't allow+    us pass wait_period to AsyncTransport directly.++    Args:+      exporter: An opencensus.trace.base_exporter.Exporter object.+    """"""++    def __init__(self, exporter):+        super().__init__(exporter, wait_period=CENSUS_UPLOAD_INTERVAL_SECS)   class OpenCensusExporter(_observability.Exporter):+    config: ""_gcp_observability.GcpObservabilityPythonConfig""+    default_labels: Optional[Mapping[str, str]]+    project_id: str+    tracer: Optional[tracer.Tracer]+    stats_recorder: Optional[StatsRecorder]+    view_manager: Optional[ViewManager]++    def __init__(+        self, config: ""_gcp_observability.GcpObservabilityPythonConfig""+    ):+        self.config = config.get()+        self.default_labels = self.config.labels+        self.project_id = self.config.project_id+        self.tracer = None+        self.stats_recorder = None+        self.view_manager = None+        self._setup_open_census_stackdriver_exporter()++    def _setup_open_census_stackdriver_exporter(self) -> None:+        if self.config.stats_enabled:+            stats = stats_module.stats+            self.stats_recorder = stats.stats_recorder+            self.view_manager = stats.view_manager+            # If testing locally please add resource=""global"" to Options, otherwise+            # StackDriver might override project_id based on detected resource.+            options = stats_exporter.Options(project_id=self.project_id)+            metrics_exporter = stats_exporter.new_stats_exporter(+                options, interval=CENSUS_UPLOAD_INTERVAL_SECS+            )+            self.view_manager.register_exporter(metrics_exporter)+            self._register_open_census_views()++        if self.config.tracing_enabled:+            current_tracer = execution_context.get_opencensus_tracer()+            trace_id = current_tracer.span_context.trace_id+            span_id = current_tracer.span_context.span_id+            if not span_id:+                span_id = span_context_module.generate_span_id()+            span_context = span_context_module.SpanContext(+                trace_id=trace_id, span_id=span_id+            )+            # Create and Saves Tracer and Sampler to ContextVar+            sampler = samplers.ProbabilitySampler(+                rate=self.config.sampling_rate+            )+            self.trace_exporter = trace_exporter.StackdriverExporter(+                project_id=self.project_id,+                transport=StackDriverAsyncTransport,+            )+            self.tracer = tracer.Tracer(+                sampler=sampler,+                span_context=span_context,+                exporter=self.trace_exporter,+            )+     def export_stats_data(         self, stats_data: List[_observability.StatsData]     ) -> None:-        # TODO(xuanwn): Add implementation-        raise NotImplementedError()+        if not self.config.stats_enabled:+            return+        for data in stats_data:+            measure = _views.METRICS_NAME_TO_MEASURE.get(data.name, None)+            if not measure:+                continue+            # Create a measurement map for each metric, otherwise metrics will+            # be override instead of accumulate.+            measurement_map = self.stats_recorder.new_measurement_map()+            # Add data label to default labels.+            labels = data.labels+            labels.update(self.default_labels)+            tag_map = TagMap()+            for key, value in labels.items():+                tag_map.insert(TagKey(key), TagValue(value))++            if data.measure_double:+                measurement_map.measure_float_put(measure, data.value_float)+            else:+                measurement_map.measure_int_put(measure, data.value_int)+            measurement_map.record(tag_map)      def export_tracing_data(         self, tracing_data: List[_observability.TracingData]     ) -> None:-        # TODO(xuanwn): Add implementation-        raise NotImplementedError()+        if not self.config.tracing_enabled:+            return+        for span_data in tracing_data:+            # Only traced data will be exported, thus TraceOptions=1.+            span_context = span_context_module.SpanContext(+                trace_id=span_data.trace_id,+                span_id=span_data.span_id,+                trace_options=trace_options_module.TraceOptions(1),+            )+            span_datas = _get_span_datas(","Nit: ""s/datas/data/g"" here and throughout. Data is either a mass noun (e.g. ""some data"") or (less commonly) the plural form of a count noun (e.g ""this datum, these data"")",X
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/33507,1242314293,2023-06-26T14:42:35Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,170 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have","I don't know what the preferred way of saying "".NET Core and .NET"" is these days. Possibly just that. But given that all .NET Core platforms are now out of MS support (IIRC) - I think it would at least be better to drop the Core. Maybe we need an introductory paragraph with terminology - I'd be fine with ""Within this document, references to '.NET Core' are intended to include .NET 6.0+"" or similar.",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/33507,1242317304,2023-06-26T14:44:34Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,170 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.++## Disadvantages of this propsal++There are a few places where adding annotations or attributes to the generated+code to help with the static flow analysis could be useful. These are:+- Checking non-null setters for certain fields in a message at compile time,+ such as fields that are strings. Runtime checks are still done in the+ generated code.+- Checking a non-null message or stream is passed to a gRPC service call.+- Specifying a non-null message or stream is returned from a gRPC service call.++By not supporting nullable reference types in the generated code these compile+time checks cannot be done.++## Outside the scope of this proposal++### Changes to related packages++Changes to `Google.Protobuf` library and other libraries ",Possibly explicitly say that there is a long-standing (slow-moving) effort to enable NRT for Google.Protobuf?,
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/33507,1242318777,2023-06-26T14:45:40Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,170 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.++## Disadvantages of this propsal++There are a few places where adding annotations or attributes to the generated+code to help with the static flow analysis could be useful. These are:+- Checking non-null setters for certain fields in a message at compile time,+ such as fields that are strings. Runtime checks are still done in the+ generated code.+- Checking a non-null message or stream is passed to a gRPC service call.+- Specifying a non-null message or stream is returned from a gRPC service call.++By not supporting nullable reference types in the generated code these compile+time checks cannot be done.++## Outside the scope of this proposal++### Changes to related packages++Changes to `Google.Protobuf` library and other libraries +(such as `Google.Api.CommonProtos`) are outside the scope of this proposal.++### Exposing protocol buffers optional fields as nullable properties++See https://github.com/protocolbuffers/protobuf/issues/9083++This has been rejected by the protocol buffers team.++> ""We get requests in some other languages that have null support to allow +optional fields to have nullable properties. The main problem is that we like to +keep languages consistent and other languages don't have those same options. +Additionally, it's not clear with some primitive fields what a null value would +be (is it the default? What if users meant to set it to that option?). For those +reasons, we will not support this in the near future.++## Alternative options to this proposal++If in the future we want to support nullable reference types in the generated +code then this should be an *opt-in* feature so as to not break existing +projects.++We need to consider:+- Options for enabling this feature+- What code changes need to be made in the generated code++Options for enabling this feature:++- Generate conditional code and the user has to define a constant in the project files to enable it+  - The generated conditional code might be messy+  - Could change `Grpc.Tools` to define the constant if it detects project has nullable enabled++- Generate code that relies on definitions of nullable attributes for older framework versions+  - Like those in https://github.com/grpc/grpc-dotnet/blob/master/src/Shared/NullableAttributes.cs+  - Where would these definitions of nullable attributes be defined?+  Dont want to define them in every generated C# file. Is there a single ","Putting the annotations in any shared library would mean they'd have to be public rather than internal, which then causes issues with potential collisions IME.",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/33340,1242538030,2023-06-26T17:40:11Z,src/core/ext/filters/client_channel/lb_policy/health_check_client.cc,"@@ -351,28 +355,40 @@ void HealthProducer::Orphan() {   subchannel_->RemoveDataProducer(this); } -void HealthProducer::AddWatcher(HealthWatcher* watcher,-                                const std::string& health_check_service_name) {+void HealthProducer::AddWatcher(+    HealthWatcher* watcher,+    const absl::optional<std::string>& health_check_service_name) {   MutexLock lock(&mu_);   grpc_pollset_set_add_pollset_set(interested_parties_,                                    watcher->interested_parties());-  auto it = health_checkers_.emplace(health_check_service_name, nullptr).first;-  auto& health_checker = it->second;-  if (health_checker == nullptr) {-    health_checker = MakeOrphanable<HealthChecker>(WeakRef(), it->first);+  if (!health_check_service_name.has_value()) {+    watcher->Notify(state_, status_);+    non_health_watchers_.insert(watcher);+  } else {+    auto it =+        health_checkers_.emplace(*health_check_service_name, nullptr).first;+    auto& health_checker = it->second;+    if (health_checker == nullptr) {+      health_checker = MakeOrphanable<HealthChecker>(WeakRef(), it->first);+    }+    health_checker->AddWatcherLocked(watcher);   }-  health_checker->AddWatcherLocked(watcher); }  void HealthProducer::RemoveWatcher(-    HealthWatcher* watcher, const std::string& health_check_service_name) {+    HealthWatcher* watcher,+    const absl::optional<std::string>& health_check_service_name) {   MutexLock lock(&mu_);   grpc_pollset_set_del_pollset_set(interested_parties_,                                    watcher->interested_parties());-  auto it = health_checkers_.find(health_check_service_name);-  if (it == health_checkers_.end()) return;-  const bool empty = it->second->RemoveWatcherLocked(watcher);-  if (empty) health_checkers_.erase(it);+  if (!health_check_service_name.has_value()) {+    non_health_watchers_.erase(watcher);+  } else {+    auto it = health_checkers_.find(*health_check_service_name);+    if (it == health_checkers_.end()) return;","I find these several lines confusing, with multiple conditions and temp variable.```suggestion    if (it != health_checkers_.end() && it->second->RemoveWatcherLocked(watcher)) {        health_checkers_.erase(it);    }```",X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/33384,1242547547,2023-06-26T17:48:29Z,src/python/grpcio_observability/grpc_observability/_open_census_exporter.py,"@@ -12,23 +12,275 @@ # See the License for the specific language governing permissions and # limitations under the License. -import logging-from typing import List+from datetime import datetime+import os+from typing import Any, List, Mapping, Optional, Tuple +from google.rpc import code_pb2 from grpc_observability import _observability  # pytype: disable=pyi-error+from grpc_observability import _views+from opencensus.ext.stackdriver import stats_exporter+from opencensus.ext.stackdriver import trace_exporter+from opencensus.stats import stats as stats_module+from opencensus.stats.measurement_map import MeasurementMap+from opencensus.tags.tag_key import TagKey+from opencensus.tags.tag_map import TagMap+from opencensus.tags.tag_value import TagValue+from opencensus.trace import execution_context+from opencensus.trace import samplers+from opencensus.trace import span+from opencensus.trace import span_context as span_context_module+from opencensus.trace import span_data as span_data_module+from opencensus.trace import status+from opencensus.trace import time_event+from opencensus.trace import trace_options as trace_options_module+from opencensus.trace import tracer -logger = logging.getLogger(__name__)+_gcp_observability = Any  # grpc_observability.py imports this module.++# 60s is the default time for open census to call export.","60s is the default value used in [OpenCensus.AsyncTransport](https://github.com/census-instrumentation/opencensus-python/blob/3a2d8dfe1db4e0129dc691c35901a0d12127afc1/opencensus/common/transports/async_.py#L26), this number is the time for StackDriver to export data to GCP (Yes, OpenCensus also have an [internal buffer queue](https://github.com/census-instrumentation/opencensus-python/blob/3a2d8dfe1db4e0129dc691c35901a0d12127afc1/opencensus/common/transports/async_.py#L185)).The time we flush data from core is called [GRPC_PYTHON_CENSUS_EXPORT_THREAD_TIMEOUT](https://github.com/grpc/grpc/blob/master/src/python/grpcio_observability/grpc_observability/_cyobservability.pyx#L30) and current default is `10s`.I do think 10000 make sense, I'll also change both export time to 10s for now.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32692,1242926220,2023-06-26T23:26:55Z,src/core/ext/filters/client_channel/lb_policy/endpoint_list.cc,"@@ -0,0 +1,176 @@+//+// Copyright 2015 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <grpc/support/port_platform.h>++#include ""src/core/ext/filters/client_channel/lb_policy/endpoint_list.h""++#include <stdlib.h>++#include <algorithm>+#include <memory>+#include <utility>+#include <vector>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/impl/connectivity_state.h>+#include <grpc/support/log.h>++#include ""src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/orphanable.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/pollset_set.h""+#include ""src/core/lib/load_balancing/delegating_helper.h""+#include ""src/core/lib/load_balancing/lb_policy.h""+#include ""src/core/lib/load_balancing/lb_policy_registry.h""+#include ""src/core/lib/resolver/server_address.h""++namespace grpc_core {++//+// EndpointList::Endpoint::Helper+//++class EndpointList::Endpoint::Helper+    : public LoadBalancingPolicy::DelegatingChannelControlHelper {+ public:+  explicit Helper(RefCountedPtr<Endpoint> endpoint)+      : endpoint_(std::move(endpoint)) {}++  ~Helper() override { endpoint_.reset(DEBUG_LOCATION, ""Helper""); }++  void UpdateState(+      grpc_connectivity_state state, const absl::Status& status,+      RefCountedPtr<LoadBalancingPolicy::SubchannelPicker> picker) override {+    auto old_state = std::exchange(endpoint_->connectivity_state_, state);+    endpoint_->picker_ = std::move(picker);+    endpoint_->OnStateUpdate(old_state, state, status);+  }++ private:+  LoadBalancingPolicy::ChannelControlHelper* parent_helper() const override {+    return endpoint_->endpoint_list_->channel_control_helper();+  }++  RefCountedPtr<Endpoint> endpoint_;+};++//+// EndpointList::Endpoint+//++void EndpointList::Endpoint::Init(+    const ServerAddress& address, const ChannelArgs& args,+    std::shared_ptr<WorkSerializer> work_serializer) {+  ChannelArgs child_args =+      args.Set(GRPC_ARG_INTERNAL_PICK_FIRST_ENABLE_HEALTH_CHECKING, true)+          .Set(GRPC_ARG_INTERNAL_PICK_FIRST_OMIT_STATUS_MESSAGE_PREFIX, true);+  LoadBalancingPolicy::Args lb_policy_args;+  lb_policy_args.work_serializer = std::move(work_serializer);+  lb_policy_args.args = child_args;+  lb_policy_args.channel_control_helper =+      std::make_unique<Helper>(Ref(DEBUG_LOCATION, ""Helper""));+  child_policy_ =+      CoreConfiguration::Get().lb_policy_registry().CreateLoadBalancingPolicy(+          ""pick_first"", std::move(lb_policy_args));+  if (GPR_UNLIKELY(endpoint_list_->tracer_ != nullptr)) {+    gpr_log(GPR_INFO, ""[%s %p] endpoint %p: created child policy %p"",+            endpoint_list_->tracer_, endpoint_list_->policy_.get(), this,+            child_policy_.get());+  }+  // Add our interested_parties pollset_set to that of the newly created+  // child policy. This will make the child policy progress upon activity on+  // this policy, which in turn is tied to the application's call.+  grpc_pollset_set_add_pollset_set(+      child_policy_->interested_parties(),+      endpoint_list_->policy_->interested_parties());+  // Update child policy.+  LoadBalancingPolicy::UpdateArgs update_args;+  update_args.addresses.emplace().emplace_back(address);+  update_args.args = child_args;+  // TODO(roth): If the child reports a non-OK status with the update,","In this situation, there's no point in logging it, because a non-OK status isn't actually a real failure; it's really just an indication of whether the resolver should consider the update a failure.  We actually have a broader pattern of this issue that occurs in many places, as introduced by #30809.  When we eventually find a good solution for this, we'll fix it everywhere it occurs.In this particular case, it's actually currently impossible for this to return non-OK anyway, because we are creating one endpoint for each address, and the only case where pick_first will return non-OK is if the address list is empty.  However, that will change when we add support for multiple addresses per endpoint, so I've added a TODO in round_robin.cc to make sure that we properly handle that case.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/32226,1243839631,2023-06-27T14:23:37Z,src/compiler/csharp_generator.cc,"@@ -436,14 +436,14 @@ void GenerateServiceDescriptorProperty(Printer* out,  void GenerateServerClass(Printer* out, const ServiceDescriptor* service) {   out->Print(-      ""/// <summary>Base class for server-side implementations of ""+      ""/// <summary>Base record for server-side implementations of ""       ""$servicename$</summary>\n"",       ""servicename"", GetServiceClassName(service));   out->Print(       ""[grpc::BindServiceMethod(typeof($classname$), ""       ""\""BindService\"")]\n"",       ""classname"", GetServiceClassName(service));-  out->Print(""public abstract partial class $name$\n"", ""name"",+  out->Print(""public abstract partial record $name$\n"", ""name"",","TBH, I don't understand why the base class for an implementation of a service would be a record rather than a class. I could see some benefits of the protobuf messages being records, but for service base class using a `record` doesn't make much sense IMHO?",X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/33257,1244211211,2023-06-27T18:55:38Z,src/core/lib/transport/promise_endpoint.h,"@@ -0,0 +1,282 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H+#define GRPC_SRC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <stddef.h>+#include <stdint.h>++#include <functional>+#include <memory>+#include <utility>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/slice_buffer.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""++namespace grpc_core {++// Wrapper around event engine endpoint that provides a promise like API.+class PromiseEndpoint {+ public:+  PromiseEndpoint(+      std::unique_ptr<grpc_event_engine::experimental::EventEngine::Endpoint>+          endpoint,+      SliceBuffer already_received);+  ~PromiseEndpoint();++  // Returns a promise that resolves to a `absl::Status` indicating the result+  // of the write operation.+  //+  // Concurrent writes are not supported, which means callers should not call+  // `Write()` before the previous write finishes. Doing that results in+  // undefined behavior.+  auto Write(SliceBuffer data) {+    {+      MutexLock lock(&write_mutex_);+      // Previous write result has not been polled.+      GPR_ASSERT(!write_result_.has_value());+      // TODO(ladynana): Replace this with `SliceBufferCast<>` when it is+      // available.+      grpc_slice_buffer_swap(write_buffer_.c_slice_buffer(),+                             data.c_slice_buffer());+    }+    // If `Write()` returns true immediately, the callback will not be called.+    // We still need to call our callback to pick up the result.+    if (endpoint_->Write(std::bind(&PromiseEndpoint::WriteCallback, this,+                                   std::placeholders::_1),+                         &write_buffer_,+                         nullptr /* uses default arguments */)) {+      WriteCallback(absl::OkStatus());+    }+    return [this]() -> Poll<absl::Status> {+      MutexLock lock(&write_mutex_);+      if (!write_result_.has_value()) {+        write_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else {+        const auto ret = *write_result_;+        write_result_.reset();+        return ret;+      }+    };+  }++  // Returns a promise that resolves to `SliceBuffer` with+  // `num_bytes` bytes.+  //+  // Concurrent reads are not supported, which means callers should not call+  // `Read()` before the previous read finishes. Doing that results in+  // undefined behavior.+  auto Read(size_t num_bytes) {+    ReleasableMutexLock lock(&read_mutex_);+    // Previous read result has not been polled.+    GPR_ASSERT(!read_result_.has_value());+    // Should not have pending reads.+    GPR_ASSERT(pending_read_buffer_.Count() == 0u);+    if (read_buffer_.Length() < num_bytes) {+      lock.Release();+      // If `Read()` returns true immediately, the callback will not be+      // called. We still need to call our callback to pick up the result and+      // maybe do further reads.+      if (endpoint_->Read(std::bind(&PromiseEndpoint::ReadCallback, this,+                                    std::placeholders::_1, num_bytes,+                                    absl::nullopt /* uses default arguments */),+                          &pending_read_buffer_,+                          nullptr /* uses default arguments */)) {+        ReadCallback(absl::OkStatus(), num_bytes, absl::nullopt);+      }+    } else {+      read_result_ = absl::OkStatus();+    }+    return [this, num_bytes]() -> Poll<absl::StatusOr<SliceBuffer>> {+      MutexLock lock(&read_mutex_);+      if (!read_result_.has_value()) {+        read_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else if (!read_result_->ok()) {+        const absl::Status ret = *read_result_;+        read_result_.reset();+        return ret;+      } else {+        SliceBuffer ret;+        grpc_slice_buffer_move_first(read_buffer_.c_slice_buffer(), num_bytes,+                                     ret.c_slice_buffer());+        read_result_.reset();+        return std::move(ret);+      }+    };+  }++  // Returns a promise that resolves to `Slice` with at least+  // `num_bytes` bytes which should be less than INT64_MAX bytes.+  //+  // Concurrent reads are not supported, which means callers should not call+  // `ReadSlice()` before the previous read finishes. Doing that results in+  // undefined behavior.+  auto ReadSlice(size_t num_bytes) {+    ReleasableMutexLock lock(&read_mutex_);+    // Previous read result has not been polled.+    GPR_ASSERT(!read_result_.has_value());+    // Should not have pending reads.+    GPR_ASSERT(pending_read_buffer_.Count() == 0u);+    if (read_buffer_.Length() < num_bytes) {+      lock.Release();+      const struct grpc_event_engine::experimental::EventEngine::Endpoint::+          ReadArgs read_args = {static_cast<int64_t>(num_bytes)};++      // If `Read()` returns true immediately, the callback will not be+      // called. We still need to call our callback to pick up the result+      // and maybe do further reads.+      if (endpoint_->Read(+              std::bind(&PromiseEndpoint::ReadCallback, this,+                        std::placeholders::_1, num_bytes, read_args),+              &pending_read_buffer_, &read_args)) {+        ReadCallback(absl::OkStatus(), num_bytes, read_args);+      }+    } else {+      read_result_ = absl::OkStatus();+    }+    return [this, num_bytes]() -> Poll<absl::StatusOr<Slice>> {+      MutexLock lock(&read_mutex_);+      if (!read_result_.has_value()) {+        read_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else if (!read_result_->ok()) {+        const auto ret = *read_result_;+        read_result_.reset();+        return ret;+      } else if (read_buffer_.RefSlice(0).size() == num_bytes) {+        read_result_.reset();+        return Slice(read_buffer_.TakeFirst().TakeCSlice());+      } else {+        MutableSlice ret = MutableSlice::CreateUninitialized(num_bytes);+        read_buffer_.MoveFirstNBytesIntoBuffer(num_bytes, ret.data());","I think you'd need to handle the read_buffer_.Size() < num_bytes case similar to how it is handled in the Read(num_bytes) method. It is not guaranteed that the event engine endpoint will always return at least num_bytes amount of data. Some event engines may ignore the ReadArgs passed to the endpoint (e.g, windows, ios).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1244347639,2023-06-27T20:59:30Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,714 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(+        status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                             ares_strerror(status)));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), qname(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string qname;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::OrphanablePtr<AresResolver>(new AresResolver(+      std::move(polled_fd_factory), std::move(event_engine), channel));+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_s;+  if (!grpc_core::SplitHostPort(name, &host, &port_s)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_s.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name.data()))]() mutable { callback(status); });","It's not safe to use `.data()` here, because there is no guarantee that `name` is a null-terminated string.  It's also not necessary in the first place, because `StrFormat()` can handle `absl::string_view` arguments just fine.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1244460903,2023-06-27T23:06:58Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,714 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(+        status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                             ares_strerror(status)));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), qname(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string qname;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::OrphanablePtr<AresResolver>(new AresResolver(+      std::move(polled_fd_factory), std::move(event_engine), channel));+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_s;+  if (!grpc_core::SplitHostPort(name, &host, &port_s)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_s.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name.data()))]() mutable { callback(status); });+      return;+    }+    port_s = default_port;+  }+  int port = 0;+  if (port_s == ""http"") {+    port = 80;+  } else if (port_s == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_s, &port)) {+    event_engine_->Run([callback = std::move(callback),+                        status = absl::InvalidArgumentError(absl::StrCat(+                            ""Failed to parse port in name: "",+                            name))]() mutable { callback(status); });+    return;+  }+  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               false /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               false /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    event_engine_->Run(+        [callback = std::move(callback), result = std::move(result)]() mutable {+          callback(std::move(result));+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);+  if (IsIpv6LoopbackAvailable()) {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,+                       &AresResolver::OnHostbynameDoneLocked,+                       static_cast<void*>(resolver_arg));",I don't think you need to explicitly cast to `void*` -- a function that takes a `void*` parameter should accept a pointer of any type.Same thing throughout.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1244467825,2023-06-27T23:15:47Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,714 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(+        status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                             ares_strerror(status)));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), qname(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string qname;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::OrphanablePtr<AresResolver>(new AresResolver(+      std::move(polled_fd_factory), std::move(event_engine), channel));+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_s;+  if (!grpc_core::SplitHostPort(name, &host, &port_s)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_s.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name.data()))]() mutable { callback(status); });+      return;+    }+    port_s = default_port;+  }+  int port = 0;+  if (port_s == ""http"") {+    port = 80;+  } else if (port_s == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_s, &port)) {+    event_engine_->Run([callback = std::move(callback),+                        status = absl::InvalidArgumentError(absl::StrCat(+                            ""Failed to parse port in name: "",+                            name))]() mutable { callback(status); });+    return;+  }+  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               false /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               false /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    event_engine_->Run(+        [callback = std::move(callback), result = std::move(result)]() mutable {+          callback(std::move(result));+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);+  if (IsIpv6LoopbackAvailable()) {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,","Now that we're using AF_UNSPEC, can we remove the address_sorting library?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1244476402,2023-06-27T23:27:21Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,714 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(+        status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                             ares_strerror(status)));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), qname(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string qname;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::OrphanablePtr<AresResolver>(new AresResolver(+      std::move(polled_fd_factory), std::move(event_engine), channel));+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_s;+  if (!grpc_core::SplitHostPort(name, &host, &port_s)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_s.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name.data()))]() mutable { callback(status); });+      return;+    }+    port_s = default_port;+  }+  int port = 0;+  if (port_s == ""http"") {+    port = 80;+  } else if (port_s == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_s, &port)) {+    event_engine_->Run([callback = std::move(callback),+                        status = absl::InvalidArgumentError(absl::StrCat(+                            ""Failed to parse port in name: "",+                            name))]() mutable { callback(status); });+    return;+  }+  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               false /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               false /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    event_engine_->Run(+        [callback = std::move(callback), result = std::move(result)]() mutable {+          callback(std::move(result));+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);+  if (IsIpv6LoopbackAvailable()) {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,+                       &AresResolver::OnHostbynameDoneLocked,+                       static_cast<void*>(resolver_arg));+  } else {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_INET,+                       &AresResolver::OnHostbynameDoneLocked,+                       static_cast<void*>(resolver_arg));+  }+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupSRV(+    absl::string_view name,+    EventEngine::DNSResolver::LookupSRVCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for SRV records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::UnknownError(+             ""Skip querying for SRV records for localhost target"")]() mutable {+          callback(status);+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new QueryArg(this, id_, host);+  ares_query(channel_, std::string(host).c_str(), ns_c_in, ns_t_srv,+             &AresResolver::OnSRVQueryDoneLocked,+             static_cast<void*>(resolver_arg));+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupTXT(+    absl::string_view name,+    EventEngine::DNSResolver::LookupTXTCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for TXT records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::UnknownError(+             ""Skip querying for TXT records for localhost target"")]() mutable {+          callback(status);+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new QueryArg(this, id_, host);+  ares_search(channel_, std::string(host).c_str(), ns_c_in, ns_t_txt,+              &AresResolver::OnTXTDoneLocked, static_cast<void*>(resolver_arg));+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++AresResolver::AresResolver(+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine, ares_channel channel)+    : grpc_core::InternallyRefCounted<AresResolver>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_resolver) ? ""AresResolver""+                                                            : nullptr),+      channel_(channel),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(std::move(event_engine)) {}++void AresResolver::CheckSocketsLocked() {+  FdNodeList new_list;+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == fd_node_list_.end()) {+          new_list.emplace_back(std::make_unique<FdNode>(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i])));+          GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p new fd: %d"", this, socks[i]);+        } else {+          new_list.splice(new_list.end(), fd_node_list_, iter);+        }+        FdNode* fd_node = new_list.back().get();+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          fd_node->readable_registered = true;+          if (fd_node->polled_fd->IsFdStillReadableLocked()) {+            // If c-ares is interested to read and the socket already has data+            // available for read, schedules OnReadable directly here. This is+            // to cope with the edge-triggered poller not getting an event if no+            // new data arrives and c-ares hasn't read all the data in the+            // previous ares_process_fd.+            GRPC_ARES_RESOLVER_TRACE_LOG(+                ""request:%p schedule read directly on: %d"", this, fd_node->as);+            event_engine_->Run(+                [self = Ref(DEBUG_LOCATION, ""CheckSocketsLocked""),+                 fd_node]() mutable {+                  self->OnReadable(fd_node, absl::OkStatus());+                });+          } else {+            // Otherwise register with the poller for readable event.+            GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                         fd_node->as);+            fd_node->polled_fd->RegisterForOnReadableLocked(+                [self = Ref(DEBUG_LOCATION, ""CheckSocketsLocked""),+                 fd_node](absl::Status status) mutable {+                  self->OnReadable(fd_node, status);+                });+          }+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                       fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""CheckSocketsLocked""),+               fd_node](absl::Status status) mutable {+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_.empty()) {+    FdNode* fd_node = fd_node_list_.front().get();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                   fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                   fd_node->polled_fd->GetName());+      fd_node_list_.pop_front();+    } else {+      new_list.splice(new_list.end(), fd_node_list_, fd_node_list_.begin());+    }+  }+  fd_node_list_ = std::move(new_list);+}++void AresResolver::MaybeStartTimerLocked() {+  if (ares_backup_poll_alarm_handle_.has_value()) {+    return;+  }+  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_RESOLVER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+      next_ares_backup_poll_alarm_duration,+      [self = Ref(DEBUG_LOCATION, ""MaybeStartTimerLocked"")]() {+        self->OnAresBackupPollAlarm();+      });+}++void AresResolver::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mutex_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_RESOLVER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                               fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  CheckSocketsLocked();+}++void AresResolver::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mutex_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_RESOLVER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                               fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  CheckSocketsLocked();+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void AresResolver::OnAresBackupPollAlarm() {+  grpc_core::MutexLock lock(&mutex_);+  GRPC_ARES_RESOLVER_TRACE_LOG(+      ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+      shutting_down_);+  if (!shutting_down_) {+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(+            ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+            fd_node->polled_fd->GetName());+        ares_socket_t as = fd_node->polled_fd->GetWrappedAresSocketLocked();+        ares_process_fd(channel_, as, as);+      }+    }+    EventEngine::Duration next_ares_backup_poll_alarm_duration =+        calculate_next_ares_backup_poll_alarm_duration();+    ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+        next_ares_backup_poll_alarm_duration,+        [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() {+          self->OnAresBackupPollAlarm();+        });+    CheckSocketsLocked();+  }+}++void AresResolver::OnHostbynameDoneLocked(void* arg, int status,+                                          int /*timeouts*/,+                                          struct hostent* hostent) {+  std::unique_ptr<HostnameQueryArg> hostname_qa(+      static_cast<HostnameQueryArg*>(arg));+  auto* ares_resolver = hostname_qa->ares_resolver;+  auto nh = ares_resolver->callback_map_.extract(hostname_qa->callback_map_id);+  GPR_ASSERT(!nh.empty());+  GPR_ASSERT(+      absl::holds_alternative<EventEngine::DNSResolver::LookupHostnameCallback>(+          nh.mapped()));+  auto callback = absl::get<EventEngine::DNSResolver::LookupHostnameCallback>(+      std::move(nh.mapped()));+  if (status != ARES_SUCCESS) {+    std::string error_msg =+        absl::StrFormat(""c-ares status is not ARES_SUCCESS name=%s: %s"",+                        hostname_qa->qname.c_str(), ares_strerror(status));+    GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                 ares_resolver, error_msg.c_str());+    ares_resolver->event_engine_->Run(+        [callback = std::move(callback),+         status = AresStatusToAbslStatus(status, error_msg)]() mutable {+          callback(status);+        });+    return;+  }+  std::vector<EventEngine::ResolvedAddress> result;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(hostname_qa->port);+        result.emplace_back(reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_RESOLVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            ares_resolver, output, hostname_qa->port, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(hostname_qa->port);+        result.emplace_back(reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_RESOLVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            ares_resolver, output, hostname_qa->port);+        break;+      }+    }+  }+  ares_resolver->event_engine_->Run(+      [callback = std::move(callback), result = std::move(result)]() mutable {+        callback(std::move(result));+      });+}++void AresResolver::OnSRVQueryDoneLocked(void* arg, int status, int /*timeouts*/,+                                        unsigned char* abuf, int alen) {+  std::unique_ptr<QueryArg> qa(static_cast<QueryArg*>(arg));+  auto* ares_resolver = qa->ares_resolver;+  auto nh = ares_resolver->callback_map_.extract(qa->callback_map_id);+  GPR_ASSERT(!nh.empty());+  GPR_ASSERT(+      absl::holds_alternative<EventEngine::DNSResolver::LookupSRVCallback>(+          nh.mapped()));+  auto callback = absl::get<EventEngine::DNSResolver::LookupSRVCallback>(+      std::move(nh.mapped()));+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        qa->qname.c_str(), ares_strerror(status));+    GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p on_srv_done_locked: %s"",+                                 ares_resolver, error_msg.c_str());+    ares_resolver->event_engine_->Run(+        [callback = std::move(callback),+         status = AresStatusToAbslStatus(status, error_msg)]() mutable {+          callback(status);+        });+    return;+  }+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"",+                               ares_resolver, parse_status);+  std::vector<EventEngine::DNSResolver::SRVRecord> result;+  if (parse_status == ARES_SUCCESS) {+    for (struct ares_srv_reply* srv_it = reply; srv_it != nullptr;+         srv_it = srv_it->next) {+      EventEngine::DNSResolver::SRVRecord record;+      record.host = srv_it->host;+      record.port = srv_it->port;+      record.priority = srv_it->priority;+      record.weight = srv_it->weight;+      result.push_back(std::move(record));+    }+  }+  if (reply != nullptr) {+    ares_free_data(reply);+  }+  ares_resolver->event_engine_->Run(+      [callback = std::move(callback), result = std::move(result)]() mutable {+        callback(std::move(result));+      });+}++void AresResolver::OnTXTDoneLocked(void* arg, int status, int /*timeouts*/,+                                   unsigned char* buf, int len) {+  std::unique_ptr<QueryArg> qa(static_cast<QueryArg*>(arg));+  auto* ares_resolver = qa->ares_resolver;+  auto nh = ares_resolver->callback_map_.extract(qa->callback_map_id);+  GPR_ASSERT(!nh.empty());+  GPR_ASSERT(+      absl::holds_alternative<EventEngine::DNSResolver::LookupTXTCallback>(+          nh.mapped()));+  auto callback = absl::get<EventEngine::DNSResolver::LookupTXTCallback>(+      std::move(nh.mapped()));+  struct ares_txt_ext* reply = nullptr;+  int parse_status = ARES_SUCCESS;","I think the logic here would be a bit clearer if we handled one status at a time.  We can avoid code duplication with a simple lambda:```auto fail = [&](absl::string_view prefix) {  std::string error_message = absl::StrFormat(""%s for %s: %s"",      prefix, qa->qname, ares_strerror(status));  GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p on_txt_done_locked: %s"",                                 ares_resolver, error_msg.c_str());  ares_resolver->event_engine_->Run(      [callback = std::move(callback),        status = AresStatusToAbslStatus(status, error_msg)]() mutable {        callback(status);      });};if (status != ARES_SUCCESS) {  fail(""TXT lookup failed"");  return;}GRPC_ARES_RESOLVER_TRACE_LOG(        ""request:%p on_txt_done_locked name=%s ARES_SUCCESS"", ares_resolver,        qa->qname.c_str());status = ares_parse_txt_reply_ext(buf, len, &reply);if (status != ARES_SUCCESS) {  fail(""parsing TXT result failed"");  return;}```",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33558,1245267479,2023-06-28T14:03:45Z,include/grpc/grpc_security.h,"@@ -526,7 +528,7 @@ GRPCAPI grpc_server_credentials* grpc_ssl_server_credentials_create(    authenticate client certificates.*/ GRPCAPI grpc_server_credentials* grpc_ssl_server_credentials_create_ex(     const char* pem_root_certs, grpc_ssl_pem_key_cert_pair* pem_key_cert_pairs,-    size_t num_key_cert_pairs,+    size_t num_key_cert_pair,",Why rename this parameter?  The plural seems more grammatically correct to me.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33558,1245273725,2023-06-28T14:07:21Z,src/core/lib/security/credentials/ssl/ssl_credentials.h,"@@ -120,6 +125,7 @@ class grpc_ssl_server_credentials final : public grpc_server_credentials {       grpc_ssl_pem_key_cert_pair* pem_key_cert_pairs, size_t num_key_cert_pairs,       grpc_ssl_client_certificate_request_type client_certificate_request); +  bool send_client_ca_list_ = true;",I think this field belongs in `grpc_ssl_server_credentials_options` instead of here.,X
110920239,erm-g,https://api.github.com/repos/grpc/grpc/pulls/33558,1245519335,2023-06-28T17:03:06Z,include/grpc/grpc_security.h,"@@ -896,6 +901,21 @@ GRPCAPI void grpc_tls_credentials_options_set_crl_directory( GRPCAPI void grpc_tls_credentials_options_set_verify_server_cert(     grpc_tls_credentials_options* options, int verify_server_cert); +/**+ * EXPERIMENTAL API - Subject to change+ *+ * Sets whether or not a TLS server should send a list of CA names in the+ * ServerHello. This list of CA names is read from the server's trust bundle, so+ * that the client can use this list as a hint to know which certificate it+ * should send to the server.+ *+ * WARNING: This API is extremely dangerous and should not be used. If the+ * server's trust bundle is too large, then the TLS server will be unable to","Does it make sense to add smth like '""too large"" definition depends on OpenSSL lib being used'?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33558,1245774604,2023-06-28T21:10:15Z,include/grpc/grpc_security.h,"@@ -528,9 +528,9 @@ GRPCAPI grpc_server_credentials* grpc_ssl_server_credentials_create(    authenticate client certificates.*/ GRPCAPI grpc_server_credentials* grpc_ssl_server_credentials_create_ex(     const char* pem_root_certs, grpc_ssl_pem_key_cert_pair* pem_key_cert_pairs,-    size_t num_key_cert_pair,+    size_t num_key_cert_pairs,     grpc_ssl_client_certificate_request_type client_certificate_request,-    void* reserved);+    bool send_client_ca_list, void* reserved);","In this particular case, I don't think we want to add an argument to this existing method, for several reasons.The back-story here is that when we first adding some of these options to SslCreds, there was some confusion about our policy with regard to backward-incompatible changes in the C-core API.  Our actual policy is that non-backward-compatible changes are fine, and the only requirement is that we need to publish a gRFC, as per [gRFC P3](https://github.com/grpc/proposal/blob/master/P3-grfcs-for-core-api-changes.md).  However, when these changes were added, for some reason we were thinking that we couldn't change the original `grpc_ssl_server_credentials_create()` API, so we added this `grpc_ssl_server_credentials_create_ex()` API with an alternative set of arguments.  And then later, we tried to generalize it more by adding `grpc_ssl_server_credentials_create_with_options()` (which is a good approach, and you'll notice that's the only interface we provide in the newer TlsCreds API).  But the result of all of this is that we now have 3 different methods for creating `grpc_ssl_server_credentials`, which is awful -- and if it wasn't for the fact that our long-term goal is to deprecate SslCreds in favor of TlsCreds, I would be pushing to clean this up.The bottom line here is that we can make breaking changes, but it will require a gRFC, which has an inherent 10-day waiting period, which I don't think is what you want here.  (Technically, we should require a gRFC even for a non-breaking pure addition to the API, such as adding the `grpc_ssl_server_credentials_options_set_send_client_ca_list()` method.  But I'm willing to ignore that in this case, since (a) it's really unlikely that this addition will prove problematic or controversial, and (b) I don't care so much about long-term consequences, since we want to eventually deprecate SslCreds anyway.  But I am not comfortable making a breaking change to an existing API without a gRFC.)Also, since we're going to want this PR back-ported to 1.56, we can't have any breaking changes here anyway, since that would require bumping the major version of C-core.  We generally only bump the major version of C-core in between minor versions, not in between two patch versions of the same minor version.So, please don't add this parameter to this method.  Instead, just change any caller using `grpc_ssl_server_credentials_create_ex()` that needs to set this option to instead use `grpc_ssl_server_credentials_create_with_options()`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33540,1245785734,2023-06-28T21:22:17Z,src/core/ext/xds/xds_lb_policy_registry.cc,"@@ -273,6 +306,9 @@ XdsLbPolicyRegistry::XdsLbPolicyRegistry() {   policy_config_factories_.emplace(       WrrLocalityLbPolicyConfigFactory::Type(),       std::make_unique<WrrLocalityLbPolicyConfigFactory>());+  policy_config_factories_.emplace(","This needs to be guarded by the env var, as per the gRFC:https://github.com/grpc/proposal/blob/master/A62-pick-first.md#temporary-environment-variable-protection",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1245889881,2023-06-28T22:33:28Z,test/core/event_engine/test_suite/tests/dns_test.cc,"@@ -25,7 +63,529 @@ void InitDNSTests() {} }  // namespace experimental }  // namespace grpc_event_engine -class EventEngineDNSTest : public EventEngineTest {};+namespace {++// TODO(yijiem): build a portable solution for Windows+constexpr char kDNSTestRecordGroupsYamlPath[] =+    ""test/core/event_engine/test_suite/tests/dns_test_record_groups.yaml"";+constexpr char kHealthCheckRecordName[] =+    ""health-check-local-dns-server-is-alive.resolver-tests.grpctestingexp"";++// You know where this comes from.+template <typename T>+void WaitForSingleOwner(std::shared_ptr<T>&& object) {+  while (object.use_count() > 1) {+    GRPC_LOG_EVERY_N_SEC(2, GPR_INFO, ""engine.use_count() = %ld"",+                         object.use_count());+    absl::SleepFor(absl::Milliseconds(100));+  }+}++}  // namespace++class EventEngineDNSTest : public EventEngineTest {+ public:+  static void SetUpTestSuite() {+    // Invoke bazel's executeable links to the .sh and .py scripts (don't use+    // the .sh and .py suffixes) to make sure that we're using bazel's test+    // environment.+    std::string kPythonWrapper = ""tools/distrib/python_wrapper"";+    std::string kDNSServerPath = ""test/cpp/naming/utils/dns_server"";+    std::string kDNSResolverPath = ""test/cpp/naming/utils/dns_resolver"";+    std::string kTCPConnectPath = ""test/cpp/naming/utils/tcp_connect"";+    // HACK: Hyrum's law.+    if (!grpc_core::GetEnv(""TEST_SRCDIR"").has_value()) {+      // Invoke the .sh and .py scripts directly where they are in source code.+      kPythonWrapper += "".sh"";+      kDNSServerPath += "".py"";+      kDNSResolverPath += "".py"";+      kTCPConnectPath += "".py"";+    }+    // 1. launch dns_server+    int port = grpc_pick_unused_port_or_die();+    ASSERT_NE(port, 0)+        << ""pick unused port failed, maybe the port server is not running? ""+           ""Start it with tools/run_tests/start_port_server.py"";+    // <path to python wrapper> <path to dns_server.py> -p <port> -r <path to+    // records config>+    _dns_server.server_process = new grpc::SubProcess(+        {kPythonWrapper, kDNSServerPath, ""-p"", std::to_string(port), ""-r"",+         kDNSTestRecordGroupsYamlPath});+    // TODO(yijiem): no way to check whether it fails or not+    _dns_server.port = port;++    // 2. wait until dns_server is up (health check)+    bool health_check_succeed = false;+    for (int i = 0; i < 10; i++) {+      // 2.1 tcp connect succeeds+      // <path to python wrapper> <path to tcp_connect.py> -s <hostname> -p+      // <port>+      grpc::SubProcess tcp_connect({kPythonWrapper, kTCPConnectPath, ""-s"",+                                    ""localhost"", ""-p"", std::to_string(port)});+      // TODO(yijiem): no way to check whether it fails or not+      if (tcp_connect.Join()) {+        // 2.2 make an A-record query to dns_server+        // <path to python wrapper> <path to dns_resolver.py> -s <hostname> -p+        // <port> -n <domain name to query>+        std::string command = absl::StrJoin(+            {kPythonWrapper.c_str(), kDNSResolverPath.c_str(), ""-s"",+             ""127.0.0.1"", ""-p"", std::to_string(port).c_str(), ""-n"",+             kHealthCheckRecordName},+            "" "");+        // TODO(yijiem): build a portable solution for Windows+        FILE* f = popen(command.c_str(), ""r"");","(This comment becomes outdated after the latest push)1. The `dns_test` launches a local python dns_server, uses another python script to do the health checking and uses the server to answer queries and runs tests against the `EventEngine::DNSResolver` implementation. Part of the challenges is to handle runfiles in both Bazel and Blaze build systems. (in Bazel the runfile dir for a cc_test is `${TEST_SRCDIR}/com_github_grpc_grpc`, in Blaze it is `${TEST_SRCDIR}/google3/third_party/grpc`) The way which the `resolver_component_test` handles this part really feels like tech-debt to me, e.g. https://source.corp.google.com/piper///depot/google3/third_party/grpc/bazel/grpc_build_system.bzl;l=1593-1602?q=file:third_party%2Fgrpc%20alternative&sq=package:piper%20file:%2F%2Fdepot%2Fgoogle3%20-file:google3%2FexperimentalSo in this change I added a minimal bazel version of `test/cpp/util/get_grpc_test_runfile_dir.(h|cc)` and a minimal blaze version of `third_party/grpc/google_specific/test/cpp/util/get_grpc_test_runfile_dir.cc` in the imported CL: https://critique.corp.google.com/cl/543840102/depot/google3/third_party/grpc/google_specific/test/cpp/util/get_grpc_test_runfile_dir.cc and switching between them in `grpc_build_system.bzl` (again feel like tech-debt, but maybe less...).2. The `resolver_component_test` test infra is not really flexible to be reused. That said, I added a `test/cpp/naming/utils/health_check.py` script and move the health checking logic from the `dns_test` into this script. This script could potentially be reused as well.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33561,1245943090,2023-06-29T00:11:27Z,src/python/grpcio_tests/tests/observability/_observability_test.py,"@@ -35,6 +35,9 @@ _STREAM_UNARY = ""/test/StreamUnary"" _STREAM_STREAM = ""/test/StreamStream"" STREAM_LENGTH = 5+PORT = 50051",We cannot introduce a fixed port. This makes it impossible to run multiple instances of the test in parallel.,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33561,1245948807,2023-06-29T00:21:21Z,src/python/grpcio_tests/tests/observability/_observability_test.py,"@@ -157,13 +162,29 @@ def testRecordUnaryUnary(self):             exporter=self.test_exporter         ):             self._start_server()-            self.unary_unary_call()+            unary_unary_call(port=self._port)          self.assertGreater(len(self.all_metric), 0)         self.assertGreater(len(self.all_span), 0)         self._validate_metrics(self.all_metric)         self._validate_spans(self.all_span) +    def testContextPropagation(self):+        # Sends two RPCs, one from gRPC client and the other from gRPC server.+        # Verify that the trace_id was propagated to the 2nd RPC.+        self._set_config_file(_VALID_CONFIG_TRACING_ONLY)+        with grpc_observability.GCPOpenCensusObservability(+            exporter=self.test_exporter+        ):+            self._start_server(port=PORT)+            unary_unary_call(port=PORT, metadata=TRIGGER_RPC_METADATA_TUPLE)++        # 2 of each for [""Recv"", ""Sent"", ""Attempt""]+        self.assertEqual(len(self.all_span), 6)","I think it would be useful to have a test that records one more RPC in the client -> server -> server chain. The tricky part is making sure that the context from an incoming request propagates to an outgoing request. While this _mostly_ does that, it's possible for an implementation to record an outgoing RPC as belonging to a trace (since the first server is responsible for sending this info out) but for the RPC to not actually carry the trace information, resulting in the second server not receiving this trace.The most straightforward way to to do this would be to have the server be sort of ""recursive"" by sending a request to itself, but this runs the risk of causing false positive tests; if the server thread that receives the response is the same as the server thread that sends the request, then the test can pass trivially without any trace context propagation functionality happening at all. I would suggest either going multiprocess or having multiple servers in the same process, each with their own thread pool.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33540,1246853034,2023-06-29T16:10:40Z,test/cpp/end2end/xds/xds_pick_first_end2end_test.cc,"@@ -0,0 +1,170 @@+// Copyright 2017 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#include <unistd.h>++#include <cstddef>+#include <optional>+#include <string>+#include <utility>+#include <vector>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include ""absl/strings/str_cat.h""++#include <grpc/event_engine/endpoint_config.h>+#include <grpcpp/support/status.h>++#include ""src/core/ext/filters/client_channel/backup_poller.h""+#include ""src/core/ext/filters/client_channel/lb_policy/xds/xds_channel_args.h""+#include ""src/core/ext/filters/client_channel/resolver/fake/fake_resolver.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/config/config_vars.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/proto/grpc/testing/xds/v3/cluster.grpc.pb.h""+#include ""src/proto/grpc/testing/xds/v3/pick_first.pb.h""+#include ""test/core/util/scoped_env_var.h""+#include ""test/core/util/test_config.h""+#include ""test/cpp/end2end/connection_attempt_injector.h""+#include ""test/cpp/end2end/xds/xds_end2end_test_lib.h""++namespace grpc {+namespace testing {+namespace {++using ::envoy::extensions::load_balancing_policies::pick_first::v3::PickFirst;++class PickFirstTest : public XdsEnd2endTest {+ protected:+  absl::variant<Status, size_t> WaitForAnyBackendHit(size_t start, size_t end) {+    Status status;+    size_t index = 3;+    SendRpcsUntil(DEBUG_LOCATION, [&](const RpcResult& result) -> bool {+      if (!result.status.ok()) {+        status = result.status;+        return false;+      }+      for (size_t i = start; i < end; ++i) {+        if (backends_[i]->backend_service()->request_count() > 0) {+          backends_[i]->backend_service()->ResetCounters();+          index = i;+          return false;+        }+      }+      return true;+    });+    if (!status.ok()) {+      return status;+    }+    return index;+  }++  void ConfigureCluster(size_t iteration, bool shuffle,+                        size_t first_endpoint_index,+                        size_t stop_endpoint_index) {+    std::string edsService = absl::StrCat(""edsservice"", iteration);+    // First 3 endpoints go to a service that will have regular pick_first LB+    balancer_->ads_service()->SetEdsResource(BuildEdsResource(+        EdsResourceArgs(+            {{""locality0"", CreateEndpointsForBackends(first_endpoint_index,+                                                      stop_endpoint_index)}}),+        edsService));+    PickFirst pick_first;+    pick_first.set_shuffle_address_list(shuffle);+    auto cluster = default_cluster_;+    cluster.clear_lb_policy();+    cluster.clear_load_balancing_policy();+    cluster.mutable_eds_cluster_config()->set_service_name(edsService);+    cluster.mutable_load_balancing_policy()+        ->add_policies()+        ->mutable_typed_extension_config()+        ->mutable_typed_config()+        ->PackFrom(pick_first);++    // Set ordered cluster configuration+    balancer_->ads_service()->SetCdsResource(cluster);+  }++  grpc_core::RefCountedPtr<grpc_core::FakeResolverResponseGenerator>+      logical_dns_cluster_resolver_response_generator_;+};++// Run both with and without load reporting, just for test coverage.+INSTANTIATE_TEST_SUITE_P(+    XdsTest, PickFirstTest,+    ::testing::Values(XdsTestType(), XdsTestType().set_enable_load_reporting()),+    &XdsTestType::Name);++TEST_P(PickFirstTest, PickFirstConfigurationIsPropagated) {","I think this test is way more complicated than it needs to be.  I think that what we actually want here is something similar to the logic that we have in the [existing unit test](https://github.com/grpc/grpc/blob/21f2eba14389ddb8346dfd16ac2c306037d3c7e9/test/core/client_channel/lb_policy/pick_first_test.cc#L261), with just a few differences.  In particular, note that the goal here is just to verify that the shuffle option is being passed in to the pick_first policy; we don't need to actually verify the behavior of that option, since we're already doing that in the unit test.  So I think that all we really need to do is to check that pick_first chooses a backend randomly each time we send it an update.Also, note that we don't need multiple CDS resource names, nor do we need multiple EDS resource names.  We can update the default CDS resource just once at the start of the test to configure it to use pick_first, and then we don't need to modify it again.  And we can populate the default EDS resource with the set of backends we want, and then we can update that EDS resource whenever we want -- updating the EDS resource will send an updated address list to the LB policy, even if the new list is identical to the old list.I suggest something like the following:```CreateAndStartBackends(3);auto eds_resource = BuildEdsResource(EdsResourceArgs(    {{""locality0"", CreateEndpointsForBackends()}}));// Change cluster to use pick_first with shuffle option.auto cluster = default_cluster_;PickFirst pick_first;pick_first.set_shuffle_address_list(true);cluster.mutable_load_balancing_policy()    ->add_policies()    ->mutable_typed_extension_config()    ->mutable_typed_config()    ->PackFrom(pick_first);balancer_->ads_service()->SetCdsResource(cluster);// Give 10 tries to get a different backend.size_t last_seen_backend = backends_.size();bool saw_different_backend = false;for (size_t i = 0; i < 10; ++i) {  // Update EDS resource.  This will send a new address list update to the LB policy.  balancer_->ads_service()->SetEdsResource(eds_resource);  // Send an RPC and figure out which backend it went to.  CheckRpcSendOk(DEBUG_LOCATION);  size_t backend_index = 0;  for (; backend_index < backends_.size(); ++backend_index) {    if (backends_[backend_index]->backend_service()->request_count() > 0) {      break;    }  }  ASSERT_LT(backend_index, backends_.size());  // If we found a different backend than last time, then the test succeeded.  if (last_seen_backend < backends_.size() &&      backend_index != last_seen_backend) {    saw_different_backend = true;    break;  }  last_seen_backend = backend_index;  // Restart the backend to force the client to go IDLE before the  // next iteration.  ShutdownBackend(backend_index);  EXPECT_TRUE(channel_->WaitForStateChange(      GRPC_CHANNEL_READY, grpc_timeout_seconds_to_deadline(5)));  EXPECT_THAT(channel_->GetState(false), GRPC_CHANNEL_IDLE);  StartBackend(backend_index);}EXPECT_TRUE(saw_different_backend);```",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1246863763,2023-06-29T16:20:46Z,test/core/event_engine/test_suite/tests/dns_test.cc,"@@ -25,7 +68,747 @@ void InitDNSTests() {} }  // namespace experimental }  // namespace grpc_event_engine +#ifdef GPR_WINDOWS class EventEngineDNSTest : public EventEngineTest {}; -// TODO(hork): establish meaningful tests+// TODO(yijiem): make the test run on Windows TEST_F(EventEngineDNSTest, TODO) { grpc_core::ExecCtx exec_ctx; }+#else++namespace {++using grpc_event_engine::experimental::EventEngine;+using SRVRecord = EventEngine::DNSResolver::SRVRecord;+using testing::ElementsAre;+using testing::Pointwise;+using testing::UnorderedPointwise;++// TODO(yijiem): make this portable for Windows+constexpr char kDNSTestRecordGroupsYamlPath[] =+    ""test/core/event_engine/test_suite/tests/dns_test_record_groups.yaml"";+constexpr char kHealthCheckRecordName[] =+    ""health-check-local-dns-server-is-alive.resolver-tests.grpctestingexp"";++MATCHER(ResolvedAddressEq, """") {+  const auto& addr0 = std::get<0>(arg);+  const auto& addr1 = std::get<1>(arg);+  return addr0.size() == addr1.size() &&+         memcmp(addr0.address(), addr1.address(), addr0.size()) == 0;+}++MATCHER(SRVRecordEq, """") {+  const auto& arg0 = std::get<0>(arg);+  const auto& arg1 = std::get<1>(arg);+  return arg0.host == arg1.host && arg0.port == arg1.port &&+         arg0.priority == arg1.priority && arg0.weight == arg1.weight;+}++MATCHER(StatusCodeEq, """") {+  return std::get<0>(arg).code() == std::get<1>(arg);+}++// Copied from tcp_socket_utils_test.cc+// TODO(yijiem): maybe move those into common test util+EventEngine::ResolvedAddress MakeAddr4(const uint8_t* data, size_t data_len,+                                       int port) {+  EventEngine::ResolvedAddress resolved_addr4;+  sockaddr_in* addr4 = reinterpret_cast<sockaddr_in*>(+      const_cast<sockaddr*>(resolved_addr4.address()));+  memset(&resolved_addr4, 0, sizeof(resolved_addr4));+  addr4->sin_family = AF_INET;+  GPR_ASSERT(data_len == sizeof(addr4->sin_addr.s_addr));+  memcpy(&addr4->sin_addr.s_addr, data, data_len);+  addr4->sin_port = htons(port);+  return EventEngine::ResolvedAddress(+      reinterpret_cast<sockaddr*>(addr4),+      static_cast<socklen_t>(sizeof(sockaddr_in)));+}++EventEngine::ResolvedAddress MakeAddr6(const uint8_t* data, size_t data_len,+                                       int port) {+  EventEngine::ResolvedAddress resolved_addr6;+  sockaddr_in6* addr6 = reinterpret_cast<sockaddr_in6*>(+      const_cast<sockaddr*>(resolved_addr6.address()));+  memset(&resolved_addr6, 0, sizeof(resolved_addr6));+  addr6->sin6_family = AF_INET6;+  GPR_ASSERT(data_len == sizeof(addr6->sin6_addr.s6_addr));+  memcpy(&addr6->sin6_addr.s6_addr, data, data_len);+  addr6->sin6_port = htons(port);+  return EventEngine::ResolvedAddress(+      reinterpret_cast<sockaddr*>(addr6),+      static_cast<socklen_t>(sizeof(sockaddr_in6)));+}++#define EXPECT_UNKNOWN_ERROR(result) \+  EXPECT_EQ((result).status().code(), absl::StatusCode::kUnknown)++}  // namespace++class EventEngineDNSTest : public EventEngineTest {+ public:+  static void SetUpTestSuite() {+    // Invoke bazel's executeable links to the .sh and .py scripts (don't use+    // the .sh and .py suffixes) to make sure that we're using bazel's test+    // environment.+    std::string kPythonWrapper = ""tools/distrib/python_wrapper"";+    std::string kDNSServerPath = ""test/cpp/naming/utils/dns_server"";+    std::string kDNSResolverPath = ""test/cpp/naming/utils/dns_resolver"";+    std::string kTCPConnectPath = ""test/cpp/naming/utils/tcp_connect"";+    // HACK: Hyrum's law.+    if (!grpc_core::GetEnv(""TEST_SRCDIR"").has_value()) {+      // Invoke the .sh and .py scripts directly where they are in source code.+      kPythonWrapper += "".sh"";+      kDNSServerPath += "".py"";+      kDNSResolverPath += "".py"";+      kTCPConnectPath += "".py"";+    }+    // 1. launch dns_server+    int port = grpc_pick_unused_port_or_die();+    // <path to python wrapper> <path to dns_server.py> -p <port> -r <path to+    // records config>+    _dns_server.server_process = new grpc::SubProcess(+        {kPythonWrapper, kDNSServerPath, ""-p"", std::to_string(port), ""-r"",+         kDNSTestRecordGroupsYamlPath});+    _dns_server.port = port;++    // 2. wait until dns_server is up (health check)+    bool health_check_succeed = false;+    for (int i = 0; i < 10; i++) {+      // 2.1 tcp connect succeeds+      // <path to python wrapper> <path to tcp_connect.py> -s <hostname> -p+      // <port>+      grpc::SubProcess tcp_connect({kPythonWrapper, kTCPConnectPath, ""-s"",+                                    ""localhost"", ""-p"", std::to_string(port)});+      int status = tcp_connect.Join();+      // TODO(yijiem): make this portable for Windows+      if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {+        // 2.2 make an A-record query to dns_server+        // <path to python wrapper> <path to dns_resolver.py> -s <hostname> -p+        // <port> -n <domain name to query>+        std::string command = absl::StrJoin<absl::string_view>(+            {kPythonWrapper, kDNSResolverPath, ""-s"", ""127.0.0.1"", ""-p"",+             std::to_string(port), ""-n"", kHealthCheckRecordName},+            "" "");+        // TODO(yijiem): make this portable for Windows+        FILE* f = popen(command.c_str(), ""r"");+        GPR_ASSERT(f != nullptr);+        char buf[128] = {};+        size_t res =+            fread(buf, sizeof(buf[0]), sizeof(buf) / sizeof(buf[0]) - 1, f);+        if (pclose(f) == 0 && res > 0) {+          absl::string_view sv(buf);+          if (sv.find(""123.123.123.123"") != sv.npos) {+            // finally+            gpr_log(+                GPR_INFO,+                ""DNS server is up! Successfully reached it over UDP and TCP."");+            health_check_succeed = true;+            break;+          }+        }+      }+      absl::SleepFor(absl::Seconds(1));+    }+    ASSERT_TRUE(health_check_succeed);+  }++  static void TearDownTestSuite() {+    _dns_server.server_process->Interrupt();+    _dns_server.server_process->Join();+    delete _dns_server.server_process;+  }++ protected:+  // Verifies that an ExecCtx exists on the thread from which the destructor is+  // invoked.+  class ExecCtxVerifier {+   public:+    explicit ExecCtxVerifier(grpc_closure* destroy_closure)+        : destroy_closure_(destroy_closure) {}++    ~ExecCtxVerifier() {+      grpc_core::ExecCtx* ctx = grpc_core::ExecCtx::Get();+      ctx->Run(DEBUG_LOCATION, destroy_closure_, absl::OkStatus());+    }++   private:+    grpc_closure* destroy_closure_;+  };++  std::unique_ptr<ExecCtxVerifier> CreateExecCtxVerifier() {+    GRPC_CLOSURE_INIT(&notify_closure_, Notify, &dns_resolver_signal_,+                      grpc_schedule_on_exec_ctx);+    return std::make_unique<ExecCtxVerifier>(&notify_closure_);+  }++  std::unique_ptr<EventEngine::DNSResolver> CreateDefaultDNSResolver() {+    std::shared_ptr<EventEngine> test_ee(this->NewEventEngine());+    EventEngine::DNSResolver::ResolverOptions options;+    options.dns_server = _dns_server.address();+    return test_ee->GetDNSResolver(options);+  }++  std::unique_ptr<EventEngine::DNSResolver>+  CreateDNSResolverWithNonResponsiveServer() {+    using FakeUdpAndTcpServer = grpc_core::testing::FakeUdpAndTcpServer;+    // Start up fake non responsive DNS server+    fake_dns_server_ = std::make_unique<FakeUdpAndTcpServer>(+        FakeUdpAndTcpServer::AcceptMode::kWaitForClientToSendFirstBytes,+        FakeUdpAndTcpServer::CloseSocketUponCloseFromPeer);+    const std::string dns_server =+        absl::StrFormat(""[::1]:%d"", fake_dns_server_->port());+    std::shared_ptr<EventEngine> test_ee(this->NewEventEngine());+    EventEngine::DNSResolver::ResolverOptions options;+    options.dns_server = dns_server;+    return test_ee->GetDNSResolver(options);+  }++  std::unique_ptr<EventEngine::DNSResolver>+  CreateDNSResolverWithoutSpecifyingServer() {+    std::shared_ptr<EventEngine> test_ee(this->NewEventEngine());+    EventEngine::DNSResolver::ResolverOptions options;+    return test_ee->GetDNSResolver(options);+  }++  struct DNSServer {+    std::string address() { return ""127.0.0.1:"" + std::to_string(port); }+    int port;+    grpc::SubProcess* server_process;+  };+  grpc_core::Notification dns_resolver_signal_;++  static void Notify(void* arg, grpc_error_handle error) {+    EXPECT_TRUE(error.ok());+    static_cast<grpc_core::Notification*>(arg)->Notify();+  }++ private:+  static DNSServer _dns_server;+  std::unique_ptr<grpc_core::testing::FakeUdpAndTcpServer> fake_dns_server_;+  grpc_closure notify_closure_;+};++EventEngineDNSTest::DNSServer EventEngineDNSTest::_dns_server;++TEST_F(EventEngineDNSTest, QueryNXHostname) {+  auto dns_resolver = CreateDefaultDNSResolver();+  bool verified = false;+  dns_resolver->LookupHostname(+      [&verified, ctx_verifier = CreateExecCtxVerifier()](auto result) {+        ASSERT_FALSE(result.ok());+        EXPECT_UNKNOWN_ERROR(result);+        EXPECT_THAT(grpc_core::StatusGetChildren(result.status()),+                    Pointwise(StatusCodeEq(), {absl::StatusCode::kUnknown,+                                               absl::StatusCode::kUnknown}));+        verified = true;+      },+      ""nonexisting-target.dns-test.event-engine."", /*default_port=*/""443"",+      std::chrono::seconds(5));+  dns_resolver_signal_.WaitForNotification();+  EXPECT_TRUE(verified);+}++TEST_F(EventEngineDNSTest, QueryWithIPLiteral) {+  constexpr uint8_t kExpectedAddresses[] = {4, 3, 2, 1};++  auto dns_resolver = CreateDefaultDNSResolver();+  bool verified = false;+  dns_resolver->LookupHostname(+      [&verified, &kExpectedAddresses,+       ctx_verifier = CreateExecCtxVerifier()](auto result) {+        ASSERT_TRUE(result.ok());+        EXPECT_THAT(*result,+                    Pointwise(ResolvedAddressEq(),+                              {MakeAddr4(kExpectedAddresses,+                                         sizeof(kExpectedAddresses), 1234)}));+        verified = true;+      },+      ""4.3.2.1:1234"",+      /*default_port=*/"""", std::chrono::seconds(5));+  dns_resolver_signal_.WaitForNotification();+  EXPECT_TRUE(verified);+}++TEST_F(EventEngineDNSTest, QueryARecord) {+  constexpr uint8_t kExpectedAddresses[][4] = {+      {1, 2, 3, 4}, {1, 2, 3, 5}, {1, 2, 3, 6}};++  auto dns_resolver = CreateDefaultDNSResolver();+  bool verified = false;+  dns_resolver->LookupHostname(+      [&verified, &kExpectedAddresses,+       ctx_verifier = CreateExecCtxVerifier()](auto result) {+        ASSERT_TRUE(result.ok());+        EXPECT_THAT(*result,+                    UnorderedPointwise(+                        ResolvedAddressEq(),+                        {MakeAddr4(kExpectedAddresses[0],+                                   sizeof(kExpectedAddresses[0]), 443),+                         MakeAddr4(kExpectedAddresses[1],+                                   sizeof(kExpectedAddresses[1]), 443),+                         MakeAddr4(kExpectedAddresses[2],+                                   sizeof(kExpectedAddresses[2]), 443)}));+        verified = true;+      },+      ""ipv4-only-multi-target.dns-test.event-engine."",+      /*default_port=*/""443"", std::chrono::seconds(5));+  dns_resolver_signal_.WaitForNotification();+  EXPECT_TRUE(verified);+}++TEST_F(EventEngineDNSTest, QueryAAAARecord) {+  constexpr uint8_t kExpectedAddresses[][16] = {+      {0x26, 0x07, 0xf8, 0xb0, 0x40, 0x0a, 0x08, 0x01, 0, 0, 0, 0, 0, 0, 0x10,+       0x02},+      {0x26, 0x07, 0xf8, 0xb0, 0x40, 0x0a, 0x08, 0x01, 0, 0, 0, 0, 0, 0, 0x10,+       0x03},+      {0x26, 0x07, 0xf8, 0xb0, 0x40, 0x0a, 0x08, 0x01, 0, 0, 0, 0, 0, 0, 0x10,+       0x04}};++  auto dns_resolver = CreateDefaultDNSResolver();+  bool verified = false;+  dns_resolver->LookupHostname(+      [&verified, &kExpectedAddresses,+       ctx_verifier = CreateExecCtxVerifier()](auto result) {+        ASSERT_TRUE(result.ok());+        EXPECT_THAT(*result,+                    UnorderedPointwise(+                        ResolvedAddressEq(),+                        {MakeAddr6(kExpectedAddresses[0],+                                   sizeof(kExpectedAddresses[0]), 443),+                         MakeAddr6(kExpectedAddresses[1],+                                   sizeof(kExpectedAddresses[1]), 443),+                         MakeAddr6(kExpectedAddresses[2],+                                   sizeof(kExpectedAddresses[2]), 443)}));+        verified = true;+      },+      ""ipv6-only-multi-target.dns-test.event-engine.:443"",+      /*default_port=*/"""", std::chrono::seconds(5));+  dns_resolver_signal_.WaitForNotification();+  EXPECT_TRUE(verified);+}++TEST_F(EventEngineDNSTest, TestAddressSorting) {+  constexpr uint8_t kExpectedAddresses[][16] = {+      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},+      {0x20, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x11, 0x11}};++  auto dns_resolver = CreateDefaultDNSResolver();+  bool verified = false;+  dns_resolver->LookupHostname(+      [&verified, &kExpectedAddresses,+       ctx_verifier = CreateExecCtxVerifier()](auto result) {+        ASSERT_TRUE(result.ok());+        EXPECT_THAT(+            *result,+            Pointwise(ResolvedAddressEq(),+                      {MakeAddr6(kExpectedAddresses[0],+                                 sizeof(kExpectedAddresses[0]), 1234),+                       MakeAddr6(kExpectedAddresses[1],+                                 sizeof(kExpectedAddresses[1]), 1234)}));+        verified = true;+      },+      ""ipv6-loopback-preferred-target.dns-test.event-engine.:1234"",+      /*default_port=*/"""", std::chrono::seconds(5));+  dns_resolver_signal_.WaitForNotification();+  EXPECT_TRUE(verified);+}++TEST_F(EventEngineDNSTest, QuerySRVRecord) {+  SRVRecord kExpectedRecords[2];","Oops, too early:```test/core/event_engine/test_suite/tests/dns_test.cc:292:8: error: designated initializers are a C++20 extension [-Werror,-Wc++20-designator]      {.host = ""ipv4-only-multi-target.dns-test.event-engine"",       ^test/core/event_engine/test_suite/tests/dns_test.cc:296:8: error: designated initializers are a C++20 extension [-Werror,-Wc++20-designator]      {.host = ""ipv6-only-multi-target.dns-test.event-engine"",```So using an initializer list without designator for now...",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1246926776,2023-06-29T17:22:08Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,714 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel channel) {",Done. `ares_channel` is actually a pointer type so that's why things still work. But I have changed here and elsewhere to pass in as a pointer to make the semantic clear.,X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/33561,1247169307,2023-06-29T20:57:35Z,src/python/grpcio_observability/grpc_observability/_gcp_observability.py,"@@ -197,10 +200,12 @@ def save_trace_context(         trace_options = trace_options_module.TraceOptions(0)         trace_options.set_enabled(is_sampled)         span_context = span_context_module.SpanContext(-            trace_id=trace_id, span_id=span_id, trace_options=trace_options+            trace_id=trace_id,+            span_id=span_id,+            trace_options=trace_options,+            from_header=True,","I'm taking a similar approach to other propagators (like [BinaryFormatPropagator](https://opencensus.io/api/python/_modules/opencensus/trace/propagation/binary_format.html#BinaryFormatPropagator.from_header)), but since it's an optional field, I'm fine to remove it if you have specific concerns.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1247197626,2023-06-29T21:34:27Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,714 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(+        status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                             ares_strerror(status)));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), qname(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string qname;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::OrphanablePtr<AresResolver>(new AresResolver(+      std::move(polled_fd_factory), std::move(event_engine), channel));+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_s;+  if (!grpc_core::SplitHostPort(name, &host, &port_s)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_s.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name.data()))]() mutable { callback(status); });+      return;+    }+    port_s = default_port;+  }+  int port = 0;+  if (port_s == ""http"") {+    port = 80;+  } else if (port_s == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_s, &port)) {+    event_engine_->Run([callback = std::move(callback),+                        status = absl::InvalidArgumentError(absl::StrCat(+                            ""Failed to parse port in name: "",+                            name))]() mutable { callback(status); });+    return;+  }+  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               false /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               false /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    event_engine_->Run(+        [callback = std::move(callback), result = std::move(result)]() mutable {+          callback(std::move(result));+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);+  if (IsIpv6LoopbackAvailable()) {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,","I hope so, maybe after we roll out the EE version and verify it works and remove the original `grpc_ares_wrapper` code. FWIW, the c-ares' addressing sorting function looks very similar to the address_sorting library (they both implement RFC 6724), but seems to have some slight difference in rule ordering. Not sure if that matters though.c-ares: https://source.corp.google.com/piper///depot/google3/third_party/ares/src/lib/ares__sortaddrinfo.c;l=282-286;rcl=540440028address_sorting: https://source.corp.google.com/piper///depot/google3/third_party/address_sorting/address_sorting.c;l=300;bpv=0;bpt=1;rcl=543911652",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1247223697,2023-06-29T22:16:44Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,714 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(+        status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                             ares_strerror(status)));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), qname(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string qname;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::OrphanablePtr<AresResolver>(new AresResolver(+      std::move(polled_fd_factory), std::move(event_engine), channel));+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_s;+  if (!grpc_core::SplitHostPort(name, &host, &port_s)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_s.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name.data()))]() mutable { callback(status); });+      return;+    }+    port_s = default_port;+  }+  int port = 0;+  if (port_s == ""http"") {+    port = 80;+  } else if (port_s == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_s, &port)) {+    event_engine_->Run([callback = std::move(callback),+                        status = absl::InvalidArgumentError(absl::StrCat(+                            ""Failed to parse port in name: "",+                            name))]() mutable { callback(status); });+    return;+  }+  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               false /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               false /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    event_engine_->Run(+        [callback = std::move(callback), result = std::move(result)]() mutable {+          callback(std::move(result));+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);+  if (IsIpv6LoopbackAvailable()) {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,+                       &AresResolver::OnHostbynameDoneLocked,+                       static_cast<void*>(resolver_arg));+  } else {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_INET,+                       &AresResolver::OnHostbynameDoneLocked,+                       static_cast<void*>(resolver_arg));+  }+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupSRV(+    absl::string_view name,+    EventEngine::DNSResolver::LookupSRVCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for SRV records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::UnknownError(",You are right. The old code reports an Ok status with an empty address list. Changed it accordingly.https://source.corp.google.com/piper///depot/google3/third_party/grpc/src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.cc;l=1091-1096;bpv=1;bpt=1,
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33574,1247264816,2023-06-29T23:49:26Z,tools/run_tests/artifacts/build_artifact_python.sh,"@@ -81,6 +81,21 @@ then   export GRPC_BUILD_OVERRIDE_BORING_SSL_ASM_PLATFORM=""linux-arm"" fi +ancillary_package_dir=(+  ""src/python/grpcio_admin/""","It would be great if we could have a single source of truth for the list here and the list of packages we're building lower in the file, but that would probably be more difficult than is reasonable for now.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1247291271,2023-06-30T00:45:56Z,src/core/ext/filters/client_channel/resolver/dns/event_engine/event_engine_client_channel_resolver.cc,"@@ -237,15 +237,8 @@ EventEngineClientChannelDNSResolver::EventEngineDNSRequestWrapper::     event_engine_resolver_->LookupSRV(         [self = Ref(DEBUG_LOCATION, ""OnSRVResolved"")](             absl::StatusOr<std::vector<EventEngine::DNSResolver::SRVRecord>>-                srv_records) {-          ApplicationCallbackExecCtx callback_exec_ctx;-          ExecCtx exec_ctx;","Ah, I think this is due to a bad merge. I have added these back. I still need to respond to that comment.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/33507,1247944742,2023-06-30T14:37:55Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023","According to the guidelines in the proposal process, for each proposal we need to open a discussion thread in the grpc.io forum so that community has a chance to voice their opinions.The process: https://github.com/grpc/proposal/blob/master/README.md#process (see bullet 5)Example: https://github.com/grpc/proposal/blob/master/L103-core-move-insecure-creds-declaration.md",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1248222866,2023-06-30T19:34:13Z,src/core/lib/event_engine/posix_engine/posix_engine.cc,"@@ -496,143 +493,74 @@ EventEngine::TaskHandle PosixEventEngine::RunAfterInternal( #if GRPC_ARES == 1 && defined(GRPC_POSIX_SOCKET_TCP)  PosixEventEngine::PosixDNSResolver::PosixDNSResolver(-    const ResolverOptions& options, PosixEnginePollerManager* poller_manager,+    const ResolverOptions& options, PosixEventPoller* poller,     std::shared_ptr<EventEngine> event_engine)     : options_(options),       event_engine_(std::move(event_engine)),-      poller_manager_(poller_manager) {}--PosixEventEngine::PosixDNSResolver::~PosixDNSResolver() {-  grpc_core::MutexLock lock(&mu_);-  // The DNSResolver is held alive by its caller (e.g.-  // event_engine_client_channel_resolver). The caller should be alive until-  // its passed-in on_resolve closure gets destroyed (usually through a-  // RefCountedPtr embedded in the closure). Until that happened, the-  // DNSResolver is alive as well as the EventEngine (since DNSResolver holds a-  // shared_ptr to the engine). Therefore, when the DNSResolver is destroyed,-  // all on_resolves should have been destroyed (they may not be called when the-  // request was cancelled) and all inflight handles should have been cleared-  // regardless of the actual sequence of events.-  GPR_ASSERT(GPR_LIKELY(inflight_requests_.empty()));-}+      poller_(poller) {} -LookupTaskHandle PosixEventEngine::PosixDNSResolver::LookupHostname(+void PosixEventEngine::PosixDNSResolver::LookupHostname(     LookupHostnameCallback on_resolve, absl::string_view name,-    absl::string_view default_port, Duration timeout) {-  PosixEventPoller* poller = poller_manager_->Poller();-  GPR_ASSERT(poller != nullptr);-  absl::StatusOr<GrpcAresHostnameRequest*> request =-      GrpcAresHostnameRequest::Create(-          name, default_port, options_.dns_server, timeout,-          std::make_unique<GrpcPolledFdFactoryPosix>(poller),-          event_engine_.get());-  if (!request.ok()) {-    // Report back initialization failure through on_resolve.-    event_engine_->Run(-        [on_resolve = std::move(on_resolve),-         status = request.status()]() mutable { on_resolve(status); });-    return LookupTaskHandle::kInvalid;-  }-  LookupTaskHandle handle{reinterpret_cast<intptr_t>(*request),-                          aba_token_.fetch_add(1)};-  {-    grpc_core::MutexLock lock(&mu_);-    inflight_requests_.insert(handle);+    absl::string_view default_port) {+  if (!ares_resolver_) {+    auto status_or = AresResolver::CreateAresResolver(","Would it make sense to change the [`EventEngine::GetDNSResolver()` API](https://github.com/grpc/grpc/blob/867973b4c0915e39b6eff17618754978ab91a4d6/include/grpc/event_engine/event_engine.h#L401) to return a `StatusOr<>`, so that we can simply fail creation of the `DNSResolver` instead of failing the individual query callbacks?",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1248223741,2023-06-30T19:35:45Z,src/core/lib/event_engine/ares_resolver.h,"@@ -59,6 +59,9 @@ class AresResolver : public grpc_core::InternallyRefCounted<AresResolver> {                      std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,                      std::shared_ptr<EventEngine> event_engine); +  // Made public so that we can use grpc_core::MakeOrphanable.","Suggest changing this comment to say something like ""Do not instantiate directly -- use CreateAresResolver() instead.""",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/32701,1248229786,2023-06-30T19:45:56Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,714 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++EventEngine::Duration calculate_next_ares_backup_poll_alarm_duration() {+  // An alternative here could be to use ares_timeout to try to be more+  // accurate, but that would require using ""struct timeval""'s, which just+  // makes things a bit more complicated. So just poll every second, as+  // suggested by the c-ares code comments.+  return std::chrono::seconds(1);+}++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(+        status, absl::StrCat(""c-ares status is not ARES_SUCCESS: "",+                             ares_strerror(status)));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), qname(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string qname;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status, absl::StrCat(""Failed to init ares channel. c-ares error: "",+                             ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::OrphanablePtr<AresResolver>(new AresResolver(+      std::move(polled_fd_factory), std::move(event_engine), channel));+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_s;+  if (!grpc_core::SplitHostPort(name, &host, &port_s)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_s.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name.data()))]() mutable { callback(status); });+      return;+    }+    port_s = default_port;+  }+  int port = 0;+  if (port_s == ""http"") {+    port = 80;+  } else if (port_s == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_s, &port)) {+    event_engine_->Run([callback = std::move(callback),+                        status = absl::InvalidArgumentError(absl::StrCat(+                            ""Failed to parse port in name: "",+                            name))]() mutable { callback(status); });+    return;+  }+  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               false /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               false /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    event_engine_->Run(+        [callback = std::move(callback), result = std::move(result)]() mutable {+          callback(std::move(result));+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);+  if (IsIpv6LoopbackAvailable()) {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,+                       &AresResolver::OnHostbynameDoneLocked,+                       static_cast<void*>(resolver_arg));+  } else {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_INET,+                       &AresResolver::OnHostbynameDoneLocked,+                       static_cast<void*>(resolver_arg));+  }+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupSRV(+    absl::string_view name,+    EventEngine::DNSResolver::LookupSRVCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for SRV records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::UnknownError(+             ""Skip querying for SRV records for localhost target"")]() mutable {+          callback(status);+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new QueryArg(this, id_, host);+  ares_query(channel_, std::string(host).c_str(), ns_c_in, ns_t_srv,+             &AresResolver::OnSRVQueryDoneLocked,+             static_cast<void*>(resolver_arg));+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupTXT(+    absl::string_view name,+    EventEngine::DNSResolver::LookupTXTCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for TXT records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::UnknownError(+             ""Skip querying for TXT records for localhost target"")]() mutable {+          callback(status);+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new QueryArg(this, id_, host);+  ares_search(channel_, std::string(host).c_str(), ns_c_in, ns_t_txt,+              &AresResolver::OnTXTDoneLocked, static_cast<void*>(resolver_arg));+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++AresResolver::AresResolver(+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine, ares_channel channel)+    : grpc_core::InternallyRefCounted<AresResolver>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_resolver) ? ""AresResolver""+                                                            : nullptr),+      channel_(channel),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(std::move(event_engine)) {}++void AresResolver::CheckSocketsLocked() {+  FdNodeList new_list;+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == fd_node_list_.end()) {+          new_list.emplace_back(std::make_unique<FdNode>(+              socks[i], polled_fd_factory_->NewGrpcPolledFdLocked(socks[i])));+          GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p new fd: %d"", this, socks[i]);+        } else {+          new_list.splice(new_list.end(), fd_node_list_, iter);+        }+        FdNode* fd_node = new_list.back().get();+        if (ARES_GETSOCK_READABLE(socks_bitmask, i) &&+            !fd_node->readable_registered) {+          fd_node->readable_registered = true;+          if (fd_node->polled_fd->IsFdStillReadableLocked()) {+            // If c-ares is interested to read and the socket already has data+            // available for read, schedules OnReadable directly here. This is+            // to cope with the edge-triggered poller not getting an event if no+            // new data arrives and c-ares hasn't read all the data in the+            // previous ares_process_fd.+            GRPC_ARES_RESOLVER_TRACE_LOG(+                ""request:%p schedule read directly on: %d"", this, fd_node->as);+            event_engine_->Run(+                [self = Ref(DEBUG_LOCATION, ""CheckSocketsLocked""),+                 fd_node]() mutable {+                  self->OnReadable(fd_node, absl::OkStatus());+                });+          } else {+            // Otherwise register with the poller for readable event.+            GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p notify read on: %d"", this,+                                         fd_node->as);+            fd_node->polled_fd->RegisterForOnReadableLocked(+                [self = Ref(DEBUG_LOCATION, ""CheckSocketsLocked""),+                 fd_node](absl::Status status) mutable {+                  self->OnReadable(fd_node, status);+                });+          }+        }+        // Register write_closure if the socket is writable and write_closure+        // has not been registered with this socket.+        if (ARES_GETSOCK_WRITABLE(socks_bitmask, i) &&+            !fd_node->writable_registered) {+          GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p notify write on: %d"", this,+                                       fd_node->as);+          fd_node->writable_registered = true;+          fd_node->polled_fd->RegisterForOnWriteableLocked(+              [self = Ref(DEBUG_LOCATION, ""CheckSocketsLocked""),+               fd_node](absl::Status status) mutable {+                self->OnWritable(fd_node, status);+              });+        }+      }+    }+  }+  // Any remaining fds in fd_node_list_ were not returned by ares_getsock()+  // and are therefore no longer in use, so they can be shut down and removed+  // from the list.+  while (!fd_node_list_.empty()) {+    FdNode* fd_node = fd_node_list_.front().get();+    if (!fd_node->already_shutdown) {+      GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                   fd_node->polled_fd->GetName());+      fd_node->polled_fd->ShutdownLocked(absl::OkStatus());+      fd_node->already_shutdown = true;+    }+    if (!fd_node->readable_registered && !fd_node->writable_registered) {+      GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p delete fd: %s"", this,+                                   fd_node->polled_fd->GetName());+      fd_node_list_.pop_front();+    } else {+      new_list.splice(new_list.end(), fd_node_list_, fd_node_list_.begin());+    }+  }+  fd_node_list_ = std::move(new_list);+}++void AresResolver::MaybeStartTimerLocked() {+  if (ares_backup_poll_alarm_handle_.has_value()) {+    return;+  }+  // Initialize the backup poll alarm+  EventEngine::Duration next_ares_backup_poll_alarm_duration =+      calculate_next_ares_backup_poll_alarm_duration();+  GRPC_ARES_RESOLVER_TRACE_LOG(+      ""request:%p StartTimers next ares process poll time in %zu ms"", this,+      Milliseconds(next_ares_backup_poll_alarm_duration));++  ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+      next_ares_backup_poll_alarm_duration,+      [self = Ref(DEBUG_LOCATION, ""MaybeStartTimerLocked"")]() {+        self->OnAresBackupPollAlarm();+      });+}++void AresResolver::OnReadable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mutex_);+  GPR_ASSERT(fd_node->readable_registered);+  fd_node->readable_registered = false;+  GRPC_ARES_RESOLVER_TRACE_LOG(""OnReadable: fd: %d; request: %p; status: %s"",+                               fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, fd_node->as, ARES_SOCKET_BAD);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  CheckSocketsLocked();+}++void AresResolver::OnWritable(FdNode* fd_node, absl::Status status) {+  grpc_core::MutexLock lock(&mutex_);+  GPR_ASSERT(fd_node->writable_registered);+  fd_node->writable_registered = false;+  GRPC_ARES_RESOLVER_TRACE_LOG(""OnWritable: fd: %d; request:%p; status: %s"",+                               fd_node->as, this, status.ToString().c_str());+  if (status.ok() && !shutting_down_) {+    ares_process_fd(channel_, ARES_SOCKET_BAD, fd_node->as);+  } else {+    // If error is not absl::OkStatus() or the resolution was cancelled, it+    // means the fd has been shutdown or timed out. The pending lookups made+    // on this request will be cancelled by the following ares_cancel(). The+    // remaining file descriptors in this request will be cleaned up in the+    // following Work() method.+    ares_cancel(channel_);+  }+  CheckSocketsLocked();+}++// In case of non-responsive DNS servers, dropped packets, etc., c-ares has+// intelligent timeout and retry logic, which we can take advantage of by+// polling ares_process_fd on time intervals. Overall, the c-ares library is+// meant to be called into and given a chance to proceed name resolution:+//   a) when fd events happen+//   b) when some time has passed without fd events having happened+// For the latter, we use this backup poller. Also see+// https://github.com/grpc/grpc/pull/17688 description for more details.+void AresResolver::OnAresBackupPollAlarm() {+  grpc_core::MutexLock lock(&mutex_);+  GRPC_ARES_RESOLVER_TRACE_LOG(+      ""request:%p OnAresBackupPollAlarm shutting_down=%d."", this,+      shutting_down_);+  if (!shutting_down_) {+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(+            ""request:%p OnAresBackupPollAlarm; ares_process_fd. fd=%s"", this,+            fd_node->polled_fd->GetName());+        ares_socket_t as = fd_node->polled_fd->GetWrappedAresSocketLocked();+        ares_process_fd(channel_, as, as);+      }+    }+    EventEngine::Duration next_ares_backup_poll_alarm_duration =+        calculate_next_ares_backup_poll_alarm_duration();+    ares_backup_poll_alarm_handle_ = event_engine_->RunAfter(+        next_ares_backup_poll_alarm_duration,+        [self = Ref(DEBUG_LOCATION, ""OnAresBackupPollAlarm"")]() {+          self->OnAresBackupPollAlarm();+        });+    CheckSocketsLocked();+  }+}++void AresResolver::OnHostbynameDoneLocked(void* arg, int status,+                                          int /*timeouts*/,+                                          struct hostent* hostent) {+  std::unique_ptr<HostnameQueryArg> hostname_qa(+      static_cast<HostnameQueryArg*>(arg));+  auto* ares_resolver = hostname_qa->ares_resolver;+  auto nh = ares_resolver->callback_map_.extract(hostname_qa->callback_map_id);+  GPR_ASSERT(!nh.empty());+  GPR_ASSERT(+      absl::holds_alternative<EventEngine::DNSResolver::LookupHostnameCallback>(+          nh.mapped()));+  auto callback = absl::get<EventEngine::DNSResolver::LookupHostnameCallback>(+      std::move(nh.mapped()));+  if (status != ARES_SUCCESS) {+    std::string error_msg =+        absl::StrFormat(""c-ares status is not ARES_SUCCESS name=%s: %s"",+                        hostname_qa->qname.c_str(), ares_strerror(status));+    GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p on_hostbyname_done_locked: %s"",+                                 ares_resolver, error_msg.c_str());+    ares_resolver->event_engine_->Run(+        [callback = std::move(callback),+         status = AresStatusToAbslStatus(status, error_msg)]() mutable {+          callback(status);+        });+    return;+  }+  std::vector<EventEngine::ResolvedAddress> result;+  for (size_t i = 0; hostent->h_addr_list[i] != nullptr; i++) {+    switch (hostent->h_addrtype) {+      case AF_INET6: {+        size_t addr_len = sizeof(struct sockaddr_in6);+        struct sockaddr_in6 addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin6_addr, hostent->h_addr_list[i],+               sizeof(struct in6_addr));+        addr.sin6_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin6_port = htons(hostname_qa->port);+        result.emplace_back(reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET6_ADDRSTRLEN];+        ares_inet_ntop(AF_INET6, &addr.sin6_addr, output, INET6_ADDRSTRLEN);+        GRPC_ARES_RESOLVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET6 result: \n""+            ""  addr: %s\n  port: %d\n  sin6_scope_id: %d\n"",+            ares_resolver, output, hostname_qa->port, addr.sin6_scope_id);+        break;+      }+      case AF_INET: {+        size_t addr_len = sizeof(struct sockaddr_in);+        struct sockaddr_in addr;+        memset(&addr, 0, addr_len);+        memcpy(&addr.sin_addr, hostent->h_addr_list[i], sizeof(struct in_addr));+        addr.sin_family = static_cast<unsigned char>(hostent->h_addrtype);+        addr.sin_port = htons(hostname_qa->port);+        result.emplace_back(reinterpret_cast<const sockaddr*>(&addr), addr_len);+        char output[INET_ADDRSTRLEN];+        ares_inet_ntop(AF_INET, &addr.sin_addr, output, INET_ADDRSTRLEN);+        GRPC_ARES_RESOLVER_TRACE_LOG(+            ""request:%p c-ares resolver gets a AF_INET result: \n""+            ""  addr: %s\n  port: %d\n"",+            ares_resolver, output, hostname_qa->port);+        break;+      }+    }+  }+  ares_resolver->event_engine_->Run(+      [callback = std::move(callback), result = std::move(result)]() mutable {+        callback(std::move(result));+      });+}++void AresResolver::OnSRVQueryDoneLocked(void* arg, int status, int /*timeouts*/,+                                        unsigned char* abuf, int alen) {+  std::unique_ptr<QueryArg> qa(static_cast<QueryArg*>(arg));+  auto* ares_resolver = qa->ares_resolver;+  auto nh = ares_resolver->callback_map_.extract(qa->callback_map_id);+  GPR_ASSERT(!nh.empty());+  GPR_ASSERT(+      absl::holds_alternative<EventEngine::DNSResolver::LookupSRVCallback>(+          nh.mapped()));+  auto callback = absl::get<EventEngine::DNSResolver::LookupSRVCallback>(+      std::move(nh.mapped()));+  if (status != ARES_SUCCESS) {+    std::string error_msg = absl::StrFormat(+        ""c-ares status is not ARES_SUCCESS qtype=SRV name=%s: %s"",+        qa->qname.c_str(), ares_strerror(status));+    GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p on_srv_done_locked: %s"",+                                 ares_resolver, error_msg.c_str());+    ares_resolver->event_engine_->Run(+        [callback = std::move(callback),+         status = AresStatusToAbslStatus(status, error_msg)]() mutable {+          callback(status);+        });+    return;+  }+  struct ares_srv_reply* reply = nullptr;+  const int parse_status = ares_parse_srv_reply(abuf, alen, &reply);+  GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p ares_parse_srv_reply: %d"",+                               ares_resolver, parse_status);+  std::vector<EventEngine::DNSResolver::SRVRecord> result;+  if (parse_status == ARES_SUCCESS) {","In general, I think it's more readable to have the code that handles an error condition right next to the condition that detects the error.  In other words, I think code of the following form is an anti-pattern:```if (success) {  // long block to handle success case} else {  // handle failure case}```I think this approach is better:```if (!success) {  // handle failure case} else {  // handle success case}```Or even better, if you can return early, this approach is best:```if (!success) {  // handle failure case  return;}// handle success case```In this case, I think we can do something like the latter:```if (parse_status != ARES_SUCCESS) {  std::string error_msg = absl::StrFormat(      ""Failed to parse srv reply: %s"", ares_strerror(parse_status));  GRPC_ARES_RESOLVER_TRACE_LOG(""request:%p on_srv_done_locked: %s"",                               ares_resolver, error_msg.c_str());  ares_resolver->event_engine_->Run(      [callback = std::move(callback),       status = AresStatusToAbslStatus(status, error_msg)]() mutable {        callback(status);      });  return;}// handle success case here```Note that the code for handling this error is almost identical to the code on lines 592-600.  To avoid this duplication, I think we can use the same lambda trick as in the TXT code (line 644).",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1248282072,2023-06-30T21:00:10Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,701 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++// An alternative here could be to use ares_timeout to try to be more+// accurate, but that would require using ""struct timeval""'s, which just+// makes things a bit more complicated. So just poll every second, as+// suggested by the c-ares code comments.+constexpr EventEngine::Duration kAresBackupPollAlarmDuration =+    std::chrono::seconds(1);++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel* channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(*channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(status, ares_strerror(status));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), query_name(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string query_name;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status,+        absl::StrCat(""Failed to init c-ares channel: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(&channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, &channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::MakeOrphanable<AresResolver>(+      std::move(polled_fd_factory), std::move(event_engine), channel);+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_string;+  if (!grpc_core::SplitHostPort(name, &host, &port_string)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_string.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name))]() mutable { callback(status); });+      return;+    }+    port_string = default_port;+  }+  int port = 0;+  if (port_string == ""http"") {+    port = 80;+  } else if (port_string == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_string, &port)) {+    event_engine_->Run([callback = std::move(callback),+                        status = absl::InvalidArgumentError(absl::StrCat(+                            ""Failed to parse port in name: "",+                            name))]() mutable { callback(status); });+    return;+  }+  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               false /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               false /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    event_engine_->Run(+        [callback = std::move(callback), result = std::move(result)]() mutable {+          callback(std::move(result));+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);+  if (IsIpv6LoopbackAvailable()) {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,+                       &AresResolver::OnHostbynameDoneLocked, resolver_arg);+  } else {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_INET,+                       &AresResolver::OnHostbynameDoneLocked, resolver_arg);+  }+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupSRV(+    absl::string_view name,+    EventEngine::DNSResolver::LookupSRVCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for SRV records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run([callback = std::move(callback)]() mutable {+      callback(std::vector<EventEngine::DNSResolver::SRVRecord>());+    });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new QueryArg(this, id_, host);+  ares_query(channel_, std::string(host).c_str(), ns_c_in, ns_t_srv,+             &AresResolver::OnSRVQueryDoneLocked, resolver_arg);+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupTXT(+    absl::string_view name,+    EventEngine::DNSResolver::LookupTXTCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for TXT records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run([callback = std::move(callback)]() mutable {+      callback(std::vector<std::string>());+    });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new QueryArg(this, id_, host);+  ares_search(channel_, std::string(host).c_str(), ns_c_in, ns_t_txt,+              &AresResolver::OnTXTDoneLocked, resolver_arg);+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++AresResolver::AresResolver(+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine, ares_channel channel)+    : grpc_core::InternallyRefCounted<AresResolver>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_ares_resolver) ? ""AresResolver""+                                                            : nullptr),+      channel_(channel),+      polled_fd_factory_(std::move(polled_fd_factory)),+      event_engine_(std::move(event_engine)) {}++void AresResolver::CheckSocketsLocked() {+  FdNodeList new_list;+  if (!shutting_down_) {+    ares_socket_t socks[ARES_GETSOCK_MAXNUM];+    int socks_bitmask = ares_getsock(channel_, socks, ARES_GETSOCK_MAXNUM);+    for (size_t i = 0; i < ARES_GETSOCK_MAXNUM; i++) {+      if (ARES_GETSOCK_READABLE(socks_bitmask, i) ||+          ARES_GETSOCK_WRITABLE(socks_bitmask, i)) {+        auto iter = std::find_if(+            fd_node_list_.begin(), fd_node_list_.end(),+            [sock = socks[i]](const auto& node) { return node->as == sock; });+        if (iter == fd_node_list_.end()) {+          new_list.emplace_back(std::make_unique<FdNode>(","nit: since this is an `std::list<std::unique_ptr<FdNode>>`, you don't need emplace here, `push_bach` is preferred. I think we have linting for that internally, so you may get that same recommendation on import.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/32701,1248290260,2023-06-30T21:15:13Z,src/core/lib/event_engine/posix_engine/posix_engine.h,"@@ -138,14 +140,23 @@ class PosixEventEngine final : public PosixEventEngineWithFdSupport,  public:   class PosixDNSResolver : public EventEngine::DNSResolver {    public:-    ~PosixDNSResolver() override;+#if GRPC_ARES == 1 && defined(GRPC_POSIX_SOCKET_TCP)","On platforms that don't support ares, this class will have an auto-generated public default constructor. Making a private, no-op default constructor, either in non-ares builds or just always having it, would prevent this from being instantiated on platforms that don't support ares. It's a bit of defensive programming, but I think it conveys the intention a bit better at compile time.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33601,1252526111,2023-07-05T04:37:25Z,src/core/lib/experiments/experiments.yaml,"@@ -149,3 +149,11 @@   owner: alishananda@google.com   test_tags: []   allow_in_fuzzing_config: false+- name: chttp2_allow_config_override_keepalive_permit_without_calls",Can we give this a shorter name? (there's some cost involved in longer names here),X
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/33507,1252761833,2023-07-05T08:40:13Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.","This can be changed by adding `#nullable enable` after the source header. For example, https://github.com/mitchdenny/aspnetcore/blob/9f4d4c6dc8c3bd3524e01645451de17aafefbd50/src/Http/Http.Extensions/gen/RequestDelegateGeneratorSources.cs#L10-L18",
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/33507,1252792691,2023-07-05T09:04:15Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.++### 5. Keeping the generated code simple and consistent++It would be possible to generate different code for nullable and non-nullable contexts+depending on some configuration, or to generate conditional code containing `#if` +everywhere.++Generating different code depending on configuration could lead to confusion or errors+if code generated in one project with nullable enabled was consumed in another project +that did not have nullable enabled. It would also have an impact on the level of +testing that would need to be done.++Generating conditional code would produce messy and potentially convoluted code, again+having an impact on testing.","Yes, but I think we should figure out how big the difference will be between nullable enabled generated code and nullable disabled generated code.I don't think there are many places in generated source that would be annotated as nullable. I took a quick look through some generated source code:* Message fields can be null.* `Equals(obj)` and `Equals(T)` would have nullable parameters.* `MergeFrom(T)` would have a nullable parameter.* `BindService` would have a nullable parameter (we could skip annotating this one since the only caller that would pass null is `Grpc.AspNetCore.Server`).* The `headers` parameter on gRPC client methods.I doubt that is everything, but I don't think there is a lot more.",
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/33507,1252806741,2023-07-05T09:15:50Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.++### 5. Keeping the generated code simple and consistent++It would be possible to generate different code for nullable and non-nullable contexts+depending on some configuration, or to generate conditional code containing `#if` +everywhere.++Generating different code depending on configuration could lead to confusion or errors+if code generated in one project with nullable enabled was consumed in another project +that did not have nullable enabled. It would also have an impact on the level of +testing that would need to be done.++Generating conditional code would produce messy and potentially convoluted code, again+having an impact on testing.++## Disadvantages of this propsal++There are a few places where adding annotations or attributes to the generated+code to help with the static flow analysis could be useful. These are:+- Checking non-null setters for certain fields in a message at compile time,+ such as fields that are strings. Runtime checks are still done in the+ generated code.+- Checking a non-null message or stream is passed to a gRPC service call.+- Specifying a non-null message or stream is returned from a gRPC service call.++By not supporting nullable reference types in the generated code these compile+time checks cannot be done.++## Outside the scope of this proposal++### Changes to related packages++Changes to `Google.Protobuf` library and other libraries +(such as `Google.Api.CommonProtos`) are outside the scope of this proposal.++There is a separate long-standing effort to enable null reference types for +`Google.Protobuf`.++### Exposing protocol buffers optional fields as nullable properties++See https://github.com/protocolbuffers/protobuf/issues/9083++This has been rejected by the protocol buffers team.++> ""We get requests in some other languages that have null support to allow +optional fields to have nullable properties. The main problem is that we like to +keep languages consistent and other languages don't have those same options. +Additionally, it's not clear with some primitive fields what a null value would +be (is it the default? What if users meant to set it to that option?). For those +reasons, we will not support this in the near future.","I don't understand this bit. Nullable reference types is only for reference types. Primitive fields (int, double, etc) won't change.Edit: Unless you're considering changing primitive fields from `int`, `double`, etc to `int?`, `double?`. That would be a big breaking change as the types are changing to `Nullable<T>`.",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/33507,1252839288,2023-07-05T09:39:25Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.","E.g. the server side base class for a service could be changed to:```C# public abstract partial class PersonLookupBase    {      [global::System.CodeDom.Compiler.GeneratedCode(""grpc_csharp_plugin"", null)]#if GRPC_ENABLE_NULLABLE_ATTRIBUTES            [return: global::System.Diagnostics.CodeAnalysis.NotNull]#endif      public virtual global::System.Threading.Tasks.Task<global::Attrtest.Person> FindPerson(#if GRPC_ENABLE_NULLABLE_ATTRIBUTES          [global::System.Diagnostics.CodeAnalysis.NotNull]#endif          global::Attrtest.SearchCriteria request,#if GRPC_ENABLE_NULLABLE_ATTRIBUTES          [global::System.Diagnostics.CodeAnalysis.NotNull]#endif          grpc::ServerCallContext context)      {        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, """"));      }```i.e. it doesn't return null, or accept null for any of the parameters.But is there any advantage is doing this as the only caller is the web server hosting the service and not user code.",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/33507,1252848056,2023-07-05T09:45:48Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.++### 5. Keeping the generated code simple and consistent++It would be possible to generate different code for nullable and non-nullable contexts+depending on some configuration, or to generate conditional code containing `#if` +everywhere.++Generating different code depending on configuration could lead to confusion or errors+if code generated in one project with nullable enabled was consumed in another project +that did not have nullable enabled. It would also have an impact on the level of +testing that would need to be done.++Generating conditional code would produce messy and potentially convoluted code, again+having an impact on testing.","There are a few other places in the generated code that break when nullable enabled, e.g.```public virtual global::Attrtest.Person FindPerson(   global::Attrtest.SearchCriteria request,   grpc::Metadata headers = null,   global::System.DateTime? deadline = null,   global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken)   )      {        return FindPerson(request, new grpc::CallOptions(headers, deadline, cancellationToken));      }```the `grpc::Metadata headers = null` is one such place above that needs changing to make it compile without warnings.It just gets messy.",
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/33507,1252862156,2023-07-05T09:57:33Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.","`NotNull` doesn't need to be used like that. There are some situations where it is useful, but it is mostly when working with a generic type argument that might or might not be a reference type. Or for informing static analysis that if this method didn't throw an error when a value was passed in, the value must not be null. See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/nullable-analysis#postconditions-maybenull-and-notnullIt should look like this:```cs#nullable enable // placed at the top of the filepublic abstract partial class PersonLookupBase{    [global::System.CodeDom.Compiler.GeneratedCode(""grpc_csharp_plugin"", null)]    public virtual global::System.Threading.Tasks.Task<global::Attrtest.Person> FindPerson(        global::Attrtest.SearchCriteria request,        grpc::ServerCallContext context)    {        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, """"));    }}```In a context with nullable enabled, reference types without `?` on them are inferred not to allow null.",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/33507,1252862643,2023-07-05T09:57:59Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.++### 5. Keeping the generated code simple and consistent++It would be possible to generate different code for nullable and non-nullable contexts+depending on some configuration, or to generate conditional code containing `#if` +everywhere.","I've been advised that the protocol buffers team discourage adding more command line options as it increases testing. We might also get inconsistent code because protoc and the gRPC plugin as both would need to be passed the same command line options. Grpc.Tools can do that but if someone is using the compiler without Grpc.Tools then they might pass incosistent arguments. Thus if we were to do anything the preference might be to generate conditional code with `#if` throughout the code - (before you comment - yes, that increases testing too). The question is how is the user experience impacted by:- not doing anything (compiles OK today)- versus the advantages the user gains- versus additional complexity of the right configuration or messiness of the generated code?",X
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/33507,1252868627,2023-07-05T10:02:23Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.++### 2. .NET Framework projects default to using C# 7.3++*.NET Framework* projects default to using compiler version C# 7.3 which does+not support nullable reference type features.++*Visual Studio 2022* does not let you change to a later compiler version for+*.NET Framework* projects:+- In *Advanced Build Settings | Language version* the drop down to select the +language version is greyed out and says *Automatically selected based on +framework version*++See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version ++Note: It is possible to edit the project file and explicitly set the language +version to a later version, but other language features that require runtime +changes in the CLR will not work. C# 7.3 is the latest language version that is +fully supported with *.NET Framework* projects.++### 3. Building gRPC projects with nullable enabled works today++There does not appear to be a problem building *.NET Core* projects that have+nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`+examples already have nullable context enabled and they build without errors +or warnings.++### 4. Breaking backwards compatibility with gRPC service classes++The generated code for gRPC services could have attributes added to specify that +a non-null message or stream must be passed to a service, and a non-null value +is returned.++However this can break existing user code. Adding these attributes to the base +class may cause errors (not warnings) in user code that has already been derived +from the base class:++> *error CS8765: Nullability of type of parameter 'request' doesn't match +overridden member (possibly because of nullability attributes).*++Note: the advantages of adding these attributes to the service methods is +questionable as the only caller of these methods is the server hosting the +services, not user code. Therefore this may not be an issue if it is not needed +to be done.++### 5. Keeping the generated code simple and consistent++It would be possible to generate different code for nullable and non-nullable contexts+depending on some configuration, or to generate conditional code containing `#if` +everywhere.++Generating different code depending on configuration could lead to confusion or errors+if code generated in one project with nullable enabled was consumed in another project +that did not have nullable enabled. It would also have an impact on the level of +testing that would need to be done.++Generating conditional code would produce messy and potentially convoluted code, again+having an impact on testing.",I updated my list with `headers`.,
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/33507,1252879448,2023-07-05T10:10:05Z,doc/csharp/csharp-null-ref-types-proposal.md,"@@ -0,0 +1,197 @@+ Handling of null reference types in C# code generation+----+* Author(s): Tony Newell+* Approver: +* Status: Draft+* Last updated: June 2023++## Abstract++The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference+ types language features introduced in C# 8.0.++This proposal discusses why there are no plans to explicitly handle nullable +reference types in the generated code.++## Background++A note on the terminology used in this document for the various *.NET* versions:+- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such +  as *.NET Framework 4.8.1*+- *.NET Core* - within this document, references to *.NET Core* are intended to include+ *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions+ from *.NET 5* and later as just *.NET*. ++*Nullable reference types* refers to a group of optional features introduced +in C# 8.0 to enable the compiler to do static flow analysis to determine if a+variable might be null before it is dereferenced. They are compile time features+that do not affect the runtime.++Various issues have been raised asking for the code generated by the protocol+buffers compiler (`protoc`) and the gRPC C# compiler plugin +(`grpc_csharp_plugin`) to support nullable reference types, including:++- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)+- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)+- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)+- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)++## Proposal++The proposal is to maintain the status quo and to keep code generation +unchanged. Reasons are given below.++## Rationale++The reasons for currently maintaining the status quo are summarised here:+1. The generated code is not in a nullable context+2. *.NET Framework* projects default to using C# 7.3+3. Building gRPC projects with nullable enabled works today+4. Breaking backwards compatibility with gRPC service classes+5. Keeping the generated code simple and consistent++There are very few disadvantages to not supporting nullable reference types in+the generated code. These are given later.++The above reasons are explained in more detail:++### 1. The generated code is not in a nullable context++The generated code is not in a nullable context. The `// <auto-generated>` +comment in the code disables it. No nullable checks are made and no compiler +warnings are generated for this code, even if the code is compiled in a project +with nullable checks enabled.","The goal is to give gRPC users information about null references in their code. For example:```protomessage User {  string name = 1;  Address address = 2;}message Address {  string street = 1;  string city = 2;}``````cspublic override Task<Empty> AddUser(User user, ServerCallContext context){    AddressEntity entity = new    {        Street = user.Address.Street, // Possible null reference exception        City = user.Address.City,    };    _addressRepository.Add(entity);    // rest of the method}```Right now this will happily compile without warnings. If gRPC code gen had annotations then they would get a warning and would know that `User.Address` could be null.```cspublic override Task<Empty> AddUser(User user, ServerCallContext context){    if (user.Address != null)    {        var entity = new AddressEntity        {            Street = user.Address.Street, // Earlier null check means there is no warning            City = user.Address.City,        };        _addressRepository.Add(entity);    }    // rest of the method}```",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/32701,1254911901,2023-07-06T20:56:43Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -0,0 +1,701 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include ""src/core/lib/event_engine/ares_resolver.h""++#include <stdint.h>++#include <string>+#include <vector>++#include ""src/core/lib/iomgr/port.h""++// IWYU pragma: no_include <arpa/inet.h>+// IWYU pragma: no_include <arpa/nameser.h>+// IWYU pragma: no_include <inttypes.h>+// IWYU pragma: no_include <netdb.h>+// IWYU pragma: no_include <netinet/in.h>+// IWYU pragma: no_include <stdlib.h>+// IWYU pragma: no_include <sys/socket.h>+// IWYU pragma: no_include <ratio>++#if GRPC_ARES == 1++#include <ares_nameser.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <initializer_list>+#include <memory>+#include <type_traits>+#include <utility>++#include ""absl/functional/any_invocable.h""+#include ""absl/hash/hash.h""+#include ""absl/strings/match.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_cat.h""+#include ""absl/strings/str_format.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/support/log.h>++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/time_util.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/host_port.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/resolved_address.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+#include ""src/core/lib/event_engine/posix_engine/tcp_socket_utils.h""+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+#endif++namespace grpc_event_engine {+namespace experimental {++grpc_core::TraceFlag grpc_trace_ares_resolver(false,+                                              ""event_engine_ares_resolver"");++namespace {++absl::Status AresStatusToAbslStatus(int status, absl::string_view error_msg) {+  switch (status) {+    case ARES_ECANCELLED:+      return absl::CancelledError(error_msg);+    case ARES_ENOTIMP:+      return absl::UnimplementedError(error_msg);+    case ARES_ENOTFOUND:+      return absl::NotFoundError(error_msg);+    default:+      return absl::UnknownError(error_msg);+  }+}++// An alternative here could be to use ares_timeout to try to be more+// accurate, but that would require using ""struct timeval""'s, which just+// makes things a bit more complicated. So just poll every second, as+// suggested by the c-ares code comments.+constexpr EventEngine::Duration kAresBackupPollAlarmDuration =+    std::chrono::seconds(1);++bool IsIpv6LoopbackAvailable() {+#ifdef GRPC_POSIX_SOCKET_ARES_EV_DRIVER+  return PosixSocketWrapper::IsIpv6LoopbackAvailable();+#elif defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)+  // TODO(yijiem): make this portable for Windows+  return true;+#else+#error ""Unsupported platform""+#endif+}++absl::Status SetRequestDNSServer(absl::string_view dns_server,+                                 ares_channel* channel) {+  GRPC_ARES_RESOLVER_TRACE_LOG(""Using DNS server %s"", dns_server.data());+  grpc_resolved_address addr;+  struct ares_addr_port_node dns_server_addr = {};+  if (grpc_parse_ipv4_hostport(dns_server, &addr, /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET;+    struct sockaddr_in* in = reinterpret_cast<struct sockaddr_in*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr4, &in->sin_addr, sizeof(struct in_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else if (grpc_parse_ipv6_hostport(dns_server, &addr,+                                      /*log_errors=*/false)) {+    dns_server_addr.family = AF_INET6;+    struct sockaddr_in6* in6 =+        reinterpret_cast<struct sockaddr_in6*>(addr.addr);+    memcpy(&dns_server_addr.addr.addr6, &in6->sin6_addr,+           sizeof(struct in6_addr));+    dns_server_addr.tcp_port = grpc_sockaddr_get_port(&addr);+    dns_server_addr.udp_port = grpc_sockaddr_get_port(&addr);+  } else {+    return absl::InvalidArgumentError(+        absl::StrCat(""Cannot parse authority: "", dns_server));+  }+  int status = ares_set_servers_ports(*channel, &dns_server_addr);+  if (status != ARES_SUCCESS) {+    return AresStatusToAbslStatus(status, ares_strerror(status));+  }+  return absl::OkStatus();+}++struct QueryArg {+  QueryArg(AresResolver* ar, int id, absl::string_view name)+      : ares_resolver(ar), callback_map_id(id), query_name(name) {}+  AresResolver* ares_resolver;+  int callback_map_id;+  std::string query_name;+};++struct HostnameQueryArg : public QueryArg {+  HostnameQueryArg(AresResolver* ar, int id, absl::string_view name, int p)+      : QueryArg(ar, id, name), port(p) {}+  int port;+};++}  // namespace++absl::StatusOr<grpc_core::OrphanablePtr<AresResolver>>+AresResolver::CreateAresResolver(+    absl::string_view dns_server,+    std::unique_ptr<GrpcPolledFdFactory> polled_fd_factory,+    std::shared_ptr<EventEngine> event_engine) {+  ares_options opts = {};+  opts.flags |= ARES_FLAG_STAYOPEN;+  ares_channel channel;+  int status = ares_init_options(&channel, &opts, ARES_OPT_FLAGS);+  if (status != ARES_SUCCESS) {+    gpr_log(GPR_ERROR, ""ares_init_options failed, status: %d"", status);+    return AresStatusToAbslStatus(+        status,+        absl::StrCat(""Failed to init c-ares channel: "", ares_strerror(status)));+  }+  event_engine_grpc_ares_test_only_inject_config(&channel);+  if (!dns_server.empty()) {+    absl::Status status = SetRequestDNSServer(dns_server, &channel);+    if (!status.ok()) {+      return status;+    }+  }+  return grpc_core::MakeOrphanable<AresResolver>(+      std::move(polled_fd_factory), std::move(event_engine), channel);+}++AresResolver::~AresResolver() {+  GPR_ASSERT(fd_node_list_.empty());+  GPR_ASSERT(callback_map_.empty());+  ares_destroy(channel_);+}++void AresResolver::Orphan() {+  {+    grpc_core::MutexLock lock(&mutex_);+    shutting_down_ = true;+    if (ares_backup_poll_alarm_handle_.has_value()) {+      event_engine_->Cancel(*ares_backup_poll_alarm_handle_);+      ares_backup_poll_alarm_handle_.reset();+    }+    for (const auto& fd_node : fd_node_list_) {+      if (!fd_node->already_shutdown) {+        GRPC_ARES_RESOLVER_TRACE_LOG(""request: %p shutdown fd: %s"", this,+                                     fd_node->polled_fd->GetName());+        fd_node->polled_fd->ShutdownLocked(+            absl::CancelledError(""AresResolver::Orphan""));+        fd_node->already_shutdown = true;+      }+    }+  }+  Unref(DEBUG_LOCATION, ""Orphan"");+}++void AresResolver::LookupHostname(+    absl::string_view name, absl::string_view default_port,+    EventEngine::DNSResolver::LookupHostnameCallback callback) {+  absl::string_view host;+  absl::string_view port_string;+  if (!grpc_core::SplitHostPort(name, &host, &port_string)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_string.empty()) {+    if (default_port.empty()) {+      event_engine_->Run([callback = std::move(callback),+                          status = absl::InvalidArgumentError(absl::StrFormat(+                              ""No port in name %s or default_port argument"",+                              name))]() mutable { callback(status); });+      return;+    }+    port_string = default_port;+  }+  int port = 0;+  if (port_string == ""http"") {+    port = 80;+  } else if (port_string == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_string, &port)) {+    event_engine_->Run([callback = std::move(callback),+                        status = absl::InvalidArgumentError(absl::StrCat(+                            ""Failed to parse port in name: "",+                            name))]() mutable { callback(status); });+    return;+  }+  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               false /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               false /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    event_engine_->Run(+        [callback = std::move(callback), result = std::move(result)]() mutable {+          callback(std::move(result));+        });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new HostnameQueryArg(this, id_, name, port);+  if (IsIpv6LoopbackAvailable()) {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_UNSPEC,+                       &AresResolver::OnHostbynameDoneLocked, resolver_arg);+  } else {+    ares_gethostbyname(channel_, std::string(host).c_str(), AF_INET,+                       &AresResolver::OnHostbynameDoneLocked, resolver_arg);+  }+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupSRV(+    absl::string_view name,+    EventEngine::DNSResolver::LookupSRVCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for SRV records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run([callback = std::move(callback)]() mutable {+      callback(std::vector<EventEngine::DNSResolver::SRVRecord>());+    });+    return;+  }+  grpc_core::MutexLock lock(&mutex_);+  callback_map_.emplace(++id_, std::move(callback));+  auto* resolver_arg = new QueryArg(this, id_, host);+  ares_query(channel_, std::string(host).c_str(), ns_c_in, ns_t_srv,+             &AresResolver::OnSRVQueryDoneLocked, resolver_arg);+  CheckSocketsLocked();+  MaybeStartTimerLocked();+}++void AresResolver::LookupTXT(+    absl::string_view name,+    EventEngine::DNSResolver::LookupTXTCallback callback) {+  absl::string_view host;+  absl::string_view port;+  if (!grpc_core::SplitHostPort(name, &host, &port)) {+    event_engine_->Run(+        [callback = std::move(callback),+         status = absl::InvalidArgumentError(absl::StrCat(+             ""Unparseable name: "", name))]() mutable { callback(status); });+    return;+  }+  GPR_ASSERT(!host.empty());+  // Don't query for TXT records if the target is ""localhost""+  if (absl::EqualsIgnoreCase(host, ""localhost"")) {+    event_engine_->Run([callback = std::move(callback)]() mutable {+      callback(std::vector<std::string>());","It's interesting, `callback` takes a `absl::StatusOr` which has an explicit default constructor which prohibits list initialization: https://source.corp.google.com/piper///depot/google3/third_party/absl/status/statusor.h;l=216-221?q=file:third_party%2Fabsl%20absl::StatusOr&sq=package:piper%20file:%2F%2Fdepot%2Fgoogle3%20-file:google3%2Fexperimental",
13091109,Romain-Geissler-1A,https://api.github.com/repos/grpc/grpc/pulls/33635,1257840585,2023-07-10T07:33:05Z,include/grpcpp/support/proto_buffer_reader.h,"@@ -154,7 +154,7 @@ class ProtoBufferReader : public grpc::protobuf::io::ZeroCopyInputStream {       }       uint64_t slice_length = GRPC_SLICE_LENGTH(*slice());       set_byte_count(ByteCount() + slice_length);-      if (slice_length <= count) {+      if (slice_length <= static_cast<uint64_t>(count)) {","From what I see, `ReadCord(absl::Cord* cord, int count)` is a virtual method defined in a Protobuf (https://github.com/protocolbuffers/protobuf/blob/a01d047456783b46a4ca675eee881de110a88799/src/google/protobuf/io/zero_copy_stream.h#L194), and in grpc you override it, so unless this change of type is made directly in protobuf, the method's signature has to keep using `int`. And in protobuf it seems the whole API uses `int` for the size of the reads, rather than `uint64_t` so, this suggested change is wider than just changing a single method.",X
17583509,zeromath,https://api.github.com/repos/grpc/grpc/pulls/33638,1258600872,2023-07-10T16:59:12Z,test/core/tsi/transport_security_test_lib.cc,"@@ -664,3 +680,71 @@ void tsi_test_frame_protector_fixture_destroy(   tsi_frame_protector_destroy(fixture->server_frame_protector);   gpr_free(fixture); }++std::string GenerateSelfSignedCertificate(+    const SelfSignedCertificateOptions& options) {+  // Generate an RSA keypair.+  RSA* rsa = RSA_new();+  BIGNUM* bignum = BN_new();+  GPR_ASSERT(BN_set_word(bignum, RSA_F4));+  GPR_ASSERT(+      RSA_generate_key_ex(rsa, /*key_size=*/2048, bignum, /*cb=*/nullptr));+  EVP_PKEY* key = EVP_PKEY_new();+  GPR_ASSERT(EVP_PKEY_assign_RSA(key, rsa));++  // Create the X509 object.+  X509* x509 = X509_new();+  GPR_ASSERT(X509_set_version(x509, X509_VERSION_3));++  // Set the not_before/after fields to infinite past/future. The value for+  // infinite future is from RFC 5280 Section 4.1.2.5.1.+  ASN1_UTCTIME* infinite_past = ASN1_UTCTIME_new();+  GPR_ASSERT(ASN1_UTCTIME_set(infinite_past, /*posix_time=*/0));+  GPR_ASSERT(X509_set1_notBefore(x509, infinite_past));+  ASN1_UTCTIME_free(infinite_past);+  ASN1_GENERALIZEDTIME* infinite_future = ASN1_GENERALIZEDTIME_new();+  GPR_ASSERT(+      ASN1_GENERALIZEDTIME_set_string(infinite_future, ""99991231235959Z""));+  GPR_ASSERT(X509_set1_notAfter(x509, infinite_future));+  ASN1_GENERALIZEDTIME_free(infinite_future);++  // Set the subject DN.+  X509_NAME* subject_name = X509_NAME_new();+  GPR_ASSERT(X509_NAME_add_entry_by_txt(+      subject_name, ""CN"", MBSTRING_ASC,","micro-nit: `/*field=*/""CN""`, similar below.",
110920239,erm-g,https://api.github.com/repos/grpc/grpc/pulls/33638,1258673065,2023-07-10T18:15:26Z,src/core/tsi/ssl_transport_security.cc,"@@ -65,6 +65,7 @@  // --- Constants. --- +#define TSI_SSL_MAX_BIO_WRITE_ATTEMPTS 100","As we discussed offline, let's do a follow up PR to expose `100` as another parameter. ",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33649,1258882028,2023-07-10T20:27:29Z,src/core/ext/transport/chttp2/transport/hpack_parser.cc,"@@ -1104,20 +1130,31 @@ grpc_error_handle HPackParser::Parse(const grpc_slice& slice, bool is_last) {     std::vector<uint8_t> buffer = std::move(unparsed_bytes_);     return ParseInput(Input(nullptr, buffer.data(),                             buffer.data() + buffer.size(), state_.frame_error),-                      is_last);+                      is_last, call_tracer);   }   return ParseInput(Input(slice.refcount, GRPC_SLICE_START_PTR(slice),                           GRPC_SLICE_END_PTR(slice), state_.frame_error),-                    is_last);+                    is_last, call_tracer); } -grpc_error_handle HPackParser::ParseInput(Input input, bool is_last) {+grpc_error_handle HPackParser::ParseInput(+    Input input, bool is_last,+    grpc_core::CallTracerAnnotationInterface* call_tracer) {   ParseInputInner(&input);   if (is_last && is_boundary()) {     if (state_.metadata_early_detection.Reject(state_.frame_length)) {       HandleMetadataSoftSizeLimitExceeded(&input);     }     global_stats().IncrementHttp2MetadataSize(state_.frame_length);+    if (call_tracer != nullptr && metadata_buffer_ != nullptr) {+      std::string metadata_annotation = absl::StrCat(+          ""gRPC metadata soft_limit:"",+          state_.metadata_early_detection.soft_limit(),+          "",hard_limit:"", state_.metadata_early_detection.hard_limit(), "","");+      MetadataSizeEncoder encoder(metadata_annotation);+      metadata_buffer_->Encode(&encoder);+      call_tracer->RecordAnnotation(metadata_annotation);","@yashykt @markdroth for general input here too: my sense here is that we should add a custom method (or enum AnnotationType) to the `CallTracer` interface for something like this, so that `CallTracer` implementations can choose whether they want to trace this data or not -- the set of things that might be traced will certainly grow, and different customers are going to want different things -- knowledge of which is best gathered in one place rather than scattered throughout the codebase (where possible)",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33649,1258891375,2023-07-10T20:38:28Z,src/core/ext/transport/chttp2/transport/hpack_parser.cc,"@@ -1104,20 +1130,31 @@ grpc_error_handle HPackParser::Parse(const grpc_slice& slice, bool is_last) {     std::vector<uint8_t> buffer = std::move(unparsed_bytes_);     return ParseInput(Input(nullptr, buffer.data(),                             buffer.data() + buffer.size(), state_.frame_error),-                      is_last);+                      is_last, call_tracer);   }   return ParseInput(Input(slice.refcount, GRPC_SLICE_START_PTR(slice),                           GRPC_SLICE_END_PTR(slice), state_.frame_error),-                    is_last);+                    is_last, call_tracer); } -grpc_error_handle HPackParser::ParseInput(Input input, bool is_last) {+grpc_error_handle HPackParser::ParseInput(+    Input input, bool is_last,+    grpc_core::CallTracerAnnotationInterface* call_tracer) {   ParseInputInner(&input);   if (is_last && is_boundary()) {     if (state_.metadata_early_detection.Reject(state_.frame_length)) {       HandleMetadataSoftSizeLimitExceeded(&input);     }     global_stats().IncrementHttp2MetadataSize(state_.frame_length);+    if (call_tracer != nullptr && metadata_buffer_ != nullptr) {+      std::string metadata_annotation = absl::StrCat(+          ""gRPC metadata soft_limit:"",+          state_.metadata_early_detection.soft_limit(),+          "",hard_limit:"", state_.metadata_early_detection.hard_limit(), "","");+      MetadataSizeEncoder encoder(metadata_annotation);+      metadata_buffer_->Encode(&encoder);+      call_tracer->RecordAnnotation(metadata_annotation);","Yeah, I agree that that would be good.  This seems like exactly the kind of annotation that we would want to be opt-in for OSS.For now, an `enum AnnotationType` is probably fine.  In the long run, I suspect that we'll need something more sophisticated, since we'll need a way to support opt-in metrics.  But I don't think we should add anything like that until we have a concrete use-case.",
16571023,ananda1066,https://api.github.com/repos/grpc/grpc/pulls/33649,1258948570,2023-07-10T21:51:41Z,src/core/ext/transport/chttp2/transport/hpack_parser.cc,"@@ -1104,20 +1130,31 @@ grpc_error_handle HPackParser::Parse(const grpc_slice& slice, bool is_last) {     std::vector<uint8_t> buffer = std::move(unparsed_bytes_);     return ParseInput(Input(nullptr, buffer.data(),                             buffer.data() + buffer.size(), state_.frame_error),-                      is_last);+                      is_last, call_tracer);   }   return ParseInput(Input(slice.refcount, GRPC_SLICE_START_PTR(slice),                           GRPC_SLICE_END_PTR(slice), state_.frame_error),-                    is_last);+                    is_last, call_tracer); } -grpc_error_handle HPackParser::ParseInput(Input input, bool is_last) {+grpc_error_handle HPackParser::ParseInput(+    Input input, bool is_last,+    grpc_core::CallTracerAnnotationInterface* call_tracer) {   ParseInputInner(&input);   if (is_last && is_boundary()) {     if (state_.metadata_early_detection.Reject(state_.frame_length)) {       HandleMetadataSoftSizeLimitExceeded(&input);     }     global_stats().IncrementHttp2MetadataSize(state_.frame_length);+    if (call_tracer != nullptr && metadata_buffer_ != nullptr) {+      std::string metadata_annotation = absl::StrCat(+          ""gRPC metadata soft_limit:"",+          state_.metadata_early_detection.soft_limit(),+          "",hard_limit:"", state_.metadata_early_detection.hard_limit(), "","");+      MetadataSizeEncoder encoder(metadata_annotation);+      metadata_buffer_->Encode(&encoder);+      call_tracer->RecordAnnotation(metadata_annotation);","Hm how granular would this type be? I think Yash had the idea previously of something like: ```enum class AnnotationType {  kProto,  kJson,  kString, // no specific format  kUnknown};```but if we want to opt-in for specific annotations,  it might look something more like: `{kDefault, kMetadataSizes}`. Also, in this case, we want to avoid encoding metadata sizes on every call for performance reasons, instead using `s->traced` to limit encoding to only those calls that are Dapper traced, which means OSS will never see the annotation. @yashykt would the `IsSampled()` function in calltracer work instead to rate-limit how often we construct the annotation? This would allow us to opt-in to the annotation in OSS as well.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/33640,1258982621,2023-07-10T22:47:05Z,src/core/ext/transport/chttp2/transport/parsing.cc,"@@ -682,6 +682,7 @@ static grpc_error_handle init_header_frame_parser(grpc_chttp2_transport* t,         }         s->parsed_trailers_only = true;         s->trailing_metadata_buffer.Set(grpc_core::GrpcTrailersOnly(), true);+        s->initial_metadata_buffer.Set(grpc_core::GrpcTrailersOnly(), true);",did you mean `s->trailing_metadata_buffer`?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33649,1260214249,2023-07-11T19:54:49Z,src/core/ext/transport/chttp2/transport/hpack_parser.cc,"@@ -1104,20 +1130,31 @@ grpc_error_handle HPackParser::Parse(const grpc_slice& slice, bool is_last) {     std::vector<uint8_t> buffer = std::move(unparsed_bytes_);     return ParseInput(Input(nullptr, buffer.data(),                             buffer.data() + buffer.size(), state_.frame_error),-                      is_last);+                      is_last, call_tracer);   }   return ParseInput(Input(slice.refcount, GRPC_SLICE_START_PTR(slice),                           GRPC_SLICE_END_PTR(slice), state_.frame_error),-                    is_last);+                    is_last, call_tracer); } -grpc_error_handle HPackParser::ParseInput(Input input, bool is_last) {+grpc_error_handle HPackParser::ParseInput(+    Input input, bool is_last,+    grpc_core::CallTracerAnnotationInterface* call_tracer) {   ParseInputInner(&input);   if (is_last && is_boundary()) {     if (state_.metadata_early_detection.Reject(state_.frame_length)) {       HandleMetadataSoftSizeLimitExceeded(&input);     }     global_stats().IncrementHttp2MetadataSize(state_.frame_length);+    if (call_tracer != nullptr && metadata_buffer_ != nullptr) {+      std::string metadata_annotation = absl::StrCat(+          ""gRPC metadata soft_limit:"",+          state_.metadata_early_detection.soft_limit(),+          "",hard_limit:"", state_.metadata_early_detection.hard_limit(), "","");+      MetadataSizeEncoder encoder(metadata_annotation);+      metadata_buffer_->Encode(&encoder);+      call_tracer->RecordAnnotation(metadata_annotation);","Chatted with @markdroth a little this morning... and we were converging on something that I think looks like the following:```class CallTracer { public:  // enum associated with the concrete type of Annotation (see below)  // use an enum here for any types that need to be down-casted to - and specifically  // an enum so we can get good code generation for switch statements in call tracer  // implementations  // (this means that things aren't completely open extensibility: if a call tracer needs  // to be able to down cast to a type then we need to add a name here - but no other  // details - this is an explicit trade-off to ensure reasonable code generation - which  // is a requirement in this space)  enum AnnotationType {    kUnknown,    kMetadataSizes, // annotation type must be grpc_core::MetadataSizesAnnotation    kDoNotUse_MustBeLast // force default: clause  };  // base class defines how to pull out a string to report  class Annotation {   public:    explicit Annotation(AnnotationType type) : type_(type) {}    AnnotationType type() { return type_; }    virtual std::string ToString() const = 0;   private:    const AnnotationType type_;  };  // record some arbitrary annotation  void RecordAnnotation(const Annotation& annotation)};// with elsewhere defined:class MetadataSizesAnnotation : public CallTracer::Annotation { public:  MetadataSizesAnnotation(uint64_t soft, uint64_t hard) : Annotation(AnnotationType::kMetadataSizes), soft_(soft), hard_(hard) {}  uint64_t soft() const { return soft_; }  uint64_t hard() const { return hard_; }  std::string ToString() const { return absl::StrCat(""soft:"", soft_, "" hard:"", hard_); }  private:  uint64_t soft_;  uint64_t hard_;};```",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33650,1260396052,2023-07-11T23:39:12Z,test/cpp/ext/filters/otel/otel_plugin_test.cc,"@@ -16,31 +16,227 @@ // // +#include ""src/cpp/ext/filters/otel/otel_plugin.h""+ #include ""api/include/opentelemetry/metrics/provider.h"" #include ""gmock/gmock.h"" #include ""gtest/gtest.h""-#include ""sdk/include/opentelemetry/sdk/metrics/meter_provider.h""+#include ""opentelemetry/sdk/metrics/meter_provider.h""+#include ""opentelemetry/sdk/metrics/metric_reader.h""++#include <grpcpp/grpcpp.h>  #include ""test/core/util/test_config.h""+#include ""test/cpp/end2end/test_service_impl.h""  namespace grpc { namespace testing { namespace { -TEST(OTelPluginTest, ApiDependency) {+std::shared_ptr<opentelemetry::sdk::metrics::MetricReader> g_reader_;",This isn't a data member and should not have an `_` suffix.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33649,1260407239,2023-07-11T23:59:42Z,src/core/ext/transport/chttp2/transport/hpack_parser.cc,"@@ -1104,20 +1130,31 @@ grpc_error_handle HPackParser::Parse(const grpc_slice& slice, bool is_last) {     std::vector<uint8_t> buffer = std::move(unparsed_bytes_);     return ParseInput(Input(nullptr, buffer.data(),                             buffer.data() + buffer.size(), state_.frame_error),-                      is_last);+                      is_last, call_tracer);   }   return ParseInput(Input(slice.refcount, GRPC_SLICE_START_PTR(slice),                           GRPC_SLICE_END_PTR(slice), state_.frame_error),-                    is_last);+                    is_last, call_tracer); } -grpc_error_handle HPackParser::ParseInput(Input input, bool is_last) {+grpc_error_handle HPackParser::ParseInput(+    Input input, bool is_last,+    grpc_core::CallTracerAnnotationInterface* call_tracer) {   ParseInputInner(&input);   if (is_last && is_boundary()) {     if (state_.metadata_early_detection.Reject(state_.frame_length)) {       HandleMetadataSoftSizeLimitExceeded(&input);     }     global_stats().IncrementHttp2MetadataSize(state_.frame_length);+    if (call_tracer != nullptr && metadata_buffer_ != nullptr) {+      std::string metadata_annotation = absl::StrCat(+          ""gRPC metadata soft_limit:"",+          state_.metadata_early_detection.soft_limit(),+          "",hard_limit:"", state_.metadata_early_detection.hard_limit(), "","");+      MetadataSizeEncoder encoder(metadata_annotation);+      metadata_buffer_->Encode(&encoder);+      call_tracer->RecordAnnotation(metadata_annotation);","Yeah, what Craig wrote looks like the right approach.  My only suggestion is that it might be a good idea to use [`UniqueTypeName`](https://github.com/grpc/grpc/blob/master/src/core/lib/gprpp/unique_type_name.h) here instead of an enum, since that way we don't need a central registry of all the types.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33649,1260416561,2023-07-12T00:17:40Z,src/core/ext/transport/chttp2/transport/hpack_parser.cc,"@@ -1104,20 +1130,31 @@ grpc_error_handle HPackParser::Parse(const grpc_slice& slice, bool is_last) {     std::vector<uint8_t> buffer = std::move(unparsed_bytes_);     return ParseInput(Input(nullptr, buffer.data(),                             buffer.data() + buffer.size(), state_.frame_error),-                      is_last);+                      is_last, call_tracer);   }   return ParseInput(Input(slice.refcount, GRPC_SLICE_START_PTR(slice),                           GRPC_SLICE_END_PTR(slice), state_.frame_error),-                    is_last);+                    is_last, call_tracer); } -grpc_error_handle HPackParser::ParseInput(Input input, bool is_last) {+grpc_error_handle HPackParser::ParseInput(+    Input input, bool is_last,+    grpc_core::CallTracerAnnotationInterface* call_tracer) {   ParseInputInner(&input);   if (is_last && is_boundary()) {     if (state_.metadata_early_detection.Reject(state_.frame_length)) {       HandleMetadataSoftSizeLimitExceeded(&input);     }     global_stats().IncrementHttp2MetadataSize(state_.frame_length);+    if (call_tracer != nullptr && metadata_buffer_ != nullptr) {+      std::string metadata_annotation = absl::StrCat(+          ""gRPC metadata soft_limit:"",+          state_.metadata_early_detection.soft_limit(),+          "",hard_limit:"", state_.metadata_early_detection.hard_limit(), "","");+      MetadataSizeEncoder encoder(metadata_annotation);+      metadata_buffer_->Encode(&encoder);+      call_tracer->RecordAnnotation(metadata_annotation);","Just to close the loop here - pretty adamant that it not be something like `UniqueTypeName` -- doing so would create big if/else chains in CallTracer implementations that can't be resolved at compile time (`UniqueTypeName` doesn't get its bit representation until program initialization).I want to be able to write:```void MyCallTracer::RecordAnnotation(const Annotation& annotation) {  switch (annotation.type()) {    case AnnotationType::kGeneric: puts(annotation.ToString().c_str()); break;    case AnnotationType::kMetadataSizes: /* do something cool and unique */ break;    // etc...  }}```Understood that this necessitates some lightweight central registry, but this stuff is going to be called with very high frequency and so we need to reduce the cost per call as far as we reasonably can.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33649,1260418217,2023-07-12T00:21:03Z,src/core/ext/transport/chttp2/transport/hpack_parser.cc,"@@ -1104,20 +1130,31 @@ grpc_error_handle HPackParser::Parse(const grpc_slice& slice, bool is_last) {     std::vector<uint8_t> buffer = std::move(unparsed_bytes_);     return ParseInput(Input(nullptr, buffer.data(),                             buffer.data() + buffer.size(), state_.frame_error),-                      is_last);+                      is_last, call_tracer);   }   return ParseInput(Input(slice.refcount, GRPC_SLICE_START_PTR(slice),                           GRPC_SLICE_END_PTR(slice), state_.frame_error),-                    is_last);+                    is_last, call_tracer); } -grpc_error_handle HPackParser::ParseInput(Input input, bool is_last) {+grpc_error_handle HPackParser::ParseInput(+    Input input, bool is_last,+    grpc_core::CallTracerAnnotationInterface* call_tracer) {   ParseInputInner(&input);   if (is_last && is_boundary()) {     if (state_.metadata_early_detection.Reject(state_.frame_length)) {       HandleMetadataSoftSizeLimitExceeded(&input);     }     global_stats().IncrementHttp2MetadataSize(state_.frame_length);+    if (call_tracer != nullptr && metadata_buffer_ != nullptr) {+      std::string metadata_annotation = absl::StrCat(+          ""gRPC metadata soft_limit:"",+          state_.metadata_early_detection.soft_limit(),+          "",hard_limit:"", state_.metadata_early_detection.hard_limit(), "","");+      MetadataSizeEncoder encoder(metadata_annotation);+      metadata_buffer_->Encode(&encoder);+      call_tracer->RecordAnnotation(metadata_annotation);","Okay, that makes sense.  I am concerned that it may become a maintenance burden in the long run, but I'm fine with starting that way and reevaluating if it becomes a problem.",X
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/33650,1260480032,2023-07-12T02:15:45Z,test/cpp/ext/filters/otel/otel_plugin_test.cc,"@@ -16,31 +16,227 @@ // // +#include ""src/cpp/ext/filters/otel/otel_plugin.h""+ #include ""api/include/opentelemetry/metrics/provider.h"" #include ""gmock/gmock.h"" #include ""gtest/gtest.h""-#include ""sdk/include/opentelemetry/sdk/metrics/meter_provider.h""+#include ""opentelemetry/sdk/metrics/meter_provider.h""+#include ""opentelemetry/sdk/metrics/metric_reader.h""++#include <grpcpp/grpcpp.h>  #include ""test/core/util/test_config.h""+#include ""test/cpp/end2end/test_service_impl.h""  namespace grpc { namespace testing { namespace { -TEST(OTelPluginTest, ApiDependency) {+std::shared_ptr<opentelemetry::sdk::metrics::MetricReader> g_reader_;","Yeah, it should have been a data member. Moved inside.",X
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/33650,1260480229,2023-07-12T02:16:04Z,test/cpp/ext/filters/otel/otel_plugin_test.cc,"@@ -16,31 +16,227 @@ // // +#include ""src/cpp/ext/filters/otel/otel_plugin.h""+ #include ""api/include/opentelemetry/metrics/provider.h"" #include ""gmock/gmock.h"" #include ""gtest/gtest.h""-#include ""sdk/include/opentelemetry/sdk/metrics/meter_provider.h""+#include ""opentelemetry/sdk/metrics/meter_provider.h""+#include ""opentelemetry/sdk/metrics/metric_reader.h""++#include <grpcpp/grpcpp.h>  #include ""test/core/util/test_config.h""+#include ""test/cpp/end2end/test_service_impl.h""  namespace grpc { namespace testing { namespace { -TEST(OTelPluginTest, ApiDependency) {+std::shared_ptr<opentelemetry::sdk::metrics::MetricReader> g_reader_;",It needed to be a data member.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33650,1261320884,2023-07-12T15:03:28Z,test/cpp/ext/otel/otel_plugin_test.cc,"@@ -90,46 +106,43 @@ class OTelPluginEnd2EndTest : public ::testing::Test {     grpc::Status status = stub_->Echo(&context, request, &response);   } -  void TearDown() override { server_->Shutdown(); }--  const std::string client_method_name_ = ""grpc.testing.EchoTestService/Echo"";-  const std::string server_method_name_ = ""grpc.testing.EchoTestService/Echo"";+  absl::flat_hash_map<std::string,+                      std::vector<opentelemetry::sdk::metrics::PointType>>+  ReadCurrentMetricsData(+      absl::AnyInvocable<+          bool(const absl::flat_hash_map<+               std::string,+               std::vector<opentelemetry::sdk::metrics::PointType>>&)>+          continue_predicate) {+    absl::flat_hash_map<std::string,+                        std::vector<opentelemetry::sdk::metrics::PointType>>+        data;+    auto deadline = absl::Now() + absl::Seconds(5);+    do {+      g_reader_->Collect([&](opentelemetry::sdk::metrics::ResourceMetrics& rm) {+        for (const opentelemetry::sdk::metrics::ScopeMetrics& smd :+             rm.scope_metric_data_) {+          for (const opentelemetry::sdk::metrics::MetricData& md :+               smd.metric_data_) {+            for (const opentelemetry::sdk::metrics::PointDataAttributes& dp :+                 md.point_data_attr_) {+              data[md.instrument_descriptor.name_].push_back(dp.point_data);+            }+          }+        }+        return true;+      });+    } while (continue_predicate(data) && deadline > absl::Now());+    return data;+  } +  std::shared_ptr<opentelemetry::sdk::metrics::MetricReader> g_reader_;","I don't think this should have a `g_` prefix, since it's no longer global.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/33711,1264958825,2023-07-17T07:10:41Z,tools/distrib/python/make_grpcio_tools.py,"@@ -228,7 +231,19 @@ def _copy_source_tree(source, target):             shutil.copyfile(source_file, target_file)  +def _delete_source_tree(target):+    """"""Deletes the copied target directory.""""""+    target = GRPCIO_TOOLS_ROOT_PREFIX + target+    target_abs = os.path.join(*target.split(""/""))+    print(""Deleting copied folder %s"" % (target_abs))+    shutil.rmtree(target_abs, ignore_errors=True)+ def main():+    parser = argparse.ArgumentParser()+    parser.add_argument(+        ""--cleanup-third-party"", default=False, action=""store_true"", help=""Delete the temporary third_party folder""","nit: naming:  throughout the grpc repo ,we use underscores in flag names AFAICT. So `--cleanup_third_party` would be more consistent?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33711,1265547907,2023-07-17T15:32:06Z,tools/distrib/python/make_grpcio_tools.py,"@@ -228,7 +231,19 @@ def _copy_source_tree(source, target):             shutil.copyfile(source_file, target_file)  +def _delete_source_tree(target):+    """"""Deletes the copied target directory.""""""+    target = GRPCIO_TOOLS_ROOT_PREFIX + target+    target_abs = os.path.join(*target.split(""/""))+    print(""Deleting copied folder %s"" % (target_abs))+    shutil.rmtree(target_abs, ignore_errors=True)+ def main():+    parser = argparse.ArgumentParser()","> Also, can we simply make the ""--cleanup-third-party"" behavior the default (and not need a new cmdline flag at all)?We can't, since most python build & test scripts require the temporary third_party tree to be there. For example: https://source.cloud.google.com/results/invocations/1c6507c0-fb08-42ce-b17e-eb92ef4140a3/log.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33696,1265978147,2023-07-17T22:56:42Z,src/core/lib/channel/call_tracer.h,"@@ -49,11 +49,30 @@ namespace grpc_core { // The base class for all tracer implementations. class CallTracerAnnotationInterface {  public:+  // Enum associated with types of Annotations.+  enum AnnotationType {",let's make this an `enum class`,X
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/33696,1266014448,2023-07-17T23:45:46Z,src/core/lib/channel/call_tracer.h,"@@ -49,11 +49,30 @@ namespace grpc_core { // The base class for all tracer implementations. class CallTracerAnnotationInterface {  public:+  // Enum associated with types of Annotations.+  enum AnnotationType {"," ""enum class"". I see it's already used elsewhere then no need to not use ""enum"" I think.(Removed the enum naming comment, found it's not nested.)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33696,1266156485,2023-07-18T03:34:20Z,src/core/lib/channel/call_tracer.h,"@@ -49,11 +49,30 @@ namespace grpc_core { // The base class for all tracer implementations. class CallTracerAnnotationInterface {  public:+  // Enum associated with types of Annotations.+  enum AnnotationType {+    kMetadataSizes,+    kDoNotUse_MustBeLast,+  };++  // Base class to define a new type of annotation.+  class Annotation {+   public:+    explicit Annotation(AnnotationType type) : type_(type) {}+    AnnotationType type() const { return type_; }+    virtual std::string ToString() const = 0;+    virtual ~Annotation() {}++   private:+    AnnotationType type_;+  };+   virtual ~CallTracerAnnotationInterface() {}   // Records an annotation on the call attempt.   // TODO(yashykt): If needed, extend this to attach attributes with   // annotations.   virtual void RecordAnnotation(absl::string_view annotation) = 0;+  virtual void RecordAnnotation(const Annotation& annotation) = 0;","@yousukseung this is not the enum, it's the enclosing class/interface",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33744,1267142007,2023-07-18T18:13:13Z,include/grpc/event_engine/event_engine.h,"@@ -397,8 +397,9 @@ class EventEngine : public std::enable_shared_from_this<EventEngine> {   virtual bool IsWorkerThread() = 0;    /// Creates and returns an instance of a DNSResolver, optionally configured by-  /// the \a options struct.-  virtual std::unique_ptr<DNSResolver> GetDNSResolver(+  /// the \a options struct. This method may return a non-OK status if an error+  /// occurred when creating the DNSResolver.+  virtual absl::StatusOr<std::unique_ptr<DNSResolver>> GetDNSResolver(","We can't return by value here, because `DNSResolver` is a base class, and we are going to be returning an implementation of a subclass, which will almost certainly have a different storage size.",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33638,1267244499,2023-07-18T19:50:58Z,src/core/tsi/ssl_transport_security.cc,"@@ -1538,15 +1539,40 @@ static tsi_result ssl_handshaker_next(tsi_handshaker* self,   // If there are received bytes, process them first.   tsi_ssl_handshaker* impl = reinterpret_cast<tsi_ssl_handshaker*>(self);   tsi_result status = TSI_OK;-  size_t bytes_consumed = received_bytes_size;   size_t bytes_written = 0;   if (received_bytes_size > 0) {-    status = ssl_handshaker_process_bytes_from_peer(impl, received_bytes,-                                                    &bytes_consumed, error);-    while (status == TSI_DRAIN_BUFFER) {-      status = ssl_handshaker_write_output_buffer(self, &bytes_written, error);-      if (status != TSI_OK) return status;-      status = ssl_handshaker_do_handshake(impl, error);+    unsigned char* remaining_bytes_to_write_to_network_io =","Agreed that the wording is a bit confusing. Let me clarify what's happening first: we're getting bytes from the peer, and writing these bytes to OpenSSL via the `BIO` object, and the name of this `BIO` object variable is `network_io`.I'm happy to send a follow-up PR to rename the `BIO` object variable (because it causes issues like this throughout this file), but I'd prefer to keep that change out-of-scope for this PR if it's OK.In the meantime, I've changed the variable name to something else to avoid confusion.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33638,1267247987,2023-07-18T19:55:18Z,src/core/tsi/ssl_transport_security.cc,"@@ -1541,23 +1541,20 @@ static tsi_result ssl_handshaker_next(tsi_handshaker* self,   tsi_result status = TSI_OK;   size_t bytes_written = 0;   if (received_bytes_size > 0) {-    unsigned char* remaining_bytes_to_write_to_network_io =+    unsigned char* remaining_bytes_to_write_to_openssl =",Do we actually need these two variables in the first place?  Can't we just modify the `received_bytes` and `received_bytes_size` variables as we consume the data?,X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33638,1267273022,2023-07-18T20:25:29Z,src/core/tsi/ssl_transport_security.cc,"@@ -1541,23 +1541,20 @@ static tsi_result ssl_handshaker_next(tsi_handshaker* self,   tsi_result status = TSI_OK;   size_t bytes_written = 0;   if (received_bytes_size > 0) {-    unsigned char* remaining_bytes_to_write_to_network_io =+    unsigned char* remaining_bytes_to_write_to_openssl =","`received_bytes_size` is needed later on when calculating the unused bytes, so we would at least need to copy the initial value of this argument. Rather than doing that, I'm leaning towards keeping the current version since I think it's more readable. More than happy to change it if you disagree though.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33671,1267350290,2023-07-18T22:14:06Z,src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb.cc,"@@ -1372,10 +1366,6 @@ ChannelArgs BuildBalancerChannelArgs(             // Strip out the service config, since we don't want the LB policy             // config specified for the parent channel to affect the LB channel.             .Remove(GRPC_ARG_SERVICE_CONFIG)-            // The channel arg for the server URI, since that will be different-            // for the LB channel than for the parent channel.  The client-            // channel factory will re-add this arg with the right value.-            .Remove(GRPC_ARG_SERVER_URI)","This is a bit tangential to the PR, but it seemed reasonable to clean it up, since I was looking at all occurences of this channel arg anyway.Basically, we used to use the C representation of channel args throughout C-core.  That representation essentially stored the args as a vector, so adding an arg did not replace any previous value of the arg; instead, it added a duplicate element to the vector, and the duplicate entry would almost certainly not actually be used, since code using the args would search through the vector from the start until they found the key they want, which would result in returning the original value, not the duplicate value.  So the code here needed to make sure that it didn't pass down this arg, lest the arg have the wrong value in the balancer channel.We have subsequently switched to a new internal representation of channel args that is essentially a map, so setting an arg will automatically replace any previous value of the arg.  And since the balancer channel will set the arg itself, that value will replace any value that we might pass in here, so it no longer matters whether we remove the arg here.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33749,1268519554,2023-07-19T18:36:35Z,bazel/grpc_build_system.bzl,"@@ -273,6 +274,20 @@ def ios_cc_test(             deps = ios_test_deps,         ) +def _update_platform_tags(tags, platforms):","nit: this is only for tests (e.g., `no_test_ios`), and it's only used for experiments. I'd suggest naming it `_update_experiments_platform_test_tags`",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33749,1268540095,2023-07-19T18:56:57Z,test/core/experiments/experiments_tag_test.cc,"@@ -0,0 +1,82 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include <string>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_split.h""+#include ""absl/strings/string_view.h""+#include ""gtest/gtest.h""++#include ""src/core/lib/config/config_vars.h""+#include ""src/core/lib/experiments/config.h""+#include ""test/core/experiments/fixtures/experiments.h""++#ifndef GRPC_EXPERIMENTS_ARE_FINAL++absl::StatusOr<bool> IsExperimentEnabledThroughFlag(+    std::string experiment_name) {+  for (auto experiment :+       absl::StrSplit(grpc_core::ConfigVars::Get().Experiments(), ',',+                      absl::SkipWhitespace())) {+    // Enable unless prefixed with '-' (=> disable).+    bool enable = true;+    if (experiment[0] == '-') {+      enable = false;+      experiment.remove_prefix(1);+    }+    // See if we can find the experiment in the list in this binary.+    if (experiment == experiment_name) {+      return enable;+    }+  }+  return absl::NotFoundError(""experiment not found"");+}++TEST(ExperimentsTestTagTest, CheckExperimentValuesTest) {+  auto status = IsExperimentEnabledThroughFlag(""test_experiment_1"");",See https://abseil.io/tips/181 for StatusOr naming guidelines.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33749,1268553932,2023-07-19T19:09:02Z,tools/codegen/core/experiments_compiler.py,"@@ -552,37 +552,34 @@ def GenTest(self, output_file):                 test_body += _EXPERIMENT_CHECK_TEXT(SnakeToPascal(exp.name))             print(_EXPERIMENTS_TEST_SKELETON(defs, test_body), file=C) -    def GenExperimentsBzl(self, output_file):+    def GenExperimentsBzl(self, mode, output_file):         if self._bzl_list_for_defaults is None:             return          bzl_to_tags_to_experiments = dict(-            (key, collections.defaultdict(list))-            for key in self._bzl_list_for_defaults.keys()-            if key is not None+            (",Python dict comprehensions can add some readability here. Something like this could work```from copy import copydefaults = {key: collections.defaultdict(list) for key in _bzl_list_for_defaults.keys()            if key is not None}bzl_to_tags_to_experiments = {platform: copy(defaults) for platform in _platforms_define.keys()}```,X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/33793,1269940223,2023-07-20T20:40:30Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/dns_resolver_ares.cc,"@@ -347,10 +347,15 @@ class AresClientChannelDNSResolverFactory : public ResolverFactory {   absl::string_view scheme() const override { return ""dns""; }    bool IsValidUri(const URI& uri) const override {-    if (absl::StripPrefix(uri.path(), ""/"").empty()) {+    absl::string_view path = absl::StripPrefix(uri.path(), ""/"");","Q: Is there some sort of ""utility"" package we could put code like this? 3x duplication pretty much guarantees the code will diverge. This code only depends on STL and ABSL so can go anywhere...",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270000664,2023-07-20T21:54:38Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,72 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <memory>+#include <string>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(+      absl::string_view crl_string);+  virtual ~Crl() = default;++ protected:+  Crl() = default;++ private:+  std::string raw_crl_;",I don't think we need this data member.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270001682,2023-07-20T21:56:18Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,72 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <memory>+#include <string>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(+      absl::string_view crl_string);+  virtual ~Crl() = default;++ protected:+  Crl() = default;++ private:+  std::string raw_crl_;+};++// Opaque representation of a Certificate+class Cert {+ public:+  static absl::StatusOr<std::unique_ptr<Cert>> Parse(+      absl::string_view cert_string);+  virtual ~Cert() = default;++ protected:+  Cert() = default;++ private:+  absl::string_view raw_cert_;+};++// The base class for CRL Provider implementations.+class CrlProvider {",This class needs a virtual dtor:```virtual ~CrlProvider() = default;```,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270002751,2023-07-20T21:58:06Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,72 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <memory>+#include <string>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(+      absl::string_view crl_string);+  virtual ~Crl() = default;++ protected:+  Crl() = default;++ private:+  std::string raw_crl_;+};++// Opaque representation of a Certificate+class Cert {+ public:+  static absl::StatusOr<std::unique_ptr<Cert>> Parse(+      absl::string_view cert_string);+  virtual ~Cert() = default;++ protected:+  Cert() = default;++ private:+  absl::string_view raw_cert_;+};++// The base class for CRL Provider implementations.+class CrlProvider {+ public:+  CrlProvider() {}+  // Get the CRL associated with a certificate. Read-only.+  virtual std::shared_ptr<Crl> GetCrl(const Cert& cert) = 0;+  virtual void CrlReadErrorCallback(absl::Status) = 0;","I don't think this method belongs on this interface.  This interface is methods that will be called by gRPC, but gRPC is never going to call this, because it's not doing the reading of the CRLs.I think the directory-watcher `CrlProvider` implementation will actually need to take this callback as a parameter when it is instantiated.  It can invoke the callback whenever there's a read error.  But this functionality is specific to that implementation; it's not part of the `CrlProvider` interface.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270005525,2023-07-20T22:03:13Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,72 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <memory>+#include <string>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(+      absl::string_view crl_string);+  virtual ~Crl() = default;++ protected:+  Crl() = default;++ private:+  std::string raw_crl_;+};++// Opaque representation of a Certificate+class Cert {","I don't understand the purpose of this class.  It's basically just a `string_view`, so why not just use that type directly instead of creating this wrapper?Stepping back, it might be useful to consider what we expect a `CrlProvider` implementation to do with this.  Presumably, it needs to parse the cert to find the issuer, so that it knows which CRL to return.  How do we expect it to do that without reaching into OpenSSL internals?  As an alternative, consider instead having this class provide an abstract interface to the attributes of the parsed certificate, so that the parsing can happen on the gRPC side and we can expose the parsed data without using OpenSSL types.  What fields of the cert is the provider likely to need to look at?  Those are the methods we should provide here.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270823574,2023-07-21T15:41:06Z,include/grpc/grpc_crl_provider.h,"@@ -38,32 +38,26 @@ class Crl {   protected:   Crl() = default;-- private:-  std::string raw_crl_; }; -// Opaque representation of a Certificate-class Cert {+// Information about a certificate to be used to fetch its associated CRL.+class CertificateInfo {  public:-  static absl::StatusOr<std::unique_ptr<Cert>> Parse(-      absl::string_view cert_string);-  virtual ~Cert() = default;+  explicit CertificateInfo(absl::string_view issuer) : issuer_(issuer) {}+  absl::string_view GetIssuer() { return issuer_; }   protected:-  Cert() = default;-  private:-  absl::string_view raw_cert_;+  std::string issuer_;","It's probably not necessary to store a copy of the string here, since this object will exist only during a single synchronous call to `GetCrl()`.  The gRPC code that constructs this `CertificateInfo` object will have its own copy of the cert info, so this can probably just contain a `string_view` -- or maybe it can even be a wrapper of some other object in the impl and can simply access the data directly from some other source.Anyway, I think these details belong in the impl, not in the API.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270828178,2023-07-21T15:45:51Z,test/core/security/grpc_crl_provider_test.cc,"@@ -0,0 +1,88 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include <memory>+#include <string>++#include <gtest/gtest.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/grpc_crl_provider.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/security/authorization/audit_logging.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++#define CRL_PATH ""test/core/tsi/test_creds/crl_data/crls/ab06acdd.r0""++namespace grpc_core {+namespace testing {++using experimental::CertificateInfo;+using experimental::Crl;+using experimental::CrlProvider;++namespace {++class TestCrlProvider : public experimental::CrlProvider {+ public:+  std::shared_ptr<Crl> GetCrl(const CertificateInfo& cert) { return test_crl_; }+  void SetCrl(absl::string_view crl_string) {+    absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+    if (result.ok()) {+      test_crl_ = *result;+    } else {+      test_crl_ = nullptr;+    }+  }++ private:+  std::shared_ptr<Crl> test_crl_;+};++class CrlProviderTest : public ::testing::Test {};","If you're not actually storing anything in the test class, then you don't need it in the first place.  You can remove this and change `TEST_F()` to just `TEST()` on line 69 below.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270832131,2023-07-21T15:49:31Z,test/core/security/grpc_crl_provider_test.cc,"@@ -0,0 +1,88 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include <memory>+#include <string>++#include <gtest/gtest.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/grpc_crl_provider.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/security/authorization/audit_logging.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++#define CRL_PATH ""test/core/tsi/test_creds/crl_data/crls/ab06acdd.r0""++namespace grpc_core {+namespace testing {++using experimental::CertificateInfo;+using experimental::Crl;+using experimental::CrlProvider;++namespace {++class TestCrlProvider : public experimental::CrlProvider {+ public:+  std::shared_ptr<Crl> GetCrl(const CertificateInfo& cert) { return test_crl_; }+  void SetCrl(absl::string_view crl_string) {+    absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+    if (result.ok()) {+      test_crl_ = *result;+    } else {+      test_crl_ = nullptr;+    }+  }++ private:+  std::shared_ptr<Crl> test_crl_;+};++class CrlProviderTest : public ::testing::Test {};++}  // namespace++TEST_F(CrlProviderTest, CrlProviderCanReadCrl) {","I'm not clear on what the purpose of this test is.  The only thing this PR actually provides an implementation of so far is the `Crl` class, and you are actually calling `Crl::Parse()`, which is useful to test.  But we're doing that in a fairly indirect way -- everything else in this PR is just interfaces so far, no implementation, and this test is creating its own test impls and then testing them, which doesn't seem very useful.It seems like we can just replace this test with a direct test of `Crl::Parse()`.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1270851721,2023-07-21T16:10:03Z,test/core/security/grpc_crl_provider_test.cc,"@@ -0,0 +1,88 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include <memory>+#include <string>++#include <gtest/gtest.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/grpc_crl_provider.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/security/authorization/audit_logging.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++#define CRL_PATH ""test/core/tsi/test_creds/crl_data/crls/ab06acdd.r0""++namespace grpc_core {+namespace testing {++using experimental::CertificateInfo;+using experimental::Crl;+using experimental::CrlProvider;++namespace {++class TestCrlProvider : public experimental::CrlProvider {+ public:+  std::shared_ptr<Crl> GetCrl(const CertificateInfo& cert) { return test_crl_; }+  void SetCrl(absl::string_view crl_string) {+    absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+    if (result.ok()) {",Code changed so I believe this is no longer relevant,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270880823,2023-07-21T16:42:57Z,include/grpc/grpc_crl_provider.h,"@@ -38,32 +38,26 @@ class Crl {   protected:   Crl() = default;-- private:-  std::string raw_crl_; }; -// Opaque representation of a Certificate-class Cert {+// Information about a certificate to be used to fetch its associated CRL.+class CertificateInfo {  public:-  static absl::StatusOr<std::unique_ptr<Cert>> Parse(-      absl::string_view cert_string);-  virtual ~Cert() = default;+  explicit CertificateInfo(absl::string_view issuer) : issuer_(issuer) {}+  absl::string_view GetIssuer() { return issuer_; }   protected:","No need to define the ctor at all; it will get one by default, since there are no other ctors defined.  And there's no need to make the ctor protected if the class has an abstract virtual method, because then there's no way for anything but a subclass to instantiate it anyway.I think the entire `protected` section can be removed.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1270881062,2023-07-21T16:43:15Z,include/grpc/grpc_crl_provider.h,"@@ -43,12 +43,10 @@ class Crl { // Information about a certificate to be used to fetch its associated CRL. class CertificateInfo {",This class needs a virtual dtor.,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/33797,1271158615,2023-07-21T22:58:34Z,tools/distrib/python/xds_protos/build.py,"@@ -19,19 +19,27 @@ from grpc_tools import protoc import pkg_resources ++def localize_path(p):+    return os.path.join(*p.split(""/""))++ # We might not want to compile all the protos EXCLUDE_PROTO_PACKAGES_LIST = [-    # Requires extra dependency to Prometheus protos-    ""envoy/service/metrics/v2"",-    ""envoy/service/metrics/v3"",-    ""envoy/service/metrics/v4alpha"",+    localize_path(p)+    for p in [+        # Requires extra dependency to Prometheus protos+        ""envoy/service/metrics/v2"",+        ""envoy/service/metrics/v3"",+        ""envoy/service/metrics/v4alpha"",+    ]","```suggestion    for p in (        # Requires extra dependency to Prometheus protos        ""envoy/service/metrics/v2"",        ""envoy/service/metrics/v3"",        ""envoy/service/metrics/v4alpha"",    )```nit",
122473768,alto-ruby,https://api.github.com/repos/grpc/grpc/pulls/33565,1271764265,2023-07-24T05:32:04Z,src/ruby/lib/grpc/generic/active_call.rb,"@@ -169,10 +169,13 @@ def receive_and_check_status       batch_result = @call.run_batch(ops)       unless @metadata_received         @call.metadata = batch_result.metadata-        @metadata_received = true       end       set_input_stream_done       attach_status_results_and_complete_call(batch_result)+    ensure+      # Ensure we don't attempt to request the initial metadata again+      # in case an exception occurs.+      @metadata_received = true","This becomes the opposite that of the original report that if `run_batch` throws before sent RECV_INITIAL_METADATA, we are setting metadata_received anyways.Ideally we need to c-core to propagate the error from [completion queue](https://github.com/grpc/grpc/blob/v1.56.0/src/core/lib/surface/completion_queue.cc#L773) so here we know whether to metadata_received or not.Given  that's a fairly large change in c-core, I incline to accept this to unblock the customer as I mentioned in the other comment in the issue, missing a RECV_INITIAL_METADATA doesn't really cause problems (for now at least).@apolcyn Do you have any other concerns?",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33827,1272501593,2023-07-24T16:35:56Z,test/core/experiments/BUILD,"@@ -53,6 +53,7 @@ grpc_cc_test(         ""gtest"",         ""absl/strings"",         ""absl/status"",+        ""absl/status:statusor"",","I suggest adding ""test/core/experiments"" to this list, to enable build dependency checking https://github.com/grpc/grpc/blob/457fd65b93cd0c2932c24b0b0f2699e854b68fa7/tools/distrib/fix_build_deps.py#L378-L394",
11522026,ralphchung,https://api.github.com/repos/grpc/grpc/pulls/33257,1272801628,2023-07-24T22:03:03Z,src/core/lib/transport/promise_endpoint.h,"@@ -0,0 +1,297 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H+#define GRPC_SRC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <stddef.h>+#include <stdint.h>++#include <functional>+#include <memory>+#include <utility>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/slice_buffer.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""++namespace grpc_core {++// Wrapper around event engine endpoint that provides a promise like API.+class PromiseEndpoint {+ public:+  PromiseEndpoint(+      std::unique_ptr<grpc_event_engine::experimental::EventEngine::Endpoint>+          endpoint,+      SliceBuffer already_received);+  ~PromiseEndpoint();++  // Returns a promise that resolves to a `absl::Status` indicating the result+  // of the write operation.+  //+  // Concurrent writes are not supported, which means callers should not call+  // `Write()` before the previous write finishes. Doing that results in+  // undefined behavior.+  auto Write(SliceBuffer data) {+    {+      MutexLock lock(&write_mutex_);+      // Assert previous write finishes.+      GPR_ASSERT(!write_result_.has_value());+      // TODO(ladynana): Replace this with `SliceBufferCast<>` when it is+      // available.+      grpc_slice_buffer_swap(write_buffer_.c_slice_buffer(),+                             data.c_slice_buffer());+    }+    // If `Write()` returns true immediately, the callback will not be called.+    // We still need to call our callback to pick up the result.+    if (endpoint_->Write(std::bind(&PromiseEndpoint::WriteCallback, this,+                                   std::placeholders::_1),+                         &write_buffer_,+                         nullptr /* uses default arguments */)) {+      WriteCallback(absl::OkStatus());+    }+    return [this]() -> Poll<absl::Status> {+      MutexLock lock(&write_mutex_);+      // If current write isn't finished return `Pending()`, else return write+      // result.+      if (!write_result_.has_value()) {+        write_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else {+        const auto ret = *write_result_;+        write_result_.reset();+        return ret;+      }+    };+  }++  // Returns a promise that resolves to `SliceBuffer` with+  // `num_bytes` bytes.+  //+  // Concurrent reads are not supported, which means callers should not call+  // `Read()` before the previous read finishes. Doing that results in+  // undefined behavior.+  auto Read(size_t num_bytes) {+    ReleasableMutexLock lock(&read_mutex_);+    // Assert previous read finishes.+    GPR_ASSERT(!read_result_.has_value());+    // Should not have pending reads.+    GPR_ASSERT(pending_read_buffer_.Count() == 0u);+    if (read_buffer_.Length() < num_bytes) {+      lock.Release();+      // Set read args with hinted bytes.+      grpc_event_engine::experimental::EventEngine::Endpoint::ReadArgs+          read_args;+      read_args.read_hint_bytes = num_bytes;+      // If `Read()` returns true immediately, the callback will not be+      // called. We still need to call our callback to pick up the result and+      // maybe do further reads.+      if (endpoint_->Read(std::bind(&PromiseEndpoint::ReadCallback, this,+                                    std::placeholders::_1, num_bytes,+                                    absl::nullopt /* uses default arguments */),","The current implementation makes `requested_read_args` in `PromiseEndpoint::ReadCallback()` useless. We probably should consider cleaning it up.The role of `requested_read_args` in the prototype PR is based on the assumption that the `num_byte` in this function could be large so that a single call to `endpoint_->Read()` will not be enough in most cases. Smaller `num_byte` should call `ReadSlice()` instead. The argument `requested_read_args` is the only difference for `Read()` and `ReadSlice()` when creating the lambda in the prototype PR.Seeing the implementation here, I am a little confused of the difference between `Read()` and `ReadSlice()`.",X
31627465,nanahpang,https://api.github.com/repos/grpc/grpc/pulls/33257,1272842876,2023-07-24T23:10:01Z,src/core/lib/transport/promise_endpoint.h,"@@ -0,0 +1,297 @@+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H+#define GRPC_SRC_CORE_LIB_TRANSPORT_PROMISE_ENDPOINT_H++#include <grpc/support/port_platform.h>++#include <stddef.h>+#include <stdint.h>++#include <functional>+#include <memory>+#include <utility>++#include ""absl/base/thread_annotations.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/types/optional.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/event_engine/slice.h>+#include <grpc/event_engine/slice_buffer.h>+#include <grpc/slice_buffer.h>+#include <grpc/support/log.h>++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""++namespace grpc_core {++// Wrapper around event engine endpoint that provides a promise like API.+class PromiseEndpoint {+ public:+  PromiseEndpoint(+      std::unique_ptr<grpc_event_engine::experimental::EventEngine::Endpoint>+          endpoint,+      SliceBuffer already_received);+  ~PromiseEndpoint();++  // Returns a promise that resolves to a `absl::Status` indicating the result+  // of the write operation.+  //+  // Concurrent writes are not supported, which means callers should not call+  // `Write()` before the previous write finishes. Doing that results in+  // undefined behavior.+  auto Write(SliceBuffer data) {+    {+      MutexLock lock(&write_mutex_);+      // Assert previous write finishes.+      GPR_ASSERT(!write_result_.has_value());+      // TODO(ladynana): Replace this with `SliceBufferCast<>` when it is+      // available.+      grpc_slice_buffer_swap(write_buffer_.c_slice_buffer(),+                             data.c_slice_buffer());+    }+    // If `Write()` returns true immediately, the callback will not be called.+    // We still need to call our callback to pick up the result.+    if (endpoint_->Write(std::bind(&PromiseEndpoint::WriteCallback, this,+                                   std::placeholders::_1),+                         &write_buffer_,+                         nullptr /* uses default arguments */)) {+      WriteCallback(absl::OkStatus());+    }+    return [this]() -> Poll<absl::Status> {+      MutexLock lock(&write_mutex_);+      // If current write isn't finished return `Pending()`, else return write+      // result.+      if (!write_result_.has_value()) {+        write_waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      } else {+        const auto ret = *write_result_;+        write_result_.reset();+        return ret;+      }+    };+  }++  // Returns a promise that resolves to `SliceBuffer` with+  // `num_bytes` bytes.+  //+  // Concurrent reads are not supported, which means callers should not call+  // `Read()` before the previous read finishes. Doing that results in+  // undefined behavior.+  auto Read(size_t num_bytes) {+    ReleasableMutexLock lock(&read_mutex_);+    // Assert previous read finishes.+    GPR_ASSERT(!read_result_.has_value());+    // Should not have pending reads.+    GPR_ASSERT(pending_read_buffer_.Count() == 0u);+    if (read_buffer_.Length() < num_bytes) {+      lock.Release();+      // Set read args with hinted bytes.+      grpc_event_engine::experimental::EventEngine::Endpoint::ReadArgs+          read_args;+      read_args.read_hint_bytes = num_bytes;+      // If `Read()` returns true immediately, the callback will not be+      // called. We still need to call our callback to pick up the result and+      // maybe do further reads.+      if (endpoint_->Read(std::bind(&PromiseEndpoint::ReadCallback, this,+                                    std::placeholders::_1, num_bytes,+                                    absl::nullopt /* uses default arguments */),","Oh, I see what you meant now. Yeah, the parameter of `requested_read_args` in ReadCallback isn't useful anymore, I will clean it up.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33233,1274120186,2023-07-25T21:05:54Z,src/core/lib/event_engine/cf_engine/dns_service_resolver.h,"@@ -0,0 +1,112 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_DNS_SERVICE_RESOLVER_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_CF_ENGINE_DNS_SERVICE_RESOLVER_H+#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include <CoreFoundation/CoreFoundation.h>+#include <dns_sd.h>++#include ""absl/container/flat_hash_map.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/cf_engine/cf_engine.h""+#include ""src/core/lib/gprpp/ref_counted.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""++namespace grpc_event_engine {+namespace experimental {++class DNSServiceResolverImpl+    : public grpc_core::RefCounted<DNSServiceResolverImpl> {+  struct DNSServiceRequest {+    EventEngine::DNSResolver::LookupHostnameCallback on_resolve_;",style guide https://google.github.io/styleguide/cppguide.html#Variable_Names: struct variable naming should not end in `_`.,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33871,1274222537,2023-07-25T23:49:40Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc,"@@ -98,12 +99,71 @@ class GrpcPolledFdPosix : public GrpcPolledFd {  class GrpcPolledFdFactoryPosix : public GrpcPolledFdFactory {  public:+  ~GrpcPolledFdFactoryPosix() {",Seems like the `GrpcPolledFdFactoryPosix` object needs to outlive the [ares_destroy](https://github.com/grpc/grpc/blob/master/src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.cc#L210) call? Is it guaranteed?,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/33442,1274232964,2023-07-26T00:12:58Z,src/python/grpcio/grpc/_server.py,"@@ -569,7 +569,7 @@ def _call_behavior(                         details = (                             ""Calling application raised unprintable Exception!""                         )-                        traceback.print_exc()+                    traceback.print_exc()                     _LOGGER.exception(details)","Sure, since we're already logging printable exceptions, I'll just add `_LOGGER` support for un-printable exceptions.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/33871,1274236247,2023-07-26T00:21:16Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc,"@@ -98,12 +99,71 @@ class GrpcPolledFdPosix : public GrpcPolledFd {  class GrpcPolledFdFactoryPosix : public GrpcPolledFdFactory {  public:+  ~GrpcPolledFdFactoryPosix() {",Yes that's guaranteed because:- `GrpcPolledFdFactoryPosix` is [owned](https://github.com/grpc/grpc/blob/498fc99479a01177aa2ad257f1390521495b0788/src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.cc#L1290) by the request object- the request object is only deleted after the query completes- the query only completes after all `GrpcPolledFd` object have been destroyed,
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/33233,1274325619,2023-07-26T03:09:02Z,test/core/event_engine/cf/cf_engine_test.cc,"@@ -80,6 +82,211 @@ TEST(CFEventEngineTest, TestConnectionCancelled) {   client_signal.WaitForNotification(); } +namespace {+std::vector<std::string> ResolvedAddressesToStrings(+    const std::vector<EventEngine::ResolvedAddress> addresses) {+  std::vector<std::string> ip_strings;+  std::transform(addresses.cbegin(), addresses.cend(),+                 std::back_inserter(ip_strings), [](auto const& address) {+                   return ResolvedAddressToString(address).value_or(""ERROR"");+                 });+  return ip_strings;+}+}  // namespace++TEST(CFEventEngineTest, CFEventEngineTest_TestCreateDNSResolver_Test) {+  grpc_core::MemoryQuota memory_quota(""cf_engine_test"");+  auto cf_engine = std::make_shared<CFEventEngine>();++  EXPECT_TRUE(cf_engine->GetDNSResolver({}).status().ok());+  EXPECT_TRUE(cf_engine->GetDNSResolver({.dns_server = """"}).status().ok());+  EXPECT_EQ(+      cf_engine->GetDNSResolver({.dns_server = ""8.8.8.8""}).status().code(),+      absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(+      cf_engine->GetDNSResolver({.dns_server = ""8.8.8.8:53""}).status().code(),+      absl::StatusCode::kInvalidArgument);+  EXPECT_EQ(+      cf_engine->GetDNSResolver({.dns_server = ""invalid""}).status().code(),+      absl::StatusCode::kInvalidArgument);+}++TEST(CFEventEngineTest, TestResolveLocalhost) {+  grpc_core::Notification resolve_signal;++  auto cf_engine = std::make_shared<CFEventEngine>();+  auto dns_resolver = cf_engine->GetDNSResolver({});++  dns_resolver.value()->LookupHostname(+      [&resolve_signal](auto result) {+        EXPECT_TRUE(result.status().ok());+        EXPECT_THAT(ResolvedAddressesToStrings(result.value()),+                    testing::UnorderedElementsAre(""127.0.0.1:80"", ""[::1]:80""));++        resolve_signal.Notify();+      },+      ""localhost"", ""80"");++  resolve_signal.WaitForNotification();+}++TEST(CFEventEngineTest, TestResolveRemote) {+  grpc_core::Notification resolve_signal;++  auto cf_engine = std::make_shared<CFEventEngine>();+  auto dns_resolver = cf_engine->GetDNSResolver({});++  dns_resolver.value()->LookupHostname(+      [&resolve_signal](auto result) {+        EXPECT_TRUE(result.status().ok());+        EXPECT_THAT(ResolvedAddressesToStrings(result.value()),+                    testing::UnorderedElementsAre(""127.0.0.1:80"", ""[::1]:80""));++        resolve_signal.Notify();+      },+      ""localtest.me:80"", ""443"");","Yeah, but specifying a local dns server is not supported for this implementation.I guess it's less likely having a DNS issue comparing to other external services (homebrew for instance) we are using to setup the environment.We used it for [iOS PerfTest](https://github.com/grpc/grpc/blob/v1.56.0/src/objective-c/tests/PerfTests/PerfTests.m#L363) for a while which was pretty stable.So I suppose it's better have test coverage? Or are there any alternative Google services?Stress runs should be fine as I imagine it'll hit the cache.",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33871,1274365269,2023-07-26T04:37:51Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_ev_driver_posix.cc,"@@ -98,12 +106,93 @@ class GrpcPolledFdPosix : public GrpcPolledFd {  class GrpcPolledFdFactoryPosix : public GrpcPolledFdFactory {  public:+  ~GrpcPolledFdFactoryPosix() {+    for (auto& fd : owned_fds_) {+      close(fd);+    }+  }+   GrpcPolledFd* NewGrpcPolledFdLocked(       ares_socket_t as, grpc_pollset_set* driver_pollset_set) override {+    auto insert_result = owned_fds_.insert(as);+    GPR_ASSERT(insert_result.second);     return new GrpcPolledFdPosix(as, driver_pollset_set);   } -  void ConfigureAresChannelLocked(ares_channel /*channel*/) override {}+  void ConfigureAresChannelLocked(ares_channel channel) override {+    ares_set_socket_functions(channel, &kSockFuncs, this);+  }++ private:+  /// Overridden socket API for c-ares+  static ares_socket_t Socket(int af, int type, int protocol,+                              void* /*user_data*/) {+    int fd = socket(af, type, protocol);+    if (fd < 0) return fd;+    /* Because we're using socket API overrides, c-ares won't+     * perform its typical configuration on the socket. See+     * https://github.com/c-ares/c-ares/blob/bad62225b7f6b278b92e8e85a255600b629ef517/src/lib/ares_process.c#L1018.+     * So we copy the default settings that c-ares would+     * normally apply on posix platforms:+     *   - non-blocking+     *   - cloexec flag+     *   - disable nagle */+    grpc_error_handle err;+    err = grpc_set_socket_nonblocking(fd, true);+    if (!err.ok()) goto error;+    err = grpc_set_socket_cloexec(fd, true);+    if (!err.ok()) goto error;+    if (type == SOCK_STREAM) {+      err = grpc_set_socket_low_latency(fd, true);+      if (!err.ok()) goto error;+    }+    return fd;+  error:+    close(fd);+    return -1;+  }++  /// Overridden connect API for c-ares+  static int Connect(ares_socket_t as, const struct sockaddr* target,+                     ares_socklen_t target_len, void* /*user_data*/) {+    return connect(as, target, target_len);+  }++  /// Overridden writev API for c-ares+  static ares_ssize_t WriteV(ares_socket_t as, const struct iovec* iov,+                             int iovec_count, void* /*user_data*/) {+    return writev(as, iov, iovec_count);+  }++  /// Overridden recvfrom API for c-ares+  static ares_ssize_t RecvFrom(ares_socket_t as, void* data, size_t data_len,+                               int flags, struct sockaddr* from,+                               ares_socklen_t* from_len, void* /*user_data*/) {+    return recvfrom(as, data, data_len, flags, from, from_len);+  }++  /// Overridden close API for c-ares+  static int Close(ares_socket_t as, void* user_data) {+    GrpcPolledFdFactoryPosix* self =+        static_cast<GrpcPolledFdFactoryPosix*>(user_data);+    if (self->owned_fds_.find(as) == self->owned_fds_.end()) {+      // c-ares owns this fd, grpc has never seen it+      return close(as);+    }+    return 0;+  }++  const struct ares_socket_functions kSockFuncs = {+      &GrpcPolledFdFactoryPosix::Socket /* socket */,+      &GrpcPolledFdFactoryPosix::Close /* close */,+      &GrpcPolledFdFactoryPosix::Connect /* connect */,+      &GrpcPolledFdFactoryPosix::RecvFrom /* recvfrom */,+      &GrpcPolledFdFactoryPosix::WriteV /* writev */,+  };++  // fds that are used/owned by grpc - we (grpc) will close them rather than+  // c-ares+  std::set<ares_socket_t> owned_fds_;",nit: maybe to use `std::unordered_set<ares_socket_t>` since it has on-average constant time complexity on search and insertion and also the ordering is not needed here.,
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/33233,1274371288,2023-07-26T04:49:49Z,src/core/lib/event_engine/cf_engine/dns_service_resolver.cc,"@@ -0,0 +1,205 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""absl/strings/str_format.h""++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/event_engine/cf_engine/dns_service_resolver.h""+#include ""src/core/lib/event_engine/posix_engine/lockfree_event.h""+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/host_port.h""++namespace grpc_event_engine {+namespace experimental {++void DNSServiceResolverImpl::LookupHostname(+    EventEngine::DNSResolver::LookupHostnameCallback on_resolve,+    absl::string_view name, absl::string_view default_port) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::LookupHostname: name: %.*s, default_port: %.*s, ""+      ""this: %p"",+      static_cast<int>(name.length()), name.data(),+      static_cast<int>(default_port.length()), default_port.data(), this);++  absl::string_view host;+  absl::string_view port_string;+  if (!grpc_core::SplitHostPort(name, &host, &port_string)) {+    on_resolve(+        absl::InvalidArgumentError(absl::StrCat(""Unparseable name: "", name)));+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_string.empty()) {+    if (default_port.empty()) {+      on_resolve(absl::InvalidArgumentError(absl::StrFormat(+          ""No port in name %s or default_port argument"", name)));+      return;+    }+    port_string = default_port;+  }++  int port = 0;+  if (port_string == ""http"") {+    port = 80;+  } else if (port_string == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_string, &port)) {+    on_resolve(absl::InvalidArgumentError(+        absl::StrCat(""Failed to parse port in name: "", name)));+    return;+  }++  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               true /* log errors */) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               true /* log errors */)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    on_resolve(std::move(result));+    return;+  }++  DNSServiceRef sdRef;+  auto host_string = std::string{host};+  auto error = DNSServiceGetAddrInfo(+      &sdRef, kDNSServiceFlagsTimeout | kDNSServiceFlagsReturnIntermediates, 0,+      kDNSServiceProtocol_IPv4 | kDNSServiceProtocol_IPv6, host_string.c_str(),+      &DNSServiceResolverImpl::ResolveCallback, this /* do not Ref */);++  if (error != kDNSServiceErr_NoError) {+    on_resolve(absl::UnknownError(+        absl::StrFormat(""DNSServiceGetAddrInfo failed with error:%d"", error)));+    return;+  }++  grpc_core::ReleasableMutexLock lock(&request_mu_);++  error = DNSServiceSetDispatchQueue(sdRef, queue_);+  if (error != kDNSServiceErr_NoError) {+    on_resolve(absl::UnknownError(absl::StrFormat(+        ""DNSServiceSetDispatchQueue failed with error:%d"", error)));+    return;+  }++  requests_.try_emplace(+      sdRef, DNSServiceRequest{+                 std::move(on_resolve), static_cast<uint16_t>(port), {}});+}++/* static */+void DNSServiceResolverImpl::ResolveCallback(+    DNSServiceRef sdRef, DNSServiceFlags flags, uint32_t interfaceIndex,+    DNSServiceErrorType errorCode, const char* hostname,+    const struct sockaddr* address, uint32_t ttl, void* context) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::ResolveCallback: sdRef: %p, flags: %x, ""+      ""interface: %d, errorCode: %d, hostname: %s, addressFamily: %d, ttl: ""+      ""%d, ""+      ""this: %p"",+      sdRef, flags, interfaceIndex, errorCode, hostname, address->sa_family,+      ttl, context);++  // no need to increase refcount here, since ResolveCallback and Shutdown is+  // called from the serial queue and it is guarenteed that it won't be called+  // after the sdRef is deallocated+  auto that = static_cast<DNSServiceResolverImpl*>(context);++  grpc_core::ReleasableMutexLock lock(&that->request_mu_);+  auto request_it = that->requests_.find(sdRef);+  GPR_ASSERT(request_it != that->requests_.end());+  auto& request = request_it->second;++  if (errorCode != kDNSServiceErr_NoError &&+      errorCode != kDNSServiceErr_NoSuchRecord) {+    request.on_resolve_(absl::UnknownError(absl::StrFormat(+        ""address lookup failed for %s: errorCode: %d"", hostname, errorCode)));+    that->requests_.erase(request_it);+    DNSServiceRefDeallocate(sdRef);+    return;+  }++  // set received ipv4 or ipv6 response, even for kDNSServiceErr_NoSuchRecord+  if (address->sa_family == AF_INET) {+    request.has_ipv4_response_ = true;+  } else if (address->sa_family == AF_INET6) {+    request.has_ipv6_response_ = true;+  }++  // collect results if there is no error (not kDNSServiceErr_NoSuchRecord)+  if (errorCode == kDNSServiceErr_NoError) {+    request.result_.emplace_back(address, address->sa_len);+    auto& resolved_address = request.result_.back();+    if (address->sa_family == AF_INET) {+      ((struct sockaddr_in*)resolved_address.address())->sin_port =","The cast you're talking about is pretty common already.https://github.com/grpc/grpc/blob/498fc99479a01177aa2ad257f1390521495b0788/src/core/lib/event_engine/tcp_socket_utils.cc#L223-L224There is a clang tidy check enabled to try to prevent C-style casts from ending up in the codebase. I'm guessing tidy does not run on iOS code, but we should try to avoid them regardless. https://clang.llvm.org/extra/clang-tidy/checks/google/readability-casting.htmlSee ec0b88a5d73445ce5e6ff63c4691956bfe37e57f  and 2ff84ed8c2cb272b26766039d5bb07b009df2617 and d2bff16c25d7c207ef0afb6844fc50f567a2b36d and e0d8c498a60be0b5b5891e280bd441ec4a9d0785 for some of the work done here.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33894,1276567712,2023-07-27T16:53:55Z,test/core/end2end/tests/no_logging.cc,"@@ -139,6 +139,12 @@ void SimpleRequest(CoreEnd2endTest& test) { }  CORE_END2END_TEST(NoLoggingTest, NoLoggingTest) {+// TODO(hork): remove when the listener flake is identified+#ifdef GPR_WINDOWS+  if (IsEventEngineListenerEnabled()) {+    return;","GTEST_SKIP() << ""not for windows + event engine listener"";would probably be preferred",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33891,1276639415,2023-07-27T18:03:00Z,src/python/grpcio_tests/tests_aio/unit/aio_rpc_error_test.py,"@@ -52,6 +53,28 @@ def test_attributes(self):             aio_rpc_error.debug_error_string(), _TEST_DEBUG_ERROR_STRING         ) +    def test_pickle(self):+        aio_rpc_error = AioRpcError(+            grpc.StatusCode.CANCELLED,+            initial_metadata=_TEST_INITIAL_METADATA,+            trailing_metadata=_TEST_TRAILING_METADATA,+            details=""details"",+            debug_error_string=_TEST_DEBUG_ERROR_STRING,+        )+        dump_error = pickle.dumps(aio_rpc_error)+        loaded_error = pickle.loads(dump_error)+        self.assertEqual(loaded_error.code(), grpc.StatusCode.CANCELLED)","Nit: I think `self.assertEqual(aio_rpc_error, loaded_error)` should be good enough. The default `__eq__` implementation will check all members and if we add new members, this test won't have to be updated along with it.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33561,1277958525,2023-07-28T18:40:02Z,src/python/grpcio_tests/tests/observability/_observability_test.py,"@@ -413,6 +445,41 @@ def _validate_spans(             self.assertTrue(prefix_exist)  +def unary_unary_call(port, metadata=None):+    with grpc.insecure_channel(f""localhost:{port}"") as channel:+        multi_callable = channel.unary_unary(_UNARY_UNARY)+        if metadata:",Nit: You don't need the conditional. You can just do `metadata = metadata or ()`,
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/33233,1278152848,2023-07-28T23:03:06Z,src/core/lib/event_engine/cf_engine/dns_service_resolver.cc,"@@ -0,0 +1,222 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""absl/strings/str_format.h""++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/event_engine/cf_engine/dns_service_resolver.h""+#include ""src/core/lib/event_engine/posix_engine/lockfree_event.h""+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/host_port.h""++namespace grpc_event_engine {+namespace experimental {++void DNSServiceResolverImpl::LookupHostname(+    EventEngine::DNSResolver::LookupHostnameCallback on_resolve,+    absl::string_view name, absl::string_view default_port) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::LookupHostname: name: %.*s, default_port: %.*s, ""+      ""this: %p"",+      static_cast<int>(name.length()), name.data(),+      static_cast<int>(default_port.length()), default_port.data(), this);++  absl::string_view host;+  absl::string_view port_string;+  if (!grpc_core::SplitHostPort(name, &host, &port_string)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(+                      absl::StrCat(""Unparseable name: "", name))]() mutable {+      on_resolve(status);+    });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_string.empty()) {+    if (default_port.empty()) {+      engine_->Run([on_resolve = std::move(on_resolve),+                    status = absl::InvalidArgumentError(absl::StrFormat(+                        ""No port in name %s or default_port argument"",+                        name))]() mutable { on_resolve(std::move(status)); });+      return;+    }+    port_string = default_port;+  }++  int port = 0;+  if (port_string == ""http"") {+    port = 80;+  } else if (port_string == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_string, &port)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(absl::StrCat(+                      ""Failed to parse port in name: "", name))]() mutable {+      on_resolve(std::move(status));+    });+    return;+  }++  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    engine_->Run([on_resolve = std::move(on_resolve),+                  result = std::move(result)]() mutable {+      on_resolve(std::move(result));+    });+    return;+  }++  DNSServiceRef sdRef;+  auto host_string = std::string{host};+  auto error = DNSServiceGetAddrInfo(+      &sdRef, kDNSServiceFlagsTimeout | kDNSServiceFlagsReturnIntermediates, 0,+      kDNSServiceProtocol_IPv4 | kDNSServiceProtocol_IPv6, host_string.c_str(),+      &DNSServiceResolverImpl::ResolveCallback, this /* do not Ref */);++  if (error != kDNSServiceErr_NoError) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::UnknownError(absl::StrFormat(+                      ""DNSServiceGetAddrInfo failed with error:%d"",+                      error))]() mutable { on_resolve(std::move(status)); });+    return;+  }++  grpc_core::ReleasableMutexLock lock(&request_mu_);++  error = DNSServiceSetDispatchQueue(sdRef, queue_);+  if (error != kDNSServiceErr_NoError) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::UnknownError(absl::StrFormat(+                      ""DNSServiceSetDispatchQueue failed with error:%d"",+                      error))]() mutable { on_resolve(std::move(status)); });+    return;+  }++  requests_.try_emplace(+      sdRef, DNSServiceRequest{+                 std::move(on_resolve), static_cast<uint16_t>(port), {}});+}++/* static */+void DNSServiceResolverImpl::ResolveCallback(+    DNSServiceRef sdRef, DNSServiceFlags flags, uint32_t interfaceIndex,+    DNSServiceErrorType errorCode, const char* hostname,+    const struct sockaddr* address, uint32_t ttl, void* context) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::ResolveCallback: sdRef: %p, flags: %x, ""+      ""interface: %d, errorCode: %d, hostname: %s, addressFamily: %d, ttl: ""+      ""%d, ""+      ""this: %p"",+      sdRef, flags, interfaceIndex, errorCode, hostname, address->sa_family,+      ttl, context);++  // no need to increase refcount here, since ResolveCallback and Shutdown is+  // called from the serial queue and it is guarenteed that it won't be called+  // after the sdRef is deallocated+  auto that = static_cast<DNSServiceResolverImpl*>(context);++  grpc_core::ReleasableMutexLock lock(&that->request_mu_);+  auto request_it = that->requests_.find(sdRef);+  GPR_ASSERT(request_it != that->requests_.end());+  auto& request = request_it->second;++  if (errorCode != kDNSServiceErr_NoError &&+      errorCode != kDNSServiceErr_NoSuchRecord) {+    request.on_resolve(absl::UnknownError(absl::StrFormat(+        ""address lookup failed for %s: errorCode: %d"", hostname, errorCode)));+    that->requests_.erase(request_it);+    DNSServiceRefDeallocate(sdRef);+    return;+  }++  // set received ipv4 or ipv6 response, even for kDNSServiceErr_NoSuchRecord+  if (address->sa_family == AF_INET) {+    request.has_ipv4_response = true;+  } else if (address->sa_family == AF_INET6) {+    request.has_ipv6_response = true;+  }++  // collect results if there is no error (not kDNSServiceErr_NoSuchRecord)+  if (errorCode == kDNSServiceErr_NoError) {+    request.result.emplace_back(address, address->sa_len);+    auto& resolved_address = request.result.back();+    if (address->sa_family == AF_INET) {+      (const_cast<sockaddr_in*>(+           reinterpret_cast<const sockaddr_in*>(resolved_address.address())))+          ->sin_port = htons(request.port);+    } else if (address->sa_family == AF_INET6) {+      (const_cast<sockaddr_in6*>(+           reinterpret_cast<const sockaddr_in6*>(resolved_address.address())))+          ->sin6_port = htons(request.port);+    }++    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSServiceResolverImpl::ResolveCallback: ""+        ""sdRef: %p, hostname: %s, addressPort: %s, this: %p"",+        sdRef, hostname,+        ResolvedAddressToString(resolved_address).value_or(""ERROR"").c_str(),+        context);+  }++  if (!(flags & kDNSServiceFlagsMoreComing) && request.has_ipv4_response &&+      request.has_ipv6_response) {+    if (request.result.empty()) {+      request.on_resolve(absl::NotFoundError(absl::StrFormat(+          ""address lookup failed for %s: Domain name not found"", hostname)));",Would it be cleaner to condition on `kDNSServiceErr_NoSuchRecord rather than request.result.empty()?,X
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/33233,1279890820,2023-07-31T21:23:01Z,src/core/lib/event_engine/cf_engine/dns_service_resolver.cc,"@@ -0,0 +1,222 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""absl/strings/str_format.h""++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/event_engine/cf_engine/dns_service_resolver.h""+#include ""src/core/lib/event_engine/posix_engine/lockfree_event.h""+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/host_port.h""++namespace grpc_event_engine {+namespace experimental {++void DNSServiceResolverImpl::LookupHostname(+    EventEngine::DNSResolver::LookupHostnameCallback on_resolve,+    absl::string_view name, absl::string_view default_port) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::LookupHostname: name: %.*s, default_port: %.*s, ""+      ""this: %p"",+      static_cast<int>(name.length()), name.data(),+      static_cast<int>(default_port.length()), default_port.data(), this);++  absl::string_view host;+  absl::string_view port_string;+  if (!grpc_core::SplitHostPort(name, &host, &port_string)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(+                      absl::StrCat(""Unparseable name: "", name))]() mutable {+      on_resolve(status);+    });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_string.empty()) {+    if (default_port.empty()) {+      engine_->Run([on_resolve = std::move(on_resolve),+                    status = absl::InvalidArgumentError(absl::StrFormat(+                        ""No port in name %s or default_port argument"",+                        name))]() mutable { on_resolve(std::move(status)); });+      return;+    }+    port_string = default_port;+  }++  int port = 0;+  if (port_string == ""http"") {+    port = 80;+  } else if (port_string == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_string, &port)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(absl::StrCat(+                      ""Failed to parse port in name: "", name))]() mutable {+      on_resolve(std::move(status));+    });+    return;+  }++  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false)) {+    // Early out if the target is an ipv4 or ipv6 literal.","aha ok thanks for explaining!In that case, if there's a way for us to detect whether the passed param is a ""ip literal"" v.s. not, do we still need the former method?I'm not suggesting that we need to do that, but just curious about whether it would be possible to reduce dependency on 2 sets of implementations, and what is the cost of that (since logic to detect whether something is a ""ip literal"" can be as simple as a regex match :))",X
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/33233,1279981730,2023-07-31T23:43:11Z,src/core/lib/event_engine/cf_engine/dns_service_resolver.cc,"@@ -0,0 +1,222 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""absl/strings/str_format.h""++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/event_engine/cf_engine/dns_service_resolver.h""+#include ""src/core/lib/event_engine/posix_engine/lockfree_event.h""+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/host_port.h""++namespace grpc_event_engine {+namespace experimental {++void DNSServiceResolverImpl::LookupHostname(+    EventEngine::DNSResolver::LookupHostnameCallback on_resolve,+    absl::string_view name, absl::string_view default_port) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::LookupHostname: name: %.*s, default_port: %.*s, ""+      ""this: %p"",+      static_cast<int>(name.length()), name.data(),+      static_cast<int>(default_port.length()), default_port.data(), this);++  absl::string_view host;+  absl::string_view port_string;+  if (!grpc_core::SplitHostPort(name, &host, &port_string)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(+                      absl::StrCat(""Unparseable name: "", name))]() mutable {+      on_resolve(status);+    });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_string.empty()) {+    if (default_port.empty()) {+      engine_->Run([on_resolve = std::move(on_resolve),+                    status = absl::InvalidArgumentError(absl::StrFormat(+                        ""No port in name %s or default_port argument"",+                        name))]() mutable { on_resolve(std::move(status)); });+      return;+    }+    port_string = default_port;+  }++  int port = 0;+  if (port_string == ""http"") {+    port = 80;+  } else if (port_string == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_string, &port)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(absl::StrCat(+                      ""Failed to parse port in name: "", name))]() mutable {+      on_resolve(std::move(status));+    });+    return;+  }++  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false)) {+    // Early out if the target is an ipv4 or ipv6 literal.","That's c-core util functions, I expect depending on them should be fine, no?It's more than regex as we are also validating an ip address, need to consider the invalid values, broad cast addresses, etc. IPv6 can be even more complex.",
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/33233,1280000131,2023-08-01T00:25:01Z,src/core/lib/event_engine/cf_engine/dns_service_resolver.cc,"@@ -0,0 +1,222 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""absl/strings/str_format.h""++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/event_engine/cf_engine/dns_service_resolver.h""+#include ""src/core/lib/event_engine/posix_engine/lockfree_event.h""+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/host_port.h""++namespace grpc_event_engine {+namespace experimental {++void DNSServiceResolverImpl::LookupHostname(+    EventEngine::DNSResolver::LookupHostnameCallback on_resolve,+    absl::string_view name, absl::string_view default_port) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::LookupHostname: name: %.*s, default_port: %.*s, ""+      ""this: %p"",+      static_cast<int>(name.length()), name.data(),+      static_cast<int>(default_port.length()), default_port.data(), this);++  absl::string_view host;+  absl::string_view port_string;+  if (!grpc_core::SplitHostPort(name, &host, &port_string)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(+                      absl::StrCat(""Unparseable name: "", name))]() mutable {+      on_resolve(status);+    });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_string.empty()) {+    if (default_port.empty()) {+      engine_->Run([on_resolve = std::move(on_resolve),+                    status = absl::InvalidArgumentError(absl::StrFormat(+                        ""No port in name %s or default_port argument"",+                        name))]() mutable { on_resolve(std::move(status)); });+      return;+    }+    port_string = default_port;+  }++  int port = 0;+  if (port_string == ""http"") {+    port = 80;+  } else if (port_string == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_string, &port)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(absl::StrCat(+                      ""Failed to parse port in name: "", name))]() mutable {+      on_resolve(std::move(status));+    });+    return;+  }++  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false)) {+    // Early out if the target is an ipv4 or ipv6 literal.+    std::vector<EventEngine::ResolvedAddress> result;+    result.emplace_back(reinterpret_cast<sockaddr*>(addr.addr), addr.len);+    engine_->Run([on_resolve = std::move(on_resolve),+                  result = std::move(result)]() mutable {+      on_resolve(std::move(result));+    });+    return;+  }++  DNSServiceRef sdRef;+  auto host_string = std::string{host};+  auto error = DNSServiceGetAddrInfo(+      &sdRef, kDNSServiceFlagsTimeout | kDNSServiceFlagsReturnIntermediates, 0,+      kDNSServiceProtocol_IPv4 | kDNSServiceProtocol_IPv6, host_string.c_str(),+      &DNSServiceResolverImpl::ResolveCallback, this /* do not Ref */);++  if (error != kDNSServiceErr_NoError) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::UnknownError(absl::StrFormat(+                      ""DNSServiceGetAddrInfo failed with error:%d"",+                      error))]() mutable { on_resolve(std::move(status)); });+    return;+  }++  grpc_core::ReleasableMutexLock lock(&request_mu_);++  error = DNSServiceSetDispatchQueue(sdRef, queue_);+  if (error != kDNSServiceErr_NoError) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::UnknownError(absl::StrFormat(+                      ""DNSServiceSetDispatchQueue failed with error:%d"",+                      error))]() mutable { on_resolve(std::move(status)); });+    return;+  }++  requests_.try_emplace(+      sdRef, DNSServiceRequest{+                 std::move(on_resolve), static_cast<uint16_t>(port), {}});+}++/* static */+void DNSServiceResolverImpl::ResolveCallback(+    DNSServiceRef sdRef, DNSServiceFlags flags, uint32_t interfaceIndex,+    DNSServiceErrorType errorCode, const char* hostname,+    const struct sockaddr* address, uint32_t ttl, void* context) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::ResolveCallback: sdRef: %p, flags: %x, ""+      ""interface: %d, errorCode: %d, hostname: %s, addressFamily: %d, ttl: ""+      ""%d, ""+      ""this: %p"",+      sdRef, flags, interfaceIndex, errorCode, hostname, address->sa_family,+      ttl, context);++  // no need to increase refcount here, since ResolveCallback and Shutdown is+  // called from the serial queue and it is guarenteed that it won't be called+  // after the sdRef is deallocated+  auto that = static_cast<DNSServiceResolverImpl*>(context);++  grpc_core::ReleasableMutexLock lock(&that->request_mu_);+  auto request_it = that->requests_.find(sdRef);+  GPR_ASSERT(request_it != that->requests_.end());+  auto& request = request_it->second;++  if (errorCode != kDNSServiceErr_NoError &&+      errorCode != kDNSServiceErr_NoSuchRecord) {+    request.on_resolve(absl::UnknownError(absl::StrFormat(+        ""address lookup failed for %s: errorCode: %d"", hostname, errorCode)));+    that->requests_.erase(request_it);+    DNSServiceRefDeallocate(sdRef);+    return;+  }++  // set received ipv4 or ipv6 response, even for kDNSServiceErr_NoSuchRecord+  if (address->sa_family == AF_INET) {+    request.has_ipv4_response = true;+  } else if (address->sa_family == AF_INET6) {+    request.has_ipv6_response = true;+  }++  // collect results if there is no error (not kDNSServiceErr_NoSuchRecord)+  if (errorCode == kDNSServiceErr_NoError) {+    request.result.emplace_back(address, address->sa_len);+    auto& resolved_address = request.result.back();+    if (address->sa_family == AF_INET) {+      (const_cast<sockaddr_in*>(+           reinterpret_cast<const sockaddr_in*>(resolved_address.address())))+          ->sin_port = htons(request.port);+    } else if (address->sa_family == AF_INET6) {+      (const_cast<sockaddr_in6*>(+           reinterpret_cast<const sockaddr_in6*>(resolved_address.address())))+          ->sin6_port = htons(request.port);+    }++    GRPC_EVENT_ENGINE_DNS_TRACE(+        ""DNSServiceResolverImpl::ResolveCallback: ""+        ""sdRef: %p, hostname: %s, addressPort: %s, this: %p"",+        sdRef, hostname,+        ResolvedAddressToString(resolved_address).value_or(""ERROR"").c_str(),+        context);+  }++  if (!(flags & kDNSServiceFlagsMoreComing) && request.has_ipv4_response &&+      request.has_ipv6_response) {+    if (request.result.empty()) {+      request.on_resolve(absl::NotFoundError(absl::StrFormat(+          ""address lookup failed for %s: Domain name not found"", hostname)));",It's ok. No big deal.. Just do it only if you see fit.. Thanks for explaining! :),
133680,sampajano,https://api.github.com/repos/grpc/grpc/pulls/33233,1280000683,2023-08-01T00:26:29Z,src/core/lib/event_engine/cf_engine/dns_service_resolver.cc,"@@ -0,0 +1,222 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#ifdef GPR_APPLE++#include ""absl/strings/str_format.h""++#include ""src/core/lib/address_utils/parse_address.h""+#include ""src/core/lib/event_engine/cf_engine/dns_service_resolver.h""+#include ""src/core/lib/event_engine/posix_engine/lockfree_event.h""+#include ""src/core/lib/event_engine/tcp_socket_utils.h""+#include ""src/core/lib/event_engine/trace.h""+#include ""src/core/lib/gprpp/host_port.h""++namespace grpc_event_engine {+namespace experimental {++void DNSServiceResolverImpl::LookupHostname(+    EventEngine::DNSResolver::LookupHostnameCallback on_resolve,+    absl::string_view name, absl::string_view default_port) {+  GRPC_EVENT_ENGINE_DNS_TRACE(+      ""DNSServiceResolverImpl::LookupHostname: name: %.*s, default_port: %.*s, ""+      ""this: %p"",+      static_cast<int>(name.length()), name.data(),+      static_cast<int>(default_port.length()), default_port.data(), this);++  absl::string_view host;+  absl::string_view port_string;+  if (!grpc_core::SplitHostPort(name, &host, &port_string)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(+                      absl::StrCat(""Unparseable name: "", name))]() mutable {+      on_resolve(status);+    });+    return;+  }+  GPR_ASSERT(!host.empty());+  if (port_string.empty()) {+    if (default_port.empty()) {+      engine_->Run([on_resolve = std::move(on_resolve),+                    status = absl::InvalidArgumentError(absl::StrFormat(+                        ""No port in name %s or default_port argument"",+                        name))]() mutable { on_resolve(std::move(status)); });+      return;+    }+    port_string = default_port;+  }++  int port = 0;+  if (port_string == ""http"") {+    port = 80;+  } else if (port_string == ""https"") {+    port = 443;+  } else if (!absl::SimpleAtoi(port_string, &port)) {+    engine_->Run([on_resolve = std::move(on_resolve),+                  status = absl::InvalidArgumentError(absl::StrCat(+                      ""Failed to parse port in name: "", name))]() mutable {+      on_resolve(std::move(status));+    });+    return;+  }++  // TODO(yijiem): Change this when refactoring code in+  // src/core/lib/address_utils to use EventEngine::ResolvedAddress.+  grpc_resolved_address addr;+  const std::string hostport = grpc_core::JoinHostPort(host, port);+  if (grpc_parse_ipv4_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false) ||+      grpc_parse_ipv6_hostport(hostport.c_str(), &addr,+                               /*log_errors=*/false)) {+    // Early out if the target is an ipv4 or ipv6 literal.","It is fine to depend on it! I was just trying to understand the reasons and necessity for it. If it saves meaningful complexity to reuse their code, then it's totally valid to do so!Maybe you could add a comment explaining what case are you relying on them v.s. the iOS solutions? So at least we have awareness on how to simplify if there's ever a need in the future. ",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/33707,1281630496,2023-08-02T09:14:27Z,tools/bazelify_tests/grpc_repo_archive.sh,"@@ -0,0 +1,118 @@+#!/bin/bash+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++set -e++ARCHIVE_WO_SUBMODULES=""$1""+ARCHIVE_WITH_SUBMODULES=""$2""+export ARCHIVES_DIR=""$(pwd)/archives""++export ARCHIVE_FORMAT=tar++mkdir -p ""${ARCHIVES_DIR}""+rm -rf ""${ARCHIVES_DIR}""/*++# HACK: To be able to collect all grpc source files as an archive+# we need to break from bazel's ""sandbox"" to be able to read files+# from the original bazel workspace (which in our case is the grpc repository root)+# This action runs with the ""standalone"" (a.k.a) local strategy,+# so path to the original bazel workspace from where this was invoked+# can be obtained by resolving the link that points to one of the+# source files.+# 1. find first component of the relative path to this script+# 2. resolve the symlink (it will point to same dir in the workspace)+# 3. one level up is the root of the original bazel workspace+FIRST_PATH_COMPONENT=""$(echo $0 | sed 's|/.*||')""+ORIGINAL_BAZEL_WORKSPACE_ROOT=""$(dirname $(readlink ${FIRST_PATH_COMPONENT}))""++# extract STABLE_GIT_COMMIT from stable-status.txt+GRPC_GIT_COMMIT_FROM_STABLE_STATUS=$(grep ^STABLE_GRPC_GIT_COMMIT bazel-out/stable-status.txt | cut -d' ' -f2)++if [ ""${GRPC_GIT_COMMIT_FROM_STABLE_STATUS}"" == """" ]+then+  echo ""Failed to obtain info about gRPC git commit from the bazel workspace. Make sure you invoke bazel with --workspace_status_command=tools/bazelify_tests/workspace_status_cmd.sh"" >&2+  exit 1+fi++GRPC_UNCOMMITED_PATCH_CHECKSUM_FROM_STABLE_STATUS=$(grep ^STABLE_GRPC_UNCOMMITED_PATCH_CHECKSUM bazel-out/stable-status.txt | cut -d' ' -f2)+GRPC_GIT_WORKSPACE_DIRTY_FROM_STABLE_STATUS=$(grep ^STABLE_GRPC_GIT_WORKSPACE_DIRTY bazel-out/stable-status.txt | cut -d' ' -f2)++pushd ${ORIGINAL_BAZEL_WORKSPACE_ROOT} >/dev/null++if [ ""${GRPC_GIT_COMMIT_FROM_STABLE_STATUS}"" != ""$(git rev-parse HEAD)"" ]+then+  echo ""Info about gRPC commit from stable-status.txt doesn't match the commit at which the workspace root is."" >&2","No particular situation in mind, but I thought there could be situations in which stable-status.txt could get out of date and if the ""STABLE_*"" values in stable-status.txt don't match the actual status of the git workspace, we could fail to recreate the archives when needed and that's a bad situation to be in since it will essentially test wrong revision of grpc and it can be hard to detect that. So better safe than sorry and I added an extra check for this.",X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/33959,1281841437,2023-08-02T12:34:48Z,tools/run_tests/helper_scripts/build_ruby.sh,"@@ -45,4 +45,4 @@ popd  # unbreak subsequent make builds by restoring zconf.h (previously renamed by cmake build) # see https://github.com/madler/zlib/issues/133-(cd third_party/zlib; git checkout zconf.h)+(cd third_party/zlib; git checkout zconf.h || cp zconf.h.included zconf.h)","this was required since inside the bazelified tests, the working copy is no longer a git workspace.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33951,1282504946,2023-08-02T23:35:56Z,src/python/grpcio/grpc/aio/_channel.py,"@@ -207,7 +207,7 @@ def __call__(             call = InterceptedUnaryStreamCall(                 self._interceptors,                 request,-                deadline,+                timeout,","Can we also delete the calculation of deadline above this, since it is now unused? Here and in the other two arities?",X
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/33928,1282507795,2023-08-02T23:42:30Z,src/core/lib/channel/call_tracer.cc,"@@ -48,4 +57,284 @@ absl::string_view ServerCallTracerFactory::ChannelArgName() {   return kServerCallTracerFactoryChannelArgName; } +class DelegatingClientCallTracer : public ClientCallTracer {+ public:+  class DelegatingClientCallAttemptTracer+      : public ClientCallTracer::CallAttemptTracer {+   public:+    explicit DelegatingClientCallAttemptTracer(+        std::vector<CallAttemptTracer*> tracers)+        : tracers_(std::move(tracers)) {+      GPR_DEBUG_ASSERT(!tracers_.empty());+    }+    ~DelegatingClientCallAttemptTracer() override {}+    void RecordSendInitialMetadata(+        grpc_metadata_batch* send_initial_metadata) override {+      for (auto* tracer : tracers_) {+        tracer->RecordSendInitialMetadata(send_initial_metadata);+      }+    }+    void RecordSendTrailingMetadata(+        grpc_metadata_batch* send_trailing_metadata) override {+      for (auto* tracer : tracers_) {+        tracer->RecordSendTrailingMetadata(send_trailing_metadata);+      }+    }+    void RecordSendMessage(const SliceBuffer& send_message) override {+      for (auto* tracer : tracers_) {+        tracer->RecordSendMessage(send_message);+      }+    }+    void RecordSendCompressedMessage(+        const SliceBuffer& send_compressed_message) override {+      for (auto* tracer : tracers_) {+        tracer->RecordSendCompressedMessage(send_compressed_message);+      }+    }+    void RecordReceivedInitialMetadata(+        grpc_metadata_batch* recv_initial_metadata) override {+      for (auto* tracer : tracers_) {+        tracer->RecordReceivedInitialMetadata(recv_initial_metadata);+      }+    }+    void RecordReceivedMessage(const SliceBuffer& recv_message) override {+      for (auto* tracer : tracers_) {+        tracer->RecordReceivedMessage(recv_message);+      }+    }+    void RecordReceivedDecompressedMessage(+        const SliceBuffer& recv_decompressed_message) override {+      for (auto* tracer : tracers_) {+        tracer->RecordReceivedDecompressedMessage(recv_decompressed_message);+      }+    }+    void RecordCancel(grpc_error_handle cancel_error) override {+      for (auto* tracer : tracers_) {+        tracer->RecordCancel(cancel_error);+      }+    }+    void RecordReceivedTrailingMetadata(+        absl::Status status, grpc_metadata_batch* recv_trailing_metadata,+        const grpc_transport_stream_stats* transport_stream_stats) override {+      for (auto* tracer : tracers_) {+        tracer->RecordReceivedTrailingMetadata(status, recv_trailing_metadata,+                                               transport_stream_stats);+      }+    }+    void RecordEnd(const gpr_timespec& latency) override {+      for (auto* tracer : tracers_) {+        tracer->RecordEnd(latency);+      }+    }+    void RecordAnnotation(absl::string_view annotation) override {+      for (auto* tracer : tracers_) {+        tracer->RecordAnnotation(annotation);+      }+    }+    void RecordAnnotation(const Annotation& annotation) override {+      for (auto* tracer : tracers_) {+        tracer->RecordAnnotation(annotation);+      }+    }+    std::string TraceId() override { return tracers_[0]->TraceId(); }+    std::string SpanId() override { return tracers_[0]->SpanId(); }+    bool IsSampled() override { return tracers_[0]->IsSampled(); }+    bool IsDelegatingTracer() override { return true; }++   private:+    // There is no additional synchronization needed since filters/interceptors+    // will be adding call tracers to the context and these are already+    // synchronized through promises/call combiners (single promise running per+    // call at any moment).+    std::vector<CallAttemptTracer*> tracers_;+  };+  explicit DelegatingClientCallTracer(ClientCallTracer* tracer)+      : tracers_{tracer} {}+  ~DelegatingClientCallTracer() override {}+  CallAttemptTracer* StartNewAttempt(bool is_transparent_retry) override {+    std::vector<CallAttemptTracer*> attempt_tracers;+    attempt_tracers.reserve(tracers_.size());+    for (auto* tracer : tracers_) {+      auto* attempt_tracer = tracer->StartNewAttempt(is_transparent_retry);+      GPR_DEBUG_ASSERT(attempt_tracer != nullptr);+      attempt_tracers.push_back(attempt_tracer);+    }+    return GetContext<Arena>()->ManagedNew<DelegatingClientCallAttemptTracer>(+        std::move(attempt_tracers));+  }++  void RecordAnnotation(absl::string_view annotation) override {+    for (auto* tracer : tracers_) {+      tracer->RecordAnnotation(annotation);+    }+  }+  void RecordAnnotation(const Annotation& annotation) override {+    for (auto* tracer : tracers_) {+      tracer->RecordAnnotation(annotation);+    }+  }+  std::string TraceId() override { return tracers_[0]->TraceId(); }+  std::string SpanId() override { return tracers_[0]->SpanId(); }+  bool IsSampled() override { return tracers_[0]->IsSampled(); }+  bool IsDelegatingTracer() override { return true; }++  // There is no additional synchronization needed since filters/interceptors+  // will be adding call tracers to the context and these are already+  // synchronized through promises/call combiners (single promise running per+  // call at any moment).+  void AddTracer(ClientCallTracer* tracer) { tracers_.push_back(tracer); }++ private:+  std::vector<ClientCallTracer*> tracers_;+};++class DelegatingServerCallTracer : public ServerCallTracer {+ public:+  explicit DelegatingServerCallTracer(ServerCallTracer* tracer)+      : tracers_{tracer} {}+  ~DelegatingServerCallTracer() override {}+  void RecordSendInitialMetadata(+      grpc_metadata_batch* send_initial_metadata) override {+    for (auto* tracer : tracers_) {+      tracer->RecordSendInitialMetadata(send_initial_metadata);+    }+  }+  void RecordSendTrailingMetadata(+      grpc_metadata_batch* send_trailing_metadata) override {+    for (auto* tracer : tracers_) {+      tracer->RecordSendTrailingMetadata(send_trailing_metadata);+    }+  }+  void RecordSendMessage(const SliceBuffer& send_message) override {+    for (auto* tracer : tracers_) {+      tracer->RecordSendMessage(send_message);+    }+  }+  void RecordSendCompressedMessage(+      const SliceBuffer& send_compressed_message) override {+    for (auto* tracer : tracers_) {+      tracer->RecordSendCompressedMessage(send_compressed_message);+    }+  }+  void RecordReceivedInitialMetadata(+      grpc_metadata_batch* recv_initial_metadata) override {+    for (auto* tracer : tracers_) {+      tracer->RecordReceivedInitialMetadata(recv_initial_metadata);+    }+  }+  void RecordReceivedMessage(const SliceBuffer& recv_message) override {+    for (auto* tracer : tracers_) {+      tracer->RecordReceivedMessage(recv_message);+    }+  }+  void RecordReceivedDecompressedMessage(+      const SliceBuffer& recv_decompressed_message) override {+    for (auto* tracer : tracers_) {+      tracer->RecordReceivedDecompressedMessage(recv_decompressed_message);+    }+  }+  void RecordCancel(grpc_error_handle cancel_error) override {+    for (auto* tracer : tracers_) {+      tracer->RecordCancel(cancel_error);+    }+  }+  void RecordReceivedTrailingMetadata(+      grpc_metadata_batch* recv_trailing_metadata) override {+    for (auto* tracer : tracers_) {+      tracer->RecordReceivedTrailingMetadata(recv_trailing_metadata);+    }+  }+  void RecordEnd(const grpc_call_final_info* final_info) override {+    for (auto* tracer : tracers_) {+      tracer->RecordEnd(final_info);+    }+  }+  void RecordAnnotation(absl::string_view annotation) override {+    for (auto* tracer : tracers_) {+      tracer->RecordAnnotation(annotation);+    }+  }+  void RecordAnnotation(const Annotation& annotation) override {+    for (auto* tracer : tracers_) {+      tracer->RecordAnnotation(annotation);+    }+  }+  std::string TraceId() override { return tracers_[0]->TraceId(); }+  std::string SpanId() override { return tracers_[0]->SpanId(); }+  bool IsSampled() override { return tracers_[0]->IsSampled(); }+  bool IsDelegatingTracer() override { return true; }++  void AddTracer(ServerCallTracer* tracer) { tracers_.push_back(tracer); }","Added comments in call_tracer.h. For the client-side, it is straightforward. For the server-side, we really only want the call tracers to be inserted when all the server tracer factories are invoked. I'm still thinking where to put the list of factories (one solution is to use ServerBuilderPlugins that will put in the factories in a list in a new channel arg, but it makes me wonder whether the ServerBuilderPlugin infrastructure is adding any value here). Anyway I would want that in a separate PR so that eyes can specifically look at that.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/33928,1282601834,2023-08-03T03:27:42Z,src/core/lib/channel/call_tracer.cc,"@@ -48,4 +57,284 @@ absl::string_view ServerCallTracerFactory::ChannelArgName() {   return kServerCallTracerFactoryChannelArgName; } +class DelegatingClientCallTracer : public ClientCallTracer {+ public:+  class DelegatingClientCallAttemptTracer+      : public ClientCallTracer::CallAttemptTracer {+   public:+    explicit DelegatingClientCallAttemptTracer(+        std::vector<CallAttemptTracer*> tracers)+        : tracers_(std::move(tracers)) {+      GPR_DEBUG_ASSERT(!tracers_.empty());+    }+    ~DelegatingClientCallAttemptTracer() override {}+    void RecordSendInitialMetadata(+        grpc_metadata_batch* send_initial_metadata) override {+      for (auto* tracer : tracers_) {+        tracer->RecordSendInitialMetadata(send_initial_metadata);+      }+    }+    void RecordSendTrailingMetadata(+        grpc_metadata_batch* send_trailing_metadata) override {+      for (auto* tracer : tracers_) {+        tracer->RecordSendTrailingMetadata(send_trailing_metadata);+      }+    }+    void RecordSendMessage(const SliceBuffer& send_message) override {+      for (auto* tracer : tracers_) {+        tracer->RecordSendMessage(send_message);+      }+    }+    void RecordSendCompressedMessage(+        const SliceBuffer& send_compressed_message) override {+      for (auto* tracer : tracers_) {+        tracer->RecordSendCompressedMessage(send_compressed_message);+      }+    }+    void RecordReceivedInitialMetadata(+        grpc_metadata_batch* recv_initial_metadata) override {+      for (auto* tracer : tracers_) {+        tracer->RecordReceivedInitialMetadata(recv_initial_metadata);+      }+    }+    void RecordReceivedMessage(const SliceBuffer& recv_message) override {+      for (auto* tracer : tracers_) {+        tracer->RecordReceivedMessage(recv_message);+      }+    }+    void RecordReceivedDecompressedMessage(+        const SliceBuffer& recv_decompressed_message) override {+      for (auto* tracer : tracers_) {+        tracer->RecordReceivedDecompressedMessage(recv_decompressed_message);+      }+    }+    void RecordCancel(grpc_error_handle cancel_error) override {+      for (auto* tracer : tracers_) {+        tracer->RecordCancel(cancel_error);+      }+    }+    void RecordReceivedTrailingMetadata(+        absl::Status status, grpc_metadata_batch* recv_trailing_metadata,+        const grpc_transport_stream_stats* transport_stream_stats) override {+      for (auto* tracer : tracers_) {+        tracer->RecordReceivedTrailingMetadata(status, recv_trailing_metadata,+                                               transport_stream_stats);+      }+    }+    void RecordEnd(const gpr_timespec& latency) override {+      for (auto* tracer : tracers_) {+        tracer->RecordEnd(latency);+      }+    }+    void RecordAnnotation(absl::string_view annotation) override {+      for (auto* tracer : tracers_) {+        tracer->RecordAnnotation(annotation);+      }+    }+    void RecordAnnotation(const Annotation& annotation) override {+      for (auto* tracer : tracers_) {+        tracer->RecordAnnotation(annotation);+      }+    }+    std::string TraceId() override { return tracers_[0]->TraceId(); }+    std::string SpanId() override { return tracers_[0]->SpanId(); }+    bool IsSampled() override { return tracers_[0]->IsSampled(); }+    bool IsDelegatingTracer() override { return true; }++   private:+    // There is no additional synchronization needed since filters/interceptors+    // will be adding call tracers to the context and these are already+    // synchronized through promises/call combiners (single promise running per+    // call at any moment).+    std::vector<CallAttemptTracer*> tracers_;+  };+  explicit DelegatingClientCallTracer(ClientCallTracer* tracer)+      : tracers_{tracer} {}+  ~DelegatingClientCallTracer() override {}+  CallAttemptTracer* StartNewAttempt(bool is_transparent_retry) override {+    std::vector<CallAttemptTracer*> attempt_tracers;+    attempt_tracers.reserve(tracers_.size());+    for (auto* tracer : tracers_) {+      auto* attempt_tracer = tracer->StartNewAttempt(is_transparent_retry);+      GPR_DEBUG_ASSERT(attempt_tracer != nullptr);+      attempt_tracers.push_back(attempt_tracer);+    }+    return GetContext<Arena>()->ManagedNew<DelegatingClientCallAttemptTracer>(+        std::move(attempt_tracers));+  }++  void RecordAnnotation(absl::string_view annotation) override {+    for (auto* tracer : tracers_) {+      tracer->RecordAnnotation(annotation);+    }+  }+  void RecordAnnotation(const Annotation& annotation) override {+    for (auto* tracer : tracers_) {+      tracer->RecordAnnotation(annotation);+    }+  }+  std::string TraceId() override { return tracers_[0]->TraceId(); }+  std::string SpanId() override { return tracers_[0]->SpanId(); }+  bool IsSampled() override { return tracers_[0]->IsSampled(); }+  bool IsDelegatingTracer() override { return true; }++  // There is no additional synchronization needed since filters/interceptors+  // will be adding call tracers to the context and these are already+  // synchronized through promises/call combiners (single promise running per+  // call at any moment).+  void AddTracer(ClientCallTracer* tracer) { tracers_.push_back(tracer); }++ private:+  std::vector<ClientCallTracer*> tracers_;+};++class DelegatingServerCallTracer : public ServerCallTracer {+ public:+  explicit DelegatingServerCallTracer(ServerCallTracer* tracer)+      : tracers_{tracer} {}+  ~DelegatingServerCallTracer() override {}+  void RecordSendInitialMetadata(+      grpc_metadata_batch* send_initial_metadata) override {+    for (auto* tracer : tracers_) {+      tracer->RecordSendInitialMetadata(send_initial_metadata);+    }+  }+  void RecordSendTrailingMetadata(+      grpc_metadata_batch* send_trailing_metadata) override {+    for (auto* tracer : tracers_) {+      tracer->RecordSendTrailingMetadata(send_trailing_metadata);+    }+  }+  void RecordSendMessage(const SliceBuffer& send_message) override {+    for (auto* tracer : tracers_) {+      tracer->RecordSendMessage(send_message);+    }+  }+  void RecordSendCompressedMessage(+      const SliceBuffer& send_compressed_message) override {+    for (auto* tracer : tracers_) {+      tracer->RecordSendCompressedMessage(send_compressed_message);+    }+  }+  void RecordReceivedInitialMetadata(+      grpc_metadata_batch* recv_initial_metadata) override {+    for (auto* tracer : tracers_) {+      tracer->RecordReceivedInitialMetadata(recv_initial_metadata);+    }+  }+  void RecordReceivedMessage(const SliceBuffer& recv_message) override {+    for (auto* tracer : tracers_) {+      tracer->RecordReceivedMessage(recv_message);+    }+  }+  void RecordReceivedDecompressedMessage(+      const SliceBuffer& recv_decompressed_message) override {+    for (auto* tracer : tracers_) {+      tracer->RecordReceivedDecompressedMessage(recv_decompressed_message);+    }+  }+  void RecordCancel(grpc_error_handle cancel_error) override {+    for (auto* tracer : tracers_) {+      tracer->RecordCancel(cancel_error);+    }+  }+  void RecordReceivedTrailingMetadata(+      grpc_metadata_batch* recv_trailing_metadata) override {+    for (auto* tracer : tracers_) {+      tracer->RecordReceivedTrailingMetadata(recv_trailing_metadata);+    }+  }+  void RecordEnd(const grpc_call_final_info* final_info) override {+    for (auto* tracer : tracers_) {+      tracer->RecordEnd(final_info);+    }+  }+  void RecordAnnotation(absl::string_view annotation) override {+    for (auto* tracer : tracers_) {+      tracer->RecordAnnotation(annotation);+    }+  }+  void RecordAnnotation(const Annotation& annotation) override {+    for (auto* tracer : tracers_) {+      tracer->RecordAnnotation(annotation);+    }+  }+  std::string TraceId() override { return tracers_[0]->TraceId(); }+  std::string SpanId() override { return tracers_[0]->SpanId(); }+  bool IsSampled() override { return tracers_[0]->IsSampled(); }+  bool IsDelegatingTracer() override { return true; }++  void AddTracer(ServerCallTracer* tracer) { tracers_.push_back(tracer); }",Let's chat soon... I'm beginning to be in favor of having channel tracers be a channel/server level configuration that's independent of filters/interceptors.,X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/33876,1284637325,2023-08-04T16:33:52Z,src/core/ext/transport/chaotic_good/client_transport.cc,"@@ -0,0 +1,121 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/ext/transport/chaotic_good/client_transport.h""++#include <stdlib.h>++#include <memory>+#include <string>+#include <tuple>++#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/slice.h>+#include <grpc/support/log.h>++#include ""src/core/ext/transport/chaotic_good/frame.h""+#include ""src/core/ext/transport/chaotic_good/frame_header.h""+#include ""src/core/ext/transport/chttp2/transport/hpack_encoder.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/detail/basic_seq.h""+#include ""src/core/lib/promise/event_engine_wakeup_scheduler.h""+#include ""src/core/lib/promise/loop.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/promise/try_join.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/slice/slice_internal.h""+#include ""src/core/lib/transport/promise_endpoint.h""++namespace grpc_core {+namespace chaotic_good {++ClientTransport::ClientTransport(+    std::unique_ptr<PromiseEndpoint> control_endpoint,+    std::unique_ptr<PromiseEndpoint> data_endpoint,+    std::shared_ptr<grpc_event_engine::experimental::EventEngine> event_engine)+    : outgoing_frames_(MpscReceiver<ClientFrame>(4)),+      control_endpoint_(std::move(control_endpoint)),+      data_endpoint_(std::move(data_endpoint)),+      event_engine_(event_engine) {+  auto hpack_compressor = std::make_shared<HPackCompressor>();+  auto write_loop = Loop(Seq(+      // Get next outgoing frame.+      this->outgoing_frames_.Next(),+      // Construct data buffers that will be sent to the endpoints.+      [hpack_compressor](ClientFrame client_frame) {+        SliceBuffer control_endpoint_buffer;",Are we allocating a new buffer for each frame here ? Instead can we keep the buffers on a per-transport basis i.e there is one control_endpoint_buffer and data_endpoint_buffer for the ClientTransport ?,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/33876,1284637842,2023-08-04T16:34:15Z,src/core/ext/transport/chaotic_good/client_transport.cc,"@@ -0,0 +1,121 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/ext/transport/chaotic_good/client_transport.h""++#include <stdlib.h>++#include <memory>+#include <string>+#include <tuple>++#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/slice.h>+#include <grpc/support/log.h>++#include ""src/core/ext/transport/chaotic_good/frame.h""+#include ""src/core/ext/transport/chaotic_good/frame_header.h""+#include ""src/core/ext/transport/chttp2/transport/hpack_encoder.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/detail/basic_seq.h""+#include ""src/core/lib/promise/event_engine_wakeup_scheduler.h""+#include ""src/core/lib/promise/loop.h""+#include ""src/core/lib/promise/poll.h""+#include ""src/core/lib/promise/try_join.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/slice/slice_internal.h""+#include ""src/core/lib/transport/promise_endpoint.h""++namespace grpc_core {+namespace chaotic_good {++ClientTransport::ClientTransport(+    std::unique_ptr<PromiseEndpoint> control_endpoint,+    std::unique_ptr<PromiseEndpoint> data_endpoint,+    std::shared_ptr<grpc_event_engine::experimental::EventEngine> event_engine)+    : outgoing_frames_(MpscReceiver<ClientFrame>(4)),+      control_endpoint_(std::move(control_endpoint)),+      data_endpoint_(std::move(data_endpoint)),+      event_engine_(event_engine) {+  auto hpack_compressor = std::make_shared<HPackCompressor>();+  auto write_loop = Loop(Seq(+      // Get next outgoing frame.+      this->outgoing_frames_.Next(),+      // Construct data buffers that will be sent to the endpoints.+      [hpack_compressor](ClientFrame client_frame) {+        SliceBuffer control_endpoint_buffer;+        SliceBuffer data_endpoint_buffer;+        MatchMutable(+            &client_frame,+            [hpack_compressor, &control_endpoint_buffer,+             &data_endpoint_buffer](ClientFragmentFrame* frame) mutable {+              control_endpoint_buffer.Append(+                  frame->Serialize(hpack_compressor.get()));+              if (frame->message != nullptr) {+                char* header_string = grpc_slice_to_c_string(+                    control_endpoint_buffer.c_slice_buffer()->slices[0]);+                auto frame_header =+                    FrameHeader::Parse(+                        reinterpret_cast<const uint8_t*>(header_string))+                        .value();+                free(header_string);+                std::string message_padding(frame_header.message_padding, '0');+                Slice slice(grpc_slice_from_cpp_string(message_padding));+                // Append message payload to data_endpoint_buffer.+                data_endpoint_buffer.Append(std::move(slice));+                // Append message payload to data_endpoint_buffer.+                frame->message->payload()->MoveFirstNBytesIntoSliceBuffer(+                    frame->message->payload()->Length(), data_endpoint_buffer);+              }+            },+            [hpack_compressor,+             &control_endpoint_buffer](CancelFrame* frame) mutable {+              control_endpoint_buffer.Append(+                  frame->Serialize(hpack_compressor.get()));+            });+        return std::make_tuple<SliceBuffer, SliceBuffer>(+            std::move(control_endpoint_buffer),",I think one of these should be data_endpoint_buffer,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33965,1284715911,2023-08-04T18:12:44Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc,"@@ -92,43 +100,41 @@ class WSAErrorContext { // from c-ares and are used with the grpc windows poller, and it, e.g., // manufactures virtual socket error codes when it e.g. needs to tell the c-ares // library to wait for an async read.-class GrpcPolledFdWindows {+class GrpcPolledFdWindows : public GrpcPolledFd {  public:-  enum WriteState {-    WRITE_IDLE,-    WRITE_REQUESTED,-    WRITE_PENDING,-    WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY,-  };-   GrpcPolledFdWindows(ares_socket_t as, Mutex* mu, int address_family,-                      int socket_type)+                      int socket_type, std::function<void()> on_shutdown_locked)",I think we prefer `absl::AnyInvocable<void()>` over `std::function<void()>`: [go/totw/191](https://g3doc.corp.google.com/devtools/library_club/g3doc/totw/191.md?cl=head).,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/33965,1284842239,2023-08-04T20:57:59Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc,"@@ -193,74 +199,86 @@ class GrpcPolledFdWindows {     grpc_socket_notify_on_read(winsocket_, &outer_read_closure_);   } -  void RegisterForOnWriteableLocked(grpc_closure* write_closure) {-    if (socket_type_ == SOCK_DGRAM) {-      GRPC_CARES_TRACE_LOG(""fd:|%s| RegisterForOnWriteableLocked called"",-                           GetName());-    } else {-      GPR_ASSERT(socket_type_ == SOCK_STREAM);-      GRPC_CARES_TRACE_LOG(-          ""fd:|%s| RegisterForOnWriteableLocked called tcp_write_state_: %d"",-          GetName(), tcp_write_state_);-    }+  void RegisterForOnWriteableLocked(grpc_closure* write_closure) override {+    GRPC_CARES_TRACE_LOG(+        ""fd:|%s| RegisterForOnWriteableLocked called connect_done_: %d ""+        ""last_wsa_send_result_: %d"",+        GetName(), connect_done_, last_wsa_send_result_);     GPR_ASSERT(write_closure_ == nullptr);     write_closure_ = write_closure;-    if (connect_done_) {-      ContinueRegisterForOnWriteableLocked();-    } else {-      GPR_ASSERT(pending_continue_register_for_on_writeable_locked_ == false);+    if (!connect_done_) {+      GPR_ASSERT(!pending_continue_register_for_on_writeable_locked_);       pending_continue_register_for_on_writeable_locked_ = true;+      grpc_socket_notify_on_write(winsocket_, &on_tcp_connect_locked_);","Why do we need to add this here? AFAICT, `ConnectTCP()` already calls `grpc_socket_notify_on_write()` for an async connect: https://github.com/grpc/grpc/blob/master/src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc#L567",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/33878,1285581312,2023-08-07T08:58:20Z,src/compiler/csharp_generator.cc,"@@ -735,14 +738,15 @@ void GenerateBindServiceWithBinderMethod(Printer* out,   for (int i = 0; i < service->method_count(); i++) {     const MethodDescriptor* method = service->method(i);     out->Print(-        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? null : ""+        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? ""+        ""null$nullforgiving$ : ""","Having looked at the code, I still don't understand why this is necessary. Grpc.Core.Api doesn't have nullable annotations yet anyway, does it? So I'd expect the generated code to be aware of that, and not warn - and when Grpc.Core.Api *does* add nullable annotations, I'd expect ServiceBinderMase.AddMethod to make the second parameter nullable. But I may be missing something...",
39062083,lsirac,https://api.github.com/repos/grpc/grpc/pulls/34001,1287418728,2023-08-08T17:02:38Z,src/core/lib/security/credentials/external/pluggable_auth_external_account_credentials.cc,"@@ -0,0 +1,401 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/external/pluggable_auth_external_account_credentials.h""++#include <cxxabi.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <future>+#include <initializer_list>+#include <map>+#include <memory>+#include <thread>+#include <utility>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/str_split.h""+#include ""absl/strings/string_view.h""+#include ""absl/strings/strip.h""++#include <grpc/slice.h>+#include <grpc/support/alloc.h>+#include <grpc/support/json.h>+#include <grpc/support/string_util.h>+#include <grpc/support/time.h>++#include ""src/core/lib/gpr/subprocess.h""+#include ""src/core/lib/iomgr/load_file.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_reader.h""+#include ""src/core/lib/security/credentials/external/external_account_credentials.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_internal.h""++extern char** environ;++#define DEFAULT_EXECUTABLE_TIMEOUT_MS 30000  // 30 seconds+#define MIN_EXECUTABLE_TIMEOUT_MS 5000       // 5 seconds+#define MAX_EXECUTABLE_TIMEOUT_MS 120000     // 120 seconds+#define SAML_SUBJECT_TOKEN_TYPE ""urn:ietf:params:oauth:token-type:saml2""+#define GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES \+  ""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES""+#define GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES_ACCEPTED_VALUE ""1""++inline bool isKeyPresent(absl::StatusOr<grpc_core::Json> json,+                         std::string key) {+  return json->object().find(key.c_str()) != json->object().end();+}++inline std::string getStringValue(absl::StatusOr<grpc_core::Json> json,+                                  std::string key) {+  auto it = json->object().find(key.c_str());+  return it->second.string();+}++bool isExpired(int expiration_time) {+  return gpr_time_cmp(+             gpr_time_from_seconds(expiration_time, GPR_CLOCK_REALTIME),+             gpr_now(GPR_CLOCK_REALTIME)) <= 0;+}++std::string get_impersonated_email(",This should be defined in the base class,X
39062083,lsirac,https://api.github.com/repos/grpc/grpc/pulls/34001,1287424897,2023-08-08T17:08:59Z,src/core/lib/security/credentials/external/pluggable_auth_external_account_credentials.h,"@@ -0,0 +1,77 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//++#ifndef GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_EXTERNAL_PLUGGABLE_AUTH_EXTERNAL_ACCOUNT_CREDENTIALS_H+#define GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_EXTERNAL_PLUGGABLE_AUTH_EXTERNAL_ACCOUNT_CREDENTIALS_H++#include <grpc/support/port_platform.h>++#include <stdint.h>++#include <functional>+#include <string>+#include <vector>++#include ""src/core/lib/gpr/subprocess.h""+#include ""src/core/lib/gprpp/ref_counted_ptr.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/security/credentials/external/external_account_credentials.h""++namespace grpc_core {++class PluggableAuthExternalAccountCredentials final+    : public ExternalAccountCredentials {+ public:+  struct ExecutableResponse {+    bool success;+    int version;+    int expiration_time;",expiration_time should be a long,
39062083,lsirac,https://api.github.com/repos/grpc/grpc/pulls/34001,1287443142,2023-08-08T17:27:33Z,src/core/lib/security/credentials/external/pluggable_auth_external_account_credentials.cc,"@@ -0,0 +1,401 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/external/pluggable_auth_external_account_credentials.h""++#include <cxxabi.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <future>+#include <initializer_list>+#include <map>+#include <memory>+#include <thread>+#include <utility>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/str_split.h""+#include ""absl/strings/string_view.h""+#include ""absl/strings/strip.h""++#include <grpc/slice.h>+#include <grpc/support/alloc.h>+#include <grpc/support/json.h>+#include <grpc/support/string_util.h>+#include <grpc/support/time.h>++#include ""src/core/lib/gpr/subprocess.h""+#include ""src/core/lib/iomgr/load_file.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_reader.h""+#include ""src/core/lib/security/credentials/external/external_account_credentials.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_internal.h""++extern char** environ;++#define DEFAULT_EXECUTABLE_TIMEOUT_MS 30000  // 30 seconds+#define MIN_EXECUTABLE_TIMEOUT_MS 5000       // 5 seconds+#define MAX_EXECUTABLE_TIMEOUT_MS 120000     // 120 seconds+#define SAML_SUBJECT_TOKEN_TYPE ""urn:ietf:params:oauth:token-type:saml2""+#define GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES \+  ""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES""+#define GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES_ACCEPTED_VALUE ""1""++inline bool isKeyPresent(absl::StatusOr<grpc_core::Json> json,+                         std::string key) {+  return json->object().find(key.c_str()) != json->object().end();+}++inline std::string getStringValue(absl::StatusOr<grpc_core::Json> json,+                                  std::string key) {+  auto it = json->object().find(key.c_str());+  return it->second.string();+}++bool isExpired(int expiration_time) {+  return gpr_time_cmp(+             gpr_time_from_seconds(expiration_time, GPR_CLOCK_REALTIME),+             gpr_now(GPR_CLOCK_REALTIME)) <= 0;+}++std::string get_impersonated_email(+    std::string service_account_impersonation_url) {+  std::vector<absl::string_view> url_elements =+      absl::StrSplit(service_account_impersonation_url, ""/"");+  absl::string_view impersonated_email = url_elements[url_elements.size() - 1];+  absl::ConsumeSuffix(&impersonated_email, "":generateAccessToken"");+  return std::string(impersonated_email);+}++bool run_executable(gpr_subprocess** gpr_subprocess, int argc, char** argv,+                    int envc, char** envp, std::string* output,+                    std::string* stderr_data, std::string* error) {+  *gpr_subprocess =+      gpr_subprocess_create_with_envp(argc, const_cast<const char**>(argv),+                                      envc, const_cast<const char**>(envp));+  std::string input = """";+  return gpr_subprocess_communicate(*gpr_subprocess, input, output, stderr_data,+                                    error);+}++namespace grpc_core {++RefCountedPtr<PluggableAuthExternalAccountCredentials>+PluggableAuthExternalAccountCredentials::Create(Options options,+                                                std::vector<std::string> scopes,+                                                grpc_error_handle* error) {+  auto creds = MakeRefCounted<PluggableAuthExternalAccountCredentials>(+      std::move(options), std::move(scopes), error);+  if (error->ok()) return creds;+  return nullptr;+}++PluggableAuthExternalAccountCredentials::+    PluggableAuthExternalAccountCredentials(Options options,+                                            std::vector<std::string> scopes,+                                            grpc_error_handle* error)+    : ExternalAccountCredentials(options, std::move(scopes)) {+  auto it = options.credential_source.object().find(""executable"");+  if (it->second.type() != Json::Type::kObject) {+    *error = GRPC_ERROR_CREATE(""executable field must be an object"");+    return;+  }+  auto executable_json = it->second;+  if (!isKeyPresent(executable_json, ""command"")) {+    *error = GRPC_ERROR_CREATE(""command field not present."");+    return;+  }+  command_ = getStringValue(executable_json, ""command"");+  executable_timeout_ms_ = DEFAULT_EXECUTABLE_TIMEOUT_MS;+  if (isKeyPresent(executable_json, ""timeout_millis"")) {+    if (!absl::SimpleAtoi(getStringValue(executable_json, ""timeout_millis""),+                          &executable_timeout_ms_)) {+      *error = GRPC_ERROR_CREATE(""timeout_millis field must be a number."");+      return;+    }+    if (executable_timeout_ms_ > MAX_EXECUTABLE_TIMEOUT_MS ||+        executable_timeout_ms_ < MIN_EXECUTABLE_TIMEOUT_MS) {+      *error = GRPC_ERROR_CREATE(absl::StrFormat(+          ""timeout_millis should be between %d and %d milliseconds."",+          MIN_EXECUTABLE_TIMEOUT_MS, MAX_EXECUTABLE_TIMEOUT_MS));+      return;+    }+  }+  if (isKeyPresent(executable_json, ""output_file""))+    output_file_path_ = getStringValue(executable_json, ""output_file"");+}++PluggableAuthExternalAccountCredentials::ExecutableResponse*+PluggableAuthExternalAccountCredentials::CreateExecutableResponse(+    std::string executable_output_string, grpc_error_handle* error) {+  auto executable_output = JsonParse(executable_output_string);+  ExecutableResponse* executable_response =+      (ExecutableResponse*)gpr_malloc(sizeof(ExecutableResponse));+  if (!executable_output.ok()) {+    *error = GRPC_ERROR_CREATE(+        absl::StrFormat(""The response from the executable contains an invalid ""+                        ""or malformed response: %s"",+                        executable_output_string));+    return nullptr;+  }+  if (!isKeyPresent(executable_output, ""version"")) {+    *error = GRPC_ERROR_CREATE(+        ""The executable response must contain the ""+        ""`version` field."");+    return nullptr;+  }+  absl::SimpleAtoi(getStringValue(executable_output, ""version""),+                   &executable_response->version);+  auto executable_output_it = executable_output->object().find(""success"");+  if (!isKeyPresent(executable_output, ""success"")) {+    *error = GRPC_ERROR_CREATE(+        ""The executable response must contain the ""+        ""`success` field."");+    return nullptr;+  }+  executable_response->success = executable_output_it->second.boolean();+  if (executable_response->success) {+    if (!isKeyPresent(executable_output, ""token_type"")) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain the ""+          ""`token_type` field."");+      return nullptr;+    }+    executable_response->token_type =+        gpr_strdup(getStringValue(executable_output, ""token_type"").c_str());+    executable_response->expiration_time =+        gpr_time_to_millis(gpr_inf_future(GPR_CLOCK_REALTIME));+    if (output_file_path_ != """" &&+        !isKeyPresent(executable_output, ""expiration_time"")) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain the `expiration_time` field ""+          ""for successful responses when an output_file has been specified in ""+          ""the configuration."");+      return nullptr;+    }+    if (isKeyPresent(executable_output, ""expiration_time"")) {+      if (!absl::SimpleAtoi(+              getStringValue(executable_output, ""expiration_time""),+              &executable_response->expiration_time)) {+        *error = GRPC_ERROR_CREATE(+            ""The executable response contains an invalid value for ""+            ""`expiration_time`."");+        return nullptr;+      }+    }+    if (strcmp(executable_response->token_type, SAML_SUBJECT_TOKEN_TYPE) == 0)+      executable_output_it = executable_output->object().find(""saml_response"");+    else+      executable_output_it = executable_output->object().find(""id_token"");+    if (executable_output_it == executable_output->object().end()) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain a valid token."");+      return nullptr;+    }+    executable_response->subject_token =+        gpr_strdup(executable_output_it->second.string().c_str());+  } else {+    if (!isKeyPresent(executable_output, ""code"")) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain the ""+          ""`code` field when unsuccessful."");+      return nullptr;+    }+    executable_response->error_code =+        gpr_strdup(getStringValue(executable_output, ""code"").c_str());+    if (!isKeyPresent(executable_output, ""message"")) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain the ""+          ""`message` field when unsuccessful."");+      return nullptr;+    }+    executable_response->error_message =+        gpr_strdup(getStringValue(executable_output, ""message"").c_str());+  }+  return executable_response;+}++void PluggableAuthExternalAccountCredentials::RetrieveSubjectToken(","This function is pretty long. I would split it up into ~3 (validate env, retrieve from outputfile, call executable)",X
39062083,lsirac,https://api.github.com/repos/grpc/grpc/pulls/34001,1287454677,2023-08-08T17:39:22Z,src/core/lib/security/credentials/external/pluggable_auth_external_account_credentials.cc,"@@ -0,0 +1,401 @@+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/external/pluggable_auth_external_account_credentials.h""++#include <cxxabi.h>+#include <stdlib.h>+#include <string.h>++#include <algorithm>+#include <chrono>+#include <future>+#include <initializer_list>+#include <map>+#include <memory>+#include <thread>+#include <utility>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/numbers.h""+#include ""absl/strings/str_format.h""+#include ""absl/strings/str_split.h""+#include ""absl/strings/string_view.h""+#include ""absl/strings/strip.h""++#include <grpc/slice.h>+#include <grpc/support/alloc.h>+#include <grpc/support/json.h>+#include <grpc/support/string_util.h>+#include <grpc/support/time.h>++#include ""src/core/lib/gpr/subprocess.h""+#include ""src/core/lib/iomgr/load_file.h""+#include ""src/core/lib/json/json.h""+#include ""src/core/lib/json/json_reader.h""+#include ""src/core/lib/security/credentials/external/external_account_credentials.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_internal.h""++extern char** environ;++#define DEFAULT_EXECUTABLE_TIMEOUT_MS 30000  // 30 seconds+#define MIN_EXECUTABLE_TIMEOUT_MS 5000       // 5 seconds+#define MAX_EXECUTABLE_TIMEOUT_MS 120000     // 120 seconds+#define SAML_SUBJECT_TOKEN_TYPE ""urn:ietf:params:oauth:token-type:saml2""+#define GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES \+  ""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES""+#define GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES_ACCEPTED_VALUE ""1""++inline bool isKeyPresent(absl::StatusOr<grpc_core::Json> json,+                         std::string key) {+  return json->object().find(key.c_str()) != json->object().end();+}++inline std::string getStringValue(absl::StatusOr<grpc_core::Json> json,+                                  std::string key) {+  auto it = json->object().find(key.c_str());+  return it->second.string();+}++bool isExpired(int expiration_time) {+  return gpr_time_cmp(+             gpr_time_from_seconds(expiration_time, GPR_CLOCK_REALTIME),+             gpr_now(GPR_CLOCK_REALTIME)) <= 0;+}++std::string get_impersonated_email(+    std::string service_account_impersonation_url) {+  std::vector<absl::string_view> url_elements =+      absl::StrSplit(service_account_impersonation_url, ""/"");+  absl::string_view impersonated_email = url_elements[url_elements.size() - 1];+  absl::ConsumeSuffix(&impersonated_email, "":generateAccessToken"");+  return std::string(impersonated_email);+}++bool run_executable(gpr_subprocess** gpr_subprocess, int argc, char** argv,+                    int envc, char** envp, std::string* output,+                    std::string* stderr_data, std::string* error) {+  *gpr_subprocess =+      gpr_subprocess_create_with_envp(argc, const_cast<const char**>(argv),+                                      envc, const_cast<const char**>(envp));+  std::string input = """";+  return gpr_subprocess_communicate(*gpr_subprocess, input, output, stderr_data,+                                    error);+}++namespace grpc_core {++RefCountedPtr<PluggableAuthExternalAccountCredentials>+PluggableAuthExternalAccountCredentials::Create(Options options,+                                                std::vector<std::string> scopes,+                                                grpc_error_handle* error) {+  auto creds = MakeRefCounted<PluggableAuthExternalAccountCredentials>(+      std::move(options), std::move(scopes), error);+  if (error->ok()) return creds;+  return nullptr;+}++PluggableAuthExternalAccountCredentials::+    PluggableAuthExternalAccountCredentials(Options options,+                                            std::vector<std::string> scopes,+                                            grpc_error_handle* error)+    : ExternalAccountCredentials(options, std::move(scopes)) {+  auto it = options.credential_source.object().find(""executable"");+  if (it->second.type() != Json::Type::kObject) {+    *error = GRPC_ERROR_CREATE(""executable field must be an object"");+    return;+  }+  auto executable_json = it->second;+  if (!isKeyPresent(executable_json, ""command"")) {+    *error = GRPC_ERROR_CREATE(""command field not present."");+    return;+  }+  command_ = getStringValue(executable_json, ""command"");+  executable_timeout_ms_ = DEFAULT_EXECUTABLE_TIMEOUT_MS;+  if (isKeyPresent(executable_json, ""timeout_millis"")) {+    if (!absl::SimpleAtoi(getStringValue(executable_json, ""timeout_millis""),+                          &executable_timeout_ms_)) {+      *error = GRPC_ERROR_CREATE(""timeout_millis field must be a number."");+      return;+    }+    if (executable_timeout_ms_ > MAX_EXECUTABLE_TIMEOUT_MS ||+        executable_timeout_ms_ < MIN_EXECUTABLE_TIMEOUT_MS) {+      *error = GRPC_ERROR_CREATE(absl::StrFormat(+          ""timeout_millis should be between %d and %d milliseconds."",+          MIN_EXECUTABLE_TIMEOUT_MS, MAX_EXECUTABLE_TIMEOUT_MS));+      return;+    }+  }+  if (isKeyPresent(executable_json, ""output_file""))+    output_file_path_ = getStringValue(executable_json, ""output_file"");+}++PluggableAuthExternalAccountCredentials::ExecutableResponse*+PluggableAuthExternalAccountCredentials::CreateExecutableResponse(+    std::string executable_output_string, grpc_error_handle* error) {+  auto executable_output = JsonParse(executable_output_string);+  ExecutableResponse* executable_response =+      (ExecutableResponse*)gpr_malloc(sizeof(ExecutableResponse));+  if (!executable_output.ok()) {+    *error = GRPC_ERROR_CREATE(+        absl::StrFormat(""The response from the executable contains an invalid ""+                        ""or malformed response: %s"",+                        executable_output_string));+    return nullptr;+  }+  if (!isKeyPresent(executable_output, ""version"")) {+    *error = GRPC_ERROR_CREATE(+        ""The executable response must contain the ""+        ""`version` field."");+    return nullptr;+  }+  absl::SimpleAtoi(getStringValue(executable_output, ""version""),+                   &executable_response->version);+  auto executable_output_it = executable_output->object().find(""success"");+  if (!isKeyPresent(executable_output, ""success"")) {+    *error = GRPC_ERROR_CREATE(+        ""The executable response must contain the ""+        ""`success` field."");+    return nullptr;+  }+  executable_response->success = executable_output_it->second.boolean();+  if (executable_response->success) {+    if (!isKeyPresent(executable_output, ""token_type"")) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain the ""+          ""`token_type` field."");+      return nullptr;+    }+    executable_response->token_type =+        gpr_strdup(getStringValue(executable_output, ""token_type"").c_str());+    executable_response->expiration_time =+        gpr_time_to_millis(gpr_inf_future(GPR_CLOCK_REALTIME));+    if (output_file_path_ != """" &&+        !isKeyPresent(executable_output, ""expiration_time"")) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain the `expiration_time` field ""+          ""for successful responses when an output_file has been specified in ""+          ""the configuration."");+      return nullptr;+    }+    if (isKeyPresent(executable_output, ""expiration_time"")) {+      if (!absl::SimpleAtoi(+              getStringValue(executable_output, ""expiration_time""),+              &executable_response->expiration_time)) {+        *error = GRPC_ERROR_CREATE(+            ""The executable response contains an invalid value for ""+            ""`expiration_time`."");+        return nullptr;+      }+    }+    if (strcmp(executable_response->token_type, SAML_SUBJECT_TOKEN_TYPE) == 0)+      executable_output_it = executable_output->object().find(""saml_response"");+    else+      executable_output_it = executable_output->object().find(""id_token"");+    if (executable_output_it == executable_output->object().end()) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain a valid token."");+      return nullptr;+    }+    executable_response->subject_token =+        gpr_strdup(executable_output_it->second.string().c_str());+  } else {+    if (!isKeyPresent(executable_output, ""code"")) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain the ""+          ""`code` field when unsuccessful."");+      return nullptr;+    }+    executable_response->error_code =+        gpr_strdup(getStringValue(executable_output, ""code"").c_str());+    if (!isKeyPresent(executable_output, ""message"")) {+      *error = GRPC_ERROR_CREATE(+          ""The executable response must contain the ""+          ""`message` field when unsuccessful."");+      return nullptr;+    }+    executable_response->error_message =+        gpr_strdup(getStringValue(executable_output, ""message"").c_str());+  }+  return executable_response;+}++void PluggableAuthExternalAccountCredentials::RetrieveSubjectToken(+    HTTPRequestContext* /*ctx*/, const Options& options,+    std::function<void(std::string, grpc_error_handle)> cb) {+  cb_ = cb;+  grpc_error_handle error;+  char* allow_exec_env_value =+      getenv(GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES);+  if (allow_exec_env_value == nullptr ||+      strcmp(getenv(GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES),+             GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES_ACCEPTED_VALUE)) {+    FinishRetrieveSubjectToken(+        """", GRPC_ERROR_CREATE(+                ""Pluggable Auth executables need to be explicitly allowed to ""+                ""run by setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES ""+                ""environment variable to 1.""));+    return;+  }+  struct SliceWrapper {+    ~SliceWrapper() { CSliceUnref(slice); }+    grpc_slice slice = grpc_empty_slice();+  };+  // Users can specify an output file path in the Pluggable Auth ADC+  // configuration. This is the file's absolute path. Their executable will+  // handle writing the 3P credentials to this file.+  // If specified, we will first check if we have valid unexpired credentials+  // stored in this location to avoid running the executable until they are+  // expired.+  if (output_file_path_ != """") {+    SliceWrapper content_slice;+    error = grpc_load_file(output_file_path_.c_str(), 0, &content_slice.slice);+    if (error.ok()) {+      std::string output_file_content =+          std::string(StringViewFromSlice(content_slice.slice));+      // If the output_file is not blank, try to get an ExecutableResponse from+      // the output file.+      if (output_file_content != """") {+        executable_response_ =+            CreateExecutableResponse(std::string(output_file_content), &error);+        if (executable_response_ == nullptr) {+          FinishRetrieveSubjectToken("""", error);+          return;+        }+        // If the cached output file has an executable response+        // that was successful and un-expired, return the subject token.+        if (executable_response_->success &&+            !isExpired(executable_response_->expiration_time)) {+          FinishRetrieveSubjectToken(executable_response_->subject_token,+                                     absl::OkStatus());+          return;+        }+      }+    }+  }+  // If the cached output_file does not contain a valid response, call the+  // executable.+  std::vector<std::string> envp_vector = {+      absl::StrFormat(""GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE=%s"", options.audience),+      absl::StrFormat(""GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE=%s"",+                      options.subject_token_type),+      absl::StrFormat(""GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE=%d"", 0),+      absl::StrFormat(+          ""GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL=%s"",+          get_impersonated_email(options.service_account_impersonation_url))};+  if (output_file_path_ != """")+    envp_vector.push_back(absl::StrFormat(+        ""GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE=%s"", output_file_path_));+  int environ_count = 0, envc = 0, argc = 0;+  while (environ[environ_count] != nullptr) environ_count += 1;+  char** envp =+      (char**)gpr_malloc(sizeof(char*) * (environ_count + envp_vector.size()));+  for (; envc < environ_count; envc++) envp[envc] = gpr_strdup(environ[envc]);+  for (int j = 0; j < envp_vector.size(); envc++, j++)+    envp[envc] = gpr_strdup(envp_vector[j].c_str());+  std::vector<std::string> arg_vector = absl::StrSplit(command_, "" "");+  argc = arg_vector.size();+  char** argv = (char**)malloc(sizeof(char*) * argc);+  for (int i = 0; i < argc; i++) {+    argv[i] = gpr_strdup(arg_vector[i].c_str());+  }+  std::packaged_task<bool(gpr_subprocess**, int, char**, int, char**,+                          std::string*, std::string*, std::string*)>+      run_executable_task(run_executable);+  std::future<bool> executable_output_future = run_executable_task.get_future();+  std::string output_string, stderr_data, error_string;+  std::thread thr(std::move(run_executable_task), &gpr_subprocess_, argc, argv,+                  envc, envp, &output_string, &stderr_data, &error_string);+  if (executable_output_future.wait_for(std::chrono::seconds(+          executable_timeout_ms_ / 1000)) != std::future_status::timeout) {+    thr.join();+    if (!executable_output_future.get()) {+      // An error must have occured in the executable.+      FinishRetrieveSubjectToken(+          """", GRPC_ERROR_CREATE(absl::StrFormat(+                  ""Executable failed with error: %s"", error_string)));+      return;+    }+    // If the output file is specified, then the executable has stored the+    // response in the output file path.+    if (output_file_path_ != """") {+      SliceWrapper content_slice;+      error =+          grpc_load_file(output_file_path_.c_str(), 0, &content_slice.slice);+      if (error.ok()) {+        absl::string_view output_file_content =+            StringViewFromSlice(content_slice.slice);+        executable_response_ =+            CreateExecutableResponse(std::string(output_file_content), &error);+      }+    } else {+      // Get the result of the executable from stdout and create an+      // ExecutableResponse object from it.+      if (output_string != """") {+        executable_response_ = CreateExecutableResponse(output_string, &error);+      } else if (stderr_data != """") {+        // Get the result of the executable from stderr and create an+        // ExecutableResponse object from it.+        executable_response_ = CreateExecutableResponse(stderr_data, &error);+      }+    }+    if (executable_response_ == nullptr) {+      FinishRetrieveSubjectToken("""", error);+      return;+    }+    if (!executable_response_->success) {","If an error occurs in the executable and there is no `code` or `message`, we should still surface that output in the exception",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/34010,1287549633,2023-08-08T19:18:40Z,test/cpp/interop/client.cc,"@@ -120,6 +120,9 @@ ABSL_FLAG(int32_t, soak_min_time_ms_between_rpcs, 0, ABSL_FLAG(int32_t, iteration_interval, 10,           ""The interval in seconds between rpcs. This is used by ""           ""long_connection test"");+ABSL_FLAG(int32_t, soak_request_size, 271828, ""The request size in a soak RPC"");","nit: let's mention in the comments that by default, sizes are configured as per the ""large unary"" spec",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/31256,1287697201,2023-08-08T21:15:50Z,src/core/lib/security/credentials/jwt/json_token.cc,"@@ -158,7 +162,11 @@ void grpc_auth_json_key_destruct(grpc_auth_json_key* json_key) {     json_key->client_email = nullptr;   }   if (json_key->private_key != nullptr) {+#if OPENSSL_VERSION_NUMBER < 0x30000000L","In making these changes I was trying to minimize changes that would affect the standard building with BoringSSL, so most everything is guarded with #if OPENSSL_VERSION_NUMBERI don't think it would be bad to update this if all the APIs are available, but I think those changes could be put off to a different PR, what do you think?",
14166415,sanjaypujare,https://api.github.com/repos/grpc/grpc/pulls/33939,1287787257,2023-08-08T23:42:23Z,src/proto/grpc/testing/messages.proto,"@@ -103,9 +103,6 @@ message SimpleRequest {    // If set the server should record this metrics report data for the current RPC.   TestOrcaReport orca_per_query_report = 11;-",So the source of this file is really https://github.com/grpc/grpc-proto/blob/master/grpc/testing/messages.proto no?I see that changes from that file are merged in here and we are also making new changes here. Will they then be merged into the file in grpc-proto? What is the normal process?,
14166415,sanjaypujare,https://api.github.com/repos/grpc/grpc/pulls/33939,1287802244,2023-08-09T00:16:18Z,src/proto/grpc/testing/messages.proto,"@@ -210,9 +207,28 @@ message LoadBalancerStatsRequest {   int32 num_rpcs = 1;   // If num_rpcs have not completed within timeout_sec, return partial results.   int32 timeout_sec = 2;+  // response header+trailer we want the values of+  repeated string metadata_keys = 3; }  message LoadBalancerStatsResponse {+  message MetadataEntry {+    string key = 1;+    string value = 2;+  }+  message RpcMetadata {+    // Metadata associated with the RPC call+    repeated MetadataEntry metadata = 1;+  }+  message MetadataByPeer {+    // metadata values in the response for each rpc for all keys+    // specified in LoadBalancerStatsRequest.metadata_keys+    // Binary values are base64 encoded+    // note this is a list of maps: each element in the list",The comment doesn't match the definition. There is no map as far as I can see. This is really a list of lists. The outer list is list of RPCs and the inner list is the list of key+value pairs. Is that right? If correct can you fix the comment so it correctly describes the proto?,X
14166415,sanjaypujare,https://api.github.com/repos/grpc/grpc/pulls/33939,1287819985,2023-08-09T00:55:30Z,test/cpp/interop/xds_stats_watcher.cc,"@@ -50,19 +55,32 @@ void XdsStatsWatcher::RpcCompleted(const AsyncClientCallResult& call,       ++num_rpcs;       auto rpcs_started = method_stat.rpcs_started();       method_stat.set_rpcs_started(++rpcs_started);+      auto rpc_metadata = metadata_by_peer_[peer].add_rpc_metadata();","This code (lines 58 thru 67) gets executed even when peer is empty (line 38 is true). We should protect it when peer is empty, is it not? Or do you want to put all the metadata together in one bucket when peer is empty?",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/33990,1288965321,2023-08-09T17:43:54Z,src/ruby/pb/test/client.rb,"@@ -649,6 +649,21 @@ def custom_metadata    end +  def special_status_message+    code = GRPC::Core::StatusCodes::UNKNOWN+    message = ""\t\ntest with whitespace\r\nand Unicode BMP  and non-BMP \t\n""+    req = SimpleRequest.new(+      response_status: EchoStatus.new(code: code, message: message))+    begin+      resp = @stub.unary_call(req)+    rescue GRPC::Unknown => e+      if e.details.force_encoding(""UTF-8"") != message+        fail AssertionError,+          ""Expected message #{message}. Received: #{e.details}""+      end+    end","This will still ""pass"" if the call accidentally succeeds, right?",
122473768,alto-ruby,https://api.github.com/repos/grpc/grpc/pulls/33990,1288972990,2023-08-09T17:49:34Z,src/ruby/pb/test/client.rb,"@@ -649,6 +649,21 @@ def custom_metadata    end +  def special_status_message+    code = GRPC::Core::StatusCodes::UNKNOWN+    message = ""\t\ntest with whitespace\r\nand Unicode BMP  and non-BMP \t\n""+    req = SimpleRequest.new(+      response_status: EchoStatus.new(code: code, message: message))+    begin+      resp = @stub.unary_call(req)+    rescue GRPC::Unknown => e+      if e.details.force_encoding(""UTF-8"") != message+        fail AssertionError,+          ""Expected message #{message}. Received: #{e.details}""+      end+    end",Test will fail at line 659 if the call succeeds.It will fill at the end if the call raises exceptions other than Unknown.,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1288998067,2023-08-09T18:08:14Z,tools/run_tests/xds_k8s_test_driver/framework/xds_url_map_testcase.py,"@@ -67,6 +67,8 @@ RpcTypeUnaryCall = ""UNARY_CALL"" RpcTypeEmptyCall = ""EMPTY_CALL"" +_first_error_printed: bool = False",Can we use a class var instead?,X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1289000021,2023-08-09T18:09:43Z,tools/run_tests/xds_k8s_test_driver/framework/xds_url_map_testcase.py,"@@ -465,13 +467,24 @@ def _fetch_and_check_xds_config(self):         # Execute the child class provided validation logic         self.xds_config_validate(DumpedXdsConfig(self._xds_json_config)) +    def _print_error_list(self, flavour, errors):+        for _, err in errors:+            logging.error(""%s: %s"" % (flavour, self.__class__.__name__))+            logging.error(""%s"" % err)+     def run(self, result: unittest.TestResult = None) -> None:         """"""Abort this test case if CSDS check is failed.          This prevents the test runner to waste time on RPC distribution test,         and yields clearer signal.         """"""+        global _first_error_printed  # pylint: disable=global-statement+         if result.failures or result.errors:+            if not _first_error_printed:","Not 100% sure this logic is right. Let's add this logic to the regular (non-url-map) test suite base class, and see how it works with the security test suite",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1289000609,2023-08-09T18:10:08Z,tools/run_tests/xds_k8s_test_driver/framework/xds_url_map_testcase.py,"@@ -465,13 +467,24 @@ def _fetch_and_check_xds_config(self):         # Execute the child class provided validation logic         self.xds_config_validate(DumpedXdsConfig(self._xds_json_config)) +    def _print_error_list(self, flavour, errors):+        for _, err in errors:+            logging.error(""%s: %s"" % (flavour, self.__class__.__name__))+            logging.error(""%s"" % err)","```suggestion            logging.error(""%s: %s"", flavour, self.__class__.__name__)            logging.error(""%s"", err)```",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1289102129,2023-08-09T19:27:46Z,tools/run_tests/xds_k8s_test_driver/framework/xds_url_map_testcase.py,"@@ -465,16 +467,28 @@ def _fetch_and_check_xds_config(self):         # Execute the child class provided validation logic         self.xds_config_validate(DumpedXdsConfig(self._xds_json_config)) +    def _print_error_list(self, flavour, errors):+        for _, err in errors:+            logging.error(""%s: %s"", flavour, self.__class__.__name__)+            logging.error(""%s"", err)+     def run(self, result: unittest.TestResult = None) -> None:         """"""Abort this test case if CSDS check is failed.          This prevents the test runner to waste time on RPC distribution test,         and yields clearer signal.         """"""+        global _first_error_printed  # pylint: disable=global-statement+         if result.failures or result.errors:+            if not _first_error_printed:+                self._print_error_list(""ERROR"", result.errors)+                self._print_error_list(""FAIL"", result.failures)+                _first_error_printed = True             logging.info(""Aborting %s"", self.__class__.__name__)         else:             super().run(result)+            logging.info(""Passed test: %s"", self.__class__.__name__)","I think if a class has multiple tests, this will just print test class name for all of them. IRRC you should be able to use `self.id()`",
39062083,lsirac,https://api.github.com/repos/grpc/grpc/pulls/34001,1289232100,2023-08-09T21:42:28Z,test/core/security/credentials_test.cc,"@@ -3799,6 +3813,895 @@ TEST(CredentialsTest,   GPR_ASSERT(url_creds == nullptr); } +TEST(CredentialsTest,+     TestPluggableAuthExternalAccountCredentialsCreateSuccess) {+  const char* options_string =+      ""{\""type\"":\""external_account\"",""+      ""\""audience\"":\""audience\"",""+      ""\""subject_token_type\"":\""subject_token_type\"",""+      ""\""service_account_impersonation_url\"":\""service_account_impersonation_""+      ""url\"",\""token_url\"":\""token_url\"",""+      ""\""token_info_url\"":\""token_info_url\"",	\""credential_source\"": ""+      ""{\""executable\"":{""+      ""\""command\"":\""command\"",""+      ""\""output_file\"":\""output_file\""}},""+      ""\""quota_project_id\"":\""quota_project_id\"",""+      ""\""client_id\"":\""client_id\"",""+      ""\""client_secret\"":\""client_secret\""}"";+  auto options_json = JsonParse(options_string);+  GPR_ASSERT(options_json.ok());+  grpc_error_handle error;+  auto creds =+      ExternalAccountCredentials::Create(*options_json, {""scope""}, &error);+  GPR_ASSERT(error.ok());+  GPR_ASSERT(creds != nullptr);+}++TEST(CredentialsTest,+     TestPluggableAuthExternalAccountCredentialsCreateFailureInvalidCommand) {+  const char* options_string =+      ""{\""type\"":\""external_account\"",""+      ""\""audience\"":\""audience\"",""+      ""\""subject_token_type\"":\""subject_token_type\"",""+      ""\""service_account_impersonation_url\"":\""service_account_impersonation_""+      ""url\"",\""token_url\"":\""token_url\"",""+      ""\""token_info_url\"":\""token_info_url\"",	\""credential_source\"": ""+      ""{\""executable\"":{""+      ""\""timeout_millis\"":10000,""+      ""\""output_file\"":\""output_file\""}},""+      ""\""quota_project_id\"":\""quota_project_id\"",""+      ""\""client_id\"":\""client_id\"",""+      ""\""client_secret\"":\""client_secret\""}"";+  auto options_json = JsonParse(options_string);+  GPR_ASSERT(options_json.ok());+  grpc_error_handle error;+  auto creds =+      ExternalAccountCredentials::Create(*options_json, {""scope""}, &error);+  std::string actual_error, expected_error = ""command field not present."";+  grpc_error_get_str(error, StatusStrProperty::kDescription, &actual_error);+  GPR_ASSERT(strcmp(actual_error.c_str(), expected_error.c_str()) == 0);+}++TEST(+    CredentialsTest,+    TestPluggableAuthExternalAccountCredentialsCreateFailureExecutableTimeoutLessThan5Seconds) {+  const char* options_string =+      ""{\""type\"":\""external_account\"",""+      ""\""audience\"":\""audience\"",""+      ""\""subject_token_type\"":\""subject_token_type\"",""+      ""\""service_account_impersonation_url\"":\""service_account_impersonation_""+      ""url\"",\""token_url\"":\""token_url\"",""+      ""\""token_info_url\"":\""token_info_url\"",	\""credential_source\"": ""+      ""{\""executable\"":{""+      ""\""command\"":\""command\"",""+      ""\""timeout_millis\"":4999,""+      ""\""output_file\"":\""output_file\""}},""+      ""\""quota_project_id\"":\""quota_project_id\"",""+      ""\""client_id\"":\""client_id\"",""+      ""\""client_secret\"":\""client_secret\""}"";+  auto options_json = JsonParse(options_string);+  GPR_ASSERT(options_json.ok());+  grpc_error_handle error;+  auto creds =+      ExternalAccountCredentials::Create(*options_json, {""scope""}, &error);+  std::string actual_error,+      expected_error =+          ""timeout_millis should be between 5000 and 120000 milliseconds."";+  grpc_error_get_str(error, StatusStrProperty::kDescription, &actual_error);+  GPR_ASSERT(strcmp(actual_error.c_str(), expected_error.c_str()) == 0);+}++TEST(+    CredentialsTest,+    TestPluggableAuthExternalAccountCredentialsCreateFailureExecutableTimeoutMoreThan120Seconds) {+  const char* options_string =+      ""{\""type\"":\""external_account\"",""+      ""\""audience\"":\""audience\"",""+      ""\""subject_token_type\"":\""subject_token_type\"",""+      ""\""service_account_impersonation_url\"":\""service_account_impersonation_""+      ""url\"",\""token_url\"":\""token_url\"",""+      ""\""token_info_url\"":\""token_info_url\"",	\""credential_source\"": ""+      ""{\""executable\"":{""+      ""\""command\"":\""command\"",""+      ""\""timeout_millis\"":120001,""+      ""\""output_file\"":\""output_file\""}},""+      ""\""quota_project_id\"":\""quota_project_id\"",""+      ""\""client_id\"":\""client_id\"",""+      ""\""client_secret\"":\""client_secret\""}"";+  auto options_json = JsonParse(options_string);+  GPR_ASSERT(options_json.ok());+  grpc_error_handle error;+  auto creds =+      ExternalAccountCredentials::Create(*options_json, {""scope""}, &error);+  std::string actual_error,+      expected_error =+          ""timeout_millis should be between 5000 and 120000 milliseconds."";+  grpc_error_get_str(error, StatusStrProperty::kDescription, &actual_error);+  GPR_ASSERT(strcmp(actual_error.c_str(), expected_error.c_str()) == 0);+}++#ifndef GPR_WINDOWS++char* get_pluggable_auth_executable_file_contents_for_output_file(+    int32_t expiration_time, const char* output_file_filename) {+  std::string executable_file_contents = absl::StrFormat(+      ""#!/bin/bash\n\necho \""{\\\""version\\\"": 1,\\\""success\\\"": ""+      ""\""true\"",\\\""token_type\\\"": ""+      ""\\\""urn:ietf:params:oauth:token-type:saml2\\\"",\\\""saml_response\\\"":""+      ""\\\""test_subject_token\\\"",\\\""expiration_time\\\"":%d}\"" > %s"",+      expiration_time, output_file_filename);+  return gpr_strdup(executable_file_contents.c_str());+}++char* get_pluggable_auth_executable_file_contents(int32_t expiration_time) {+  std::string executable_file_contents = absl::StrFormat(+      ""#!/bin/bash\n\necho \""{\\\""version\\\"": 1,\\\""success\\\"": ""+      ""\""true\"",\\\""token_type\\\"": ""+      ""\\\""urn:ietf:params:oauth:token-type:saml2\\\"",\\\""saml_response\\\"":""+      ""\\\""test_subject_token\\\"",\\\""expiration_time\\\"":%d}\"""",+      expiration_time);+  return gpr_strdup(executable_file_contents.c_str());+}++char* get_pluggable_auth_executable_file_contents_for_id_token(+    int32_t expiration_time) {+  std::string executable_file_contents = absl::StrFormat(+      ""#!/bin/bash\n\necho \""{\\\""version\\\"": 1,\\\""success\\\"": ""+      ""\""true\"",\\\""token_type\\\"": ""+      ""\\\""urn:ietf:params:oauth:token-type:jwt\\\"",\\\""id_token\\\"":""+      ""\\\""test_subject_token\\\"",\\\""expiration_time\\\"":%d}\"""",+      expiration_time);+  return gpr_strdup(executable_file_contents.c_str());+}++Json get_valid_pluggable_auth_credential_source(const char* filename) {+  auto credential_source = JsonParse(+      absl::StrFormat(""{\""executable\"":{\""command\"":\""%s\""}}"", filename));+  GPR_ASSERT(credential_source.ok());+  return *credential_source;+}++Json get_valid_pluggable_auth_credential_source_with_output_file(+    const char* executable_filename, const char* output_file_filename) {+  auto credential_source = JsonParse(absl::StrFormat(+      ""{\""executable\"":{\""command\"":\""%s\"", \""output_file\"":\""%s\""}}"",+      executable_filename, output_file_filename));+  GPR_ASSERT(credential_source.ok());+  return *credential_source;+}","Same as above. These can be merged (or at the very least, one calls the other, no need to duplicate)",X
39062083,lsirac,https://api.github.com/repos/grpc/grpc/pulls/34001,1289264174,2023-08-09T22:15:25Z,test/core/security/credentials_test.cc,"@@ -3799,6 +3813,895 @@ TEST(CredentialsTest,   GPR_ASSERT(url_creds == nullptr); } +TEST(CredentialsTest,+     TestPluggableAuthExternalAccountCredentialsCreateSuccess) {+  const char* options_string =+      ""{\""type\"":\""external_account\"",""+      ""\""audience\"":\""audience\"",""+      ""\""subject_token_type\"":\""subject_token_type\"",""+      ""\""service_account_impersonation_url\"":\""service_account_impersonation_""+      ""url\"",\""token_url\"":\""token_url\"",""+      ""\""token_info_url\"":\""token_info_url\"",	\""credential_source\"": ""+      ""{\""executable\"":{""+      ""\""command\"":\""command\"",""+      ""\""output_file\"":\""output_file\""}},""+      ""\""quota_project_id\"":\""quota_project_id\"",""+      ""\""client_id\"":\""client_id\"",""+      ""\""client_secret\"":\""client_secret\""}"";+  auto options_json = JsonParse(options_string);+  GPR_ASSERT(options_json.ok());+  grpc_error_handle error;+  auto creds =+      ExternalAccountCredentials::Create(*options_json, {""scope""}, &error);+  GPR_ASSERT(error.ok());+  GPR_ASSERT(creds != nullptr);+}++TEST(CredentialsTest,+     TestPluggableAuthExternalAccountCredentialsCreateFailureInvalidCommand) {+  const char* options_string =+      ""{\""type\"":\""external_account\"",""+      ""\""audience\"":\""audience\"",""+      ""\""subject_token_type\"":\""subject_token_type\"",""+      ""\""service_account_impersonation_url\"":\""service_account_impersonation_""+      ""url\"",\""token_url\"":\""token_url\"",""+      ""\""token_info_url\"":\""token_info_url\"",	\""credential_source\"": ""+      ""{\""executable\"":{""+      ""\""timeout_millis\"":10000,""+      ""\""output_file\"":\""output_file\""}},""+      ""\""quota_project_id\"":\""quota_project_id\"",""+      ""\""client_id\"":\""client_id\"",""+      ""\""client_secret\"":\""client_secret\""}"";+  auto options_json = JsonParse(options_string);+  GPR_ASSERT(options_json.ok());+  grpc_error_handle error;+  auto creds =+      ExternalAccountCredentials::Create(*options_json, {""scope""}, &error);+  std::string actual_error, expected_error = ""command field not present."";+  grpc_error_get_str(error, StatusStrProperty::kDescription, &actual_error);+  GPR_ASSERT(strcmp(actual_error.c_str(), expected_error.c_str()) == 0);+}++TEST(+    CredentialsTest,+    TestPluggableAuthExternalAccountCredentialsCreateFailureExecutableTimeoutLessThan5Seconds) {+  const char* options_string =+      ""{\""type\"":\""external_account\"",""+      ""\""audience\"":\""audience\"",""+      ""\""subject_token_type\"":\""subject_token_type\"",""+      ""\""service_account_impersonation_url\"":\""service_account_impersonation_""+      ""url\"",\""token_url\"":\""token_url\"",""+      ""\""token_info_url\"":\""token_info_url\"",	\""credential_source\"": ""+      ""{\""executable\"":{""+      ""\""command\"":\""command\"",""+      ""\""timeout_millis\"":4999,""+      ""\""output_file\"":\""output_file\""}},""+      ""\""quota_project_id\"":\""quota_project_id\"",""+      ""\""client_id\"":\""client_id\"",""+      ""\""client_secret\"":\""client_secret\""}"";+  auto options_json = JsonParse(options_string);+  GPR_ASSERT(options_json.ok());+  grpc_error_handle error;+  auto creds =+      ExternalAccountCredentials::Create(*options_json, {""scope""}, &error);+  std::string actual_error,+      expected_error =+          ""timeout_millis should be between 5000 and 120000 milliseconds."";+  grpc_error_get_str(error, StatusStrProperty::kDescription, &actual_error);+  GPR_ASSERT(strcmp(actual_error.c_str(), expected_error.c_str()) == 0);+}++TEST(+    CredentialsTest,+    TestPluggableAuthExternalAccountCredentialsCreateFailureExecutableTimeoutMoreThan120Seconds) {+  const char* options_string =+      ""{\""type\"":\""external_account\"",""+      ""\""audience\"":\""audience\"",""+      ""\""subject_token_type\"":\""subject_token_type\"",""+      ""\""service_account_impersonation_url\"":\""service_account_impersonation_""+      ""url\"",\""token_url\"":\""token_url\"",""+      ""\""token_info_url\"":\""token_info_url\"",	\""credential_source\"": ""+      ""{\""executable\"":{""+      ""\""command\"":\""command\"",""+      ""\""timeout_millis\"":120001,""+      ""\""output_file\"":\""output_file\""}},""+      ""\""quota_project_id\"":\""quota_project_id\"",""+      ""\""client_id\"":\""client_id\"",""+      ""\""client_secret\"":\""client_secret\""}"";+  auto options_json = JsonParse(options_string);+  GPR_ASSERT(options_json.ok());+  grpc_error_handle error;+  auto creds =+      ExternalAccountCredentials::Create(*options_json, {""scope""}, &error);+  std::string actual_error,+      expected_error =+          ""timeout_millis should be between 5000 and 120000 milliseconds."";+  grpc_error_get_str(error, StatusStrProperty::kDescription, &actual_error);+  GPR_ASSERT(strcmp(actual_error.c_str(), expected_error.c_str()) == 0);+}++#ifndef GPR_WINDOWS++char* get_pluggable_auth_executable_file_contents_for_output_file(+    int32_t expiration_time, const char* output_file_filename) {+  std::string executable_file_contents = absl::StrFormat(+      ""#!/bin/bash\n\necho \""{\\\""version\\\"": 1,\\\""success\\\"": ""+      ""\""true\"",\\\""token_type\\\"": ""+      ""\\\""urn:ietf:params:oauth:token-type:saml2\\\"",\\\""saml_response\\\"":""+      ""\\\""test_subject_token\\\"",\\\""expiration_time\\\"":%d}\"" > %s"",+      expiration_time, output_file_filename);+  return gpr_strdup(executable_file_contents.c_str());+}++char* get_pluggable_auth_executable_file_contents(int32_t expiration_time) {+  std::string executable_file_contents = absl::StrFormat(+      ""#!/bin/bash\n\necho \""{\\\""version\\\"": 1,\\\""success\\\"": ""+      ""\""true\"",\\\""token_type\\\"": ""+      ""\\\""urn:ietf:params:oauth:token-type:saml2\\\"",\\\""saml_response\\\"":""+      ""\\\""test_subject_token\\\"",\\\""expiration_time\\\"":%d}\"""",+      expiration_time);+  return gpr_strdup(executable_file_contents.c_str());+}++char* get_pluggable_auth_executable_file_contents_for_id_token(+    int32_t expiration_time) {+  std::string executable_file_contents = absl::StrFormat(+      ""#!/bin/bash\n\necho \""{\\\""version\\\"": 1,\\\""success\\\"": ""+      ""\""true\"",\\\""token_type\\\"": ""+      ""\\\""urn:ietf:params:oauth:token-type:jwt\\\"",\\\""id_token\\\"":""+      ""\\\""test_subject_token\\\"",\\\""expiration_time\\\"":%d}\"""",+      expiration_time);+  return gpr_strdup(executable_file_contents.c_str());+}++Json get_valid_pluggable_auth_credential_source(const char* filename) {+  auto credential_source = JsonParse(+      absl::StrFormat(""{\""executable\"":{\""command\"":\""%s\""}}"", filename));+  GPR_ASSERT(credential_source.ok());+  return *credential_source;+}++Json get_valid_pluggable_auth_credential_source_with_output_file(+    const char* executable_filename, const char* output_file_filename) {+  auto credential_source = JsonParse(absl::StrFormat(+      ""{\""executable\"":{\""command\"":\""%s\"", \""output_file\"":\""%s\""}}"",+      executable_filename, output_file_filename));+  GPR_ASSERT(credential_source.ok());+  return *credential_source;+}++TEST(CredentialsTest, TestPluggableAuthExecutableSuccess) {+  ExecCtx exec_ctx;+  char* executable_file_contents = get_pluggable_auth_executable_file_contents(+      gpr_time_to_millis(gpr_inf_future(GPR_CLOCK_REALTIME)));+  char* filename =+      write_file(pluggable_auth_file_path_prefix, executable_file_contents);+  auto credential_source = get_valid_pluggable_auth_credential_source(filename);+  TestExternalAccountCredentials::ServiceAccountImpersonation+      service_account_impersonation;+  service_account_impersonation.token_lifetime_seconds = 3600;+  ExternalAccountCredentials::Options options = {+      ""external_account"",                 // type;+      ""audience"",                         // audience;+      ""subject_token_type"",               // subject_token_type;+      """",                                 // service_account_impersonation_url;+      service_account_impersonation,      // service_account_impersonation;+      ""https://foo.com:5555/token"",       // token_url;+      ""https://foo.com:5555/token_info"",  // token_info_url;+      credential_source,                  // credential_source;+      ""quota_project_id"",                 // quota_project_id;+      ""client_id"",                        // client_id;+      ""client_secret"",                    // client_secret;+      """",                                 // workforce_pool_user_project;+  };+  grpc_error_handle error;+  auto creds =+      PluggableAuthExternalAccountCredentials::Create(options, {}, &error);+  SetEnv(""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES"", ""1"");+  chmod(filename, ALLPERMS);+  GPR_ASSERT(creds != nullptr);+  auto state = RequestMetadataState::NewInstance(+      absl::OkStatus(), ""authorization: Bearer token_exchange_access_token"");+  HttpRequest::SetOverride(httpcli_get_should_not_be_called,+                           external_account_creds_httpcli_post_success,+                           httpcli_put_should_not_be_called);+  state->RunRequestMetadataTest(creds.get(), kTestUrlScheme, kTestAuthority,+                                kTestPath);+  ExecCtx::Get()->Flush();+  HttpRequest::SetOverride(nullptr, nullptr, nullptr);+  UnsetEnv(""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES"");+}++TEST(CredentialsTest, TestPluggableAuthExecutableSuccessIdToken) {+  ExecCtx exec_ctx;+  char* executable_file_contents =+      get_pluggable_auth_executable_file_contents_for_id_token(+          gpr_time_to_millis(gpr_inf_future(GPR_CLOCK_REALTIME)));+  char* filename =+      write_file(pluggable_auth_file_path_prefix, executable_file_contents);+  auto credential_source = get_valid_pluggable_auth_credential_source(filename);+  TestExternalAccountCredentials::ServiceAccountImpersonation+      service_account_impersonation;+  service_account_impersonation.token_lifetime_seconds = 3600;+  ExternalAccountCredentials::Options options = {+      ""external_account"",                 // type;+      ""audience"",                         // audience;+      ""subject_token_type"",               // subject_token_type;+      """",                                 // service_account_impersonation_url;+      service_account_impersonation,      // service_account_impersonation;+      ""https://foo.com:5555/token"",       // token_url;+      ""https://foo.com:5555/token_info"",  // token_info_url;+      credential_source,                  // credential_source;+      ""quota_project_id"",                 // quota_project_id;+      ""client_id"",                        // client_id;+      ""client_secret"",                    // client_secret;+      """",                                 // workforce_pool_user_project;+  };+  grpc_error_handle error;+  auto creds =+      PluggableAuthExternalAccountCredentials::Create(options, {}, &error);+  SetEnv(""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES"", ""1"");+  chmod(filename, ALLPERMS);+  GPR_ASSERT(creds != nullptr);+  auto state = RequestMetadataState::NewInstance(+      absl::OkStatus(), ""authorization: Bearer token_exchange_access_token"");+  HttpRequest::SetOverride(httpcli_get_should_not_be_called,+                           external_account_creds_httpcli_post_success,+                           httpcli_put_should_not_be_called);+  state->RunRequestMetadataTest(creds.get(), kTestUrlScheme, kTestAuthority,+                                kTestPath);+  ExecCtx::Get()->Flush();+  HttpRequest::SetOverride(nullptr, nullptr, nullptr);+  UnsetEnv(""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES"");+}++char* get_pluggable_auth_cached_executable_contents(int32_t expiration_time) {+  std::string cached_executable_response_file_contents = absl::StrFormat(+      ""{\""version\"": 1,\""success\"": ""+      ""true,\""token_type\"":\""urn:ietf:params:oauth:token-type:saml2\"",""+      ""\""saml_response\"":\""test_subject_token\"",\""expiration_time\"":%d}"",+      expiration_time);+  return gpr_strdup(cached_executable_response_file_contents.c_str());+}++TEST(CredentialsTest, TestPluggableAuthSuccessCachedExecutableResponse) {+  ExecCtx exec_ctx;+  char* cached_response_contents =+      get_pluggable_auth_cached_executable_contents(+          gpr_time_to_millis(gpr_inf_future(GPR_CLOCK_REALTIME)));+  char* cached_output_file_filename =+      write_file(pluggable_auth_file_path_prefix, cached_response_contents);+  auto credential_source =+      get_valid_pluggable_auth_credential_source_with_output_file(+          ""invalid executable"", cached_output_file_filename);+  TestExternalAccountCredentials::ServiceAccountImpersonation+      service_account_impersonation;+  service_account_impersonation.token_lifetime_seconds = 3600;+  ExternalAccountCredentials::Options options = {+      ""external_account"",                 // type;+      ""audience"",                         // audience;+      ""subject_token_type"",               // subject_token_type;+      """",                                 // service_account_impersonation_url;+      service_account_impersonation,      // service_account_impersonation;+      ""https://foo.com:5555/token"",       // token_url;+      ""https://foo.com:5555/token_info"",  // token_info_url;+      credential_source,                  // credential_source;+      ""quota_project_id"",                 // quota_project_id;+      ""client_id"",                        // client_id;+      ""client_secret"",                    // client_secret;+      """",                                 // workforce_pool_user_project;+  };+  grpc_error_handle error;+  auto creds =+      PluggableAuthExternalAccountCredentials::Create(options, {}, &error);+  SetEnv(""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES"", ""1"");+  GPR_ASSERT(creds != nullptr);+  auto state = RequestMetadataState::NewInstance(+      absl::OkStatus(), ""authorization: Bearer token_exchange_access_token"");+  HttpRequest::SetOverride(httpcli_get_should_not_be_called,+                           external_account_creds_httpcli_post_success,+                           httpcli_put_should_not_be_called);+  state->RunRequestMetadataTest(creds.get(), kTestUrlScheme, kTestAuthority,+                                kTestPath);+  ExecCtx::Get()->Flush();+  HttpRequest::SetOverride(nullptr, nullptr, nullptr);+  UnsetEnv(""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES"");+}++TEST(CredentialsTest,+     TestPluggableAuthSuccessWithExpiredCachedExecutableResponse) {+  ExecCtx exec_ctx;+  char* cached_response_contents =+      get_pluggable_auth_cached_executable_contents(+          gpr_time_to_millis(gpr_inf_past(GPR_CLOCK_REALTIME)));+  char* cached_output_file_filename =+      write_file(pluggable_auth_file_path_prefix, cached_response_contents);+  char* executable_file_contents =+      get_pluggable_auth_executable_file_contents_for_output_file(+          gpr_time_to_millis(gpr_inf_future(GPR_CLOCK_REALTIME)),+          cached_output_file_filename);+  char* executable_file_filename =+      write_file(pluggable_auth_file_path_prefix, executable_file_contents);+  auto credential_source =+      get_valid_pluggable_auth_credential_source_with_output_file(+          executable_file_filename, cached_output_file_filename);+  TestExternalAccountCredentials::ServiceAccountImpersonation+      service_account_impersonation;+  service_account_impersonation.token_lifetime_seconds = 3600;+  ExternalAccountCredentials::Options options = {+      ""external_account"",                 // type;+      ""audience"",                         // audience;+      ""subject_token_type"",               // subject_token_type;+      """",                                 // service_account_impersonation_url;+      service_account_impersonation,      // service_account_impersonation;+      ""https://foo.com:5555/token"",       // token_url;+      ""https://foo.com:5555/token_info"",  // token_info_url;+      credential_source,                  // credential_source;+      ""quota_project_id"",                 // quota_project_id;+      ""client_id"",                        // client_id;+      ""client_secret"",                    // client_secret;+      """",                                 // workforce_pool_user_project;+  };+  grpc_error_handle error;+  auto creds =+      PluggableAuthExternalAccountCredentials::Create(options, {}, &error);+  SetEnv(""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES"", ""1"");+  chmod(executable_file_filename, ALLPERMS);+  GPR_ASSERT(creds != nullptr);+  auto state = RequestMetadataState::NewInstance(+      absl::OkStatus(), ""authorization: Bearer token_exchange_access_token"");+  HttpRequest::SetOverride(httpcli_get_should_not_be_called,+                           external_account_creds_httpcli_post_success,+                           httpcli_put_should_not_be_called);+  state->RunRequestMetadataTest(creds.get(), kTestUrlScheme, kTestAuthority,+                                kTestPath);+  ExecCtx::Get()->Flush();+  HttpRequest::SetOverride(nullptr, nullptr, nullptr);+  UnsetEnv(""GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES"");+}++TEST(CredentialsTest,","These tests are mostly copy and pasted many times over. Let's refactor them to avoid duplicating them a bunch (e.g. move common logical pieces into their own function, check if we parameterize tests in this repo)",X
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/33175,1289292335,2023-08-09T22:30:52Z,third_party/upb/upb/port/def.inc,"@@ -327,3 +327,30 @@ void __asan_unpoison_memory_region(void const volatile *addr, size_t size); #else #define UPB_DESC(sym) google_protobuf_##sym #endif+",All files under `third_party/upb' and `src/core/ext/upb-generated' are not allowed to be modified as they belong to other project. Would you undo this change?,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/34025,1289453022,2023-08-10T02:19:13Z,src/core/lib/event_engine/ares_resolver.cc,"@@ -702,4 +707,6 @@ void noop_inject_channel_config(ares_channel* /*channel*/) {} void (*event_engine_grpc_ares_test_only_inject_config)(ares_channel* channel) =     noop_inject_channel_config; +bool g_event_engine_grpc_ares_test_only_force_tcp = false;",will it ever be possible to compile this and the older grpc_ares_wrapper code into the same binary?If so we would have an ODR violation here?I suppose we have the same issue with `noop_inject_channel_config` ?,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/34025,1289468509,2023-08-10T02:32:32Z,src/core/lib/event_engine/posix_engine/grpc_polled_fd_posix.h,"@@ -93,16 +103,95 @@ class GrpcPolledFdFactoryPosix : public GrpcPolledFdFactory {   explicit GrpcPolledFdFactoryPosix(PosixEventPoller* poller)       : poller_(poller) {} +  ~GrpcPolledFdFactoryPosix() override {+    for (auto& fd : owned_fds_) {+      close(fd);+    }+  }+   GrpcPolledFd* NewGrpcPolledFdLocked(ares_socket_t as) override {+    GPR_ASSERT(owned_fds_.insert(as).second);     return new GrpcPolledFdPosix(         as,         poller_->CreateHandle(as, ""c-ares socket"", poller_->CanTrackErrors()));   } -  void ConfigureAresChannelLocked(ares_channel /*channel*/) override {}+  void ConfigureAresChannelLocked(ares_channel channel) override {+    ares_set_socket_functions(channel, &kSockFuncs, this);+    ares_set_socket_configure_callback(+        channel, &GrpcPolledFdFactoryPosix::ConfigureSocket, nullptr);+  }   private:+  /// Overridden socket API for c-ares+  static ares_socket_t Socket(int af, int type, int protocol,+                              void* /*user_data*/) {+    return socket(af, type, protocol);+  }++  /// Overridden connect API for c-ares+  static int Connect(ares_socket_t as, const struct sockaddr* target,+                     ares_socklen_t target_len, void* /*user_data*/) {+    return connect(as, target, target_len);+  }++  /// Overridden writev API for c-ares+  static ares_ssize_t WriteV(ares_socket_t as, const struct iovec* iov,+                             int iovec_count, void* /*user_data*/) {+    return writev(as, iov, iovec_count);+  }++  /// Overridden recvfrom API for c-ares+  static ares_ssize_t RecvFrom(ares_socket_t as, void* data, size_t data_len,+                               int flags, struct sockaddr* from,+                               ares_socklen_t* from_len, void* /*user_data*/) {+    return recvfrom(as, data, data_len, flags, from, from_len);+  }++  /// Overridden close API for c-ares+  static int Close(ares_socket_t as, void* user_data) {+    GrpcPolledFdFactoryPosix* self =+        static_cast<GrpcPolledFdFactoryPosix*>(user_data);+    if (self->owned_fds_.find(as) == self->owned_fds_.end()) {+      // c-ares owns this fd, grpc has never seen it+      return close(as);+    }+    return 0;+  }++  /// Because we're using socket API overrides, c-ares won't+  /// perform its typical configuration on the socket. See+  /// https://github.com/c-ares/c-ares/blob/bad62225b7f6b278b92e8e85a255600b629ef517/src/lib/ares_process.c#L1018.+  /// So we use the configure socket callback override and copy default+  /// settings that c-ares would normally apply on posix platforms:+  ///   - non-blocking+  ///   - cloexec flag+  ///   - disable nagle+  static int ConfigureSocket(ares_socket_t fd, int type, void* /*user_data*/) {+    // clang-format off+#define RETURN_IF_ERROR(expr) if (!(expr).ok()) { return -1; }+    // clang-format on+    PosixSocketWrapper sock(fd);+    RETURN_IF_ERROR(sock.SetSocketNonBlocking(1));+    RETURN_IF_ERROR(sock.SetSocketCloexec(1));+    if (type == SOCK_STREAM) {+      RETURN_IF_ERROR(sock.SetSocketLowLatency(1));+    }+    return 0;+  }++  const struct ares_socket_functions kSockFuncs = {+      &GrpcPolledFdFactoryPosix::Socket /* socket */,+      &GrpcPolledFdFactoryPosix::Close /* close */,+      &GrpcPolledFdFactoryPosix::Connect /* connect */,+      &GrpcPolledFdFactoryPosix::RecvFrom /* recvfrom */,+      &GrpcPolledFdFactoryPosix::WriteV /* writev */,+  };+   PosixEventPoller* poller_;+  // fds that are used/owned by grpc - we (grpc) will close them rather than+  // c-ares+  std::unordered_set<ares_socket_t> owned_fds_;","One sharp edge on this API that I think becomes apparent with this change:The `GrpcPolledFdFactoryPosix` will accumulate memory on each lookup, which won't be free'd until destroyed. So it can't be used as a long-lived object. For example we'd have a leak if the client channel resolver code was changed to create one resolver and keep using it.To double check, no code will ever use this `GrpcPolledFdFactoryPosix` as a long-lived object, right? From my reading I think we are good as of today. Wondering if there's any better enforcement than a comment to prevent this kind of mistake in the future though.",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/33878,1289812389,2023-08-10T09:10:13Z,src/compiler/csharp_generator.cc,"@@ -735,14 +738,15 @@ void GenerateBindServiceWithBinderMethod(Printer* out,   for (int i = 0; i < service->method_count(); i++) {     const MethodDescriptor* method = service->method(i);     out->Print(-        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? null : ""+        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? ""+        ""null$nullforgiving$ : ""","If I remove the null forgiving operator the warning is:`CS8604 Possible null reference argument for parameter 'handler' in 'void ServiceBinderBase.AddMethod<Point, Feature>(Method<Point, Feature> method, UnaryServerMethod<Point, Feature> handler)'.`so it does appear to be necessary.",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/33175,1290780192,2023-08-10T23:50:06Z,CMakeLists.txt,,We might be able to create a new test based on https://github.com/grpc/grpc/blob/master/test/distrib/cpp/run_distrib_test_cmake.bat,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1291587038,2023-08-11T16:53:08Z,tools/run_tests/xds_k8s_test_driver/framework/test_cases/base_testcase.py,"@@ -0,0 +1,54 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""Base test case used for xds tests.""""""++from typing import List, Optional, Tuple+import unittest++from absl import logging+from absl.testing import absltest++# Type aliases+ErrorAndFailureType = Tuple[unittest.TestCase, str]+++class BaseTestCase(absltest.TestCase):+    def run(self, result: unittest.TestResult = None) -> None:+        super().run(result)+        current_errors = self._get_current_errors(result.errors)+        current_failures = self._get_current_errors(result.failures)+        if not current_errors and not current_failures:+            logging.info(""----- TestCase %s PASSED -----"", self.id())+        else:+            logging.info(""----- TestCase %s FAILED -----"", self.id())+            if current_errors:+                self._print_error_list(""ERROR"", current_errors)+            if current_failures:+                self._print_error_list(""FAILURE"", current_failures)++    def _get_current_errors(+        self, errors: List[ErrorAndFailureType]","Prefer `list` to `typing.List````class typing.List(list, MutableSequence[T])Deprecated alias to list.```>  http://docs.python.org/3/library/typing.html#typing.List",
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/33876,1291709594,2023-08-11T19:29:41Z,src/core/ext/transport/chaotic_good/client_transport.cc,"@@ -0,0 +1,120 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/ext/transport/chaotic_good/client_transport.h""++#include <stdlib.h>++#include <memory>+#include <string>+#include <tuple>++#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/slice.h>+#include <grpc/support/log.h>++#include ""src/core/ext/transport/chaotic_good/frame.h""+#include ""src/core/ext/transport/chaotic_good/frame_header.h""+#include ""src/core/ext/transport/chttp2/transport/hpack_encoder.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/detail/basic_seq.h""+#include ""src/core/lib/promise/event_engine_wakeup_scheduler.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/loop.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/slice/slice_internal.h""+#include ""src/core/lib/transport/promise_endpoint.h""++namespace grpc_core {+namespace chaotic_good {++ClientTransport::ClientTransport(+    std::unique_ptr<PromiseEndpoint> control_endpoint,+    std::unique_ptr<PromiseEndpoint> data_endpoint,+    std::shared_ptr<grpc_event_engine::experimental::EventEngine> event_engine)+    : outgoing_frames_(MpscReceiver<ClientFrame>(4)),+      control_endpoint_(std::move(control_endpoint)),+      data_endpoint_(std::move(data_endpoint)),+      control_endpoint_write_buffer_(SliceBuffer()),+      data_endpoint_write_buffer_(SliceBuffer()),+      event_engine_(event_engine) {+  auto hpack_compressor = std::make_shared<HPackCompressor>();",Lets make hpack_compressor also as a member of the ClientTransport class ? Is there a reason not to do so ?,X
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/34025,1291729150,2023-08-11T19:58:48Z,src/core/lib/event_engine/posix_engine/grpc_polled_fd_posix.h,"@@ -93,16 +103,95 @@ class GrpcPolledFdFactoryPosix : public GrpcPolledFdFactory {   explicit GrpcPolledFdFactoryPosix(PosixEventPoller* poller)       : poller_(poller) {} +  ~GrpcPolledFdFactoryPosix() override {+    for (auto& fd : owned_fds_) {+      close(fd);+    }+  }+   GrpcPolledFd* NewGrpcPolledFdLocked(ares_socket_t as) override {+    GPR_ASSERT(owned_fds_.insert(as).second);     return new GrpcPolledFdPosix(         as,         poller_->CreateHandle(as, ""c-ares socket"", poller_->CanTrackErrors()));   } -  void ConfigureAresChannelLocked(ares_channel /*channel*/) override {}+  void ConfigureAresChannelLocked(ares_channel channel) override {+    ares_set_socket_functions(channel, &kSockFuncs, this);+    ares_set_socket_configure_callback(+        channel, &GrpcPolledFdFactoryPosix::ConfigureSocket, nullptr);+  }   private:+  /// Overridden socket API for c-ares+  static ares_socket_t Socket(int af, int type, int protocol,+                              void* /*user_data*/) {+    return socket(af, type, protocol);+  }++  /// Overridden connect API for c-ares+  static int Connect(ares_socket_t as, const struct sockaddr* target,+                     ares_socklen_t target_len, void* /*user_data*/) {+    return connect(as, target, target_len);+  }++  /// Overridden writev API for c-ares+  static ares_ssize_t WriteV(ares_socket_t as, const struct iovec* iov,+                             int iovec_count, void* /*user_data*/) {+    return writev(as, iov, iovec_count);+  }++  /// Overridden recvfrom API for c-ares+  static ares_ssize_t RecvFrom(ares_socket_t as, void* data, size_t data_len,+                               int flags, struct sockaddr* from,+                               ares_socklen_t* from_len, void* /*user_data*/) {+    return recvfrom(as, data, data_len, flags, from, from_len);+  }++  /// Overridden close API for c-ares+  static int Close(ares_socket_t as, void* user_data) {+    GrpcPolledFdFactoryPosix* self =+        static_cast<GrpcPolledFdFactoryPosix*>(user_data);+    if (self->owned_fds_.find(as) == self->owned_fds_.end()) {+      // c-ares owns this fd, grpc has never seen it+      return close(as);+    }+    return 0;+  }++  /// Because we're using socket API overrides, c-ares won't+  /// perform its typical configuration on the socket. See+  /// https://github.com/c-ares/c-ares/blob/bad62225b7f6b278b92e8e85a255600b629ef517/src/lib/ares_process.c#L1018.+  /// So we use the configure socket callback override and copy default+  /// settings that c-ares would normally apply on posix platforms:+  ///   - non-blocking+  ///   - cloexec flag+  ///   - disable nagle+  static int ConfigureSocket(ares_socket_t fd, int type, void* /*user_data*/) {+    // clang-format off+#define RETURN_IF_ERROR(expr) if (!(expr).ok()) { return -1; }+    // clang-format on+    PosixSocketWrapper sock(fd);+    RETURN_IF_ERROR(sock.SetSocketNonBlocking(1));+    RETURN_IF_ERROR(sock.SetSocketCloexec(1));+    if (type == SOCK_STREAM) {+      RETURN_IF_ERROR(sock.SetSocketLowLatency(1));+    }+    return 0;+  }++  const struct ares_socket_functions kSockFuncs = {+      &GrpcPolledFdFactoryPosix::Socket /* socket */,+      &GrpcPolledFdFactoryPosix::Close /* close */,+      &GrpcPolledFdFactoryPosix::Connect /* connect */,+      &GrpcPolledFdFactoryPosix::RecvFrom /* recvfrom */,+      &GrpcPolledFdFactoryPosix::WriteV /* writev */,+  };+   PosixEventPoller* poller_;+  // fds that are used/owned by grpc - we (grpc) will close them rather than+  // c-ares+  std::unordered_set<ares_socket_t> owned_fds_;","> Each client channel resolver indirectly creates a GrpcPolledFdFactoryPosix, so it will be destroyed when the request finishes.Sounds good. I guess, we just need to make sure it stays that way. cc @markdroth Just to note, I'm not really concerned about the memory overhead. What I really mean to point out is there there is the possibility that we could have a memory leak if, in the future, we ever mistakenly uses this API as a long-lived object - then we'd have a leak and could eventually OOM or run out of file descriptors.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1293664620,2023-08-14T15:54:25Z,tools/run_tests/xds_k8s_test_driver/framework/test_cases/base_testcase.py,"@@ -0,0 +1,48 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""Base test case used for xds test suites.""""""++from typing import Optional+import unittest++from absl import logging+from absl.testing import absltest+++class BaseTestCase(absltest.TestCase):+    def run(self, result: unittest.TestResult = None) -> None:+        super().run(result)+        current_errors = [+            error for test, error in result.errors if test is self+        ]+        current_failures = [+            failure for test, failure in result.failures if test is self+        ]+        if current_errors or current_failures:+            logging.info(""----- TestCase %s FAILED -----"", self.id())+            if current_errors:+                self._print_error_list(""ERROR"", current_errors)+            if current_failures:+                self._print_error_list(""FAILURE"", current_failures)+        else:+            logging.info(""----- TestCase %s PASSED -----"", self.id())++    def _print_error_list(+        self, flavour: str, errors: Optional[list[str]]+    ) -> None:+        if not errors:+            return",Not necessary - a `for` loop over an empty list will produce nothing.,X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1293690840,2023-08-14T16:17:02Z,tools/run_tests/xds_k8s_test_driver/framework/test_cases/base_testcase.py,"@@ -0,0 +1,48 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""Base test case used for xds test suites.""""""++from typing import Optional+import unittest++from absl import logging+from absl.testing import absltest+++class BaseTestCase(absltest.TestCase):+    def run(self, result: unittest.TestResult = None) -> None:+        super().run(result)+        current_errors = [+            error for test, error in result.errors if test is self+        ]+        current_failures = [+            failure for test, failure in result.failures if test is self+        ]+        if current_errors or current_failures:+            logging.info(""----- TestCase %s FAILED -----"", self.id())+            if current_errors:+                self._print_error_list(""ERROR"", current_errors)","`flavour` argument is unclear. Let's make it a `is_unexpected_error` and move down `ERROR` and `FAILURE` to `_print_error_list(errors, is_unexpected_error: bool = False)`. Also let's add a comment explaining that failures are those errors that `explicitly signalled using the TestCase.assert*() methods` - https://docs.python.org/3/library/unittest.html#unittest.TestResult",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1293698862,2023-08-14T16:23:02Z,tools/run_tests/xds_k8s_test_driver/framework/test_cases/base_testcase.py,"@@ -0,0 +1,48 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""Base test case used for xds test suites.""""""++from typing import Optional+import unittest++from absl import logging+from absl.testing import absltest+++class BaseTestCase(absltest.TestCase):+    def run(self, result: unittest.TestResult = None) -> None:+        super().run(result)+        current_errors = [+            error for test, error in result.errors if test is self+        ]+        current_failures = [+            failure for test, failure in result.failures if test is self+        ]+        if current_errors or current_failures:+            logging.info(""----- TestCase %s FAILED -----"", self.id())+            if current_errors:+                self._print_error_list(""ERROR"", current_errors)+            if current_failures:+                self._print_error_list(""FAILURE"", current_failures)+        else:","Looks like there's two more possible cases (https://docs.python.org/3/library/unittest.html#unittest.TestResult)- a test is skipped when it's in `result.skipped`- a test was expected to fail, but it succeeded when it's in `result. unexpectedSuccesses`",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1293786585,2023-08-14T17:48:49Z,tools/run_tests/xds_k8s_test_driver/framework/test_cases/base_testcase.py,"@@ -0,0 +1,66 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""Base test case used for xds test suites.""""""++from typing import Optional+import unittest++from absl import logging+from absl.testing import absltest+++class BaseTestCase(absltest.TestCase):+    def run(self, result: unittest.TestResult = None) -> None:+        super().run(result)+        current_errors = [+            error for test, error in result.errors if test is self+        ]+        current_failures = [+            failure for test, failure in result.failures if test is self+        ]+        current_unexpected_successes = [+            test for test in result.unexpectedSuccesses if test is self+        ]+        current_skipped = [+            reason for test, reason in result.skipped if test is self+        ]+        # Assume one test case will only have one status.+        if current_errors or current_failures:+            logging.info(""----- TestCase %s FAILED -----"", self.id())+            if current_errors:+                self._print_error_list(current_errors, is_unexpected_error=True)+            if current_failures:+                self._print_error_list(current_failures)+        elif current_unexpected_successes:+            logging.info(+                ""----- TestCase %s UNEXPECTEDLY SUCCEED -----"", self.id()+            )+        elif current_skipped:+            logging.info(""----- TestCase %s SKIPPED -----"", self.id())+            logging.info(""Reason for skipping: %s"", current_skipped)+        else:+            logging.info(""----- TestCase %s PASSED -----"", self.id())++    def _print_error_list(+        self, errors: Optional[list[str]], is_unexpected_error: bool = False",1. No need for Optional - we never pass it as None2. Not sure if the list contains strings and not exceptions,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34023,1293821222,2023-08-14T18:22:02Z,tools/run_tests/xds_k8s_test_driver/framework/test_cases/base_testcase.py,"@@ -0,0 +1,66 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""Base test case used for xds test suites.""""""++from typing import Optional+import unittest++from absl import logging+from absl.testing import absltest+++class BaseTestCase(absltest.TestCase):+    def run(self, result: unittest.TestResult = None) -> None:+        super().run(result)+        current_errors = [+            error for test, error in result.errors if test is self+        ]+        current_failures = [+            failure for test, failure in result.failures if test is self+        ]+        current_unexpected_successes = [+            test for test in result.unexpectedSuccesses if test is self+        ]+        current_skipped = [+            reason for test, reason in result.skipped if test is self+        ]+        # Assume one test case will only have one status.+        if current_errors or current_failures:+            logging.info(""----- TestCase %s FAILED -----"", self.id())+            if current_errors:+                self._print_error_list(current_errors, is_unexpected_error=True)+            if current_failures:+                self._print_error_list(current_failures)+        elif current_unexpected_successes:+            logging.info(+                ""----- TestCase %s UNEXPECTEDLY SUCCEED -----"", self.id()+            )+        elif current_skipped:+            logging.info(""----- TestCase %s SKIPPED -----"", self.id())+            logging.info(""Reason for skipping: %s"", current_skipped)+        else:+            logging.info(""----- TestCase %s PASSED -----"", self.id())++    def _print_error_list(+        self, errors: Optional[list[str]], is_unexpected_error: bool = False","2 - nope, the is a `list[str]` - just checked",
31627465,nanahpang,https://api.github.com/repos/grpc/grpc/pulls/33876,1295039582,2023-08-15T19:44:54Z,src/core/ext/transport/chaotic_good/client_transport.cc,"@@ -0,0 +1,120 @@+// Copyright 2022 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/ext/transport/chaotic_good/client_transport.h""++#include <stdlib.h>++#include <memory>+#include <string>+#include <tuple>++#include ""absl/status/statusor.h""++#include <grpc/event_engine/event_engine.h>+#include <grpc/slice.h>+#include <grpc/support/log.h>++#include ""src/core/ext/transport/chaotic_good/frame.h""+#include ""src/core/ext/transport/chaotic_good/frame_header.h""+#include ""src/core/ext/transport/chttp2/transport/hpack_encoder.h""+#include ""src/core/lib/gprpp/match.h""+#include ""src/core/lib/promise/activity.h""+#include ""src/core/lib/promise/detail/basic_seq.h""+#include ""src/core/lib/promise/event_engine_wakeup_scheduler.h""+#include ""src/core/lib/promise/join.h""+#include ""src/core/lib/promise/loop.h""+#include ""src/core/lib/slice/slice.h""+#include ""src/core/lib/slice/slice_buffer.h""+#include ""src/core/lib/slice/slice_internal.h""+#include ""src/core/lib/transport/promise_endpoint.h""++namespace grpc_core {+namespace chaotic_good {++ClientTransport::ClientTransport(+    std::unique_ptr<PromiseEndpoint> control_endpoint,+    std::unique_ptr<PromiseEndpoint> data_endpoint,+    std::shared_ptr<grpc_event_engine::experimental::EventEngine> event_engine)+    : outgoing_frames_(MpscReceiver<ClientFrame>(4)),+      control_endpoint_(std::move(control_endpoint)),+      data_endpoint_(std::move(data_endpoint)),+      control_endpoint_write_buffer_(SliceBuffer()),+      data_endpoint_write_buffer_(SliceBuffer()),+      event_engine_(event_engine) {+  auto hpack_compressor = std::make_shared<HPackCompressor>();","Not really, I think we were using it as a local variable in Constructor because there's no other place need it. But moving to the class member should good, I've updated the code.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34054,1295126196,2023-08-15T21:19:53Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -62,10 +62,9 @@ namespace grpc_core {  TraceFlag grpc_lb_pick_first_trace(false, ""pick_first""); -// TODO(eostroukhov): Remove once this feature is no longer experimental. bool ShufflePickFirstEnabled() {","Let's just remove this completely.  If it's passing interop tests, we no longer need the knob.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34054,1295126552,2023-08-15T21:20:20Z,test/core/xds/xds_lb_policy_registry_test.cc,"@@ -486,13 +486,13 @@ TEST(PickFirst, ShuffleOmitted) {   EXPECT_EQ(*result, ""{\""pick_first\"":{\""shuffleAddressList\"":false}}""); } -TEST(PickFirst, EnvVarDisabled) {+TEST(PickFirst, EnvVarEnabled) {","This test no longer has value, so let's just remove it.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/34065,1295140116,2023-08-15T21:35:02Z,src/core/lib/event_engine/thread_pool/thread_count.h,"@@ -0,0 +1,95 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include <grpc/support/port_platform.h>++#include <atomic>+#include <cstddef>+#include <vector>++#include ""absl/base/thread_annotations.h""++#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/gprpp/time.h""++namespace grpc_event_engine {+namespace experimental {++// Tracks counts across some fixed number of shards.+// It is intended for fast increment/decrement operations, but a slower overall+// count operation.+class BusyThreadCount {+ public:+  // Increments a per-shard counter on construction, decrements on destruction.+  class AutoThreadCounter {+   public:+    AutoThreadCounter(BusyThreadCount* counter, size_t idx);+    ~AutoThreadCounter();++   private:+    BusyThreadCount* counter_;+    size_t idx_;+  };++  BusyThreadCount();+  AutoThreadCounter MakeAutoThreadCounter(size_t idx);+  void Increment(size_t idx);+  void Decrement(size_t idx);+  size_t count();+  // Returns some valid index into the per-shard data, which is rotated on every+  // call to distribute load and reduce contention.+  size_t NextIndex();++ private:+  struct ShardedData {+    std::atomic<int> busy_count{0};+  } GPR_ALIGN_STRUCT(GPR_CACHELINE_SIZE);++  std::vector<ShardedData> shards_;+  std::atomic<int> next_idx_{0};+};++// Tracks the number of living threads. It is intended for a fast count+// operation, with relatively slower increment/decrement operations.+class LivingThreadCount {+ public:+  // Increments the global counter on construction, decrements on destruction.+  class AutoThreadCounter {+   public:+    explicit AutoThreadCounter(LivingThreadCount* counter);+    ~AutoThreadCounter();++   private:+    LivingThreadCount* counter_;+  };++  AutoThreadCounter MakeAutoThreadCounter();+  void Increment() ABSL_LOCKS_EXCLUDED(mu_);+  void Decrement() ABSL_LOCKS_EXCLUDED(mu_);+  void BlockUntilThreadCount(size_t desired_threads,+                             grpc_core::Duration timeout, const char* why)","This is only used for periodic logging, ""Waiting for thread pool to idle ..."". An example where it's been useful: we've seen fork tests hang with a large list of these logs, and the long log list helps identify where and how things got stuck.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/34056,1295371999,2023-08-16T04:42:14Z,src/cpp/common/alarm.cc,"@@ -52,78 +62,94 @@ class AlarmImpl : public grpc::internal::CompletionQueueTag {     return true;   }   void Set(grpc::CompletionQueue* cq, gpr_timespec deadline, void* tag) {-    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;     grpc_core::ExecCtx exec_ctx;     GRPC_CQ_INTERNAL_REF(cq->cq(), ""alarm"");     cq_ = cq->cq();     tag_ = tag;     GPR_ASSERT(grpc_cq_begin_op(cq_, this));-    GRPC_CLOSURE_INIT(-        &on_alarm_,-        [](void* arg, grpc_error_handle error) {-          // queue the op on the completion queue-          AlarmImpl* alarm = static_cast<AlarmImpl*>(arg);-          alarm->Ref();-          // Preserve the cq and reset the cq_ so that the alarm-          // can be reset when the alarm tag is delivered.-          grpc_completion_queue* cq = alarm->cq_;-          alarm->cq_ = nullptr;-          grpc_cq_end_op(-              cq, alarm, error,-              [](void* /*arg*/, grpc_cq_completion* /*completion*/) {}, arg,-              &alarm->completion_);-          GRPC_CQ_INTERNAL_UNREF(cq, ""alarm"");-        },-        this, grpc_schedule_on_exec_ctx);-    grpc_timer_init(&timer_,-                    grpc_core::Timestamp::FromTimespecRoundUp(deadline),-                    &on_alarm_);+    Ref();+    GPR_ASSERT(cq_armed_.exchange(true) == false);+    GPR_ASSERT(!callback_armed_.load());+    cq_timer_handle_ = event_engine_->RunAfter(+        grpc_core::Timestamp::FromTimespecRoundUp(deadline) -+            grpc_core::ExecCtx::Get()->Now(),+        [this] {+          cq_armed_.store(false);+          OnCQAlarm(absl::OkStatus());+        });   }   void Set(gpr_timespec deadline, std::function<void(bool)> f) {-    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;     grpc_core::ExecCtx exec_ctx;     // Don't use any CQ at all. Instead just use the timer to fire the function     callback_ = std::move(f);     Ref();-    GRPC_CLOSURE_INIT(-        &on_alarm_,-        [](void* arg, grpc_error_handle error) {-          grpc_core::Executor::Run(GRPC_CLOSURE_CREATE(-                                       [](void* arg, grpc_error_handle error) {-                                         AlarmImpl* alarm =-                                             static_cast<AlarmImpl*>(arg);-                                         alarm->callback_(error.ok());-                                         alarm->Unref();-                                       },-                                       arg, nullptr),-                                   error);-        },-        this, grpc_schedule_on_exec_ctx);-    grpc_timer_init(&timer_,-                    grpc_core::Timestamp::FromTimespecRoundUp(deadline),-                    &on_alarm_);+    GPR_ASSERT(callback_armed_.exchange(true) == false);+    GPR_ASSERT(!cq_armed_.load());","So an alarm can be either `callback_armed_` or `cq_armed_`, but not both? Is this semantic documented somewhere? What will happen if we allow both?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34075,1296425799,2023-08-16T21:02:43Z,src/core/lib/channel/channel_args.cc,"@@ -313,6 +313,17 @@ std::string ChannelArgs::ToString() const {   return absl::StrCat(""{"", absl::StrJoin(arg_strings, "", ""), ""}""); } +std::vector<std::vector<std::string>> ChannelArgs::GetChannelArgsDebugInfo() const {",Where will we be using the return value (in production code) - I'm curious about the choice of data structure here.,
139093547,tanvi-jagtap,https://api.github.com/repos/grpc/grpc/pulls/34075,1296623407,2023-08-17T03:05:18Z,src/core/lib/channel/channel_args.cc,"@@ -313,6 +313,17 @@ std::string ChannelArgs::ToString() const {   return absl::StrCat(""{"", absl::StrJoin(arg_strings, "", ""), ""}""); } +std::vector<std::vector<std::string>> ChannelArgs::GetChannelArgsDebugInfo() const {","I thought of a proto , but that would not be suitable for non-Google code.I thought maybe a new struct or class. But then we would have to convert it to a string somewhere in the code... I thought of a single csv like string, but Yousuk pointed out that people may want to surface this debugging information in their own way. We should let them process it in their own way. ",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/33878,1297081374,2023-08-17T11:22:08Z,src/compiler/csharp_generator.cc,"@@ -735,14 +738,15 @@ void GenerateBindServiceWithBinderMethod(Printer* out,   for (int i = 0; i < service->method_count(); i++) {     const MethodDescriptor* method = service->method(i);     out->Print(-        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? null : ""+        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? ""+        ""null$nullforgiving$ : ""","FYI - it is called from Grpc.AspNetCore via reflection:https://github.com/grpc/grpc-dotnet/blob/2b1da779bf45a0c55006bc3d36d1e54485c8e834/src/Grpc.AspNetCore.Server/Model/Internal/BinderServiceModelProvider.cs#L54C23-L54C23```C# bindMethodInfo.Invoke(null, new object?[] { binder, null });```So I think keeping my fix of adding null forgiving operator is correct.",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/33878,1297088350,2023-08-17T11:29:26Z,src/compiler/csharp_generator.cc,"@@ -735,14 +738,15 @@ void GenerateBindServiceWithBinderMethod(Printer* out,   for (int i = 0; i < service->method_count(); i++) {     const MethodDescriptor* method = service->method(i);     out->Print(-        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? null : ""+        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? ""+        ""null$nullforgiving$ : ""","I'm still confused... fundamentally, it sounds like the method really *should* have a nullable parameter, given that we're intentionally calling it with a null argument. So can we fix that? Or have I completely missed something?(I'm somewhat unnerved by generating calls to an experimental API within a non-experimental generator, admittedly...)",
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/33878,1297141159,2023-08-17T12:21:41Z,src/compiler/csharp_generator.cc,"@@ -735,14 +738,15 @@ void GenerateBindServiceWithBinderMethod(Printer* out,   for (int i = 0; i < service->method_count(); i++) {     const MethodDescriptor* method = service->method(i);     out->Print(-        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? null : ""+        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? ""+        ""null$nullforgiving$ : """,The `AddMethod` definitions are in `ServiceBinderBase.cs` in `Grpc.Core.Api`.Maybe we should add nullable annotations to `Grpc.Core.Api` - but then the generated code is dependent on a particular version of the Grpc.Core.Api package if you don't want to see warnings.,
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/34096,1297744431,2023-08-17T20:56:51Z,src/proto/grpc/testing/messages.proto,"@@ -309,3 +317,23 @@ message TestOrcaReport {   map<string, double> request_cost = 3;   map<string, double> utilization = 4; }++enum HookRequestCommand {",They are from that other PR. This file source of truth is https://github.com/grpc/grpc-proto/blob/master/grpc/testing/messages.proto that already has the messages.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34075,1298599637,2023-08-18T15:42:08Z,src/core/lib/channel/channel_args.cc,"@@ -313,6 +313,17 @@ std::string ChannelArgs::ToString() const {   return absl::StrCat(""{"", absl::StrJoin(arg_strings, "", ""), ""}""); } +std::vector<std::vector<std::string>> ChannelArgs::GetChannelArgsDebugInfo() const {","ok I think given all this, let's either:1. define a new struct `struct ChannelArgs::DebugEntry { string key; string value; }`2. or just add a `ForEachDebugEntry(F f)` to ChannelArgs that iterates through and calls f with the stringified key and value for each entry - and save the data type conversion until we need itIn either case we should convert `ToString` to use the new function.",X
3314323,felschr,https://api.github.com/repos/grpc/grpc/pulls/33535,1300188766,2023-08-21T14:25:10Z,src/compiler/csharp_generator_helpers.h,"@@ -26,9 +26,25 @@ namespace grpc_csharp_generator {  inline bool ServicesFilename(const grpc::protobuf::FileDescriptor* file,                              const std::string& file_suffix,-                             std::string& out_file_name_or_error) {-  out_file_name_or_error =-      grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+                             const std::string& base_namespace,+                             std::string& out_file, std::string* error) {+  // Support for base_namespace option is **experimental**.+  //+  // If base_namespace is provided then slightly different name mangling+  // is used to generate the service file name. This is because this+  // uses common code with protoc. For most file names this will not+  // make a difference (only files with punctuation or numbers in the+  // name.)+  // Otherwise the behavior remains the same as before.+  if (base_namespace.empty()) {+    out_file = grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+  } else {+    out_file = GRPC_CUSTOM_CSHARP_GETOUTPUTFILE(file, file_suffix, true,+                                                base_namespace, error);+    if (out_file.empty()) {+      return false;+    }+  }","I'm not entirely sure what happens here, but with `protoc`'s `base_namespace` option I can specify `base_namespace=` (yes, without a value after the `=`) and it'll generate the code into a folder structure instead of putting everything into the root directory.I expected the same behavior for grpc, but it still tries to put all files into the root directory, which in my case causes issues with duplicate file names.Since `GRPC_CUSTOM_CSHARP_GETOUTPUTFILE()` already handles the `base_namespace.empty()` case perhaps the check in grpc just needs to be removed?:https://github.com/protocolbuffers/protobuf/blob/1bfcedaf1280923f36e52a6fa0a5645ab63568f0/src/google/protobuf/compiler/csharp/names.cc#L137-L153",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34112,1300214710,2023-08-21T14:44:28Z,src/core/tsi/transport_security_interface.h,"@@ -258,6 +258,12 @@ typedef struct tsi_handshaker_result tsi_handshaker_result; tsi_result tsi_handshaker_result_extract_peer(const tsi_handshaker_result* self,                                               tsi_peer* peer); +// This method extracts tsi local peer. It returns TSI_OK assuming there is no fatal+// error.+// The caller is responsible for destructing the local peer.+tsi_result tsi_handshaker_result_extract_local_peer(const tsi_handshaker_result* self,","I think it may be overkill to add a new API to TSI - instead, can we just add the properties to the `tsi_peer` that we build during `tsi_handshaker_result_extract_peer`?There is precedent for having local connection info in the `tsi_peer` (e.g. see the ALTS TSI handshaker) and it has several advantages:1. Much less work in this PR and to import the code (there are many internal TSI implementations that would need updating).2. Easier to maintain, because we don't have 2 parallel but nearly identical flows.",X
3314323,felschr,https://api.github.com/repos/grpc/grpc/pulls/33535,1300233854,2023-08-21T14:59:21Z,src/compiler/csharp_generator_helpers.h,"@@ -26,9 +26,25 @@ namespace grpc_csharp_generator {  inline bool ServicesFilename(const grpc::protobuf::FileDescriptor* file,                              const std::string& file_suffix,-                             std::string& out_file_name_or_error) {-  out_file_name_or_error =-      grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+                             const std::string& base_namespace,+                             std::string& out_file, std::string* error) {+  // Support for base_namespace option is **experimental**.+  //+  // If base_namespace is provided then slightly different name mangling+  // is used to generate the service file name. This is because this+  // uses common code with protoc. For most file names this will not+  // make a difference (only files with punctuation or numbers in the+  // name.)+  // Otherwise the behavior remains the same as before.+  if (base_namespace.empty()) {+    out_file = grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;+  } else {+    out_file = GRPC_CUSTOM_CSHARP_GETOUTPUTFILE(file, file_suffix, true,+                                                base_namespace, error);+    if (out_file.empty()) {+      return false;+    }+  }","Just found the empty string behavior in protoc documented here:https://github.com/protocolbuffers/protobuf/blob/1bfcedaf1280923f36e52a6fa0a5645ab63568f0/src/google/protobuf/compiler/csharp/csharp_options.h#L63-L67So, essentially when `base_namespace` is explicitly set via the CLI the variable `base_namespace_specified` is set to `true` which in turn causes `GetOutputFile()` to be invoked with `generate_directories` set to `true`.To match the behavior, grpc should also check if `base_namespace` was explicitly set and use that in the conditional, e.g.:```suggestion  if (!base_namespace_specified) {    out_file = grpc_generator::FileNameInUpperCamel(file, false) + file_suffix;  } else {    out_file = GRPC_CUSTOM_CSHARP_GETOUTPUTFILE(file, file_suffix, true,                                                base_namespace, error);    if (out_file.empty()) {      return false;    }  }```No need to removing this check entirely to retain backwards compatibility. See https://github.com/grpc/grpc/pull/32636/files#r1148360058 for some notes on that.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/34097,1300669418,2023-08-21T21:32:20Z,tools/run_tests/xds_k8s_test_driver/tests/unit/helpers/skips_test.py,"@@ -0,0 +1,247 @@+# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+from typing import Optional++from absl.testing import absltest+from absl.testing import parameterized+from packaging import version as pkg_version++from framework.helpers import skips+++class TestConfigVersionGteTest(parameterized.TestCase):+    """"""+    Unit test for the version comparison helper TestConfig.version_gte.++    See TestConfig.version_gte for doc for the description of the special cases+    mentioned below.+    """"""++    INVALID_VERSIONS: tuple[str, ...] = (+        ""1.2.xx"",+        ""1.x.x"",+        ""alpha"",+        ""1.x.alpha"",+        ""1.2.x.alpha"",+        ""1.x.3"",+        ""x.1.3"",+        ""v1.x.3"",+        ""v.1.2.0"",+        ""y1.2.0"",+    )++    VALID_VERSIONS: tuple[str, ...] = (+        ""1.2.x"",+        ""1.2.0"",+        ""v1.2.x"",+        ""v1.2.0"",+        ""V1.2.0"",+        ""1.999.x"",+        ""2.999.x"",+    )++    VALID_DEV_VERSIONS: tuple[str, ...] = (+        ""dev-1.3.x"",+        ""dev-1.3.0"",+        ""dev-master"",+    )++    @classmethod+    def _make_test_config(cls, version: str) -> skips.TestConfig:+        return skips.TestConfig(+            client_lang=skips.Lang.UNKNOWN,+            server_lang=skips.Lang.UNKNOWN,+            version=version,+        )++    @classmethod+    def _v_prefix_combos(cls, left: str, right: str) -> tuple[str, str]:+        yield left, right+        yield f""v{left}"", right+        yield left, f""v{right}""+        yield f""v{left}"", f""v{right}""++    @parameterized.parameters(",Nice use of parameters ,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34122,1301150695,2023-08-22T07:29:57Z,test/cpp/naming/resolver_component_tests_runner_invoker.cc,"@@ -55,6 +55,16 @@ ABSL_FLAG(     ""False indicates that this test is running under run_tests.py. ""     ""Child process test binaries are located differently based on this flag. ""); +#ifdef GPR_WINDOWS+ABSL_FLAG(bool, running_locally, false,","More options here:- You could potentially use the ""GRPC_PORT_ISOLATED_RUNTIME=1"" define, which is only set when running on RBE (normally it's used to determine the port picker behavior, but with an explanatory comment you could potentially use it for detecting whether running on RBE or no).https://github.com/grpc/grpc/blob/c867c418c13652b8ece1986cff6717541f89f2c8/tools/remote_build/include/rbe_remote_execution.bazelrc#L31- alternatively, you could set an --action_env or --test_env variable and add it to rbe_remote_execution.bazelrc (since detection whether running on RBE or not is a reasonable thing to detect)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1302264524,2023-08-22T22:48:28Z,src/cpp/ext/otel/otel_client_filter.cc,"@@ -100,11 +102,31 @@ OpenTelemetryCallTracer::OpenTelemetryCallAttemptTracer::     : parent_(parent),       arena_allocated_(arena_allocated),       start_time_(absl::Now()) {-  // TODO(yashykt): Figure out how to get this to work with absl::string_view+  // We don't have the peer labels at this point.+  if (OTelPluginState().labels_injector != nullptr) {+    labels_ = OTelPluginState().labels_injector->GetLocalLabels();+  }+  labels_.emplace_back(OTelMethodKey(), parent_->method_);+  labels_.emplace_back(OTelTargetKey(), parent_->parent_->target());   if (OTelPluginState().client.attempt.started != nullptr) {-    OTelPluginState().client.attempt.started->Add(-        1, {{std::string(OTelMethodKey()), std::string(parent_->method_)},-            {std::string(OTelTargetKey()), parent_->parent_->target()}});+    OTelPluginState().client.attempt.started->Add(1, labels_);+  }+}++void OpenTelemetryCallTracer::OpenTelemetryCallAttemptTracer::+    RecordReceivedInitialMetadata(grpc_metadata_batch* recv_initial_metadata) {+  if (OTelPluginState().labels_injector != nullptr) {+    auto peer_labels =+        OTelPluginState().labels_injector->GetPeerLabels(recv_initial_metadata);","The comment on `GetPeerLabels()` in otel_plugin.h says that it includes the local labels returned by `GetLocalLabels()`.  However, here we are adding the returned labels to `labels_`, when we have already previously added the local labels to `labels_` in the ctor.  Won't that result in duplicate labels?",X
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/33878,1302790775,2023-08-23T10:04:43Z,src/compiler/csharp_generator.cc,"@@ -735,14 +738,15 @@ void GenerateBindServiceWithBinderMethod(Printer* out,   for (int i = 0; i < service->method_count(); i++) {     const MethodDescriptor* method = service->method(i);     out->Print(-        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? null : ""+        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? ""+        ""null$nullforgiving$ : ""","I think the safest thing (for now) is to add the annotations to the generated code, then update the code in `Grpc.Core.Api` and  `Grpc.AspNetCore.Server` later.- If we update `Grpc.Core.Api` and add annotations to `ServiceBinderBase.cs` to say the `handler` parameter may be null then we also need to add annotations to `ProviderServiceBinder.cs` in `Grpc.AspNetCore.Server` as the base class definition will have changed and warnings are treated as errors in that project- If we don't add the null forgiving operator annotations to the generated code then projects using new code generation but using older `Grpc.Core.Api` without the changes will have warnings.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34125,1303335180,2023-08-23T17:29:32Z,.github/workflows/psm-interop.yaml,"@@ -0,0 +1,74 @@+name: PSM Interop++on:+  pull_request:+  push:+    branches:+      - master+      - 'v1.*'++permissions:+  contents: read++jobs:+  unittest:+    # By default, only version is printed out in parens, e.g. ""unittest (3.10)""+    # This changes it to ""unittest (python3.10)""+    name: ""unittest (python${{ matrix.python_version }})""+    runs-on: ubuntu-latest+    strategy:+      matrix:+        python_version: [""3.9"", ""3.10""]+      fail-fast: false+    permissions:+      pull-requests: read  # Used by paths-filter to read the diff.+    defaults:+      run:+        working-directory: 'tools/run_tests/xds_k8s_test_driver'++    steps:+      - uses: actions/checkout@v3++      # To add this job to required GitHub checks, it's not enough to use+      # the on.pull_request.paths filter. For required checks, the job needs to+      # return the success status, and not be skipped.+      # Using paths-filter action, we skip the setup/test steps when psm interop+      # files are unchanged, and the job returns success.+      - uses: dorny/paths-filter@v2+        id: paths_filter+        with:+          filters:  |+            psm_interop_src:","Yes, good point. I didn't like it much too. For now, I think the benefits outweigh the risks. I _absolutely_ don't want to block anything in the repo because, f.e. newer pip breaks things.For the long-term, I have plans to move the framework out to its own repo, but we should discuss it separately.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1303349753,2023-08-23T17:43:54Z,src/cpp/ext/gsm/metadata_exchange.cc,"@@ -0,0 +1,243 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/cpp/ext/gsm/metadata_exchange.h""++#include <stddef.h>++#include <unordered_map>++#include ""absl/meta/type_traits.h""+#include ""absl/strings/escaping.h""+#include ""absl/strings/string_view.h""+#include ""absl/types/optional.h""+#include ""absl/types/variant.h""+#include ""google/protobuf/struct.upb.h""+#include ""opentelemetry/sdk/resource/semantic_conventions.h""+#include ""upb/base/string_view.h""+#include ""upb/mem/arena.h""+#include ""upb/upb.hpp""++#include ""src/core/lib/gprpp/env.h""++namespace grpc {+namespace internal {++namespace {++const char kMetadataExchangeTypeKey[] = ""type"";+const char kMetadataExchangePodNameKey[] = ""pod_name"";+const char kMetadataExchangeContainerNameKey[] = ""container_name"";+const char kMetadataExchangeNamespaceNameKey[] = ""namespace_name"";+const char kMetadataExchangeClusterNameKey[] = ""cluster_name"";+const char kMetadataExchangeLocationKey[] = ""location"";+const char kMetadataExchangeProjectIdKey[] = ""project_id"";+const char kMetadataExchangeCanonicalServiceNameKey[] =+    ""canonical_service_name"";+const char kPeerTypeAttribute[] = ""peer_type"";+const char kPeerPodNameAttribute[] = ""peer_pod_name"";+const char kPeerContainerNameAttribute[] = ""peer_container_name"";+const char kPeerNamespaceNameAttribute[] = ""peer_namespace_name"";+const char kPeerClusterNameAttribute[] = ""peer_cluster_name"";+const char kPeerLocationAttribute[] = ""peer_location"";+const char kPeerProjectIdAttribute[] = ""peer_project_id"";+const char kPeerCanonicalServiceNameAttribute[] = ""peer_canonical_service_name"";++upb_StringView AbslStrToUpbStr(absl::string_view str) {+  return upb_StringView_FromDataAndSize(str.data(), str.size());+}++std::string UpbStrToStdStr(upb_StringView str) {+  return std::string(str.data, str.size);+}++void AddStringKeyValueToStructProto(google_protobuf_Struct* struct_pb,+                                    absl::string_view key,+                                    absl::string_view value, upb_Arena* arena) {+  google_protobuf_Value* value_pb = google_protobuf_Value_new(arena);+  google_protobuf_Value_set_string_value(value_pb, AbslStrToUpbStr(value));+  google_protobuf_Struct_fields_set(struct_pb, AbslStrToUpbStr(key), value_pb,+                                    arena);+}++std::string GetStringValueFromAttributeMap(+    const opentelemetry::sdk::common::AttributeMap& map,+    absl::string_view key) {+  const auto& attributes = map.GetAttributes();+  const auto it = attributes.find(std::string(key));+  if (it == attributes.end()) {+    return ""unknown"";+  }+  const auto* string_value = absl::get_if<std::string>(&it->second);+  if (string_value == nullptr) {+    return ""unknown"";+  }+  return *string_value;+}++}  // namespace++ServiceMeshLabelsInjector::ServiceMeshLabelsInjector(+    const opentelemetry::sdk::common::AttributeMap& map) {+  upb::Arena arena;+  auto* metadata = google_protobuf_Struct_new(arena.ptr());+  // Assume kubernetes for now+  std::string type_value = GetStringValueFromAttributeMap(+      map, opentelemetry::sdk::resource::SemanticConventions::kCloudPlatform);+  std::string pod_name_value = GetStringValueFromAttributeMap(+      map, opentelemetry::sdk::resource::SemanticConventions::kK8sPodName);+  std::string container_name_value = GetStringValueFromAttributeMap(+      map,+      opentelemetry::sdk::resource::SemanticConventions::kK8sContainerName);+  std::string namespace_value = GetStringValueFromAttributeMap(+      map,+      opentelemetry::sdk::resource::SemanticConventions::kK8sNamespaceName);+  std::string cluster_name_value = GetStringValueFromAttributeMap(+      map, opentelemetry::sdk::resource::SemanticConventions::kK8sClusterName);+  std::string cluster_location_value = GetStringValueFromAttributeMap(+      map, opentelemetry::sdk::resource::SemanticConventions::+               kCloudRegion);  // if regional+  if (cluster_location_value == ""unknown"") {+    cluster_location_value = GetStringValueFromAttributeMap(+        map, opentelemetry::sdk::resource::SemanticConventions::+                 kCloudAvailabilityZone);  // if zonal+  }+  std::string project_id_value = GetStringValueFromAttributeMap(+      map, opentelemetry::sdk::resource::SemanticConventions::kCloudAccountId);+  std::string canonical_service_value =+      grpc_core::GetEnv(""CANONICAL_SERVICE_NAME"").value_or(""unknown"");+  // Create metadata to be sent over wire.+  AddStringKeyValueToStructProto(metadata, kMetadataExchangeTypeKey, type_value,+                                 arena.ptr());+  AddStringKeyValueToStructProto(metadata, kMetadataExchangePodNameKey,+                                 pod_name_value, arena.ptr());+  AddStringKeyValueToStructProto(metadata, kMetadataExchangeContainerNameKey,+                                 container_name_value, arena.ptr());+  AddStringKeyValueToStructProto(metadata, kMetadataExchangeNamespaceNameKey,+                                 namespace_value, arena.ptr());+  AddStringKeyValueToStructProto(metadata, kMetadataExchangeClusterNameKey,+                                 cluster_name_value, arena.ptr());+  AddStringKeyValueToStructProto(metadata, kMetadataExchangeLocationKey,+                                 cluster_location_value, arena.ptr());+  AddStringKeyValueToStructProto(metadata, kMetadataExchangeProjectIdKey,+                                 project_id_value, arena.ptr());+  AddStringKeyValueToStructProto(metadata,+                                 kMetadataExchangeCanonicalServiceNameKey,+                                 canonical_service_value, arena.ptr());+  size_t output_length;+  char* output =+      google_protobuf_Struct_serialize(metadata, arena.ptr(), &output_length);+  serialized_labels_to_send_ = grpc_core::Slice::FromCopiedString(+      absl::Base64Escape(absl::string_view(output, output_length)));+  // Fill up local labels map. The rest we get from the detected Resource and+  // from the peer.+  local_labels_.emplace_back(""canonical_service_name"", canonical_service_value);+}++std::string GetStringValueFromUpbStruct(google_protobuf_Struct* struct_pb,+                                        absl::string_view key,+                                        upb_Arena* arena) {+  if (struct_pb == nullptr) {+    return ""unknown"";+  }+  google_protobuf_Value* value_pb = google_protobuf_Value_new(arena);+  bool present = google_protobuf_Struct_fields_get(+      struct_pb, AbslStrToUpbStr(key), &value_pb);+  if (present) {+    if (google_protobuf_Value_has_string_value(value_pb)) {+      return UpbStrToStdStr(google_protobuf_Value_string_value(value_pb));+    }+  }+  return ""unknown"";+}++std::vector<std::pair<std::string, std::string>>+ServiceMeshLabelsInjector::GetPeerLabels(+    grpc_metadata_batch* incoming_initial_metadata) {+  auto peer_metadata =+      incoming_initial_metadata->Take(grpc_core::XEnvoyPeerMetadata());+  std::vector<std::pair<std::string, std::string>> labels;+  bool metadata_found = false;","Suggest writing this as:```upb::Arena arena;google_protobuf_Struct* struct_pb = nullptr;if (peer_metadata.has_value()) {  std::string decoded_metadata;  bool metadata_decoded = absl::Base64Unescape(      peer_metadata.value().as_string_view(), &decoded_metadata);  if (metadata_decoded) {    struct_pb = google_protobuf_Struct_parse(        decoded_metadata.c_str(), decoded_metadata.size(), arena.ptr());  }}labels.emplace_back(kPeerTypeAttribute,                    GetStringValueFromUpbStruct(                        struct_pb, kMetadataExchangeTypeKey, arena.ptr()));// ...same for other labels...```This way, we don't need the ""else"" block on lines 218-226, since `GetStringValueFromUpbStruct()` will return ""unknown"" if `struct_pb` is null.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1303355004,2023-08-23T17:49:07Z,src/cpp/ext/otel/otel_server_call_tracer.cc,"@@ -160,28 +169,25 @@ void OpenTelemetryServerCallTracer::RecordSendTrailingMetadata(  void OpenTelemetryServerCallTracer::RecordEnd(     const grpc_call_final_info* final_info) {-  absl::InlinedVector<std::pair<std::string, std::string>, 2> attributes = {-      {std::string(OTelMethodKey()), std::string(method_)},-      {std::string(OTelStatusKey()),-       absl::StatusCodeToString(-           static_cast<absl::StatusCode>(final_info->final_status))},-      {std::string(OTelAuthorityKey()), authority_}};+  labels_.emplace_back(OTelStatusKey(),+                       absl::StatusCodeToString(static_cast<absl::StatusCode>(+                           final_info->final_status)));   if (OTelPluginState().server.call.duration != nullptr) {     OTelPluginState().server.call.duration->Record(-        absl::ToDoubleSeconds(elapsed_time_), attributes,+        absl::ToDoubleSeconds(elapsed_time_), labels_,",What is the type of the labels parameter passed to `Record()`?  Does this have to use `std::string`?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1303376955,2023-08-23T18:10:51Z,test/cpp/ext/gsm/metadata_exchange_test.cc,"@@ -0,0 +1,187 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/cpp/ext/gsm/metadata_exchange.h""++#include ""absl/functional/any_invocable.h""+#include ""api/include/opentelemetry/metrics/provider.h""+#include ""gmock/gmock.h""+#include ""google/cloud/opentelemetry/resource_detector.h""+#include ""gtest/gtest.h""+#include ""opentelemetry/sdk/metrics/meter_provider.h""+#include ""opentelemetry/sdk/metrics/metric_reader.h""++#include <grpcpp/grpcpp.h>++#include ""src/core/lib/channel/call_tracer.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/core/lib/gprpp/env.h""+#include ""src/cpp/ext/gsm/gsm_observability.h""+#include ""src/cpp/ext/otel/otel_plugin.h""+#include ""test/core/util/test_config.h""+#include ""test/cpp/end2end/test_service_impl.h""+#include ""test/cpp/ext/otel/otel_test_library.h""++namespace grpc {+namespace testing {+namespace {++class MetadataExchangeTest : public OTelPluginEnd2EndTest {+ protected:+  void SetUp(const absl::flat_hash_set<absl::string_view>& metric_names,","Why is this needed?  Seems like it's just forwarding to the parent class, but if we didn't define this method in the first place, we'd just wind up directly calling the method from the parent class anyway.",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/34122,1303471117,2023-08-23T19:46:53Z,test/cpp/naming/resolver_component_tests_runner_invoker.cc,"@@ -55,6 +55,16 @@ ABSL_FLAG(     ""False indicates that this test is running under run_tests.py. ""     ""Child process test binaries are located differently based on this flag. ""); +#ifdef GPR_WINDOWS+ABSL_FLAG(bool, running_locally, false,+          ""This flag only exists on Windows and is only effective when running ""+          ""under Bazel. ""+          ""Set this to true (e.g. --test_arg=--running_locally=true) when ""+          ""running the test locally. ""+          ""This is because the RUNFILES dir behavior is different between ""","good question. I found there is a `--enable_runfiles` option and is default off on Windows so Bazel will just create a MANIFEST file under the RUNFILES dir instead of creating the symlinks tree. When enabled, Bazel errored with:```C:\users\yijiem\_bazel_yijiem\install\1a52a8611778e900b15612375871f5a1\build-runfiles.exe --allow_relative bazel-out/x64_windows-fastbuild/bin/test/cpp/naming/utils/tcp_connect.exe.runfiles_manifest bazel-out/x64_windows-fastbuild/bin/test/cpp/naming/utils/tcp_connect.exe.runfiles: Process exited with status 1: Process exited with status 1build-runfiles error: CreateSymbolicLinkW failed:Bazel needs to create symlinks to build the runfiles tree.Creating symlinks on Windows requires one of the following:    1. Bazel is run with administrator privileges.    2. The system version is Windows 10 Creators Update (1703) or later and developer mode is enabled.```After qualifying for these 2 conditions, Bazel runs the test just fine. I think most of the change in this file can be reverted and I have added logging to hint about this flag if Bazel is invoked locally (using the `GRPC_PORT_ISOLATED_RUNTIME` preprocessor symbol check).",
6579971,paulosjca,https://api.github.com/repos/grpc/grpc/pulls/34117,1303504770,2023-08-23T20:23:54Z,test/cpp/qps/scenario_runner.py,"@@ -0,0 +1,138 @@+#!/usr/bin/env python3++# Copyright 2023 gRPC authors.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+""""""+Local QPS benchmark runner for the OSS Benchmark loadtest configurations.++This tool will run a scenario locally, either already extracted from+scenario_config_extractor, or extracted from a benchmark loadtest config. The+driver, client, and server all in the same process. You can run the process+under a custom runner using the --runner_cmd=""<COMMAND>"" flag, and with custom+environment variables if needed.++This example will run an optimized build of the loadtest under gdb++GRPC_VERBOSITY=debug \+    bazel run \+    --config=opt \+    --cxxopt=""-gmlt"" \+    test/cpp/qps:scenario_runner -- \+    --loadtest_file=/path/to/loadtest.config \+    --runner_cmd=""gdb --args""++This builds the binary and runs:++    gdb --args bazel-bin/.../scenario_runner -- \+        --loadtest_config=/tmp/path/extracted_scenario_json.config++        +If you have already extracted the JSON scenario using scenario_config_exporter,+you can replace `--loadtest_file=loadtest.yaml` with+`--scenario_file=scenario.json`.+++Other --runner_cmd examples:+    --runner_cmd=""perf record -F 777 -o $(pwd)/perf.data -g --event=cpu-cycles"",+    --runner_cmd=""perf stat record -o $(pwd)/perf.stat.data"",+""+""""""+++import os+import subprocess+import sys+import tempfile++from absl import app+from absl import flags+import yaml++_LOADTEST_YAML = flags.DEFINE_string(+    ""loadtest_file"", default=None, help=""Path to the benchmark loadtest file""+)+_SCENARIO_JSON = flags.DEFINE_string(+    ""scenario_file"", default=None, help=""Path to a scenario JSON file""+)+_RUNNER_CMD = flags.DEFINE_string(+    ""runner_cmd"",+    default="""",+    help=""Run the scearnio runner under a custom command (example: bazel ... --cmd='perf lock record -o $(pwd)/out')"",+)+_RUN_FIRST = flags.DEFINE_bool(+    ""run_first"",+    default=False,+    help=""Only run the first scenario in the loadtest"",+)+_RUN_ALL = flags.DEFINE_bool(+    ""run_all"", default=False, help=""Run all scenarios in the loadtest""+)+++def run_command(filename):+    cmd = [+        os.path.join(+            os.path.dirname(os.path.abspath(__file__)),+            ""scenario_runner_cc"",+        ),+        ""--loadtest_config"",+        filename,+    ]+    if _RUNNER_CMD.value:+        cmd = _RUNNER_CMD.value.split("" "") + cmd+    print(cmd)+    subprocess.run(cmd, check=True)+    if _RUN_FIRST.value:+        print(""Exiting due to --run_first"")+        sys.exit(0)+++def run_loadtests():+    loadtests = []+    with open(+        os.path.join(+            os.path.dirname(os.path.abspath(__file__)), _LOADTEST_YAML.value+        )+    ) as f:+        loadtests = list(yaml.safe_load_all(f))+    if len(loadtests) > 1 and not (_RUN_FIRST.value or _RUN_ALL.value):+        print(+            ""The loadtest configuration contains more than one scenario. Please specify --run_first or --run_all."",","Nit: The language being used here seems unclear. Each loadtest contains only one scenario. The ""loadtest configuration file"" may be a multipart yaml file containing multiple loadtests. So I would say ""contains more than one loadtest"".It is also possible for a loadtest configuration file to contain multiple loadtests with the same scenario. This is the case for instance if they are generated with the `--runs_per_test` flag set.https://github.com/grpc/grpc/blob/master/tools/run_tests/performance/README.md#generating-load-test-configurations",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1303572468,2023-08-23T21:42:54Z,src/cpp/ext/otel/otel_client_filter.cc,"@@ -100,11 +102,31 @@ OpenTelemetryCallTracer::OpenTelemetryCallAttemptTracer::     : parent_(parent),       arena_allocated_(arena_allocated),       start_time_(absl::Now()) {-  // TODO(yashykt): Figure out how to get this to work with absl::string_view+  // We don't have the peer labels at this point.+  if (OTelPluginState().labels_injector != nullptr) {+    labels_ = OTelPluginState().labels_injector->GetLocalLabels();+  }+  labels_.emplace_back(OTelMethodKey(), parent_->method_);+  labels_.emplace_back(OTelTargetKey(), parent_->parent_->target());   if (OTelPluginState().client.attempt.started != nullptr) {-    OTelPluginState().client.attempt.started->Add(-        1, {{std::string(OTelMethodKey()), std::string(parent_->method_)},-            {std::string(OTelTargetKey()), parent_->parent_->target()}});+    OTelPluginState().client.attempt.started->Add(1, labels_);+  }+}++void OpenTelemetryCallTracer::OpenTelemetryCallAttemptTracer::+    RecordReceivedInitialMetadata(grpc_metadata_batch* recv_initial_metadata) {+  if (OTelPluginState().labels_injector != nullptr) {+    auto peer_labels =+        OTelPluginState().labels_injector->GetPeerLabels(recv_initial_metadata);","Sorry, yeah. Removed the `(Includes the local labels.)` comment. I was trying out different things, and the current structure looked nicer to me where we first add in the local labels when we first create the call, and then add in peer labels when get initial metadata. So, no duplication.",X
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1303574832,2023-08-23T21:46:05Z,src/cpp/ext/otel/otel_client_filter.cc,"@@ -100,11 +102,31 @@ OpenTelemetryCallTracer::OpenTelemetryCallAttemptTracer::     : parent_(parent),       arena_allocated_(arena_allocated),       start_time_(absl::Now()) {-  // TODO(yashykt): Figure out how to get this to work with absl::string_view+  // We don't have the peer labels at this point.+  if (OTelPluginState().labels_injector != nullptr) {+    labels_ = OTelPluginState().labels_injector->GetLocalLabels();+  }+  labels_.emplace_back(OTelMethodKey(), parent_->method_);+  labels_.emplace_back(OTelTargetKey(), parent_->parent_->target());   if (OTelPluginState().client.attempt.started != nullptr) {-    OTelPluginState().client.attempt.started->Add(-        1, {{std::string(OTelMethodKey()), std::string(parent_->method_)},-            {std::string(OTelTargetKey()), parent_->parent_->target()}});+    OTelPluginState().client.attempt.started->Add(1, labels_);+  }+}++void OpenTelemetryCallTracer::OpenTelemetryCallAttemptTracer::+    RecordReceivedInitialMetadata(grpc_metadata_batch* recv_initial_metadata) {+  if (OTelPluginState().labels_injector != nullptr) {+    auto peer_labels =+        OTelPluginState().labels_injector->GetPeerLabels(recv_initial_metadata);+    labels_.insert(labels_.end(), std::make_move_iterator(peer_labels.begin()),",I do the translation in `metadata_exchange.cc`. This allows some flexibility if we can't have the keys used in metadata exchange to exactly map to the keys that we want in the gsm metrics.,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1303620557,2023-08-23T22:54:25Z,src/cpp/ext/otel/otel_server_call_tracer.cc,"@@ -160,28 +169,25 @@ void OpenTelemetryServerCallTracer::RecordSendTrailingMetadata(  void OpenTelemetryServerCallTracer::RecordEnd(     const grpc_call_final_info* final_info) {-  absl::InlinedVector<std::pair<std::string, std::string>, 2> attributes = {-      {std::string(OTelMethodKey()), std::string(method_)},-      {std::string(OTelStatusKey()),-       absl::StatusCodeToString(-           static_cast<absl::StatusCode>(final_info->final_status))},-      {std::string(OTelAuthorityKey()), authority_}};+  labels_.emplace_back(OTelStatusKey(),+                       absl::StatusCodeToString(static_cast<absl::StatusCode>(+                           final_info->final_status)));   if (OTelPluginState().server.call.duration != nullptr) {     OTelPluginState().server.call.duration->Record(-        absl::ToDoubleSeconds(elapsed_time_), attributes,+        absl::ToDoubleSeconds(elapsed_time_), labels_,","https://github.com/open-telemetry/opentelemetry-cpp/blob/c0f17d99b0f47c65c80bcd873179bc46a01b494d/sdk/include/opentelemetry/sdk/common/attribute_utils.h#L30Yeah, I was trying to see if it made sense to modify the OTel C++ implementation to add in absl::string_view support",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1303622628,2023-08-23T22:58:29Z,test/cpp/ext/otel/otel_test_library.h,"@@ -0,0 +1,94 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_TEST_CPP_EXT_OTEL_OTEL_TEST_LIBRARY_H+#define GRPC_TEST_CPP_EXT_OTEL_OTEL_TEST_LIBRARY_H++#include ""absl/functional/any_invocable.h""+#include ""api/include/opentelemetry/metrics/provider.h""+#include ""gmock/gmock.h""+#include ""gtest/gtest.h""+#include ""opentelemetry/sdk/metrics/meter_provider.h""+#include ""opentelemetry/sdk/metrics/metric_reader.h""++#include <grpcpp/grpcpp.h>++#include ""src/core/lib/channel/call_tracer.h""+#include ""src/core/lib/config/core_configuration.h""+#include ""src/cpp/ext/otel/otel_plugin.h""+#include ""test/core/util/test_config.h""+#include ""test/cpp/end2end/test_service_impl.h""++namespace grpc {+namespace testing {++class MockMetricReader : public opentelemetry::sdk::metrics::MetricReader {+ public:+  opentelemetry::sdk::metrics::AggregationTemporality GetAggregationTemporality(+      opentelemetry::sdk::metrics::InstrumentType) const noexcept override {+    return opentelemetry::sdk::metrics::AggregationTemporality::kDelta;+  }++  bool OnForceFlush(std::chrono::microseconds) noexcept override {+    return true;+  }++  bool OnShutDown(std::chrono::microseconds) noexcept override { return true; }++  void OnInitialized() noexcept override {}+};++class OTelPluginEnd2EndTest : public ::testing::Test {+ protected:+  using ::testing::Test::SetUp;+  void SetUp(",I can rename it. This is just one of the patterns I saw being used in the wild and adopted it :D,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1304493616,2023-08-24T15:17:22Z,src/cpp/ext/otel/otel_server_call_tracer.cc,"@@ -160,28 +169,25 @@ void OpenTelemetryServerCallTracer::RecordSendTrailingMetadata(  void OpenTelemetryServerCallTracer::RecordEnd(     const grpc_call_final_info* final_info) {-  absl::InlinedVector<std::pair<std::string, std::string>, 2> attributes = {-      {std::string(OTelMethodKey()), std::string(method_)},-      {std::string(OTelStatusKey()),-       absl::StatusCodeToString(-           static_cast<absl::StatusCode>(final_info->final_status))},-      {std::string(OTelAuthorityKey()), authority_}};+  labels_.emplace_back(OTelStatusKey(),+                       absl::StatusCodeToString(static_cast<absl::StatusCode>(+                           final_info->final_status)));   if (OTelPluginState().server.call.duration != nullptr) {     OTelPluginState().server.call.duration->Record(-        absl::ToDoubleSeconds(elapsed_time_), attributes,+        absl::ToDoubleSeconds(elapsed_time_), labels_,","Seems like it's at least worth asking them about what the options are here to avoid allocations.The ideal thing would probably be to use slices here, so that we can just pass them refs to the slices we already have.  That doesn't really work, since slice is an internal gRPC type that they can't depend on.  But maybe they could provide some sort of ref-counted string interface, and we could provide an implementation of that interface that is backed by slices.Alternatively, if we can guarantee that our copy of the strings live long enough for OT to use them (not sure if that's true, would be good to understand), then passing in string_views would work.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1304629286,2023-08-24T17:04:59Z,src/cpp/ext/otel/otel_server_call_tracer.cc,"@@ -160,28 +169,25 @@ void OpenTelemetryServerCallTracer::RecordSendTrailingMetadata(  void OpenTelemetryServerCallTracer::RecordEnd(     const grpc_call_final_info* final_info) {-  absl::InlinedVector<std::pair<std::string, std::string>, 2> attributes = {-      {std::string(OTelMethodKey()), std::string(method_)},-      {std::string(OTelStatusKey()),-       absl::StatusCodeToString(-           static_cast<absl::StatusCode>(final_info->final_status))},-      {std::string(OTelAuthorityKey()), authority_}};+  labels_.emplace_back(OTelStatusKey(),+                       absl::StatusCodeToString(static_cast<absl::StatusCode>(+                           final_info->final_status)));   if (OTelPluginState().server.call.duration != nullptr) {     OTelPluginState().server.call.duration->Record(-        absl::ToDoubleSeconds(elapsed_time_), attributes,+        absl::ToDoubleSeconds(elapsed_time_), labels_,","Yes, you are right. This is probably an issue that's going to be faced by more people, not just us. I'll start a discussion around this. > Alternatively, if we can guarantee that our copy of the strings live long enough for OT to use them (not sure if that's true, would be good to understand), then passing in string_views would work.We could probably guarantee this for the strings that last forever, like our MonitoredResource labels. I think this should be acceptable. Let's see whether it's accepted.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1304629395,2023-08-24T17:05:05Z,src/cpp/ext/otel/otel_plugin.h,"@@ -25,16 +25,37 @@  #include <memory> #include <string>+#include <utility>+#include <vector>  #include ""absl/container/flat_hash_set.h"" #include ""absl/strings/string_view.h"" #include ""opentelemetry/metrics/meter_provider.h"" #include ""opentelemetry/metrics/sync_instruments.h"" #include ""opentelemetry/nostd/shared_ptr.h"" +#include ""src/core/lib/transport/metadata_batch.h""+ namespace grpc { namespace internal { +class LabelsInjector {+ public:+  virtual ~LabelsInjector() {}+  // Read the incoming initial metadata to get the set of labels to be added to+  // metrics. (Includes the local labels.)+  virtual std::vector<std::pair<std::string, std::string>> GetPeerLabels(","> Do we expect more than one value for the same label key? If not, why use a vector of pairs instead of a map?Since the allocation of memory for a vector is contiguous, the iteration over a vector is faster than a map.> The local labels (both keys and values) should be fixed for the entire process, so those should be able to be allocated only once, not once per RPC. Can we expose them as absl::string_view instead of std::string?There are two kinds of local labels, 1) those that we need to send over to the peer and 2) those that we need to record along with our metrics (since they are not present in MonitoredResource)For 1, yes, these are saved as a `grpc_core::Slice` and that's how we add them to the out going initial metadataFor 2, since OTel C++ accepts std::string and not absl::string_view, doing this, won't help us.> The peer label keys and values could probably be exposed as Slice, which would take a ref instead of making a copy.The same issue, right now, we don't have a way of passing a non std::string string type to OTel C++. > Maybe instead of using either a vector or a map, we can return an iterable interface?I think we can pass an iterable interface to OTel C++, but we would first need the ability to pass in string_view.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1304698968,2023-08-24T18:12:55Z,src/cpp/ext/otel/otel_plugin.h,"@@ -25,16 +25,37 @@  #include <memory> #include <string>+#include <utility>+#include <vector>  #include ""absl/container/flat_hash_set.h"" #include ""absl/strings/string_view.h"" #include ""opentelemetry/metrics/meter_provider.h"" #include ""opentelemetry/metrics/sync_instruments.h"" #include ""opentelemetry/nostd/shared_ptr.h"" +#include ""src/core/lib/transport/metadata_batch.h""+ namespace grpc { namespace internal { +class LabelsInjector {+ public:+  virtual ~LabelsInjector() {}+  // Read the incoming initial metadata to get the set of labels to be added to+  // metrics. (Includes the local labels.)+  virtual std::vector<std::pair<std::string, std::string>> GetPeerLabels(","> Since the allocation of memory for a vector is contiguous, the iteration over a vector is faster than a map.I'm not sure how much that really matters, since the strings themselves may not be stored inline, so we could be reading from different locations in memory anyway.  I guess that if a `std::string` happens to be inlined, it might help, but certainly if we switch to `absl::string_view`, this would still be an issue.> since OTel C++ accepts std::string and not absl::string_view, doing this, won't help us.I argue that even if OT currently does not support this, it's better for us to have the right interface between two components in our own code, so that if OT fixes this later, we have less work to do.  In other words, even if we still need to construct a `std::string` here, I think it's better to do it in the `CallTracer` than to bake this assumption into the `LabelsInjector` API.> I think we can pass an iterable interface to OTel C++, but we would first need the ability to pass in string_view.Unless I'm missing something here (and please tell me if I am), I think that's actually an orthogonal issue.  Even if OT requires `std::string`, we can still construct the `std::string` as we return each element of the iterable interface.  Doing that would still avoid the allocation for the vector itself.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34151,1304852698,2023-08-24T20:51:10Z,tools/run_tests/xds_k8s_test_driver/kubernetes-manifests/gamma/tdmesh.yaml,"@@ -0,0 +1,17 @@+---+kind: TDMesh+apiVersion: net.gke.io/v1alpha1+metadata:+  name: ${mesh_name}+  namespace: ${namespace_name}+  labels:+    owner: xds-k8s-interop-test+spec:+  gatewayClassName: gke-td+  allowedRoutes:+    namespaces:+      from: All+    kinds:+    - group: net.gke.io+      kind: TDGRPCRoute",Confirmed this doesn't work at the moment:```framework.helpers.retryers.RetryError: Retry error calling framework.infrastructure.k8s.KubernetesNamespace.get_service: timeout 0:01:00 (h:mm:ss) exceeded. Check result callback returned False.Reason: A k8s service wasn't assigned a NEG (Network Endpoint Group).################################################################################# IMPORTANT: This is not a root cause. This is an indication that# _something_ -- literally _anything_ -- has gone wrong in the xDS flow.# It is _your_ responsibility to look through the interop client and/or# server logs to determine what exactly went wrong.################################################################################# Please inspect the information below:Timeout 0:01:00 (h:mm:ss) waiting for service psm-grpc-server to report NEG status. Last service status:psm-grpc-server:---conditions: nullload_balancer:  ingress: null...```,
39203661,zasweq,https://api.github.com/repos/grpc/grpc/pulls/32810,1304953101,2023-08-24T23:04:15Z,test/cpp/interop/xds_interop_server.cc,"@@ -65,13 +66,59 @@ using grpc::testing::SimpleResponse; using grpc::testing::TestService; using grpc::testing::XdsUpdateHealthService; +namespace {+constexpr absl::string_view kRpcBehaviorMetadataKey = ""rpc-behavior"";+constexpr absl::string_view kErrorCodeRpcBehavior = ""error-code-"";++std::set<std::string> GetRpcBehaviorMetadata(ServerContext* context) {+  std::set<std::string> rpc_behaviors;","I don't think using a set here is correct. According to the gRFC: ""The `rpc-behavior` header value can have multiple options separated by commas. In that case, the value should be split by commas and the *options should be applied in the order specified*"". Specifically, I think using a set here loses the ordering of the list separated by commas.",
39203661,zasweq,https://api.github.com/repos/grpc/grpc/pulls/32810,1304953559,2023-08-24T23:05:24Z,test/cpp/interop/xds_interop_server.cc,"@@ -65,13 +66,59 @@ using grpc::testing::SimpleResponse; using grpc::testing::TestService; using grpc::testing::XdsUpdateHealthService; +namespace {+constexpr absl::string_view kRpcBehaviorMetadataKey = ""rpc-behavior"";+constexpr absl::string_view kErrorCodeRpcBehavior = ""error-code-"";++std::set<std::string> GetRpcBehaviorMetadata(ServerContext* context) {+  std::set<std::string> rpc_behaviors;",https://github.com/grpc/grpc-java/blob/42b4c61d5e869b1534808204bc71df84720f5087/interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java#L403 see here for deterministic list to build out.,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/33965,1306003806,2023-08-25T18:19:55Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc,"@@ -753,131 +743,68 @@ class SockToPolledFdMap {                            StatusToString(error).c_str());       return INVALID_SOCKET;     }-    GrpcPolledFdWindows* polled_fd =-        new GrpcPolledFdWindows(s, map->mu_, af, type);+    auto on_shutdown_locked = [self, s]() {+      // grpc_winsocket_shutdown calls closesocket which invalidates our+      // socket -> polled_fd mapping because the socket handle can be henceforth+      // reused.+      self->sockets_.erase(s);","If we are erasing the polled fd from the map, then it's because `ShutdownLocked` was called on the polled fd. This means that the c-ares wrapper actually owns the polled fd - it deletes it [here](https://github.com/grpc/grpc/blob/aaf6c3475cd0de21b96839ccbfb703cf9c798697/src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.cc#L223).Note that the polled fd factory only deletes those polled fds not still remaining in the map at the end of the resolution - i.e. polled fds created by the c-ares library and not ever seen by the c-ares grpc wrapper.",X
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/33965,1306144086,2023-08-25T20:54:25Z,src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_ev_driver_windows.cc,"@@ -753,131 +743,68 @@ class SockToPolledFdMap {                            StatusToString(error).c_str());       return INVALID_SOCKET;     }-    GrpcPolledFdWindows* polled_fd =-        new GrpcPolledFdWindows(s, map->mu_, af, type);+    auto on_shutdown_locked = [self, s]() {+      // grpc_winsocket_shutdown calls closesocket which invalidates our+      // socket -> polled_fd mapping because the socket handle can be henceforth+      // reused.+      self->sockets_.erase(s);","> Is it because some operations on the socket encountered some errors so that c-ares decided to close it without returning it back to the c-ares wrapper through ares_getsock()?Yes, this is the practical case I'm thinking of.> In that case, why don't we just actually close that socket in CloseSocket and destroy the GrpcPolledFdWindows but wait till the end when the factory is destroyed?We could do this, but I don't see the benefit, and it would add extra complexity because we would need to track additional state per polled fd: something like `bool owned_by_c_ares_lib_` which would start out `true` and be set `false` in `NewGrpcPolledFdLocked`.`CloseSocket` would then need to check `owned_by_c_ares_lib_`, and if true we'd need to:1) shut down the endpoint2) remove the entry from the `sockets_` map3) delete the endpointIMO, that would be more complex than the current model of this PR, where we just shutdown/destroy everything left in `sockets_` at the end.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1308011068,2023-08-28T22:15:05Z,src/cpp/ext/otel/otel_plugin.h,"@@ -25,16 +25,37 @@  #include <memory> #include <string>+#include <utility>+#include <vector>  #include ""absl/container/flat_hash_set.h"" #include ""absl/strings/string_view.h"" #include ""opentelemetry/metrics/meter_provider.h"" #include ""opentelemetry/metrics/sync_instruments.h"" #include ""opentelemetry/nostd/shared_ptr.h"" +#include ""src/core/lib/transport/metadata_batch.h""+ namespace grpc { namespace internal { +class LabelsInjector {+ public:+  virtual ~LabelsInjector() {}+  // Read the incoming initial metadata to get the set of labels to be added to+  // metrics. (Includes the local labels.)+  virtual std::vector<std::pair<std::string, std::string>> GetPeerLabels(","> I'm not sure how much that really matters, since the strings themselves may not be stored inline, so we could be reading from different locations in memory anyway. I guess that if a std::string happens to be inlined, it might help, but certainly if we switch to absl::string_view, this would still be an issue.The difference may not be much, but I don't see a reason to use a map given that a simple vector satisfies our purpose.> I argue that even if OT currently does not support this, it's better for us to have the right interface between two components in our own code, so that if OT fixes this later, we have less work to do. In other words, even if we still need to construct a std::string here, I think it's better to do it in the CallTracer than to bake this assumption into the LabelsInjector API.I was wrong. The OTel API actually does take in an `absl::string_view`. It's just that the SDK later converts it to a std::string. Irrespective, you are right, I shouldn't unnecessarily create a string when an `absl::string_view` does the job. I wonder why this wasn't working for me earlier.. maybe it's because they use their own bespoke `opentelemetry::nostd::string_view` instead of `absl::string_view`> Unless I'm missing something here (and please tell me if I am), I think that's actually an orthogonal issue. Even if OT requires std::string, we can still construct the std::string as we return each element of the iterable interface. Doing that would still avoid the allocation for the vector itself.Created an iterator. In the new logic, I use a std::string to store the labels that are read from the peer while we use absl::string_view for our local labels",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1308078320,2023-08-29T00:31:40Z,src/cpp/ext/otel/otel_plugin.h,"@@ -25,16 +25,37 @@  #include <memory> #include <string>+#include <utility>+#include <vector>  #include ""absl/container/flat_hash_set.h"" #include ""absl/strings/string_view.h"" #include ""opentelemetry/metrics/meter_provider.h"" #include ""opentelemetry/metrics/sync_instruments.h"" #include ""opentelemetry/nostd/shared_ptr.h"" +#include ""src/core/lib/transport/metadata_batch.h""+ namespace grpc { namespace internal { +class LabelsInjector {+ public:+  virtual ~LabelsInjector() {}+  // Read the incoming initial metadata to get the set of labels to be added to+  // metrics. (Includes the local labels.)+  virtual std::vector<std::pair<std::string, std::string>> GetPeerLabels(","The changes to use `absl::string_view` look good!  (As a side note, I realized that my earlier comment about using `Slice` doesn't make sense, since we're not encoding any of the label values as a single string by itself; we're always encoding them into a protobuf first.)However, I think the way you're using the iterable here isn't sufficient to actually solve the problem that I was concerned about.  It looks like you're using the iterable between the `CallTracer` and OT, but you're still using a vector between the `LabelsInjector` and the `CallTracer`, so this isn't actually helping us reduce the unnecessary overhead between the components in our own code.What I had intended here was to use an iterable interface to return the data from `LabelsInjector` to `CallTracer`, to avoid the need for allocating the vector.  For example, in `GetPeerLabels()`, the iterable could hold a slice ref to the metadata value.  On its first iteration, it could deserialize the protobuf.  It can have a fixed list of labels that it will look at and track the current index into that last, so that it knows which element to return on each iteration.  This would avoid the need to allocate a vector, and it would avoid the need to allocate a `std::string` for each label value (it could be returned as a `string_view`).Note that once you have such an iterable interface between `LabelsInjector` and `CallTracer`, it should be trivial to wrap that iterable in the OT iterable interface that you need to pass the data from `CallTracer` to OT.",
4210911,anicr7,https://api.github.com/repos/grpc/grpc/pulls/34184,1308224161,2023-08-29T05:37:29Z,src/core/ext/xds/xds_client.cc,"@@ -1690,7 +1702,7 @@ void XdsClient::CancelResourceWatch(const XdsResourceType* type,   if (resource_it == type_map.end()) return;   ResourceState& resource_state = resource_it->second;   // Remove watcher.-  resource_state.watchers.erase(watcher);+  delete_watcher_from(resource_state.watchers);","Discussed this offline but for posterity, the actual issue that we noticed is being caused by authority_state.channel_state.reset(line 1721) right now.So we also need to find to prevent a possible deadlock due to it along with the watcher deletion. ",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34051,1308974266,2023-08-29T15:02:45Z,src/core/lib/transport/metadata_batch.h,"@@ -305,6 +305,13 @@ struct GrpcTagsBinMetadata : public SimpleSliceBasedMetadata {   static absl::string_view key() { return ""grpc-tags-bin""; } }; +// XEnvoyPeerMetadata+struct XEnvoyPeerMetadata : public SimpleSliceBasedMetadata {",(also how big is this expected to be... min/median/max bytes? - a rough guess would suffice),
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1309043286,2023-08-29T15:53:53Z,src/core/lib/transport/metadata_batch.h,"@@ -305,6 +305,13 @@ struct GrpcTagsBinMetadata : public SimpleSliceBasedMetadata {   static absl::string_view key() { return ""grpc-tags-bin""; } }; +// XEnvoyPeerMetadata+struct XEnvoyPeerMetadata : public SimpleSliceBasedMetadata {","If there are no proxies in the middle, it will always be the same for each client/server pair.  The problem is that we can't depend on that, because if there is a proxy in between, then the proxy could route each request from a given client to a different server (i.e., the client might see a different value for each request), and the proxy could send requests from different clients on the same connection to a server (i.e., the server might see a different value for each request).FWIW, keep in mind that in the long run, we want to completely eliminate this mechanism in favor of some out-of-band lookup for the metadata, so hopefully this isn't going to stick around forever.  But there are obviously no guarantees.",X
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1309495385,2023-08-30T01:11:06Z,src/cpp/ext/otel/otel_plugin.h,"@@ -25,16 +25,37 @@  #include <memory> #include <string>+#include <utility>+#include <vector>  #include ""absl/container/flat_hash_set.h"" #include ""absl/strings/string_view.h"" #include ""opentelemetry/metrics/meter_provider.h"" #include ""opentelemetry/metrics/sync_instruments.h"" #include ""opentelemetry/nostd/shared_ptr.h"" +#include ""src/core/lib/transport/metadata_batch.h""+ namespace grpc { namespace internal { +class LabelsInjector {+ public:+  virtual ~LabelsInjector() {}+  // Read the incoming initial metadata to get the set of labels to be added to+  // metrics. (Includes the local labels.)+  virtual std::vector<std::pair<std::string, std::string>> GetPeerLabels(","I did switch to an iterable interface between GSM and OTel as well. > What I had intended here was to use an iterable interface to return the data from LabelsInjector to CallTracer, to avoid the need for allocating the vector.As discussed on GVC, we will not be able to avoid an allocation but now *I think* we have atleast reduced the amount of memory we allocate, since the iterable classes just refer to the existing backing store and just return `std::pair<absl::string_view, absl::string_view>`",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1309498719,2023-08-30T01:16:08Z,src/core/lib/transport/metadata_batch.h,"@@ -305,6 +305,13 @@ struct GrpcTagsBinMetadata : public SimpleSliceBasedMetadata {   static absl::string_view key() { return ""grpc-tags-bin""; } }; +// XEnvoyPeerMetadata+struct XEnvoyPeerMetadata : public SimpleSliceBasedMetadata {",The metadata that we send remains the same for the lifetime of the binary.  The metadata that we receive as Mark mentioned is potentially changing.,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/34185,1309620503,2023-08-30T04:20:04Z,test/cpp/naming/cancel_ares_query_test.cc,"@@ -471,6 +471,71 @@ TEST_F(CancelDuringAresQuery, TestQueryFailsBecauseTcpServerClosesSocket) {   } } +// This test is meant to repro a bug noticed in internal issue b/297538255.+// The general issue is the loop in+// https://github.com/grpc/grpc/blob/f6a994229e72bc771963706de7a0cd8aa9150bb6/src/core/ext/filters/client_channel/resolver/dns/c_ares/grpc_ares_wrapper.cc#L371.+// The problem with that loop is that c-ares *can* in certain situations stop+// caring about the fd being processed without reading all of the data out of+// the read buffer. In that case, we keep looping because+// IsFdStillReadableLocked() keeps returning true, but we never make progress.+// Meanwhile, we are holding a lock which prevents cancellation or timeouts from+// kicking in, and thus we spin-loop forever.+//+// At the time of writing, this test case illustrates one way to hit that bug.+// It works as follows:+//   1) We force c-ares to use TCP for its DNS queries+//   2) We stand up a fake DNS server that, for each incoming connection, sends+//      three all-zero bytes and then closes the socket.+//   3) When the c-ares library receives the three-zero-byte response from the+//      DNS server, it parses the first two-bytes as a length field:+//      https://github.com/c-ares/c-ares/blob/6360e96b5cf8e5980c887ce58ef727e53d77243a/src/lib/ares_process.c#L410.+//   4) Because the first two bytes were zero, c-ares attempts to malloc a+//      zero-length buffer:+//      https://github.com/c-ares/c-ares/blob/6360e96b5cf8e5980c887ce58ef727e53d77243a/src/lib/ares_process.c#L428.+//   5) Because malloc(0) returns NULL, c-ares invokes handle_error and stops",Just a small nit: maybe say c-ares' default_malloc(0) returns NULL instead? Since it seems like some systems may return a valid pointer on malloc(0): https://github.com/c-ares/c-ares/blob/main/src/lib/ares_library_init.c#L38-L42,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34051,1310459118,2023-08-30T15:28:57Z,src/core/lib/transport/metadata_batch.h,"@@ -305,6 +305,13 @@ struct GrpcTagsBinMetadata : public SimpleSliceBasedMetadata {   static absl::string_view key() { return ""grpc-tags-bin""; } }; +// XEnvoyPeerMetadata+struct XEnvoyPeerMetadata : public SimpleSliceBasedMetadata {",Ok... and the other question: how big is it?(I'm trying to sanity check whether the compression policy makes sense),
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/34191,1310517863,2023-08-30T16:12:48Z,src/core/ext/transport/chaotic_good/frame.cc,"@@ -115,7 +120,11 @@ absl::StatusOr<Arena::PoolPtr<Metadata>> ReadMetadata(     uint32_t stream_id, bool is_header, bool is_client) {   if (!maybe_slices.ok()) return maybe_slices.status();   auto& slices = *maybe_slices;-  Arena::PoolPtr<Metadata> metadata;+  MemoryAllocator memory_allocator = MemoryAllocator(+      ResourceQuota::Default()->memory_quota()->CreateMemoryAllocator(+          ""read_metadata""));+  auto arena = MakeScopedArena(1024, &memory_allocator);",I dont think we should be allocating an arena each time a frame is parsed. We should change the ServerFragmentFrame::Deserialize and ReadMetadata methods to plumb the arena ptr from the transport down to this spot.,
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/34191,1310570263,2023-08-30T16:55:53Z,test/core/transport/chaotic_good/client_transport_test.cc,"@@ -127,218 +244,447 @@ class ClientTransportTest : public ::testing::Test {     }     return messages;   }+  // Wait for last stream read to finish.+  auto Wait() {+    return [this]() mutable -> Poll<Result> {+      MutexLock lock(&mu_);+      if (last_stream_read_done_) {+        return Result{};+      } else {+        waker_ = Activity::current()->MakeNonOwningWaker();+        return Pending();+      }+    };+  }+  // Wake up the pending Wait() promise.+  void Wakeup() {+    MutexLock lock(&mu_);+    last_stream_read_done_ = true;+    waker_.Wakeup();+  }   private:+  struct Result {};+  Mutex mu_;+  Waker waker_ ABSL_GUARDED_BY(mu_);+  bool last_stream_read_done_ ABSL_GUARDED_BY(mu_) = false;   MockEndpoint* control_endpoint_ptr_;   MockEndpoint* data_endpoint_ptr_;   size_t initial_arena_size = 1024;   MemoryAllocator memory_allocator_;+  Sequence control_endpoint_sequence;+  Sequence data_endpoint_sequence;   protected:   MockEndpoint& control_endpoint_;   MockEndpoint& data_endpoint_;   std::shared_ptr<grpc_event_engine::experimental::FuzzingEventEngine>       event_engine_;-  ClientTransport client_transport_;+  std::unique_ptr<ClientTransport> client_transport_;   ScopedArenaPtr arena_;   Pipe<MessageHandle> pipe_client_to_server_messages_;+  Pipe<MessageHandle> pipe_server_to_client_messages_;+  Pipe<ServerMetadataHandle> pipe_server_intial_metadata_;   // Added for mutliple streams tests.   Pipe<MessageHandle> pipe_client_to_server_messages_second_;--  const absl::Status kDummyErrorStatus =-      absl::ErrnoToStatus(5566, ""just an error"");-  static constexpr size_t kDummyRequestSize = 5566u;+  Pipe<MessageHandle> pipe_server_to_client_messages_second_;+  Pipe<ServerMetadataHandle> pipe_server_intial_metadata_second_;+  std::vector<absl::AnyInvocable<void(absl::Status)>> read_callback; };  TEST_F(ClientTransportTest, AddOneStream) {+  InitialClientTransport(1);   auto messages = CreateMessages(1);   ClientMetadataHandle md;-  auto args = CallArgs{-      std::move(md), ClientInitialMetadataOutstandingToken::Empty(), nullptr,-      nullptr,       &pipe_client_to_server_messages_.receiver,      nullptr};+  auto args = CallArgs{std::move(md),+                       ClientInitialMetadataOutstandingToken::Empty(),+                       nullptr,+                       &pipe_server_intial_metadata_.sender,+                       &pipe_client_to_server_messages_.receiver,+                       &pipe_server_to_client_messages_.sender};   StrictMock<MockFunction<void(absl::Status)>> on_done;   EXPECT_CALL(on_done, Call(absl::OkStatus()));   EXPECT_CALL(control_endpoint_, Write).WillOnce(Return(true));   EXPECT_CALL(data_endpoint_, Write).WillOnce(Return(true));   auto activity = MakeActivity(       Seq(-          // Concurrently: send message into the pipe, and receive from the-          // pipe.-          Join(Seq(pipe_client_to_server_messages_.sender.Push(-                       std::move(messages[0])),-                   [this] {-                     this->pipe_client_to_server_messages_.sender.Close();-                     return absl::OkStatus();-                   }),-               client_transport_.AddStream(std::move(args))),+          // Concurrently: write and read messages in client transport.+          Join(+              // Send messages to call_args.client_to_server_messages pipe,+              // which will be eventually sent to control/data endpoints.+              Seq(pipe_client_to_server_messages_.sender.Push(+                      std::move(messages[0])),+                  [this] {+                    pipe_client_to_server_messages_.sender.Close();+                    return absl::OkStatus();+                  }),+              // Add first stream with call_args into client transport.+              Seq(Join(client_transport_->AddStream(std::move(args)),+                       [this]() {+                         // Concurrently: start read from control endpoints.+                         read_callback[0](absl::OkStatus());+                         return absl::OkStatus();+                       }),+                  [](std::tuple<absl::StatusOr<ServerMetadataHandle>,+                                absl::Status>+                         ret) {+                    // AddStream will finish with server trailers:+                    // ""grpc-status:0"".+                    EXPECT_EQ(std::get<0>(ret)+                                  .value()+                                  ->get(GrpcStatusMetadata())+                                  .value(),+                              grpc_status_code::GRPC_STATUS_OK);+                    return absl::OkStatus();+                  }),+              // Receive messages from control/data endpoints.+              Seq(+                  // Receive server initial metadata.+                  pipe_server_intial_metadata_.receiver.Next(),+                  // Receive server to client messages.+                  pipe_server_to_client_messages_.receiver.Next(),+                  [this] {+                    // Close pipes after receive message.",Can you add expectations here and elsewhere to validate that the initial metadata and message values match the expected ones ?,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1310643894,2023-08-30T18:05:07Z,src/cpp/ext/gsm/metadata_exchange.cc,"@@ -120,6 +122,116 @@ absl::string_view GetStringValueFromUpbStruct(google_protobuf_Struct* struct_pb,   return ""unknown""; } +class LocalLabelsIterable : public LabelsIterable {+ public:+  explicit LocalLabelsIterable(+      const std::vector<std::pair<absl::string_view, std::string>>& labels)+      : labels_(labels) {}++  absl::optional<std::pair<absl::string_view, absl::string_view>> Next()+      override {+    if (pos_ >= labels_.size()) {+      return absl::nullopt;+    }+    return labels_[pos_++];+  }++  size_t Size() const override { return labels_.size(); }++  void ResetIteratorPosition() override { pos_ = 0; }++ private:+  size_t pos_ = 0;+  const std::vector<std::pair<absl::string_view, std::string>>& labels_;+};++class PeerLabelsIterable : public LabelsIterable {+ public:+  explicit PeerLabelsIterable(grpc_core::Slice remote_metadata) {+    std::string decoded_metadata;","Instead of doing this decoding here, I suggest doing it in `Next()` when `pos_` is 0.  That way, we're not holding on to the memory for the deserialized proto until we actually need it.  Note that for a streaming call, there can be a long time between receiving the initial metadata and the end of the call, which is where we actually need to do the iteration.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1310665709,2023-08-30T18:27:30Z,src/cpp/ext/gsm/metadata_exchange.cc,"@@ -120,6 +122,116 @@ absl::string_view GetStringValueFromUpbStruct(google_protobuf_Struct* struct_pb,   return ""unknown""; } +class LocalLabelsIterable : public LabelsIterable {+ public:+  explicit LocalLabelsIterable(+      const std::vector<std::pair<absl::string_view, std::string>>& labels)+      : labels_(labels) {}++  absl::optional<std::pair<absl::string_view, absl::string_view>> Next()+      override {+    if (pos_ >= labels_.size()) {+      return absl::nullopt;+    }+    return labels_[pos_++];+  }++  size_t Size() const override { return labels_.size(); }++  void ResetIteratorPosition() override { pos_ = 0; }++ private:+  size_t pos_ = 0;+  const std::vector<std::pair<absl::string_view, std::string>>& labels_;+};++class PeerLabelsIterable : public LabelsIterable {+ public:+  explicit PeerLabelsIterable(grpc_core::Slice remote_metadata) {+    std::string decoded_metadata;+    bool metadata_decoded = absl::Base64Unescape(+        remote_metadata.as_string_view(), &decoded_metadata);+    if (metadata_decoded) {+      struct_pb_ = google_protobuf_Struct_parse(+          decoded_metadata.c_str(), decoded_metadata.size(), arena_.ptr());+      type_ = GetStringValueFromUpbStruct(struct_pb_, kMetadataExchangeTypeKey,+                                          arena_.ptr());+    }+  }++  absl::optional<std::pair<absl::string_view, absl::string_view>> Next()+      override {+    if (struct_pb_ == nullptr) {+      return absl::nullopt;+    }+    if (pos_++ == 0) {+      return std::make_pair(kPeerTypeAttribute, type_);+    }+    // Only handle GKE type for now.+    if (type_ != kGkeType) {+      return absl::nullopt;+    }+    switch (pos_ - 1) {+      case 1:+        return std::make_pair(+            kPeerPodNameAttribute,+            GetStringValueFromUpbStruct(struct_pb_, kMetadataExchangePodNameKey,+                                        arena_.ptr()));+      case 2:+        return std::make_pair(+            kPeerContainerNameAttribute,+            GetStringValueFromUpbStruct(+                struct_pb_, kMetadataExchangeContainerNameKey, arena_.ptr()));+      case 3:+        return std::make_pair(+            kPeerNamespaceNameAttribute,+            GetStringValueFromUpbStruct(+                struct_pb_, kMetadataExchangeNamespaceNameKey, arena_.ptr()));+      case 4:+        return std::make_pair(+            kPeerClusterNameAttribute,+            GetStringValueFromUpbStruct(+                struct_pb_, kMetadataExchangeClusterNameKey, arena_.ptr()));+      case 5:+        return std::make_pair(+            kPeerLocationAttribute,+            GetStringValueFromUpbStruct(+                struct_pb_, kMetadataExchangeLocationKey, arena_.ptr()));+      case 6:+        return std::make_pair(+            kPeerProjectIdAttribute,+            GetStringValueFromUpbStruct(+                struct_pb_, kMetadataExchangeProjectIdKey, arena_.ptr()));+      case 7:+        return std::make_pair(+            kPeerCanonicalServiceAttribute,+            GetStringValueFromUpbStruct(struct_pb_,+                                        kMetadataExchangeCanonicalServiceKey,+                                        arena_.ptr()));+      default:+        return absl::nullopt;+    }+  }++  size_t Size() const override {+    if (struct_pb_ == nullptr) {+      return 0;+    }+    if (type_ != kGkeType) {+      return 1;+    }+    return 8;+  }++  void ResetIteratorPosition() override { pos_ = 0; }++ private:+  upb::Arena arena_;+  google_protobuf_Struct* struct_pb_ = nullptr;+  absl::string_view type_;","To save a bit of memory, this could be an enum.  That would also make the conditional more efficient in the future when we add support for GCE and other environments.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1310675007,2023-08-30T18:36:23Z,src/cpp/ext/gsm/metadata_exchange.cc,"@@ -178,59 +295,18 @@ ServiceMeshLabelsInjector::ServiceMeshLabelsInjector(   // TODO(yashykt): Add mesh_id } -std::vector<std::pair<absl::string_view, std::string>>-ServiceMeshLabelsInjector::GetPeerLabels(+std::unique_ptr<LabelsIterable> ServiceMeshLabelsInjector::GetPeerLabels(     grpc_metadata_batch* incoming_initial_metadata) {-  auto remote_metadata =+  auto peer_metadata =       incoming_initial_metadata->Take(grpc_core::XEnvoyPeerMetadata());-  std::vector<std::pair<absl::string_view, std::string>> labels;-  upb::Arena arena;-  google_protobuf_Struct* struct_pb = nullptr;-  if (remote_metadata.has_value()) {-    std::string decoded_metadata;-    bool metadata_decoded = absl::Base64Unescape(-        remote_metadata.value().as_string_view(), &decoded_metadata);-    if (metadata_decoded) {-      struct_pb = google_protobuf_Struct_parse(-          decoded_metadata.c_str(), decoded_metadata.size(), arena.ptr());-    }+  if (!peer_metadata.has_value()) {+    return nullptr;   }-  labels.emplace_back(kPeerTypeAttribute,-                      GetStringValueFromUpbStruct(-                          struct_pb, kMetadataExchangeTypeKey, arena.ptr()));-  labels.emplace_back(kPeerPodNameAttribute,-                      GetStringValueFromUpbStruct(-                          struct_pb, kMetadataExchangePodNameKey, arena.ptr()));-  labels.emplace_back(-      kPeerContainerNameAttribute,-      GetStringValueFromUpbStruct(struct_pb, kMetadataExchangeContainerNameKey,-                                  arena.ptr()));-  labels.emplace_back(-      kPeerNamespaceNameAttribute,-      GetStringValueFromUpbStruct(struct_pb, kMetadataExchangeNamespaceNameKey,-                                  arena.ptr()));-  labels.emplace_back(-      kPeerClusterNameAttribute,-      GetStringValueFromUpbStruct(struct_pb, kMetadataExchangeClusterNameKey,-                                  arena.ptr()));-  labels.emplace_back(-      kPeerLocationAttribute,-      GetStringValueFromUpbStruct(struct_pb, kMetadataExchangeLocationKey,-                                  arena.ptr()));-  labels.emplace_back(-      kPeerProjectIdAttribute,-      GetStringValueFromUpbStruct(struct_pb, kMetadataExchangeProjectIdKey,-                                  arena.ptr()));-  labels.emplace_back(-      kPeerCanonicalServiceAttribute,-      GetStringValueFromUpbStruct(-          struct_pb, kMetadataExchangeCanonicalServiceKey, arena.ptr()));-  return labels;+  return std::make_unique<PeerLabelsIterable>(std::move(peer_metadata).value());",Suggest using `*std::move(peer_metadata)` instead of using the `value()` method.  See go/totw/181.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1310681977,2023-08-30T18:43:12Z,src/cpp/ext/otel/otel_plugin.cc,"@@ -202,5 +202,48 @@ absl::flat_hash_set<std::string> OpenTelemetryPluginBuilder::BaseMetrics() {           OTelServerCallRcvdTotalCompressedMessageSizeInstrumentName())}; } +absl::string_view StatusCodeToString(grpc_status_code code) {",We already have a function to do this:https://github.com/grpc/grpc/blob/fb635a1959e8828a70194134c29a87c0c6b8c0fd/src/core/lib/channel/status_util.h#L37,X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34210,1310776037,2023-08-30T20:19:15Z,tools/dockerfile/interoptest/grpc_interop_cxx_xds/Dockerfile.xds_client,"@@ -27,10 +27,13 @@ COPY . . RUN tools/bazel build //test/cpp/interop:xds_interop_client RUN cp -rL /workdir/bazel-bin/test/cpp/interop/xds_interop_client /artifacts/ -FROM python:3.9-slim-bullseye-COPY --from=0 /artifacts ./+FROM python:3.9-slim-bookworm  ENV GRPC_VERBOSITY=""DEBUG"" ENV GRPC_TRACE=""xds_client,xds_resolver,xds_cluster_manager_lb,cds_lb,xds_cluster_resolver_lb,priority_lb,xds_cluster_impl_lb,weighted_target_lb,xds_server_config_fetcher,ring_hash_lb,outlier_detection_lb,xds_wrr_locality_lb,xds_override_host_lb"" +RUN apt-get update -y && apt-get upgrade -y","```suggestionRUN apt-get update \    && apt-get -y upgrade \    && apt-get -y autoremove \    && rm -rf /var/lib/apt/lists/*```Without a proper cleanup, undeleted images will still trigger a vulnerability report.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34210,1310776254,2023-08-30T20:19:29Z,tools/dockerfile/interoptest/grpc_interop_cxx_xds/Dockerfile.xds_server,"@@ -27,11 +27,13 @@ COPY . . RUN tools/bazel build //test/cpp/interop:xds_interop_server RUN cp -rL /workdir/bazel-bin/test/cpp/interop/xds_interop_server /artifacts/ -FROM python:3.9-slim-bullseye--COPY --from=0 /artifacts ./+FROM python:3.9-slim-bookworm  ENV GRPC_VERBOSITY=""DEBUG"" ENV GRPC_TRACE=""xds_client,xds_resolver,xds_cluster_manager_lb,cds_lb,xds_cluster_resolver_lb,priority_lb,xds_cluster_impl_lb,weighted_target_lb,xds_server_config_fetcher,ring_hash_lb,outlier_detection_lb,xds_wrr_locality_lb,xds_override_host_lb"" +RUN apt-get update -y && apt-get upgrade -y",```suggestionRUN apt-get update \    && apt-get -y upgrade \    && apt-get -y autoremove \    && rm -rf /var/lib/apt/lists/*```,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1310907464,2023-08-30T22:42:23Z,src/cpp/ext/gsm/metadata_exchange.cc,"@@ -120,6 +122,116 @@ absl::string_view GetStringValueFromUpbStruct(google_protobuf_Struct* struct_pb,   return ""unknown""; } +class LocalLabelsIterable : public LabelsIterable {+ public:+  explicit LocalLabelsIterable(+      const std::vector<std::pair<absl::string_view, std::string>>& labels)+      : labels_(labels) {}++  absl::optional<std::pair<absl::string_view, absl::string_view>> Next()+      override {+    if (pos_ >= labels_.size()) {+      return absl::nullopt;+    }+    return labels_[pos_++];+  }++  size_t Size() const override { return labels_.size(); }++  void ResetIteratorPosition() override { pos_ = 0; }++ private:+  size_t pos_ = 0;+  const std::vector<std::pair<absl::string_view, std::string>>& labels_;+};++class PeerLabelsIterable : public LabelsIterable {+ public:+  explicit PeerLabelsIterable(grpc_core::Slice remote_metadata) {+    std::string decoded_metadata;","We either hold on to the metadata or the deserialized proto. Note that for `Size()`, we need the deserialized proto anyway. We *could* do it lazily the first time we need it?",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34180,1310909797,2023-08-30T22:45:48Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -66,12 +68,40 @@ grpc_ssl_credentials::create_security_connector(   absl::optional<std::string> overridden_target_name =       args->GetOwnedString(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG);   auto* ssl_session_cache = args->GetObject<tsi::SslSessionLRUCache>();+  tsi_ssl_session_cache* tsi_ssl_session_cache =+      ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr();++  const tsi_ssl_root_certs_store* root_store;+  // Use default root certificates.+  if (config_.pem_root_certs == nullptr) {+    // TODO(gtcooke94) make sure to remove this memory+    const char* pem_root_certs =+        grpc_core::DefaultSslRootStore::GetPemRootCerts();+    if (pem_root_certs == nullptr) {+      gpr_log(GPR_ERROR, ""Could not get default pem root certs."");+      return nullptr;+    }+    size_t root_len = strlen(pem_root_certs);+    char* default_roots = strcpy(new char[root_len + 1], pem_root_certs);+    config_.pem_root_certs = default_roots;+    root_store = grpc_core::DefaultSslRootStore::GetRootStore();+  } else {+    config_.pem_root_certs = config_.pem_root_certs;+    root_store = nullptr;+  }++  grpc_security_status status = initialize_client_handshaker_factory(+      &config_, config_.pem_root_certs, root_store, tsi_ssl_session_cache);","I don't think we can pass in the `tsi_ssl_session_cache` in this way because it is coming from the ChannelArgs, which are tied to the channel rather than to the SSL credentials.To get around this, I was thinking that we could add a new `tsi_ssl_session_cache*` parameter to the `tsi_ssl_client_handshaker_factory_create_handshaker` API, and plumb the session cache pointer from here to where the security connector calls that API. WDYT?If we can do that, then I think we can also move all of this logic to the constructor of the SSL credentials.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/33969,1310982164,2023-08-31T00:52:43Z,src/python/grpcio/grpc/_cython/_cygrpc/common.pyx.pxi,"@@ -0,0 +1,45 @@+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++class BaseError(Exception):+    """"""+    This class is EXPERIMENTAL.+    The base class for exceptions generated by gRPC.+    """"""++class UsageError(BaseError):+    """"""+    This class is EXPERIMENTAL.",Can we make sure that these classes and docstrings end up in the generated documentation? I'm not sure if it will show up since 1) it's included via reimport and 2) it's defined in Cython.,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34051,1310994198,2023-08-31T01:17:22Z,src/cpp/ext/otel/otel_call_tracer.h,"@@ -96,9 +95,9 @@ class OpenTelemetryCallTracer : public grpc_core::ClientCallTracer {     const bool arena_allocated_;     // Start time (for measuring latency).     absl::Time start_time_;-    std::vector<std::pair<absl::string_view,-                          absl::variant<absl::string_view, std::string>>>-        labels_;+    std::string method_;","uh, this should be unused actually.. removed",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1311794892,2023-08-31T15:16:00Z,src/cpp/ext/otel/otel_server_call_tracer.cc,"@@ -131,16 +134,17 @@ class OpenTelemetryServerCallTracer : public grpc_core::ServerCallTracer {  private:   absl::Time start_time_;   absl::Duration elapsed_time_;-  std::string method_;+  grpc_core::Slice path_;+  absl::string_view method_;","Instead of storing this as a data member, we could just have a method that returns this value by calling `absl::StripPrefix(path_.as_string_view(), ""/"")`.  That would reduce per-call memory with very little additional CPU overhead.Same thing in the client call tracer, I suspect.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34051,1311817640,2023-08-31T15:29:36Z,src/cpp/ext/gsm/metadata_exchange.cc,"@@ -147,77 +157,81 @@ class LocalLabelsIterable : public LabelsIterable {  class PeerLabelsIterable : public LabelsIterable {  public:-  explicit PeerLabelsIterable(grpc_core::Slice remote_metadata) {-    std::string decoded_metadata;-    bool metadata_decoded = absl::Base64Unescape(-        remote_metadata.as_string_view(), &decoded_metadata);-    if (metadata_decoded) {-      struct_pb_ = google_protobuf_Struct_parse(-          decoded_metadata.c_str(), decoded_metadata.size(), arena_.ptr());-      type_ = GetStringValueFromUpbStruct(struct_pb_, kMetadataExchangeTypeKey,-                                          arena_.ptr());-    }-  }+  explicit PeerLabelsIterable(grpc_core::Slice remote_metadata)+      : metadata_(std::move(remote_metadata)) {}    absl::optional<std::pair<absl::string_view, absl::string_view>> Next()       override {-    if (struct_pb_ == nullptr) {+    auto& struct_pb = GetDecodedMetadata();+    if (struct_pb.struct_pb == nullptr) {       return absl::nullopt;     }-    if (pos_++ == 0) {-      return std::make_pair(kPeerTypeAttribute, type_);+    if (++pos_ == 1) {+      return std::make_pair(kPeerTypeAttribute,+                            GetStringValueFromUpbStruct(+                                struct_pb.struct_pb, kMetadataExchangeTypeKey,+                                struct_pb.arena.ptr()));     }     // Only handle GKE type for now.-    if (type_ != kGkeType) {-      return absl::nullopt;-    }-    switch (pos_ - 1) {-      case 1:-        return std::make_pair(-            kPeerPodNameAttribute,-            GetStringValueFromUpbStruct(struct_pb_, kMetadataExchangePodNameKey,-                                        arena_.ptr()));-      case 2:-        return std::make_pair(-            kPeerContainerNameAttribute,-            GetStringValueFromUpbStruct(-                struct_pb_, kMetadataExchangeContainerNameKey, arena_.ptr()));-      case 3:-        return std::make_pair(-            kPeerNamespaceNameAttribute,-            GetStringValueFromUpbStruct(-                struct_pb_, kMetadataExchangeNamespaceNameKey, arena_.ptr()));-      case 4:-        return std::make_pair(-            kPeerClusterNameAttribute,-            GetStringValueFromUpbStruct(-                struct_pb_, kMetadataExchangeClusterNameKey, arena_.ptr()));-      case 5:-        return std::make_pair(-            kPeerLocationAttribute,-            GetStringValueFromUpbStruct(-                struct_pb_, kMetadataExchangeLocationKey, arena_.ptr()));-      case 6:-        return std::make_pair(-            kPeerProjectIdAttribute,-            GetStringValueFromUpbStruct(-                struct_pb_, kMetadataExchangeProjectIdKey, arena_.ptr()));-      case 7:-        return std::make_pair(-            kPeerCanonicalServiceAttribute,-            GetStringValueFromUpbStruct(struct_pb_,-                                        kMetadataExchangeCanonicalServiceKey,-                                        arena_.ptr()));-      default:+    switch (type_) {+      case GcpResourceType::kGke:+        switch (pos_) {","Consider using a static array here:```struct GkeAttribute {  absl::string_view otel_attribute;  absl::string_view metadata_attribute;};static const std::array<GkeAttribute, 7> kGkeAttributeList = {  { kPeerPodNameAttribute, kMetadataExchangePodNameKey },  { kPeerContainerNameAttribute, kMetadataExchangeContainerNameKey },  // ...};```Then the code here becomes:```if (pos_ - 1 >= kGkeAttributeList.size()) return absl::nullopt;const GkeAttribute& attr = kGkeAttributeList[pos_ - 1];return std::make_pair(    attr.otel_attribute,    GetStringValueFromUpbStruct(        struct_pb.struct_pb,        attr.metadata_attribute,        struct_pb.arena.ptr()));```Also, on line 237, you can change the hard-coded `8` to `kGkeAttributeList.size() + 1`.With this approach, if we ever add new labels here, there will be only one place to update the code.",X
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/33969,1311965200,2023-08-31T17:26:40Z,src/python/grpcio/grpc/_cython/_cygrpc/common.pyx.pxi,"@@ -0,0 +1,45 @@+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++class BaseError(Exception):+    """"""+    This class is EXPERIMENTAL.+    The base class for exceptions generated by gRPC.+    """"""++class UsageError(BaseError):+    """"""+    This class is EXPERIMENTAL.","We should have them, before this change, those errors are also defined in Cython and included via reimport in Async stack, and they're included in our documentation: https://grpc.github.io/grpc/python/grpc_asyncio.html#grpc-exceptions",
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/34218,1312007065,2023-08-31T18:01:56Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -418,46 +606,47 @@ void PickFirst::PickFirstSubchannelData::ProcessConnectivityChangeLocked(   //    select in place of the current one.   // If the subchannel is READY, use it.   if (new_state == GRPC_CHANNEL_READY) {-    subchannel_list()->set_in_transient_failure(false);+    subchannel_list_->in_transient_failure_ = false;     ProcessUnselectedReadyLocked();     return;   }   // If we haven't yet seen the initial connectivity state notification   // for all subchannels, do nothing.-  if (!subchannel_list()->AllSubchannelsSeenInitialState()) return;+  if (!subchannel_list_->AllSubchannelsSeenInitialState()) return;   // If we're still here and this is the initial connectivity state   // notification for this subchannel, that means it was the last one to   // see its initial notification.  Start trying to connect, starting   // with the first subchannel.   if (!old_state.has_value()) {-    subchannel_list()->subchannel(0)->ReactToConnectivityStateLocked();+    subchannel_list_->subchannels_.front().ReactToConnectivityStateLocked();     return;   }   // Ignore any other updates for subchannels we're not currently trying to   // connect to.-  if (Index() != subchannel_list()->attempting_index()) return;+  if (Index() != subchannel_list_->attempting_index_) return;   // React to the connectivity state.   ReactToConnectivityStateLocked(); } -void PickFirst::PickFirstSubchannelData::ReactToConnectivityStateLocked() {-  PickFirst* p = static_cast<PickFirst*>(subchannel_list()->policy());+void PickFirst::SubchannelList::SubchannelData::+    ReactToConnectivityStateLocked() {+  PickFirst* p = subchannel_list_->policy_.get();   // Otherwise, process connectivity state.-  switch (connectivity_state().value()) {+  switch (connectivity_state_.value()) {     case GRPC_CHANNEL_READY:       // Already handled this case above, so this should not happen.       GPR_UNREACHABLE_CODE(break);     case GRPC_CHANNEL_TRANSIENT_FAILURE: {       // Find the next subchannel not in state TRANSIENT_FAILURE.       // We skip subchannels in state TRANSIENT_FAILURE to avoid a       // large recursion that could overflow the stack.-      PickFirstSubchannelData* found_subchannel = nullptr;+      SubchannelData* found_subchannel = nullptr;       for (size_t next_index = Index() + 1;-           next_index < subchannel_list()->num_subchannels(); ++next_index) {-        PickFirstSubchannelData* sc = subchannel_list()->subchannel(next_index);-        GPR_ASSERT(sc->connectivity_state().has_value());-        if (sc->connectivity_state() != GRPC_CHANNEL_TRANSIENT_FAILURE) {-          subchannel_list()->set_attempting_index(next_index);+           next_index < subchannel_list_->size(); ++next_index) {","645-667 seem to use more of `subchannel_list_` - so maybe there should be a ""find_next_subchannel_not_transient_failure` method in subchannel list class?",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34218,1312010359,2023-08-31T18:05:26Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -418,46 +606,47 @@ void PickFirst::PickFirstSubchannelData::ProcessConnectivityChangeLocked(   //    select in place of the current one.   // If the subchannel is READY, use it.   if (new_state == GRPC_CHANNEL_READY) {-    subchannel_list()->set_in_transient_failure(false);+    subchannel_list_->in_transient_failure_ = false;     ProcessUnselectedReadyLocked();     return;   }   // If we haven't yet seen the initial connectivity state notification   // for all subchannels, do nothing.-  if (!subchannel_list()->AllSubchannelsSeenInitialState()) return;+  if (!subchannel_list_->AllSubchannelsSeenInitialState()) return;   // If we're still here and this is the initial connectivity state   // notification for this subchannel, that means it was the last one to   // see its initial notification.  Start trying to connect, starting   // with the first subchannel.   if (!old_state.has_value()) {-    subchannel_list()->subchannel(0)->ReactToConnectivityStateLocked();+    subchannel_list_->subchannels_.front().ReactToConnectivityStateLocked();     return;   }   // Ignore any other updates for subchannels we're not currently trying to   // connect to.-  if (Index() != subchannel_list()->attempting_index()) return;+  if (Index() != subchannel_list_->attempting_index_) return;","I'm not sure what you mean by ""encapsulation"".  If you mean the fact that we're directly accessing a data member, I think it's fine, because this access is coming from `SubchannelData`, which is nested inside of `SubchannelList` and can therefore access its data members by normal C++ scoping rules.  In effect, `SubchannelData` is part of the implementation of `SubchannelList`, so it's fine to access its private data members.  We use this pattern quite a bit.",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1312021192,2023-08-31T18:12:36Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -66,12 +68,40 @@ grpc_ssl_credentials::create_security_connector(   absl::optional<std::string> overridden_target_name =       args->GetOwnedString(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG);   auto* ssl_session_cache = args->GetObject<tsi::SslSessionLRUCache>();+  tsi_ssl_session_cache* tsi_ssl_session_cache =+      ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr();++  const tsi_ssl_root_certs_store* root_store;+  // Use default root certificates.+  if (config_.pem_root_certs == nullptr) {+    // TODO(gtcooke94) make sure to remove this memory+    const char* pem_root_certs =+        grpc_core::DefaultSslRootStore::GetPemRootCerts();+    if (pem_root_certs == nullptr) {+      gpr_log(GPR_ERROR, ""Could not get default pem root certs."");+      return nullptr;+    }+    size_t root_len = strlen(pem_root_certs);+    char* default_roots = strcpy(new char[root_len + 1], pem_root_certs);+    config_.pem_root_certs = default_roots;+    root_store = grpc_core::DefaultSslRootStore::GetRootStore();+  } else {+    config_.pem_root_certs = config_.pem_root_certs;+    root_store = nullptr;+  }++  grpc_security_status status = initialize_client_handshaker_factory(+      &config_, config_.pem_root_certs, root_store, tsi_ssl_session_cache);","I think that makes sense with the `tsi_ssl_session_cache`. `tsi_ssl_client_handshaker_factory_create_handshaker` ends up getting called here - https://github.com/grpc/grpc/blob/4295f0250c6344c1e492bdb45d4ad01ae28d9177/src/core/lib/security/security_connector/ssl/ssl_security_connector.cc#L140 and we have access to the channel args, so that should be easy to plumb.I don't know if we can move all the logic to the SSL credentials - we're still making a lot of calls to OpenSSL that can fail when creating and populating the SSL_CTX, so we need to be able to do a status return",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34225,1313170990,2023-09-01T15:16:57Z,src/core/ext/filters/channel_idle/channel_idle_filter.cc,"@@ -111,12 +113,21 @@ struct MaxAgeFilter::Config {             .value_or(kDefaultMaxConnectionAgeGrace);     // generate a random number between 1 - kMaxConnectionAgeJitter and     // 1 + kMaxConnectionAgeJitter-    const double multiplier =-        rand() * kMaxConnectionAgeJitter * 2.0 / RAND_MAX + 1.0 --        kMaxConnectionAgeJitter;+    struct BitGen {+      Mutex mu;+      absl::BitGen bit_gen ABSL_GUARDED_BY(mu);+      double MakeUniformDouble(double min, double max) {+        MutexLock lock(&mu);+        return absl::Uniform(bit_gen, min, max);+      }+    };+    static NoDestruct<PerCpu<BitGen>> bit_gen(PerCpuOptions().SetMaxShards(8));","Would it be better to just instantiate a new `absl::BitGen` object each time we call this?  I believe this code runs at connection establishment time, not per-call, right?  If so, it shouldn't be that performance sensitive and therefore may not be worth the complexity of `PerCpu<>` and synchronization.  Also, it seems like allocating 8 `BitGen` objects will increase memory usage, which may also not be the right trade-off.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34103,1315000716,2023-09-04T14:17:06Z,include/grpc/support/port_platform.h,"@@ -53,6 +53,57 @@ #define WIN32_LEAN_AND_MEAN #endif /* WIN32_LEAN_AND_MEAN */ +// GPRC_DLL+// inspired by+// https://github.com/abseil/abseil-cpp/blob/20220623.1/absl/base/config.h#L730-L747+//+// When building gRPC as a DLL, this macro expands to `__declspec(dllexport)`+// so we can annotate symbols appropriately as being exported. When used in+// headers consuming a DLL, this macro expands to `__declspec(dllimport)` so+// that consumers know the symbol is defined inside the DLL. In all other cases,+// the macro expands to nothing.+//+// Warning: shared library support for Windows (i.e. producing DLL plus import+//   library instead of a static library) is experimental. Some symbols that can+//   be linked using the static library may not be available when using the+//   dynamically linked library.+//+// Note: GRPC_DLL_EXPORTS is set in CMakeLists.txt when building shared+// grpc{,_unsecure}+//       GRPC_DLL_IMPORTS is set by us as part of the interface for consumers of+//       the DLL+#if !defined(GRPC_DLL)","note that the GRPC_DLL GRPCXX_DLL and GPR_DLL defines depend on the assumption that the only 3  ""public"" libraries known to us are gpr, grpc and grpc++. In the future, we are likely planning to make the layout of libraries in cmake more akin to what's in grpc's bazel BUILD (that has much more granular targets) at which point it won't be feasible to hand list all the known public libraries here?I'll leave the decision whether the defines make sense as-is to @veblush  but I wanted to point out this potential problem.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34103,1315003571,2023-09-04T14:20:02Z,CMakeLists.txt,"@@ -421,8 +421,42 @@ endif()  if(WIN32)   set(_gRPC_ALLTARGETS_LIBRARIES ${_gRPC_ALLTARGETS_LIBRARIES} ws2_32 crypt32)+  set(_gRPC_STATIC_WIN32 STATIC) endif() +if(BUILD_SHARED_LIBS AND WIN32)++# Currently for shared lib on Windows (i.e. a DLL) certain bits of source code+# are generated from protobuf definitions by upbc. This source code does not include+# annotations needed to export these functions from gprc.lib so we have to+# re-include a small subset of these.+#+# This is not an ideal situation because these functions will be unavailable+# to clients of grpc and the libraries that need this (e.g. grpc++) will+# include redundant duplicate code. Hence, the duplication is only activated+# for DLL builds - and should be completely removed when source files are+# generated with the necessary __declspec annotations.+set(gRPC_UPB_GEN_DUPL_SRC","ok, patching the build with gRPC_UPB_GEN_DUPL_SRC and gRPC_ADDITIONAL_WIN_DLL_SRC seems very dirty so we should really have a clear plan how to handle these in the future cleanly, otherwise we're introducing some serious and hard-to-understand technical debt.If there's a clear (and commited) plan how to get rid of these hacks in the future I might be ok with having there temporarily, but otherwise this is difficult to accept.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34103,1315008221,2023-09-04T14:24:42Z,templates/CMakeLists.txt.template,"@@ -150,6 +150,20 @@       private_libs.append(""-l"" + lib_name)     return private_libs +  def lib_type_for_lib(lib_name):+    """"""Returns STATIC/SHARED to force a static or shared lib build depending on the library.""""""+    # grpc_csharp_ext is loaded by C# runtime and it+    # only makes sense as a shared lib.+    if lib_name in ['grpc_csharp_ext']:+      return ' SHARED'++    # upb always compiles as a static library on Windows+    elif lib_name in ['upb','upb_collections_lib','upb_json_lib','upb_textformat_lib']:","note that in the future we'll need a better way of telling which are the ""upb"" libraries than just listing them in multiple places in the CmakeLists.txt.tempate.FWIW, there should be single place that defines sth like `is_upb_library` and use that from elsewhere. Unfortunately, since our upb cmake dependency is in flux, we're not there yet.",X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34103,1315015903,2023-09-04T14:32:25Z,templates/CMakeLists.txt.template,"@@ -759,6 +820,17 @@     set_target_properties(${lib.name} PROPERTIES COMPILE_PDB_NAME ""${lib.name}""       COMPILE_PDB_OUTPUT_DIRECTORY <%text>""${CMAKE_BINARY_DIR}</%text>""     )+    % if lib.name == 'gpr':","to improve our cmake build, we're trying to get fewer reference to libraries by their name, not more. So in my opinion this change introduces technical debt that will need to be dealt with later (so not an ideal outcome).Basically deciding whether a library should have some special settings assigned to it should be based on library's metadata (e.g. is the a ""base"" grpc public library), not by listing libraries that should have these setting by their names.Unfortunately, the refactoring of our cmake build to extrapolate metadata like this (instead of relying of knowing the names of individual targets) is only in progress and definitely needs much more work.  My worries is that making changes like the once suggested in this PR, we'll make the subsequent refactoring even harder.",X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34103,1315020265,2023-09-04T14:37:03Z,include/grpc/support/port_platform.h,"@@ -53,6 +53,57 @@ #define WIN32_LEAN_AND_MEAN #endif /* WIN32_LEAN_AND_MEAN */ +// GPRC_DLL+// inspired by+// https://github.com/abseil/abseil-cpp/blob/20220623.1/absl/base/config.h#L730-L747+//+// When building gRPC as a DLL, this macro expands to `__declspec(dllexport)`+// so we can annotate symbols appropriately as being exported. When used in+// headers consuming a DLL, this macro expands to `__declspec(dllimport)` so+// that consumers know the symbol is defined inside the DLL. In all other cases,+// the macro expands to nothing.+//+// Warning: shared library support for Windows (i.e. producing DLL plus import+//   library instead of a static library) is experimental. Some symbols that can+//   be linked using the static library may not be available when using the+//   dynamically linked library.+//+// Note: GRPC_DLL_EXPORTS is set in CMakeLists.txt when building shared+// grpc{,_unsecure}+//       GRPC_DLL_IMPORTS is set by us as part of the interface for consumers of+//       the DLL+#if !defined(GRPC_DLL)","at the same time, I realize that because of the import / export semantics in windows DLLs, there probably needs to be a separate define for each library, so this is tricky to resolve.What does absl do here (since AFAIK absl consists of many shared libraries)?",
4710688,dawidcha,https://api.github.com/repos/grpc/grpc/pulls/34103,1315130653,2023-09-04T17:19:05Z,include/grpc/support/port_platform.h,"@@ -53,6 +53,57 @@ #define WIN32_LEAN_AND_MEAN #endif /* WIN32_LEAN_AND_MEAN */ +// GPRC_DLL+// inspired by+// https://github.com/abseil/abseil-cpp/blob/20220623.1/absl/base/config.h#L730-L747+//+// When building gRPC as a DLL, this macro expands to `__declspec(dllexport)`+// so we can annotate symbols appropriately as being exported. When used in+// headers consuming a DLL, this macro expands to `__declspec(dllimport)` so+// that consumers know the symbol is defined inside the DLL. In all other cases,+// the macro expands to nothing.+//+// Warning: shared library support for Windows (i.e. producing DLL plus import+//   library instead of a static library) is experimental. Some symbols that can+//   be linked using the static library may not be available when using the+//   dynamically linked library.+//+// Note: GRPC_DLL_EXPORTS is set in CMakeLists.txt when building shared+// grpc{,_unsecure}+//       GRPC_DLL_IMPORTS is set by us as part of the interface for consumers of+//       the DLL+#if !defined(GRPC_DLL)","> at the same time, I realize that because of the import / export semantics in windows DLLs, there probably needs to be a separate define for each library, so this is tricky to resolve. What does absl do here (since AFAIK absl consists of many shared libraries)?Abseil uses a single pair of macros for import/export determination ABSL_BUILD_DLL & ABSL_CONSUME_DLLThe abseil shared build emits a single DLL: abseil_dll.dll with an import library of abseil_dll.lib. It also emits other more specific import libraries, but I believe that these still reference the same DLL",
4710688,dawidcha,https://api.github.com/repos/grpc/grpc/pulls/34103,1315135297,2023-09-04T17:31:17Z,CMakeLists.txt,"@@ -421,8 +421,42 @@ endif()  if(WIN32)   set(_gRPC_ALLTARGETS_LIBRARIES ${_gRPC_ALLTARGETS_LIBRARIES} ws2_32 crypt32)+  set(_gRPC_STATIC_WIN32 STATIC) endif() +if(BUILD_SHARED_LIBS AND WIN32)++# Currently for shared lib on Windows (i.e. a DLL) certain bits of source code+# are generated from protobuf definitions by upbc. This source code does not include+# annotations needed to export these functions from gprc.lib so we have to+# re-include a small subset of these.+#+# This is not an ideal situation because these functions will be unavailable+# to clients of grpc and the libraries that need this (e.g. grpc++) will+# include redundant duplicate code. Hence, the duplication is only activated+# for DLL builds - and should be completely removed when source files are+# generated with the necessary __declspec annotations.+set(gRPC_UPB_GEN_DUPL_SRC","> ok, patching the build with gRPC_UPB_GEN_DUPL_SRC and gRPC_ADDITIONAL_WIN_DLL_SRC seems very dirty so we should really have a clear plan how to handle these in the future cleanly, otherwise we're introducing some serious and hard-to-understand technical debt.> > If there's a clear (and commited) plan how to get rid of these hacks in the future I might be ok with having there temporarily, but otherwise this is difficult to accept.Agreed - and it gets worse when we get the tests to build as well.Question: is the upb-generated and upbdefs-generated code part of the public API?As things stand, there's no way of annotating these generated files with dllimport/dllexport tags as the capability to do that in upb doesn't seem to exist (though it does in protobuf), so they are not currently exposed - hence the need to duplicate. I think the right solution is to factor out all this generated code from being included directly into grpc and into a separate always-static library, say upb_generated. The existing grpc library then gets renamed to something like grpc_base and the grpc definition simply includes grpc_base and the definition for grpc simply includes upb_generated and grpc_base - yielding a library with the exact same contents as the existing grpc, but allowing the duplicated source to be avoided by having those libs that need it because they depend on a grpc in which the symbols are not visible, to depend on grpc_base instead and mix in the symbols at the 'leaf' level.I think that would work provided the upb-generated symbols are not part of the public API.",X
4710688,dawidcha,https://api.github.com/repos/grpc/grpc/pulls/34103,1315142057,2023-09-04T17:50:20Z,templates/CMakeLists.txt.template,"@@ -759,6 +820,17 @@     set_target_properties(${lib.name} PROPERTIES COMPILE_PDB_NAME ""${lib.name}""       COMPILE_PDB_OUTPUT_DIRECTORY <%text>""${CMAKE_BINARY_DIR}</%text>""     )+    % if lib.name == 'gpr':","Yes, I get it - I did look at finding a way to add that to the metadata generated from bazel, but didn't want to move before agreeing a direction. Is there a branch with the cmake build refactoring in progress? I can take at contributing if it would help.",
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/33878,1315241617,2023-09-05T00:22:15Z,src/compiler/csharp_generator.cc,"@@ -735,14 +738,15 @@ void GenerateBindServiceWithBinderMethod(Printer* out,   for (int i = 0; i < service->method_count(); i++) {     const MethodDescriptor* method = service->method(i);     out->Print(-        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? null : ""+        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? ""+        ""null$nullforgiving$ : ""","The `!` is required because the `ServiceBinderBase.AddMethod` overloads aren't annotated to allow a nullable handler: https://github.com/grpc/grpc-dotnet/blob/3f908444494b01eed9ffa9f141bbe9f170aee7f6/src/Grpc.Core.Api/ServiceBinderBase.cs#L43This should be fixed in Grpc.Core.Api. However, even if fixed there, nullable generated code would require a fixed version of Grpc.Core.Api. If an older Grpc.Core.Api version is used, then there would be a warning that null can't be passed to the method.What I think we should do:1. Fix `ServiceBinderBase.AddMethod` to make handler nullable in grpc/grpc-dotnet.1. Leave the `!` here, but add a comment explaining why it is needed and add a TODO that it should be removed in the future. Once the updated version of Grpc.Core.Api has been public for some time, maybe in a years time, then the workaround can be removed.This would reduce the chance of people seeing warnings from generated code and give a path to a clean state.",X
33685575,h-vetinari,https://api.github.com/repos/grpc/grpc/pulls/34103,1315338903,2023-09-05T04:05:24Z,include/grpc/support/port_platform.h,"@@ -53,6 +53,57 @@ #define WIN32_LEAN_AND_MEAN #endif /* WIN32_LEAN_AND_MEAN */ +// GPRC_DLL+// inspired by+// https://github.com/abseil/abseil-cpp/blob/20220623.1/absl/base/config.h#L730-L747+//+// When building gRPC as a DLL, this macro expands to `__declspec(dllexport)`+// so we can annotate symbols appropriately as being exported. When used in+// headers consuming a DLL, this macro expands to `__declspec(dllimport)` so+// that consumers know the symbol is defined inside the DLL. In all other cases,+// the macro expands to nothing.+//+// Warning: shared library support for Windows (i.e. producing DLL plus import+//   library instead of a static library) is experimental. Some symbols that can+//   be linked using the static library may not be available when using the+//   dynamically linked library.+//+// Note: GRPC_DLL_EXPORTS is set in CMakeLists.txt when building shared+// grpc{,_unsecure}+//       GRPC_DLL_IMPORTS is set by us as part of the interface for consumers of+//       the DLL+#if !defined(GRPC_DLL)","> I realize that because of the import / export semantics in windows DLLs, there probably needs to be a separate define for each library, so this is tricky to resolve.> What does absl do here (since AFAIK absl consists of many shared libraries)?I believe the pain with having a separate symbol per library is why abseil essentially creates one big DLL (with consequently only one macro switching between dllimport & dllexport), rather than handling this on a per-library level.grpc's current situation with 3 libs is perhaps still acceptable for a manual setup, but if there are going to be more, then the shared setup on windows will likely have to bunch them together.Note that this is a ""lesser-of-two-evils"" situation, because the build divergence between `unix || static` and `win && shared` causes quite a bit of hassle, both for the build itself, but also for the pkgconfig & CMake metadata.CC @derekmauro",X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/33878,1315472196,2023-09-05T07:16:54Z,src/compiler/csharp_generator.cc,"@@ -735,14 +738,15 @@ void GenerateBindServiceWithBinderMethod(Printer* out,   for (int i = 0; i < service->method_count(); i++) {     const MethodDescriptor* method = service->method(i);     out->Print(-        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? null : ""+        ""serviceBinder.AddMethod($methodfield$, serviceImpl == null ? ""+        ""null$nullforgiving$ : ""","> The `!` is required because the `ServiceBinderBase.AddMethod` overloads aren't annotated to allow a nullable handler: https://github.com/grpc/grpc-dotnet/blob/3f908444494b01eed9ffa9f141bbe9f170aee7f6/src/Grpc.Core.Api/ServiceBinderBase.cs#L43> > This should be fixed in Grpc.Core.Api. However, even if fixed there, nullable generated code would require a fixed version of Grpc.Core.Api. If an older Grpc.Core.Api version is used, then there would be a warning that null can't be passed to the method.> > What I think we should do:> > 1. Fix `ServiceBinderBase.AddMethod` to make handler nullable in grpc/grpc-dotnet.> 2. Leave the `!` here, but add a comment explaining why it is needed and add a TODO that it should be removed in the future. Once the updated version of Grpc.Core.Api has been public for some time, maybe in a years time, then the workaround can be removed.> > This would reduce the chance of people seeing warnings from generated code and give a path to a clean state.I agree with @JamesNK here. Also this is basically what @tonydnewell  has already proposed so we seem to be in agreement.@tonydnewell  can you please add the comment?",X
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/34230,1316151231,2023-09-05T16:52:22Z,src/core/lib/channel/connected_channel.cc,"@@ -548,7 +548,7 @@ ArenaPromise<ServerMetadataHandle> MakeClientCallPromise(         }         if (!done_recv_messages) {           auto p = recv_messages();-          if (auto* r = p.value_if_ready()) {+          if ([[maybe_unused]] auto* r = p.value_if_ready()) {","`[[maybe_unused]]` is a C++17 attribute. I don't think we have moved to C++17 yet. And if initialization is C++17 extension too, see: https://godbolt.org/z/Mc5TTMe8T. So I suggest changing this code to:```auto* r = p.value_if_ready();if (r) {...} else {...}```Cc @ctiller",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1316413452,2023-09-05T21:15:19Z,src/core/lib/security/credentials/ssl/ssl_credentials.h,"@@ -70,6 +70,11 @@ class grpc_ssl_credentials : public grpc_channel_credentials {                     const grpc_ssl_verify_peer_options* verify_options);    grpc_ssl_config config_;+  grpc_security_status initialize_client_handshaker_factory(","To make sure I'm clear, you want to go on and change this to `InitializeClientHandshakerFactory`? Or just note it and save it for a larger PR where we restyle everything",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1316414683,2023-09-05T21:17:01Z,src/core/lib/security/credentials/ssl/ssl_credentials.h,"@@ -70,6 +70,11 @@ class grpc_ssl_credentials : public grpc_channel_credentials {                     const grpc_ssl_verify_peer_options* verify_options);    grpc_ssl_config config_;+  grpc_security_status initialize_client_handshaker_factory(+      const grpc_ssl_config* config, const char* pem_root_certs,+      const tsi_ssl_root_certs_store* root_store,+      tsi_ssl_session_cache* ssl_session_cache);+  tsi_ssl_client_handshaker_factory* client_handshaker_factory_ = nullptr;","I realized the handshaker_factories are already doing ref counting c-style, added explicit code to make this clear.See [here](https://github.com/grpc/grpc/blob/5c9e4050c1e8c66b1b8b4e93d48b8e23ff1ea818/src/core/tsi/ssl_transport_security.cc#L1759) for an example of where it is already being counted.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34221,1317559988,2023-09-06T16:39:01Z,test/core/ext/filters/client_channel/http_proxy_mapper_test.cc,,"This test should not have been moved.  We do not need to exactly mirror the directory structure from the `src` tree in the `test` tree -- and in the long term, we will probably remove the arbitrary division between the `lib` and `ext` directories in the `src` tree.The client channel tests should stay in `test/core/client_channel`.",X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/34221,1317576744,2023-09-06T16:52:59Z,test/core/ext/filters/client_channel/http_proxy_mapper_test.cc,,"Sorry, my bad. My understanding was there was no need to move the test but it was ok to do that. PR to move it back: https://github.com/grpc/grpc/pull/34268",X
4710688,dawidcha,https://api.github.com/repos/grpc/grpc/pulls/34103,1317735900,2023-09-06T19:31:22Z,CMakeLists.txt,"@@ -421,8 +421,42 @@ endif()  if(WIN32)   set(_gRPC_ALLTARGETS_LIBRARIES ${_gRPC_ALLTARGETS_LIBRARIES} ws2_32 crypt32)+  set(_gRPC_STATIC_WIN32 STATIC) endif() +if(BUILD_SHARED_LIBS AND WIN32)++# Currently for shared lib on Windows (i.e. a DLL) certain bits of source code+# are generated from protobuf definitions by upbc. This source code does not include+# annotations needed to export these functions from gprc.lib so we have to+# re-include a small subset of these.+#+# This is not an ideal situation because these functions will be unavailable+# to clients of grpc and the libraries that need this (e.g. grpc++) will+# include redundant duplicate code. Hence, the duplication is only activated+# for DLL builds - and should be completely removed when source files are+# generated with the necessary __declspec annotations.+set(gRPC_UPB_GEN_DUPL_SRC","> Future plan is to have a DLL suport from upb and I'm following up on this but it will take sometime as upb needs to create their cmakefile first. Once upb has a proper cmake with DLL support, we'll be able to remove this hack. Until we have it, I'm fine with this workaround.@veblush @jtattermusch @h-vetinari Would it be possible to arrange a zoom call to discuss options on this? I can see that upb is in flux (I see it just got moved to be a direct part of protobuf from being a repo in its own right), but I don't believe that the proposed changes in this PR add significant extra work with respect to adapting to that change. I'm also not seeing a future in which it won't be necessary at some level to provide additional metadata above and beyond what can be gleaned from the Bazel BUILD file, though I totally agree that such knowledge does not belong in the CMakeLists template file.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/34227,1317778116,2023-09-06T20:10:32Z,examples/python/interceptors/streaming/hellostreamingworld_pb2.pyi,"@@ -0,0 +1,67 @@+""""""",These generated files should be added to [the Makefile](https://github.com/grpc/grpc/blob/master/examples/python/Makefile).,X
33685575,h-vetinari,https://api.github.com/repos/grpc/grpc/pulls/34103,1317962575,2023-09-07T00:56:54Z,templates/CMakeLists.txt.template,"@@ -486,8 +507,42 @@    if(WIN32)     set(_gRPC_ALLTARGETS_LIBRARIES <%text>${_gRPC_ALLTARGETS_LIBRARIES}</%text> ws2_32 crypt32)+    set(_gRPC_STATIC_WIN32 STATIC)   endif() +  if(BUILD_SHARED_LIBS AND WIN32)++  # Currently for shared lib on Windows (i.e. a DLL) certain bits of source code+  # are generated from protobuf definitions by upbc. This source code does not include+  # annotations needed to export these functions from gprc.lib so we have to+  # re-include a small subset of these.+  #+  # This is not an ideal situation because these functions will be unavailable+  # to clients of grpc and the libraries that need this (e.g. grpc++) will+  # include redundant duplicate code. Hence, the duplication is only activated+  # for DLL builds - and should be completely removed when source files are+  # generated with the necessary __declspec annotations.+  set(gRPC_UPB_GEN_DUPL_SRC+    src/core/ext/upb-generated/src/proto/grpc/gcp/altscontext.upb.c+    src/core/ext/upb-generated/src/proto/grpc/health/v1/health.upb.c+    src/core/ext/upb-generated/src/proto/grpc/gcp/transport_security_common.upb.c+  )++  # When building shared lib on Windows, additional missing symbols need to+  # be resolved for grpc++_unsecure. Also that build needs to be able to resolve","Even though @dawidcha has improved the implementation, I believe this goes back to something I did originally. As I tried to switch our arrow builds in conda-forge to depend on the shared builds of grpc, there was an experimental symbol (`grpc::experimental::StaticDataCertificateProvider`) that could not get found anymore.When [trying](https://github.com/conda-forge/grpc-cpp-feedstock/pull/303) to add `GRPCXX_DLL` to that class, the build failed because it was relying on symbols (`CertificateProviderInterface` at least) that were only present in `grpc++` (rather than `grpc++_unsecure`). I didn't analyse this further as it didn't make a big difference on our side, but I guess the `StaticDataCertificateProvider` should be fully in `grpc++`?",
4710688,dawidcha,https://api.github.com/repos/grpc/grpc/pulls/34103,1318568369,2023-09-07T13:00:30Z,templates/CMakeLists.txt.template,"@@ -486,8 +507,42 @@    if(WIN32)     set(_gRPC_ALLTARGETS_LIBRARIES <%text>${_gRPC_ALLTARGETS_LIBRARIES}</%text> ws2_32 crypt32)+    set(_gRPC_STATIC_WIN32 STATIC)   endif() +  if(BUILD_SHARED_LIBS AND WIN32)++  # Currently for shared lib on Windows (i.e. a DLL) certain bits of source code+  # are generated from protobuf definitions by upbc. This source code does not include+  # annotations needed to export these functions from gprc.lib so we have to+  # re-include a small subset of these.+  #+  # This is not an ideal situation because these functions will be unavailable+  # to clients of grpc and the libraries that need this (e.g. grpc++) will+  # include redundant duplicate code. Hence, the duplication is only activated+  # for DLL builds - and should be completely removed when source files are+  # generated with the necessary __declspec annotations.+  set(gRPC_UPB_GEN_DUPL_SRC+    src/core/ext/upb-generated/src/proto/grpc/gcp/altscontext.upb.c+    src/core/ext/upb-generated/src/proto/grpc/health/v1/health.upb.c+    src/core/ext/upb-generated/src/proto/grpc/gcp/transport_security_common.upb.c+  )++  # When building shared lib on Windows, additional missing symbols need to+  # be resolved for grpc++_unsecure. Also that build needs to be able to resolve","The reason this is happening is that there is a dependency on StaticDataCertificateProvider which is ultimately resolved by including the file src\core\lib\security\credentials\tls\grpc_tls_certificate_provider.cc. This source file includes a function PrivateKeyAndCertificateMatch which has a dependency on openssl, hence the need to link it to resolve. For static libraries, I assume the PrivateKeyAndCertificateMatch function is being excluded by the linker because it isn't being used - the DLL can't do that because as a runtime artifact the linker can't know whether or not the function will be used, so has to include it.I believe that it should be possible to get round this by moving the PrivateKeyAndCertificateMatch function (and maybe a few others) into a separate compilation unit that isn't included in the xx_unsecure libraries.I can do that now, or in a follow up PR.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34277,1318940401,2023-09-07T17:48:29Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -99,12 +102,16 @@ class OverrideHostTest : public XdsEnd2endTest {   // Builds a Listener with Fault Injection filter config. If the http_fault   // is nullptr, then assign an empty filter config. This filter config is   // required to enable the fault injection features.-  Listener BuildListenerWithStatefulSessionFilter() {-    CookieBasedSessionState cookie_state;-    cookie_state.mutable_cookie()->set_name(std::string(kCookieName));+  Listener BuildListenerWithStatefulSessionFilter(+      absl::string_view cookieName = kCookieName) {","The parameter should be called `cookie_name`, as per the style guide.",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34180,1319095107,2023-09-07T20:35:56Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -119,6 +149,42 @@ void grpc_ssl_credentials::set_max_tls_version(   config_.max_tls_version = max_tls_version; } +grpc_security_status grpc_ssl_credentials::initialize_client_handshaker_factory(+    const grpc_ssl_config* config, const char* pem_root_certs,+    const tsi_ssl_root_certs_store* root_store,+    tsi_ssl_session_cache* session_cache) {+  if (client_handshaker_factory_ != nullptr) {","I don't think the current strategy works because of the following example:* User creates SSL credentials object and holds on to it for the lifetime of their application.* User uses the SSL credentials object to create channel 1 without any session cache in the channel args.* User uses the SSL credentials object to create channel 2 with a session cache in the channel args.The user expects that both TLS handshakes are full handshakes, and the cache is populated with a session ticket after the creation of channel 2. However, this will not happen with the current strategy because the handshaker factory is created when we create channel 1 (when there is no session cache), and it is reused when we create channel 2.To get around examples like this, I'm proposing we slightly tweak the logic as follows:1. In the `grpc_ssl_credentials` constructor, call `initialize_client_handshaker_factory` with no session cache and store the resulting client handshaker factory as a member field of the `grpc_ssl_credentials` class.2. In the `grpc_ssl_credentials::create_security_connector` method, try to read the session cache from the channel args, as you're doing now. If the session cache is nullptr, then using the client handshaker factory that is stored as a member field; otherwise, call `initialize_client_handshaker_factory` to build a new client handshaker factory (with the non-null session cache) and we will only use this client handshaker factory for this subchannel.WDYT?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34273,1319202036,2023-09-07T23:19:30Z,src/cpp/ext/otel/otel_plugin.h,"@@ -132,6 +133,12 @@ class OpenTelemetryPluginBuilder {   OpenTelemetryPluginBuilder& SetLabelsInjector(       std::unique_ptr<LabelsInjector> labels_injector); +  // If set, \a channel_selector is called once per channel to decide whether to+  // collect metrics on the channel or not.+  OpenTelemetryPluginBuilder& SetChannelSelector(","Given our discussion about eventually wanting to separate the target and channel scopes, it seems like this is actually the target-level scope selector, not the channel-level scope selector.  We may eventually want a channel-level selector that takes channel args as input.  I don't want to actually add that right now, but let's leave ourselves room to do that -- can we rename this to `SetTargetSelector()`?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34277,1319205005,2023-09-07T23:26:41Z,test/cpp/end2end/xds/xds_override_host_end2end_test.cc,"@@ -440,6 +449,36 @@ TEST_P(OverrideHostTest, ClusterGoneHostStays) {       GetAffinityCookieHeaderForBackend(DEBUG_LOCATION, 1, kNumEchoRpcs / 3)); } +TEST_P(OverrideHostTest, DisabledPerPath) {+  const std::string kCustomCookieName = ""GSSA"";","As far as I can tell, the cookie name has absolutely no bearing on the bug we're fixing here, so I don't see why it's useful to add all of this additional plumbing for it in the test.  I won't insist on removing it, but IMHO this extra complexity does nothing except distract the reader from what's actually important here.",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34180,1320209447,2023-09-08T18:30:08Z,src/core/lib/security/credentials/ssl/ssl_credentials.h,"@@ -70,6 +70,11 @@ class grpc_ssl_credentials : public grpc_channel_credentials {                     const grpc_ssl_verify_peer_options* verify_options);    grpc_ssl_config config_;+  grpc_security_status initialize_client_handshaker_factory(","Correct, let's change the naming to `InitializeClientHandshakerFactory`. :)",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1320218896,2023-09-08T18:40:48Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -66,12 +68,61 @@ grpc_ssl_credentials::create_security_connector(   absl::optional<std::string> overridden_target_name =       args->GetOwnedString(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG);   auto* ssl_session_cache = args->GetObject<tsi::SslSessionLRUCache>();-  grpc_core::RefCountedPtr<grpc_channel_security_connector> sc =-      grpc_ssl_channel_security_connector_create(-          this->Ref(), std::move(call_creds), &config_, target,-          overridden_target_name.has_value() ? overridden_target_name->c_str()-                                             : nullptr,-          ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr());+  tsi_ssl_session_cache* tsi_ssl_session_cache =+      ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr();++  const tsi_ssl_root_certs_store* root_store;+  // Use default (e.g. OS) root certificates if the user did not pass any root+  // certificates.+  if (config_.pem_root_certs == nullptr) {+    const char* pem_root_certs =+        grpc_core::DefaultSslRootStore::GetPemRootCerts();+    if (pem_root_certs == nullptr) {+      gpr_log(GPR_ERROR, ""Could not get default pem root certs."");+      return nullptr;+    }+    size_t root_len = strlen(pem_root_certs);+    char* default_roots = strcpy(new char[root_len + 1], pem_root_certs);+    config_.pem_root_certs = default_roots;+    root_store = grpc_core::DefaultSslRootStore::GetRootStore();+  } else {+    config_.pem_root_certs = config_.pem_root_certs;+    root_store = nullptr;+  }++  grpc_core::RefCountedPtr<grpc_channel_security_connector> sc = nullptr;+  // We need a separate factory and ctx if there's a cache in the channel+  // args+  if (tsi_ssl_session_cache != nullptr) {+    // Get a different client handshaker factory and give to it the security+    // connector+    tsi_ssl_client_handshaker_factory* factory_with_cache = nullptr;+    grpc_security_status status = initialize_client_handshaker_factory(+        &config_, config_.pem_root_certs, root_store, tsi_ssl_session_cache,+        &factory_with_cache);+    if (status != GRPC_SECURITY_OK) {+      return nullptr;+    }+    sc = grpc_ssl_channel_security_connector_create(+        this->Ref(), std::move(call_creds), &config_, target,+        overridden_target_name.has_value() ? overridden_target_name->c_str()+                                           : nullptr,+        factory_with_cache);+    tsi_ssl_client_handshaker_factory_unref(factory_with_cache);+  } else {+    grpc_security_status status = initialize_client_handshaker_factory(","I think we still get the efficiency gain because `initialize_client_handshaker_factory` just returns the class `client_handshaker_factory_` if it already exists, so the credentials really just initiate it once the first time this is called.Doing it in the constructor, storing the status, then checking the status at this location would just move the heavy lifting to construction time of the credentials from the initial establishing of the connection - all of this happens before the first connection regardless, so I don't think shifting it necessarily gets any notable gain, just displaces it.WDYT?",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34180,1320227567,2023-09-08T18:50:47Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -66,12 +68,61 @@ grpc_ssl_credentials::create_security_connector(   absl::optional<std::string> overridden_target_name =       args->GetOwnedString(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG);   auto* ssl_session_cache = args->GetObject<tsi::SslSessionLRUCache>();-  grpc_core::RefCountedPtr<grpc_channel_security_connector> sc =-      grpc_ssl_channel_security_connector_create(-          this->Ref(), std::move(call_creds), &config_, target,-          overridden_target_name.has_value() ? overridden_target_name->c_str()-                                             : nullptr,-          ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr());+  tsi_ssl_session_cache* tsi_ssl_session_cache =+      ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr();++  const tsi_ssl_root_certs_store* root_store;+  // Use default (e.g. OS) root certificates if the user did not pass any root+  // certificates.+  if (config_.pem_root_certs == nullptr) {+    const char* pem_root_certs =+        grpc_core::DefaultSslRootStore::GetPemRootCerts();+    if (pem_root_certs == nullptr) {+      gpr_log(GPR_ERROR, ""Could not get default pem root certs."");+      return nullptr;+    }+    size_t root_len = strlen(pem_root_certs);+    char* default_roots = strcpy(new char[root_len + 1], pem_root_certs);+    config_.pem_root_certs = default_roots;+    root_store = grpc_core::DefaultSslRootStore::GetRootStore();+  } else {+    config_.pem_root_certs = config_.pem_root_certs;+    root_store = nullptr;+  }++  grpc_core::RefCountedPtr<grpc_channel_security_connector> sc = nullptr;+  // We need a separate factory and ctx if there's a cache in the channel+  // args+  if (tsi_ssl_session_cache != nullptr) {+    // Get a different client handshaker factory and give to it the security+    // connector+    tsi_ssl_client_handshaker_factory* factory_with_cache = nullptr;+    grpc_security_status status = initialize_client_handshaker_factory(+        &config_, config_.pem_root_certs, root_store, tsi_ssl_session_cache,+        &factory_with_cache);+    if (status != GRPC_SECURITY_OK) {+      return nullptr;+    }+    sc = grpc_ssl_channel_security_connector_create(+        this->Ref(), std::move(call_creds), &config_, target,+        overridden_target_name.has_value() ? overridden_target_name->c_str()+                                           : nullptr,+        factory_with_cache);+    tsi_ssl_client_handshaker_factory_unref(factory_with_cache);+  } else {+    grpc_security_status status = initialize_client_handshaker_factory(","We will get some efficiency gain, but the current code is not thread-safe: if you make multiple concurrent calls to `create_security_connector`, then there will be race conditions over populating the handshaker factory. To make it thread-safe, we would need to add a lock to guard the code block that populates and fetches the handshaker factory. However, I strongly suspect that contention over this lock would eat away at most of the performance gains that we want (at in the use cases where you're continuously creating a large volume of connections).If we move everything to the constructor, then the cached handshaker factory is constant throughout the lifetime of the `grpc_ssl_credentials` object, and we avoid the lock contention issue.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1320239804,2023-09-08T19:05:23Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -66,12 +68,61 @@ grpc_ssl_credentials::create_security_connector(   absl::optional<std::string> overridden_target_name =       args->GetOwnedString(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG);   auto* ssl_session_cache = args->GetObject<tsi::SslSessionLRUCache>();-  grpc_core::RefCountedPtr<grpc_channel_security_connector> sc =-      grpc_ssl_channel_security_connector_create(-          this->Ref(), std::move(call_creds), &config_, target,-          overridden_target_name.has_value() ? overridden_target_name->c_str()-                                             : nullptr,-          ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr());+  tsi_ssl_session_cache* tsi_ssl_session_cache =+      ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr();++  const tsi_ssl_root_certs_store* root_store;+  // Use default (e.g. OS) root certificates if the user did not pass any root+  // certificates.+  if (config_.pem_root_certs == nullptr) {+    const char* pem_root_certs =+        grpc_core::DefaultSslRootStore::GetPemRootCerts();+    if (pem_root_certs == nullptr) {+      gpr_log(GPR_ERROR, ""Could not get default pem root certs."");+      return nullptr;+    }+    size_t root_len = strlen(pem_root_certs);+    char* default_roots = strcpy(new char[root_len + 1], pem_root_certs);+    config_.pem_root_certs = default_roots;+    root_store = grpc_core::DefaultSslRootStore::GetRootStore();+  } else {+    config_.pem_root_certs = config_.pem_root_certs;+    root_store = nullptr;+  }++  grpc_core::RefCountedPtr<grpc_channel_security_connector> sc = nullptr;+  // We need a separate factory and ctx if there's a cache in the channel+  // args+  if (tsi_ssl_session_cache != nullptr) {+    // Get a different client handshaker factory and give to it the security+    // connector+    tsi_ssl_client_handshaker_factory* factory_with_cache = nullptr;+    grpc_security_status status = initialize_client_handshaker_factory(+        &config_, config_.pem_root_certs, root_store, tsi_ssl_session_cache,+        &factory_with_cache);+    if (status != GRPC_SECURITY_OK) {+      return nullptr;+    }+    sc = grpc_ssl_channel_security_connector_create(+        this->Ref(), std::move(call_creds), &config_, target,+        overridden_target_name.has_value() ? overridden_target_name->c_str()+                                           : nullptr,+        factory_with_cache);+    tsi_ssl_client_handshaker_factory_unref(factory_with_cache);+  } else {+    grpc_security_status status = initialize_client_handshaker_factory(","That makes sense, good pointIn the case that the status is bad, I think it's still totally _safe_ to wait and report it here, so we can just have the exact same check with the stored statusWill make the change",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1320287990,2023-09-08T19:55:41Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -66,12 +68,61 @@ grpc_ssl_credentials::create_security_connector(   absl::optional<std::string> overridden_target_name =       args->GetOwnedString(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG);   auto* ssl_session_cache = args->GetObject<tsi::SslSessionLRUCache>();-  grpc_core::RefCountedPtr<grpc_channel_security_connector> sc =-      grpc_ssl_channel_security_connector_create(-          this->Ref(), std::move(call_creds), &config_, target,-          overridden_target_name.has_value() ? overridden_target_name->c_str()-                                             : nullptr,-          ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr());+  tsi_ssl_session_cache* tsi_ssl_session_cache =+      ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr();++  const tsi_ssl_root_certs_store* root_store;","Other than wanting to be able to return out, which we can still do if `pem_root_certs == nullptr`Will move to constructor",
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/34290,1320322626,2023-09-08T20:39:42Z,WORKSPACE,"@@ -102,6 +102,14 @@ load(""@com_github_google_benchmark//:bazel/benchmark_deps.bzl"", ""benchmark_deps""  benchmark_deps() +load(""@io_opentelemetry_cpp//bazel:repository.bzl"", ""opentelemetry_cpp_deps"")","hm, we tried that but it gives a cyclic dependency error.",X
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/34290,1320338054,2023-09-08T21:00:57Z,WORKSPACE,"@@ -102,6 +102,14 @@ load(""@com_github_google_benchmark//:bazel/benchmark_deps.bzl"", ""benchmark_deps""  benchmark_deps() +load(""@io_opentelemetry_cpp//bazel:repository.bzl"", ""opentelemetry_cpp_deps"")",I think that's because the opentelemetry repo calls `grpc_extra_deps()` - https://github.com/open-telemetry/opentelemetry-cpp/blob/main/WORKSPACE#L15,
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34293,1320971536,2023-09-11T04:06:09Z,test/core/end2end/h2_ssl_session_reuse_test.cc,"@@ -263,9 +243,93 @@ TEST(H2SessionReuseTest, SingleReuse) {    grpc_server* server = server_create(cq, server_addr.c_str()); -  do_round_trip(cq, server, server_addr.c_str(), cache, false);-  do_round_trip(cq, server, server_addr.c_str(), cache, true);-  do_round_trip(cq, server, server_addr.c_str(), cache, true);+  // create client creds+  grpc_slice ca_slice, cert_slice, key_slice;+  GPR_ASSERT(GRPC_LOG_IF_ERROR(""load_file"",+                               grpc_load_file(CA_CERT_PATH, 1, &ca_slice)));+  GPR_ASSERT(GRPC_LOG_IF_ERROR(+      ""load_file"", grpc_load_file(CLIENT_CERT_PATH, 1, &cert_slice)));+  GPR_ASSERT(GRPC_LOG_IF_ERROR(""load_file"",+                               grpc_load_file(CLIENT_KEY_PATH, 1, &key_slice)));+  const char* ca_cert =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(ca_slice);+  const char* client_cert =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(cert_slice);+  const char* client_key =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(key_slice);+  grpc_ssl_pem_key_cert_pair signed_client_key_cert_pair = {client_key,+                                                            client_cert};+  grpc_channel_credentials* client_creds = grpc_ssl_credentials_create(",Is it possible to move the creation of the `grpc_channel_credentials` to a helper function so we don't have to duplicate the code?,X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34293,1320972715,2023-09-11T04:09:25Z,test/core/end2end/h2_ssl_session_reuse_test.cc,"@@ -263,9 +243,93 @@ TEST(H2SessionReuseTest, SingleReuse) {    grpc_server* server = server_create(cq, server_addr.c_str()); -  do_round_trip(cq, server, server_addr.c_str(), cache, false);-  do_round_trip(cq, server, server_addr.c_str(), cache, true);-  do_round_trip(cq, server, server_addr.c_str(), cache, true);+  // create client creds+  grpc_slice ca_slice, cert_slice, key_slice;+  GPR_ASSERT(GRPC_LOG_IF_ERROR(""load_file"",+                               grpc_load_file(CA_CERT_PATH, 1, &ca_slice)));+  GPR_ASSERT(GRPC_LOG_IF_ERROR(+      ""load_file"", grpc_load_file(CLIENT_CERT_PATH, 1, &cert_slice)));+  GPR_ASSERT(GRPC_LOG_IF_ERROR(""load_file"",+                               grpc_load_file(CLIENT_KEY_PATH, 1, &key_slice)));+  const char* ca_cert =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(ca_slice);+  const char* client_cert =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(cert_slice);+  const char* client_key =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(key_slice);+  grpc_ssl_pem_key_cert_pair signed_client_key_cert_pair = {client_key,+                                                            client_cert};+  grpc_channel_credentials* client_creds = grpc_ssl_credentials_create(+      ca_cert, &signed_client_key_cert_pair, nullptr, nullptr);++  do_round_trip(cq, server, server_addr.c_str(), cache, client_creds, false);+  do_round_trip(cq, server, server_addr.c_str(), cache, client_creds, true);+  do_round_trip(cq, server, server_addr.c_str(), cache, client_creds, true);++  grpc_ssl_session_cache_destroy(cache);++  GPR_ASSERT(grpc_completion_queue_next(+                 cq, grpc_timeout_milliseconds_to_deadline(100), nullptr)+                 .type == GRPC_QUEUE_TIMEOUT);++  grpc_server_shutdown_and_notify(server, cq, grpc_core::CqVerifier::tag(1000));+  grpc_event ev;+  do {+    ev = grpc_completion_queue_next(cq, grpc_timeout_seconds_to_deadline(5),+                                    nullptr);+  } while (ev.type != GRPC_OP_COMPLETE ||+           ev.tag != grpc_core::CqVerifier::tag(1000));+  grpc_server_destroy(server);+  grpc_channel_credentials_release(client_creds);+  grpc_slice_unref(cert_slice);+  grpc_slice_unref(key_slice);+  grpc_slice_unref(ca_slice);++  grpc_completion_queue_shutdown(cq);+  drain_cq(cq);+  grpc_completion_queue_destroy(cq);+}++TEST(H2SessionReuseTest, ConcurrentReuse) {+  int port = grpc_pick_unused_port_or_die();++  std::string server_addr = grpc_core::JoinHostPort(""localhost"", port);++  grpc_completion_queue* cq = grpc_completion_queue_create_for_next(nullptr);+  grpc_ssl_session_cache* cache = grpc_ssl_session_cache_create_lru(16);++  grpc_server* server = server_create(cq, server_addr.c_str());++  // create client creds+  grpc_slice ca_slice, cert_slice, key_slice;+  GPR_ASSERT(GRPC_LOG_IF_ERROR(""load_file"",+                               grpc_load_file(CA_CERT_PATH, 1, &ca_slice)));+  GPR_ASSERT(GRPC_LOG_IF_ERROR(+      ""load_file"", grpc_load_file(CLIENT_CERT_PATH, 1, &cert_slice)));+  GPR_ASSERT(GRPC_LOG_IF_ERROR(""load_file"",+                               grpc_load_file(CLIENT_KEY_PATH, 1, &key_slice)));+  const char* ca_cert =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(ca_slice);+  const char* client_cert =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(cert_slice);+  const char* client_key =+      reinterpret_cast<const char*> GRPC_SLICE_START_PTR(key_slice);+  grpc_ssl_pem_key_cert_pair signed_client_key_cert_pair = {client_key,+                                                            client_cert};+  grpc_channel_credentials* client_creds = grpc_ssl_credentials_create(+      ca_cert, &signed_client_key_cert_pair, nullptr, nullptr);++  do_round_trip(cq, server, server_addr.c_str(), cache, client_creds, false);+  grpc_completion_queue* cq2 = grpc_completion_queue_create_for_next(nullptr);++  std::thread* t1 = new std::thread([&]() -> void {","nit: Please use full names for variables, so e.g. replace `t1` with `thread_1` and similarly below.",
2793282,veblush,https://api.github.com/repos/grpc/grpc/pulls/34290,1322091775,2023-09-11T21:28:23Z,WORKSPACE,"@@ -102,6 +102,14 @@ load(""@com_github_google_benchmark//:bazel/benchmark_deps.bzl"", ""benchmark_deps""  benchmark_deps() +load(""@io_opentelemetry_cpp//bazel:repository.bzl"", ""opentelemetry_cpp_deps"")","Not sure whether opentelemetry `WORKSPACE` file is evaluated when building gRPC targets from gRPC workspace. As long as application developer can use gRPC OpenTelemetry targets without calling additional functions other than grpc_deps` and `grpc_extra_deps`, this might be fine.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34311,1323689492,2023-09-12T22:55:52Z,src/cpp/ext/csm/csm_observability.cc,"@@ -71,8 +75,27 @@ CsmObservabilityBuilder& CsmObservabilityBuilder::SetTargetAttributeFilter(  absl::StatusOr<CsmObservability> CsmObservabilityBuilder::BuildAndRegister() {   builder_.BuildAndRegisterGlobal();+  builder_.SetTargetSelector(CsmChannelTargetSelector);   return CsmObservability(); } +bool CsmChannelTargetSelector(absl::string_view target) {+  auto uri = grpc_core::URI::Parse(target);","Note that we support a [default prefix mechanism](https://github.com/grpc/grpc/blob/ce8838f05cb8d0374aba9edd06c7d38b0d5453a6/src/core/lib/resolver/resolver_registry.cc#L130), which means that the target specified by the application when they create a channel may not actually parse as a URI.  By default, [the default prefix is `dns:///`](https://github.com/grpc/grpc/blob/ce8838f05cb8d0374aba9edd06c7d38b0d5453a6/src/core/lib/resolver/resolver_registry.cc#L68), which means that users can just create a channel for `server.example.com:80`, and we'll treat that as `dns:///server.example.com:80`, even though the original string doesn't parse as a URI.Is the string that we pass to this function the original target string used by the application, or is it already canonicalized to be a URI?  If it's the original string, then it may not parse as a URI.In theory, there could be a case where the default prefix is set to `xds:`, in which case the URI could fail to parse here even if it is actually a CSM channel.  But there's no public API for setting the default prefix, so I don't think we really need to worry about this.That having been said, if we are passing in the original target string that may not parse as a URI, then I think we should not emit the error log on line 85, because that will happen on a fairly routine basis with people omitting the `dns:///` prefix.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34312,1323703221,2023-09-12T23:09:07Z,src/cpp/ext/csm/csm_observability.cc,"@@ -70,6 +73,11 @@ CsmObservabilityBuilder& CsmObservabilityBuilder::SetTargetAttributeFilter( }  absl::StatusOr<CsmObservability> CsmObservabilityBuilder::BuildAndRegister() {+  builder_.SetServerSelector([](const grpc_core::ChannelArgs& args) {+    // Directly using the channel arg string to avoid a dependency on xDS.","I'd prefer not to duplicate the string in two places, since it's possible that they could get out of sync.I don't think we need a full xDS dependency to avoid this.  We can create a standalone header file that defines this channel arg key, and we can depend on that header in both the xDS code and here.",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34293,1323830570,2023-09-13T01:46:29Z,test/cpp/end2end/concurrent_resumption_test.cc,"@@ -0,0 +1,143 @@+#include <memory>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include <grpcpp/channel.h>+#include <grpcpp/client_context.h>+#include <grpcpp/create_channel.h>+// #include <grpcpp/security/audit_logging.h>+// #include <grpcpp/security/authorization_policy_provider.h>+#include <grpcpp/server.h>+#include <grpcpp/server_builder.h>++#include ""src/core/lib/iomgr/load_file.h""+// #include ""src/core/lib/security/authorization/audit_logging.h""+// #include+// ""src/core/lib/security/authorization/grpc_authorization_policy_provider.h""+// #include ""src/core/lib/security/credentials/fake/fake_credentials.h""+// #include ""src/cpp/client/secure_credentials.h""+// #include ""src/cpp/server/secure_server_credentials.h""+// #include ""src/proto/grpc/testing/echo.grpc.pb.h""+// #include ""test/core/util/audit_logging_utils.h""+#include ""src/proto/grpc/testing/echo.grpc.pb.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""+#include ""test/cpp/end2end/test_service_impl.h""++namespace grpc {+namespace testing {+namespace {++constexpr char kCaCertPath[] = ""src/core/tsi/test_creds/ca.pem"";+constexpr char kServerCertPath[] = ""src/core/tsi/test_creds/server1.pem"";+constexpr char kServerKeyPath[] = ""src/core/tsi/test_creds/server1.key"";+constexpr char kClientCertPath[] = ""src/core/tsi/test_creds/client.pem"";+constexpr char kClientKeyPath[] = ""src/core/tsi/test_creds/client.key"";+constexpr char kMessage[] = ""Hello"";++std::string ReadFile(const char* file_path) {+  grpc_slice slice;+  GPR_ASSERT(+      GRPC_LOG_IF_ERROR(""load_file"", grpc_load_file(file_path, 0, &slice)));+  std::string file_contents(grpc_core::StringViewFromSlice(slice));+  grpc_slice_unref(slice);+  return file_contents;+}++class GrpcResumptionTest : public ::testing::Test {+ protected:+  void RunServer() {+    std::string root_cert = ReadFile(kCaCertPath);+    grpc::SslServerCredentialsOptions::PemKeyCertPair key_cert_pair = {+        ReadFile(kServerKeyPath), ReadFile(kServerCertPath)};+    grpc::SslServerCredentialsOptions sslOpts;+    sslOpts.pem_key_cert_pairs.push_back(key_cert_pair);+    sslOpts.pem_root_certs = root_cert;+    sslOpts.force_client_auth = true;++    grpc::ServerBuilder builder;+    TestServiceImpl service_;++    builder.AddListeningPort(server_addr_, grpc::SslServerCredentials(sslOpts));+    builder.RegisterService(""foo.test.google.fr"", &service_);+    server_ = builder.BuildAndStart();+    std::cout << ""GREG: server waiting on "" << server_addr_ << ""\n"";+    server_->Wait();+  }++  //   void TearDown() override {+  //     if (server_ != nullptr) {+  //       server_->Shutdown();+  //       server_thread_->join();+  //     }+  //     server_thread_ = nullptr;+  //   }++  TestServiceImpl service_;+  std::unique_ptr<Server> server_;+  std::thread* server_thread_;+  std::string server_addr_;+};++TEST_F(GrpcResumptionTest, ConcurrentResumption) {+  int port = grpc_pick_unused_port_or_die();","Optional: You can make this more concise by rewriting these 4 lines as:```server_addr_ = absl::StrCat(""localhost:"", std::to_string(grpc_pick_unused_port_or_die()));```",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34293,1324770054,2023-09-13T16:22:28Z,test/cpp/end2end/concurrent_resumption_test.cc,"@@ -0,0 +1,143 @@+#include <memory>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include <grpcpp/channel.h>+#include <grpcpp/client_context.h>+#include <grpcpp/create_channel.h>+// #include <grpcpp/security/audit_logging.h>+// #include <grpcpp/security/authorization_policy_provider.h>+#include <grpcpp/server.h>+#include <grpcpp/server_builder.h>++#include ""src/core/lib/iomgr/load_file.h""+// #include ""src/core/lib/security/authorization/audit_logging.h""+// #include+// ""src/core/lib/security/authorization/grpc_authorization_policy_provider.h""+// #include ""src/core/lib/security/credentials/fake/fake_credentials.h""+// #include ""src/cpp/client/secure_credentials.h""+// #include ""src/cpp/server/secure_server_credentials.h""+// #include ""src/proto/grpc/testing/echo.grpc.pb.h""+// #include ""test/core/util/audit_logging_utils.h""+#include ""src/proto/grpc/testing/echo.grpc.pb.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""+#include ""test/cpp/end2end/test_service_impl.h""++namespace grpc {+namespace testing {+namespace {++constexpr char kCaCertPath[] = ""src/core/tsi/test_creds/ca.pem"";+constexpr char kServerCertPath[] = ""src/core/tsi/test_creds/server1.pem"";+constexpr char kServerKeyPath[] = ""src/core/tsi/test_creds/server1.key"";+constexpr char kClientCertPath[] = ""src/core/tsi/test_creds/client.pem"";+constexpr char kClientKeyPath[] = ""src/core/tsi/test_creds/client.key"";+constexpr char kMessage[] = ""Hello"";++std::string ReadFile(const char* file_path) {+  grpc_slice slice;+  GPR_ASSERT(+      GRPC_LOG_IF_ERROR(""load_file"", grpc_load_file(file_path, 0, &slice)));+  std::string file_contents(grpc_core::StringViewFromSlice(slice));+  grpc_slice_unref(slice);+  return file_contents;+}++class GrpcResumptionTest : public ::testing::Test {+ protected:+  void RunServer() {+    std::string root_cert = ReadFile(kCaCertPath);+    grpc::SslServerCredentialsOptions::PemKeyCertPair key_cert_pair = {+        ReadFile(kServerKeyPath), ReadFile(kServerCertPath)};+    grpc::SslServerCredentialsOptions sslOpts;+    sslOpts.pem_key_cert_pairs.push_back(key_cert_pair);+    sslOpts.pem_root_certs = root_cert;+    sslOpts.force_client_auth = true;++    grpc::ServerBuilder builder;+    TestServiceImpl service_;++    builder.AddListeningPort(server_addr_, grpc::SslServerCredentials(sslOpts));+    builder.RegisterService(""foo.test.google.fr"", &service_);+    server_ = builder.BuildAndStart();+    std::cout << ""GREG: server waiting on "" << server_addr_ << ""\n"";+    server_->Wait();+  }++  //   void TearDown() override {+  //     if (server_ != nullptr) {+  //       server_->Shutdown();+  //       server_thread_->join();+  //     }+  //     server_thread_ = nullptr;+  //   }++  TestServiceImpl service_;+  std::unique_ptr<Server> server_;+  std::thread* server_thread_;+  std::string server_addr_;+};++TEST_F(GrpcResumptionTest, ConcurrentResumption) {+  int port = grpc_pick_unused_port_or_die();+  std::ostringstream addr;+  addr << ""localhost:"" << port;+  server_addr_ = addr.str();+  std::cout << ""GREG: Serving on "" << server_addr_ << ""\n"";+  server_thread_ = new std::thread([&]() { RunServer(); });","Will definitely add that, the `sleep(1)` was my temporary solution while working on figuring on why the test wasn't working",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/34293,1324841136,2023-09-13T17:22:46Z,test/cpp/end2end/ssl_credentials_test.cc,"@@ -0,0 +1,144 @@+#include <memory>++#include <gmock/gmock.h>+#include <gtest/gtest.h>++#include ""absl/synchronization/notification.h""++#include <grpc/grpc_security.h>+#include <grpcpp/channel.h>+#include <grpcpp/client_context.h>+#include <grpcpp/create_channel.h>+#include <grpcpp/server.h>+#include <grpcpp/server_builder.h>++#include ""src/core/lib/iomgr/load_file.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""+#include ""test/cpp/end2end/test_service_impl.h""++namespace grpc {+namespace testing {+namespace {++constexpr char kCaCertPath[] = ""src/core/tsi/test_creds/ca.pem"";+constexpr char kServerCertPath[] = ""src/core/tsi/test_creds/server1.pem"";+constexpr char kServerKeyPath[] = ""src/core/tsi/test_creds/server1.key"";+constexpr char kClientCertPath[] = ""src/core/tsi/test_creds/client.pem"";+constexpr char kClientKeyPath[] = ""src/core/tsi/test_creds/client.key"";+constexpr char kMessage[] = ""Hello"";++std::string ReadFile(const char* file_path) {",micro-nit: Can we use `const std::string& file_path` for the parameter instead?We can then pass `file_path.c_str()` to the `grpc_load_file` API.,X
57042389,tonydnewell,https://api.github.com/repos/grpc/grpc/pulls/33878,1325768881,2023-09-14T10:50:57Z,src/compiler/csharp_plugin.cc,"@@ -62,14 +63,17 @@ class CSharpGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator {         // The option may be removed or file names generated may change         // in the future.         base_namespace = options[i].second;+      } else if (options[i].first == ""enable_nrt"") {",There was a discussion here about the naming on the option in protoc: https://github.com/protocolbuffers/protobuf/pull/13218#discussion_r1276246494,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34274,1326208592,2023-09-14T16:16:36Z,src/core/ext/filters/client_channel/lb_policy/health_check_client_internal.h,"@@ -125,7 +126,8 @@ class HealthProducer : public Subchannel::DataProducerInterface {     WeakRefCountedPtr<HealthProducer> producer_;     absl::string_view health_check_service_name_;     std::shared_ptr<WorkSerializer> work_serializer_ =-        std::make_shared<WorkSerializer>();+        std::make_shared<WorkSerializer>(+            grpc_event_engine::experimental::GetDefaultEventEngine());","Instead of hard-coding the use of the default EE here, let's use [the one from the subchannel](https://github.com/grpc/grpc/blob/1986007e1ee735ec3f977f31cc8569c5ad954c7e/src/core/ext/filters/client_channel/subchannel.h#L378).  We can add a method on `Subchannel` to expose it, and then call it here as `producer_->subchannel_->event_engine()`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34274,1326221449,2023-09-14T16:24:32Z,src/core/lib/experiments/experiments.yaml,"@@ -185,3 +195,10 @@   owner: ctiller@google.com   test_tags: []   allow_in_fuzzing_config: true+- name: round_robin_delegate_to_pick_first",Looks like a bad merge?  I don't think this should be added in this PR.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34274,1326222266,2023-09-14T16:25:03Z,src/core/lib/experiments/rollouts.yaml,"@@ -94,3 +96,5 @@   default: true - name: jitter_max_idle   default: true+- name: round_robin_delegate_to_pick_first",Also from a bad merge?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34274,1326255951,2023-09-14T16:48:08Z,src/core/lib/gprpp/work_serializer.cc,"@@ -253,14 +284,231 @@ void WorkSerializer::WorkSerializerImpl::DrainQueueOwned() {   } } +//+// WorkSerializer::DispatchingWorkSerializer+//++// DispatchingWorkSerializer: executes callbacks one at a time on EventEngine.+// One at a time guarantees that fixed size thread pools in EventEngine+// implementations are not starved of threads by long running work serializers.+// We implement EventEngine::Closure directly to avoid allocating once per+// callback in the queue when scheduling.+class WorkSerializer::DispatchingWorkSerializer final+    : public WorkSerializerImpl,+      private grpc_event_engine::experimental::EventEngine::Closure {","Please [don't use private inheritance](https://google.github.io/styleguide/cppguide.html#Inheritance).  In this case, I think we can have a data member of this type instead, which will slightly increase the memory usage per `WorkSerializer` but will not require allocating per callback in the queue.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34274,1326357751,2023-09-14T18:18:29Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -37,10 +35,10 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  protected:-  RoundRobinTest() : lb_policy_(MakeLbPolicy(""round_robin"")) {}+  RoundRobinTest() : LoadBalancingPolicyTest(""round_robin"") {}    void ExpectStartup(absl::Span<const absl::string_view> addresses) {","This function is no longer needed.  I thought I removed it in one of my commits, but maybe that got lost in a merge somewhere.",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1326359096,2023-09-14T18:19:46Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -57,26 +79,62 @@ grpc_ssl_credentials::~grpc_ssl_credentials() {     config_.verify_options.verify_peer_destruct(         config_.verify_options.verify_peer_callback_userdata);   }+  tsi_ssl_client_handshaker_factory_unref(client_handshaker_factory_); }  grpc_core::RefCountedPtr<grpc_channel_security_connector> grpc_ssl_credentials::create_security_connector(     grpc_core::RefCountedPtr<grpc_call_credentials> call_creds,     const char* target, grpc_core::ChannelArgs* args) {+  if (config_.pem_root_certs == nullptr) {+    gpr_log(GPR_ERROR, ""Could not get default pem root certs."");+    return nullptr;+  }   absl::optional<std::string> overridden_target_name =       args->GetOwnedString(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG);   auto* ssl_session_cache = args->GetObject<tsi::SslSessionLRUCache>();-  grpc_core::RefCountedPtr<grpc_channel_security_connector> sc =-      grpc_ssl_channel_security_connector_create(-          this->Ref(), std::move(call_creds), &config_, target,-          overridden_target_name.has_value() ? overridden_target_name->c_str()-                                             : nullptr,-          ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr());-  if (sc == nullptr) {-    return sc;+  tsi_ssl_session_cache* session_cache =+      ssl_session_cache == nullptr ? nullptr : ssl_session_cache->c_ptr();++  grpc_core::RefCountedPtr<grpc_channel_security_connector> security_connector =+      nullptr;+  if (session_cache != nullptr) {+    // We need a separate factory and ctx if there's a cache in the channel+    // args. SSL_CTX should live with the factory and that should live on the+    // credentials. However, there is a way to configure a session cache in the+    // channel args, so that prevents us from also keeping the session cache at+    // the credentials level. In the case of a session cache, we still need to+    // keep a separate factory and SSL_CTX at the subchannel/security_connector+    // level.+    tsi_ssl_client_handshaker_factory* factory_with_cache = nullptr;+    grpc_security_status status = InitializeClientHandshakerFactory(+        &config_, config_.pem_root_certs, root_store_, session_cache,+        &factory_with_cache);+    if (status != GRPC_SECURITY_OK) {+      return nullptr;",I think the only two statuses here are `GRPC_SECURITY_OK` and `GRPC_SECURITY_ERROR`Adding a log to indicate `InitializeClientHandshakerFactory` returned a bad status,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1326360880,2023-09-14T18:21:43Z,src/core/lib/security/credentials/ssl/ssl_credentials.cc,"@@ -119,6 +177,45 @@ void grpc_ssl_credentials::set_max_tls_version(   config_.max_tls_version = max_tls_version; } +grpc_security_status grpc_ssl_credentials::InitializeClientHandshakerFactory(+    const grpc_ssl_config* config, const char* pem_root_certs,+    const tsi_ssl_root_certs_store* root_store,+    tsi_ssl_session_cache* ssl_session_cache,+    tsi_ssl_client_handshaker_factory** handshaker_factory) {+  // This class level factory can't have a session cache by design. If we want","I don't think so - this is the bifurcation. The class level factory can't have a session cache, so if the `ssl_session_cache != nullptr` then we need to make a separate factory with a separate CTX that is not associated with the credentials class.But in the case that there is _not_ a session cache, we do want to use a factory on the class instance that is only initialized once.",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1326364134,2023-09-14T18:25:03Z,src/core/lib/security/credentials/ssl/ssl_credentials.h,"@@ -69,7 +69,16 @@ class grpc_ssl_credentials : public grpc_channel_credentials {                     grpc_ssl_pem_key_cert_pair* pem_key_cert_pair,                     const grpc_ssl_verify_peer_options* verify_options); +  grpc_security_status InitializeClientHandshakerFactory(",See the thread above this - this initializes the `client_handshaker_factory_` on this class instance of credentials. But if there's a session cache we use it to make a new factory.I don't think we want it to be static - it uses and modifies the instance `client_handshaker_factory_`,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1326366292,2023-09-14T18:27:13Z,src/core/tsi/ssl_transport_security.cc,"@@ -1762,6 +1762,13 @@ void tsi_ssl_client_handshaker_factory_unref(   tsi_ssl_handshaker_factory_unref(&factory->base); } +tsi_ssl_client_handshaker_factory* tsi_ssl_client_handshaker_factory_ref(+    tsi_ssl_client_handshaker_factory* client_factory) {+  if (client_factory == nullptr) return nullptr;+  return reinterpret_cast<tsi_ssl_client_handshaker_factory*>(","I'm not 100% on this - the semantics of the `tsi_ssl_handshaker_factory_ref` that this calls is to return the factory, but's it's also just the same one that's in. I figured semantically since it returns it, there was a reason for that and it should be used?",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/34180,1326366905,2023-09-14T18:27:52Z,src/core/tsi/ssl_transport_security.cc,"@@ -1762,6 +1762,13 @@ void tsi_ssl_client_handshaker_factory_unref(   tsi_ssl_handshaker_factory_unref(&factory->base); } +tsi_ssl_client_handshaker_factory* tsi_ssl_client_handshaker_factory_ref(+    tsi_ssl_client_handshaker_factory* client_factory) {+  if (client_factory == nullptr) return nullptr;+  return reinterpret_cast<tsi_ssl_client_handshaker_factory*>(",https://github.com/grpc/grpc/blob/1986007e1ee735ec3f977f31cc8569c5ad954c7e/src/core/tsi/ssl_transport_security.cc#L1132-L1137,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34312,1326432755,2023-09-14T19:35:20Z,src/core/BUILD,"@@ -4178,6 +4178,15 @@ grpc_cc_library(     deps = [""//:gpr_platform""], ) +grpc_cc_library(+    name = ""xds_enabled_server"",+    hdrs = [+        ""ext/xds/xds_enabled_server.h"",+    ],+    language = ""c++"",+    deps = [""//:gpr_platform""],","If you remove the include as per my other comment, then I think we don't think we need this dependency.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34274,1326538562,2023-09-14T21:33:43Z,src/core/lib/gprpp/work_serializer.cc,"@@ -41,15 +48,39 @@ DebugOnlyTraceFlag grpc_work_serializer_trace(false, ""work_serializer""); // WorkSerializer::WorkSerializerImpl // -class WorkSerializer::WorkSerializerImpl : public Orphanable {+class WorkSerializer::WorkSerializerImpl {","done for now... I expect to revisit here (and elsewhere) down the line... once we de-experimentalize we'll be carrying the inheritance only for Orphanable, adding 8 bytes per serializer needlessly.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34274,1326539951,2023-09-14T21:35:39Z,src/core/lib/gprpp/work_serializer.cc,"@@ -253,14 +284,231 @@ void WorkSerializer::WorkSerializerImpl::DrainQueueOwned() {   } } +//+// WorkSerializer::DispatchingWorkSerializer+//++// DispatchingWorkSerializer: executes callbacks one at a time on EventEngine.+// One at a time guarantees that fixed size thread pools in EventEngine+// implementations are not starved of threads by long running work serializers.+// We implement EventEngine::Closure directly to avoid allocating once per+// callback in the queue when scheduling.+class WorkSerializer::DispatchingWorkSerializer final+    : public WorkSerializerImpl,+      private grpc_event_engine::experimental::EventEngine::Closure {","I don't think increasing the size of work serializer here is worthwhile - we need to be working towards decreasing the size of channels, not increasing it. I'll make this public inheritance to satisfy the style guide.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34274,1326621910,2023-09-14T23:44:55Z,test/cpp/end2end/client_lb_end2end_test.cc,"@@ -638,9 +638,12 @@ TEST_F(ClientLbEnd2endTest, ChannelStateConnectingWhenResolving) {   EXPECT_EQ(channel->GetState(true /* try_to_connect */), GRPC_CHANNEL_IDLE);   // Now that the channel is trying to connect, we should get to state   // CONNECTING.-  while (channel->GetState(false) == GRPC_CHANNEL_IDLE) {-    std::this_thread::sleep_for(std::chrono::milliseconds(10));-  }+  ASSERT_TRUE(+      WaitForChannelState(channel.get(), [&](grpc_connectivity_state state) {+        if (state == GRPC_CHANNEL_IDLE) return false;+        EXPECT_EQ(state, GRPC_CHANNEL_CONNECTING);+        return true;+      }));   EXPECT_EQ(channel->GetState(false /* try_to_connect */),",This expectation is no longer needed with the change you made immediately above.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34274,1326622585,2023-09-14T23:46:14Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -37,10 +35,10 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  protected:-  RoundRobinTest() : lb_policy_(MakeLbPolicy(""round_robin"")) {}+  RoundRobinTest() : LoadBalancingPolicyTest(""round_robin"") {}    void ExpectStartup(absl::Span<const absl::string_view> addresses) {","This PR is removing all callers of this function, so I think it should remove the function too.  There's no point leaving unused code lying around.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34274,1326625803,2023-09-14T23:50:19Z,src/core/lib/gprpp/work_serializer.cc,"@@ -253,14 +284,231 @@ void WorkSerializer::WorkSerializerImpl::DrainQueueOwned() {   } } +//+// WorkSerializer::DispatchingWorkSerializer+//++// DispatchingWorkSerializer: executes callbacks one at a time on EventEngine.+// One at a time guarantees that fixed size thread pools in EventEngine+// implementations are not starved of threads by long running work serializers.+// We implement EventEngine::Closure directly to avoid allocating once per+// callback in the queue when scheduling.+class WorkSerializer::DispatchingWorkSerializer final+    : public WorkSerializerImpl,+      private grpc_event_engine::experimental::EventEngine::Closure {+ public:+  explicit DispatchingWorkSerializer(+      std::shared_ptr<grpc_event_engine::experimental::EventEngine>+          event_engine)+      : event_engine_(std::move(event_engine)) {}+  void Run(std::function<void()> callback,+           const DebugLocation& location) override;+  void Schedule(std::function<void()> callback,+                const DebugLocation& location) override {+    // We always dispatch to event engine, so Schedule and Run share semantics.+    Run(callback, location);+  }+  void DrainQueue() override {}+  void Orphan() override;++#ifndef NDEBUG+  bool RunningInWorkSerializer() const override {+    return running_work_serializer_ == this;+  }+#endif++ private:+  // Wrapper to capture DebugLocation for the callback.+  struct CallbackWrapper {+    CallbackWrapper(std::function<void()> cb, const DebugLocation& loc)+        : callback(std::move(cb)), location(loc) {}+    std::function<void()> callback;+    // GPR_NO_UNIQUE_ADDRESS means this is 0 sized in release builds.+    GPR_NO_UNIQUE_ADDRESS DebugLocation location;+  };+  using CallbackVector = absl::InlinedVector<CallbackWrapper, 1>;++  // Override EventEngine::Closure+  void Run() override;++  // Refill processing_ from incoming_+  // If processing_ is empty, also update running_ and return false.+  // If additionally orphaned, will also delete this (therefore, it's not safe+  // to touch any member variables if Refill returns false).+  bool Refill();++  // Perform the parts of Refill that need to acquire mu_+  // Returns a tri-state indicating whether we were refilled successfully (=>+  // keep running), or finished, and then if we were orphaned.+  enum class RefillResult { kRefilled, kFinished, kFinishedAndOrphaned };+  RefillResult RefillInner();++#ifndef NDEBUG+  void SetCurrentThread() { running_work_serializer_ = this; }+  void ClearCurrentThread() { running_work_serializer_ = nullptr; }+#else+  void SetCurrentThread() {}+  void ClearCurrentThread() {}+#endif++  // Member variables are roughly sorted to keep processing cache lines+  // separated from incoming cache lines.++  // Callbacks that are currently being processed.+  // Only accessed by: a Run() call going from not-running to running, or a work+  // item being executed in EventEngine -- ie this does not need a mutex because+  // all access is serialized.+  // Stored in reverse execution order so that callbacks can be `pop_back()`'d+  // on completion to free up any resources they hold.+  CallbackVector processing_;+  // EventEngine instance upon which we'll do our work.+  const std::shared_ptr<grpc_event_engine::experimental::EventEngine>+      event_engine_;+  // Flags containing run state:+  // - running_ goes from false->true whenever the first callback is scheduled+  //   on an idle WorkSerializer, and transitions back to false after the last+  //   callback scheduled is completed and the WorkSerializer is again idle.+  // - orphaned_ transitions to true once upon Orphan being called.+  // When orphaned_ is true and running_ is false, the DispatchingWorkSerializer+  // instance is deleted.+  bool running_ ABSL_GUARDED_BY(mu_) = false;+  bool orphaned_ ABSL_GUARDED_BY(mu_) = false;+  Mutex mu_;+  // Queued callbacks. New work items land here, and when processing_ is drained+  // we move this entire queue into processing_ and work on draining it again.+  // In low traffic scenarios this gives two mutex acquisitions per work item,+  // but as load increases we get some natural batching and the rate of mutex+  // acquisitions per work item tends towards 1.+  CallbackVector incoming_ ABSL_GUARDED_BY(mu_);++#ifndef NDEBUG+  static thread_local DispatchingWorkSerializer* running_work_serializer_;+#endif+};++#ifndef NDEBUG+thread_local WorkSerializer::DispatchingWorkSerializer*+    WorkSerializer::DispatchingWorkSerializer::running_work_serializer_ =+        nullptr;+#endif++void WorkSerializer::DispatchingWorkSerializer::Orphan() {+  ReleasableMutexLock lock(&mu_);+  // If we're not running, then we can delete immediately.+  if (!running_) {+    lock.Release();+    delete this;+    return;+  }+  // Otherwise store a flag to delete when we're done.+  orphaned_ = true;+}++// Implementation of WorkSerializerImpl::Run+void WorkSerializer::DispatchingWorkSerializer::Run(+    std::function<void()> callback, const DebugLocation& location) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_work_serializer_trace)) {+    gpr_log(GPR_INFO, ""WorkSerializer[%p] Scheduling callback [%s:%d]"", this,+            location.file(), location.line());+  }+  MutexLock lock(&mu_);+  if (!running_) {+    // If we were previously idle, insert this callback directly into the empty+    // processing_ list and start running.+    running_ = true;+    GPR_ASSERT(processing_.empty());+    processing_.emplace_back(std::move(callback), location);+    event_engine_->Run(this);+  } else {+    // We are already running, so add this callback to the incoming_ list.+    // The work loop will eventually get to it.+    incoming_.emplace_back(std::move(callback), location);+  }+}++// Implementation of EventEngine::Closure::Run - our actual work loop+void WorkSerializer::DispatchingWorkSerializer::Run() {+  // TODO(ctiller): remove these when we can deprecate ExecCtx+  ApplicationCallbackExecCtx app_exec_ctx;+  ExecCtx exec_ctx;+  // Grab the last element of processing_ - which is the next item in our queue+  // since processing_ is stored in reverse order.+  auto& cb = processing_.back();+  if (GRPC_TRACE_FLAG_ENABLED(grpc_work_serializer_trace)) {+    gpr_log(GPR_INFO, ""WorkSerializer[%p] Executing callback [%s:%d]"", this,+            cb.location.file(), cb.location.line());+  }+  // Run the work item.+  SetCurrentThread();+  cb.callback();+  // pop_back here destroys the callback - freeing any resources it might hold.+  // We do so before clearing the current thread in case the callback destructor+  // wants to check that it's in the WorkSerializer too.+  processing_.pop_back();+  ClearCurrentThread();+  // Check if we've drained the queue and if so refill it.+  if (processing_.empty() && !Refill()) return;+  // There's still work in processing_, so schedule ourselves again on+  // EventEngine.+  event_engine_->Run(this);+}++WorkSerializer::DispatchingWorkSerializer::RefillResult+WorkSerializer::DispatchingWorkSerializer::RefillInner() {+  // Recover any memory held by processing_, so that we don't grow forever.+  // Do so before acquiring a lock so we don't cause inadvertent contention.+  processing_.shrink_to_fit();","Really?  From a glance at the implementation, it looks like [`clear()` does](https://github.com/abseil/abseil-cpp/blob/5655528c41830f733160de4fb0b99073841bae9e/absl/container/inlined_vector.h#L806).  It looks like [`resize()` might also](https://github.com/abseil/abseil-cpp/blob/5655528c41830f733160de4fb0b99073841bae9e/absl/container/inlined_vector.h#L602), although it's a bit hard to follow through all the templating.Anyway, doesn't really matter, I was mainly curious.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34274,1326654210,2023-09-15T00:38:44Z,test/core/client_channel/lb_policy/round_robin_test.cc,"@@ -37,10 +35,10 @@ namespace {  class RoundRobinTest : public LoadBalancingPolicyTest {  protected:-  RoundRobinTest() : lb_policy_(MakeLbPolicy(""round_robin"")) {}+  RoundRobinTest() : LoadBalancingPolicyTest(""round_robin"") {}    void ExpectStartup(absl::Span<const absl::string_view> addresses) {",didn't realize we were removing usage here... long week :),
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34274,1326656190,2023-09-15T00:42:46Z,src/core/lib/gprpp/work_serializer.cc,"@@ -253,14 +284,231 @@ void WorkSerializer::WorkSerializerImpl::DrainQueueOwned() {   } } +//+// WorkSerializer::DispatchingWorkSerializer+//++// DispatchingWorkSerializer: executes callbacks one at a time on EventEngine.+// One at a time guarantees that fixed size thread pools in EventEngine+// implementations are not starved of threads by long running work serializers.+// We implement EventEngine::Closure directly to avoid allocating once per+// callback in the queue when scheduling.+class WorkSerializer::DispatchingWorkSerializer final+    : public WorkSerializerImpl,+      private grpc_event_engine::experimental::EventEngine::Closure {+ public:+  explicit DispatchingWorkSerializer(+      std::shared_ptr<grpc_event_engine::experimental::EventEngine>+          event_engine)+      : event_engine_(std::move(event_engine)) {}+  void Run(std::function<void()> callback,+           const DebugLocation& location) override;+  void Schedule(std::function<void()> callback,+                const DebugLocation& location) override {+    // We always dispatch to event engine, so Schedule and Run share semantics.+    Run(callback, location);+  }+  void DrainQueue() override {}+  void Orphan() override;++#ifndef NDEBUG+  bool RunningInWorkSerializer() const override {+    return running_work_serializer_ == this;+  }+#endif++ private:+  // Wrapper to capture DebugLocation for the callback.+  struct CallbackWrapper {+    CallbackWrapper(std::function<void()> cb, const DebugLocation& loc)+        : callback(std::move(cb)), location(loc) {}+    std::function<void()> callback;+    // GPR_NO_UNIQUE_ADDRESS means this is 0 sized in release builds.+    GPR_NO_UNIQUE_ADDRESS DebugLocation location;+  };+  using CallbackVector = absl::InlinedVector<CallbackWrapper, 1>;++  // Override EventEngine::Closure+  void Run() override;++  // Refill processing_ from incoming_+  // If processing_ is empty, also update running_ and return false.+  // If additionally orphaned, will also delete this (therefore, it's not safe+  // to touch any member variables if Refill returns false).+  bool Refill();++  // Perform the parts of Refill that need to acquire mu_+  // Returns a tri-state indicating whether we were refilled successfully (=>+  // keep running), or finished, and then if we were orphaned.+  enum class RefillResult { kRefilled, kFinished, kFinishedAndOrphaned };+  RefillResult RefillInner();++#ifndef NDEBUG+  void SetCurrentThread() { running_work_serializer_ = this; }+  void ClearCurrentThread() { running_work_serializer_ = nullptr; }+#else+  void SetCurrentThread() {}+  void ClearCurrentThread() {}+#endif++  // Member variables are roughly sorted to keep processing cache lines+  // separated from incoming cache lines.++  // Callbacks that are currently being processed.+  // Only accessed by: a Run() call going from not-running to running, or a work+  // item being executed in EventEngine -- ie this does not need a mutex because+  // all access is serialized.+  // Stored in reverse execution order so that callbacks can be `pop_back()`'d+  // on completion to free up any resources they hold.+  CallbackVector processing_;+  // EventEngine instance upon which we'll do our work.+  const std::shared_ptr<grpc_event_engine::experimental::EventEngine>+      event_engine_;+  // Flags containing run state:+  // - running_ goes from false->true whenever the first callback is scheduled+  //   on an idle WorkSerializer, and transitions back to false after the last+  //   callback scheduled is completed and the WorkSerializer is again idle.+  // - orphaned_ transitions to true once upon Orphan being called.+  // When orphaned_ is true and running_ is false, the DispatchingWorkSerializer+  // instance is deleted.+  bool running_ ABSL_GUARDED_BY(mu_) = false;+  bool orphaned_ ABSL_GUARDED_BY(mu_) = false;+  Mutex mu_;+  // Queued callbacks. New work items land here, and when processing_ is drained+  // we move this entire queue into processing_ and work on draining it again.+  // In low traffic scenarios this gives two mutex acquisitions per work item,+  // but as load increases we get some natural batching and the rate of mutex+  // acquisitions per work item tends towards 1.+  CallbackVector incoming_ ABSL_GUARDED_BY(mu_);++#ifndef NDEBUG+  static thread_local DispatchingWorkSerializer* running_work_serializer_;+#endif+};++#ifndef NDEBUG+thread_local WorkSerializer::DispatchingWorkSerializer*+    WorkSerializer::DispatchingWorkSerializer::running_work_serializer_ =+        nullptr;+#endif++void WorkSerializer::DispatchingWorkSerializer::Orphan() {+  ReleasableMutexLock lock(&mu_);+  // If we're not running, then we can delete immediately.+  if (!running_) {+    lock.Release();+    delete this;+    return;+  }+  // Otherwise store a flag to delete when we're done.+  orphaned_ = true;+}++// Implementation of WorkSerializerImpl::Run+void WorkSerializer::DispatchingWorkSerializer::Run(+    std::function<void()> callback, const DebugLocation& location) {+  if (GRPC_TRACE_FLAG_ENABLED(grpc_work_serializer_trace)) {+    gpr_log(GPR_INFO, ""WorkSerializer[%p] Scheduling callback [%s:%d]"", this,+            location.file(), location.line());+  }+  MutexLock lock(&mu_);+  if (!running_) {+    // If we were previously idle, insert this callback directly into the empty+    // processing_ list and start running.+    running_ = true;+    GPR_ASSERT(processing_.empty());+    processing_.emplace_back(std::move(callback), location);+    event_engine_->Run(this);+  } else {+    // We are already running, so add this callback to the incoming_ list.+    // The work loop will eventually get to it.+    incoming_.emplace_back(std::move(callback), location);+  }+}++// Implementation of EventEngine::Closure::Run - our actual work loop+void WorkSerializer::DispatchingWorkSerializer::Run() {+  // TODO(ctiller): remove these when we can deprecate ExecCtx+  ApplicationCallbackExecCtx app_exec_ctx;+  ExecCtx exec_ctx;+  // Grab the last element of processing_ - which is the next item in our queue+  // since processing_ is stored in reverse order.+  auto& cb = processing_.back();+  if (GRPC_TRACE_FLAG_ENABLED(grpc_work_serializer_trace)) {+    gpr_log(GPR_INFO, ""WorkSerializer[%p] Executing callback [%s:%d]"", this,+            cb.location.file(), cb.location.line());+  }+  // Run the work item.+  SetCurrentThread();+  cb.callback();+  // pop_back here destroys the callback - freeing any resources it might hold.+  // We do so before clearing the current thread in case the callback destructor+  // wants to check that it's in the WorkSerializer too.+  processing_.pop_back();+  ClearCurrentThread();+  // Check if we've drained the queue and if so refill it.+  if (processing_.empty() && !Refill()) return;+  // There's still work in processing_, so schedule ourselves again on+  // EventEngine.+  event_engine_->Run(this);+}++WorkSerializer::DispatchingWorkSerializer::RefillResult+WorkSerializer::DispatchingWorkSerializer::RefillInner() {+  // Recover any memory held by processing_, so that we don't grow forever.+  // Do so before acquiring a lock so we don't cause inadvertent contention.+  processing_.shrink_to_fit();","ah, forgot this was `absl::InlinedVector` - `std::vector` doesn't, and I prefer to keep things so we don't accidentally cause an outage should we change to `std::vector`. (It's an experiment I'd like to do in the future - it would significantly reduce idle memory usage)",
1888193,ginayeh,https://api.github.com/repos/grpc/grpc/pulls/34387,1329148545,2023-09-18T18:47:19Z,tools/run_tests/xds_k8s_test_driver/tests/baseline_test.py,,Can you help to revert changes in this file?  This is probably a result of me doing some local testing/verification of rpc metadata header stuff.,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/33460,1330609410,2023-09-19T19:24:58Z,tools/run_tests/xds_k8s_test_driver/bin/cleanup/cleanup.py,"@@ -129,7 +170,7 @@ def get_expire_timestamp() -> datetime.datetime:     )  -def exec_gcloud(project: str, *cmds: List[str]) -> Json:+def exec_gcloud(project: str, *cmds: str) -> Json:",Should we keep`*cmds` as list?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34286,1330626176,2023-09-19T19:43:45Z,src/core/lib/surface/server.cc,"@@ -1211,30 +1171,21 @@ void Server::ChannelData::InitTransport(RefCountedPtr<Server> server,   grpc_transport_perform_op(transport, op); } -Server::ChannelRegisteredMethod* Server::ChannelData::GetRegisteredMethod(-    const grpc_slice& host, const grpc_slice& path) {-  if (registered_methods_ == nullptr) return nullptr;-  // TODO(ctiller): unify these two searches-  // check for an exact match with host-  uint32_t hash = MixHash32(grpc_slice_hash(host), grpc_slice_hash(path));-  for (size_t i = 0; i <= registered_method_max_probes_; i++) {-    ChannelRegisteredMethod* rm =-        &(*registered_methods_)[(hash + i) % registered_methods_->size()];-    if (rm->server_registered_method == nullptr) break;-    if (!rm->has_host) continue;-    if (rm->host != host) continue;-    if (rm->method != path) continue;-    return rm;-  }-  // check for a wildcard method definition (no host set)-  hash = MixHash32(0, grpc_slice_hash(path));-  for (size_t i = 0; i <= registered_method_max_probes_; i++) {-    ChannelRegisteredMethod* rm =-        &(*registered_methods_)[(hash + i) % registered_methods_->size()];-    if (rm->server_registered_method == nullptr) break;-    if (rm->has_host) continue;-    if (rm->method != path) continue;-    return rm;+Server::RegisteredMethod* Server::ChannelData::GetRegisteredMethod(+    const absl::string_view& host, const absl::string_view& path)+    ABSL_LOCKS_EXCLUDED(registered_methods_mu_) {+  MutexLock lock(&server_->registered_methods_mu_);","We'll need to figure out a way to avoid this lock: since it's on the per-request path it'll be a huge contention point.One thing to consider is making `registered_methods_` a `shared_ptr<const flat_hash_map<...>>` - if we did that then when we register a new method we could acquire the lock, make a new `shared_ptr<const flat_hash_map<>>` and then install that into registered_methods_ -- and we could then have each channel pick up its own reference to the map.The effect would be that newly registered methods *after* server instantiation would not be visible to channels, and maybe that's ok.Another approach would be to crash on registering a method after the server has started -- if we did that, then we don't need a mutex to *read* from registered_methods_ because it's guaranteed immutable at that point.",
31627465,nanahpang,https://api.github.com/repos/grpc/grpc/pulls/34191,1333663650,2023-09-21T22:34:18Z,src/core/ext/transport/chaotic_good/client_transport.h,"@@ -55,56 +70,124 @@ class ClientTransport {     if (writer_ != nullptr) {       writer_.reset();     }+    if (reader_ != nullptr) {+      reader_.reset();+    }   }   auto AddStream(CallArgs call_args) {     // At this point, the connection is set up.     // Start sending data frames.     uint64_t stream_id;+    InterActivityPipe<ServerFrame, server_frame_queue_size_> server_frames;     {       MutexLock lock(&mu_);       stream_id = next_stream_id_++;+      stream_map_.insert(+          std::pair<uint32_t,+                    std::shared_ptr<InterActivityPipe<+                        ServerFrame, server_frame_queue_size_>::Sender>>(+              stream_id, std::make_shared<InterActivityPipe<+                             ServerFrame, server_frame_queue_size_>::Sender>(+                             std::move(server_frames.sender))));     }-    return Seq(-        // Continuously send data frame with client to server messages.-        ForEach(std::move(*call_args.client_to_server_messages),-                [stream_id, initial_frame = true,-                 client_initial_metadata =-                     std::move(call_args.client_initial_metadata),-                 outgoing_frames = outgoing_frames_.MakeSender()](-                    MessageHandle result) mutable {-                  ClientFragmentFrame frame;-                  frame.stream_id = stream_id;-                  frame.message = std::move(result);-                  if (initial_frame) {-                    // Send initial frame with client intial metadata.-                    frame.headers = std::move(client_initial_metadata);-                    initial_frame = false;-                  }-                  return Seq(-                      outgoing_frames.Send(ClientFrame(std::move(frame))),-                      [](bool success) -> absl::Status {-                        if (!success) {-                          return absl::InternalError(-                              ""Send frame to outgoing_frames failed."");-                        }-                        return absl::OkStatus();-                      });-                }));+    return TrySeq(+        TryJoin(+            // Continuously send client frame with client to server messages.+            ForEach(std::move(*call_args.client_to_server_messages),+                    [stream_id, initial_frame = true,+                     client_initial_metadata =+                         std::move(call_args.client_initial_metadata),+                     outgoing_frames = outgoing_frames_.MakeSender()](+                        MessageHandle result) mutable {+                      ClientFragmentFrame frame;+                      frame.stream_id = stream_id;+                      frame.message = std::move(result);+                      if (initial_frame) {+                        // Send initial frame with client intial metadata.+                        frame.headers = std::move(client_initial_metadata);+                        initial_frame = false;",The `initial_frame` will be false after the first frame is sent because the lambda function is mutable and the capture list value could be changed in runtime (I double checked this with printing out`std::cout<<initial_frame` in the lambda function).,
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34447,1334779730,2023-09-22T20:12:29Z,examples/cpp/csm/Dockerfile.client,"@@ -0,0 +1,39 @@+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++FROM python:3.9-slim-bookworm++RUN apt-get update -y && apt-get upgrade -y && apt-get install -y build-essential clang curl++WORKDIR /workdir++RUN ln -s /usr/bin/python3 /usr/bin/python+RUN mkdir /artifacts++COPY . .+RUN OVERRIDE_BAZEL_VERSION=5.4.0 tools/bazel build //examples/cpp/csm:csm_greeter_client",This should no longer be needed,X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/34447,1335232088,2023-09-24T19:10:04Z,examples/cpp/csm/Dockerfile.client,"@@ -0,0 +1,39 @@+# Copyright 2023 The gRPC Authors+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+#     http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.++FROM python:3.9-slim-bookworm++RUN apt-get update -y && apt-get upgrade -y && apt-get install -y build-essential clang curl++WORKDIR /workdir++RUN ln -s /usr/bin/python3 /usr/bin/python+RUN mkdir /artifacts++COPY . .+RUN OVERRIDE_BAZEL_VERSION=5.4.0 tools/bazel build //examples/cpp/csm:csm_greeter_client",No longer needed but also innocuous. I'll take the AI to remove this after the release.,X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/34426,1337579344,2023-09-26T17:44:22Z,src/core/ext/filters/client_channel/lb_policy/pick_first/pick_first.cc,"@@ -607,14 +658,81 @@ void PickFirst::SubchannelList::SubchannelData::OnConnectivityStateChange(   // see its initial notification.  Start trying to connect, starting   // with the first subchannel.   if (!old_state.has_value()) {-    subchannel_list_->subchannels_.front().ReactToConnectivityStateLocked();+    if (!IsPickFirstHappyEyeballsEnabled()) {+      subchannel_list_->subchannels_.front().ReactToConnectivityStateLocked();+      return;+    }+    subchannel_list_->StartConnectingNextSubchannel();+    return;+  }+  if (!IsPickFirstHappyEyeballsEnabled()) {+    // Ignore any other updates for subchannels we're not currently trying to+    // connect to.+    if (Index() != subchannel_list_->attempting_index_) return;+    // React to the connectivity state.+    ReactToConnectivityStateLocked();     return;   }-  // Ignore any other updates for subchannels we're not currently trying to-  // connect to.-  if (Index() != subchannel_list_->attempting_index_) return;-  // React to the connectivity state.-  ReactToConnectivityStateLocked();+  // Otherwise, process connectivity state change.",nit: I feel like SubchannelData::OnConnectivityStateChange is becoming really long and hard to follow. Should it be split in several methods?,X
5564114,Vignesh2208,https://api.github.com/repos/grpc/grpc/pulls/34191,1337596068,2023-09-26T18:00:29Z,src/core/ext/transport/chaotic_good/client_transport.cc,"@@ -113,6 +123,73 @@ ClientTransport::ClientTransport(       [](absl::Status status) {         GPR_ASSERT(status.code() == absl::StatusCode::kCancelled ||                    status.code() == absl::StatusCode::kInternal);+        // TODO(ladynana): handle the promise endpoint write failures with+        // outgoing_frames.close() once available.+      });+  auto read_loop = Loop([this] {+    return TrySeq(+        // Read frame header from control endpoint.+        this->control_endpoint_->Read(FrameHeader::frame_header_size_),+        // Read different parts of the server frame from control/data endpoints+        // based on frame header.+        [this](SliceBuffer read_buffer) mutable {+          frame_header_ = std::make_shared<FrameHeader>(+              FrameHeader::Parse(+                  reinterpret_cast<const uint8_t*>(GRPC_SLICE_START_PTR(+                      read_buffer.c_slice_buffer()->slices[0])))+                  .value());+          // Read header and trailers from control endpoint.+          // Read message padding and message from data endpoint.+          return TryJoin(+              control_endpoint_->Read(frame_header_->GetFrameLength()),+              data_endpoint_->Read(frame_header_->message_padding ++                                   frame_header_->message_length));+        },+        // Construct and send the server frame to corresponding stream.+        [this](std::tuple<SliceBuffer, SliceBuffer> ret) mutable {+          control_endpoint_read_buffer_ = std::move(std::get<0>(ret));+          // Discard message padding and only keep message in data read buffer.+          std::get<1>(ret).MoveLastNBytesIntoSliceBuffer(+              frame_header_->message_length, data_endpoint_read_buffer_);+          ServerFragmentFrame frame;+          // Initialized to get this_cpu() info in global_stat().+          ExecCtx exec_ctx;+          // Deserialize frame from read buffer.+          absl::BitGen bitgen;+          auto status = frame.Deserialize(hpack_parser_.get(), *frame_header_,+                                          absl::BitGenRef(bitgen),+                                          control_endpoint_read_buffer_);+          GPR_ASSERT(status.ok());+          // Move message into frame.+          frame.message = arena_->MakePooled<Message>(+              std::move(data_endpoint_read_buffer_), 0);+          std::shared_ptr<+              InterActivityPipe<ServerFrame, server_frame_queue_size_>::Sender>+              sender;+          {+            MutexLock lock(&mu_);+            sender = stream_map_[frame.stream_id];+          }+          return sender->Push(ServerFrame(std::move(frame)));+        },+        // Check if send frame to corresponding stream successfully.+        [](bool ret) -> LoopCtl<absl::Status> {+          if (ret) {+            // Send incoming frames successfully.+            return Continue();+          } else {+            return absl::InternalError(""Send incoming frames failed."");+          }+        });+  });+  reader_ = MakeActivity(+      // Continuously read next incoming frames from promise endpoints.+      std::move(read_loop), EventEngineWakeupScheduler(event_engine_),+      [](absl::Status status) {+        GPR_ASSERT(status.code() == absl::StatusCode::kCancelled ||+                   status.code() == absl::StatusCode::kInternal);+        // TODO(ladynana): handle the promise endpoint read failures with+        // iterating stream_map_ and close all the pipes once available.","I think you may also need to pass the arena_.get() variable to both the reader and writer activity like this: https://github.com/grpc/grpc/blob/master/test/core/promise/activity_test.cc#L266. Otherwise if GetContext<Arena> is executed in another thread, it will probably fail.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34487,1337683775,2023-09-26T19:26:59Z,src/core/ext/filters/client_channel/lb_policy/grpclb/grpclb.cc,"@@ -1767,6 +1767,10 @@ void GrpcLb::CreateOrUpdateChildPolicyLocked() {     update_args.addresses = serverlist_->GetServerAddressList(         lb_calld_ == nullptr ? nullptr : lb_calld_->client_stats());     is_backend_from_grpclb_load_balancer = true;+    if (update_args.addresses.ok() && update_args.addresses->empty()) {+      update_args.resolution_note =+          absl::StrCat(""empty list from balancer: "", resolution_note_);","There's no point in using `resolution_note_` here, because it won't contain anything relevant.  `resolution_note_` is set based on the resolution note passed down from the resolver.  But in this case, we're using an address list from the balancer, not from the resolver.This should just be:```update_args.resolution_note = ""empty serverlist from grpclb balancer"";```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34493,1338888263,2023-09-27T16:30:00Z,src/core/ext/filters/client_channel/client_channel.h,"@@ -473,6 +474,7 @@ class ClientChannel::LoadBalancedCall   const BackendMetricData* backend_metric_data_ = nullptr;   std::unique_ptr<LoadBalancingPolicy::SubchannelCallTrackerInterface>       lb_subchannel_call_tracker_;+  grpc_call_context_element* const call_context_;","Why is it necessary to move this into the base class?  I see that `call_attempt_tracer()` accesses it, but if we're holding a ref to the `PromiseBasedLoadBalancedCall` object, shouldn't we still be able to access `GetContext<grpc_call_context_element>()` as we were doing before?The reason I ask is that it seems like this increases per-call memory for promise-based calls, so I just want to make sure we actually need to do so.",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1338971357,2023-09-27T17:34:37Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,79 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/support/sync.h>++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(+      absl::string_view crl_string);+  virtual ~Crl() = default;+  virtual std::string Issuer() = 0;++ protected:+  Crl() = default;+};++// Information about a certificate to be used to fetch its associated CRL.+class CertificateInfo {+ public:+  virtual ~CertificateInfo() = default;+  virtual absl::string_view GetIssuer() const = 0;+};++// The base class for CRL Provider implementations.+class CrlProvider {+ public:+  CrlProvider() = default;","nit: I think this should be removed, since you should not be able to instantiate a pure virtual class.",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1338991517,2023-09-27T17:51:08Z,include/grpcpp/security/crl_provider.h,"@@ -0,0 +1,51 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPCPP_SECURITY_CRL_PROVIDER_H+#define GRPCPP_SECURITY_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>+#include <utility>++#include <grpc/grpc_crl_provider.h>+#include <grpcpp/impl/sync.h>+#include <grpcpp/support/string_ref.h>++namespace grpc {+namespace experimental {++using grpc_core::experimental::+    CertificateInfo;                         // NOLINT(misc-unused-using-decls)+using grpc_core::experimental::Crl;          // NOLINT(misc-unused-using-decls)+using grpc_core::experimental::CrlProvider;  // NOLINT(misc-unused-using-decls)++class StaticCrlProvider : CrlProvider {",Can you explain why we need a duplicate static implementation? Can we just rely on the `grpc_core` implementation?,X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1338993645,2023-09-27T17:52:56Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h,"@@ -0,0 +1,55 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H+#define GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H++#include <openssl/crypto.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_crl_provider.h>++namespace grpc_core {+namespace experimental {++class CrlImpl : public Crl {+ public:+  explicit CrlImpl(X509_CRL* crl);","For my own understanding, do we really want the caller of this API to be creating the `X509_CRL` object? Should we hide this under the hood of the constructor instead?",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1338997904,2023-09-27T17:56:25Z,src/core/tsi/ssl_transport_security.cc,"@@ -953,6 +964,36 @@ static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {   return preverify_ok; } +// X509_STORE_set_get_crl() sets the function to get the crl for a given+// certificate x. When found, the crl must be assigned to *crl. This function+// must return 0 on failure and 1 on success. If no function to get the issuer+// is provided, the internal default function will be used instead.+static int GetCrlFromProvider(X509_STORE_CTX* ctx, X509_CRL** crl_out,+                              X509* x) {+  SSL* ssl = static_cast<SSL*>(+      X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx()));","Please check the return value of `SSL_get_ex_data_X509_STORE_CTX_idx` prior to using it, per https://www.openssl.org/docs/man1.0.2/man3/SSL_get_ex_data_X509_STORE_CTX_idx.html.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1339063561,2023-09-27T18:50:43Z,include/grpcpp/security/crl_provider.h,"@@ -0,0 +1,51 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPCPP_SECURITY_CRL_PROVIDER_H+#define GRPCPP_SECURITY_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>+#include <utility>++#include <grpc/grpc_crl_provider.h>+#include <grpcpp/impl/sync.h>+#include <grpcpp/support/string_ref.h>++namespace grpc {+namespace experimental {++using grpc_core::experimental::+    CertificateInfo;                         // NOLINT(misc-unused-using-decls)+using grpc_core::experimental::Crl;          // NOLINT(misc-unused-using-decls)+using grpc_core::experimental::CrlProvider;  // NOLINT(misc-unused-using-decls)++class StaticCrlProvider : CrlProvider {","This was my bad it shouldn't be here, it should be a `using` like the others above in this file",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1339080277,2023-09-27T19:04:55Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h,"@@ -0,0 +1,55 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H+#define GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H++#include <openssl/crypto.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_crl_provider.h>++namespace grpc_core {+namespace experimental {++class CrlImpl : public Crl {+ public:+  explicit CrlImpl(X509_CRL* crl);+  ~CrlImpl() override;+  std::string Issuer() override;+  X509_CRL& crl() const { return *crl_; }++ private:+  X509_CRL* crl_;+  std::string issuer_;+};++class CertificateInfoImpl : public CertificateInfo {+ public:+  explicit CertificateInfoImpl(absl::string_view issuer) : issuer_(issuer) {}+  absl::string_view GetIssuer() const override { return issuer_; }++ private:+  absl::string_view issuer_;","This is meant to be a very short lived object that is created and immediately used to fetch a CRL, so we should control the lifetime of the underlying buffer in `ssl_transport_security.cc` and be certain that it's longer than the life of this object. It would be a single string copy to store it as a `std::string`.WDYT?",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1339093775,2023-09-27T19:15:46Z,src/core/tsi/ssl_transport_security.cc,"@@ -953,6 +964,36 @@ static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {   return preverify_ok; } +// X509_STORE_set_get_crl() sets the function to get the crl for a given+// certificate x. When found, the crl must be assigned to *crl. This function+// must return 0 on failure and 1 on success. If no function to get the issuer+// is provided, the internal default function will be used instead.+static int GetCrlFromProvider(X509_STORE_CTX* ctx, X509_CRL** crl_out,+                              X509* x) {+  SSL* ssl = static_cast<SSL*>(+      X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx()));+  SSL_CTX* ssl_ctx = SSL_get_SSL_CTX(ssl);+  grpc_core::experimental::CrlProvider* provider =+      static_cast<grpc_core::experimental::CrlProvider*>(+          SSL_CTX_get_ex_data(ssl_ctx, g_ssl_ctx_ex_crl_provider_index));++  char* buf = X509_NAME_oneline(X509_get_issuer_name(x), nullptr, 0);","Exactly - `X509_get_issuer_name` returns an `X509_NAME` type object, which `X509_NAME_oneline` converts into a `char*` buffer. `X509_NAME_oneline` can take an input buffer and length and put the data in there, or if that input is null it allocates a new buffer and returns it.",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1339183187,2023-09-27T20:35:10Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h,"@@ -0,0 +1,55 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H+#define GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H++#include <openssl/crypto.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_crl_provider.h>++namespace grpc_core {+namespace experimental {++class CrlImpl : public Crl {+ public:+  explicit CrlImpl(X509_CRL* crl);+  ~CrlImpl() override;+  std::string Issuer() override;+  X509_CRL& crl() const { return *crl_; }++ private:+  X509_CRL* crl_;+  std::string issuer_;+};++class CertificateInfoImpl : public CertificateInfo {+ public:+  explicit CertificateInfoImpl(absl::string_view issuer) : issuer_(issuer) {}+  absl::string_view GetIssuer() const override { return issuer_; }++ private:+  absl::string_view issuer_;","That's how we're using it right now, but I think that is dangerous because we may refactor the `ssl_transport_security.cc` code in the future or use this class for some other purpose in the future. I'd strongly suggest changing this. :)",X
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1339183667,2023-09-27T20:35:35Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h,"@@ -0,0 +1,55 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H+#define GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H++#include <openssl/crypto.h>++#include ""absl/strings/string_view.h""++#include <grpc/grpc_crl_provider.h>++namespace grpc_core {+namespace experimental {++class CrlImpl : public Crl {+ public:+  explicit CrlImpl(X509_CRL* crl);+  ~CrlImpl() override;+  std::string Issuer() override;+  X509_CRL& crl() const { return *crl_; }++ private:+  X509_CRL* crl_;+  std::string issuer_;",Can we change the constructor logic to do the derivation in a helper function and call the helper in the initializer list?,X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1339230139,2023-09-27T21:18:52Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,82 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <memory>+#include <vector>++#include <openssl/bio.h>+#include <openssl/crypto.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""++#include <grpc/support/log.h>++namespace grpc_core {+namespace experimental {++CrlImpl::CrlImpl(X509_CRL* crl) : crl_(crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);",This would complicate the external API some for `Issuer()` to return a `std::optional<std::string>`What value do we get out of this behavior? A cleaner handling of bad CRLs? Because in the end we'll be discarding it either way - I lean more towards tossing things out at a higher level if there is no issuer?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34493,1339235436,2023-09-27T21:24:30Z,src/core/ext/filters/client_channel/client_channel.h,"@@ -473,6 +474,7 @@ class ClientChannel::LoadBalancedCall   const BackendMetricData* backend_metric_data_ = nullptr;   std::unique_ptr<LoadBalancingPolicy::SubchannelCallTrackerInterface>       lb_subchannel_call_tracker_;+  grpc_call_context_element* const call_context_;",it does... the virtual call was messing highly with the sanitizer reports and when i moved this everything became clear within minutes - so it's suboptimal for now in deference to debug-ability (and I think there's going to be more instances of this soon) -- and once we finalize the transition we can move to a `GetContext<>` call everywhere and eliminate this.,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1339268654,2023-09-27T21:59:45Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,82 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <memory>+#include <vector>++#include <openssl/bio.h>+#include <openssl/crypto.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""++#include <grpc/support/log.h>++namespace grpc_core {+namespace experimental {++CrlImpl::CrlImpl(X509_CRL* crl) : crl_(crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);+  issuer_ = buf;+  OPENSSL_free(buf);+}++CrlImpl::~CrlImpl() { X509_CRL_free(crl_); }++std::string CrlImpl::Issuer() { return issuer_; }++absl::StatusOr<std::unique_ptr<Crl>> Crl::Parse(absl::string_view crl_string) {+  BIO* crl_bio =+      BIO_new_mem_buf(crl_string.data(), static_cast<int>(crl_string.size()));+  // Errors on BIO+  if (crl_bio == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from crl string to BIO failed."");+  }+  X509_CRL* crl = PEM_read_bio_X509_CRL(crl_bio, nullptr, nullptr, nullptr);+  BIO_free(crl_bio);+  if (crl == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from PEM string to X509 CRL failed."");+  }+  return std::make_unique<CrlImpl>(crl);+}++StaticCrlProvider::StaticCrlProvider(std::vector<std::string> crls) {+  for (const auto& raw_crl : crls) {+    absl::StatusOr<std::unique_ptr<Crl>> result = Crl::Parse(raw_crl);+    GPR_ASSERT(result.ok());","Alright this represented a larger change, so please take a closer look :)Commit hash - 0732e787d5",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1340554260,2023-09-28T18:54:33Z,src/core/tsi/ssl_transport_security.h,"@@ -179,9 +180,15 @@ struct tsi_ssl_client_handshaker_options {   // The directory where all hashed CRL files enforced by the handshaker are   // located. If the directory is invalid, CRL checking will fail open and just   // log. An empty directory will not enable crl checking. Only OpenSSL version-  // > 1.1 is supported for CRL checking+  // > 1.1 is supported for CRL checking. Cannot be used in conjunction with","Yes, changed to `>=` - I believe the intention is to use `1.1.1` which is technically `> 1.1`, but I think `>=` is clearer",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1340585482,2023-09-28T19:30:17Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,79 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/support/sync.h>++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(","I see, thanks for clarifying. In that case, I think this should probably be a standalone function, since it specific to our implementation of the `Crl` interface and not about the general `Crl` class. Also, can you add comments that document its functionality?",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1340590479,2023-09-28T19:36:07Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,83 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/support/sync.h>++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL.+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(+      absl::string_view crl_string);+  virtual ~Crl() = default;+  virtual absl::string_view Issuer() = 0;+};++// Information about a certificate to be used to fetch its associated CRL.+class CertificateInfo {+ public:+  virtual ~CertificateInfo() = default;+  virtual absl::string_view Issuer() const = 0;+};++// The base class for CRL Provider implementations.+// CrlProviders can be passed in as a way to supply CRLs during handshakes.+// CrlProviders must be thread safe. They are on the critical path of gRPC+// creating a connection and doing a handshake, so the implementation of+// `GetCrl` should be very fast. It is suggested to have an in-memory map of+// CRLs for quick lookup and return, and doing expensive updates to this map+// asynchronously.+class CrlProvider {+ public:+  virtual ~CrlProvider() = default;+  // Get the CRL associated with a certificate. Read-only.+  virtual std::shared_ptr<Crl> GetCrl(const CertificateInfo& cert) = 0;+};++class StaticCrlProvider : public CrlProvider {+ public:+  // Each element of the input vector is expected to be the raw contents of a+  // CRL file.+  std::shared_ptr<Crl> GetCrl(const CertificateInfo& certificate_info) override;+  static absl::StatusOr<std::shared_ptr<CrlProvider>> FromVector(+      const std::vector<std::string> crls);++ private:+  explicit StaticCrlProvider(+      const absl::flat_hash_map<std::string, std::shared_ptr<Crl>>);",nit: Please add the parameter name.,
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1340590665,2023-09-28T19:36:22Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,83 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/support/sync.h>++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL.+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(+      absl::string_view crl_string);+  virtual ~Crl() = default;+  virtual absl::string_view Issuer() = 0;+};++// Information about a certificate to be used to fetch its associated CRL.+class CertificateInfo {+ public:+  virtual ~CertificateInfo() = default;+  virtual absl::string_view Issuer() const = 0;+};++// The base class for CRL Provider implementations.+// CrlProviders can be passed in as a way to supply CRLs during handshakes.+// CrlProviders must be thread safe. They are on the critical path of gRPC+// creating a connection and doing a handshake, so the implementation of+// `GetCrl` should be very fast. It is suggested to have an in-memory map of+// CRLs for quick lookup and return, and doing expensive updates to this map+// asynchronously.+class CrlProvider {+ public:+  virtual ~CrlProvider() = default;+  // Get the CRL associated with a certificate. Read-only.+  virtual std::shared_ptr<Crl> GetCrl(const CertificateInfo& cert) = 0;+};++class StaticCrlProvider : public CrlProvider {+ public:+  // Each element of the input vector is expected to be the raw contents of a+  // CRL file.+  std::shared_ptr<Crl> GetCrl(const CertificateInfo& certificate_info) override;+  static absl::StatusOr<std::shared_ptr<CrlProvider>> FromVector(+      const std::vector<std::string> crls);++ private:+  explicit StaticCrlProvider(+      const absl::flat_hash_map<std::string, std::shared_ptr<Crl>>);",nit: Should the parameter be `const&` instead of just `const`?,
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1340607400,2023-09-28T19:53:33Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,83 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/support/sync.h>++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL.+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(+      absl::string_view crl_string);+  virtual ~Crl() = default;+  virtual absl::string_view Issuer() = 0;+};++// Information about a certificate to be used to fetch its associated CRL.+class CertificateInfo {+ public:+  virtual ~CertificateInfo() = default;+  virtual absl::string_view Issuer() const = 0;+};++// The base class for CRL Provider implementations.+// CrlProviders can be passed in as a way to supply CRLs during handshakes.+// CrlProviders must be thread safe. They are on the critical path of gRPC+// creating a connection and doing a handshake, so the implementation of+// `GetCrl` should be very fast. It is suggested to have an in-memory map of+// CRLs for quick lookup and return, and doing expensive updates to this map+// asynchronously.+class CrlProvider {+ public:+  virtual ~CrlProvider() = default;+  // Get the CRL associated with a certificate. Read-only.+  virtual std::shared_ptr<Crl> GetCrl(const CertificateInfo& cert) = 0;+};++class StaticCrlProvider : public CrlProvider {+ public:+  // Each element of the input vector is expected to be the raw contents of a+  // CRL file.+  std::shared_ptr<Crl> GetCrl(const CertificateInfo& certificate_info) override;+  static absl::StatusOr<std::shared_ptr<CrlProvider>> FromVector(+      const std::vector<std::string> crls);++ private:+  explicit StaticCrlProvider(+      const absl::flat_hash_map<std::string, std::shared_ptr<Crl>>);+  absl::flat_hash_map<std::string, std::shared_ptr<Crl>> crls_;","Can we mark this as ""const"" now that it is populated via an initializer list in the constructor?",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1340614657,2023-09-28T20:02:06Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,82 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <memory>+#include <vector>++#include <openssl/bio.h>+#include <openssl/crypto.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""++#include <grpc/support/log.h>++namespace grpc_core {+namespace experimental {++CrlImpl::CrlImpl(X509_CRL* crl) : crl_(crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);","Ya that's a good point. In that case, instead of a public constructor, WDYT of the following:- Have a public static factory method, e.g. `static absl::StatusOr<CrlImpl> Create(X509_CRL* crl)`.- In the implementation of `Create`, call `IssuerFromCrl`. If anything bad happens, return an error status. If nothing bad happens, create the `CrlImpl` using the constructor and return.WDYT?",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34519,1340625700,2023-09-28T20:15:51Z,tools/run_tests/xds_k8s_test_driver/framework/rpc/grpc_testing.py,"@@ -159,6 +161,25 @@ def set_not_serving(self):             rpc=""SetNotServing"", req=empty_pb2.Empty(), log_level=logging.INFO         ) +    def send_hook_request_start_server(self):","`HookService` [is not a part of](https://github.com/grpc/grpc/blob/e76ac4ab07d936a857339fb1bd4eeb621bd3fba6/src/proto/grpc/testing/test.proto#L95-L110) `XdsUpdateHealthService`, so it shouldn't be in `XdsUpdateHealthServiceClient`.We should create another class called `HookServiceClient`.",X
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/34519,1340636816,2023-09-28T20:29:50Z,tools/run_tests/xds_k8s_test_driver/framework/rpc/grpc_testing.py,"@@ -159,6 +161,25 @@ def set_not_serving(self):             rpc=""SetNotServing"", req=empty_pb2.Empty(), log_level=logging.INFO         ) +    def send_hook_request_start_server(self):","[`SendHookRequest` _is_ and that's what's being invoked here](https://github.com/grpc/grpc/blob/a17f08b49d7e46a2a102c84f57086fd1e6312113/src/proto/grpc/testing/test.proto#L109). There are two different RPCs here:- `HookService.Hook`, which you pointed out here and which is called by `grpcurl`- `XdsUpdateHelathService.SendHookRequest`, which controls a server running `HookService.Hook` and which is the actual RPC method referenced here.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34518,1340640621,2023-09-28T20:34:47Z,tools/dockerfile/interoptest/grpc_interop_cxx_xds/Dockerfile.xds_server,"@@ -38,5 +45,12 @@ RUN apt-get update \     && rm -rf /var/lib/apt/lists/*  COPY --from=0 /artifacts ./+COPY --from=0 /workdir/grpcurl /bin/grpcurl++# TODO: The reflection server is not currently fully functional. Copying the+# protos is required for CLI RPC tools run against localhost of this container+# image until this is fixed.+COPY --from=0 /workdir/src/proto  /src/proto/+COPY tools/dockerfile/interoptest/grpc_interop_cxx_xds/xds_server_entrypoint.sh / -ENTRYPOINT [""/xds_interop_server""]+ENTRYPOINT [""/xds_server_entrypoint.sh""]",Let's add a todo to replace it with [tini](https://github.com/krallin/tini) or similar.,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1340640752,2023-09-28T20:34:58Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,79 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/support/sync.h>++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(","> since it specific to our implementation of the Crl interface and not about the general Crl classI don't quite understand what you mean here - we totally own this `Crl` interface and expect both our internal provider impls and external provider impls to use it. We have to have some way for users to create our API representation of CRLsAs for a standalone func vs. a static factory, I'm a fan of keeping it as a static factory for `Crl`s, I think the API is easier to discover and use that way, rather than users having to find the `Crl` type and a different function for creating the `Crl` type",X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34519,1340656685,2023-09-28T20:53:20Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/k8s.py,"@@ -954,6 +951,7 @@ def port_forward_pod(             self._api.context,             self.name,             f""pod/{pod.metadata.name}"",+            pod.metadata.name,","let's use `pod.metadata.uid` instead:> uid: a unique in time and space value (typically an RFC 4122 generated identifier, see [the identifiers docs](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/)) used to distinguish between objects with the same name that have been deleted and recreated>  https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1340682183,2023-09-28T21:23:01Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,82 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <memory>+#include <vector>++#include <openssl/bio.h>+#include <openssl/crypto.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/status/status.h""+#include ""absl/status/statusor.h""++#include <grpc/support/log.h>++namespace grpc_core {+namespace experimental {++CrlImpl::CrlImpl(X509_CRL* crl) : crl_(crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);","Ok made the change - ended up having to override the copy constructor of `CrlImpl` to duplicate the `X509_CRL*` because with this new implementation we create a `CrlImpl` then do `std::make_unique` which copies. Then the temporary `CrlImpl` in the function was freed and it freed the `X509_CRL`, so we got use-after-free issues later. So please take a close look",
52979934,matthewstevenson88,https://api.github.com/repos/grpc/grpc/pulls/33786,1340696403,2023-09-28T21:45:34Z,include/grpc/grpc_crl_provider.h,"@@ -0,0 +1,79 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_GRPC_CRL_PROVIDER_H+#define GRPC_GRPC_CRL_PROVIDER_H++#include <map>+#include <memory>+#include <string>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/support/sync.h>++namespace grpc_core {+namespace experimental {++// Opaque representation of a CRL+class Crl {+ public:+  static absl::StatusOr<std::unique_ptr<Crl>> Parse(","My concern is just that `Parse` uses our default `Crl` implementation, which is not clear from the current code (at least without looking at the implementation). One way to make this would be to move it out of the `Crl` class, but we could also just document what `Parse` does in a comment.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/34400,1340713407,2023-09-28T22:16:13Z,src/core/lib/event_engine/grpc_polled_fd.h,"@@ -47,21 +51,35 @@ class GrpcPolledFd {   virtual bool IsFdStillReadableLocked() = 0;   // Called once and only once. Must cause cancellation of any pending   // read/write callbacks.-  virtual void ShutdownLocked(grpc_error_handle error) = 0;+  virtual void ShutdownLocked(absl::Status error) = 0;   // Get the underlying ares_socket_t that this was created from   virtual ares_socket_t GetWrappedAresSocketLocked() = 0;   // A unique name, for logging   virtual const char* GetName() const = 0; }; +#ifndef GPR_WINDOWS+using GrpcPolledFdReturnType = std::unique_ptr<GrpcPolledFd>;+#else+// On Windows, the GrpcPolledFd is a virtual socket implementation and has a+// shared ownership which is owned by the AresResolver, the GrpcPolledFdFactory+// and pending IOCP callbacks.+using GrpcPolledFdReturnType = std::shared_ptr<GrpcPolledFd>;","If it's not harmful to have Posix use a shared_ptr as well, I'd recommend using the same type for readability. It would remove complexity here, and developer overhead wondering what type they are working with, at the cost of some extra type overhead (ref counting). Since this is not on the fast path, I think that would be better.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/34400,1340720619,2023-09-28T22:29:59Z,src/core/lib/event_engine/windows/grpc_polled_fd_windows.h,"@@ -0,0 +1,210 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H++#include <grpc/support/port_platform.h>++#include ""src/core/lib/iomgr/port.h""  // IWYU pragma: keep++#if GRPC_ARES == 1 && defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)++#include <memory>++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/sync.h""++// TODO(apolcyn): remove this hack after fixing upstream.+// Our grpc/c-ares code on Windows uses the ares_set_socket_functions API,+// which uses ""struct iovec"" type, which on Windows is defined inside of+// a c-ares header that is not public.+// See https://github.com/c-ares/c-ares/issues/206.+struct iovec {+  void* iov_base;+  size_t iov_len;+};++namespace grpc_event_engine {+namespace experimental {++class GrpcPolledFdFactoryWindows : public GrpcPolledFdFactory {+ public:+  explicit GrpcPolledFdFactoryWindows(IOCP* iocp);+  ~GrpcPolledFdFactoryWindows() override = default;++  void Initialize(grpc_core::Mutex* mutex, EventEngine* event_engine) override;+  GrpcPolledFdReturnType NewGrpcPolledFdLocked(ares_socket_t as) override;+  void ConfigureAresChannelLocked(ares_channel channel) override;++ private:+  // c-ares reads and takes action on the error codes of the+  // ""virtual socket operations"" in this file, via the WSAGetLastError+  // APIs. If code in this file wants to set a specific WSA error that+  // c-ares should read, it must do so by calling SetWSAError() on the+  // WSAErrorContext instance passed to it. A WSAErrorContext must only be+  // instantiated at the top of the virtual socket function callstack.+  class WSAErrorContext {+   public:+    explicit WSAErrorContext(){};++    ~WSAErrorContext() {+      if (error_ != 0) {+        WSASetLastError(error_);+      }+    }++    // Disallow copy and assignment operators+    WSAErrorContext(const WSAErrorContext&) = delete;+    WSAErrorContext& operator=(const WSAErrorContext&) = delete;++    void SetWSAError(int error) { error_ = error; }++   private:+    int error_ = 0;+  };++  // c-ares creates its own sockets and is meant to read them when readable and+  // write them when writeable. To fit this socket usage model into the grpc+  // windows poller (which gives notifications when attempted reads and writes+  // are actually fulfilled rather than possible), this GrpcPolledFdWindows+  // class takes advantage of the ares_set_socket_functions API and acts as a+  // virtual socket. It holds its own read and write buffers which are written+  // to and read from c-ares and are used with the grpc windows poller, and it,+  // e.g., manufactures virtual socket error codes when it e.g. needs to tell+  // the c-ares library to wait for an async read.+  class GrpcPolledFdWindows+      : public GrpcPolledFd,+        public std::enable_shared_from_this<GrpcPolledFdWindows> {+   public:+    GrpcPolledFdWindows(std::unique_ptr<WinSocket> winsocket,+                        grpc_core::Mutex* mu, int address_family,+                        int socket_type, EventEngine* event_engine);+    ~GrpcPolledFdWindows() override;++    void RegisterForOnReadableLocked(+        absl::AnyInvocable<void(absl::Status)> read_closure) override;+    void RegisterForOnWriteableLocked(+        absl::AnyInvocable<void(absl::Status)> write_closure) override;+    bool IsFdStillReadableLocked() override;+    void ShutdownLocked(absl::Status error) override;+    ares_socket_t GetWrappedAresSocketLocked() override;+    const char* GetName() const override;++    ares_ssize_t RecvFrom(WSAErrorContext* wsa_error_ctx, void* data,+                          ares_socket_t data_len, int /* flags */,+                          struct sockaddr* from, ares_socklen_t* from_len);+    ares_ssize_t SendV(WSAErrorContext* wsa_error_ctx, const struct iovec* iov,+                       int iov_count);+    int Connect(WSAErrorContext* wsa_error_ctx, const struct sockaddr* target,+                ares_socklen_t target_len);++   private:+    enum WriteState {+      WRITE_IDLE,+      WRITE_REQUESTED,+      WRITE_PENDING,+      WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY,+    };++    void ScheduleAndNullReadClosure(absl::Status error);+    void ScheduleAndNullWriteClosure(absl::Status error);+    void ContinueRegisterForOnReadableLocked();+    void ContinueRegisterForOnWriteableLocked();+    int SendWriteBuf(LPDWORD bytes_sent_ptr, LPWSAOVERLAPPED overlapped,+                     int* wsa_error_code);+    ares_ssize_t SendVUDP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    ares_ssize_t SendVTCP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    void OnTcpConnect();+    int ConnectUDP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    int ConnectTCP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    // TODO(apolcyn): improve this error handling to be less conversative.+    // An e.g. ECONNRESET error here should result in errors when+    // c-ares reads from this socket later, but it shouldn't necessarily cancel+    // the entire resolution attempt. Doing so will allow the ""inject broken+    // nameserver list"" test to pass on Windows.+    void OnIocpReadable();+    void OnIocpWriteable();++    static grpc_slice FlattenIovec(const struct iovec* iov, int iov_count);++    grpc_core::Mutex* mu_;+    std::unique_ptr<WinSocket> winsocket_;+    char recv_from_source_addr_[200];+    ares_socklen_t recv_from_source_addr_len_;+    grpc_slice read_buf_;+    bool read_buf_has_data_ = false;+    grpc_slice write_buf_;+    absl::AnyInvocable<void(absl::Status)> read_closure_;+    absl::AnyInvocable<void(absl::Status)> write_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_read_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_write_closure_;+    const std::string name_;",Consider grouping all const members together at the top of the member variable list.,X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34334,1340721732,2023-09-28T22:32:12Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/gcp/compute.py,"@@ -579,6 +587,20 @@ def _operation_status_done(operation):     def _execute(  # pylint: disable=arguments-differ         self, request, *, timeout_sec=_WAIT_FOR_OPERATION_SEC     ):+        if xds_flags.ENABLE_GFE_DEBUG_HEADER.value:+            old_postproc = request.postproc++            def _log_debug_header(resp, contents):+                if DEBUG_HEADER_IN_RESPONSE in resp:+                    logger.info(+                        ""Received debug headers: %s"",+                        resp[DEBUG_HEADER_IN_RESPONSE],+                    )+                return old_postproc(resp, contents)++            logger.info(""Adding debug headers for method: %s"", request.methodId)+            request.headers[DEBUG_HEADER_KEY] = DEBUG_HEADER_VALUE+            request.postproc = _log_debug_header","Looks like we need `response_callbacks` (see `add_response_callback`) instead of overriding `request.postproc`. It's called just before `postproc`, but not after raising on an HTTP error (which we actually want):```py        for callback in self.response_callbacks:            callback(resp)        if resp.status >= 300:            raise HttpError(resp, content, uri=self.uri)        return self.postproc(resp, content)```https://github.com/googleapis/google-api-python-client/blob/d1bd28f839c8da94d043606ed0b66ab60ff27545/googleapiclient/http.py#L912-L916",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/34400,1340724208,2023-09-28T22:37:13Z,src/core/lib/event_engine/windows/grpc_polled_fd_windows.h,"@@ -0,0 +1,210 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H++#include <grpc/support/port_platform.h>++#include ""src/core/lib/iomgr/port.h""  // IWYU pragma: keep++#if GRPC_ARES == 1 && defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)++#include <memory>++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/sync.h""++// TODO(apolcyn): remove this hack after fixing upstream.+// Our grpc/c-ares code on Windows uses the ares_set_socket_functions API,+// which uses ""struct iovec"" type, which on Windows is defined inside of+// a c-ares header that is not public.+// See https://github.com/c-ares/c-ares/issues/206.+struct iovec {+  void* iov_base;+  size_t iov_len;+};++namespace grpc_event_engine {+namespace experimental {++class GrpcPolledFdFactoryWindows : public GrpcPolledFdFactory {+ public:+  explicit GrpcPolledFdFactoryWindows(IOCP* iocp);+  ~GrpcPolledFdFactoryWindows() override = default;++  void Initialize(grpc_core::Mutex* mutex, EventEngine* event_engine) override;+  GrpcPolledFdReturnType NewGrpcPolledFdLocked(ares_socket_t as) override;+  void ConfigureAresChannelLocked(ares_channel channel) override;++ private:+  // c-ares reads and takes action on the error codes of the+  // ""virtual socket operations"" in this file, via the WSAGetLastError+  // APIs. If code in this file wants to set a specific WSA error that+  // c-ares should read, it must do so by calling SetWSAError() on the+  // WSAErrorContext instance passed to it. A WSAErrorContext must only be+  // instantiated at the top of the virtual socket function callstack.+  class WSAErrorContext {+   public:+    explicit WSAErrorContext(){};++    ~WSAErrorContext() {+      if (error_ != 0) {+        WSASetLastError(error_);+      }+    }++    // Disallow copy and assignment operators+    WSAErrorContext(const WSAErrorContext&) = delete;+    WSAErrorContext& operator=(const WSAErrorContext&) = delete;++    void SetWSAError(int error) { error_ = error; }++   private:+    int error_ = 0;+  };++  // c-ares creates its own sockets and is meant to read them when readable and+  // write them when writeable. To fit this socket usage model into the grpc+  // windows poller (which gives notifications when attempted reads and writes+  // are actually fulfilled rather than possible), this GrpcPolledFdWindows+  // class takes advantage of the ares_set_socket_functions API and acts as a+  // virtual socket. It holds its own read and write buffers which are written+  // to and read from c-ares and are used with the grpc windows poller, and it,+  // e.g., manufactures virtual socket error codes when it e.g. needs to tell+  // the c-ares library to wait for an async read.+  class GrpcPolledFdWindows+      : public GrpcPolledFd,+        public std::enable_shared_from_this<GrpcPolledFdWindows> {+   public:+    GrpcPolledFdWindows(std::unique_ptr<WinSocket> winsocket,+                        grpc_core::Mutex* mu, int address_family,+                        int socket_type, EventEngine* event_engine);+    ~GrpcPolledFdWindows() override;++    void RegisterForOnReadableLocked(+        absl::AnyInvocable<void(absl::Status)> read_closure) override;+    void RegisterForOnWriteableLocked(+        absl::AnyInvocable<void(absl::Status)> write_closure) override;+    bool IsFdStillReadableLocked() override;+    void ShutdownLocked(absl::Status error) override;+    ares_socket_t GetWrappedAresSocketLocked() override;+    const char* GetName() const override;++    ares_ssize_t RecvFrom(WSAErrorContext* wsa_error_ctx, void* data,+                          ares_socket_t data_len, int /* flags */,+                          struct sockaddr* from, ares_socklen_t* from_len);+    ares_ssize_t SendV(WSAErrorContext* wsa_error_ctx, const struct iovec* iov,+                       int iov_count);+    int Connect(WSAErrorContext* wsa_error_ctx, const struct sockaddr* target,+                ares_socklen_t target_len);++   private:+    enum WriteState {+      WRITE_IDLE,+      WRITE_REQUESTED,+      WRITE_PENDING,+      WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY,+    };++    void ScheduleAndNullReadClosure(absl::Status error);+    void ScheduleAndNullWriteClosure(absl::Status error);+    void ContinueRegisterForOnReadableLocked();+    void ContinueRegisterForOnWriteableLocked();+    int SendWriteBuf(LPDWORD bytes_sent_ptr, LPWSAOVERLAPPED overlapped,+                     int* wsa_error_code);+    ares_ssize_t SendVUDP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    ares_ssize_t SendVTCP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    void OnTcpConnect();+    int ConnectUDP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    int ConnectTCP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    // TODO(apolcyn): improve this error handling to be less conversative.+    // An e.g. ECONNRESET error here should result in errors when+    // c-ares reads from this socket later, but it shouldn't necessarily cancel+    // the entire resolution attempt. Doing so will allow the ""inject broken+    // nameserver list"" test to pass on Windows.+    void OnIocpReadable();+    void OnIocpWriteable();++    static grpc_slice FlattenIovec(const struct iovec* iov, int iov_count);++    grpc_core::Mutex* mu_;+    std::unique_ptr<WinSocket> winsocket_;+    char recv_from_source_addr_[200];+    ares_socklen_t recv_from_source_addr_len_;+    grpc_slice read_buf_;+    bool read_buf_has_data_ = false;+    grpc_slice write_buf_;+    absl::AnyInvocable<void(absl::Status)> read_closure_;+    absl::AnyInvocable<void(absl::Status)> write_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_read_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_write_closure_;+    const std::string name_;+    bool shutdown_called_ = false;+    int address_family_;+    int socket_type_;+    // State related to TCP sockets+    AnyInvocableClosure on_tcp_connect_locked_;+    bool connect_done_ = false;+    int wsa_connect_error_ = 0;+    WriteState tcp_write_state_ = WRITE_IDLE;+    // We don't run register_for_{readable,writeable} logic until+    // a socket is connected. In the interim, we queue readable/writeable+    // registrations with the following state.+    bool pending_continue_register_for_on_readable_locked_ = false;+    bool pending_continue_register_for_on_writeable_locked_ = false;+    EventEngine* event_engine_;+  };++  // These virtual socket functions are called from within the c-ares+  // library. These methods generally dispatch those socket calls to the+  // appropriate methods. The virtual ""socket"" and ""close"" methods are+  // special and instead create/add and remove/destroy GrpcPolledFdWindows+  // objects.+  static ares_socket_t Socket(int af, int type, int protocol, void* user_data);","This requires explanation as to why they need to be static members of this class (access to private classes). As an alternative, this could also be done as a friend class of static methodr, to keep the declarations out of the header.",X
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/34400,1340733149,2023-09-28T22:57:04Z,src/core/lib/event_engine/windows/grpc_polled_fd_windows.cc,"@@ -0,0 +1,711 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#include <grpc/support/port_platform.h>++#include ""src/core/lib/iomgr/port.h""  // IWYU pragma: keep++#if GRPC_ARES == 1 && defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)++#include <winsock2.h>++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/support/log_windows.h>++#include ""src/core/lib/address_utils/sockaddr_utils.h""+#include ""src/core/lib/event_engine/ares_resolver.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/windows/grpc_polled_fd_windows.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/debug_location.h""+#include ""src/core/lib/gprpp/sync.h""+#include ""src/core/lib/iomgr/error.h""+#include ""src/core/lib/slice/slice.h""++namespace grpc_event_engine {+namespace experimental {++GrpcPolledFdFactoryWindows::GrpcPolledFdWindows::GrpcPolledFdWindows(+    std::unique_ptr<WinSocket> winsocket, grpc_core::Mutex* mu,+    int address_family, int socket_type, EventEngine* event_engine)+    : mu_(mu),+      winsocket_(std::move(winsocket)),+      read_buf_(grpc_empty_slice()),+      write_buf_(grpc_empty_slice()),+      name_(absl::StrFormat(""c-ares socket: %"" PRIdPTR,+                            winsocket_->raw_socket())),+      address_family_(address_family),+      socket_type_(socket_type),+      on_tcp_connect_locked_([this]() { OnTcpConnect(); }),+      event_engine_(event_engine) {}++GrpcPolledFdFactoryWindows::GrpcPolledFdWindows::~GrpcPolledFdWindows() {+  GRPC_ARES_RESOLVER_TRACE_LOG(+      ""fd:|%s| ~GrpcPolledFdWindows shutdown_called_: %d "", GetName(),+      shutdown_called_);+  grpc_core::CSliceUnref(read_buf_);+  grpc_core::CSliceUnref(write_buf_);+  GPR_ASSERT(read_closure_ == nullptr);+  GPR_ASSERT(write_closure_ == nullptr);+  if (!shutdown_called_) {+    winsocket_->Shutdown(DEBUG_LOCATION, ""~GrpcPolledFdWindows"");+  }+}++void GrpcPolledFdFactoryWindows::GrpcPolledFdWindows::+    ScheduleAndNullReadClosure(absl::Status error) {+  event_engine_->Run([read_closure = std::move(read_closure_),+                      error]() mutable { read_closure(error); });+  read_closure_ = nullptr;+}++void GrpcPolledFdFactoryWindows::GrpcPolledFdWindows::+    ScheduleAndNullWriteClosure(absl::Status error) {+  event_engine_->Run([write_closure = std::move(write_closure_),+                      error]() mutable { write_closure(error); });+  write_closure_ = nullptr;+}++void GrpcPolledFdFactoryWindows::GrpcPolledFdWindows::+    RegisterForOnReadableLocked(+        absl::AnyInvocable<void(absl::Status)> read_closure) {+  GPR_ASSERT(read_closure_ == nullptr);+  read_closure_ = std::move(read_closure);+  grpc_core::CSliceUnref(read_buf_);+  GPR_ASSERT(!read_buf_has_data_);+  read_buf_ = GRPC_SLICE_MALLOC(4192);+  if (connect_done_) {+    ContinueRegisterForOnReadableLocked();+  } else {+    GPR_ASSERT(pending_continue_register_for_on_readable_locked_ == false);+    pending_continue_register_for_on_readable_locked_ = true;+  }+}++void GrpcPolledFdFactoryWindows::GrpcPolledFdWindows::+    ContinueRegisterForOnReadableLocked() {+  GRPC_ARES_RESOLVER_TRACE_LOG(+      ""fd:|%s| ContinueRegisterForOnReadableLocked ""+      ""wsa_connect_error_:%d"",+      GetName(), wsa_connect_error_);+  GPR_ASSERT(connect_done_);+  if (wsa_connect_error_ != 0) {+    ScheduleAndNullReadClosure(GRPC_WSA_ERROR(wsa_connect_error_, ""connect""));+    return;+  }+  WSABUF buffer;+  buffer.buf = reinterpret_cast<char*>(GRPC_SLICE_START_PTR(read_buf_));+  buffer.len = GRPC_SLICE_LENGTH(read_buf_);+  memset(winsocket_->read_info()->overlapped(), 0, sizeof(OVERLAPPED));+  recv_from_source_addr_len_ = sizeof(recv_from_source_addr_);+  DWORD flags = 0;+  if (WSARecvFrom(winsocket_->raw_socket(), &buffer, 1, nullptr, &flags,","since this is a C-ism, it might be worth comparing explicitly against 0 to better indicate error conditions.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/33460,1340740775,2023-09-28T23:11:13Z,tools/run_tests/xds_k8s_test_driver/bin/cleanup/cleanup.py,"@@ -129,7 +170,7 @@ def get_expire_timestamp() -> datetime.datetime:     )  -def exec_gcloud(project: str, *cmds: List[str]) -> Json:+def exec_gcloud(project: str, *cmds: str) -> Json:","Nothing changed, it's just the correct way to annotate `*args`. From  https://peps.python.org/pep-0484/#arbitrary-argument-lists-and-default-argument-values:```pydef foo(*args: str, **kwds: int): ...```is acceptable and it means that, e.g., all of the following represent function calls with valid types of arguments:```pyfoo('a', 'b', 'c')foo(x=1, y=2)foo('', z=0)```---So by this logic, ```pyfoo(*cmds: List[str])``` would mean that```pyfoo(['a', 'b'], ['c', 'd'], ...)```is expected",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34334,1340751515,2023-09-28T23:37:24Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/gcp/compute.py,"@@ -48,9 +53,11 @@ def __init__(         self,         api_manager: gcp.api.GcpApiManager,         project: str,+        gfe_debug_header: str,         version: str = ""v1"",     ):         super().__init__(api_manager.compute(version), project)+        self.gfe_debug_header = gfe_debug_header",nit: add class property annotation `gfe_debug_header: Optional[str]`,
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34334,1340753091,2023-09-28T23:41:45Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/gcp/compute.py,"@@ -579,6 +586,18 @@ def _operation_status_done(operation):     def _execute(  # pylint: disable=arguments-differ         self, request, *, timeout_sec=_WAIT_FOR_OPERATION_SEC     ):+        if self.gfe_debug_header != DISABLE_DEBUG_HEADER_VALUE:++            def _log_debug_header(resp):",Since we're not using local vars to restore the previous postproc anymore - no need to make it an inner method. Let's make it a class method.,X
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34334,1340771642,2023-09-29T00:34:00Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/gcp/compute.py,"@@ -48,9 +53,11 @@ def __init__(         self,         api_manager: gcp.api.GcpApiManager,         project: str,+        gfe_debug_header: str,","it won't accept it in the list of values, but it'll happily accepted in default:> `default: str|None, the default value of the flag.`> https://github.com/abseil/abseil-py/blob/b188d9080c8e5628bb52a93a04ad930abb1717eb/absl/flags/_defines.py#L439",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34334,1340786074,2023-09-29T01:19:20Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/gcp/compute.py,"@@ -44,13 +49,22 @@ class GcpResource:     class ZonalGcpResource(GcpResource):         zone: str +    def _log_debug_header(self, resp: httplib2.Response):","```suggestion    @classmethod    def _log_debug_header(cls, resp: httplib2.Response):```",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1341461346,2023-09-29T14:50:01Z,src/core/tsi/ssl_transport_security.cc,"@@ -953,6 +960,58 @@ static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {   return preverify_ok; } +// X509_STORE_set_get_crl() sets the function to get the crl for a given+// certificate x. When found, the crl must be assigned to *crl. This function+// must return 0 on failure and 1 on success. If no function to get the issuer+// is provided, the internal default function will be used instead.+static int GetCrlFromProvider(X509_STORE_CTX* ctx, X509_CRL** crl_out,+                              X509* x) {+  SSL* ssl = static_cast<SSL*>(+      X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx()));+  if (ssl == nullptr) {+    gpr_log(GPR_ERROR,+            ""error while fetching from CrlProvider. SSL object is null"");+    return 0;+  }++  SSL_CTX* ssl_ctx = SSL_get_SSL_CTX(ssl);+  grpc_core::experimental::CrlProvider* provider =+      static_cast<grpc_core::experimental::CrlProvider*>(+          SSL_CTX_get_ex_data(ssl_ctx, g_ssl_ctx_ex_crl_provider_index));++  char* buf = X509_NAME_oneline(X509_get_issuer_name(x), nullptr, 0);+  grpc_core::experimental::CertificateInfoImpl cert_impl =+      grpc_core::experimental::CertificateInfoImpl(buf);+  std::shared_ptr<grpc_core::experimental::Crl> internal_crl =+      provider->GetCrl(cert_impl);+  OPENSSL_free(buf);+  // There wasn't a CRL found in the provider. Returning 0 will end up causing+  // OpenSSL to return X509_V_ERR_UNABLE_TO_GET_CRL. We then catch that error+  // and behave how we want for a missing CRL.+  // It is important to treat missing CRLs and empty CRLs differently.+  if (internal_crl == nullptr) {","I think we were talking about logging if `buf == nullptr` which is a few lines up`internal_crl == nullptr` is totally reasonable behavior - we've actually gotten bug tickets for log spam for logging about this before. We don't require CRLs for every issuer, so not finding a CRL isn't necessarily something to log aboutUp the chain returning `0` here makes OpenSSL return `X509_V_ERR_UNABLE_TO_GET_CRL`, which we then look for later. I think that's the appropriate place to have logs about this",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1341495149,2023-09-29T15:17:25Z,test/core/tsi/crl_ssl_transport_security_test.cc,"@@ -296,31 +249,25 @@ class CrlSslTransportSecurityTest       delete self;     } -    static char* LoadFile(absl::string_view file_path) {-      grpc_slice slice;-      GPR_ASSERT(grpc_load_file(file_path.data(), 1, &slice) ==-                 absl::OkStatus());-      char* data = grpc_slice_to_c_string(slice);-      grpc_slice_unref(slice);-      return data;-    }-     static struct tsi_test_fixture_vtable kVtable;      tsi_test_fixture base_;-    bool use_revoked_server_cert_;-    bool use_revoked_client_cert_;-    bool use_faulty_crl_directory_;-    bool use_revoked_intermediate_;-    bool use_missing_intermediate_crl_;-    bool use_missing_root_crl_;     char* root_cert_;     tsi_ssl_root_certs_store* root_store_;-    tsi_ssl_pem_key_cert_pair* revoked_pem_key_cert_pairs_;-    tsi_ssl_pem_key_cert_pair* valid_pem_key_cert_pairs_;-    tsi_ssl_pem_key_cert_pair* revoked_intermediate_pem_key_cert_pairs_;     tsi_ssl_server_handshaker_factory* server_handshaker_factory_;     tsi_ssl_client_handshaker_factory* client_handshaker_factory_;++    char* server_key_;","I converted everything except `crl_directory_` to `std::string` in commit hash `7a9239a3bf`, it's important that `crl_directory_` be able to be `nullptr`. Figured it was easy to do that directly instead of having to have blocks like```if (crl_directory.empty()) { opts.crl_directory = nullptr else {opts.crl_directory = crl_directory}```I think this also results in more copies of the strings representing the entire files, but I don't think anything is particularly large. PTAL and let me know what you think, it'll be easy to revert if we want to keep the `char*`.It did make the memory management cleaner, `ccbc5301e3` I removed all the handling for freeing the `char*`s",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/34400,1343060057,2023-10-02T19:11:42Z,src/core/lib/event_engine/windows/grpc_polled_fd_windows.h,"@@ -0,0 +1,210 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H++#include <grpc/support/port_platform.h>++#include ""src/core/lib/iomgr/port.h""  // IWYU pragma: keep++#if GRPC_ARES == 1 && defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)++#include <memory>++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/sync.h""++// TODO(apolcyn): remove this hack after fixing upstream.+// Our grpc/c-ares code on Windows uses the ares_set_socket_functions API,+// which uses ""struct iovec"" type, which on Windows is defined inside of+// a c-ares header that is not public.+// See https://github.com/c-ares/c-ares/issues/206.+struct iovec {+  void* iov_base;+  size_t iov_len;+};++namespace grpc_event_engine {+namespace experimental {++class GrpcPolledFdFactoryWindows : public GrpcPolledFdFactory {+ public:+  explicit GrpcPolledFdFactoryWindows(IOCP* iocp);+  ~GrpcPolledFdFactoryWindows() override = default;++  void Initialize(grpc_core::Mutex* mutex, EventEngine* event_engine) override;+  GrpcPolledFdReturnType NewGrpcPolledFdLocked(ares_socket_t as) override;+  void ConfigureAresChannelLocked(ares_channel channel) override;++ private:+  // c-ares reads and takes action on the error codes of the+  // ""virtual socket operations"" in this file, via the WSAGetLastError+  // APIs. If code in this file wants to set a specific WSA error that+  // c-ares should read, it must do so by calling SetWSAError() on the+  // WSAErrorContext instance passed to it. A WSAErrorContext must only be+  // instantiated at the top of the virtual socket function callstack.+  class WSAErrorContext {+   public:+    explicit WSAErrorContext(){};++    ~WSAErrorContext() {+      if (error_ != 0) {+        WSASetLastError(error_);+      }+    }++    // Disallow copy and assignment operators+    WSAErrorContext(const WSAErrorContext&) = delete;+    WSAErrorContext& operator=(const WSAErrorContext&) = delete;++    void SetWSAError(int error) { error_ = error; }++   private:+    int error_ = 0;+  };++  // c-ares creates its own sockets and is meant to read them when readable and+  // write them when writeable. To fit this socket usage model into the grpc+  // windows poller (which gives notifications when attempted reads and writes+  // are actually fulfilled rather than possible), this GrpcPolledFdWindows+  // class takes advantage of the ares_set_socket_functions API and acts as a+  // virtual socket. It holds its own read and write buffers which are written+  // to and read from c-ares and are used with the grpc windows poller, and it,+  // e.g., manufactures virtual socket error codes when it e.g. needs to tell+  // the c-ares library to wait for an async read.+  class GrpcPolledFdWindows+      : public GrpcPolledFd,+        public std::enable_shared_from_this<GrpcPolledFdWindows> {+   public:+    GrpcPolledFdWindows(std::unique_ptr<WinSocket> winsocket,+                        grpc_core::Mutex* mu, int address_family,+                        int socket_type, EventEngine* event_engine);+    ~GrpcPolledFdWindows() override;++    void RegisterForOnReadableLocked(+        absl::AnyInvocable<void(absl::Status)> read_closure) override;+    void RegisterForOnWriteableLocked(+        absl::AnyInvocable<void(absl::Status)> write_closure) override;+    bool IsFdStillReadableLocked() override;+    void ShutdownLocked(absl::Status error) override;+    ares_socket_t GetWrappedAresSocketLocked() override;+    const char* GetName() const override;++    ares_ssize_t RecvFrom(WSAErrorContext* wsa_error_ctx, void* data,+                          ares_socket_t data_len, int /* flags */,+                          struct sockaddr* from, ares_socklen_t* from_len);+    ares_ssize_t SendV(WSAErrorContext* wsa_error_ctx, const struct iovec* iov,+                       int iov_count);+    int Connect(WSAErrorContext* wsa_error_ctx, const struct sockaddr* target,+                ares_socklen_t target_len);++   private:+    enum WriteState {+      WRITE_IDLE,+      WRITE_REQUESTED,+      WRITE_PENDING,+      WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY,+    };++    void ScheduleAndNullReadClosure(absl::Status error);+    void ScheduleAndNullWriteClosure(absl::Status error);+    void ContinueRegisterForOnReadableLocked();+    void ContinueRegisterForOnWriteableLocked();+    int SendWriteBuf(LPDWORD bytes_sent_ptr, LPWSAOVERLAPPED overlapped,+                     int* wsa_error_code);+    ares_ssize_t SendVUDP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    ares_ssize_t SendVTCP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    void OnTcpConnect();+    int ConnectUDP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    int ConnectTCP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    // TODO(apolcyn): improve this error handling to be less conversative.+    // An e.g. ECONNRESET error here should result in errors when+    // c-ares reads from this socket later, but it shouldn't necessarily cancel+    // the entire resolution attempt. Doing so will allow the ""inject broken+    // nameserver list"" test to pass on Windows.+    void OnIocpReadable();+    void OnIocpWriteable();++    static grpc_slice FlattenIovec(const struct iovec* iov, int iov_count);++    grpc_core::Mutex* mu_;+    std::unique_ptr<WinSocket> winsocket_;+    char recv_from_source_addr_[200];",Done. This buffer is used to store the sockaddr struct of the source address read from the packet. I guess 200 is a big enough size.,
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/34400,1343067112,2023-10-02T19:20:29Z,src/core/lib/event_engine/windows/grpc_polled_fd_windows.h,"@@ -0,0 +1,210 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H++#include <grpc/support/port_platform.h>++#include ""src/core/lib/iomgr/port.h""  // IWYU pragma: keep++#if GRPC_ARES == 1 && defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)++#include <memory>++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/sync.h""++// TODO(apolcyn): remove this hack after fixing upstream.+// Our grpc/c-ares code on Windows uses the ares_set_socket_functions API,+// which uses ""struct iovec"" type, which on Windows is defined inside of+// a c-ares header that is not public.+// See https://github.com/c-ares/c-ares/issues/206.+struct iovec {+  void* iov_base;+  size_t iov_len;+};++namespace grpc_event_engine {+namespace experimental {++class GrpcPolledFdFactoryWindows : public GrpcPolledFdFactory {+ public:+  explicit GrpcPolledFdFactoryWindows(IOCP* iocp);+  ~GrpcPolledFdFactoryWindows() override = default;++  void Initialize(grpc_core::Mutex* mutex, EventEngine* event_engine) override;+  GrpcPolledFdReturnType NewGrpcPolledFdLocked(ares_socket_t as) override;+  void ConfigureAresChannelLocked(ares_channel channel) override;++ private:+  // c-ares reads and takes action on the error codes of the+  // ""virtual socket operations"" in this file, via the WSAGetLastError+  // APIs. If code in this file wants to set a specific WSA error that+  // c-ares should read, it must do so by calling SetWSAError() on the+  // WSAErrorContext instance passed to it. A WSAErrorContext must only be+  // instantiated at the top of the virtual socket function callstack.+  class WSAErrorContext {+   public:+    explicit WSAErrorContext(){};++    ~WSAErrorContext() {+      if (error_ != 0) {+        WSASetLastError(error_);+      }+    }++    // Disallow copy and assignment operators+    WSAErrorContext(const WSAErrorContext&) = delete;+    WSAErrorContext& operator=(const WSAErrorContext&) = delete;++    void SetWSAError(int error) { error_ = error; }++   private:+    int error_ = 0;+  };++  // c-ares creates its own sockets and is meant to read them when readable and+  // write them when writeable. To fit this socket usage model into the grpc+  // windows poller (which gives notifications when attempted reads and writes+  // are actually fulfilled rather than possible), this GrpcPolledFdWindows+  // class takes advantage of the ares_set_socket_functions API and acts as a+  // virtual socket. It holds its own read and write buffers which are written+  // to and read from c-ares and are used with the grpc windows poller, and it,+  // e.g., manufactures virtual socket error codes when it e.g. needs to tell+  // the c-ares library to wait for an async read.+  class GrpcPolledFdWindows+      : public GrpcPolledFd,+        public std::enable_shared_from_this<GrpcPolledFdWindows> {+   public:+    GrpcPolledFdWindows(std::unique_ptr<WinSocket> winsocket,+                        grpc_core::Mutex* mu, int address_family,+                        int socket_type, EventEngine* event_engine);+    ~GrpcPolledFdWindows() override;++    void RegisterForOnReadableLocked(+        absl::AnyInvocable<void(absl::Status)> read_closure) override;+    void RegisterForOnWriteableLocked(+        absl::AnyInvocable<void(absl::Status)> write_closure) override;+    bool IsFdStillReadableLocked() override;+    void ShutdownLocked(absl::Status error) override;+    ares_socket_t GetWrappedAresSocketLocked() override;+    const char* GetName() const override;++    ares_ssize_t RecvFrom(WSAErrorContext* wsa_error_ctx, void* data,+                          ares_socket_t data_len, int /* flags */,+                          struct sockaddr* from, ares_socklen_t* from_len);+    ares_ssize_t SendV(WSAErrorContext* wsa_error_ctx, const struct iovec* iov,+                       int iov_count);+    int Connect(WSAErrorContext* wsa_error_ctx, const struct sockaddr* target,+                ares_socklen_t target_len);++   private:+    enum WriteState {+      WRITE_IDLE,+      WRITE_REQUESTED,+      WRITE_PENDING,+      WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY,+    };++    void ScheduleAndNullReadClosure(absl::Status error);+    void ScheduleAndNullWriteClosure(absl::Status error);+    void ContinueRegisterForOnReadableLocked();+    void ContinueRegisterForOnWriteableLocked();+    int SendWriteBuf(LPDWORD bytes_sent_ptr, LPWSAOVERLAPPED overlapped,+                     int* wsa_error_code);+    ares_ssize_t SendVUDP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    ares_ssize_t SendVTCP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    void OnTcpConnect();+    int ConnectUDP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    int ConnectTCP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    // TODO(apolcyn): improve this error handling to be less conversative.+    // An e.g. ECONNRESET error here should result in errors when+    // c-ares reads from this socket later, but it shouldn't necessarily cancel+    // the entire resolution attempt. Doing so will allow the ""inject broken+    // nameserver list"" test to pass on Windows.+    void OnIocpReadable();+    void OnIocpWriteable();++    static grpc_slice FlattenIovec(const struct iovec* iov, int iov_count);++    grpc_core::Mutex* mu_;+    std::unique_ptr<WinSocket> winsocket_;+    char recv_from_source_addr_[200];+    ares_socklen_t recv_from_source_addr_len_;+    grpc_slice read_buf_;+    bool read_buf_has_data_ = false;+    grpc_slice write_buf_;+    absl::AnyInvocable<void(absl::Status)> read_closure_;+    absl::AnyInvocable<void(absl::Status)> write_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_read_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_write_closure_;+    const std::string name_;+    bool shutdown_called_ = false;+    int address_family_;","Some member variables do not have default value, e.g. `name_`, `address_family_`, `socket_type_`, and are set in the constructor's initializer list.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/34400,1343102002,2023-10-02T20:02:46Z,src/core/lib/event_engine/windows/grpc_polled_fd_windows.h,"@@ -0,0 +1,210 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H++#include <grpc/support/port_platform.h>++#include ""src/core/lib/iomgr/port.h""  // IWYU pragma: keep++#if GRPC_ARES == 1 && defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)++#include <memory>++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/sync.h""++// TODO(apolcyn): remove this hack after fixing upstream.+// Our grpc/c-ares code on Windows uses the ares_set_socket_functions API,+// which uses ""struct iovec"" type, which on Windows is defined inside of+// a c-ares header that is not public.+// See https://github.com/c-ares/c-ares/issues/206.+struct iovec {+  void* iov_base;+  size_t iov_len;+};++namespace grpc_event_engine {+namespace experimental {++class GrpcPolledFdFactoryWindows : public GrpcPolledFdFactory {+ public:+  explicit GrpcPolledFdFactoryWindows(IOCP* iocp);+  ~GrpcPolledFdFactoryWindows() override = default;++  void Initialize(grpc_core::Mutex* mutex, EventEngine* event_engine) override;+  GrpcPolledFdReturnType NewGrpcPolledFdLocked(ares_socket_t as) override;+  void ConfigureAresChannelLocked(ares_channel channel) override;++ private:+  // c-ares reads and takes action on the error codes of the+  // ""virtual socket operations"" in this file, via the WSAGetLastError+  // APIs. If code in this file wants to set a specific WSA error that+  // c-ares should read, it must do so by calling SetWSAError() on the+  // WSAErrorContext instance passed to it. A WSAErrorContext must only be+  // instantiated at the top of the virtual socket function callstack.+  class WSAErrorContext {+   public:+    explicit WSAErrorContext(){};++    ~WSAErrorContext() {+      if (error_ != 0) {+        WSASetLastError(error_);+      }+    }++    // Disallow copy and assignment operators+    WSAErrorContext(const WSAErrorContext&) = delete;+    WSAErrorContext& operator=(const WSAErrorContext&) = delete;++    void SetWSAError(int error) { error_ = error; }++   private:+    int error_ = 0;+  };++  // c-ares creates its own sockets and is meant to read them when readable and+  // write them when writeable. To fit this socket usage model into the grpc+  // windows poller (which gives notifications when attempted reads and writes+  // are actually fulfilled rather than possible), this GrpcPolledFdWindows+  // class takes advantage of the ares_set_socket_functions API and acts as a+  // virtual socket. It holds its own read and write buffers which are written+  // to and read from c-ares and are used with the grpc windows poller, and it,+  // e.g., manufactures virtual socket error codes when it e.g. needs to tell+  // the c-ares library to wait for an async read.+  class GrpcPolledFdWindows+      : public GrpcPolledFd,+        public std::enable_shared_from_this<GrpcPolledFdWindows> {+   public:+    GrpcPolledFdWindows(std::unique_ptr<WinSocket> winsocket,+                        grpc_core::Mutex* mu, int address_family,+                        int socket_type, EventEngine* event_engine);+    ~GrpcPolledFdWindows() override;++    void RegisterForOnReadableLocked(+        absl::AnyInvocable<void(absl::Status)> read_closure) override;+    void RegisterForOnWriteableLocked(+        absl::AnyInvocable<void(absl::Status)> write_closure) override;+    bool IsFdStillReadableLocked() override;+    void ShutdownLocked(absl::Status error) override;+    ares_socket_t GetWrappedAresSocketLocked() override;+    const char* GetName() const override;++    ares_ssize_t RecvFrom(WSAErrorContext* wsa_error_ctx, void* data,+                          ares_socket_t data_len, int /* flags */,+                          struct sockaddr* from, ares_socklen_t* from_len);+    ares_ssize_t SendV(WSAErrorContext* wsa_error_ctx, const struct iovec* iov,+                       int iov_count);+    int Connect(WSAErrorContext* wsa_error_ctx, const struct sockaddr* target,+                ares_socklen_t target_len);++   private:+    enum WriteState {+      WRITE_IDLE,+      WRITE_REQUESTED,+      WRITE_PENDING,+      WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY,+    };++    void ScheduleAndNullReadClosure(absl::Status error);+    void ScheduleAndNullWriteClosure(absl::Status error);+    void ContinueRegisterForOnReadableLocked();+    void ContinueRegisterForOnWriteableLocked();+    int SendWriteBuf(LPDWORD bytes_sent_ptr, LPWSAOVERLAPPED overlapped,+                     int* wsa_error_code);+    ares_ssize_t SendVUDP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    ares_ssize_t SendVTCP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    void OnTcpConnect();+    int ConnectUDP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    int ConnectTCP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    // TODO(apolcyn): improve this error handling to be less conversative.+    // An e.g. ECONNRESET error here should result in errors when+    // c-ares reads from this socket later, but it shouldn't necessarily cancel+    // the entire resolution attempt. Doing so will allow the ""inject broken+    // nameserver list"" test to pass on Windows.+    void OnIocpReadable();+    void OnIocpWriteable();++    static grpc_slice FlattenIovec(const struct iovec* iov, int iov_count);++    grpc_core::Mutex* mu_;+    std::unique_ptr<WinSocket> winsocket_;+    char recv_from_source_addr_[200];+    ares_socklen_t recv_from_source_addr_len_;+    grpc_slice read_buf_;+    bool read_buf_has_data_ = false;+    grpc_slice write_buf_;+    absl::AnyInvocable<void(absl::Status)> read_closure_;+    absl::AnyInvocable<void(absl::Status)> write_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_read_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_write_closure_;+    const std::string name_;+    bool shutdown_called_ = false;+    int address_family_;","No argument there. I'm suggesting that for consistency, the things known at compile time can be initialized together in one place (default class values, or specified in an initializer list, but preferably not both).",
5663878,yijiem,https://api.github.com/repos/grpc/grpc/pulls/34400,1343258029,2023-10-02T23:36:24Z,src/core/lib/event_engine/windows/grpc_polled_fd_windows.h,"@@ -0,0 +1,210 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H++#include <grpc/support/port_platform.h>++#include ""src/core/lib/iomgr/port.h""  // IWYU pragma: keep++#if GRPC_ARES == 1 && defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)++#include <memory>++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/sync.h""++// TODO(apolcyn): remove this hack after fixing upstream.+// Our grpc/c-ares code on Windows uses the ares_set_socket_functions API,+// which uses ""struct iovec"" type, which on Windows is defined inside of+// a c-ares header that is not public.+// See https://github.com/c-ares/c-ares/issues/206.+struct iovec {+  void* iov_base;+  size_t iov_len;+};++namespace grpc_event_engine {+namespace experimental {++class GrpcPolledFdFactoryWindows : public GrpcPolledFdFactory {+ public:+  explicit GrpcPolledFdFactoryWindows(IOCP* iocp);+  ~GrpcPolledFdFactoryWindows() override = default;++  void Initialize(grpc_core::Mutex* mutex, EventEngine* event_engine) override;+  GrpcPolledFdReturnType NewGrpcPolledFdLocked(ares_socket_t as) override;+  void ConfigureAresChannelLocked(ares_channel channel) override;++ private:+  // c-ares reads and takes action on the error codes of the+  // ""virtual socket operations"" in this file, via the WSAGetLastError+  // APIs. If code in this file wants to set a specific WSA error that+  // c-ares should read, it must do so by calling SetWSAError() on the+  // WSAErrorContext instance passed to it. A WSAErrorContext must only be+  // instantiated at the top of the virtual socket function callstack.+  class WSAErrorContext {+   public:+    explicit WSAErrorContext(){};++    ~WSAErrorContext() {+      if (error_ != 0) {+        WSASetLastError(error_);+      }+    }++    // Disallow copy and assignment operators+    WSAErrorContext(const WSAErrorContext&) = delete;+    WSAErrorContext& operator=(const WSAErrorContext&) = delete;++    void SetWSAError(int error) { error_ = error; }++   private:+    int error_ = 0;+  };++  // c-ares creates its own sockets and is meant to read them when readable and+  // write them when writeable. To fit this socket usage model into the grpc+  // windows poller (which gives notifications when attempted reads and writes+  // are actually fulfilled rather than possible), this GrpcPolledFdWindows+  // class takes advantage of the ares_set_socket_functions API and acts as a+  // virtual socket. It holds its own read and write buffers which are written+  // to and read from c-ares and are used with the grpc windows poller, and it,+  // e.g., manufactures virtual socket error codes when it e.g. needs to tell+  // the c-ares library to wait for an async read.+  class GrpcPolledFdWindows+      : public GrpcPolledFd,+        public std::enable_shared_from_this<GrpcPolledFdWindows> {+   public:+    GrpcPolledFdWindows(std::unique_ptr<WinSocket> winsocket,+                        grpc_core::Mutex* mu, int address_family,+                        int socket_type, EventEngine* event_engine);+    ~GrpcPolledFdWindows() override;++    void RegisterForOnReadableLocked(+        absl::AnyInvocable<void(absl::Status)> read_closure) override;+    void RegisterForOnWriteableLocked(+        absl::AnyInvocable<void(absl::Status)> write_closure) override;+    bool IsFdStillReadableLocked() override;+    void ShutdownLocked(absl::Status error) override;+    ares_socket_t GetWrappedAresSocketLocked() override;+    const char* GetName() const override;++    ares_ssize_t RecvFrom(WSAErrorContext* wsa_error_ctx, void* data,+                          ares_socket_t data_len, int /* flags */,+                          struct sockaddr* from, ares_socklen_t* from_len);+    ares_ssize_t SendV(WSAErrorContext* wsa_error_ctx, const struct iovec* iov,+                       int iov_count);+    int Connect(WSAErrorContext* wsa_error_ctx, const struct sockaddr* target,+                ares_socklen_t target_len);++   private:+    enum WriteState {+      WRITE_IDLE,+      WRITE_REQUESTED,+      WRITE_PENDING,+      WRITE_WAITING_FOR_VERIFICATION_UPON_RETRY,+    };++    void ScheduleAndNullReadClosure(absl::Status error);+    void ScheduleAndNullWriteClosure(absl::Status error);+    void ContinueRegisterForOnReadableLocked();+    void ContinueRegisterForOnWriteableLocked();+    int SendWriteBuf(LPDWORD bytes_sent_ptr, LPWSAOVERLAPPED overlapped,+                     int* wsa_error_code);+    ares_ssize_t SendVUDP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    ares_ssize_t SendVTCP(WSAErrorContext* wsa_error_ctx,+                          const struct iovec* iov, int iov_count);+    void OnTcpConnect();+    int ConnectUDP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    int ConnectTCP(WSAErrorContext* wsa_error_ctx,+                   const struct sockaddr* target, ares_socklen_t target_len);+    // TODO(apolcyn): improve this error handling to be less conversative.+    // An e.g. ECONNRESET error here should result in errors when+    // c-ares reads from this socket later, but it shouldn't necessarily cancel+    // the entire resolution attempt. Doing so will allow the ""inject broken+    // nameserver list"" test to pass on Windows.+    void OnIocpReadable();+    void OnIocpWriteable();++    static grpc_slice FlattenIovec(const struct iovec* iov, int iov_count);++    grpc_core::Mutex* mu_;+    std::unique_ptr<WinSocket> winsocket_;+    char recv_from_source_addr_[200];+    ares_socklen_t recv_from_source_addr_len_;+    grpc_slice read_buf_;+    bool read_buf_has_data_ = false;+    grpc_slice write_buf_;+    absl::AnyInvocable<void(absl::Status)> read_closure_;+    absl::AnyInvocable<void(absl::Status)> write_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_read_closure_;+    std::unique_ptr<AnyInvocableClosure> outer_write_closure_;+    const std::string name_;+    bool shutdown_called_ = false;+    int address_family_;+    int socket_type_;+    // State related to TCP sockets+    AnyInvocableClosure on_tcp_connect_locked_;+    bool connect_done_ = false;+    int wsa_connect_error_ = 0;+    WriteState tcp_write_state_ = WRITE_IDLE;+    // We don't run register_for_{readable,writeable} logic until+    // a socket is connected. In the interim, we queue readable/writeable+    // registrations with the following state.+    bool pending_continue_register_for_on_readable_locked_ = false;+    bool pending_continue_register_for_on_writeable_locked_ = false;+    EventEngine* event_engine_;+  };++  // These virtual socket functions are called from within the c-ares+  // library. These methods generally dispatch those socket calls to the+  // appropriate methods. The virtual ""socket"" and ""close"" methods are+  // special and instead create/add and remove/destroy GrpcPolledFdWindows+  // objects.+  static ares_socket_t Socket(int af, int type, int protocol, void* user_data);",Good point. Went with the friend class of static methods approach. I also moved the `GrpcPolledFdWindows` class declaration and some other stuff into the .cc file since these don't need to be in the header file.,X
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34521,1343654253,2023-10-03T07:51:03Z,src/csharp/BUILD-INTEGRATION.md,"@@ -79,6 +79,32 @@ For `.proto` files that are outside of the project directory a link can be added  For more examples see the example project files in GitHub: https://github.com/grpc/grpc-dotnet/tree/master/examples +## Sharing `.proto` files between projects++Instead of each project generating their own code from a set of `.proto` files, you may have a shared .NET project that generates the code once, and then have other projects in the solution reference the shared project.","I think you could describe the problem better.the problem statement is that you have a .proto file and you want to use it in multiple projects (usually within the same solution)- if you did include the .proto file via <Protobuf> in multiple projects, that could lead to some projects getting multiple definitions of the same generated code, which can in turn break the build.- to prevent the problem, define a class library that contains the generated code from .proto files and have other projects in your solution reference the class library, instead of generating the .proto file themselves.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34521,1343655737,2023-10-03T07:51:53Z,src/csharp/BUILD-INTEGRATION.md,"@@ -79,6 +79,32 @@ For `.proto` files that are outside of the project directory a link can be added  For more examples see the example project files in GitHub: https://github.com/grpc/grpc-dotnet/tree/master/examples +## Sharing `.proto` files between projects++Instead of each project generating their own code from a set of `.proto` files, you may have a shared .NET project that generates the code once, and then have other projects in the solution reference the shared project.","nit: I think instead of ""shared .NET project"" you should say ""class library"" which describes what it actually is.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/34521,1343658396,2023-10-03T07:53:36Z,src/csharp/BUILD-INTEGRATION.md,"@@ -79,6 +79,32 @@ For `.proto` files that are outside of the project directory a link can be added  For more examples see the example project files in GitHub: https://github.com/grpc/grpc-dotnet/tree/master/examples +## Sharing `.proto` files between projects++Instead of each project generating their own code from a set of `.proto` files, you may have a shared .NET project that generates the code once, and then have other projects in the solution reference the shared project.++There are a couple of examples in GitHub:+- The [Liber example](https://github.com/grpc/grpc-dotnet/tree/master/examples#liber)+  demonstrates how common protocol buffers messages can be compiled once and used in other projects:+  - The *Common* project generates messages contained in `common.proto`+  - The *Client* and *Server* projects reference the *Common* project.+  - They do not need to recompile `common.proto` as those .NET types are already in+    the *Common* project.+  - They do however each generate their own gRPC client or server code as both have a ",add a note that Client and Server projects each having their own version of greet.proto is ok since they don't reference each other and they only reference the shared Common class library?,X
303201,JamesNK,https://api.github.com/repos/grpc/grpc/pulls/34521,1345039499,2023-10-04T01:13:52Z,src/csharp/BUILD-INTEGRATION.md,"@@ -79,6 +79,39 @@ For `.proto` files that are outside of the project directory a link can be added  For more examples see the example project files in GitHub: https://github.com/grpc/grpc-dotnet/tree/master/examples +## Sharing `.proto` files between multiple projects (in the same VS solution)++If you have one or more `.proto` files that you want to use in multiple project then+you may create a shared class library that compiled the generated the code.+The other projects in the solution then can reference this shared class library instead of each project having to compile+the same `.proto` files.","Update to explicitly call out two common approaches:````suggestionIt's common to want to share `.proto` files between projects. For example, a gRPC clientand gRPC server share the same contract. It is preferable to share contracts withoutcopying `.proto` files because copies can go out of sync over time.There are a couple of ways to use `.proto` files in multiple projects without duplication:* Sharing `.proto` files between projects with MSBuild links.* Generating code in a class library and sharing the library.### Sharing `.proto` with MSBuild links`.proto` files can be placed in a shared location and referenced by multiple projectsusing MSBuild's [`Link` or `LinkBase` settings](https://learn.microsoft.com/visualstudio/msbuild/common-msbuild-item-metadata).```xml<ItemGroup>   <Protobuf Include=""..\Protos\greet.proto"" GrpcServices=""None"" Link=""Protos\greet.proto""/></ItemGroup>```In the example above, `greet.proto` is in a shared `Protos` directory outside the project directory. Multiple projects can reference the proto file.### Generating code in a class libraryCreate a class library that references `.proto` files and contains generated code. The otherprojects in the solution can then reference this shared class library instead of each projecthaving to compile the same `.proto` files.````",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347933397,2023-10-05T20:27:55Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h,"@@ -0,0 +1,68 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H+#define GRPC_SRC_CORE_LIB_SECURITY_CREDENTIALS_TLS_GRPC_TLS_CRL_PROVIDER_H++#include <grpc/support/port_platform.h>++#include <string>++#include <openssl/crypto.h>++#include ""absl/status/statusor.h""+#include ""absl/strings/string_view.h""++#include <grpc/grpc_crl_provider.h>++namespace grpc_core {+namespace experimental {++class CrlImpl : public Crl {+ public:+  // Takes ownership of the X509_CRL pointer.+  CrlImpl(X509_CRL* crl, const std::string& issuer);",The parameter should probably be `absl::string_view`.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347934072,2023-10-05T20:28:39Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,137 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <limits.h>++#include <memory>+#include <utility>+#include <vector>++#include <openssl/bio.h>+#include <openssl/mem.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++namespace grpc_core {+namespace experimental {++namespace {+std::string IssuerFromCrl(X509_CRL* crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);+  std::string ret;+  if (buf != nullptr) {+    ret = buf;+  }+  OPENSSL_free(buf);+  return ret;+}++}  // namespace++CertificateInfoImpl::CertificateInfoImpl(absl::string_view issuer)",These simple one-line ctors or accessor methods can be inlined in the class declarations in the .h file rather than being defined separately in the .cc file.  You generally only need to put a function in the .cc file if it's more than a line or two long.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347953252,2023-10-05T20:49:10Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,137 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <limits.h>++#include <memory>+#include <utility>+#include <vector>++#include <openssl/bio.h>+#include <openssl/mem.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++namespace grpc_core {+namespace experimental {++namespace {+std::string IssuerFromCrl(X509_CRL* crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);+  std::string ret;+  if (buf != nullptr) {+    ret = buf;+  }+  OPENSSL_free(buf);+  return ret;+}++}  // namespace++CertificateInfoImpl::CertificateInfoImpl(absl::string_view issuer)+    : issuer_(issuer) {}++absl::string_view CertificateInfoImpl::Issuer() const { return issuer_; }++CrlImpl::CrlImpl(X509_CRL* crl, const std::string& issuer)+    : crl_(crl), issuer_(issuer) {}++// Copy constructor needs to duplicate the X509_CRL* since the destructor frees+// it+CrlImpl::CrlImpl(const CrlImpl& other)+    : crl_(X509_CRL_dup(other.crl())), issuer_(other.issuer_) {}++absl::StatusOr<CrlImpl> CrlImpl::Create(X509_CRL* crl) {+  std::string issuer = IssuerFromCrl(crl);+  if (issuer.empty()) {+    return absl::InvalidArgumentError(""Issuer of crl cannot be empty"");+  }+  return CrlImpl(crl, issuer);+}++CrlImpl::~CrlImpl() { X509_CRL_free(crl_); }++X509_CRL* CrlImpl::crl() const { return crl_; }++absl::string_view CrlImpl::Issuer() { return issuer_; }++absl::StatusOr<std::unique_ptr<Crl>> Crl::Parse(absl::string_view crl_string) {+  if (crl_string.size() >= INT_MAX) {+    return absl::InvalidArgumentError(""crl_string cannot be of size INT_MAX"");+  }+  BIO* crl_bio =+      BIO_new_mem_buf(crl_string.data(), static_cast<int>(crl_string.size()));+  // Errors on BIO+  if (crl_bio == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from crl string to BIO failed."");+  }+  X509_CRL* crl = PEM_read_bio_X509_CRL(crl_bio, nullptr, nullptr, nullptr);+  BIO_free(crl_bio);+  if (crl == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from PEM string to X509 CRL failed."");+  }+  absl::StatusOr<CrlImpl> result = CrlImpl::Create(crl);+  if (!result.ok()) {+    return result.status();+  }+  return std::make_unique<CrlImpl>(std::move(*result));+}++StaticCrlProvider::StaticCrlProvider(+    const absl::flat_hash_map<std::string, std::shared_ptr<Crl>>& crls)","We can avoid an unnecessary copy of this map by passing the parameter in by value:```StaticCrlProvider::StaticCrlProvider(    absl::flat_hash_map<std::string, std::shared_ptr<Crl>> crls)    : crls_(std::move(crls)) {}```Then use `std::move()` when you instantiate the ctor in `FromVector()`.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347962864,2023-10-05T20:57:40Z,src/core/tsi/ssl_transport_security.cc,"@@ -953,6 +960,58 @@ static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {   return preverify_ok; } +// X509_STORE_set_get_crl() sets the function to get the crl for a given+// certificate x. When found, the crl must be assigned to *crl. This function+// must return 0 on failure and 1 on success. If no function to get the issuer+// is provided, the internal default function will be used instead.+static int GetCrlFromProvider(X509_STORE_CTX* ctx, X509_CRL** crl_out,+                              X509* x) {",I'd prefer to see a more descriptive name here.  I don't see any value in forcing the parameter names here to match poor choices made by OpenSSL.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347983773,2023-10-05T21:11:02Z,test/core/security/grpc_tls_crl_provider_test.cc,"@@ -0,0 +1,100 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <memory>+#include <string>+#include <vector>++#include <gtest/gtest.h>++#include ""absl/status/statusor.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/grpc_crl_provider.h>++#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++#define CRL_PATH ""test/core/tsi/test_creds/crl_data/crls/ab06acdd.r0""","Instead of using macros, please use constants.```constexpr char* kCrlPath = ""test/core/tsi/test_creds/crl_data/crls/ab06acdd.r0"";constexpr absl::string_view kCrlIssuer = ""/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=testca"";```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347987630,2023-10-05T21:12:52Z,test/core/security/grpc_tls_crl_provider_test.cc,"@@ -0,0 +1,100 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <memory>+#include <string>+#include <vector>++#include <gtest/gtest.h>++#include ""absl/status/statusor.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/grpc_crl_provider.h>++#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++#define CRL_PATH ""test/core/tsi/test_creds/crl_data/crls/ab06acdd.r0""+#define CRL_ISSUER ""/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=testca""++namespace grpc_core {+namespace testing {++using ::grpc_core::experimental::CertificateInfoImpl;+using ::grpc_core::experimental::Crl;+using ::grpc_core::experimental::CrlImpl;+using ::grpc_core::experimental::CrlProvider;+using ::grpc_core::experimental::StaticCrlProvider;++TEST(CrlProviderTest, CanParseCrl) {+  std::string crl_string = GetFileContents(CRL_PATH);+  absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+  ASSERT_TRUE(result.ok());+  ASSERT_NE(*result, nullptr);+  auto* crl = static_cast<CrlImpl*>(result->get());+  EXPECT_STREQ(crl->Issuer().data(), CRL_ISSUER);+}++TEST(CrlProviderTest, InvalidFile) {+  std::string crl_string = ""INVALID CRL FILE"";+  absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+  EXPECT_EQ(result.status(),+            absl::InvalidArgumentError(+                ""Conversion from PEM string to X509 CRL failed.""));+}++TEST(CrlProviderTest, StaticCrlProviderLookup) {+  std::vector<std::string> crl_strings = {GetFileContents(CRL_PATH)};+  absl::StatusOr<std::shared_ptr<CrlProvider>> result =+      StaticCrlProvider::FromVector(crl_strings);+  std::shared_ptr<CrlProvider> provider = std::move(*result);++  CertificateInfoImpl cert = CertificateInfoImpl(CRL_ISSUER);++  auto crl = provider->GetCrl(cert);+  ASSERT_NE(crl, nullptr);+  ASSERT_EQ(crl->Issuer(), CRL_ISSUER);+}++TEST(CrlProviderTest, StaticCrlProviderLookupBad) {+  std::vector<std::string> crl_strings = {GetFileContents(CRL_PATH)};+  absl::StatusOr<std::shared_ptr<CrlProvider>> result =+      StaticCrlProvider::FromVector(crl_strings);+  std::shared_ptr<CrlProvider> provider = std::move(*result);","Same as above: please add `ASSERT_TRUE(result.ok()) << result.status()` before this line, and don't bother with this unnecessary temporary variable.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347990478,2023-10-05T21:16:21Z,test/core/security/grpc_tls_crl_provider_test.cc,"@@ -0,0 +1,100 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <memory>+#include <string>+#include <vector>++#include <gtest/gtest.h>++#include ""absl/status/statusor.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/grpc_crl_provider.h>++#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++#define CRL_PATH ""test/core/tsi/test_creds/crl_data/crls/ab06acdd.r0""+#define CRL_ISSUER ""/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=testca""++namespace grpc_core {+namespace testing {++using ::grpc_core::experimental::CertificateInfoImpl;+using ::grpc_core::experimental::Crl;+using ::grpc_core::experimental::CrlImpl;+using ::grpc_core::experimental::CrlProvider;+using ::grpc_core::experimental::StaticCrlProvider;++TEST(CrlProviderTest, CanParseCrl) {+  std::string crl_string = GetFileContents(CRL_PATH);+  absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+  ASSERT_TRUE(result.ok());+  ASSERT_NE(*result, nullptr);+  auto* crl = static_cast<CrlImpl*>(result->get());+  EXPECT_STREQ(crl->Issuer().data(), CRL_ISSUER);+}++TEST(CrlProviderTest, InvalidFile) {+  std::string crl_string = ""INVALID CRL FILE"";+  absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+  EXPECT_EQ(result.status(),+            absl::InvalidArgumentError(+                ""Conversion from PEM string to X509 CRL failed.""));+}++TEST(CrlProviderTest, StaticCrlProviderLookup) {+  std::vector<std::string> crl_strings = {GetFileContents(CRL_PATH)};+  absl::StatusOr<std::shared_ptr<CrlProvider>> result =+      StaticCrlProvider::FromVector(crl_strings);+  std::shared_ptr<CrlProvider> provider = std::move(*result);",There's no need for this temporary variable.  See https://abseil.io/tips/181 for the preferred pattern here.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347997350,2023-10-05T21:24:07Z,test/core/tsi/crl_ssl_transport_security_test.cc,"@@ -54,103 +53,88 @@ const char* kSslTsiTestCrlSupportedCrlDirMissingIntermediate = const char* kSslTsiTestCrlSupportedCrlDirMissingRoot =     ""test/core/tsi/test_creds/crl_data/crls_missing_root/""; const char* kSslTsiTestFaultyCrlsDir = ""bad_path/"";+const std::string kRevokedKeyPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""revoked.key"");+const std::string kRevokedCertPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""revoked.pem"");+const std::string kValidKeyPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""valid.key"");+const std::string kValidCertPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""valid.pem"");+const std::string kRevokedIntermediateKeyPath = absl::StrCat(+    kSslTsiTestCrlSupportedCredentialsDir, ""leaf_signed_by_intermediate.key"");+const std::string kRevokedIntermediateCertPath = absl::StrCat(+    kSslTsiTestCrlSupportedCredentialsDir, ""leaf_and_intermediate_chain.pem"");+const std::string kRootCrlPath =+    absl::StrCat(kSslTsiTestCrlSupportedCrlDir, ""current.crl"");+const std::string kIntermediateCrlPath =+    absl::StrCat(kSslTsiTestCrlSupportedCrlDir, ""intermediate.crl"");++std::string LoadFile(absl::string_view file_path) {",Please use the existing [`GetFileContents()` function](https://github.com/grpc/grpc/blob/7fabc61f07be423cccda79463f30dc390b83ac9c/test/core/util/tls_utils.h#L60) instead of duplicating this functionality.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1347998242,2023-10-05T21:25:12Z,test/core/tsi/crl_ssl_transport_security_test.cc,"@@ -54,103 +53,88 @@ const char* kSslTsiTestCrlSupportedCrlDirMissingIntermediate = const char* kSslTsiTestCrlSupportedCrlDirMissingRoot =     ""test/core/tsi/test_creds/crl_data/crls_missing_root/""; const char* kSslTsiTestFaultyCrlsDir = ""bad_path/"";+const std::string kRevokedKeyPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""revoked.key"");+const std::string kRevokedCertPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""revoked.pem"");+const std::string kValidKeyPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""valid.key"");+const std::string kValidCertPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""valid.pem"");+const std::string kRevokedIntermediateKeyPath = absl::StrCat(+    kSslTsiTestCrlSupportedCredentialsDir, ""leaf_signed_by_intermediate.key"");+const std::string kRevokedIntermediateCertPath = absl::StrCat(+    kSslTsiTestCrlSupportedCredentialsDir, ""leaf_and_intermediate_chain.pem"");+const std::string kRootCrlPath =+    absl::StrCat(kSslTsiTestCrlSupportedCrlDir, ""current.crl"");+const std::string kIntermediateCrlPath =+    absl::StrCat(kSslTsiTestCrlSupportedCrlDir, ""intermediate.crl"");++std::string LoadFile(absl::string_view file_path) {+  grpc_slice slice;+  GPR_ASSERT(grpc_load_file(file_path.data(), 1, &slice) == absl::OkStatus());","Note that in the general case, it's not safe to assume that the string returned by `absl::string_view::data()` is null-terminated.  It may be that you are always passing in a null-terminated string to this function, but there's nothing in the API that guarantees this, so it seems like a bad choice of interface.  I suggest either changing the parameter from `absl::string_view` to `const char*` or changing this line to `std::string(file_path).c_str()`, which will make a copy and ensure that it is null-terminated.Looks like this may have been a pre-existing bug.  And the question is moot anyway, as per my comment above, since this function should just go away.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1348004017,2023-10-05T21:31:44Z,test/core/tsi/crl_ssl_transport_security_test.cc,"@@ -54,103 +53,88 @@ const char* kSslTsiTestCrlSupportedCrlDirMissingIntermediate = const char* kSslTsiTestCrlSupportedCrlDirMissingRoot =     ""test/core/tsi/test_creds/crl_data/crls_missing_root/""; const char* kSslTsiTestFaultyCrlsDir = ""bad_path/"";+const std::string kRevokedKeyPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""revoked.key"");+const std::string kRevokedCertPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""revoked.pem"");+const std::string kValidKeyPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""valid.key"");+const std::string kValidCertPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""valid.pem"");+const std::string kRevokedIntermediateKeyPath = absl::StrCat(+    kSslTsiTestCrlSupportedCredentialsDir, ""leaf_signed_by_intermediate.key"");+const std::string kRevokedIntermediateCertPath = absl::StrCat(+    kSslTsiTestCrlSupportedCredentialsDir, ""leaf_and_intermediate_chain.pem"");+const std::string kRootCrlPath =+    absl::StrCat(kSslTsiTestCrlSupportedCrlDir, ""current.crl"");+const std::string kIntermediateCrlPath =+    absl::StrCat(kSslTsiTestCrlSupportedCrlDir, ""intermediate.crl"");++std::string LoadFile(absl::string_view file_path) {+  grpc_slice slice;+  GPR_ASSERT(grpc_load_file(file_path.data(), 1, &slice) == absl::OkStatus());+  char* data = grpc_slice_to_c_string(slice);+  grpc_slice_unref(slice);+  std::string ret = data;+  gpr_free(data);+  return ret;+}  class CrlSslTransportSecurityTest     : public testing::TestWithParam<tsi_tls_version> {  protected:   // A tsi_test_fixture implementation.   class SslTsiTestFixture {    public:-    // When use_faulty_crl_directory is set, the crl_directory of the-    // client is set to a non-existant path.-    static SslTsiTestFixture* Create(bool use_revoked_server_cert,-                                     bool use_revoked_client_cert,-                                     bool use_faulty_crl_directory) {-      return new SslTsiTestFixture(-          use_revoked_server_cert, use_revoked_client_cert,-          use_faulty_crl_directory, false, false, false);-    }--    static SslTsiTestFixture* CreateWithIntermediate(-        bool use_revoked_intermediate, bool use_missing_intermediate_crl,-        bool use_missing_root_crl) {-      return new SslTsiTestFixture(-          false, false, false, use_revoked_intermediate,-          use_missing_intermediate_crl, use_missing_root_crl);-    }--    void Run() {-      tsi_test_do_handshake(&base_);-      tsi_test_fixture_destroy(&base_);-    }--   private:-    SslTsiTestFixture(bool use_revoked_server_cert,-                      bool use_revoked_client_cert,-                      bool use_faulty_crl_directory,-                      bool use_revoked_intermediate,-                      bool use_missing_intermediate_crl,-                      bool use_missing_root_crl)-        : use_revoked_server_cert_(use_revoked_server_cert),-          use_revoked_client_cert_(use_revoked_client_cert),-          use_faulty_crl_directory_(use_faulty_crl_directory),-          use_revoked_intermediate_(use_revoked_intermediate),-          use_missing_intermediate_crl_(use_missing_intermediate_crl),-          use_missing_root_crl_(use_missing_root_crl) {+    SslTsiTestFixture(",I like the API change here that puts more of the actual data into the test cases!,
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1349308680,2023-10-06T20:47:08Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,137 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <limits.h>++#include <memory>+#include <utility>+#include <vector>++#include <openssl/bio.h>+#include <openssl/mem.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++namespace grpc_core {+namespace experimental {++namespace {+std::string IssuerFromCrl(X509_CRL* crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);+  std::string ret;+  if (buf != nullptr) {+    ret = buf;+  }+  OPENSSL_free(buf);+  return ret;+}++}  // namespace++CertificateInfoImpl::CertificateInfoImpl(absl::string_view issuer)+    : issuer_(issuer) {}++absl::string_view CertificateInfoImpl::Issuer() const { return issuer_; }++CrlImpl::CrlImpl(X509_CRL* crl, const std::string& issuer)+    : crl_(crl), issuer_(issuer) {}++// Copy constructor needs to duplicate the X509_CRL* since the destructor frees+// it+CrlImpl::CrlImpl(const CrlImpl& other)+    : crl_(X509_CRL_dup(other.crl())), issuer_(other.issuer_) {}++absl::StatusOr<CrlImpl> CrlImpl::Create(X509_CRL* crl) {+  std::string issuer = IssuerFromCrl(crl);+  if (issuer.empty()) {+    return absl::InvalidArgumentError(""Issuer of crl cannot be empty"");+  }+  return CrlImpl(crl, issuer);+}++CrlImpl::~CrlImpl() { X509_CRL_free(crl_); }++X509_CRL* CrlImpl::crl() const { return crl_; }++absl::string_view CrlImpl::Issuer() { return issuer_; }++absl::StatusOr<std::unique_ptr<Crl>> Crl::Parse(absl::string_view crl_string) {+  if (crl_string.size() >= INT_MAX) {+    return absl::InvalidArgumentError(""crl_string cannot be of size INT_MAX"");+  }+  BIO* crl_bio =+      BIO_new_mem_buf(crl_string.data(), static_cast<int>(crl_string.size()));+  // Errors on BIO+  if (crl_bio == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from crl string to BIO failed."");+  }+  X509_CRL* crl = PEM_read_bio_X509_CRL(crl_bio, nullptr, nullptr, nullptr);+  BIO_free(crl_bio);+  if (crl == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from PEM string to X509 CRL failed."");+  }+  absl::StatusOr<CrlImpl> result = CrlImpl::Create(crl);+  if (!result.ok()) {+    return result.status();+  }+  return std::make_unique<CrlImpl>(std::move(*result));+}++StaticCrlProvider::StaticCrlProvider(+    const absl::flat_hash_map<std::string, std::shared_ptr<Crl>>& crls)+    : crls_(crls) {}++absl::StatusOr<std::shared_ptr<CrlProvider>> StaticCrlProvider::FromVector(+    const std::vector<std::string> crls) {+  absl::flat_hash_map<std::string, std::shared_ptr<Crl>> crl_map;+  for (const auto& raw_crl : crls) {+    absl::StatusOr<std::unique_ptr<Crl>> result = Crl::Parse(raw_crl);+    if (!result.ok()) {+      return absl::InvalidArgumentError(+          absl::StrCat(""Parsing crl string failed with result "",+                       result.status().ToString()));+    }+    std::unique_ptr<Crl> crl = std::move(*result);+    crl_map[crl->Issuer()] = std::move(crl);","I'm thinking about that specifically for the static case - this would mean they've passed in a CRL with a duplicate issuer and something will be deleted.I suppose we could just return a bad status and force the user to provide a clean creation, or we could log. WDYT?",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1349311346,2023-10-06T20:51:07Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,137 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <limits.h>++#include <memory>+#include <utility>+#include <vector>++#include <openssl/bio.h>+#include <openssl/mem.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++namespace grpc_core {+namespace experimental {++namespace {+std::string IssuerFromCrl(X509_CRL* crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);+  std::string ret;+  if (buf != nullptr) {+    ret = buf;+  }+  OPENSSL_free(buf);+  return ret;+}++}  // namespace++CertificateInfoImpl::CertificateInfoImpl(absl::string_view issuer)+    : issuer_(issuer) {}++absl::string_view CertificateInfoImpl::Issuer() const { return issuer_; }++CrlImpl::CrlImpl(X509_CRL* crl, const std::string& issuer)+    : crl_(crl), issuer_(issuer) {}++// Copy constructor needs to duplicate the X509_CRL* since the destructor frees+// it+CrlImpl::CrlImpl(const CrlImpl& other)+    : crl_(X509_CRL_dup(other.crl())), issuer_(other.issuer_) {}++absl::StatusOr<CrlImpl> CrlImpl::Create(X509_CRL* crl) {+  std::string issuer = IssuerFromCrl(crl);+  if (issuer.empty()) {+    return absl::InvalidArgumentError(""Issuer of crl cannot be empty"");+  }+  return CrlImpl(crl, issuer);+}++CrlImpl::~CrlImpl() { X509_CRL_free(crl_); }++X509_CRL* CrlImpl::crl() const { return crl_; }++absl::string_view CrlImpl::Issuer() { return issuer_; }++absl::StatusOr<std::unique_ptr<Crl>> Crl::Parse(absl::string_view crl_string) {+  if (crl_string.size() >= INT_MAX) {+    return absl::InvalidArgumentError(""crl_string cannot be of size INT_MAX"");+  }+  BIO* crl_bio =+      BIO_new_mem_buf(crl_string.data(), static_cast<int>(crl_string.size()));+  // Errors on BIO+  if (crl_bio == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from crl string to BIO failed."");+  }+  X509_CRL* crl = PEM_read_bio_X509_CRL(crl_bio, nullptr, nullptr, nullptr);+  BIO_free(crl_bio);+  if (crl == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from PEM string to X509 CRL failed."");+  }+  absl::StatusOr<CrlImpl> result = CrlImpl::Create(crl);+  if (!result.ok()) {+    return result.status();+  }+  return std::make_unique<CrlImpl>(std::move(*result));+}++StaticCrlProvider::StaticCrlProvider(+    const absl::flat_hash_map<std::string, std::shared_ptr<Crl>>& crls)+    : crls_(crls) {}++absl::StatusOr<std::shared_ptr<CrlProvider>> StaticCrlProvider::FromVector(+    const std::vector<std::string> crls) {+  absl::flat_hash_map<std::string, std::shared_ptr<Crl>> crl_map;+  for (const auto& raw_crl : crls) {+    absl::StatusOr<std::unique_ptr<Crl>> result = Crl::Parse(raw_crl);+    if (!result.ok()) {+      return absl::InvalidArgumentError(+          absl::StrCat(""Parsing crl string failed with result "",+                       result.status().ToString()));+    }+    std::unique_ptr<Crl> crl = std::move(*result);+    crl_map[crl->Issuer()] = std::move(crl);+  }+  StaticCrlProvider provider = StaticCrlProvider(crl_map);","This gives me an error because the ctor for `StaticCrlProvider` that takes a crl_map is private, and shared_ptr wants it to be public. The intention is to be forced to create it using the static `Create`. I could do similarly to the `CrlImpl` where I make a `StaticCrlProviderImpl` inherit from `StaticCrlProvider` so I can have the public ctor on the `StaticCrlProviderImpl` to be able to use `make_shared`, but I thought that might be overkill.WDYT?",X
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1349314788,2023-10-06T20:56:26Z,src/core/tsi/ssl_transport_security.cc,"@@ -940,8 +946,16 @@ static int RootCertExtractCallback(int preverify_ok, X509_STORE_CTX* ctx) {     return preverify_ok;   } -  SSL* ssl = static_cast<SSL*>(-      X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx()));+  ERR_clear_error();+  int ssl_index = SSL_get_ex_data_X509_STORE_CTX_idx();+  if (ssl_index < 0) {+    char err_str[256];+    ERR_error_string_n(ERR_get_error(), err_str, sizeof(err_str));","Ack, I'm looking into thisThis specific line you've commented on is just a tangential cleanup where we weren't checking the `SSL_get_ex_data_X509_STORE_CTX_idx()`return value so I fixed it here (I had to use the fn for the CRL interactions so we figured we'd go on and fix all the usages).",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/34292,1350606840,2023-10-09T17:40:55Z,src/python/grpcio_tests/tests_aio/unit/server_test.py,"@@ -579,15 +582,18 @@ async def test_maximum_concurrent_rpcs(self):         # Build the channel         channel = aio.insecure_channel(bind_address)         # Deplete the concurrent quota with 3 times of max RPCs-        rpcs = []+        rpc_tasks = []         for _ in range(3 * _MAXIMUM_CONCURRENT_RPCS):-            rpcs.append(channel.unary_unary(_BLOCK_BRIEFLY)(_REQUEST))","Can you explain the change here in a bit more detail? `channel.unary_unary(_BLOCK_BRIEFLY)(_REQUEST)` should return a `UnaryUnaryCall`, [which is an Awaitable](https://github.com/grpc/grpc/blob/01907a776771eae2b2b5082fcf6d4ca2bd8386ce/src/python/grpcio/grpc/aio/_base_call.py#L138). So [`asyncio.wait`](https://docs.python.org/3/library/asyncio-task.html#asyncio.wait) should be able to accept these. Is the issue that the return type of `asyncio.wait` does not match up with the parameters expected by `self.loop.create_task`?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34618,1350774532,2023-10-09T20:46:44Z,src/core/lib/transport/transport.h,"@@ -618,37 +619,90 @@ std::string grpc_transport_stream_op_batch_string(     grpc_transport_stream_op_batch* op, bool truncate); std::string grpc_transport_op_string(grpc_transport_op* op); -// Send a batch of operations on a transport--// Takes ownership of any objects contained in ops.--// Arguments:-//   transport - the transport on which to initiate the stream-//   stream    - the stream on which to send the operations. This must be-//               non-NULL and previously initialized by the same transport.-//   op        - a grpc_transport_stream_op_batch specifying the op to perform-//-void grpc_transport_perform_stream_op(grpc_transport* transport,-                                      grpc_stream* stream,-                                      grpc_transport_stream_op_batch* op);+namespace grpc_core { -void grpc_transport_perform_op(grpc_transport* transport,-                               grpc_transport_op* op);+class FilterStackTransport {+ public:+  // Memory required for a single stream element - this is allocated by upper+  // layers and initialized by the transport+  // TODO(ctiller): not used for promises, remove+  virtual size_t SizeOfStream() const = 0;++  // HACK: inproc does not handle stream op batch callbacks correctly (receive+  // ops are required to complete prior to on_complete triggering).+  // This flag is used to disable coalescing of batches in connected_channel for+  // that specific transport.+  // TODO(ctiller): This ought not be necessary once we have promises complete.+  virtual bool HackyDisableStreamOpBatchCoalescingInConnectedChannel()+      const = 0;++  // implementation of grpc_transport_perform_stream_op+  virtual void PerformStreamOp(grpc_stream* stream,+                               grpc_transport_stream_op_batch* op) = 0;++  // implementation of grpc_transport_destroy_stream+  virtual void DestroyStream(grpc_stream* stream,+                             grpc_closure* then_schedule_closure) = 0;+}; -// Send a ping on a transport+class PromiseTransport {+ public:+  // Create a promise to execute one client call.+  // If this is non-null, it may be used in preference to+  // perform_stream_op.+  // If this is used in preference to perform_stream_op, the+  // following can be omitted also:+  //   - calling init_stream, destroy_stream, set_pollset, set_pollset_set+  //   - allocation of memory for call data (sizeof_stream may be ignored)+  // There is an on-going migration to move all filters to providing this, and+  // then to drop perform_stream_op.+  virtual ArenaPromise<ServerMetadataHandle> MakeCallPromise(+      CallArgs call_args) = 0;",virtual void SetAcceptCall(AnyInvocable<ArenaPromise<ServerMetadataHandle>(CallArgs)> accept) = 0;,
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/34292,1350829210,2023-10-09T22:04:21Z,src/python/grpcio_tests/tests/_sanity/_sanity_test.py,"@@ -39,9 +39,9 @@ def testTestsJsonUpToDate(self):         )          tests_json_string = pkgutil.get_data(self.TEST_PKG_PATH, ""tests.json"")-        tests_json = tests_json_string.decode()+        tests_json = json.loads(tests_json_string.decode()) -        self.assertSequenceEqual(tests_json, test_suite_names)+        self.assertListEqual(tests_json, test_suite_names)","Because of the test discovery issue, the error message from `assertSequenceEqual` is very hard to read thus I changed to `assertListEqual`.I just tried again and now the message looks similar to `assertListEqual`, I'll revert this change.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/34292,1350902884,2023-10-09T22:35:23Z,src/python/grpcio/grpc/_cython/_cygrpc/aio/server.pyx.pxi,"@@ -213,9 +215,10 @@ cdef class _ServicerContext:      def set_code(self, object code):         self._rpc_state.status_code = get_status_code(code)+        self._rpc_state.py_status_code = code      def code(self):-        return self._rpc_state.status_code","Yes we should return Python code here, `py_status_code` is set when we called `abort` or `set_code`, both of them are called with Python code.The issue is we're returning `_rpc_state.status_code` here, in sync stack this is correct because [that's the Python code](https://github.com/grpc/grpc/blob/ce75ec23a1a9c5239834b92da4ce0992d367a39c/src/python/grpcio/grpc/_server.py#L410-L412), but in Aio we already [translated this `_rpc_state.status_code` to `Cython.StatusCode`](https://github.com/grpc/grpc/blob/ce75ec23a1a9c5239834b92da4ce0992d367a39c/src/python/grpcio/grpc/_cython/_cygrpc/aio/server.pyx.pxi#L215), so we have to return the original `py_status_code`.",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/34292,1350927886,2023-10-09T22:41:26Z,src/python/grpcio_tests/tests_aio/unit/metadata_test.py,"@@ -183,9 +183,9 @@ async def _test_inspect_context(request, context):         context.set_trailing_metadata(_TRAILING_METADATA)          # ensure that we can read back the data we set on the context-        assert context.get_code() == _NON_OK_CODE","Is it, but we're expecting an RpcError in test and calling `get_code()` will result in and RpcError, just not the one we want:https://github.com/grpc/grpc/blob/ce75ec23a1a9c5239834b92da4ce0992d367a39c/src/python/grpcio_tests/tests_aio/unit/metadata_test.py#L354-L355",
24593237,XuanWang-Amos,https://api.github.com/repos/grpc/grpc/pulls/34292,1353029884,2023-10-10T17:17:44Z,src/python/grpcio_tests/tests_aio/unit/server_test.py,"@@ -579,15 +582,18 @@ async def test_maximum_concurrent_rpcs(self):         # Build the channel         channel = aio.insecure_channel(bind_address)         # Deplete the concurrent quota with 3 times of max RPCs-        rpcs = []+        rpc_tasks = []         for _ in range(3 * _MAXIMUM_CONCURRENT_RPCS):-            rpcs.append(channel.unary_unary(_BLOCK_BRIEFLY)(_REQUEST))","`asyncio.wait` does not accept `UnaryUnaryCall` anymore. This code works fine before 3.11 but will start getting this error in 3.11:```Traceback (most recent call last):  File ""/usr/local/google/home/xuanwn/.pyenv/versions/311env/lib/python3.11/site-packages/grpc/aio/_call.py"", line 576, in _invoke    serialized_response = await self._cython_call.unary_unary(                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  File ""src/python/grpcio/grpc/_cython/_cygrpc/aio/call.pyx.pxi"", line 331, in unary_unary  File ""src/python/grpcio/grpc/_cython/_cygrpc/aio/call.pyx.pxi"", line 149, in grpc._cython.cygrpc._AioCall._set_status  File ""/usr/local/google/home/xuanwn/.pyenv/versions/3.11.0/lib/python3.11/asyncio/tasks.py"", line 515, in _on_completion    f.exception() is not None)):    ^^^^^^^^^^^AttributeError: 'UnaryUnaryCall' object has no attribute 'exception'```likely because [passing coroutine objects to asyncio.wait() directly is forbidden starting 3.11](https://docs.python.org/3/library/asyncio-task.html#asyncio.wait).In order to get it to work, we need create a task, and since `asyncio.create_task` only accept coroutine, we need a wrapper to wrap `UnaryUnaryCall`.Reference:* [Awaitable objects in Python after 3.10](https://stackoverflow.com/questions/76566490/awaitable-objects-in-python-after-3-10)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1353097927,2023-10-10T18:25:36Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,137 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <limits.h>++#include <memory>+#include <utility>+#include <vector>++#include <openssl/bio.h>+#include <openssl/mem.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++namespace grpc_core {+namespace experimental {++namespace {+std::string IssuerFromCrl(X509_CRL* crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);+  std::string ret;+  if (buf != nullptr) {+    ret = buf;+  }+  OPENSSL_free(buf);+  return ret;+}++}  // namespace++CertificateInfoImpl::CertificateInfoImpl(absl::string_view issuer)+    : issuer_(issuer) {}++absl::string_view CertificateInfoImpl::Issuer() const { return issuer_; }++CrlImpl::CrlImpl(X509_CRL* crl, const std::string& issuer)+    : crl_(crl), issuer_(issuer) {}++// Copy constructor needs to duplicate the X509_CRL* since the destructor frees+// it+CrlImpl::CrlImpl(const CrlImpl& other)+    : crl_(X509_CRL_dup(other.crl())), issuer_(other.issuer_) {}++absl::StatusOr<CrlImpl> CrlImpl::Create(X509_CRL* crl) {+  std::string issuer = IssuerFromCrl(crl);+  if (issuer.empty()) {+    return absl::InvalidArgumentError(""Issuer of crl cannot be empty"");+  }+  return CrlImpl(crl, issuer);+}++CrlImpl::~CrlImpl() { X509_CRL_free(crl_); }++X509_CRL* CrlImpl::crl() const { return crl_; }++absl::string_view CrlImpl::Issuer() { return issuer_; }++absl::StatusOr<std::unique_ptr<Crl>> Crl::Parse(absl::string_view crl_string) {+  if (crl_string.size() >= INT_MAX) {+    return absl::InvalidArgumentError(""crl_string cannot be of size INT_MAX"");+  }+  BIO* crl_bio =+      BIO_new_mem_buf(crl_string.data(), static_cast<int>(crl_string.size()));+  // Errors on BIO+  if (crl_bio == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from crl string to BIO failed."");+  }+  X509_CRL* crl = PEM_read_bio_X509_CRL(crl_bio, nullptr, nullptr, nullptr);+  BIO_free(crl_bio);+  if (crl == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from PEM string to X509 CRL failed."");+  }+  absl::StatusOr<CrlImpl> result = CrlImpl::Create(crl);+  if (!result.ok()) {+    return result.status();+  }+  return std::make_unique<CrlImpl>(std::move(*result));+}++StaticCrlProvider::StaticCrlProvider(+    const absl::flat_hash_map<std::string, std::shared_ptr<Crl>>& crls)+    : crls_(crls) {}++absl::StatusOr<std::shared_ptr<CrlProvider>> StaticCrlProvider::FromVector(+    const std::vector<std::string> crls) {+  absl::flat_hash_map<std::string, std::shared_ptr<Crl>> crl_map;+  for (const auto& raw_crl : crls) {+    absl::StatusOr<std::unique_ptr<Crl>> result = Crl::Parse(raw_crl);+    if (!result.ok()) {+      return absl::InvalidArgumentError(+          absl::StrCat(""Parsing crl string failed with result "",+                       result.status().ToString()));+    }+    std::unique_ptr<Crl> crl = std::move(*result);+    crl_map[crl->Issuer()] = std::move(crl);+  }+  StaticCrlProvider provider = StaticCrlProvider(crl_map);","See https://abseil.io/tips/134 for best practices here.  In most cases, I think it's fine to make the ctor public but add a comment saying that callers should always use the factory method instead of instantiating directly.In this particular case, though, since `StaticCrlProvider` is defined in the public header file, this may be one of the rare cases where it would be worth a bit of complexity to hide the ctor.  I suggest doing one of the following:1. Move the factory method out of the class and make it a standalone function, like `absl::StatusOr<std::shared_ptr<CrlProvider>> CreateStaticCrlProvider(absl::Span<const std::string> crls);`.  Then you can move the class out of the header file entirely, and it's fine for the ctor to be public within the class with a comment to use the factory instead.2. Keep the class in the header, but define nothing other than the factory method.  In the implementation, define `StaticCrlProviderImpl` that inherits from `StaticCrlProvider` and provides all of the functionality, and have the definition of the factory method return an instance of `StaticCrlProviderImpl`.Note that both of these approaches have the additional benefit of hiding the `absl::flat_hash_map<>` dependency from the header file.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1353100749,2023-10-10T18:28:14Z,src/core/lib/security/credentials/tls/grpc_tls_crl_provider.cc,"@@ -0,0 +1,137 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <limits.h>++#include <memory>+#include <utility>+#include <vector>++#include <openssl/bio.h>+#include <openssl/mem.h>+#include <openssl/pem.h>+#include <openssl/x509.h>++#include ""absl/container/flat_hash_map.h""+#include ""absl/status/status.h""+#include ""absl/status/statusor.h""+#include ""absl/strings/str_cat.h""++namespace grpc_core {+namespace experimental {++namespace {+std::string IssuerFromCrl(X509_CRL* crl) {+  char* buf = X509_NAME_oneline(X509_CRL_get_issuer(crl), nullptr, 0);+  std::string ret;+  if (buf != nullptr) {+    ret = buf;+  }+  OPENSSL_free(buf);+  return ret;+}++}  // namespace++CertificateInfoImpl::CertificateInfoImpl(absl::string_view issuer)+    : issuer_(issuer) {}++absl::string_view CertificateInfoImpl::Issuer() const { return issuer_; }++CrlImpl::CrlImpl(X509_CRL* crl, const std::string& issuer)+    : crl_(crl), issuer_(issuer) {}++// Copy constructor needs to duplicate the X509_CRL* since the destructor frees+// it+CrlImpl::CrlImpl(const CrlImpl& other)+    : crl_(X509_CRL_dup(other.crl())), issuer_(other.issuer_) {}++absl::StatusOr<CrlImpl> CrlImpl::Create(X509_CRL* crl) {+  std::string issuer = IssuerFromCrl(crl);+  if (issuer.empty()) {+    return absl::InvalidArgumentError(""Issuer of crl cannot be empty"");+  }+  return CrlImpl(crl, issuer);+}++CrlImpl::~CrlImpl() { X509_CRL_free(crl_); }++X509_CRL* CrlImpl::crl() const { return crl_; }++absl::string_view CrlImpl::Issuer() { return issuer_; }++absl::StatusOr<std::unique_ptr<Crl>> Crl::Parse(absl::string_view crl_string) {+  if (crl_string.size() >= INT_MAX) {+    return absl::InvalidArgumentError(""crl_string cannot be of size INT_MAX"");+  }+  BIO* crl_bio =+      BIO_new_mem_buf(crl_string.data(), static_cast<int>(crl_string.size()));+  // Errors on BIO+  if (crl_bio == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from crl string to BIO failed."");+  }+  X509_CRL* crl = PEM_read_bio_X509_CRL(crl_bio, nullptr, nullptr, nullptr);+  BIO_free(crl_bio);+  if (crl == nullptr) {+    return absl::InvalidArgumentError(+        ""Conversion from PEM string to X509 CRL failed."");+  }+  absl::StatusOr<CrlImpl> result = CrlImpl::Create(crl);+  if (!result.ok()) {+    return result.status();+  }+  return std::make_unique<CrlImpl>(std::move(*result));+}++StaticCrlProvider::StaticCrlProvider(+    const absl::flat_hash_map<std::string, std::shared_ptr<Crl>>& crls)","I added a comment elsewhere about this, but it looks like you're missing the `std::move()` when populating the `crls_` field in the ctor initializer list.  That will avoid the copy.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1353168364,2023-10-10T18:53:37Z,include/grpcpp/security/tls_credentials_options.h,"@@ -113,6 +116,7 @@ class TlsCredentialsOptions {  private:   std::shared_ptr<CertificateProviderInterface> certificate_provider_;   std::shared_ptr<CertificateVerifier> certificate_verifier_;+  std::shared_ptr<CrlProvider> crl_provider_;",I don't think this data member is needed.  We can just store it inside the `c_credentials_options_` object.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1353171090,2023-10-10T18:54:16Z,src/cpp/common/tls_credentials_options.cc,"@@ -43,6 +44,15 @@ void TlsCredentialsOptions::set_certificate_provider(   } } +void TlsCredentialsOptions::set_crl_provider(+    std::shared_ptr<CrlProvider> crl_provider) {+  crl_provider_ = std::move(crl_provider);+  if (crl_provider_ != nullptr) {",I don't think we need to check whether it's null.  We can just unconditionally pass the value to the C-core options struct.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1353190832,2023-10-10T19:06:45Z,test/core/security/grpc_tls_crl_provider_test.cc,"@@ -0,0 +1,100 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#include <grpc/support/port_platform.h>++#include ""src/core/lib/security/credentials/tls/grpc_tls_crl_provider.h""++#include <memory>+#include <string>+#include <vector>++#include <gtest/gtest.h>++#include ""absl/status/statusor.h""++#include <grpc/grpc_audit_logging.h>+#include <grpc/grpc_crl_provider.h>++#include ""test/core/util/test_config.h""+#include ""test/core/util/tls_utils.h""++#define CRL_PATH ""test/core/tsi/test_creds/crl_data/crls/ab06acdd.r0""+#define CRL_ISSUER ""/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=testca""++namespace grpc_core {+namespace testing {++using ::grpc_core::experimental::CertificateInfoImpl;+using ::grpc_core::experimental::Crl;+using ::grpc_core::experimental::CrlImpl;+using ::grpc_core::experimental::CrlProvider;+using ::grpc_core::experimental::StaticCrlProvider;++TEST(CrlProviderTest, CanParseCrl) {+  std::string crl_string = GetFileContents(CRL_PATH);+  absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+  ASSERT_TRUE(result.ok());+  ASSERT_NE(*result, nullptr);+  auto* crl = static_cast<CrlImpl*>(result->get());+  EXPECT_STREQ(crl->Issuer().data(), CRL_ISSUER);+}++TEST(CrlProviderTest, InvalidFile) {+  std::string crl_string = ""INVALID CRL FILE"";+  absl::StatusOr<std::shared_ptr<Crl>> result = Crl::Parse(crl_string);+  EXPECT_EQ(result.status(),+            absl::InvalidArgumentError(+                ""Conversion from PEM string to X509 CRL failed.""));+}++TEST(CrlProviderTest, StaticCrlProviderLookup) {+  std::vector<std::string> crl_strings = {GetFileContents(CRL_PATH)};+  absl::StatusOr<std::shared_ptr<CrlProvider>> result =+      StaticCrlProvider::FromVector(crl_strings);+  std::shared_ptr<CrlProvider> provider = std::move(*result);","Calling `result->` gives you what's inside the `StatusOr<>`.  In this case, that's a `shared_ptr<>`, so you have to deference that too to get to the object.  So you can say something like `(*result)->GetCrl()`.Note that, as per the abseil tip, you should call the variable something like `crl_provider` instead of `result`.Please fix this pattern throughout this PR.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1353204005,2023-10-10T19:12:11Z,test/core/tsi/crl_ssl_transport_security_test.cc,"@@ -54,103 +53,88 @@ const char* kSslTsiTestCrlSupportedCrlDirMissingIntermediate = const char* kSslTsiTestCrlSupportedCrlDirMissingRoot =     ""test/core/tsi/test_creds/crl_data/crls_missing_root/""; const char* kSslTsiTestFaultyCrlsDir = ""bad_path/"";+const std::string kRevokedKeyPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""revoked.key"");+const std::string kRevokedCertPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""revoked.pem"");+const std::string kValidKeyPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""valid.key"");+const std::string kValidCertPath =+    absl::StrCat(kSslTsiTestCrlSupportedCredentialsDir, ""valid.pem"");+const std::string kRevokedIntermediateKeyPath = absl::StrCat(+    kSslTsiTestCrlSupportedCredentialsDir, ""leaf_signed_by_intermediate.key"");+const std::string kRevokedIntermediateCertPath = absl::StrCat(+    kSslTsiTestCrlSupportedCredentialsDir, ""leaf_and_intermediate_chain.pem"");+const std::string kRootCrlPath =+    absl::StrCat(kSslTsiTestCrlSupportedCrlDir, ""current.crl"");+const std::string kIntermediateCrlPath =+    absl::StrCat(kSslTsiTestCrlSupportedCrlDir, ""intermediate.crl"");++std::string LoadFile(absl::string_view file_path) {+  grpc_slice slice;+  GPR_ASSERT(grpc_load_file(file_path.data(), 1, &slice) == absl::OkStatus());","`GetFileContents()` takes a `char*` parameter instead of an `absl::string_view` parameter, so it's not an issue for that function.",
16962414,gtcooke94,https://api.github.com/repos/grpc/grpc/pulls/33786,1353273150,2023-10-10T20:13:46Z,src/core/lib/security/credentials/tls/tls_credentials.cc,"@@ -46,6 +44,14 @@ bool CredentialOptionSanityCheck(grpc_tls_credentials_options* options,     gpr_log(GPR_ERROR, ""TLS credentials options is nullptr."");     return false;   }+  if (!options->crl_directory().empty() && options->crl_provider() != nullptr) {+    gpr_log(GPR_ERROR,+            ""Setting crl_directory and crl_provider not supported. Using the ""+            ""crl_provider."");+    // TODO(gtcooke94) - Maybe return false here. Right now object lifetime of","So as of right now there is no way for this to _not_ transfer the ownership of the options to the credentials, because all of the errors still end up returning true. The only return false is when `options == nullptr`, in which case it doesn't exist to transfer.This has us talking about an overall bad design that we've discovered - `  grpc::experimental::TlsChannelCredentialsOptions options;` simply leaks if not passed through then owned by a `TlsCredentials` (it creates a `new c_credentials` in it's constructor which is what leaks).We don't like that, but it's a broader change to the API to make it okay, so we left the TODO and said for now we'd treat this misconfiguration like other misconfigurations are treated - they get a default and it continues to work.WDYT?",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34631,1353457814,2023-10-10T21:36:55Z,tools/run_tests/xds_k8s_test_driver/framework/xds_k8s_testcase.py,"@@ -826,12 +826,17 @@ def _start_test_client(         self,         server_target: str,         *,+        wait_for_active_ads_timeout: Optional[_timedelta] = None,         wait_for_active_channel_timeout: Optional[_timedelta] = None,         **kwargs,     ) -> XdsTestClient:         test_client = self.client_runner.run(             server_target=server_target, **kwargs         )+        test_client.wait_for_active_ads_channel(","Since we technically don't check for the ADS specifically, we probably should say `xds` instead of `ads`.Also, looks like we'd need to rename `wait_for_active_server_channel`. Both say `wait_for_active_`, but we check for completely different things. Maybe let's rename `wait_for_active_server_channel` to `wait_for_server_channel_ready` and rename `wait_for_active_ads_channel` to `wait_for_xds_channel_active`?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/33786,1353593506,2023-10-10T23:06:15Z,src/cpp/common/tls_credentials_options.cc,"@@ -46,10 +47,9 @@ void TlsCredentialsOptions::set_certificate_provider(  void TlsCredentialsOptions::set_crl_provider(     std::shared_ptr<CrlProvider> crl_provider) {-  crl_provider_ = std::move(crl_provider);-  if (crl_provider_ != nullptr) {+  if (crl_provider != nullptr) {","Still need to remove this check.  We should unconditionally pass it to the C-core struct, even if it's null.",
295906,drfloob,https://api.github.com/repos/grpc/grpc/pulls/34400,1355313300,2023-10-11T16:08:39Z,src/core/lib/event_engine/windows/grpc_polled_fd_windows.h,"@@ -0,0 +1,210 @@+// Copyright 2023 The gRPC Authors+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.++#ifndef GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H+#define GRPC_SRC_CORE_LIB_EVENT_ENGINE_WINDOWS_GRPC_POLLED_FD_WINDOWS_H++#include <grpc/support/port_platform.h>++#include ""src/core/lib/iomgr/port.h""  // IWYU pragma: keep++#if GRPC_ARES == 1 && defined(GRPC_WINDOWS_SOCKET_ARES_EV_DRIVER)++#include <memory>++#include <ares.h>++#include ""absl/functional/any_invocable.h""+#include ""absl/status/status.h""++#include <grpc/event_engine/event_engine.h>++#include ""src/core/lib/event_engine/common_closures.h""+#include ""src/core/lib/event_engine/grpc_polled_fd.h""+#include ""src/core/lib/event_engine/windows/iocp.h""+#include ""src/core/lib/event_engine/windows/win_socket.h""+#include ""src/core/lib/gprpp/sync.h""++// TODO(apolcyn): remove this hack after fixing upstream.+// Our grpc/c-ares code on Windows uses the ares_set_socket_functions API,+// which uses ""struct iovec"" type, which on Windows is defined inside of+// a c-ares header that is not public.+// See https://github.com/c-ares/c-ares/issues/206.+struct iovec {+  void* iov_base;+  size_t iov_len;+};++namespace grpc_event_engine {+namespace experimental {++class GrpcPolledFdFactoryWindows : public GrpcPolledFdFactory {+ public:+  explicit GrpcPolledFdFactoryWindows(IOCP* iocp);+  ~GrpcPolledFdFactoryWindows() override = default;++  void Initialize(grpc_core::Mutex* mutex, EventEngine* event_engine) override;+  GrpcPolledFdReturnType NewGrpcPolledFdLocked(ares_socket_t as) override;+  void ConfigureAresChannelLocked(ares_channel channel) override;++ private:+  // c-ares reads and takes action on the error codes of the+  // ""virtual socket operations"" in this file, via the WSAGetLastError+  // APIs. If code in this file wants to set a specific WSA error that+  // c-ares should read, it must do so by calling SetWSAError() on the+  // WSAErrorContext instance passed to it. A WSAErrorContext must only be+  // instantiated at the top of the virtual socket function callstack.+  class WSAErrorContext {+   public:+    explicit WSAErrorContext(){};++    ~WSAErrorContext() {+      if (error_ != 0) {+        WSASetLastError(error_);+      }+    }++    // Disallow copy and assignment operators+    WSAErrorContext(const WSAErrorContext&) = delete;+    WSAErrorContext& operator=(const WSAErrorContext&) = delete;++    void SetWSAError(int error) { error_ = error; }++   private:+    int error_ = 0;+  };++  // c-ares creates its own sockets and is meant to read them when readable and+  // write them when writeable. To fit this socket usage model into the grpc+  // windows poller (which gives notifications when attempted reads and writes+  // are actually fulfilled rather than possible), this GrpcPolledFdWindows+  // class takes advantage of the ares_set_socket_functions API and acts as a+  // virtual socket. It holds its own read and write buffers which are written+  // to and read from c-ares and are used with the grpc windows poller, and it,+  // e.g., manufactures virtual socket error codes when it e.g. needs to tell+  // the c-ares library to wait for an async read.+  class GrpcPolledFdWindows+      : public GrpcPolledFd,+        public std::enable_shared_from_this<GrpcPolledFdWindows> {+   public:+    GrpcPolledFdWindows(std::unique_ptr<WinSocket> winsocket,+                        grpc_core::Mutex* mu, int address_family,+                        int socket_type, EventEngine* event_engine);+    ~GrpcPolledFdWindows() override;++    void RegisterForOnReadableLocked(","Ah, that's too bad, I thought some progress had been made there. Thanks for checking!",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/34291,1355881535,2023-10-11T23:28:08Z,src/python/grpcio/grpc/_server.py,"@@ -121,6 +122,7 @@ class _HandlerCallDetails(   class _RPCState(object):+    context: contextvars.Context",Can we add some text to [the public documentation](https://github.com/grpc/grpc/blob/f092b7a73f5d097c411f7cd17d47dab2a839e090/src/python/grpcio/grpc/__init__.py#L1391) about this new guarantee that contextvars will be propagated between server interceptors? Likewise for the asyncio modifications?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34617,1357188279,2023-10-12T17:48:58Z,include/grpc/impl/channel_arg_names.h,"@@ -328,6 +328,9 @@ /** Channel arg to set http proxy per channel. If set, the channel arg  *  value will be preferred over the environment variable settings. */ #define GRPC_ARG_HTTP_PROXY ""grpc.http_proxy""+/** Channel arg to set proxy per channel. If set, the channel arg+ *  value will be preferred over the environment variable settings. */+#define GRPC_ARG_ADDRESS_PROXY ""grpc.address_proxy""",Please add the second channel arg to support specifying the list of address ranges for which this proxy will be used.  I don't think we want to add one without the other.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34618,1358504538,2023-10-13T16:46:46Z,src/core/ext/transport/chttp2/transport/chttp2_transport.cc,"@@ -610,9 +607,12 @@ static void init_keepalive_pings_if_enabled_locked( grpc_chttp2_transport::grpc_chttp2_transport(     const grpc_core::ChannelArgs& channel_args, grpc_endpoint* ep,     bool is_client)-    : refs(1, GRPC_TRACE_FLAG_ENABLED(grpc_trace_chttp2_refcount)-                  ? ""chttp2_refcount""-                  : nullptr),+    : grpc_core::RefCounted<grpc_chttp2_transport,+                            grpc_core::NonPolymorphicRefCount>(+          GRPC_TRACE_FLAG_ENABLED(grpc_trace_chttp2_refcount)+              ? ""chttp2_refcount""+              : nullptr,+          1),",This parameter is not necessary.,X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34692,1360853359,2023-10-16T15:23:25Z,src/cpp/ext/otel/otel_plugin.h,"@@ -65,9 +65,11 @@ class LabelsInjector {  public:   virtual ~LabelsInjector() {}   // Read the incoming initial metadata to get the set of labels to be added to-  // metrics.+  // metrics. If \a received_peer_metadata is not nullptr, it is set to true if+  // peer's metadata was received on the wire, false otherwise.   virtual std::unique_ptr<LabelsIterable> GetLabels(-      grpc_metadata_batch* incoming_initial_metadata) = 0;+      grpc_metadata_batch* incoming_initial_metadata,+      bool* received_peer_metadata) = 0;","Instead of exposing this bit in the `LabelsInjector` API and handling this in the OTel call tracers, I think we should instead handle this inside of the `LabelsInjector` impl itself.  The reason I say that is that in the future, if we replace metadata exchange with a metadata lookup service, the concept of ""received metadata from peer"" will no longer be relevant, and we won't want to have this state machinery stick around.",X
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34692,1361132379,2023-10-16T18:40:02Z,src/cpp/ext/otel/otel_plugin.h,"@@ -65,9 +65,11 @@ class LabelsInjector {  public:   virtual ~LabelsInjector() {}   // Read the incoming initial metadata to get the set of labels to be added to-  // metrics.+  // metrics. If \a received_peer_metadata is not nullptr, it is set to true if+  // peer's metadata was received on the wire, false otherwise.   virtual std::unique_ptr<LabelsIterable> GetLabels(-      grpc_metadata_batch* incoming_initial_metadata) = 0;+      grpc_metadata_batch* incoming_initial_metadata,+      bool* received_peer_metadata) = 0;","We don't need this ability on the client anyway, so it'd be fine with a nullptr on the client side.It's just the server that has to check whether the client sent metadata before it attaches metadata itself, whereas the client always attaches metadata.",
672669,sergiitk,https://api.github.com/repos/grpc/grpc/pulls/34687,1361156517,2023-10-16T19:06:02Z,tools/run_tests/xds_k8s_test_driver/framework/infrastructure/gcp/compute.py,"@@ -585,7 +586,7 @@ def _operation_status_done(operation):      @staticmethod     def _log_debug_header(resp: httplib2.Response):-        if DEBUG_HEADER_IN_RESPONSE in resp:+        if DEBUG_HEADER_IN_RESPONSE in resp and resp.status != HTTP_OK_STATUS:","```suggestion        if DEBUG_HEADER_IN_RESPONSE in resp and resp.status >= 300:```There are other commonly used positive 2xx http responses, f.e. `201 Created` is a very common positive status. Let's just do what [googleapis library](https://github.com/googleapis/google-api-python-client/blob/6fa72cd3e8e747395f9569c6f246ca4d12459b03/googleapiclient/http.py#L1597-L1598C68) does: `resp.status >= 300`.",
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34692,1361371953,2023-10-17T00:00:59Z,src/cpp/ext/csm/metadata_exchange.cc,"@@ -301,8 +309,8 @@ class MeshLabelsIterable : public LabelsIterable {    const std::vector<std::pair<absl::string_view, std::string>>& local_labels_;   // Holds either the metadata slice or the decoded proto struct.-  mutable absl::variant<grpc_core::Slice, StructPb> metadata_;-  mutable GcpResourceType type_;+  mutable absl::variant<absl::optional<grpc_core::Slice>, StructPb> metadata_;","I can also simply say that an empty slice is not a valid value for the metadata, and that makes it more simple",
28025951,HannahShiSFB,https://api.github.com/repos/grpc/grpc/pulls/33786,1361463160,2023-10-17T03:16:17Z,test/cpp/end2end/BUILD,"@@ -1056,3 +1056,45 @@ grpc_cc_test(         ""//test/cpp/util:test_util"",     ], )++grpc_cc_test(+    name = ""crl_provider_test"",+    srcs = [""crl_provider_test.cc""],+    data = [+        ""//src/core/tsi/test_creds:ca.pem"",+        ""//src/core/tsi/test_creds:client.key"",+        ""//src/core/tsi/test_creds:client.pem"",+        ""//src/core/tsi/test_creds:server1.key"",+        ""//src/core/tsi/test_creds:server1.pem"",+        ""//test/core/tsi/test_creds/crl_data:ca.pem"",+        ""//test/core/tsi/test_creds/crl_data:intermediate_ca.key"",+        ""//test/core/tsi/test_creds/crl_data:intermediate_ca.pem"",+        ""//test/core/tsi/test_creds/crl_data:leaf_and_intermediate_chain.pem"",+        ""//test/core/tsi/test_creds/crl_data:leaf_signed_by_intermediate.key"",+        ""//test/core/tsi/test_creds/crl_data:leaf_signed_by_intermediate.pem"",+        ""//test/core/tsi/test_creds/crl_data:revoked.key"",+        ""//test/core/tsi/test_creds/crl_data:revoked.pem"",+        ""//test/core/tsi/test_creds/crl_data:valid.key"",+        ""//test/core/tsi/test_creds/crl_data:valid.pem"",+        ""//test/core/tsi/test_creds/crl_data/crls:ab06acdd.r0"",+        ""//test/core/tsi/test_creds/crl_data/crls:b9322cac.r0"",+        ""//test/core/tsi/test_creds/crl_data/crls:current.crl"",+        ""//test/core/tsi/test_creds/crl_data/crls:intermediate.crl"",+        ""//test/core/tsi/test_creds/crl_data/crls_missing_intermediate:ab06acdd.r0"",+        ""//test/core/tsi/test_creds/crl_data/crls_missing_root:b9322cac.r0"",","Looks like file path is [not supported](https://github.com/bazelbuild/rules_apple/blob/3.0.0/test/ios_application_resources_test.sh#L148-L184C10) for ios rules.A quick fix would be only add files that are actually used in your test, looks like they passes with https://github.com/grpc/grpc/pull/34707/commits/fe118acde612b03aa31248eb707dfc3641707990 in #34707 which I only removed the ones that conflicts. From what I see in you test, only 6 of those files are used.--@sampajano We probably can just remove job `grpc_bazel_cpp_ios_event_engine_experiment_tests.cfg` as per our previous discussion, 0 test was actually executed on iOS.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34693,1362421823,2023-10-17T16:28:01Z,test/cpp/ext/otel/otel_plugin_test.cc,"@@ -121,6 +121,7 @@ TEST_F(OTelPluginEnd2EndTest, ClientAttemptSentTotalCompressedMessageSize) {           &data[kMetricName][0].point_data);   ASSERT_NE(point_data, nullptr);   ASSERT_EQ(point_data->count_, 1);+  ASSERT_EQ(absl::get<int64_t>(point_data->max_), 5);","I don't think this is the right layer to add a test of chttp2 stats collection:- it's quite disconnected from the code under test, which means when it breaks the author of that pr will have to spend substantial time connecting the dots- it locks otel usage to chttp2, and it's likely at this point that we'll see otel + chaotic good usage next year- it ties our testing to otel: if we decide to move to a different telemetry library in the future (this has happened before) we lose test coverage on our transportsI'd recommend instead adding a core end2end test that injects a filter or a custom call tracer, and exercise it just with http2 transports.",X
4181124,yashykt,https://api.github.com/repos/grpc/grpc/pulls/34693,1362564667,2023-10-17T18:10:20Z,test/cpp/ext/otel/otel_plugin_test.cc,"@@ -121,6 +121,7 @@ TEST_F(OTelPluginEnd2EndTest, ClientAttemptSentTotalCompressedMessageSize) {           &data[kMetricName][0].point_data);   ASSERT_NE(point_data, nullptr);   ASSERT_EQ(point_data->count_, 1);+  ASSERT_EQ(absl::get<int64_t>(point_data->max_), 5);","I can add a http2 specific test (since it'll probably also be useful for future stats stuff), but for these metrics, the transport doesn't matter. All transports should be recording the same data size.",
1644595,gnossen,https://api.github.com/repos/grpc/grpc/pulls/34712,1362803102,2023-10-17T21:26:00Z,src/python/grpcio_tests/tests/unit/_api_test.py,"@@ -115,6 +116,21 @@ def test_secure_channel(self):         channel = grpc.secure_channel(""google.com:443"", channel_credentials)         channel.close() +    def test_multiple_secure_channel(self):+        def create_secure_channel():+            channel_credentials = grpc.ssl_channel_credentials()",Nit: You should probably synchronize with a [`WaitGroup`](https://github.com/grpc/grpc/blob/6d669e9c788bcdce9c7896a7d0af227c85c33372/src/python/grpcio_tests/tests/unit/test_common.py#L119) here so that the test is more likely to actually run the Core functions simultaneously.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/34697,1362832674,2023-10-17T21:50:34Z,src/core/ext/transport/chttp2/transport/internal.h,"@@ -462,6 +463,8 @@ struct grpc_chttp2_transport : public grpc_core::KeepsGrpcInitialized {   /// grace period to wait for data after sending a ping before keepalives   /// timeout   grpc_core::Duration keepalive_timeout;+  /// number of stream objects currently allocated by this transport+  std::atomic<size_t> streams_allocated{0};","init_stream (which uniquely calls the constructor for `grpc_chttp2_stream`) is called outside the combiner;To keep this code simple I don't want to reason about which path we're taking to get to the constructor (since it's weirdly different between client & server, etc...) - doing so would only lead to bugs (we don't want a security problem because we accidentally decremented too many times).Other places we use similar atomics (transport level):- every transport op- every time a stream is created or destroyed- every time a stream is removed- every ping- every read- every writeAlso at the stream level:- every time a stream becomes writable- every stream op (at least 2x)This is not including any of the refcounting that happens external to the transport.The atomic is not a concern.",X
85715732,yousukseung,https://api.github.com/repos/grpc/grpc/pulls/34592,1362898814,2023-10-17T22:51:18Z,src/core/lib/channel/tcp_tracer.h,"@@ -0,0 +1,140 @@+//+//+// Copyright 2023 gRPC authors.+//+// Licensed under the Apache License, Version 2.0 (the ""License"");+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//     http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an ""AS IS"" BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+//+//++#ifndef GRPC_SRC_CORE_LIB_CHANNEL_TCP_TRACER_H+#define GRPC_SRC_CORE_LIB_CHANNEL_TCP_TRACER_H++#include <grpc/support/port_platform.h>++#include <stddef.h>+#include <stdint.h>++#include <string>++#include ""absl/time/time.h""+#include ""absl/types/optional.h""++namespace grpc_core {++// Interface for TCP tracer implementations. Created by CallTracerInterface.+class TcpTracerInterface {+ public:+  enum class Type {+    kUnknown = 0,+    // When the sendmsg system call or its variants returned for the traced byte+    // offset.+    kSendMsg,+    // When the traced byte offset is enqueued in kernel schedulers (aka,+    // qdiscs). There can be multiple schedulers.+    kScheduled,+    // When the traced byte offset is handed over to the NIC.+    kSent,+    // When the acknowledgement for the traced byte offset was received.+    kAcked,+    // When the connection is closed. This is not associated with a byte offset.+    kClosed,+  };++  struct ConnectionMetrics {","It's up to the tracer implementation so we cannot tell, but it's generally from when the annotation is generated until the tracer decides to throw away. But `tcp_tracer` cannot depend on grpc components so I assume we cannot use `grpc_core::Table`. But TCP instrumentation assumes it's reasonably sampled to work without impact. In prod for example, we have the same above struct created from when the timestamp is parsed from kernel until the call completes (roughly), but this only works with 0.1% sampling or the overhead will be too much.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34617,1364082838,2023-10-18T15:25:06Z,src/core/ext/filters/client_channel/http_proxy_mapper.cc,"@@ -58,14 +57,10 @@ namespace grpc_core { namespace { -bool ServerInCIDRRange(absl::string_view server_host,+bool ServerInCIDRRange(const grpc_resolved_address& server_address,                        absl::string_view no_proxy_entry) {","Please rename this parameter to `cidr_range`, since it's now being used for both no-proxy and yes-proxy ranges.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34617,1364165953,2023-10-18T16:21:04Z,test/core/client_channel/http_proxy_mapper_test.cc,"@@ -32,12 +36,55 @@ #include ""test/core/util/scoped_env_var.h"" #include ""test/core/util/test_config.h"" +// Need to be in the same namespace as absl::optional...+namespace absl {","It's not okay to put code into the `absl` namespace, since we don't own that namespace.Instead, I suggest you change the matcher to explictly print whatever you want.  For example, you can replace line 85 with the following:```if (*address_string != address) {  *result_listener << ""Actual address: "" << *address_string;  return false;}return true;```Alternatively, you can explicitly print things in the individual tests via something like this:```EXPECT_THAT(address, AddressEq(""1.2.3.4""))    << grpc_sockaddr_to_string(address, true).value_or(""unknown"");```",X
287917,eugeneo,https://api.github.com/repos/grpc/grpc/pulls/34617,1364255089,2023-10-18T17:18:48Z,test/core/client_channel/http_proxy_mapper_test.cc,"@@ -32,12 +36,55 @@ #include ""test/core/util/scoped_env_var.h"" #include ""test/core/util/test_config.h"" +// Need to be in the same namespace as absl::optional...+namespace absl {","I removed these function, but I would like to suggest considering building a library of functions as it would be a significant boost to productivity. E.g. we could consider moving `AddressEq` matcher to a shared header.",X
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/34617,1364609837,2023-10-18T22:14:21Z,test/core/client_channel/http_proxy_mapper_test.cc,"@@ -32,12 +36,55 @@ #include ""test/core/util/scoped_env_var.h"" #include ""test/core/util/test_config.h"" +// Need to be in the same namespace as absl::optional...+namespace absl {",I'd be fine with having a common library of matchers.  We already have a similar one here: https://github.com/grpc/grpc/blob/a0c1027bb3da36bfa5d3eb2630fd62dd79d41608/test/core/resolver/endpoint_addresses_test.cc#L48,X
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/34400,1364650810,2023-10-18T22:44:15Z,src/core/lib/event_engine/ares_resolver.h,"@@ -87,10 +87,14 @@ class AresResolver : public grpc_core::InternallyRefCounted<AresResolver> {   // close the socket (possibly through ares_destroy).   struct FdNode {     FdNode() = default;-    FdNode(ares_socket_t as, GrpcPolledFd* polled_fd)-        : as(as), polled_fd(polled_fd) {}+    FdNode(ares_socket_t as, GrpcPolledFd* pf) : as(as), polled_fd(pf) {}     ares_socket_t as;+#ifdef GPR_WINDOWS+    // On Windows, GrpcPolledFd is owned by the GrpcPolledFdFactory.+    GrpcPolledFd* polled_fd;",I'm not crazy about changing the type of this field based on platform.I think we could push this complexity into grpc polled fd windows:`NewGrpcPolledFd` on windows can return `GrpcPolledFdWrapper`.`GrpcPolledFdWrapper` can be a thin wrapper over `GrpcPolledFd`:- delegate all methods to the inner object- dtor does nothing and simply releases the inner object,
13387,jpkrohling,https://api.github.com/repos/keycloak/keycloak/pulls/517,14994798,2014-07-16T12:48:39Z,integration/admin-client/pom.xml,"@@ -0,0 +1,46 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<project xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">+    <parent>+        <artifactId>keycloak-parent</artifactId>+        <groupId>org.keycloak</groupId>+        <version>1.0-beta-4-SNAPSHOT</version>+        <relativePath>../../pom.xml</relativePath>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>admin-client</artifactId>+    <name>Keycloak Admin REST Client</name>++    <dependencies>+        <dependency>+            <groupId>org.keycloak</groupId>+            <artifactId>keycloak-core</artifactId>+            <version>1.0-beta-2</version>+        </dependency>+        <dependency>+            <groupId>org.codehaus.jackson</groupId>+            <artifactId>jackson-mapper-asl</artifactId>+            <version>1.9.13</version>+        </dependency>+        <dependency>+            <groupId>org.apache.httpcomponents</groupId>+            <artifactId>httpclient</artifactId>+            <version>4.0-alpha4</version>","The parent specifies already a property with the httpcomponents to use, which is currently set to 4.2.1. So, you can use ${keycloak.apache.httpcomponents.version} instead of a fixed version. Note that this is probably the reason for some compilation issues (see other comments).",X
13387,jpkrohling,https://api.github.com/repos/keycloak/keycloak/pulls/517,14994861,2014-07-16T12:49:44Z,integration/admin-client/src/main/java/org/keycloak/admin/client/http/methods/KeycloakHttpDelete.java,"@@ -0,0 +1,126 @@+package org.keycloak.admin.client.http.methods;++import org.keycloak.admin.client.http.AuthorizationHeader;+import org.keycloak.admin.client.token.TokenManager;+import org.apache.http.HttpEntity;+import org.apache.http.HttpException;+import org.apache.http.HttpResponse;+import org.apache.http.client.methods.HttpDelete;+import org.apache.http.entity.StringEntity;++import java.io.IOException;+import java.io.UnsupportedEncodingException;+import java.net.URISyntaxException;+import java.util.Map;++/**+ * @author rodrigo.sasaki@icarros.com.br+ */+public class KeycloakHttpDelete extends KeycloakHttpMethod{+    +    private HttpEntity entity;++    private boolean hasStringBody;++    public KeycloakHttpDelete(String url, TokenManager tokenManager){+        super(url, tokenManager);+    }++    @Override+    public HttpResponse execute(){+        if(hasBody()){+            return executeWithBody();+        } else {+            return executeWithoutBody();+        }+    }+    +    public HttpResponse executeWithBody(){+        HttpResponse response = null;+        try {+            HttpDeleteWithBody delete = new HttpDeleteWithBody(url);+            delete.setEntity(entity);+            handleHeaders(delete);+            response = client.execute(delete);+        } catch (HttpException e) {","This caused a compilation problem in my local machine. I believe it's because of the updated version of httpcomponents. So, this catch needs to be removed.",
13387,jpkrohling,https://api.github.com/repos/keycloak/keycloak/pulls/517,14994897,2014-07-16T12:50:49Z,integration/admin-client/src/main/java/org/keycloak/admin/client/http/methods/KeycloakHttpDelete.java,"@@ -0,0 +1,126 @@+package org.keycloak.admin.client.http.methods;++import org.keycloak.admin.client.http.AuthorizationHeader;+import org.keycloak.admin.client.token.TokenManager;+import org.apache.http.HttpEntity;+import org.apache.http.HttpException;+import org.apache.http.HttpResponse;+import org.apache.http.client.methods.HttpDelete;+import org.apache.http.entity.StringEntity;++import java.io.IOException;+import java.io.UnsupportedEncodingException;+import java.net.URISyntaxException;+import java.util.Map;++/**+ * @author rodrigo.sasaki@icarros.com.br+ */+public class KeycloakHttpDelete extends KeycloakHttpMethod{+    +    private HttpEntity entity;++    private boolean hasStringBody;++    public KeycloakHttpDelete(String url, TokenManager tokenManager){+        super(url, tokenManager);+    }++    @Override+    public HttpResponse execute(){+        if(hasBody()){+            return executeWithBody();+        } else {+            return executeWithoutBody();+        }+    }+    +    public HttpResponse executeWithBody(){+        HttpResponse response = null;+        try {+            HttpDeleteWithBody delete = new HttpDeleteWithBody(url);+            delete.setEntity(entity);+            handleHeaders(delete);+            response = client.execute(delete);+        } catch (HttpException e) {+            e.printStackTrace();+        } catch (IOException e) {+            e.printStackTrace();","Instead of just printing the stack trace, what about letting it throw the original exception? The caller can then decide what to do. Or, perhaps the caller could configure how many retries it would like to be performed, in case of a communications failure. I remember seeing something similar on the Wildfly Adapter code. ",X
13387,jpkrohling,https://api.github.com/repos/keycloak/keycloak/pulls/1043,26391917,2015-03-13T14:56:37Z,forms/common-themes/src/main/resources/theme/admin/base/resources/partials/realm-credentials.html,"@@ -46,7 +46,9 @@                             <input class=""form-control disabled"" type=""text"" value=""{{p.name|capitalize}}"" readonly>                         </td>                         <td>-                            <input class=""form-control"" ng-model=""p.value"" type=""number"" placeholder=""No value assigned""  min=""1"">+                            <input class=""form-control"" ng-model=""p.value"" ng-show=""p.name != 'notUsername' ""","""not username"" doesn't requires any parameters, so, don't show a field for entering the value if the policy is ""not username""",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/1283,31125994,2015-05-27T12:03:26Z,services/src/main/java/org/keycloak/services/resources/admin/RealmAdminResource.java,"@@ -416,10 +419,25 @@ public void updateRealmEventsConfig(final RealmEventsConfigRepresentation rep) {         }                  if(dateFrom != null) {-            query.fromDate(dateFrom);+            SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd"");+            Date from = null;+            try {+                from = df.parse(dateFrom);+            } catch (ParseException e) {+                e.printStackTrace();","This should return an error (or throw exception), not just ""swallow"" the exception",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/1283,31223396,2015-05-28T11:16:34Z,services/src/main/java/org/keycloak/services/resources/admin/RealmAdminResource.java,"@@ -416,10 +420,25 @@ public void updateRealmEventsConfig(final RealmEventsConfigRepresentation rep) {         }                  if(dateFrom != null) {-            query.fromDate(dateFrom);+            SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd"");+            Date from = null;+            try {+                from = df.parse(dateFrom);+            } catch (ParseException e) {+                return new ArrayList<Event>();",This should return an error or throw an exception - not just return an empty list of events,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/1297,31499623,2015-06-02T07:58:05Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java,"@@ -269,6 +265,31 @@ public Response buildRefreshToken() {         return Cors.add(request, Response.ok(res, MediaType.APPLICATION_JSON_TYPE)).auth().allowedOrigins(client).allowedMethods(""POST"").exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS).build();     } +    private void updateClientSession(ClientSessionModel clientSession) {+        if(clientSession == null) {+            logger.error(""client session is null"");+            return;+        }+        String adapterSessionId = formParams.getFirst(AdapterConstants.CLIENT_SESSION_STATE);+        if (adapterSessionId != null) {+            String adapterSessionHost = formParams.getFirst(AdapterConstants.CLIENT_SESSION_HOST);+            logger.debugf(""Adapter Session '%s' saved in ClientSession for client '%s'. Host is '%s'"", adapterSessionId, client.getClientId(), adapterSessionHost);++            event.detail(AdapterConstants.CLIENT_SESSION_STATE, adapterSessionId);+            clientSession.setNote(AdapterConstants.CLIENT_SESSION_STATE, adapterSessionId);+            event.detail(AdapterConstants.CLIENT_SESSION_HOST, adapterSessionHost);+            clientSession.setNote(AdapterConstants.CLIENT_SESSION_HOST, adapterSessionHost);+        }+    }++    private void updateClientSessions(List<ClientSessionModel> clientSessions) {+        for (ClientSessionModel clientSession : clientSessions) {+            if(client.getClientId().equals(client.getClientId())) {","Thanks for the PR. Few comments:- There is bug in this condition.  if(client.getClientId().equals(client.getClientId())) is always true. You may want to compare with clientId from the clientSession right?- Is it possible to add the test for changing clientSessionState during refresh? We already have some tests as part of AdapterTest (and AdapterTestStrategy) class for classic logout, however I guess that you're not using keycloak adapters but you have some custom adapter code of your own?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/1350,32104807,2015-06-10T10:28:13Z,forms/common-themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -122,8 +122,8 @@ }  #kc-login {","This is not correct. As the login button is on the left side there's no need for the float. Also, by adding the margin you are adding a bigger margin that specified in PatternFly.We should just remove '#kc-login {....}' completely.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/1622,39733720,2015-09-17T11:07:20Z,forms/common-themes/src/main/resources/theme/base/login/login-update-profile.ftl,"@@ -6,6 +6,15 @@         ${msg(""loginProfileTitle"")}     <#elseif section = ""form"">         <form id=""kc-update-profile-form"" class=""${properties.kcFormClass!}"" action=""${url.loginAction}"" method=""post"">+            <div class=""${properties.kcFormGroupClass!} ${messagesPerField.printIfExists('username',properties.kcFormGroupErrorClass!)}"" <#if !realm.editUsernameAllowed>style=""display:none""</#if>>","This should not hide the fields with css, instead the whole section should be omitted from the output when username can't be changed",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/1618,39809689,2015-09-17T23:06:15Z,forms/account-freemarker/src/main/java/org/keycloak/account/freemarker/FreeMarkerAccountProvider.java,"@@ -197,7 +197,11 @@ public Response createResponse(AccountPages page) {             String result = freeMarker.processTemplate(attributes, Templates.getTemplate(page), theme);             Response.ResponseBuilder builder = Response.status(status).type(MediaType.TEXT_HTML).entity(result);             BrowserSecurityHeaderSetup.headers(builder, realm);-            LocaleHelper.updateLocaleCookie(builder, locale, realm, uriInfo, Urls.localeCookiePath(baseUri,realm.getName()));++            String keycloakLocaleCookiePath = Urls.localeCookiePath(baseUri, realm.getName());","I've got it working with $translate.use.  The only caveat is that the KEYCLOAK_LOCALE cookie needs to use root as its path.  The reason is because to share a cookie both angular and Freemarker pages need a common subpath.  The only one guaranteed to work for both is ""/"".  Really, that's been the sticking point all along.I don't know of any reason why using the root path for a cookie would cause a problem, but I wanted to make you aware in case you know of problems with that.  If you are OK with this solution I'll clean everything up and update the PR.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/1618,39830654,2015-09-18T07:36:39Z,forms/account-freemarker/src/main/java/org/keycloak/account/freemarker/FreeMarkerAccountProvider.java,"@@ -197,7 +197,11 @@ public Response createResponse(AccountPages page) {             String result = freeMarker.processTemplate(attributes, Templates.getTemplate(page), theme);             Response.ResponseBuilder builder = Response.status(status).type(MediaType.TEXT_HTML).entity(result);             BrowserSecurityHeaderSetup.headers(builder, realm);-            LocaleHelper.updateLocaleCookie(builder, locale, realm, uriInfo, Urls.localeCookiePath(baseUri,realm.getName()));++            String keycloakLocaleCookiePath = Urls.localeCookiePath(baseUri, realm.getName());",Actually thinking about this some more maybe we shouldn't use a cookie at all. The only reason we use a cookie for login forms is that there's not always a user logged-in. For the admin console though there's always a logged-in user. As the users selected locale is available on the user model we could just add to the whoAmI endpoint to also return the locale? This would be more similar to the approach that users own applications would need to use. They'd add the locale to the token and get it from there.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/1783,44420177,2015-11-10T15:34:34Z,forms/common-themes/src/main/resources/theme/base/admin/resources/partials/required-actions.html,"@@ -20,8 +20,8 @@         <tbody>         <tr ng-repeat=""requiredAction in requiredActions"" data-ng-show=""requiredActions.length > 0"">             <td>{{requiredAction.name}}</td>-            <td><input type=""checkbox"" ng-model=""requiredAction.enabled"" ng-change=""updateRequiredAction(requiredAction)""></td>-            <td><input type=""checkbox"" ng-model=""requiredAction.defaultAction"" ng-change=""updateRequiredAction(requiredAction)""></td>+            <td><input type=""checkbox"" ng-model=""requiredAction.enabled"" ng-change=""updateRequiredAction(requiredAction)"" id=""{{requiredAction.alias}}""></td>",I believe that's similar to above. Selecting directly the checkbox is in my opinion better and more robust approach than relying on text in the previous column.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/1783,44510191,2015-11-11T08:18:59Z,forms/common-themes/src/main/resources/theme/base/admin/resources/partials/required-actions.html,"@@ -20,8 +20,8 @@         <tbody>         <tr ng-repeat=""requiredAction in requiredActions"" data-ng-show=""requiredActions.length > 0"">             <td>{{requiredAction.name}}</td>-            <td><input type=""checkbox"" ng-model=""requiredAction.enabled"" ng-change=""updateRequiredAction(requiredAction)""></td>-            <td><input type=""checkbox"" ng-model=""requiredAction.defaultAction"" ng-change=""updateRequiredAction(requiredAction)""></td>+            <td><input type=""checkbox"" ng-model=""requiredAction.enabled"" ng-change=""updateRequiredAction(requiredAction)"" id=""{{requiredAction.alias}}""></td>","I don't think it's similar to above. We can end up with overusing IDs if we're not careful. I'm happy with either here, but the ID should use the pattern <id>+<element>. So it would be ""{{requiredAction.name}}.enabled"" and ""{{requiredAction.name}}.defaultAction"". I'd still say it would be better to just have ID on the tr and use names within.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2202,52435492,2016-02-10T09:51:20Z,services/src/main/java/org/keycloak/services/resources/RealmsResource.java,"@@ -115,6 +119,41 @@ public Object getProtocol(final @PathParam(""realm"") String name,         return endpoint;     } +    /**+     * Returns a temporary redirect to the client url configured for the given {@code clientId} in the given {@code realmName}.+     * <p>+     * This allows a client to refer to other clients just by their client id in URLs, will then redirect users to the actual client url.+     * The client url is derived according to the rules of the base url in the client configuration.+     * </p>+     *+     * @param realmName+     * @param clientId+     * @return+     * @since 1.9+     */+    @GET+    @Path(""{realm}/clients/{client_id}/redirect"")","This is the same path as the client-registration service is registered at. We either need a different path for this or move the client-registration. With regards to having a clients landing page like we discussed in mailing list it makes more sense to move client registration service, but that means changing endpoints that are already included in past releases. I'll figure out what to do here.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/2202,52720670,2016-02-12T09:36:55Z,testsuite/integration/src/test/java/org/keycloak/testsuite/RealmResourceTest.java,"@@ -0,0 +1,67 @@+package org.keycloak.testsuite;++import org.junit.ClassRule;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.models.ClientModel;+import org.keycloak.models.RealmModel;+import org.keycloak.services.managers.RealmManager;+import org.keycloak.testsuite.rule.KeycloakRule;+import org.keycloak.testsuite.rule.KeycloakRule.KeycloakSetup;+import org.keycloak.testsuite.rule.WebResource;+import org.keycloak.testsuite.rule.WebRule;+import org.openqa.selenium.WebDriver;++import static org.junit.Assert.assertEquals;++/**+ * @author <a href=""mailto:thomas.darimont@gmail.com"">Thomas Darimont</a>+ */+public class RealmResourceTest {++    @ClassRule+    public static KeycloakRule keycloakRule = new KeycloakRule(new KeycloakSetup() {++        @Override+        public void config(RealmManager manager, RealmModel adminstrationRealm, RealmModel appRealm) {++            RealmModel testRealm = manager.getRealmByName(""test"");++            ClientModel launchpadClient = testRealm.addClient(""launchpad-test"");+            launchpadClient.setBaseUrl("""");+            launchpadClient.setRootUrl(""http://example.org/launchpad"");++            ClientModel dummyClient = testRealm.addClient(""dummy-test"");+            dummyClient.setRootUrl(""http://example.org/dummy"");+            dummyClient.setBaseUrl(""/base-path"");+        }+    });++    @Rule+    public WebRule webRule = new WebRule(this);++    @WebResource+    protected OAuthClient oauth;++    @WebResource+    protected WebDriver webDriver;++    /**+     * Integration test for {@link org.keycloak.services.resources.RealmsResource#getRedirect(String, String)}.+     * @throws Exception+     */+    @Test+    public void testClientRedirectEndpoint() throws Exception {++        oauth.doLogin(""test-user@localhost"", ""password"");++        webDriver.get(""http://localhost:8081/auth/realms/test/clients/launchpad-test/redirect"");","How can I parameterize the keycloak port here? Just via: `System.getProperties(""keycloak.port"")` or via `System.getenv(""KEYCLOAK_DEV_PORT"")`?",X
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/2202,52723555,2016-02-12T10:08:18Z,testsuite/integration/src/test/java/org/keycloak/testsuite/RealmResourceTest.java,"@@ -0,0 +1,67 @@+package org.keycloak.testsuite;++import org.junit.ClassRule;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.models.ClientModel;+import org.keycloak.models.RealmModel;+import org.keycloak.services.managers.RealmManager;+import org.keycloak.testsuite.rule.KeycloakRule;+import org.keycloak.testsuite.rule.KeycloakRule.KeycloakSetup;+import org.keycloak.testsuite.rule.WebResource;+import org.keycloak.testsuite.rule.WebRule;+import org.openqa.selenium.WebDriver;++import static org.junit.Assert.assertEquals;++/**+ * @author <a href=""mailto:thomas.darimont@gmail.com"">Thomas Darimont</a>+ */+public class RealmResourceTest {++    @ClassRule+    public static KeycloakRule keycloakRule = new KeycloakRule(new KeycloakSetup() {++        @Override+        public void config(RealmManager manager, RealmModel adminstrationRealm, RealmModel appRealm) {++            RealmModel testRealm = manager.getRealmByName(""test"");++            ClientModel launchpadClient = testRealm.addClient(""launchpad-test"");+            launchpadClient.setBaseUrl("""");+            launchpadClient.setRootUrl(""http://example.org/launchpad"");++            ClientModel dummyClient = testRealm.addClient(""dummy-test"");+            dummyClient.setRootUrl(""http://example.org/dummy"");+            dummyClient.setBaseUrl(""/base-path"");+        }+    });++    @Rule+    public WebRule webRule = new WebRule(this);++    @WebResource+    protected OAuthClient oauth;++    @WebResource+    protected WebDriver webDriver;++    /**+     * Integration test for {@link org.keycloak.services.resources.RealmsResource#getRedirect(String, String)}.+     * @throws Exception+     */+    @Test+    public void testClientRedirectEndpoint() throws Exception {++        oauth.doLogin(""test-user@localhost"", ""password"");++        webDriver.get(""http://localhost:8081/auth/realms/test/clients/launchpad-test/redirect"");","Okay, I try to adapt that - though I've some issues:- How can I create the two test clients within the test realms? The KeycloakServer (as well as WebDriver, WebRule) rule isn't available to the arquillian-integration tests- Do I need to create ""Page"" to test the redirect?I couldn't find an example that does something similar in arquillian-integration tests - or did I miss something? Any hints?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2299,54526777,2016-03-01T06:14:45Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/authentication/actions/TermsAndConditionsTest.java,"@@ -0,0 +1,120 @@+/*+ * JBoss, Home of Professional Open Source+ *+ * Copyright 2013 Red Hat, Inc. and/or its affiliates.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.console.authentication.actions;++import java.util.concurrent.TimeUnit;+import org.jboss.arquillian.graphene.page.Page;+import org.junit.Assert;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.testsuite.auth.page.login.TermsAndConditions;+import org.keycloak.testsuite.console.AbstractConsoleTest;+import org.keycloak.testsuite.console.page.authentication.RequiredActions;+import org.keycloak.testsuite.console.page.users.User;+import org.keycloak.testsuite.console.page.users.CreateUser;++import org.keycloak.testsuite.console.page.users.UserAttributesForm;+import org.keycloak.testsuite.util.WaitUtils;++/**+ *+ */+public class TermsAndConditionsTest extends AbstractConsoleTest {++    private static final String USERNAME = ""user1"";+    +    private static final String PASSWORD = ""user1"";+    +    private static final String TERMS_TEXT = ""Terms and conditions to be defined"";+    +    @Page+    private RequiredActions requiredActionsPage;++    @Page+    private TermsAndConditions termsAndConditionsPage;++    @Page+    CreateUser createUser;+    +    @Page+    User user;++    /**+     * Increase 'implicitWait'. If smaller then logout from Test Realm Admin Console+     * may not succeed.+     */+    @Override+    protected void driverSettings() {+        driver.manage().timeouts().pageLoadTimeout(WaitUtils.PAGELOAD_TIMEOUT, TimeUnit.MILLISECONDS);+        driver.manage().timeouts().implicitlyWait(10000, TimeUnit.MILLISECONDS);+        driver.manage().window().maximize();+    }+    +    @Before+    public void createUserAccount() throws Exception {","You need to test 3 different scenarios for terms and conditions (T&C), here you are only testing one. The scenarios to test are:1. User exists prior to enabling terms and conditions. First login to check that the is not asked to confirm T&C, then add the required action through admin console and check the user is required2. User self-registers after T&C is enabled. Check that user is required to confirm T&C during registration.3. User is registered by admin. Check that user is required to confirm T&C on first login (this is what you are testing now).Finally you should not use the admin console (RequiredActions, CreateUser) to configure tests. Use the admin endpoints. Admin console approach is slow and unstable, which is why we've separated the admin console tests out.",
1183516,mbaluch,https://api.github.com/repos/keycloak/keycloak/pulls/2329,55335401,2016-03-08T09:36:08Z,testsuite/integration-arquillian/tests/other/console/src/main/resources/themes/qe/login/theme.properties,"@@ -0,0 +1 @@+parent=base","I missed that you recommended to ""use keycloak theme as base"". I think that there will be more tests on themes and IMO it will be easier to track what has been tested if we use base and add configuration with new tests. In case there will be much duplicated configuration we can change it later.What do you think?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2329,55336494,2016-03-08T09:46:21Z,testsuite/integration-arquillian/tests/other/console/src/main/resources/themes/qe/login/messages/messages_en.properties,"@@ -0,0 +1,4 @@+doAccept=Yes","No harm. It's fine to include, but personally I would stick with purely on the termsText and have a separate test for custom themes that do bigger modifications.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2329,55358073,2016-03-08T13:30:08Z,testsuite/integration-arquillian/tests/other/console/src/main/resources/themes/qe/login/messages/messages_en.properties,"@@ -0,0 +1,4 @@+doAccept=Yes",I've already merged. I wouldn't rename the test as this is testing the terms and conditions feature. I'd rather add a separate CustomThemeTest.,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2348,55638413,2016-03-10T06:23:09Z,adapters/spi/tomcat-adapter-spi/pom.xml,"@@ -29,17 +29,26 @@ 	<artifactId>keycloak-tomcat-adapter-spi</artifactId> 	<name>Keycloak Tomcat Adapter SPI</name>     <properties>-        <!-- <tomcat.version>8.0.14</tomcat.version> -->-        <!-- <tomcat.version>7.0.52</tomcat.version> -->         <tomcat.version>6.0.41</tomcat.version>     </properties> 	<description /> +    <dependencyManagement>",Tomcat adapters should use dependency versions from JBoss AS,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2348,55638425,2016-03-10T06:23:13Z,adapters/saml/tomcat/pom.xml,"@@ -30,6 +30,18 @@     <artifactId>keycloak-saml-tomcat-integration-pom</artifactId>     <packaging>pom</packaging> +    <dependencyManagement>",Tomcat adapters should use dependency versions from JBoss AS,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2348,55638441,2016-03-10T06:23:30Z,adapters/oidc/tomcat/pom.xml,"@@ -30,6 +30,18 @@     <artifactId>keycloak-tomcat-integration-pom</artifactId>     <packaging>pom</packaging> +    <dependencyManagement>",Tomcat adapters should use dependency versions from JBoss AS,
9034478,lkubik,https://api.github.com/repos/keycloak/keycloak/pulls/2348,56359448,2016-03-16T15:52:32Z,adapters/oidc/tomcat/pom.xml,"@@ -30,6 +30,18 @@     <artifactId>keycloak-tomcat-integration-pom</artifactId>     <packaging>pom</packaging> +    <dependencyManagement>",What do you mean by JBoss AS. This dependency managament is from JBoss AS.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2348,56797133,2016-03-21T09:36:19Z,adapters/oidc/tomcat/pom.xml,"@@ -30,6 +30,18 @@     <artifactId>keycloak-tomcat-integration-pom</artifactId>     <packaging>pom</packaging> +    <dependencyManagement>","I meant Tomcat adapters should not use dependency versions from JBoss AS 7/EAP. Tomcat is an active project, while JBoss AS7 is long been replaced by WildFly.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2381,56945025,2016-03-22T07:12:44Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/HttpClientBuilder.java,"@@ -287,16 +289,20 @@ public HttpClient build() {                 cm = new SingleClientConnManager(registry);             }             BasicHttpParams params = new BasicHttpParams();-            if (socketTimeout > -1)-            {++            if (proxyHost != null) {+                params.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHost);",Looks like this is deprecated - https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/params/ConnRoutePNames.html#DEFAULT_PROXY,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2381,57285003,2016-03-24T08:16:20Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/HttpClientBuilder.java,"@@ -287,16 +289,20 @@ public HttpClient build() {                 cm = new SingleClientConnManager(registry);             }             BasicHttpParams params = new BasicHttpParams();-            if (socketTimeout > -1)-            {++            if (proxyHost != null) {+                params.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxyHost);","What about the following from section 2.8 in https://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html:   HttpHost proxy = new HttpHost(""someproxy"", 8080);   DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);   CloseableHttpClient httpclient = HttpClients.custom()        .setRoutePlanner(routePlanner)        .build();",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/2826,63043615,2016-05-12T15:41:48Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/ClientAuthSignedJWTTest.java,"@@ -845,7 +845,9 @@ protected JsonWebToken createRequestToken(String clientId, String realmInfoUrl)              int now = Time.currentTime();             if (isClaimEnabled(""issuedAt"")) reqToken.issuedAt(now);-            if (isClaimEnabled(""expiration"")) reqToken.expiration(now + getTokenTimeout());+            // For the time being there's no getter for tokenTimeout in JWTClientCredentialsProvider","That crossed my mind too, but it didn't seem to me like very ""objective"" solution - it would break some object design principles (hiding a property). Adding a getter (either public or protected) looked like much more cleaner solution.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2826,63134894,2016-05-13T05:30:01Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/ClientAuthSignedJWTTest.java,"@@ -845,7 +845,9 @@ protected JsonWebToken createRequestToken(String clientId, String realmInfoUrl)              int now = Time.currentTime();             if (isClaimEnabled(""issuedAt"")) reqToken.issuedAt(now);-            if (isClaimEnabled(""expiration"")) reqToken.expiration(now + getTokenTimeout());+            // For the time being there's no getter for tokenTimeout in JWTClientCredentialsProvider","Well, one is changing the implementation for the sake of a test, which is bad! The other is working around it in the test, which is perfectly fine. It's a test, if you want to test that scenario then you have plenty of opportunities to retrieve the expiration without modifying the implementation. ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/2849,64174201,2016-05-23T06:36:45Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/AbstractBrokerTest.java,"@@ -113,22 +115,37 @@ protected IdentityProviderRepresentation createIdentityProvider(String alias, St         return identityProviderRepresentation;     } +    private void waitForPage(String title) {+        long startAt = System.currentTimeMillis();++        while (!driver.getTitle().toLowerCase().contains(title)+                && System.currentTimeMillis() - startAt < 200) {+            try {+                Thread.sleep(5);",Do NOT add 5 second sleeps. Any waiting for elements has to pull periodically and not just sleep for a long time (5 seconds \* 1000 tests is a long time!).,
2922117,chameleon82,https://api.github.com/repos/keycloak/keycloak/pulls/2925,67595414,2016-06-18T04:36:00Z,themes/src/main/resources/theme/base/account/messages/messages_ru.properties,"@@ -0,0 +1,151 @@+doSave=\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C+doCancel=\u041E\u0442\u043C\u0435\u043D\u0430+doLogOutAllSessions=\u0412\u044B\u0439\u0442\u0438 \u0438\u0437 \u0432\u0441\u0435\u0445 \u0441\u0435\u0441\u0441\u0438\u0439+doRemove=\u0423\u0434\u0430\u043B\u0438\u0442\u044C+doAdd=\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C+doSignOut=\u0412\u044B\u0445\u043E\u0434++editAccountHtmlTtile=\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0430\u043A\u043A\u0430\u0443\u043D\u0442","Realm' is often translated as ' ' (Security area). But it confused me. Translating as '' (Kingdom) also will be so strange and more confusing for users. Also, long word like ' ' breaks design in some pages. I don`t like this word being in english too, but yet not found sanity translation :)",
2922117,chameleon82,https://api.github.com/repos/keycloak/keycloak/pulls/2925,67632538,2016-06-20T03:20:49Z,themes/src/main/resources/theme/base/account/messages/messages_ru.properties,"@@ -0,0 +1,151 @@+doSave=\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C+doCancel=\u041E\u0442\u043C\u0435\u043D\u0430+doLogOutAllSessions=\u0412\u044B\u0439\u0442\u0438 \u0438\u0437 \u0432\u0441\u0435\u0445 \u0441\u0435\u0441\u0441\u0438\u0439+doRemove=\u0423\u0434\u0430\u043B\u0438\u0442\u044C+doAdd=\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C+doSignOut=\u0412\u044B\u0445\u043E\u0434++editAccountHtmlTtile=\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0430\u043A\u043A\u0430\u0443\u043D\u0442","Unfortunaly, we have word 'scope' also translating as ''. It's incomprehensible for user. I agree, that translating 'realm' as '' is not bad. But what we can do with 'scope'? '', '' or another?",
3992240,alicerum,https://api.github.com/repos/keycloak/keycloak/pulls/2925,67661041,2016-06-20T09:38:47Z,themes/src/main/resources/theme/base/login/messages/messages_ru.properties,"@@ -0,0 +1,218 @@+doLogIn=\u0412\u0445\u043E\u0434+doRegister=\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044F+doCancel=\u041E\u0442\u043C\u0435\u043D\u0430+doSubmit=\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C+doYes=\u0414\u0430+doNo=\u041D\u0435\u0442+doContinue=\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C+doAccept=\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C+doDecline=\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C+doForgotPassword=\u0417\u0430\u0431\u044B\u043B\u0438 \u043F\u0430\u0440\u043E\u043B\u044C?+doClickHere=\u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0441\u044E\u0434\u0430+doImpersonate=\u041F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C\u0441\u044F+kerberosNotConfigured=Kerberos \u043D\u0435 \u0441\u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043E\u0432\u0430\u043D+kerberosNotConfiguredTitle=Kerberos\u043D\u0435 \u0441\u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043E\u0432\u0430\u043D+bypassKerberosDetail=\u041B\u0438\u0431\u043E \u0432\u044B \u043D\u0435 \u0432\u043E\u0448\u043B\u0438 \u0432 \u0441\u0438\u0441\u0442\u0435\u043C\u0443 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E Kerberos \u0438\u043B\u0438 \u0432\u0430\u0448 \u0431\u0440\u0430\u0443\u0437\u0435\u0440 \u043D\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D \u0434\u043B\u044F \u0432\u0445\u043E\u0434\u0430 \u0432 \u0441\u0438\u0441\u0442\u0435\u043C\u0443 Kerberos. \u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043D\u0430\u0436\u043C\u0438\u0442\u0435 \u043A\u043D\u043E\u043F\u043A\u0443 \u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C \u0434\u043B\u044F \u0432\u0445\u043E\u0434\u0430 \u0432 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u0434\u0440\u0443\u0433\u0438\u0445 \u0441\u0440\u0435\u0434\u0441\u0442\u0432+kerberosNotSetUp=Kerberos \u043D\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D. \u0412\u044B \u043D\u0435 \u043C\u043E\u0436\u0435\u0442\u0435 \u0432\u043E\u0439\u0442\u0438.+registerWithTitle=\u0417\u0430\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0441 {0}+registerWithTitleHtml={0}+loginTitle=Log in to {0}+loginTitleHtml={0}+impersonateTitle={0} \u041F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F+impersonateTitleHtml=<strong>{0}</strong> \u041F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F</strong>+realmChoice=Realm+unknownUser=\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C+loginTotpTitle=\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430 \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u043E\u0433\u043E \u0430\u0443\u0442\u0435\u043D\u0442\u0438\u0444\u0438\u043A\u0430\u0442\u043E\u0440\u0430+loginProfileTitle=\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438 \u0443\u0447\u0435\u0442\u043D\u043E\u0439 \u0437\u0430\u043F\u0438\u0441\u0438+loginTimeout=\u0412\u044B \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u0434\u043E\u043B\u0433\u043E \u0431\u0435\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u043E\u0432\u0430\u043B\u0438. \u041F\u0440\u043E\u0446\u0435\u0441\u0441 \u0430\u0443\u0442\u0435\u043D\u0442\u0438\u0444\u0438\u043A\u0430\u0446\u0438\u0438 \u043D\u0430\u0447\u043D\u0435\u0442\u0441\u044F \u0441 \u043D\u0430\u0447\u0430\u043B\u0430.+oauthGrantTitle=\u0421\u043E\u0433\u043B\u0430\u0441\u043E\u0432\u0430\u0442\u044C \u0434\u043E\u0441\u0442\u0443\u043F+oauthGrantTitleHtml={0}+errorTitle=\u041C\u044B \u0441\u043E\u0436\u0430\u043B\u0435\u0435\u043C...+errorTitleHtml=\u041C\u044B <strong>\u0441\u043E\u0436\u0430\u043B\u0435\u0435\u043C</strong> ...+emailVerifyTitle=\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u0435 \u043F\u043E\u0447\u0442\u043E\u0432\u043E\u0433\u043E \u0430\u0434\u0440\u0435\u0441\u0430+emailForgotTitle=\u0417\u0430\u0431\u044B\u043B\u0438 \u043F\u0430\u0440\u043E\u043B\u044C?+updatePasswordTitle=\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u043F\u0430\u0440\u043E\u043B\u044F+codeSuccessTitle=\u0423\u0441\u043F\u0435\u0448\u043D\u044B\u0439 \u043A\u043E\u0434+codeErrorTitle=\u041E\u0448\u0438\u0431\u043E\u0447\u043D\u044B\u0439 \u043A\u043E\u0434\: {0}++termsTitle=\u0423\u0441\u043B\u043E\u0432\u0438\u044F \u0438 \u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u044F+termsTitleHtml=\u0423\u0441\u043B\u043E\u0432\u0438\u044F \u0438 \u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u044F+termsText=<p>\u0423\u0441\u043B\u043E\u0432\u0438\u044F \u0438 \u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u044F \u0434\u043E\u043B\u0436\u043D\u044B \u0431\u044B\u0442\u044C \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u044B</p>++recaptchaFailed=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0430\u044F Recaptcha+recaptchaNotConfigured=Recaptcha \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F, \u043D\u043E \u043D\u0435 \u0441\u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u0430+consentDenied=\u0412 \u0441\u043E\u0433\u043B\u0430\u0441\u043E\u0432\u0430\u043D\u0438\u0438 \u043E\u0442\u043A\u0430\u0437\u0430\u043D\u043E.++noAccount=\u041D\u043E\u0432\u044B\u0439 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C?+username=\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F+usernameOrEmail=\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0438\u043B\u0438 \u044D\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u0430\u044F \u043F\u043E\u0447\u0442\u0430","    ' looks really long and doesn't fit in one line :)Since we have 'email' in other places, and everybody does that anyways, we could use '   email' or even '  email'.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/2948,67679381,2016-06-20T12:14:44Z,server-spi/src/main/java/org/keycloak/events/admin/ResourceType.java,"@@ -0,0 +1,155 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.events.admin;++/**+ * Represents Keycloak resource types for which {@link AdminEvent AdminEvent's} can be triggered.+ *+ * @author <a href=""mailto:thomas.darimont@gmail.com"">Thomas Darimont</a>+ */+public enum ResourceType {",There is already a similar type in {{org.keycloak.partialimport.ResourceType}} but it is in a seperate package that I didn't want to pull-in. Perhaphs one could unify both enums.,X
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/2989,69275010,2016-07-01T09:45:55Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/UserInfoEndpoint.java,"@@ -132,7 +132,7 @@ private Response issueUserInfo(String tokenString) {         ClientModel clientModel = realm.getClientByClientId(token.getIssuedFor());         UserModel userModel = userSession.getUser();         AccessToken userInfo = new AccessToken();-        tokenManager.transformAccessToken(session, userInfo, realm, clientModel, userModel, userSession, clientSession);+        tokenManager.transformUserInfoAccessToken(session, userInfo, realm, clientModel, userModel, userSession, clientSession);",`transformUserInfoAccessToken` -> does the userinfo really represent an AccessToken? technically yes but actually  are different things...,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/2989,69275243,2016-07-01T09:47:57Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/UserAttributeMapper.java,"@@ -39,7 +39,7 @@  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>  * @version $Revision: 1 $  */-public class UserAttributeMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper, OIDCIDTokenMapper {+public class UserAttributeMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper, OIDCIDTokenMapper, UserInfoTokenMapper {","Currently I only support userinfo configuration for `UserAttributeMapper`, which other mappers should also provide this support and which not?Seems like the code for transforming / filtering / injecting claims is often very similar - this could also be streamlined a bit.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/3052,71661374,2016-07-21T07:54:35Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/CookieAuthenticator.java,"@@ -83,6 +84,15 @@ public void close() {      } +    protected boolean requireReauthentication(UserSessionModel userSession, ClientSessionModel clientSession) {+        return isPromptLogin(clientSession) || isAuthTimeExpired(userSession, clientSession);+    }++    protected boolean isPromptLogin(ClientSessionModel clientSession) {","Yes. It's always the question, whether to go with something easy or with something more generic, but usually more complex ;)The logic for prompt=login or ""max_age"" needs to be somewhere. For me, it look the easier and better option is to add into the Authenticator implementation itself rather then to the framework and increase the complexity of the framework.Note that we also need to update (or don't update) auth_time based on SSO authentication happen or ""real"" authentication happen.So how you expect the generic approach to work? I can see 2 possibilities:- Have 2 authentication flows - one with cookie authenticator and one without cookie authenticator. The flow will be chosen according to ""prompt=login"" or ""max_age=XX"" is used. - Remove CookieAuthenticator and instead implement SSO cookie check before authenticator framework is triggered. The SSO cookie check will be skiped if you use ""prompt=login"" or ""max_age=XX"". If Cookie is valid, the Authentication framework won't be triggered at all and user will be considered authenticated.TBH both options looks to me more complex then just add the behaviour directly into Cookie authenticator.",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/3155,79983278,2016-09-22T06:49:47Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1255,9 +1272,13 @@ public void setMasterAdminClient(ClientModel client) {          for (IdentityProviderEntity entity: entities) {             IdentityProviderModel identityProviderModel = new IdentityProviderModel();+            IdentityProviderFactory providerFactory = KeycloakFactoryUtils.getIdentityProviderFactoryById(session, entity.getProviderId());","You can do this with with the following (no need for KeycloakFactoryUtils):`session.getFactory().getProviderFactory(IdentityProviderFactory.class, entity.getProviderId())`",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/3155,80013776,2016-09-22T10:29:59Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1255,9 +1272,13 @@ public void setMasterAdminClient(ClientModel client) {          for (IdentityProviderEntity entity: entities) {             IdentityProviderModel identityProviderModel = new IdentityProviderModel();+            IdentityProviderFactory providerFactory = KeycloakFactoryUtils.getIdentityProviderFactoryById(session, entity.getProviderId());","@stianst this code won't compile:   `session.getKeycloakSessionFactory().getProviderFactory(IdentityProviderFactory.class, entity.getProviderId());`Just try it, please",
6472395,opuertas,https://api.github.com/repos/keycloak/keycloak/pulls/3277,81508353,2016-10-03T08:25:37Z,adapters/oidc/spring-boot/src/main/java/org/keycloak/adapters/springboot/KeycloakSpringBootProperties.java,"@@ -23,7 +23,9 @@ import java.util.ArrayList; import java.util.List; -@ConfigurationProperties(prefix = ""keycloak"", ignoreUnknownFields = false)+/* setting ignoreUnknownFields=true to avoid re-rebinding problem with property keycloak.config.resolver+   when using spring cloud - see KEYCLOAK-2977 */+@ConfigurationProperties(prefix = ""keycloak"", ignoreUnknownFields = true)",true is already the default value for the ignoreUnknownFields parameter.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/3333,83695907,2016-10-17T17:44:21Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -873,10 +865,11 @@         function checkLoginIframe() {             var promise = createPromise(); -            if (loginIframe.iframe && loginIframe.iframeOrigin) {+            if (loginIframe.iframe && loginIframe.iframeOrigin && loginIframe.callbackList.length !== 0) {                 var msg = {};                 msg.callbackId = createCallbackId();-                loginIframe.callbackMap[msg.callbackId] = promise;+                msg.sessionId = kc.sessionId;+                loginIframe.callbackList.push(promise);","The current check on L876 is when the iframe is not enabled. Then it just resolves to true so it can continue. Actually you should move ""loginIframe.callbackList.length !== 0"" check within the current if. If iframe is enabled it should add to the list, then if the list was empty send the message. Otherwise it'll get resolved when the next message callback is received.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/3325,83701084,2016-10-17T18:11:14Z,integration/client-cli/client-registration-cli/pom.xml,"@@ -0,0 +1,143 @@+<?xml version=""1.0""?>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">+    <parent>+        <artifactId>keycloak-client-cli-parent</artifactId>+        <groupId>org.keycloak</groupId>+        <version>2.3.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>keycloak-client-registration-cli</artifactId>+    <name>Keycloak Client Registration CLI</name>+    <description/>++    <dependencies>+        <dependency>+            <groupId>org.jboss.aesh</groupId>+            <artifactId>aesh</artifactId>+            <version>0.66.10</version>",Add version to dependencyManagement in keycloak parent and also use a property for it,
335133,sebastienblanc,https://api.github.com/repos/keycloak/keycloak/pulls/3333,83816938,2016-10-18T09:40:46Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -873,10 +865,11 @@         function checkLoginIframe() {             var promise = createPromise(); -            if (loginIframe.iframe && loginIframe.iframeOrigin) {+            if (loginIframe.iframe && loginIframe.iframeOrigin && loginIframe.callbackList.length !== 0) {                 var msg = {};                 msg.callbackId = createCallbackId();-                loginIframe.callbackMap[msg.callbackId] = promise;+                msg.sessionId = kc.sessionId;+                loginIframe.callbackList.push(promise);","But that won't work the first time , since we add the promise to the list , it never sends a message and the the callback will never be called to resolve the promise.",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/3325,83817432,2016-10-18T09:43:21Z,integration/client-cli/client-registration-cli/pom.xml,"@@ -0,0 +1,143 @@+<?xml version=""1.0""?>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">+    <parent>+        <artifactId>keycloak-client-cli-parent</artifactId>+        <groupId>org.keycloak</groupId>+        <version>2.3.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>keycloak-client-registration-cli</artifactId>+    <name>Keycloak Client Registration CLI</name>+    <description/>++    <dependencies>+        <dependency>+            <groupId>org.jboss.aesh</groupId>+            <artifactId>aesh</artifactId>+            <version>0.66.10</version>","That doesn't work currently as it clashes with https://github.com/keycloak/keycloak/blob/2.2.1.Final/wildfly/adduser/src/main/java/org/keycloak/wildfly/adduser/AddUser.java which needs to be compatible with Wildfly's version of Aesh, whereas registration client has no dependency on Wildfly, and thus is technically not restricted in which version to use. Downgrading reg-cli to 0.66.4 doesn't work, also reg-cli will drive further Aesh improvements, and we need to be able to benefit from them. I think here we should keep reg-cli on a separate version.",
335133,sebastienblanc,https://api.github.com/repos/keycloak/keycloak/pulls/3332,83846652,2016-10-18T12:54:59Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/filter/KeycloakAuthenticatedActionsFilter.java,"@@ -0,0 +1,90 @@+package org.keycloak.adapters.springsecurity.filter;++import java.io.IOException;++import javax.servlet.FilterChain;+import javax.servlet.ServletException;+import javax.servlet.ServletRequest;+import javax.servlet.ServletResponse;+import javax.servlet.http.HttpServletRequest;+import javax.servlet.http.HttpServletResponse;++/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++import org.keycloak.adapters.AdapterDeploymentContext;+import org.keycloak.adapters.AuthenticatedActionsHandler;+import org.keycloak.adapters.NodesRegistrationManagement;+import org.keycloak.adapters.OIDCHttpFacade;+import org.keycloak.adapters.spi.HttpFacade;+import org.keycloak.adapters.springsecurity.facade.SimpleHttpFacade;+import org.slf4j.Logger;+import org.slf4j.LoggerFactory;+import org.springframework.beans.BeansException;+import org.springframework.context.ApplicationContext;+import org.springframework.context.ApplicationContextAware;+import org.springframework.web.filter.GenericFilterBean;++/**+ * Exposes a Keycloak adapter {@link AuthenticatedActionsHandler} as a Spring Security filter.+ *+ * @author <a href=""mailto:srossillo@smartling.com"">Scott Rossillo</a>+ * @version $Revision: 1 $+ */",Looks like a copy/paste comment from another class ;) Could you clean this up ?,X
18479673,ebondu,https://api.github.com/repos/keycloak/keycloak/pulls/3332,83890316,2016-10-18T16:06:10Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/filter/KeycloakAuthenticatedActionsFilter.java,"@@ -0,0 +1,90 @@+package org.keycloak.adapters.springsecurity.filter;++import java.io.IOException;++import javax.servlet.FilterChain;+import javax.servlet.ServletException;+import javax.servlet.ServletRequest;+import javax.servlet.ServletResponse;+import javax.servlet.http.HttpServletRequest;+import javax.servlet.http.HttpServletResponse;++/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++import org.keycloak.adapters.AdapterDeploymentContext;+import org.keycloak.adapters.AuthenticatedActionsHandler;+import org.keycloak.adapters.NodesRegistrationManagement;+import org.keycloak.adapters.OIDCHttpFacade;+import org.keycloak.adapters.spi.HttpFacade;+import org.keycloak.adapters.springsecurity.facade.SimpleHttpFacade;+import org.slf4j.Logger;+import org.slf4j.LoggerFactory;+import org.springframework.beans.BeansException;+import org.springframework.context.ApplicationContext;+import org.springframework.context.ApplicationContextAware;+import org.springframework.web.filter.GenericFilterBean;++/**+ * Exposes a Keycloak adapter {@link AuthenticatedActionsHandler} as a Spring Security filter.+ *+ * @author <a href=""mailto:srossillo@smartling.com"">Scott Rossillo</a>+ * @version $Revision: 1 $+ */",This class is inspired by the KeycloakPreAuthActionsFilter class so it looks like a copy/past but in fact the javadoc is already up to date ;). Is there any expected values for the @version/@author fields?,X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3473,86850204,2016-11-07T19:33:05Z,saml-core/src/main/java/org/keycloak/saml/processing/core/util/XMLEncryptionUtil.java,"@@ -514,7 +514,7 @@ private static String getXMLEncryptionURLForKeyUnwrap(String publicKeyAlgo, int             }         }         if (publicKeyAlgo.contains(""RSA""))-            return XMLCipher.RSA_v1dot5;+            return XMLCipher.RSA_OAEP;","Very likely so. SAML uses xmlenc for (key) encryption, and xmlenc mandates presence of RSA-OAEP algorithm [see [here](https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#sec-AlgID)]. SP that were configured to disallow RSA-OAEP should be upgraded to allow it, and rather deprecate RSA PKCS v1.5 - see e.g. [here](http://crypto.stackexchange.com/a/12706) for reasoning behind this.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3292,87747868,2016-11-14T07:14:42Z,services/src/main/java/org/keycloak/broker/saml/mappers/UserAttributeMapper.java,"@@ -99,61 +101,84 @@ public String getDisplayType() {     @Override     public void preprocessFederatedIdentity(KeycloakSession session, RealmModel realm, IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {         String attribute = mapperModel.getConfig().get(USER_ATTRIBUTE);-        String value = getAttribute(mapperModel, context);-        if (value != null) {-            if (attribute.equalsIgnoreCase(""email"")) {-                context.setEmail(value);-            } else if (attribute.equalsIgnoreCase(""firstName"")) {-                context.setFirstName(value);-            } else if (attribute.equalsIgnoreCase(""lastName"")) {-                context.setLastName(value);+        Map<String, List<String>> attributeToValues = getAttribute(mapperModel, context);+        if (!attributeToValues.isEmpty()) {+            String attributeName = getAttributeName(mapperModel);+            if (attribute.equalsIgnoreCase(EMAIL)) {+                setIfNotEmpty(context::setEmail, attributeToValues.get(attributeName));+            } else if (attribute.equalsIgnoreCase(FIRST_NAME)) {+                setIfNotEmpty(context::setFirstName, attributeToValues.get(attributeName));+            } else if (attribute.equalsIgnoreCase(LAST_NAME)) {+                setIfNotEmpty(context::setLastName, attributeToValues.get(attributeName));             } else {-                context.setUserAttribute(attribute, value);+                context.setUserAttribute(attribute, attributeToValues.get(attributeName));             }         }     } -    protected String getAttribute(IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {+    private String getAttributeName(IdentityProviderMapperModel mapperModel) {","`getAttributeValues(mapperModel, context);` (line 105) creates a map with keys that are based on attribute name. When looking up attribute name, code refers to `attribute` variable declared at line 104 as:``` javaString attribute = mapperModel.getConfig().get(USER_ATTRIBUTE);```However, value of `attribute` can be different to the key in the map `attributeToValues` because `getAttributeValues()` uses method for computing key under which the value is stored (see lines 135-139 and 150-154) that is different to `attribute`. E.g., the option from config should be also trimmed similarly to attribute names in 135-139.I'd suggest extracting method to retrieve attribute key from name and friendly name to a separate method and use it in both places (e.g. with setting friendlyName to null in case of config option).",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3292,87760308,2016-11-14T09:10:01Z,services/src/main/java/org/keycloak/broker/saml/mappers/UserAttributeMapper.java,"@@ -99,61 +101,84 @@ public String getDisplayType() {     @Override     public void preprocessFederatedIdentity(KeycloakSession session, RealmModel realm, IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {         String attribute = mapperModel.getConfig().get(USER_ATTRIBUTE);-        String value = getAttribute(mapperModel, context);-        if (value != null) {-            if (attribute.equalsIgnoreCase(""email"")) {-                context.setEmail(value);-            } else if (attribute.equalsIgnoreCase(""firstName"")) {-                context.setFirstName(value);-            } else if (attribute.equalsIgnoreCase(""lastName"")) {-                context.setLastName(value);+        Map<String, List<String>> attributeToValues = getAttributeValues(mapperModel, context);+        if (!attributeToValues.isEmpty()) {+            String attributeName = getAttributeName(mapperModel);+            if (attribute.equalsIgnoreCase(EMAIL)) {+                setIfNotEmpty(context::setEmail, attributeToValues.get(attributeName));+            } else if (attribute.equalsIgnoreCase(FIRST_NAME)) {+                setIfNotEmpty(context::setFirstName, attributeToValues.get(attributeName));+            } else if (attribute.equalsIgnoreCase(LAST_NAME)) {+                setIfNotEmpty(context::setLastName, attributeToValues.get(attributeName));             } else {-                context.setUserAttribute(attribute, value);+                context.setUserAttribute(attribute, attributeToValues.get(attributeName));             }         }     } -    protected String getAttribute(IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {+    private String getAttributeName(IdentityProviderMapperModel mapperModel) {+        String attributeName = mapperModel.getConfig().get(ATTRIBUTE_NAME);+        if (attributeName == null) {+            attributeName = mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME);+        }+        return attributeName;+    }++    private void setIfNotEmpty(Consumer<String> consumer, List<String> values){+        if (values != null && !values.isEmpty()) {+            consumer.accept(values.get(0));+        }+    }++    private Map<String, List<String>> getAttributeValues(IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {+        Map<String, List<String>> attributeToValues = new HashMap<>();         String name = mapperModel.getConfig().get(ATTRIBUTE_NAME);         if (name != null && name.trim().equals("""")) name = null;         String friendly = mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME);         if (friendly != null && friendly.trim().equals("""")) friendly = null;-        AssertionType assertion = (AssertionType)context.getContextData().get(SAMLEndpoint.SAML_ASSERTION);+        AssertionType assertion = (AssertionType) context.getContextData().get(SAMLEndpoint.SAML_ASSERTION);         for (AttributeStatementType statement : assertion.getAttributeStatements()) {             for (AttributeStatementType.ASTChoiceType choice : statement.getAttributes()) {                 AttributeType attr = choice.getAttribute();                 if (name != null && !name.equals(attr.getName())) continue;                 if (friendly != null && !friendly.equals(attr.getFriendlyName())) continue; -                List<Object> attributeValue = attr.getAttributeValue();-                if (attributeValue == null || attributeValue.isEmpty()) return null;-                return attributeValue.get(0).toString();+                List<String> attributeValue = attr.getAttributeValue().stream()+                        .filter(Objects::nonNull)+                        .map(Object::toString)+                        .collect(Collectors.toList());+                if (name != null) {+                    attributeToValues.put(name, attributeValue);+                } else if (friendly != null) {+                    attributeToValues.put(friendly, attributeValue);+                }             }         }-        return null;+        return attributeToValues;     }      @Override     public void updateBrokeredUser(KeycloakSession session, RealmModel realm, UserModel user, IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {","You can have a look at org.keycloak.testsuite.broker.AbstractKeycloakIdentityProviderTest.testAccountManagementLinkIdentity() test, this test already invokes this function [when logging in for the second time](https://github.com/keycloak/keycloak/blob/master/testsuite/integration/src/test/java/org/keycloak/testsuite/broker/AbstractKeycloakIdentityProviderTest.java#L436). You need to change the user detail (mobile number) in between the two login sessions.",
978482,manuel-palacio,https://api.github.com/repos/keycloak/keycloak/pulls/3292,88563830,2016-11-17T22:42:14Z,testsuite/integration/src/test/java/org/keycloak/testsuite/broker/SAMLKeyCloakServerBrokerUserAttributeTest.java,"@@ -0,0 +1,163 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.broker;++import org.junit.ClassRule;+import org.junit.Test;+import org.keycloak.common.util.Time;+import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.representations.idm.IdentityProviderRepresentation;+import org.keycloak.services.managers.RealmManager;+import org.keycloak.testsuite.KeycloakServer;+import org.keycloak.testsuite.rule.AbstractKeycloakRule;++import java.util.Arrays;++import static org.hamcrest.Matchers.*;+import static org.junit.Assert.assertThat;+import static org.junit.Assert.assertTrue;+++public class SAMLKeyCloakServerBrokerUserAttributeTest extends AbstractIdentityProviderTest {++    @ClassRule+    public static AbstractKeycloakRule samlServerRule = new AbstractKeycloakRule() {++        @Override+        protected void configureServer(KeycloakServer server) {+            server.getConfig().setPort(8082);+        }++        @Override+        protected void configure(KeycloakSession session, RealmManager manager, RealmModel adminRealm) {+            server.importRealm(getClass().getResourceAsStream(""/broker-test/test-broker-realm-with-saml-with-multi-value-user-attributes.json""));+        }++        @Override+        protected String[] getTestRealms() {+            return new String[]{""realm-with-saml-idp-basic""};+        }+    };++    @Override+    protected String getProviderId() {+        return ""kc-saml-idp-basic"";+    }+++    @Test+    public void canAccessMultiValueAttribute() {+        UserModel user = assertSuccessfulAuthentication(getIdentityProviderModel(), ""test-user-1"", ""new@email.com"", true);+        assertThat(user.getAttribute(""mobile""), containsInAnyOrder(""617-666-7777"", ""617-666-7778""));+        assertThat(user.getFirstAttribute(""mobile""), is(""617-666-7777""));+    }++    @Test+    public void canAccessSingleValueAttribute() {+        UserModel user = assertSuccessfulAuthentication(getIdentityProviderModel(), ""test-user-2"", ""new@email.com"", true);+        assertThat(user.getAttribute(""mobile""), containsInAnyOrder(""617-666-7777""));+        assertThat(user.getFirstAttribute(""mobile""), is(""617-666-7777""));+    }++    @Test+    public void nonExistingAttributeLookupReturnsAnEmptyList() {+        UserModel user = assertSuccessfulAuthentication(getIdentityProviderModel(), ""test-user-3"", ""new@email.com"", true);+        assertThat(user.getAttribute(""mobile""), is(empty()));+    }++    @Test  //TODO+    public void canUpdateBrokeredUserAttributes() {","@hmlnarik I copied the code from AbstractKeycloakIdentityProviderTest but I am finding it a bit cryptic. Does it need to be this complex just to test that the attributes are updated through the mapper? Furthermore, I could not manage to assert that the attributes are there at the end of the test. Any suggestions? Thx",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3292,89956911,2016-11-29T08:05:28Z,services/src/main/java/org/keycloak/broker/oidc/mappers/AbstractJsonUserAttributeMapper.java,"@@ -29,13 +29,14 @@ import org.keycloak.provider.ProviderConfigProperty;  import java.util.ArrayList;+import java.util.Iterator;",unused import - please remove,X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3292,89957605,2016-11-29T08:11:46Z,services/src/main/java/org/keycloak/broker/oidc/mappers/AbstractJsonUserAttributeMapper.java,"@@ -206,9 +207,15 @@ public static String getJsonValue(JsonNode baseNode, String fieldPath) { 			}  			if (idx < 0) {-				if (!currentNode.isValueNode()) {+				if (currentNode.isArray()) {",This changes semantics - warning has to be logged and null has to be returned when the current node is neither simple array of strings node nor value node,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3292,89958828,2016-11-29T08:21:53Z,services/src/main/java/org/keycloak/broker/oidc/mappers/UserAttributeMapper.java,"@@ -88,37 +96,66 @@ public String getDisplayType() {     @Override     public void preprocessFederatedIdentity(KeycloakSession session, RealmModel realm, IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {         String attribute = mapperModel.getConfig().get(USER_ATTRIBUTE);+        if(StringUtil.isNullOrEmpty(attribute)){+            return;+        }         Object value = getClaimValue(mapperModel, context);-        if (value != null) {-            if (attribute.equalsIgnoreCase(""email"")) {-                context.setEmail(value.toString());-            } else if (attribute.equalsIgnoreCase(""firstName"")) {-                context.setFirstName(value.toString());-            } else if (attribute.equalsIgnoreCase(""lastName"")) {-                context.setLastName(value.toString());-            } else {-                context.setUserAttribute(attribute, value.toString());-            }+        List<String> values = toList(value);++        if (EMAIL.equalsIgnoreCase(attribute)) {+            setIfNotEmpty(context::setEmail, values);+        } else if (FIRST_NAME.equalsIgnoreCase(attribute)) {+            setIfNotEmpty(context::setFirstName, values);+        } else if (LAST_NAME.equalsIgnoreCase(attribute)) {+            setIfNotEmpty(context::setLastName, values);+        } else {+            List<String> valuesToString = values.stream()+                    .filter(Objects::nonNull)+                    .map(Object::toString)+                    .collect(Collectors.toList());++            context.setUserAttribute(attribute, valuesToString);+        }+    }++    private void setIfNotEmpty(Consumer<String> consumer, List<String> values) {+        if (values != null && !values.isEmpty()) {+            consumer.accept(values.get(0));+        }+    }++    private List<String> toList(Object value) {",Can you refactor without intermediate `values` list filled again please? E.g.```javaList<Object> values = (value instanceof List)  ? (List<Object>) value  : Collections.singletonList(value);```,X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3292,89961017,2016-11-29T08:37:29Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/OIDCAttributeMapperHelper.java,"@@ -70,29 +69,78 @@ public static Object mapAttributeValue(ProtocolMapperModel mappingModel, Object                     ServicesLogger.LOGGER.multipleValuesForMapper(attributeValue.toString(), mappingModel.getName());                 } -                attributeValue = valueAsList.get(0);+                attributeValue = valueAsList;             }         }          String type = mappingModel.getConfig().get(JSON_TYPE);+        Object converted = convertToType(type, attributeValue);+        return converted != null ? converted : attributeValue;+    }++    private static <X, T> List<T> transform(List<X> attributeValue, Function<X, T> mapper) {+        return attributeValue.stream()+                .filter(Objects::nonNull)+                .map(mapper)+                .collect(Collectors.toList());+    }++    private static Object convertToType(String type, Object attributeValue) {         if (type == null) return attributeValue;-        if (type.equals(""boolean"")) {-            if (attributeValue instanceof Boolean) return attributeValue;-            if (attributeValue instanceof String) return Boolean.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");-        } else if (type.equals(""String"")) {-            if (attributeValue instanceof String) return attributeValue;-            return attributeValue.toString();-        } else if (type.equals(""long"")) {-            if (attributeValue instanceof Long) return attributeValue;-            if (attributeValue instanceof String) return Long.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");-        } else if (type.equals(""int"")) {-            if (attributeValue instanceof Integer) return attributeValue;-            if (attributeValue instanceof String) return Integer.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");+        switch (type) {+            case ""boolean"":+                Object booleanObject = getBoolean(attributeValue);+                if (booleanObject != null) return booleanObject;+                if (attributeValue instanceof List) {+                    return transform((List<Object>) attributeValue, OIDCAttributeMapperHelper::getBoolean);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            case ""String"":+                if (attributeValue instanceof String) return attributeValue;+                if (attributeValue instanceof List) {+                    return transform((List<String>) attributeValue, OIDCAttributeMapperHelper::getString);+                }+                return attributeValue.toString();+            case ""long"":+                Object longObject = getLong(attributeValue);+                if (longObject != null) return longObject;+                if (attributeValue instanceof List) {+                    return transform((List<Long>) attributeValue, OIDCAttributeMapperHelper::getLong);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            case ""int"":+                Object intObject = getInteger(attributeValue);+                if (intObject != null) return intObject;+                if (attributeValue instanceof List) {+                    return transform((List<Integer>) attributeValue, OIDCAttributeMapperHelper::getInteger);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            default:+                return null;         }-        return attributeValue;+    }++    private static String getString(Object attributeValue) {+        return attributeValue.toString();+    }+++    private static Long getLong(Object attributeValue) {+        if (attributeValue instanceof Long) return (Long) attributeValue;+        if (attributeValue instanceof String) return Long.valueOf((String) attributeValue);+        return null;+    }++    private static Integer getInteger(Object attributeValue) {+        if (attributeValue instanceof Integer) return (Integer) attributeValue;+        if (attributeValue instanceof String) return Integer.valueOf((String) attributeValue);",`NumberFormatException` has to be caught and converted to `RuntimeException` when exception occurs.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3292,89961034,2016-11-29T08:37:33Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/OIDCAttributeMapperHelper.java,"@@ -70,29 +69,78 @@ public static Object mapAttributeValue(ProtocolMapperModel mappingModel, Object                     ServicesLogger.LOGGER.multipleValuesForMapper(attributeValue.toString(), mappingModel.getName());                 } -                attributeValue = valueAsList.get(0);+                attributeValue = valueAsList;             }         }          String type = mappingModel.getConfig().get(JSON_TYPE);+        Object converted = convertToType(type, attributeValue);+        return converted != null ? converted : attributeValue;+    }++    private static <X, T> List<T> transform(List<X> attributeValue, Function<X, T> mapper) {+        return attributeValue.stream()+                .filter(Objects::nonNull)+                .map(mapper)+                .collect(Collectors.toList());+    }++    private static Object convertToType(String type, Object attributeValue) {         if (type == null) return attributeValue;-        if (type.equals(""boolean"")) {-            if (attributeValue instanceof Boolean) return attributeValue;-            if (attributeValue instanceof String) return Boolean.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");-        } else if (type.equals(""String"")) {-            if (attributeValue instanceof String) return attributeValue;-            return attributeValue.toString();-        } else if (type.equals(""long"")) {-            if (attributeValue instanceof Long) return attributeValue;-            if (attributeValue instanceof String) return Long.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");-        } else if (type.equals(""int"")) {-            if (attributeValue instanceof Integer) return attributeValue;-            if (attributeValue instanceof String) return Integer.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");+        switch (type) {+            case ""boolean"":+                Object booleanObject = getBoolean(attributeValue);+                if (booleanObject != null) return booleanObject;+                if (attributeValue instanceof List) {+                    return transform((List<Object>) attributeValue, OIDCAttributeMapperHelper::getBoolean);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            case ""String"":+                if (attributeValue instanceof String) return attributeValue;+                if (attributeValue instanceof List) {+                    return transform((List<String>) attributeValue, OIDCAttributeMapperHelper::getString);+                }+                return attributeValue.toString();+            case ""long"":+                Object longObject = getLong(attributeValue);+                if (longObject != null) return longObject;+                if (attributeValue instanceof List) {+                    return transform((List<Long>) attributeValue, OIDCAttributeMapperHelper::getLong);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            case ""int"":+                Object intObject = getInteger(attributeValue);+                if (intObject != null) return intObject;+                if (attributeValue instanceof List) {+                    return transform((List<Integer>) attributeValue, OIDCAttributeMapperHelper::getInteger);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            default:+                return null;         }-        return attributeValue;+    }++    private static String getString(Object attributeValue) {+        return attributeValue.toString();+    }+++    private static Long getLong(Object attributeValue) {+        if (attributeValue instanceof Long) return (Long) attributeValue;+        if (attributeValue instanceof String) return Long.valueOf((String) attributeValue);",`NumberFormatException` has to be caught and converted to `RuntimeException` when exception occurs.,
978482,manuel-palacio,https://api.github.com/repos/keycloak/keycloak/pulls/3292,90127650,2016-11-29T22:18:39Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/OIDCAttributeMapperHelper.java,"@@ -70,29 +69,86 @@ public static Object mapAttributeValue(ProtocolMapperModel mappingModel, Object                     ServicesLogger.LOGGER.multipleValuesForMapper(attributeValue.toString(), mappingModel.getName());                 } -                attributeValue = valueAsList.get(0);+                attributeValue = valueAsList;             }         }          String type = mappingModel.getConfig().get(JSON_TYPE);+        Object converted = convertToType(type, attributeValue);+        return converted != null ? converted : attributeValue;+    }++    private static <X, T> List<T> transform(List<X> attributeValue, Function<X, T> mapper) {+        return attributeValue.stream()+                .filter(Objects::nonNull)+                .map(mapper)+                .collect(Collectors.toList());+    }++    private static Object convertToType(String type, Object attributeValue) {         if (type == null) return attributeValue;-        if (type.equals(""boolean"")) {-            if (attributeValue instanceof Boolean) return attributeValue;-            if (attributeValue instanceof String) return Boolean.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");-        } else if (type.equals(""String"")) {-            if (attributeValue instanceof String) return attributeValue;-            return attributeValue.toString();-        } else if (type.equals(""long"")) {-            if (attributeValue instanceof Long) return attributeValue;-            if (attributeValue instanceof String) return Long.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");-        } else if (type.equals(""int"")) {-            if (attributeValue instanceof Integer) return attributeValue;-            if (attributeValue instanceof String) return Integer.valueOf((String)attributeValue);-            throw new RuntimeException(""cannot map type for token claim"");+        switch (type) {+            case ""boolean"":+                Object booleanObject = getBoolean(attributeValue);+                if (booleanObject != null) return booleanObject;+                if (attributeValue instanceof List) {+                    return transform((List<Object>) attributeValue, OIDCAttributeMapperHelper::getBoolean);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            case ""String"":+                if (attributeValue instanceof String) return attributeValue;+                if (attributeValue instanceof List) {+                    return transform((List<String>) attributeValue, OIDCAttributeMapperHelper::getString);+                }+                return attributeValue.toString();+            case ""long"":+                Object longObject = getLong(attributeValue);+                if (longObject != null) return longObject;+                if (attributeValue instanceof List) {+                    return transform((List<Long>) attributeValue, OIDCAttributeMapperHelper::getLong);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            case ""int"":+                Object intObject = getInteger(attributeValue);+                if (intObject != null) return intObject;+                if (attributeValue instanceof List) {+                    return transform((List<Integer>) attributeValue, OIDCAttributeMapperHelper::getInteger);+                }+                throw new RuntimeException(""cannot map type for token claim"");+            default:+                return null;         }-        return attributeValue;+    }++    private static String getString(Object attributeValue) {+        return attributeValue.toString();+    }+++    private static Long getLong(Object attributeValue) {+        if (attributeValue instanceof Long) return (Long) attributeValue;+        try {+            if (attributeValue instanceof String) return Long.valueOf((String) attributeValue);+        } catch (NumberFormatException ex) {+            throw new RuntimeException(ex);+        }+        return null;+    }++    private static Integer getInteger(Object attributeValue) {+        if (attributeValue instanceof Integer) return (Integer) attributeValue;+        try {+            if (attributeValue instanceof String) return Integer.valueOf((String) attributeValue);+        } catch (NumberFormatException ex) {+            throw new RuntimeException(ex);",Is this catch necessary? NumberFormatException is a subclass of RuntimeException,
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/3572,90265976,2016-11-30T16:11:15Z,model/infinispan/src/main/java/org/keycloak/connections/infinispan/InfinispanConnectionProvider.java,"@@ -27,7 +27,7 @@      String REALM_CACHE_NAME = ""realms"";     String REALM_REVISIONS_CACHE_NAME = ""realmRevisions"";-    int REALM_REVISIONS_CACHE_DEFAULT_MAX = 10000;+    int REALM_REVISIONS_CACHE_DEFAULT_MAX = 20000;",Upped this default value to help with testing with large number of realms. Should be covered anyway by a realms cache size in standalone.xml when KC is executed in managed mode.,
978482,manuel-palacio,https://api.github.com/repos/keycloak/keycloak/pulls/3292,90417275,2016-12-01T10:15:41Z,services/src/main/java/org/keycloak/broker/oidc/mappers/AbstractJsonUserAttributeMapper.java,"@@ -125,9 +125,9 @@ public void preprocessFederatedIdentity(KeycloakSession session, RealmModel real 		} 		attribute = attribute.trim(); -		String value = getJsonValue(mapperModel, context);+		Object value = getJsonValue(mapperModel, context); 		if (value != null) {-			context.setUserAttribute(attribute, value);+			context.setUserAttribute(attribute, value.toString());","@hmlnarik This method is inherited by several ""social"" user attribute mappers. I wonder if it we need to check if the value is a list since the context has an overloaded method to accept a list of attribute values or if we don't ever need to handle this case in the sub-classes. ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/3649,93011551,2016-12-19T11:12:11Z,services/src/main/java/org/keycloak/protocol/oidc/installation/KeycloakOIDCClientInstallation.java,"@@ -87,7 +87,7 @@ public static boolean showClientCredentialsAdapterConfig(ClientModel client) {             return false;         } -        if (client.isBearerOnly() && client.getNodeReRegistrationTimeout() <= 0) {+        if (client.isBearerOnly() && !client.isServiceAccountsEnabled() && client.getNodeReRegistrationTimeout() <= 0) {","Seems OK, but could you add tests to https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/client/InstallationTest.java please?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/3739,95790809,2017-01-12T13:33:20Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/ClientTemplateResource.java,"@@ -44,7 +45,7 @@      @PUT     @Consumes(MediaType.APPLICATION_JSON)-    public void update(ClientTemplateRepresentation rep);+    public Response update(ClientTemplateRepresentation rep);",We shouldn't change this to return a Response as that requires closing the response and there is no need for it. Rather just rely on exceptions like the other update methods do.,
18479673,ebondu,https://api.github.com/repos/keycloak/keycloak/pulls/3741,96252021,2017-01-16T15:27:59Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/filter/KeycloakAuthenticationProcessingFilter.java,"@@ -207,28 +216,17 @@ protected void successfulAuthentication(HttpServletRequest request, HttpServletR         } finally {             SecurityContextHolder.clearContext();         }-     }+    +          @Override-    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,-            AuthenticationException failed) throws IOException, ServletException {--        if (this.isBearerTokenRequest(request)) {-            SecurityContextHolder.clearContext();-            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, ""Unable to authenticate bearer token"");-            return;-        }-        else if (this.isBasicAuthRequest(request)) {-            SecurityContextHolder.clearContext();-            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, ""Unable to authenticate with basic authentication"");-            return;-        }--        super.unsuccessfulAuthentication(request, response, failed);-    }+	protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,+			AuthenticationException failed) throws IOException, ServletException {+		super.unsuccessfulAuthentication(request, response, failed);+	} -    @Override+	@Override","Yep, I changed my IDE conf to apply the ""JBoss Community"" style. However, formatting the file automatically cause many changes. Do you want me to commit these changes for this PR regarding to your git recommandations ?> - One commit per PR> - No changes to code not directly related to your change (e.g. no formatting changes or refactoring to existing code, if you want to refactor/improve existing code that's a separate discussion to mailing list and JIRA issue) ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/3769,96588033,2017-01-18T08:52:34Z,services/src/main/java/org/keycloak/keys/loader/PublicKeyStorageManager.java,"@@ -53,4 +64,12 @@ public static PublicKey getIdentityProviderPublicKey(KeycloakSession session, Re         return keyStorage.getPublicKey(modelKey, kid, loader);     } +    protected static PublicKey getSavedPublicKey(OIDCIdentityProviderConfig config) {+        if (config.getPublicKeySignatureVerifier() != null && !config.getPublicKeySignatureVerifier().trim().equals("""")) {+            return PemUtils.decodePublicKey(config.getPublicKeySignatureVerifier());","PublicKeyStorageManager isn't cached afaik, so this will be pretty bad for performance as decoding pems is rather expensive.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/3766,96630010,2017-01-18T13:08:28Z,testsuite/integration-arquillian/tests/pom.xml,"@@ -466,7 +466,7 @@         <profile>             <id>auth-server-migration</id>             <properties>-                <migration.import.file>src/test/resources/migration-test/migration-realm-${migrated.auth.server.version}.json</migration.import.file>+                <migration.import.file>target/test-classes/migration-test/migration-realm-${migrated.auth.server.version}.json</migration.import.file>","Because we may want to filter test resources. For instance, to test migration of drools policy I need to specify the ${project.version} for the policy maven artifact.Beside that, the same files in ```src/test/resources``` are mirrored to ```target/test-classes```.",X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/3766,96631337,2017-01-18T13:16:56Z,server-spi-private/src/main/java/org/keycloak/migration/migrators/MigrateTo2_5_1.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.migration.migrators;+++import java.util.function.Consumer;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Stream;++import org.keycloak.authorization.AuthorizationProvider;+import org.keycloak.authorization.model.Policy;+import org.keycloak.authorization.model.ResourceServer;+import org.keycloak.authorization.store.PolicyStore;+import org.keycloak.authorization.store.ResourceServerStore;+import org.keycloak.migration.ModelVersion;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class MigrateTo2_5_1 implements Migration {","Garbage, that logic is doing nothing. Do I still need the keep the class even if all work is done by liquibase ? ",X
335133,sebastienblanc,https://api.github.com/repos/keycloak/keycloak/pulls/3755,96814597,2017-01-19T08:56:45Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/filter/KeycloakAuthenticationProcessingFilter.java,"@@ -109,7 +109,7 @@ public KeycloakAuthenticationProcessingFilter(AuthenticationManager authenticati      *      */     public KeycloakAuthenticationProcessingFilter(AuthenticationManager authenticationManager, RequestMatcher-                requiresAuthenticationRequestMatcher) {",Has anything changed in the class ? I see only formatting changes,
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/3944,105851199,2017-03-14T08:42:10Z,testsuite/integration-arquillian/tests/base/pom.xml,"@@ -199,5 +199,12 @@         </plugins>      </build>-    +    <profiles>","@stianst True, that part is a temporary solution. I can remove it.",X
2922117,chameleon82,https://api.github.com/repos/keycloak/keycloak/pulls/3898,106176614,2017-03-15T14:20:39Z,themes/src/main/resources/theme/base/admin/messages/messages_ru.properties,"@@ -1,14 +1,26 @@-invalidPasswordMinLengthMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u0430\u044F \u0434\u043B\u0438\u043D\u0430 {0}.-invalidPasswordMinDigitsMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0446\u0438\u0444\u0440\u043E\u0432\u044B\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 {0}.-invalidPasswordMinLowerCaseCharsMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u0432 \u043D\u0438\u0436\u043D\u0435\u043C \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0435 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 {0}.-invalidPasswordMinUpperCaseCharsMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u0432 \u0432\u0435\u0440\u0445\u043D\u0435\u043C \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0435 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 {0}.-invalidPasswordMinSpecialCharsMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0441\u043F\u0435\u0446\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 {0}.-invalidPasswordNotUsernameMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u043D\u0435 \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0442\u044C \u0441 \u0438\u043C\u0435\u043D\u0435\u043C \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F.-invalidPasswordRegexPatternMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u043D\u0435 \u043F\u0440\u043E\u0448\u0435\u043B \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0443 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u044B\u043C \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0435\u043C.-invalidPasswordHistoryMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u043D\u0435 \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0442\u044C \u0441 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u043C\u0438 {0} \u043F\u0430\u0440\u043E\u043B\u044F\u043C\u0438.+# encoding: utf-8+invalidPasswordMinLengthMessage= :   {0}.+invalidPasswordMinDigitsMessage= :       {0}.+invalidPasswordMinLowerCaseCharsMessage= :         {0}.+invalidPasswordMinUpperCaseCharsMessage= :         {0}.+invalidPasswordMinSpecialCharsMessage= :      {0}.+invalidPasswordNotUsernameMessage= :      .+invalidPasswordRegexPatternMessage= :     .+invalidPasswordHistoryMessage= :      {0} .+invalidPasswordGenericMessage= :      . -ldapErrorInvalidCustomFilter=\u0421\u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0435\u043C \u0444\u0438\u043B\u044C\u0442\u0440 LDAP \u043D\u0435 \u0434\u043E\u043B\u0436\u0435\u043D \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 ""("" \u0438\u043B\u0438 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "")"".-ldapErrorMissingClientId=Client ID \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D \u0432 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438, \u0435\u0441\u043B\u0438 \u043D\u0435 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F \u043C\u0430\u043F\u043F\u0438\u043D\u0433 \u0440\u043E\u043B\u0435\u0439 realm.-ldapErrorCantPreserveGroupInheritanceWithUIDMembershipType=\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0443\u043D\u0430\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0443 \u0438 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0447\u043B\u0435\u043D\u0441\u0442\u0432\u043E UID \u0442\u0438\u043F\u0430 \u0432\u043C\u0435\u0441\u0442\u0435.-ldapErrorCantWriteOnlyForReadOnlyLdap=\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0440\u0435\u0436\u0438\u043C \u0442\u043E\u043B\u044C\u043A\u043E-\u043D\u0430-\u0437\u0430\u043F\u0438\u0441\u044C, \u043A\u043E\u0433\u0434\u0430 LDAP \u043F\u0440\u043E\u0432\u0430\u0439\u0434\u0435\u0440 \u043D\u0435 \u0432 \u0440\u0435\u0436\u0438\u043C\u0435 WRITABLE-ldapErrorCantWriteOnlyAndReadOnly=\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0440\u0435\u0436\u0438\u043C\u044B \u0442\u043E\u043B\u044C\u043A\u043E-\u043D\u0430-\u0447\u0442\u0435\u043D\u0438\u0435 \u0438 \u0442\u043E\u043B\u044C\u043A\u043E-\u043D\u0430-\u0437\u0430\u043F\u0438\u0441\u044C \u0432\u043C\u0435\u0441\u0442\u0435\ No newline at end of file+ldapErrorInvalidCustomFilter=   LDAP     ""(""    "")"".+ldapErrorMissingClientId=Client ID     ,      realm.","Yeah, you are right, my bad. Should be ""   realm"" as elsewhere. ",
2922117,chameleon82,https://api.github.com/repos/keycloak/keycloak/pulls/3898,106178289,2017-03-15T14:26:49Z,themes/src/main/resources/theme/base/admin/messages/messages_ru.properties,"@@ -1,14 +1,26 @@-invalidPasswordMinLengthMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u0430\u044F \u0434\u043B\u0438\u043D\u0430 {0}.-invalidPasswordMinDigitsMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0446\u0438\u0444\u0440\u043E\u0432\u044B\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 {0}.-invalidPasswordMinLowerCaseCharsMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u0432 \u043D\u0438\u0436\u043D\u0435\u043C \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0435 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 {0}.-invalidPasswordMinUpperCaseCharsMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u0432 \u0432\u0435\u0440\u0445\u043D\u0435\u043C \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0435 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 {0}.-invalidPasswordMinSpecialCharsMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0441\u043F\u0435\u0446\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u043D\u0435 \u043C\u0435\u043D\u0435\u0435 {0}.-invalidPasswordNotUsernameMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u043D\u0435 \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0442\u044C \u0441 \u0438\u043C\u0435\u043D\u0435\u043C \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F.-invalidPasswordRegexPatternMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u043D\u0435 \u043F\u0440\u043E\u0448\u0435\u043B \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0443 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u044B\u043C \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u0435\u043C.-invalidPasswordHistoryMessage=\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u043F\u0430\u0440\u043E\u043B\u044C: \u043D\u0435 \u0434\u043E\u043B\u0436\u0435\u043D \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0442\u044C \u0441 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u043C\u0438 {0} \u043F\u0430\u0440\u043E\u043B\u044F\u043C\u0438.+# encoding: utf-8+invalidPasswordMinLengthMessage= :   {0}.+invalidPasswordMinDigitsMessage= :       {0}.+invalidPasswordMinLowerCaseCharsMessage= :         {0}.+invalidPasswordMinUpperCaseCharsMessage= :         {0}.+invalidPasswordMinSpecialCharsMessage= :      {0}.+invalidPasswordNotUsernameMessage= :      .+invalidPasswordRegexPatternMessage= :     .+invalidPasswordHistoryMessage= :      {0} .+invalidPasswordGenericMessage= :      .","I`m agree, end user is not technical specialist, and """" would been cleaner for him understanding.",
2922117,chameleon82,https://api.github.com/repos/keycloak/keycloak/pulls/3898,106235634,2017-03-15T17:45:09Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_ru.properties,"@@ -1,915 +1,1267 @@-consoleTitle=\u041A\u043E\u043D\u0441\u043E\u043B\u044C \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0442\u043E\u0440\u0430 Keycloak+# encoding: utf-8+consoleTitle=  Keycloak  # Common messages-enabled=\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u043E-name=\u0418\u043C\u044F-displayName=\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0435\u043C\u043E\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435-displayNameHtml=\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0435\u043C\u043E\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432 HTML-save=\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C-cancel=\u041E\u0442\u043C\u0435\u043D\u0430-onText=\u0412\u041A\u041B-offText=\u0412\u042B\u041A-client=\u041A\u043B\u0438\u0435\u043D\u0442-clients=\u041A\u043B\u0438\u0435\u043D\u0442\u044B-clear=\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C-selectOne=\u0412\u044B\u0431\u0440\u0430\u0442\u044C...--true=\u0414\u0430-false=\u041D\u0435\u0442+enabled=+hidden=+name=+displayName= +displayNameHtml=   HTML+save=+cancel=+onText=+offText=+client=+clients=+clear=+selectOne=... +true=+false=++endpoints=   # Realm settings-realm-detail.enabled.tooltip=\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0438 \u0438 \u043A\u043B\u0438\u0435\u043D\u0442\u044B \u043C\u043E\u0433\u0443\u0442 \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0434\u043E\u0441\u0442\u0443\u043F \u043A Realm \u0442\u043E\u043B\u044C\u043A\u043E \u0435\u0441\u043B\u0438 \u043E\u043D \u0432\u043A\u043B\u044E\u0447\u0435\u043D-registrationAllowed=\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F-registrationAllowed.tooltip=\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C/\u0432\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438. \u0421\u0441\u044B\u043B\u043A\u0430 \u0434\u043B\u044F \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u0431\u0443\u0434\u0435\u0442 \u0442\u0430\u043A\u0436\u0435 \u043F\u043E\u043A\u0430\u0437\u0430\u043D\u0430 \u043D\u0430 \u0444\u043E\u0440\u043C\u0435 \u0432\u0445\u043E\u0434\u0430.-registrationEmailAsUsername=Email \u043A\u0430\u043A \u0438\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F-registrationEmailAsUsername.tooltip=\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0442\u043E \u043D\u0430 \u0444\u043E\u0440\u043C\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E\u043B\u0435 \u0438\u043C\u0435\u043D\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0431\u0443\u0434\u0435\u0442 \u0441\u043A\u0440\u044B\u0442\u043E \u0438 \u0432 \u043A\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0438\u043C\u0435\u043D\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0434\u043B\u044F \u043D\u043E\u0432\u044B\u0445 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0435\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F email.-editUsernameAllowed=\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u0443\u0435\u043C\u043E\u0435 \u0438\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F-editUsernameAllowed.tooltip=\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E,\u0442\u043E \u0438\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u043C\u043E\u0436\u043D\u043E \u0431\u0443\u0434\u0435\u0442 \u043E\u0442\u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C, \u0438\u043D\u0430\u0447\u0435 \u043E\u043D\u043E \u0431\u0443\u0434\u0435\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u043C \u0442\u043E\u043B\u044C\u043A\u043E \u0434\u043B\u044F \u0447\u0442\u0435\u043D\u0438\u044F.-resetPasswordAllowed=\u0417\u0430\u0431\u044B\u043B\u0438 \u043F\u0430\u0440\u043E\u043B\u044C-resetPasswordAllowed.tooltip=\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0435\u0442 \u0441\u0441\u044B\u043B\u043A\u0443 \u043D\u0430 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435 \u0432\u0445\u043E\u0434\u0430 \u0434\u043B\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F, \u043F\u043E \u043F\u0435\u0440\u0435\u0445\u043E\u0434\u0443 \u043D\u0430 \u043A\u043E\u0442\u043E\u0440\u0443\u044E \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0441\u043C\u043E\u0436\u0435\u0442 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0441\u0432\u043E\u0438 \u0434\u0430\u043D\u043D\u044B\u0435 \u0434\u043B\u044F \u0432\u0445\u043E\u0434\u0430.-rememberMe=\u0417\u0430\u043F\u043E\u043C\u043D\u0438\u0442\u044C \u043C\u0435\u043D\u044F-rememberMe.tooltip=\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0447\u0435\u043A\u0431\u043E\u043A\u0441 \u043D\u0430 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435 \u0432\u0445\u043E\u0434\u0430, \u0447\u0442\u043E\u0431\u044B \u0440\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044C \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044E \u0437\u0430\u043F\u043E\u043C\u043D\u0438\u0442\u044C \u0432\u0445\u043E\u0434 \u0432 \u0443\u0447\u0435\u0442\u043D\u0443\u044E \u0437\u0430\u043F\u0438\u0441\u044C \u0432 \u0441\u043B\u0443\u0447\u0430\u0435 \u0435\u0441\u043B\u0438 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043D\u0430\u044F \u0441\u0435\u0441\u0441\u0438\u044F \u0443\u0441\u0442\u0430\u0440\u0435\u0435\u0442.-verifyEmail=\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u0435 email-verifyEmail.tooltip=\u0422\u0440\u0435\u0431\u0443\u0435\u0442 \u0443 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C \u0441\u0432\u043E\u0439 email \u043F\u0440\u0438 \u043F\u0435\u0440\u0432\u043E\u043C \u0432\u0445\u043E\u0434\u0435 \u0432 \u0443\u0447\u0435\u0442\u043D\u0443\u044E \u0437\u0430\u043F\u0438\u0441\u044C.-sslRequired=\u0422\u0440\u0435\u0431\u0443\u0435\u0442 SSL-sslRequired.option.all=\u0432\u0441\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B-sslRequired.option.external=\u0432\u043D\u0435\u0448\u043D\u0438\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B-sslRequired.option.none=\u043D\u0435\u0442-sslRequired.tooltip=\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u043B\u0438 HTTPS? '\u043D\u0435\u0442' \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043E HTTPS \u043D\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u0434\u043B\u044F \u043B\u044E\u0431\u043E\u0433\u043E \u043A\u043B\u0438\u0435\u043D\u0442\u0430 \u0441 \u043B\u044E\u0431\u044B\u043C IP \u0430\u0434\u0440\u0435\u0441\u043E\u043C. '\u0412\u043D\u0435\u0448\u043D\u0438\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B' \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043E localhost \u0438 \u043F\u0440\u0438\u0432\u0430\u0442\u043D\u044B\u0435 IP \u0430\u0434\u0440\u0435\u0441\u0430 \u043C\u043E\u0433\u0443\u0442 \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0434\u043E\u0441\u0442\u0443\u043F \u0431\u0435\u0437 HTTPS. '\u0412\u0441\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B' \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043E HTTPS \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u0434\u043B\u044F \u0432\u0441\u0435\u0445 IP \u0430\u0434\u0440\u0435\u0441\u043E\u0432.-publicKey=\u041F\u0443\u0431\u043B\u0438\u0447\u043D\u044B\u0439 \u043A\u043B\u044E\u0447-privateKey=\u041F\u0440\u0438\u0432\u0430\u0442\u043D\u044B\u0439 \u043A\u043B\u044E\u0447-gen-new-keys=\u0421\u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043D\u043E\u0432\u044B\u0439 \u043A\u043B\u044E\u0447-certificate=\u0421\u0435\u0440\u0442\u0438\u0444\u0438\u043A\u0430\u0442-host=\u0425\u043E\u0441\u0442-smtp-host=SMTP \u0445\u043E\u0441\u0442-port=\u041F\u043E\u0440\u0442-smtp-port=SMTP \u043F\u043E\u0440\u0442 (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E 25)-from=\u041E\u0442-sender-email-addr=Email \u043E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u0435\u043B\u044F-enable-ssl=\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C SSL-enable-start-tls=\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C StartTLS-enable-auth=\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0430\u0443\u0442\u0435\u043D\u0442\u0438\u0444\u0438\u043A\u0430\u0446\u0438\u044E-username=\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F-login-username=\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0434\u043B\u044F \u0432\u0445\u043E\u0434\u0430-password=\u041F\u0430\u0440\u043E\u043B\u044C-login-password=\u041F\u0430\u0440\u043E\u043B\u044C \u0434\u043B\u044F \u0432\u0445\u043E\u0434\u0430-login-theme=\u0422\u0435\u043C\u0430 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B \u0432\u0445\u043E\u0434\u0430-login-theme.tooltip=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043C\u0443 \u0434\u043B\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446 \u0432\u0445\u043E\u0434\u0430, \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E\u0433\u043E \u043E\u0434\u043D\u043E\u0440\u0430\u0437\u043E\u0432\u043E\u0433\u043E \u043F\u0430\u0440\u043E\u043B\u044F (TOTP), \u0432\u044B\u0434\u0430\u0447\u0438 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0438\u0439, \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u0438 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u043F\u0430\u0440\u043E\u043B\u044F.-account-theme=\u0422\u0435\u043C\u0430 \u0443\u0447\u0435\u0442\u043D\u043E\u0439 \u0437\u0430\u043F\u0438\u0441\u0438-account-theme.tooltip=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043C\u0443 \u0434\u043B\u044F \u0443\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u044F \u0443\u0447\u0435\u0442\u043D\u043E\u0439 \u0437\u0430\u043F\u0438\u0441\u044C\u044E \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F.-admin-console-theme=\u0422\u0435\u043C\u0430 \u043A\u043E\u043D\u0441\u043E\u043B\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0442\u043E\u0440\u0430-select-theme-admin-console=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043C\u0443 \u0434\u043B\u044F \u043A\u043E\u043D\u0441\u043E\u043B\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0442\u043E\u0440\u0430.-email-theme=\u0422\u0435\u043C\u0430 \u0434\u043B\u044F email-select-theme-email=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043C\u0443 \u0434\u043B\u044F email, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0431\u0443\u0434\u0443\u0442 \u043E\u0442\u0441\u044B\u043B\u0430\u0442\u044C\u0441\u044F \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430.-i18n-enabled=\u0418\u043D\u0442\u0435\u0440\u043D\u0430\u0446\u0438\u043E\u043D\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F-supported-locales=\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043C\u044B\u0435 \u044F\u0437\u044B\u043A\u0438-supported-locales.placeholder=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438 \u043D\u0430\u0436\u043C\u0438\u0442\u0435 Enter-default-locale=\u042F\u0437\u044B\u043A \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E-realm-cache-clear=\u041A\u044D\u0448 Realm-realm-cache-clear.tooltip=\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043F\u0438\u0441\u0438 \u0432 \u043A\u044D\u0448\u0435 realm (\u0443\u0434\u0430\u043B\u0438\u0442 \u0432\u0441\u0435 \u0437\u0430\u043F\u0438\u0441\u0438 \u0434\u043B\u044F \u0432\u0441\u0435\u0445 realm)-user-cache-clear=\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u043A\u044D\u0448-user-cache-clear.tooltip=\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043F\u0438\u0441\u0438 \u0432 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u043C \u043A\u044D\u0448\u0435 (\u044D\u0442\u043E \u0443\u0434\u0430\u043B\u0438\u0442 \u0437\u0430\u043F\u0438\u0441\u0438 \u0434\u043B\u044F \u0432\u0441\u0435\u0445 realm)-revoke-refresh-token=\u041E\u0442\u0437\u044B\u0432 \u0442\u043E\u043A\u0435\u043D\u0430 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F-revoke-refresh-token.tooltip=\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0442\u043E \u0442\u043E\u043A\u0435\u043D\u044B \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u043C\u043E\u0433\u0443\u0442 \u0431\u044B\u0442\u044C \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u044B \u0435\u0434\u0438\u043D\u043E\u0436\u0434\u044B. \u0412 \u043F\u0440\u043E\u0442\u0438\u0432\u043D\u043E\u043C \u0441\u043B\u0443\u0447\u0430\u0435, \u0442\u043E\u043A\u0435\u043D \u043E\u0442\u0437\u044B\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0435 \u0431\u0443\u0434\u0435\u0442 \u0438 \u043C\u043E\u0436\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u043C\u043D\u043E\u0433\u043E\u043A\u0440\u0430\u0442\u043D\u043E.-sso-session-idle=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0441\u0435\u0441\u0441\u0438\u0438 SSO-seconds=\u0441\u0435\u043A\u0443\u043D\u0434-minutes=\u043C\u0438\u043D\u0443\u0442-hours=\u0447\u0430\u0441\u043E\u0432-days=\u0434\u043D\u0435\u0439-sso-session-max=\u041E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D\u0438\u0435 \u0441\u0435\u0441\u0441\u0438\u0438 SSO-sso-session-idle.tooltip=\u0414\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0431\u0435\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u0441\u0435\u0441\u0441\u0438\u0438. \u041F\u043E \u0438\u0441\u0442\u0435\u0447\u0435\u043D\u0438\u0438 \u044D\u0442\u043E\u0433\u043E \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u044B \u0438 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043D\u044B\u0435 \u0441\u0435\u0441\u0441\u0438\u0438 \u0441\u0442\u0430\u043D\u043E\u0432\u044F\u0442\u0441\u044F \u043D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u044B\u043C\u0438.-sso-session-max.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0434\u043E \u0442\u043E\u0433\u043E, \u043A\u0430\u043A \u0438\u0441\u0442\u0435\u0447\u0435\u0442 \u0441\u0435\u0441\u0441\u0438\u044F. \u041F\u043E \u0438\u0441\u0442\u0435\u0447\u0435\u043D\u0438\u0438 \u044D\u0442\u043E\u0433\u043E \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u044B \u0438 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043D\u044B\u0435 \u0441\u0435\u0441\u0441\u0438\u0438 \u0441\u0442\u0430\u043D\u043E\u0432\u044F\u0442\u0441\u044F \u043D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u044B\u043C\u0438.-offline-session-idle=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u043E\u0444\u0444\u043B\u0430\u0439\u043D \u0441\u0435\u0441\u0441\u0438\u0438-offline-session-idle.tooltip=\u0414\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0431\u0435\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u043E\u0444\u0444\u043B\u0430\u0439\u043D \u0441\u0435\u0441\u0441\u0438\u0438. \u0412\u0430\u043C \u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u043E\u0444\u0444\u043B\u0430\u0439\u043D \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u0445\u043E\u0442\u044F \u0431\u044B \u0440\u0430\u0437 \u0437\u0430 \u044D\u0442\u043E\u0442 \u043F\u0435\u0440\u0438\u043E\u0434, \u0438\u043D\u0430\u0447\u0435 \u0441\u0435\u0441\u0441\u0438\u044F \u0438\u0441\u0442\u0435\u0447\u0435\u0442.-access-token-lifespan=\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0436\u0438\u0437\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430-access-token-lifespan.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430. \u0417\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0440\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0442\u044C \u043A\u0430\u043A \u043C\u043E\u0436\u043D\u043E \u0431\u043B\u0438\u0436\u0435 \u043A \u0442\u0430\u0439\u043C\u0430\u0443\u0442\u0443 SSO.-access-token-lifespan-for-implicit-flow=\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0436\u0438\u0437\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430 \u0434\u043B\u044F Implicit Flow-access-token-lifespan-for-implicit-flow.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430 \u043F\u043E\u0441\u043B\u0435 \u0442\u043E\u0433\u043E \u043A\u0430\u043A \u0441\u0435\u0441\u0441\u0438\u044F \u0442\u043E\u043A\u0435\u043D\u0430 OpenID Connect Implicit Flow \u0438\u0441\u0442\u0435\u043A\u043B\u0430. \u042D\u0442\u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0440\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043A\u0430\u043A \u043C\u043E\u0436\u043D\u043E \u0431\u043B\u0438\u0436\u0435 \u043A \u0442\u0430\u0439\u043C\u0430\u0443\u0442\u0443 SSO. \u041D\u0435\u0442 \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u0438 \u043E\u0431\u043D\u043E\u0432\u0438\u0442\u044C \u0442\u043E\u043A\u0435\u043D \u0432\u043E \u0432\u0440\u0435\u043C\u044F Implicit Flow, \u043F\u043E\u044D\u0442\u043E\u043C\u0443 \u044D\u0442\u043E\u0442 \u0442\u0430\u0439\u043C\u0430\u0443\u0442 \u043E\u0442\u043B\u0438\u0447\u0430\u0435\u0442\u0441\u044F \u043E\u0442 '\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438 \u0436\u0438\u0437\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430' -client-login-timeout=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0430\u0432\u0442\u043E\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u043A\u043B\u0438\u0435\u043D\u0442\u0430-client-login-timeout.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u043A\u043B\u0438\u0435\u043D\u0442\u0430 \u0434\u043B\u044F \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0438\u044F \u043F\u0440\u043E\u0442\u043E\u043A\u043E\u043B\u0430 access token. \u041E\u0431\u044B\u0447\u043D\u043E \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0440\u0430\u0432\u043D\u044B\u043C 1 \u043C\u0438\u043D\u0443\u0442\u0435.-login-timeout=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0432\u0445\u043E\u0434\u0430-login-timeout.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0434\u043B\u044F \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0438\u044F \u0432\u0445\u043E\u0434\u0430. \u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 (30 \u043C\u0438\u043D\u0443\u0442 \u0438 \u0431\u043E\u043B\u0435\u0435).-login-action-timeout=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u043F\u043E \u0432\u0445\u043E\u0434\u0443-login-action-timeout.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F, \u0437\u0430 \u043A\u043E\u0442\u043E\u0440\u043E\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0434\u043E\u043B\u0436\u0435\u043D \u0432\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043F\u043E\u0441\u043B\u0435 \u0432\u0445\u043E\u0434\u0430, \u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u043F\u0430\u0440\u043E\u043B\u044F \u0438\u043B\u0438 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044F \u043E\u0434\u043D\u043E\u0440\u0430\u0437\u043E\u0432\u043E\u0433\u043E \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E\u0433\u043E \u043F\u0430\u0440\u043E\u043B\u044F. \u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 (5 \u043C\u0438\u043D\u0443\u0442 \u0438 \u0431\u043E\u043B\u0435\u0435).-headers=\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438-brute-force-detection=\u041E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u0435 Brute Force+realm-detail.enabled.tooltip=       Realm    +realm-detail.oidc-endpoints.tooltip=    OpenID Connect+registrationAllowed= +registrationAllowed.tooltip=/  .         .+registrationEmailAsUsername=Email   ","As previous PR https://github.com/keycloak/keycloak/pull/2925 we decided to translate words in one way, and translate Email as ""email"", not "" "", cause its so long on login/reg forms. I guess, ""Email    "" will be prettier.",
2922117,chameleon82,https://api.github.com/repos/keycloak/keycloak/pulls/3898,106238654,2017-03-15T17:56:10Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_ru.properties,"@@ -1,915 +1,1267 @@-consoleTitle=\u041A\u043E\u043D\u0441\u043E\u043B\u044C \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0442\u043E\u0440\u0430 Keycloak+# encoding: utf-8+consoleTitle=  Keycloak  # Common messages-enabled=\u0412\u043A\u043B\u044E\u0447\u0435\u043D\u043E-name=\u0418\u043C\u044F-displayName=\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0435\u043C\u043E\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435-displayNameHtml=\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0435\u043C\u043E\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432 HTML-save=\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C-cancel=\u041E\u0442\u043C\u0435\u043D\u0430-onText=\u0412\u041A\u041B-offText=\u0412\u042B\u041A-client=\u041A\u043B\u0438\u0435\u043D\u0442-clients=\u041A\u043B\u0438\u0435\u043D\u0442\u044B-clear=\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C-selectOne=\u0412\u044B\u0431\u0440\u0430\u0442\u044C...--true=\u0414\u0430-false=\u041D\u0435\u0442+enabled=+hidden=+name=+displayName= +displayNameHtml=   HTML+save=+cancel=+onText=+offText=+client=+clients=+clear=+selectOne=... +true=+false=++endpoints=   # Realm settings-realm-detail.enabled.tooltip=\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0438 \u0438 \u043A\u043B\u0438\u0435\u043D\u0442\u044B \u043C\u043E\u0433\u0443\u0442 \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0434\u043E\u0441\u0442\u0443\u043F \u043A Realm \u0442\u043E\u043B\u044C\u043A\u043E \u0435\u0441\u043B\u0438 \u043E\u043D \u0432\u043A\u043B\u044E\u0447\u0435\u043D-registrationAllowed=\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F-registrationAllowed.tooltip=\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C/\u0432\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0443 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438. \u0421\u0441\u044B\u043B\u043A\u0430 \u0434\u043B\u044F \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u0431\u0443\u0434\u0435\u0442 \u0442\u0430\u043A\u0436\u0435 \u043F\u043E\u043A\u0430\u0437\u0430\u043D\u0430 \u043D\u0430 \u0444\u043E\u0440\u043C\u0435 \u0432\u0445\u043E\u0434\u0430.-registrationEmailAsUsername=Email \u043A\u0430\u043A \u0438\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F-registrationEmailAsUsername.tooltip=\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0442\u043E \u043D\u0430 \u0444\u043E\u0440\u043C\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E\u043B\u0435 \u0438\u043C\u0435\u043D\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0431\u0443\u0434\u0435\u0442 \u0441\u043A\u0440\u044B\u0442\u043E \u0438 \u0432 \u043A\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0438\u043C\u0435\u043D\u0438 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0434\u043B\u044F \u043D\u043E\u0432\u044B\u0445 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u0435\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F email.-editUsernameAllowed=\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u0443\u0435\u043C\u043E\u0435 \u0438\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F-editUsernameAllowed.tooltip=\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E,\u0442\u043E \u0438\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u043C\u043E\u0436\u043D\u043E \u0431\u0443\u0434\u0435\u0442 \u043E\u0442\u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C, \u0438\u043D\u0430\u0447\u0435 \u043E\u043D\u043E \u0431\u0443\u0434\u0435\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u043C \u0442\u043E\u043B\u044C\u043A\u043E \u0434\u043B\u044F \u0447\u0442\u0435\u043D\u0438\u044F.-resetPasswordAllowed=\u0417\u0430\u0431\u044B\u043B\u0438 \u043F\u0430\u0440\u043E\u043B\u044C-resetPasswordAllowed.tooltip=\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0435\u0442 \u0441\u0441\u044B\u043B\u043A\u0443 \u043D\u0430 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435 \u0432\u0445\u043E\u0434\u0430 \u0434\u043B\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F, \u043F\u043E \u043F\u0435\u0440\u0435\u0445\u043E\u0434\u0443 \u043D\u0430 \u043A\u043E\u0442\u043E\u0440\u0443\u044E \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0441\u043C\u043E\u0436\u0435\u0442 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0441\u0432\u043E\u0438 \u0434\u0430\u043D\u043D\u044B\u0435 \u0434\u043B\u044F \u0432\u0445\u043E\u0434\u0430.-rememberMe=\u0417\u0430\u043F\u043E\u043C\u043D\u0438\u0442\u044C \u043C\u0435\u043D\u044F-rememberMe.tooltip=\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0447\u0435\u043A\u0431\u043E\u043A\u0441 \u043D\u0430 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0435 \u0432\u0445\u043E\u0434\u0430, \u0447\u0442\u043E\u0431\u044B \u0440\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044C \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044E \u0437\u0430\u043F\u043E\u043C\u043D\u0438\u0442\u044C \u0432\u0445\u043E\u0434 \u0432 \u0443\u0447\u0435\u0442\u043D\u0443\u044E \u0437\u0430\u043F\u0438\u0441\u044C \u0432 \u0441\u043B\u0443\u0447\u0430\u0435 \u0435\u0441\u043B\u0438 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043D\u0430\u044F \u0441\u0435\u0441\u0441\u0438\u044F \u0443\u0441\u0442\u0430\u0440\u0435\u0435\u0442.-verifyEmail=\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u0435 email-verifyEmail.tooltip=\u0422\u0440\u0435\u0431\u0443\u0435\u0442 \u0443 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C \u0441\u0432\u043E\u0439 email \u043F\u0440\u0438 \u043F\u0435\u0440\u0432\u043E\u043C \u0432\u0445\u043E\u0434\u0435 \u0432 \u0443\u0447\u0435\u0442\u043D\u0443\u044E \u0437\u0430\u043F\u0438\u0441\u044C.-sslRequired=\u0422\u0440\u0435\u0431\u0443\u0435\u0442 SSL-sslRequired.option.all=\u0432\u0441\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B-sslRequired.option.external=\u0432\u043D\u0435\u0448\u043D\u0438\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B-sslRequired.option.none=\u043D\u0435\u0442-sslRequired.tooltip=\u0422\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u043B\u0438 HTTPS? '\u043D\u0435\u0442' \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043E HTTPS \u043D\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u0434\u043B\u044F \u043B\u044E\u0431\u043E\u0433\u043E \u043A\u043B\u0438\u0435\u043D\u0442\u0430 \u0441 \u043B\u044E\u0431\u044B\u043C IP \u0430\u0434\u0440\u0435\u0441\u043E\u043C. '\u0412\u043D\u0435\u0448\u043D\u0438\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B' \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043E localhost \u0438 \u043F\u0440\u0438\u0432\u0430\u0442\u043D\u044B\u0435 IP \u0430\u0434\u0440\u0435\u0441\u0430 \u043C\u043E\u0433\u0443\u0442 \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0434\u043E\u0441\u0442\u0443\u043F \u0431\u0435\u0437 HTTPS. '\u0412\u0441\u0435 \u0437\u0430\u043F\u0440\u043E\u0441\u044B' \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043E HTTPS \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u0434\u043B\u044F \u0432\u0441\u0435\u0445 IP \u0430\u0434\u0440\u0435\u0441\u043E\u0432.-publicKey=\u041F\u0443\u0431\u043B\u0438\u0447\u043D\u044B\u0439 \u043A\u043B\u044E\u0447-privateKey=\u041F\u0440\u0438\u0432\u0430\u0442\u043D\u044B\u0439 \u043A\u043B\u044E\u0447-gen-new-keys=\u0421\u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043D\u043E\u0432\u044B\u0439 \u043A\u043B\u044E\u0447-certificate=\u0421\u0435\u0440\u0442\u0438\u0444\u0438\u043A\u0430\u0442-host=\u0425\u043E\u0441\u0442-smtp-host=SMTP \u0445\u043E\u0441\u0442-port=\u041F\u043E\u0440\u0442-smtp-port=SMTP \u043F\u043E\u0440\u0442 (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E 25)-from=\u041E\u0442-sender-email-addr=Email \u043E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u0435\u043B\u044F-enable-ssl=\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C SSL-enable-start-tls=\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C StartTLS-enable-auth=\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0430\u0443\u0442\u0435\u043D\u0442\u0438\u0444\u0438\u043A\u0430\u0446\u0438\u044E-username=\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F-login-username=\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0434\u043B\u044F \u0432\u0445\u043E\u0434\u0430-password=\u041F\u0430\u0440\u043E\u043B\u044C-login-password=\u041F\u0430\u0440\u043E\u043B\u044C \u0434\u043B\u044F \u0432\u0445\u043E\u0434\u0430-login-theme=\u0422\u0435\u043C\u0430 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B \u0432\u0445\u043E\u0434\u0430-login-theme.tooltip=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043C\u0443 \u0434\u043B\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446 \u0432\u0445\u043E\u0434\u0430, \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E\u0433\u043E \u043E\u0434\u043D\u043E\u0440\u0430\u0437\u043E\u0432\u043E\u0433\u043E \u043F\u0430\u0440\u043E\u043B\u044F (TOTP), \u0432\u044B\u0434\u0430\u0447\u0438 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0438\u0439, \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u0438 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u043F\u0430\u0440\u043E\u043B\u044F.-account-theme=\u0422\u0435\u043C\u0430 \u0443\u0447\u0435\u0442\u043D\u043E\u0439 \u0437\u0430\u043F\u0438\u0441\u0438-account-theme.tooltip=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043C\u0443 \u0434\u043B\u044F \u0443\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u044F \u0443\u0447\u0435\u0442\u043D\u043E\u0439 \u0437\u0430\u043F\u0438\u0441\u044C\u044E \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F.-admin-console-theme=\u0422\u0435\u043C\u0430 \u043A\u043E\u043D\u0441\u043E\u043B\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0442\u043E\u0440\u0430-select-theme-admin-console=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043C\u0443 \u0434\u043B\u044F \u043A\u043E\u043D\u0441\u043E\u043B\u0438 \u0430\u0434\u043C\u0438\u043D\u0438\u0441\u0442\u0440\u0430\u0442\u043E\u0440\u0430.-email-theme=\u0422\u0435\u043C\u0430 \u0434\u043B\u044F email-select-theme-email=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0442\u0435\u043C\u0443 \u0434\u043B\u044F email, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0431\u0443\u0434\u0443\u0442 \u043E\u0442\u0441\u044B\u043B\u0430\u0442\u044C\u0441\u044F \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430.-i18n-enabled=\u0418\u043D\u0442\u0435\u0440\u043D\u0430\u0446\u0438\u043E\u043D\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F-supported-locales=\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043C\u044B\u0435 \u044F\u0437\u044B\u043A\u0438-supported-locales.placeholder=\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438 \u043D\u0430\u0436\u043C\u0438\u0442\u0435 Enter-default-locale=\u042F\u0437\u044B\u043A \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E-realm-cache-clear=\u041A\u044D\u0448 Realm-realm-cache-clear.tooltip=\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043F\u0438\u0441\u0438 \u0432 \u043A\u044D\u0448\u0435 realm (\u0443\u0434\u0430\u043B\u0438\u0442 \u0432\u0441\u0435 \u0437\u0430\u043F\u0438\u0441\u0438 \u0434\u043B\u044F \u0432\u0441\u0435\u0445 realm)-user-cache-clear=\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439 \u043A\u044D\u0448-user-cache-clear.tooltip=\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043F\u0438\u0441\u0438 \u0432 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u043C \u043A\u044D\u0448\u0435 (\u044D\u0442\u043E \u0443\u0434\u0430\u043B\u0438\u0442 \u0437\u0430\u043F\u0438\u0441\u0438 \u0434\u043B\u044F \u0432\u0441\u0435\u0445 realm)-revoke-refresh-token=\u041E\u0442\u0437\u044B\u0432 \u0442\u043E\u043A\u0435\u043D\u0430 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F-revoke-refresh-token.tooltip=\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0442\u043E \u0442\u043E\u043A\u0435\u043D\u044B \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u043C\u043E\u0433\u0443\u0442 \u0431\u044B\u0442\u044C \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u044B \u0435\u0434\u0438\u043D\u043E\u0436\u0434\u044B. \u0412 \u043F\u0440\u043E\u0442\u0438\u0432\u043D\u043E\u043C \u0441\u043B\u0443\u0447\u0430\u0435, \u0442\u043E\u043A\u0435\u043D \u043E\u0442\u0437\u044B\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0435 \u0431\u0443\u0434\u0435\u0442 \u0438 \u043C\u043E\u0436\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u043C\u043D\u043E\u0433\u043E\u043A\u0440\u0430\u0442\u043D\u043E.-sso-session-idle=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0441\u0435\u0441\u0441\u0438\u0438 SSO-seconds=\u0441\u0435\u043A\u0443\u043D\u0434-minutes=\u043C\u0438\u043D\u0443\u0442-hours=\u0447\u0430\u0441\u043E\u0432-days=\u0434\u043D\u0435\u0439-sso-session-max=\u041E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D\u0438\u0435 \u0441\u0435\u0441\u0441\u0438\u0438 SSO-sso-session-idle.tooltip=\u0414\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0431\u0435\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u0441\u0435\u0441\u0441\u0438\u0438. \u041F\u043E \u0438\u0441\u0442\u0435\u0447\u0435\u043D\u0438\u0438 \u044D\u0442\u043E\u0433\u043E \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u044B \u0438 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043D\u044B\u0435 \u0441\u0435\u0441\u0441\u0438\u0438 \u0441\u0442\u0430\u043D\u043E\u0432\u044F\u0442\u0441\u044F \u043D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u044B\u043C\u0438.-sso-session-max.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0434\u043E \u0442\u043E\u0433\u043E, \u043A\u0430\u043A \u0438\u0441\u0442\u0435\u0447\u0435\u0442 \u0441\u0435\u0441\u0441\u0438\u044F. \u041F\u043E \u0438\u0441\u0442\u0435\u0447\u0435\u043D\u0438\u0438 \u044D\u0442\u043E\u0433\u043E \u0432\u0440\u0435\u043C\u0435\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u044B \u0438 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u043D\u044B\u0435 \u0441\u0435\u0441\u0441\u0438\u0438 \u0441\u0442\u0430\u043D\u043E\u0432\u044F\u0442\u0441\u044F \u043D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u044B\u043C\u0438.-offline-session-idle=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u043E\u0444\u0444\u043B\u0430\u0439\u043D \u0441\u0435\u0441\u0441\u0438\u0438-offline-session-idle.tooltip=\u0414\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0431\u0435\u0437\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u043E\u0444\u0444\u043B\u0430\u0439\u043D \u0441\u0435\u0441\u0441\u0438\u0438. \u0412\u0430\u043C \u043D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u043E\u0444\u0444\u043B\u0430\u0439\u043D \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u0445\u043E\u0442\u044F \u0431\u044B \u0440\u0430\u0437 \u0437\u0430 \u044D\u0442\u043E\u0442 \u043F\u0435\u0440\u0438\u043E\u0434, \u0438\u043D\u0430\u0447\u0435 \u0441\u0435\u0441\u0441\u0438\u044F \u0438\u0441\u0442\u0435\u0447\u0435\u0442.-access-token-lifespan=\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0436\u0438\u0437\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430-access-token-lifespan.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430. \u0417\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0440\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0442\u044C \u043A\u0430\u043A \u043C\u043E\u0436\u043D\u043E \u0431\u043B\u0438\u0436\u0435 \u043A \u0442\u0430\u0439\u043C\u0430\u0443\u0442\u0443 SSO.-access-token-lifespan-for-implicit-flow=\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0436\u0438\u0437\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430 \u0434\u043B\u044F Implicit Flow-access-token-lifespan-for-implicit-flow.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430 \u043F\u043E\u0441\u043B\u0435 \u0442\u043E\u0433\u043E \u043A\u0430\u043A \u0441\u0435\u0441\u0441\u0438\u044F \u0442\u043E\u043A\u0435\u043D\u0430 OpenID Connect Implicit Flow \u0438\u0441\u0442\u0435\u043A\u043B\u0430. \u042D\u0442\u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0440\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043A\u0430\u043A \u043C\u043E\u0436\u043D\u043E \u0431\u043B\u0438\u0436\u0435 \u043A \u0442\u0430\u0439\u043C\u0430\u0443\u0442\u0443 SSO. \u041D\u0435\u0442 \u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u0438 \u043E\u0431\u043D\u043E\u0432\u0438\u0442\u044C \u0442\u043E\u043A\u0435\u043D \u0432\u043E \u0432\u0440\u0435\u043C\u044F Implicit Flow, \u043F\u043E\u044D\u0442\u043E\u043C\u0443 \u044D\u0442\u043E\u0442 \u0442\u0430\u0439\u043C\u0430\u0443\u0442 \u043E\u0442\u043B\u0438\u0447\u0430\u0435\u0442\u0441\u044F \u043E\u0442 '\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438 \u0436\u0438\u0437\u043D\u0438 \u0442\u043E\u043A\u0435\u043D\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430' -client-login-timeout=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0430\u0432\u0442\u043E\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u043A\u043B\u0438\u0435\u043D\u0442\u0430-client-login-timeout.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u043A\u043B\u0438\u0435\u043D\u0442\u0430 \u0434\u043B\u044F \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0438\u044F \u043F\u0440\u043E\u0442\u043E\u043A\u043E\u043B\u0430 access token. \u041E\u0431\u044B\u0447\u043D\u043E \u0443\u0441\u0442\u0430\u043D\u0430\u0432\u043B\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0440\u0430\u0432\u043D\u044B\u043C 1 \u043C\u0438\u043D\u0443\u0442\u0435.-login-timeout=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0432\u0445\u043E\u0434\u0430-login-timeout.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044F \u0434\u043B\u044F \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0438\u044F \u0432\u0445\u043E\u0434\u0430. \u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 (30 \u043C\u0438\u043D\u0443\u0442 \u0438 \u0431\u043E\u043B\u0435\u0435).-login-action-timeout=\u0422\u0430\u0439\u043C\u0430\u0443\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0439 \u043F\u043E \u0432\u0445\u043E\u0434\u0443-login-action-timeout.tooltip=\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F, \u0437\u0430 \u043A\u043E\u0442\u043E\u0440\u043E\u0435 \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0434\u043E\u043B\u0436\u0435\u043D \u0432\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043F\u043E\u0441\u043B\u0435 \u0432\u0445\u043E\u0434\u0430, \u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440, \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435 \u043F\u0430\u0440\u043E\u043B\u044F \u0438\u043B\u0438 \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044F \u043E\u0434\u043D\u043E\u0440\u0430\u0437\u043E\u0432\u043E\u0433\u043E \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E\u0433\u043E \u043F\u0430\u0440\u043E\u043B\u044F. \u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0443\u0435\u0442\u0441\u044F \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u043E \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 (5 \u043C\u0438\u043D\u0443\u0442 \u0438 \u0431\u043E\u043B\u0435\u0435).-headers=\u0417\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u0438-brute-force-detection=\u041E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u0435 Brute Force+realm-detail.enabled.tooltip=       Realm    +realm-detail.oidc-endpoints.tooltip=    OpenID Connect+registrationAllowed= +registrationAllowed.tooltip=/  .         .+registrationEmailAsUsername=Email   +registrationEmailAsUsername.tooltip= ,                    email.+editUsernameAllowed=  +editUsernameAllowed.tooltip= ,     ,       .+resetPasswordAllowed= +resetPasswordAllowed.tooltip=      ,           .+rememberMe= +rememberMe.tooltip=    ,              .+loginWithEmailAllowed=  email+loginWithEmailAllowed.tooltip=     email.+duplicateEmailsAllowed= email+duplicateEmailsAllowed.tooltip=        email.       .     email           email.","because it database term, may be we should not translate this word? Or translate it as """"? I propose next variant ""    email         email  .""",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/3565,107416768,2017-03-22T13:48:00Z,themes/src/main/resources/theme/base/admin/resources/partials/client-detail.html,"@@ -37,7 +37,7 @@                 </div>                 <kc-tooltip>{{:: 'client.enabled.tooltip' | translate}}</kc-tooltip>             </div>-            <div class=""form-group clearfix block"">+            <div class=""form-group clearfix block"" data-ng-show=""protocol != 'docker-v2'"">                 <label class=""col-md-2 control-label"" for=""consentRequired"">{{:: 'consent-required' | translate}}</label>                 <div class=""col-sm-6"">                     <input ng-model=""clientEdit.consentRequired"" name=""consentRequired"" id=""consentRequired"" onoffswitch on-text=""{{:: 'onText' | translate}}"" off-text=""{{:: 'offText' | translate}}""/>",Is there a way to sort Client Protocol list for #protocol select input in such a way that *docker-v2* is the last one in the list - it makes more sense for it to be the last choice as it's reasonable to expect that it will be the least used option?,
464659,jimmidyson,https://api.github.com/repos/keycloak/keycloak/pulls/3911,108070613,2017-03-26T20:36:53Z,services/src/main/java/org/keycloak/social/openshift/OpenshifV3IdentityProviderConfig.java,"@@ -0,0 +1,27 @@+package org.keycloak.social.openshift;++import org.keycloak.broker.oidc.OAuth2IdentityProviderConfig;+import org.keycloak.models.IdentityProviderModel;++public class OpenshifV3IdentityProviderConfig extends OAuth2IdentityProviderConfig {","nit: just noticed typo in class name, missing `t` at end of openshift",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/3972,108212025,2017-03-27T16:12:21Z,services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java,"@@ -854,6 +855,9 @@ public void validateUser(UserModel authenticatedUser) {         if (authenticatedUser == null) return;         if (!authenticatedUser.isEnabled()) throw new AuthenticationFlowException(AuthenticationFlowError.USER_DISABLED);         if (realm.isBruteForceProtected()) {+            if (event.getEvent().getType().equals(EventType.RESET_PASSWORD)) {","@stianst hmmm there's no authentication logic required to send a forgot password e-mail, right? So I don't get why this is bad.What would be a good approach?",
2659880,josh-cain,https://api.github.com/repos/keycloak/keycloak/pulls/3565,109043930,2017-03-30T21:36:45Z,themes/src/main/resources/theme/base/admin/resources/partials/client-detail.html,"@@ -37,7 +37,7 @@                 </div>                 <kc-tooltip>{{:: 'client.enabled.tooltip' | translate}}</kc-tooltip>             </div>-            <div class=""form-group clearfix block"">+            <div class=""form-group clearfix block"" data-ng-show=""protocol != 'docker-v2'"">                 <label class=""col-md-2 control-label"" for=""consentRequired"">{{:: 'consent-required' | translate}}</label>                 <div class=""col-sm-6"">                     <input ng-model=""clientEdit.consentRequired"" name=""consentRequired"" id=""consentRequired"" onoffswitch on-text=""{{:: 'onText' | translate}}"" off-text=""{{:: 'offText' | translate}}""/>","So I took a look at this - other than one-off hacking the order (which I don't think we wanna do), this would require a pretty broad change to the data model for the serverInfo's ProviderRepresentation.  Right now angular is just doing a naive sort:`$scope.protocols = Object.keys(serverInfo.providers['login-protocol'].providers).sort();`Could we perhaps create an issue and do that on a follow-up review?  This one's already gotten pretty big, and I'd consider that a more general aesthetic fix.  For instance, there is not a determinitive order in authenticator choices in the dropdown, etc.  I think the angular models could use a widespread application of some kind of salience/display order.",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/3565,109406219,2017-04-03T12:41:03Z,themes/src/main/resources/theme/base/admin/resources/partials/client-detail.html,"@@ -37,7 +37,7 @@                 </div>                 <kc-tooltip>{{:: 'client.enabled.tooltip' | translate}}</kc-tooltip>             </div>-            <div class=""form-group clearfix block"">+            <div class=""form-group clearfix block"" data-ng-show=""protocol != 'docker-v2'"">                 <label class=""col-md-2 control-label"" for=""consentRequired"">{{:: 'consent-required' | translate}}</label>                 <div class=""col-sm-6"">                     <input ng-model=""clientEdit.consentRequired"" name=""consentRequired"" id=""consentRequired"" onoffswitch on-text=""{{:: 'onText' | translate}}"" off-text=""{{:: 'offText' | translate}}""/>","I agree. If docker-v2 feature has to be enabled explicitly, then I think it's acceptable to have it like this for now.Sorting is a problem present in multiple locations. If we wanted sorting control at db query layer that would require to model current unsorted collections as lists rather than sets, which is quite a disruptive upgrade in the model. Simple alphabetic sorting (ascending, descending by some field) at REST endpoint would already get us very far for a general case (performance-wise it would be better to do it at db layer), but here we even have a special case where we want specific entry to be at the end of the list. That would still best be done in REST endpoint rather than on the client. For example a special query parameter with special syntax using something like:```?reorder=authenticationProviders[-docker-v2]```might be used to move *docker-v2* entry to the end of the collection (leading minus signifying 'move to the end'). We could implement that as part of a bigger REST API overhaul which would add facilities like that across the board in a generic way.",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/3565,109406662,2017-04-03T12:43:03Z,services/src/main/java/org/keycloak/protocol/docker/DockerAuthV2Protocol.java,"@@ -0,0 +1,183 @@+package org.keycloak.protocol.docker;++import org.jboss.logging.Logger;+import org.jboss.resteasy.specimpl.ResponseBuilderImpl;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.jose.jws.JWSBuilder;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientSessionModel;+import org.keycloak.models.KeyManager;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ProtocolMapperModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.LoginProtocol;+import org.keycloak.protocol.ProtocolMapper;+import org.keycloak.protocol.docker.mapper.DockerAuthV2AttributeMapper;+import org.keycloak.representations.docker.DockerResponse;+import org.keycloak.representations.docker.DockerResponseToken;+import org.keycloak.services.ErrorResponseException;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;+import javax.ws.rs.core.UriInfo;+import java.text.SimpleDateFormat;+import java.util.Date;+import java.util.Set;++public class DockerAuthV2Protocol implements LoginProtocol {+    protected static final Logger logger = Logger.getLogger(DockerEndpoint.class);++    public static final String LOGIN_PROTOCOL = ""docker-v2"";+    public static final String ACCOUNT_PARAM = ""account"";+    public static final String SERVICE_PARAM = ""service"";+    public static final String SCOPE_PARAM = ""scope"";+    public static final String ISSUER = ""docker.iss""; // don't want to overlap with OIDC notes+    public static final String ISO_8601_DATE_FORMAT = ""yyyy-MM-dd'T'HH:mm:ss'Z'"";++    private KeycloakSession session;+    private RealmModel realm;+    private UriInfo uriInfo;+    private HttpHeaders headers;","No, it's better as it is. I just pointed out what IDEA was telling me. Maybe that part of implementation was still incomplete.",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/3565,109417665,2017-04-03T13:35:37Z,services/src/main/java/org/keycloak/services/DefaultKeycloakSessionFactory.java,"@@ -18,25 +18,13 @@  import org.jboss.logging.Logger; import org.keycloak.Config;+import org.keycloak.common.Profile; import org.keycloak.common.util.MultivaluedHashMap; import org.keycloak.models.KeycloakSession; import org.keycloak.models.KeycloakSessionFactory;-import org.keycloak.provider.EnvironmentDependentProviderFactory;-import org.keycloak.provider.Provider;-import org.keycloak.provider.ProviderEvent;-import org.keycloak.provider.ProviderEventListener;-import org.keycloak.provider.ProviderFactory;-import org.keycloak.provider.ProviderManager;-import org.keycloak.provider.ProviderManagerDeployer;-import org.keycloak.provider.ProviderManagerRegistry;-import org.keycloak.provider.Spi;--import java.util.HashMap;-import java.util.HashSet;-import java.util.LinkedList;-import java.util.List;-import java.util.Map;-import java.util.Set;+import org.keycloak.provider.*;",Imports should not be folded like this. Default IDEA setting is bad.,
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/3565,109442371,2017-04-03T15:09:18Z,services/src/main/java/org/keycloak/protocol/docker/DockerAuthenticator.java,"@@ -0,0 +1,85 @@+package org.keycloak.protocol.docker;++import org.jboss.logging.Logger;+import org.jboss.resteasy.specimpl.ResponseBuilderImpl;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.events.Errors;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.protocol.saml.profile.ecp.authenticator.HttpBasicAuthenticator;+import org.keycloak.representations.docker.DockerAccess;+import org.keycloak.representations.docker.DockerError;+import org.keycloak.representations.docker.DockerErrorResponseToken;+import org.keycloak.services.messages.Messages;+import org.keycloak.theme.Theme;+import org.keycloak.theme.ThemeProvider;++import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;+import java.io.IOException;+import java.util.Collections;+import java.util.Locale;+import java.util.Optional;+import java.util.Properties;++public class DockerAuthenticator extends HttpBasicAuthenticator {++    private static final Logger logger = Logger.getLogger(DockerAuthenticator.class);++    public static final String ID = ""docker-http-basic-authenticator"";++    @Override+    protected void authFailure(final AuthenticationFlowContext context, final RealmModel realm, final UserModel user) {+        invalidUserAction(context, realm, user.getUsername(), context.getSession().getContext().resolveLocale(user));+    }","It seems to me that by resolving locale for error messages for existing user we may give away the information that the attempted user is in fact a valid user. For example, if I try 'bob':'1234' I get back ""Unknown user or invalid password"", but if I try 'jacques':'1234' I may get back something like 'Utilisateur inconnu ou mot de passe invalide'. Now I know jacques is a valid username.Localisation should only take into account passed language value - extra query parameter in auth request, or a cookie - if docker-v2 protocol supports that.But then, won't the result of 'docker login' then be something like:```Error response from daemon: Get https://localhost:5000/v2/: unauthorized: Utilisateur inconnu ou mot de passe invalide.```Why even bother with such a halfway solution? I would keep it simple - just return all messages in english.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/3565,109612913,2017-04-04T09:15:24Z,services/src/main/java/org/keycloak/services/DefaultKeycloakSessionFactory.java,"@@ -229,6 +217,10 @@ private boolean isEnabled(ProviderFactory factory, Config.Scope scope) {         if (factory instanceof EnvironmentDependentProviderFactory) {             return ((EnvironmentDependentProviderFactory) factory).isSupported();         }+        if (factory instanceof FeatureDependentProviderFactory) {+            return Optional.ofNullable(((FeatureDependentProviderFactory) factory).getRequiredFeatures()).orElse(Collections.emptySet())+                    .stream().allMatch(requiredFeature -> Profile.isFeatureEnabled(requiredFeature));+        }",We already have EnvironmentDependentProviderFactory#isSupported which covers this and there is no need to introduce yet another way to do it. It's nice and simple to use and is also flexible beyond just profiles. Look at:https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/authentication/authenticators/browser/ScriptBasedAuthenticatorFactory.java#L155,X
2659880,josh-cain,https://api.github.com/repos/keycloak/keycloak/pulls/3565,109676416,2017-04-04T14:23:33Z,services/src/main/java/org/keycloak/protocol/saml/profile/ecp/authenticator/HttpBasicAuthenticator.java,"@@ -39,8 +39,12 @@ public void authenticate(final AuthenticationFlowContext context) {                 final boolean valid = context.getSession().userCredentialManager().isValid(realm, user, UserCredentialModel.password(password));                  if (valid) {-                    context.getClientSession().setAuthenticatedUser(user);-                    context.success();+                    if (user.isEnabled()) {+                        context.getClientSession().setAuthenticatedUser(user);+                        context.success();+                    } else {+                        userDisabledFailure(context, realm, user);+                    }","OK - so I updated the userDisabledFailure to do what it was doing before in the HttpBasicAuthenticator: letting users in.  Otherwise, the refactoring in place is just to expose various action components to the Docker child class.  Will that fly?",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/3565,109884473,2017-04-05T10:46:48Z,services/src/main/java/org/keycloak/services/DefaultKeycloakSessionFactory.java,"@@ -229,6 +217,10 @@ private boolean isEnabled(ProviderFactory factory, Config.Scope scope) {         if (factory instanceof EnvironmentDependentProviderFactory) {             return ((EnvironmentDependentProviderFactory) factory).isSupported();         }+        if (factory instanceof FeatureDependentProviderFactory) {+            return Optional.ofNullable(((FeatureDependentProviderFactory) factory).getRequiredFeatures()).orElse(Collections.emptySet())+                    .stream().allMatch(requiredFeature -> Profile.isFeatureEnabled(requiredFeature));+        }","Yes. I agree conditional would be a much better name. However, renaming it breaks backwards compatibility so that's not an option and I don't like alternatives so it is what it is ;)",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/4015,110197778,2017-04-06T15:46:24Z,services/src/main/java/org/keycloak/authorization/common/UserModelIdentity.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.authorization.common;++import org.keycloak.authorization.attribute.Attributes;+import org.keycloak.authorization.identity.Identity;+import org.keycloak.models.ClientModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RoleModel;+import org.keycloak.models.UserModel;++import java.util.Collection;+import java.util.Map;++/**+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>+ * @version $Revision: 1 $+ */+public class UserModelIdentity implements Identity {",Can't find where this class is being used. Am I'm missing something ?,
704239,patriot1burke,https://api.github.com/repos/keycloak/keycloak/pulls/4015,110228937,2017-04-06T18:05:10Z,services/src/main/java/org/keycloak/authorization/common/UserModelIdentity.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.authorization.common;++import org.keycloak.authorization.attribute.Attributes;+import org.keycloak.authorization.identity.Identity;+import org.keycloak.models.ClientModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RoleModel;+import org.keycloak.models.UserModel;++import java.util.Collection;+import java.util.Map;++/**+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>+ * @version $Revision: 1 $+ */+public class UserModelIdentity implements Identity {",gonna use that class later,X
2659880,josh-cain,https://api.github.com/repos/keycloak/keycloak/pulls/3565,114176072,2017-05-01T18:49:59Z,server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java,"@@ -371,7 +377,7 @@ public static RealmRepresentation toRepresentation(RealmModel realm, boolean int         rep.setAttributes(attributes);          if (!internal) {-            rep = StripSecretsUtils.strip(rep);+            return StripSecretsUtils.strip(rep);","Certainly.  I've been splitting up PR's that aren't strictly related (I.E. null values for default procotols).  However, I didn't see the harm in finializing the variable for use with Lambdas since the final output wound up being kind of an if/else.  That function seemed to be imperative anyway in that it was modifying the underlying config values on the list.  Anyway, will un-finalize as the lambda portion is being removed.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3557,116415801,2017-05-15T06:08:50Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.2.0.xml,"@@ -0,0 +1,235 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++     <changeSet author=""glavoie@gmail.com"" id=""3.2.0"">+        <createIndex indexName=""IDX_ASSOC_POL_ASSOC_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""ASSOCIATED_POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_ASSOC_POL_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""POLICY_ID"" type=""VARCHAR(36)""/>","This index is unnecessary because there is already an index for primary key on ASSOCIATED_POLICY(**POLICY_ID**, ASSOCIATED_POLICY_ID) from [here](https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/resources/META-INF/jpa-changelog-authz-2.0.0.xml#L162). Please remove.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3557,116416150,2017-05-15T06:12:45Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.2.0.xml,"@@ -0,0 +1,235 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++     <changeSet author=""glavoie@gmail.com"" id=""3.2.0"">+        <createIndex indexName=""IDX_ASSOC_POL_ASSOC_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""ASSOCIATED_POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_ASSOC_POL_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_REALM_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_FLOW_REALM"" tableName=""AUTHENTICATION_FLOW"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_CONFIG_REALM"" tableName=""AUTHENTICATOR_CONFIG"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_REALM"" tableName=""CLIENT"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>","This index is unnecessary because there is already a unique index on CLIENT(**REALM_ID**, NAME) from [here](https://github.com/keycloak/keycloak/blob/989a701e9559cef4f5a6e38fdf30808975a37563/model/jpa/src/main/resources/META-INF/jpa-changelog-1.0.0.Final.xml#L402). Please remove.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3557,116416703,2017-05-15T06:17:56Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.2.0.xml,"@@ -0,0 +1,235 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++     <changeSet author=""glavoie@gmail.com"" id=""3.2.0"">+        <createIndex indexName=""IDX_ASSOC_POL_ASSOC_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""ASSOCIATED_POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_ASSOC_POL_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_REALM_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_FLOW_REALM"" tableName=""AUTHENTICATION_FLOW"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_CONFIG_REALM"" tableName=""AUTHENTICATOR_CONFIG"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_REALM"" tableName=""CLIENT"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_CLIENT_TEMPL_ID"" tableName=""CLIENT"">+            <column name=""CLIENT_TEMPLATE_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_ATTR_CLIENT"" tableName=""CLIENT_ATTRIBUTES"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>","This index is unnecessary because there is already an index for primary key on CLIENT_ATTRIBUTES(**CLIENT_ID**, NAME) from [here](https://github.com/keycloak/keycloak/blob/1aeec2a83c6677cd7dcfccb6ba2c39d10143b920/model/jpa/src/main/resources/META-INF/jpa-changelog-1.1.0.Beta1.xml#L68). Please remove.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3557,116416854,2017-05-15T06:19:22Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.2.0.xml,"@@ -0,0 +1,235 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++     <changeSet author=""glavoie@gmail.com"" id=""3.2.0"">+        <createIndex indexName=""IDX_ASSOC_POL_ASSOC_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""ASSOCIATED_POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_ASSOC_POL_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_REALM_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_FLOW_REALM"" tableName=""AUTHENTICATION_FLOW"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_CONFIG_REALM"" tableName=""AUTHENTICATOR_CONFIG"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_REALM"" tableName=""CLIENT"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_CLIENT_TEMPL_ID"" tableName=""CLIENT"">+            <column name=""CLIENT_TEMPLATE_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_ATTR_CLIENT"" tableName=""CLIENT_ATTRIBUTES"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_DEF_ROLES_CLIENT"" tableName=""CLIENT_DEFAULT_ROLES"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLI_ID_PRV_MAP_ID_PRV"" tableName=""CLIENT_IDENTITY_PROV_MAPPING"">+            <column name=""IDENTITY_PROVIDER_ID"" type=""VARCHAR(36)""/>+        </createIndex>","This index is unnecessary because there is already a unique index on CLIENT_IDENTITY_PROV_MAPPING(**IDENTITY_PROVIDER_ID**, CLIENT_ID) from [here](https://github.com/keycloak/keycloak/blob/989a701e9559cef4f5a6e38fdf30808975a37563/model/jpa/src/main/resources/META-INF/jpa-changelog-1.2.0.Beta1.xml#L155). Please remove.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3557,116416969,2017-05-15T06:20:39Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.2.0.xml,"@@ -0,0 +1,235 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++     <changeSet author=""glavoie@gmail.com"" id=""3.2.0"">+        <createIndex indexName=""IDX_ASSOC_POL_ASSOC_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""ASSOCIATED_POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_ASSOC_POL_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_REALM_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_FLOW_REALM"" tableName=""AUTHENTICATION_FLOW"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_CONFIG_REALM"" tableName=""AUTHENTICATOR_CONFIG"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_REALM"" tableName=""CLIENT"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_CLIENT_TEMPL_ID"" tableName=""CLIENT"">+            <column name=""CLIENT_TEMPLATE_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_ATTR_CLIENT"" tableName=""CLIENT_ATTRIBUTES"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_DEF_ROLES_CLIENT"" tableName=""CLIENT_DEFAULT_ROLES"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLI_ID_PRV_MAP_ID_PRV"" tableName=""CLIENT_IDENTITY_PROV_MAPPING"">+            <column name=""IDENTITY_PROVIDER_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_ID_PROV_MAP_CLIENT"" tableName=""CLIENT_IDENTITY_PROV_MAPPING"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_NODE_REG_CLIENT"" tableName=""CLIENT_NODE_REGISTRATIONS"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>","This index is unnecessary because there is already an index for primary key on CLIENT_NODE_REGISTRATIONS(**CLIENT_ID**, NAME) from [here](https://github.com/keycloak/keycloak/blob/1aeec2a83c6677cd7dcfccb6ba2c39d10143b920/model/jpa/src/main/resources/META-INF/jpa-changelog-1.1.0.Beta1.xml#L70). Please remove.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3557,116417146,2017-05-15T06:22:27Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.2.0.xml,"@@ -0,0 +1,235 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++     <changeSet author=""glavoie@gmail.com"" id=""3.2.0"">+        <createIndex indexName=""IDX_ASSOC_POL_ASSOC_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""ASSOCIATED_POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_ASSOC_POL_POL_ID"" tableName=""ASSOCIATED_POLICY"">+            <column name=""POLICY_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_REALM_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_EXEC_FLOW"" tableName=""AUTHENTICATION_EXECUTION"">+            <column name=""FLOW_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_FLOW_REALM"" tableName=""AUTHENTICATION_FLOW"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_AUTH_CONFIG_REALM"" tableName=""AUTHENTICATOR_CONFIG"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_REALM"" tableName=""CLIENT"">+            <column name=""REALM_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_CLIENT_TEMPL_ID"" tableName=""CLIENT"">+            <column name=""CLIENT_TEMPLATE_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_ATTR_CLIENT"" tableName=""CLIENT_ATTRIBUTES"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_DEF_ROLES_CLIENT"" tableName=""CLIENT_DEFAULT_ROLES"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLI_ID_PRV_MAP_ID_PRV"" tableName=""CLIENT_IDENTITY_PROV_MAPPING"">+            <column name=""IDENTITY_PROVIDER_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_ID_PROV_MAP_CLIENT"" tableName=""CLIENT_IDENTITY_PROV_MAPPING"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_NODE_REG_CLIENT"" tableName=""CLIENT_NODE_REGISTRATIONS"">+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLIENT_SESSION_SESSION"" tableName=""CLIENT_SESSION"">+            <column name=""SESSION_ID"" type=""VARCHAR(36)""/>+        </createIndex>+        <createIndex indexName=""IDX_CLI_SES_AUT_STAT_CLI_SES"" tableName=""CLIENT_SESSION_AUTH_STATUS"">+            <column name=""CLIENT_SESSION"" type=""VARCHAR(36)""/>","This index is unnecessary because there is already an index for primary key on CLIENT_SESSION_AUTH_STATUS(**CLIENT_SESSION**, AUTHENTICATOR) from [here](https://github.com/keycloak/keycloak/blob/1aeec2a83c6677cd7dcfccb6ba2c39d10143b920/model/jpa/src/main/resources/META-INF/jpa-changelog-1.3.0.xml#L182). Please remove.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3561,117008235,2017-05-17T13:59:03Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1777,55 +1763,34 @@ public void removeComponent(ComponentModel component) {         if (c == null) return;         session.users().preRemove(this, component);         removeComponents(component.getId());-        em.createNamedQuery(""deleteComponentConfigByComponent"").setParameter(""component"", c).executeUpdate();-        em.remove(c);+        getEntity().getComponents().remove(c);     }      @Override     public void removeComponents(String parentId) {-        TypedQuery<String> query = em.createNamedQuery(""getComponentIdsByParent"", String.class)-                .setParameter(""realm"", realm)-                .setParameter(""parentId"", parentId);-        List<String> results = query.getResultList();-        if (results.isEmpty()) return;-        for (String id : results) {-            session.users().preRemove(this, getComponent(id));-        }-        em.createNamedQuery(""deleteComponentConfigByParent"").setParameter(""parentId"", parentId).executeUpdate();-        em.createNamedQuery(""deleteComponentByParent"").setParameter(""parentId"", parentId).executeUpdate();-+        getEntity().getComponents().stream()+                .filter(c -> parentId.equals(c.getParentId()))+                .forEach(c -> session.users().preRemove(this, getComponent(c.getId())));","There is missing part for removal of components where ```parentId == c.getParentId()``` (cf. ```em.createNamedQuery(""deleteComponentByParent"").setParameter(""parentId"", parentId).executeUpdate();```). Maybe I'm missing something, are the components removed elsewhere?",
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/3561,117017189,2017-05-17T14:30:19Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1777,55 +1763,34 @@ public void removeComponent(ComponentModel component) {         if (c == null) return;         session.users().preRemove(this, component);         removeComponents(component.getId());-        em.createNamedQuery(""deleteComponentConfigByComponent"").setParameter(""component"", c).executeUpdate();-        em.remove(c);+        getEntity().getComponents().remove(c);     }      @Override     public void removeComponents(String parentId) {-        TypedQuery<String> query = em.createNamedQuery(""getComponentIdsByParent"", String.class)-                .setParameter(""realm"", realm)-                .setParameter(""parentId"", parentId);-        List<String> results = query.getResultList();-        if (results.isEmpty()) return;-        for (String id : results) {-            session.users().preRemove(this, getComponent(id));-        }-        em.createNamedQuery(""deleteComponentConfigByParent"").setParameter(""parentId"", parentId).executeUpdate();-        em.createNamedQuery(""deleteComponentByParent"").setParameter(""parentId"", parentId).executeUpdate();-+        getEntity().getComponents().stream()+                .filter(c -> parentId.equals(c.getParentId()))+                .forEach(c -> session.users().preRemove(this, getComponent(c.getId())));","That part would be done on line 1766 ( getEntity().getComponents().remove(c) )EDIT: Looks like you are right. ComponentConfig are handled by cascade, but I missed the children components as the mapping is not a FK in ComponentEntity. Can likely attach that directly within the .forEach() call.",
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/3561,117234958,2017-05-18T12:35:42Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1777,55 +1763,34 @@ public void removeComponent(ComponentModel component) {         if (c == null) return;         session.users().preRemove(this, component);         removeComponents(component.getId());-        em.createNamedQuery(""deleteComponentConfigByComponent"").setParameter(""component"", c).executeUpdate();-        em.remove(c);+        getEntity().getComponents().remove(c);     }      @Override     public void removeComponents(String parentId) {-        TypedQuery<String> query = em.createNamedQuery(""getComponentIdsByParent"", String.class)-                .setParameter(""realm"", realm)-                .setParameter(""parentId"", parentId);-        List<String> results = query.getResultList();-        if (results.isEmpty()) return;-        for (String id : results) {-            session.users().preRemove(this, getComponent(id));-        }-        em.createNamedQuery(""deleteComponentConfigByParent"").setParameter(""parentId"", parentId).executeUpdate();-        em.createNamedQuery(""deleteComponentByParent"").setParameter(""parentId"", parentId).executeUpdate();-+        getEntity().getComponents().stream()+                .filter(c -> parentId.equals(c.getParentId()))+                .forEach(c -> session.users().preRemove(this, getComponent(c.getId())));","I thought about this version, but I suspect a ConcurrentModificationException if modifying the collection while it's being read by the stream. I've also thought about that pattern, but I feel that it may become cryptic we try to much to wrap everything around the stream.     @Override    public void removeComponents(String parentId) {        getEntity().getComponents().removeAll(                getEntity().getComponents().stream()                        .filter(c -> Objects.equals(parentId, c.getParentId()))                        .map(c -> {                            session.users().preRemove(this, getComponent(c.getId()));                            return c;                        })                        .collect(Collectors.toList())        );    }",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/3561,117432156,2017-05-19T08:45:07Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1777,55 +1763,34 @@ public void removeComponent(ComponentModel component) {         if (c == null) return;         session.users().preRemove(this, component);         removeComponents(component.getId());-        em.createNamedQuery(""deleteComponentConfigByComponent"").setParameter(""component"", c).executeUpdate();-        em.remove(c);+        getEntity().getComponents().remove(c);     }      @Override     public void removeComponents(String parentId) {-        TypedQuery<String> query = em.createNamedQuery(""getComponentIdsByParent"", String.class)-                .setParameter(""realm"", realm)-                .setParameter(""parentId"", parentId);-        List<String> results = query.getResultList();-        if (results.isEmpty()) return;-        for (String id : results) {-            session.users().preRemove(this, getComponent(id));-        }-        em.createNamedQuery(""deleteComponentConfigByParent"").setParameter(""parentId"", parentId).executeUpdate();-        em.createNamedQuery(""deleteComponentByParent"").setParameter(""parentId"", parentId).executeUpdate();-+        getEntity().getComponents().stream()+                .filter(c -> parentId.equals(c.getParentId()))+                .forEach(c -> session.users().preRemove(this, getComponent(c.getId())));","I think you're right. It seems that there is no straightforward way to do it just with a single stream. What do you think about this pattern which IMHO is both readable and reasonably streamed?```java@Overridepublic void removeComponents(String parentId) {    Predicate<ComponentEntity> sameParent = c -> Objects.equals(parentId, c.getParentId());    getEntity().getComponents().stream()            .filter(sameParent)            .map(this::entityToModel)            .forEach(c -> session.users().preRemove(this, c));    getEntity().getComponents().removeIf(sameParent);}```",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118233995,2017-05-24T12:09:55Z,services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java,"@@ -371,13 +371,12 @@ protected Response handleLoginResponse(String samlResponse, SAMLDocumentHolder h                     assertionElement = DocumentUtil.getElement(holder.getSamlDocument(), new QName(JBossSAMLConstants.ASSERTION.get()));                 } -                if (config.isWantAssertionsSigned() && config.isValidateSignature()) {-                    if (!AssertionUtil.isSignatureValid(assertionElement, getIDPKeyLocator())) {-                        logger.error(""validation failed"");-                        event.event(EventType.IDENTITY_PROVIDER_RESPONSE);-                        event.error(Errors.INVALID_SIGNATURE);-                        return ErrorPage.error(session, Messages.INVALID_REQUESTER);-                    }+                if ((config.isWantAssertionsSigned() && !XMLSignatureUtil.isSigned(assertionElement.getOwnerDocument()))",WantAssertionsSigned requires signed assertions while what is checked for validity in isSigned is the whole document (arbitrary element signature would suffice to satisfy the condition in that method). This has to be fixed to reflect WantAssertionsSigned logic.,
1031478,skjolber,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118258128,2017-05-24T13:53:33Z,saml-core/src/main/java/org/keycloak/saml/processing/core/util/IDFedLSInputResolver.java,"@@ -49,6 +49,7 @@         // XML Schema/DTD         schemaLocationMap.put(""datatypes.dtd"", ""schema/w3c/xmlschema/datatypes.dtd"");         schemaLocationMap.put(""XMLSchema.dtd"", ""schema/w3c/xmlschema/XMLSchema.dtd"");+        schemaLocationMap.put(""http://www.w3.org/2001/XMLSchema.dtd"", ""schema/w3c/xmlschema/XMLSchema.dtd"");        ","The previous PR changed the SPMetadataDescriptor which generates XML. So the unit test ValidationTest was updated to actually schema-validate the generated output. However this did not work right without a few fixes to IDFedLSInputResolver. Constructing a dedicated test for the resolver is quite difficult, since it need to interfere with outgoing http connections. The best way is to just disconnect the internet and see that schema loading still works. Any ideas?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118645432,2017-05-26T07:06:54Z,saml-core/pom.xml,"@@ -54,6 +54,11 @@             <artifactId>xmlsec</artifactId>         </dependency>         <dependency>+            <groupId>org.picketlink</groupId>","Picketlink must not be included as dependency, not even for tests. See below",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118645687,2017-05-26T07:08:57Z,saml-core/src/main/java/org/keycloak/saml/processing/api/saml/v2/sig/SAML2Signature.java,"@@ -210,18 +208,20 @@ public Node getNextSiblingOfIssuer(Document doc) {      *      * @param document SAML document to have its ID attribute configured.      */-    private void configureIdAttribute(Document document) {+    public static void configureIdAttribute(Document document) {         // Estabilish the IDness of the ID attribute.-        document.getDocumentElement().setIdAttribute(ID_ATTRIBUTE_NAME, true);+        configureIdAttribute(document.getDocumentElement());          NodeList nodes = document.getElementsByTagNameNS(JBossSAMLURIConstants.ASSERTION_NSURI.get(),                 JBossSAMLConstants.ASSERTION.get());          for (int i = 0; i < nodes.getLength(); i++) {-            Node n = nodes.item(i);-            if (n instanceof Element) {",This condition has to remain here.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118650779,2017-05-26T07:49:05Z,saml-core/src/main/java/org/keycloak/saml/processing/core/util/IDFedLSInputResolver.java,"@@ -49,6 +49,7 @@         // XML Schema/DTD         schemaLocationMap.put(""datatypes.dtd"", ""schema/w3c/xmlschema/datatypes.dtd"");         schemaLocationMap.put(""XMLSchema.dtd"", ""schema/w3c/xmlschema/XMLSchema.dtd"");+        schemaLocationMap.put(""http://www.w3.org/2001/XMLSchema.dtd"", ""schema/w3c/xmlschema/XMLSchema.dtd"");        ","Even though I understand the need for changes in this class, please remove them from this PR. Feel free to open a new JIRA and have these fixed properly, with proper inclusion of the schemas/dtds (not by including picketlink-wildfly-common).",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118651104,2017-05-26T07:51:23Z,saml-core/src/main/java/org/keycloak/saml/processing/core/saml/v2/util/AssertionUtil.java,"@@ -267,42 +268,54 @@ public static void createSAML11TimedConditions(SAML11AssertionType assertion, lo     }      /**-     * Given an assertion element, validate the signature+     * Given an Assertion element, validate the Signature child element      *      * @param assertionElement      * @param publicKey the {@link PublicKey}      *-     * @return+     * @return true if signature is valid      */     public static boolean isSignatureValid(Element assertionElement, PublicKey publicKey) {","This method works for any element, not just assertion, please rename parameter accordingly.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118651556,2017-05-26T07:54:47Z,saml-core/src/main/java/org/keycloak/saml/processing/core/saml/v2/util/AssertionUtil.java,"@@ -267,42 +268,54 @@ public static void createSAML11TimedConditions(SAML11AssertionType assertion, lo     }      /**-     * Given an assertion element, validate the signature+     * Given an Assertion element, validate the Signature child element      *      * @param assertionElement      * @param publicKey the {@link PublicKey}      *-     * @return+     * @return true if signature is valid      */     public static boolean isSignatureValid(Element assertionElement, PublicKey publicKey) {-        try {-            Document doc = DocumentUtil.createDocument();-            Node n = doc.importNode(assertionElement, true);-            doc.appendChild(n);--            return new SAML2Signature().validate(doc, new HardcodedKeyLocator(publicKey));-        } catch (Exception e) {-            logger.signatureAssertionValidationError(e);-        }-        return false;+        return isSignatureValid(assertionElement, new HardcodedKeyLocator(publicKey));     }      /**-     * Given an assertion element, validate the signature.+     * Given an Assertion element, validate the Signature child element+     *+     * @param assertionElement+     * @param keyLocator the {@link KeyLocator}+     *+     * @return true if signature is present and valid      */+         public static boolean isSignatureValid(Element assertionElement, KeyLocator keyLocator) {         try {-            Document doc = DocumentUtil.createDocument();-            Node n = doc.importNode(assertionElement, true);-            doc.appendChild(n);--            return new SAML2Signature().validate(doc, keyLocator);+            SAML2Signature.configureIdAttribute(assertionElement);+            +            Element signature = getSignature(assertionElement);+            if(signature != null) {+                return XMLSignatureUtil.validateSingleNode(signature, keyLocator);+            }         } catch (Exception e) {             logger.signatureAssertionValidationError(e);         }         return false;     }+    +    /**+     * +     * Check whether an Assertion element contains a Signature child element.+     * +     */ +    public static boolean isSignature(Element assertionElement) {","This method works for any element, not just assertion, please rename parameter accordingly.Furthermore, this method is not about whether the element is a signature but whether it has been signed. Rename to e.g. isSignedElement.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118652563,2017-05-26T08:02:00Z,saml-core/src/main/java/org/keycloak/saml/common/util/DocumentUtil.java,"@@ -554,4 +554,33 @@ private static DocumentBuilderFactory getDocumentBuilderFactory() {          return documentBuilderFactory;     }++    /**+     * Get a (direct) child {@linkplain Element} from the parent {@linkplain Element}. +     *+     * @param parent parent element+     * @param targetNamespace namespace URI+     * @param targetLocalName local name+     * @return a child element matching the target namespace and localname, where {@linkplain Element#getParentNode()} is the parent input parameter+     * @return+     */+    +    public static Element getDirectChildElement(Element parent, String targetNamespace, String targetLocalName) {+        Node child = parent.getFirstChild();+        +        while(child != null) {+            if(child instanceof Element) {+                Element childElement = (Element)child;+                +                String ns = childElement.getNamespaceURI();+                String localName = childElement.getLocalName();+                +                if(targetNamespace.equals(ns) && targetLocalName.equals(localName)) {","Use ```Objects.equals(targetNamespace, ns)``` (dtto for local name) instead to prevent accidental NPE",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,118652715,2017-05-26T08:03:04Z,saml-core/src/main/java/org/keycloak/saml/processing/api/saml/v2/sig/SAML2Signature.java,"@@ -210,18 +208,20 @@ public Node getNextSiblingOfIssuer(Document doc) {      *      * @param document SAML document to have its ID attribute configured.      */-    private void configureIdAttribute(Document document) {+    public static void configureIdAttribute(Document document) {         // Estabilish the IDness of the ID attribute.-        document.getDocumentElement().setIdAttribute(ID_ATTRIBUTE_NAME, true);+        configureIdAttribute(document.getDocumentElement());          NodeList nodes = document.getElementsByTagNameNS(JBossSAMLURIConstants.ASSERTION_NSURI.get(),                 JBossSAMLConstants.ASSERTION.get());          for (int i = 0; i < nodes.getLength(); i++) {-            Node n = nodes.item(i);-            if (n instanceof Element) {-                ((Element) n).setIdAttribute(ID_ATTRIBUTE_NAME, true);-            }+            configureIdAttribute((Element) nodes.item(i));         }     }+    +    public static void configureIdAttribute(Element assertion) {","This method works for any element, not just assertion, please rename parameter accordingly.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,119549960,2017-06-01T08:00:05Z,services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java,"@@ -371,13 +371,12 @@ protected Response handleLoginResponse(String samlResponse, SAMLDocumentHolder h                     assertionElement = DocumentUtil.getElement(holder.getSamlDocument(), new QName(JBossSAMLConstants.ASSERTION.get()));                 } -                if (config.isWantAssertionsSigned() && config.isValidateSignature()) {-                    if (!AssertionUtil.isSignatureValid(assertionElement, getIDPKeyLocator())) {-                        logger.error(""validation failed"");-                        event.event(EventType.IDENTITY_PROVIDER_RESPONSE);-                        event.error(Errors.INVALID_SIGNATURE);-                        return ErrorPage.error(session, Messages.INVALID_REQUESTER);-                    }+                if ((config.isWantAssertionsSigned() && !AssertionUtil.isSignedElement(assertionElement))+                        || (config.isValidateSignature() && !AssertionUtil.isSignatureValid(assertionElement, getIDPKeyLocator()))) {+                    logger.error(""validation failed"");","Would this condition work for SAML documents where only the whole document (not the assertions) is signed?Please create a KcSamlSignedDocumentOnlyBrokerTest based on org.keycloak.testsuite.broker.KcSamlSignedBrokerTest, check https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcSamlSignedBrokerTest.java#L52.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4118,119550290,2017-06-01T08:02:01Z,saml-core/src/main/java/org/keycloak/saml/processing/api/saml/v2/sig/SAML2Signature.java,"@@ -210,18 +208,20 @@ public Node getNextSiblingOfIssuer(Document doc) {      *      * @param document SAML document to have its ID attribute configured.      */-    private void configureIdAttribute(Document document) {+    public static void configureIdAttribute(Document document) {         // Estabilish the IDness of the ID attribute.-        document.getDocumentElement().setIdAttribute(ID_ATTRIBUTE_NAME, true);+        configureIdAttribute(document.getDocumentElement());          NodeList nodes = document.getElementsByTagNameNS(JBossSAMLURIConstants.ASSERTION_NSURI.get(),                 JBossSAMLConstants.ASSERTION.get());          for (int i = 0; i < nodes.getLength(); i++) {-            Node n = nodes.item(i);-            if (n instanceof Element) {","That's true according to the documentation, but in reality it returns an untyped NodeList where by mistake a non-Element node can occur. Better safe than sorry here, please keep the condition.",X
1031478,skjolber,https://api.github.com/repos/keycloak/keycloak/pulls/4118,119573671,2017-06-01T09:56:24Z,saml-core/src/main/java/org/keycloak/saml/processing/api/saml/v2/sig/SAML2Signature.java,"@@ -210,18 +208,20 @@ public Node getNextSiblingOfIssuer(Document doc) {      *      * @param document SAML document to have its ID attribute configured.      */-    private void configureIdAttribute(Document document) {+    public static void configureIdAttribute(Document document) {         // Estabilish the IDness of the ID attribute.-        document.getDocumentElement().setIdAttribute(ID_ATTRIBUTE_NAME, true);+        configureIdAttribute(document.getDocumentElement());          NodeList nodes = document.getElementsByTagNameNS(JBossSAMLURIConstants.ASSERTION_NSURI.get(),                 JBossSAMLConstants.ASSERTION.get());          for (int i = 0; i < nodes.getLength(); i++) {-            Node n = nodes.item(i);-            if (n instanceof Element) {","If the Document implementation is not according to spec, and the cast to Element fails, we then would be aware of and able to fix the bug in the implementation. If we do not trust the implementation to work, why bother calling the method - it might 'not work' in countless ways. The code should be safe, as there is no logical loophole (an exception will always occor). So unless there is a concrete example of an implemenation which triggers an exception in the code, on which the project is dependant and which cannot be fixed, keeping the old code does not make sense.",X
1031478,skjolber,https://api.github.com/repos/keycloak/keycloak/pulls/4201,119850823,2017-06-02T13:03:12Z,services/src/main/java/org/keycloak/broker/saml/mappers/AttributeToRoleMapper.java,"@@ -115,21 +123,32 @@ public void importNewUser(KeycloakSession session, RealmModel realm, UserModel u             user.grantRole(role);         }     }-+         protected boolean isAttributePresent(IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {-        String name = mapperModel.getConfig().get(ATTRIBUTE_NAME);-        if (name != null && name.trim().equals("""")) name = null;-        String friendly = mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME);-        if (friendly != null && friendly.trim().equals("""")) friendly = null;+        String name = emptyToNull(mapperModel.getConfig().get(ATTRIBUTE_NAME));+        String friendly = emptyToNull(mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME));         String desiredValue = mapperModel.getConfig().get(ATTRIBUTE_VALUE);         AssertionType assertion = (AssertionType)context.getContextData().get(SAMLEndpoint.SAML_ASSERTION);         for (AttributeStatementType statement : assertion.getAttributeStatements()) {             for (AttributeStatementType.ASTChoiceType choice : statement.getAttributes()) {                 AttributeType attr = choice.getAttribute();-                if (name != null && !name.equals(attr.getName())) continue;-                if (friendly != null && !name.equals(attr.getFriendlyName())) continue;+                if (name != null) {+                    String attributeName = emptyToNull(attr.getName()); // optional attribute+                    +                    if(attributeName == null || !name.equals(attributeName)) {+                        continue;+                    }+                }+                if (friendly != null) {+                    String attributeFriendlyName = emptyToNull(attr.getFriendlyName()); // optional attribute+                    if(attributeFriendlyName == null || !friendly.equals(attributeFriendlyName)) {+                        continue;+                    }+                }                 for (Object val : attr.getAttributeValue()) {-                    if (val.equals(desiredValue)) return true;+                    if (val != null && val.toString().equals(desiredValue)) {","This solution is suboptimal as the toString() is really a subsistute for specifying the desfiredValue type in the user-interface. However it is problably good enough, I'll add a test.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4201,120051439,2017-06-05T06:54:21Z,services/src/main/java/org/keycloak/broker/saml/mappers/AttributeToRoleMapper.java,"@@ -115,19 +116,38 @@ public void importNewUser(KeycloakSession session, RealmModel realm, UserModel u             user.grantRole(role);         }     }+    +    /**+     * Check whether there is a match between an Attribute name, friendly-name and/or value. +     * The value must be of String type; corresponding to the {@linkplain SAMLParserUtil#parseAttributeValue} xsi-type mapping.+     * +     * @param mapperModel mapping to evaluate+     * @param context context with Assertion+     * @return true if present+     */      protected boolean isAttributePresent(IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {-        String name = mapperModel.getConfig().get(ATTRIBUTE_NAME);-        if (name != null && name.trim().equals("""")) name = null;-        String friendly = mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME);-        if (friendly != null && friendly.trim().equals("""")) friendly = null;+        String name = StringUtil.nullOrEmptyOrWhitespaceToNull(mapperModel.getConfig().get(ATTRIBUTE_NAME));",Please keep the amount of changes minimal and use the org.keycloak.saml.common.util.StringUtil.isNotNull(String) with original conditions instead.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4201,120052520,2017-06-05T07:03:03Z,services/src/main/java/org/keycloak/broker/saml/mappers/AttributeToRoleMapper.java,"@@ -115,19 +116,38 @@ public void importNewUser(KeycloakSession session, RealmModel realm, UserModel u             user.grantRole(role);         }     }+    +    /**+     * Check whether there is a match between an Attribute name, friendly-name and/or value. +     * The value must be of String type; corresponding to the {@linkplain SAMLParserUtil#parseAttributeValue} xsi-type mapping.+     * +     * @param mapperModel mapping to evaluate+     * @param context context with Assertion+     * @return true if present+     */      protected boolean isAttributePresent(IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {-        String name = mapperModel.getConfig().get(ATTRIBUTE_NAME);-        if (name != null && name.trim().equals("""")) name = null;-        String friendly = mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME);-        if (friendly != null && friendly.trim().equals("""")) friendly = null;+        String name = StringUtil.nullOrEmptyOrWhitespaceToNull(mapperModel.getConfig().get(ATTRIBUTE_NAME));+        String friendly = StringUtil.nullOrEmptyOrWhitespaceToNull(mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME));         String desiredValue = mapperModel.getConfig().get(ATTRIBUTE_VALUE);         AssertionType assertion = (AssertionType)context.getContextData().get(SAMLEndpoint.SAML_ASSERTION);         for (AttributeStatementType statement : assertion.getAttributeStatements()) {             for (AttributeStatementType.ASTChoiceType choice : statement.getAttributes()) {                 AttributeType attr = choice.getAttribute();-                if (name != null && !name.equals(attr.getName())) continue;-                if (friendly != null && !name.equals(attr.getFriendlyName())) continue;+                if (name != null) {","Keep the amount of changes minimal. Update the original condition if necessary, use Objects.equals instead of name.equals",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4201,120052523,2017-06-05T07:03:05Z,services/src/main/java/org/keycloak/broker/saml/mappers/AttributeToRoleMapper.java,"@@ -115,19 +116,38 @@ public void importNewUser(KeycloakSession session, RealmModel realm, UserModel u             user.grantRole(role);         }     }+    +    /**+     * Check whether there is a match between an Attribute name, friendly-name and/or value. +     * The value must be of String type; corresponding to the {@linkplain SAMLParserUtil#parseAttributeValue} xsi-type mapping.+     * +     * @param mapperModel mapping to evaluate+     * @param context context with Assertion+     * @return true if present+     */      protected boolean isAttributePresent(IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {-        String name = mapperModel.getConfig().get(ATTRIBUTE_NAME);-        if (name != null && name.trim().equals("""")) name = null;-        String friendly = mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME);-        if (friendly != null && friendly.trim().equals("""")) friendly = null;+        String name = StringUtil.nullOrEmptyOrWhitespaceToNull(mapperModel.getConfig().get(ATTRIBUTE_NAME));+        String friendly = StringUtil.nullOrEmptyOrWhitespaceToNull(mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME));         String desiredValue = mapperModel.getConfig().get(ATTRIBUTE_VALUE);         AssertionType assertion = (AssertionType)context.getContextData().get(SAMLEndpoint.SAML_ASSERTION);         for (AttributeStatementType statement : assertion.getAttributeStatements()) {             for (AttributeStatementType.ASTChoiceType choice : statement.getAttributes()) {                 AttributeType attr = choice.getAttribute();-                if (name != null && !name.equals(attr.getName())) continue;-                if (friendly != null && !name.equals(attr.getFriendlyName())) continue;",Only this condition needs a fix.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4192,120268415,2017-06-06T05:36:48Z,adapters/saml/core/src/main/resources/schema/keycloak_saml_adapter_1_8.xsd,"@@ -100,6 +100,11 @@                     <xs:documentation>The session id is changed by default on a successful login on some platforms to plug a security attack vector. Change this to true to disable this. It is recommended you do not turn it off. Default value is false.</xs:documentation>                 </xs:annotation>         </xs:attribute>+        <xs:attribute name=""autodetectBearerOnly"" type=""xs:boolean"" use=""optional"" default=""false"">","New XSD (version 1.9) is necessary instead of editing a 1.8 version.Before this PR would be accepted, two PRs  accompanying this one into https://github.com/keycloak/keycloak.github.io/tree/master/schema and https://github.com/keycloak/keycloak-documentation/blob/master/securing_apps/topics/saml/java/general-config would be needed to cover documentation of the adapter configuration and exposing the new schema.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4192,120268712,2017-06-06T05:39:30Z,adapters/saml/core/src/main/java/org/keycloak/adapters/saml/profile/AbstractSamlAuthenticationHandler.java,"@@ -693,4 +699,34 @@ private boolean validateRedirectBindingSignatureForKey(SignatureAlgorithm sigAlg          return signature.verify(decodedSignature);     }++    protected boolean isAutodetectedBearerOnly(HttpFacade.Request request) {",All the following conditions have to be covered by tests in https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/AbstractSAMLServletsAdapterTest.java,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4211,120604371,2017-06-07T11:54:29Z,testsuite/integration-arquillian/tests/base/src/test/resources/arquillian.xml,"@@ -74,6 +74,7 @@                 ${auth.server.feature}             </property>             <property name=""javaVmArguments"">+                ${auth.server.jboss.jvm.args}","maybe naming could reflect this parameter is used for debug, e.g. auth.server.jboss.jvm.debug.args ?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4095,123175765,2017-06-21T07:50:32Z,model/jpa/src/main/java/org/keycloak/JPAConstants.java,"@@ -0,0 +1,8 @@+package org.keycloak;++public final class JPAConstants {+    public static final int ORACLE_IN_LIMIT = 1000;",This constant needs to be customizable. Check [`org.keycloak.connections.jpa.DefaultJpaConnectionProviderFactory.config`](https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/connections/jpa/DefaultJpaConnectionProviderFactory.java#L66) field.,X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4095,123185325,2017-06-21T08:36:20Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -446,16 +473,36 @@ public ClientModel getCreatedClient() {      @Override     public List<ClientModel> getClients(RealmModel realm) {-        TypedQuery<String> query = em.createNamedQuery(""getClientIdsByRealm"", String.class);+        TypedQuery<ClientEntity> query = em.createNamedQuery(""getClientsByRealm"", ClientEntity.class);+        Set<ClientEntity> result = null;+        Map<String, Set<RoleModel>> rolesMap = new TreeMap<>();         query.setParameter(""realm"", realm.getId());-        List<String> clients = query.getResultList();-        if (clients.isEmpty()) return Collections.EMPTY_LIST;-        List<ClientModel> list = new LinkedList<>();-        for (String id : clients) {-            ClientModel client = session.realms().getClientById(id, realm);-            if (client != null) list.add(client);++        //Load Roles Model+        for (Tuple t : em.createNamedQuery(""realmScopeMappingIds"", Tuple.class).setParameter(""realm"", realm.getId()).getResultList()) {","Maybe the following is more readable?```javarolesMap = em.createNamedQuery(""realmScopeMappingIds"", Tuple.class)       .setParameter(""realm"", realm.getId())       .getResultList())       .stream()       .collect(t -> Collectors::groupingBy(t.get(0, String.class),                                             Collectors::mapping(t -> t.get(1, String.class), Collectors::toSet())```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4095,123186984,2017-06-21T08:43:27Z,server-spi/src/main/java/org/keycloak/models/RealmProvider.java,"@@ -80,6 +80,8 @@      RoleModel getRoleById(String id, RealmModel realm); +    List<RoleModel> getRolesById( RealmModel realm,String... ids);",Why to use `String...` instead of `List<String>` (or even `Iterable<String>`)?Parameters of two methods with similar function should be ordered consistently (c.f. `getRoleById` above),
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4201,123464676,2017-06-22T09:40:50Z,services/src/main/java/org/keycloak/broker/saml/mappers/AttributeToRoleMapper.java,"@@ -115,19 +117,31 @@ public void importNewUser(KeycloakSession session, RealmModel realm, UserModel u             user.grantRole(role);         }     }+    +    /**+     * Check whether there is a match between an Attribute name, friendly-name and/or value. +     * The value must be of String type; corresponding to the {@linkplain SAMLParserUtil#parseAttributeValue} xsi-type mapping.+     * +     * @param mapperModel mapping to evaluate+     * @param context context with Assertion+     * @return true if present+     */      protected boolean isAttributePresent(IdentityProviderMapperModel mapperModel, BrokeredIdentityContext context) {+        // match against optional Attribute attributes 'name' and 'friendlyName' and values.+        // name/friendly-name filters are inactive if configured as null, empty or whitespace         String name = mapperModel.getConfig().get(ATTRIBUTE_NAME);-        if (name != null && name.trim().equals("""")) name = null;+        if (!StringUtil.isNotNull(name)) name = null;         String friendly = mapperModel.getConfig().get(ATTRIBUTE_FRIENDLY_NAME);-        if (friendly != null && friendly.trim().equals("""")) friendly = null;+        if (!StringUtil.isNotNull(friendly)) friendly = null;         String desiredValue = mapperModel.getConfig().get(ATTRIBUTE_VALUE);         AssertionType assertion = (AssertionType)context.getContextData().get(SAMLEndpoint.SAML_ASSERTION);         for (AttributeStatementType statement : assertion.getAttributeStatements()) {             for (AttributeStatementType.ASTChoiceType choice : statement.getAttributes()) {                 AttributeType attr = choice.getAttribute();-                if (name != null && !name.equals(attr.getName())) continue;-                if (friendly != null && !name.equals(attr.getFriendlyName())) continue;+                if (name != null && !Objects.areEqual(name, attr.getName())) continue;","Keep the amount of changes minimal. Update the original condition if necessary, use Objects.equals instead of areEqual. Use e.g. ```javaif (name != null && ! Objects.equals(name, attr.getName())) continue;```",
2424580,ASzc,https://api.github.com/repos/keycloak/keycloak/pulls/4185,124274348,2017-06-27T13:34:40Z,"distribution/feature-packs/server-feature-pack/src/main/resources/licenses/rh-sso/Select2,Apache Software License 2.0.txt","@@ -0,0 +1 @@+Select2,GNU General Public License v2.0 only.txt","The symbolic link here doesn't reflect any decision on which license Keycloak chooses to use for Select2. That project doesn't offer discrete license texts in its source code, so both license files have identical text, so they get symlinked for deduplication purposes.",
2424580,ASzc,https://api.github.com/repos/keycloak/keycloak/pulls/4185,124285026,2017-06-27T14:12:23Z,"distribution/feature-packs/server-feature-pack/src/main/resources/licenses/rh-sso/Select2,Apache Software License 2.0.txt","@@ -0,0 +1 @@+Select2,GNU General Public License v2.0 only.txt","That's true for the modern versions, but the version in use in 7.1.0 is licensed as ASL v2 or GPL v2. https://github.com/select2/select2/blob/3.4.1/LICENSE",
2424580,ASzc,https://api.github.com/repos/keycloak/keycloak/pulls/4185,124296194,2017-06-27T14:47:07Z,"distribution/feature-packs/server-feature-pack/src/main/resources/licenses/rh-sso/Select2,Apache Software License 2.0.txt","@@ -0,0 +1 @@+Select2,GNU General Public License v2.0 only.txt","The way I would recommend reading the license data is to start with the xml or the html. Then, if additional information is desired for a particular component's license, either use the remote URL or access the local file. The regular filenames make it easy to programmatically find local files when processing the xml data. The symlinks avoid the bloat this regular naming scheme would otherwise cause.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/4233,126661921,2017-07-11T11:28:45Z,services/src/test/java/org/keycloak/test/broker/oidc/AbstractOAuth2IdentityProviderTest.java,"@@ -121,10 +132,54 @@ public void getFederatedIdentity_responseUrlLine() { 		Assert.assertEquals(""458rtf"", fi.getId()); 	} -	private TestProvider getTested() {+	@Test","We require proper functional tests with driving the tests through the actual login pages. Take a look at https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/AbstractBrokerTest.java#L94. It uses Selenium/Webdriver to go to the actual login page, click on the IDP button, fill in the form on the IDP, etc..",
1345317,scranen,https://api.github.com/repos/keycloak/keycloak/pulls/4340,129386108,2017-07-25T18:24:11Z,themes/src/main/resources-community/theme/base/account/messages/messages_nl.properties,"@@ -0,0 +1,133 @@+doSave=Opslaan+doCancel=Annuleer+doLogOutAllSessions=Alle sessies uitloggen+doRemove=Verwijder+doAdd=Voeg toe+doSignOut=Afmelden+editAccountHtmlTitle=Bewerk account+federatedIdentitiesHtmlTitle=Verenigde identiteiten+accountLogHtmlTitle=Account log+changePasswordHtmlTitle=Verander wachtwoord+sessionsHtmlTitle=Sessies+accountManagementTitle=Keycloak Accountbeheer+authenticatorTitle=Authenticator+applicationsHtmlTitle=Toepassingen+authenticatorCode=Eenmalige code+email=Emailadres+firstName=Voornaam+givenName=Voornaam+fullName=Volledige naam+lastName=Achternaam+familyName=Achternaam+password=Wachtwoord+passwordConfirm=Bevestiging+passwordNew=Nieuw Wachtwoord+username=Gebruikersnaam+address=Adres+street=Straat+locality=Stad of plaats+region=Staat, provincie of regio+postal_code=Zip- of postcode+country=Land+emailVerified=Emailadres geverifieerd+gssDelegationCredential=GSS gedelegeerde aanmeldgegevens+role_admin=Beheer+role_realm-admin=Realm Beheer+role_create-realm=Creer realm+role_view-realm=Toon realm+role_view-users=Toon gebruikers+role_view-applications=Toon toepassingen+role_view-clients=Toon clients+role_view-events=Toon gebeurtenissen+role_view-identity-providers=Toon identity providers+role_manage-realm=Beheer realm+role_manage-users=Beheer gebruikers+role_manage-applications=Beheer toepassingen+role_manage-identity-providers=Beheer identity providers+role_manage-clients=Beheer clients+role_manage-events=Beheer gebeurtenissen+role_view-profile=Toon profiel+role_manage-account=Beheer account+role_manage-account-links=Beheer accountkoppelingen+role_read-token=Lees token+role_offline-access=Offline toegang+role_uma_authorization=Verkrijg toestemmingen+client_account=Account+client_security-admin-console=Console Veligheidsbeheer+client_admin-cli=Beheer CLI+client_realm-management=Realm-beheer+client_broker=Broker+requiredFields=Verplichte velden+allFieldsRequired=Alle velden verplicht+backToApplication=&laquo; Terug naar toepassing+backTo=Terug naar {0}+date=Datum+event=Gebeurtenis+ip=IP+client=Client+clients=Clients+details=Details+started=Gestart+lastAccess=Laatste toegang+expires=Vervalt+applications=Toepassingen+account=Account+federatedIdentity=Verenigde identiteit+authenticator=Authenticator+sessions=Sessies+log=Log+application=Toepassing+availablePermissions=Beschikbare machtigingen+grantedPermissions=Gegunde rechten+grantedPersonalInfo=Gegunde Persoonsgegevens+additionalGrants=Extra gunningen+action=Actie+inResource=in+fullAccess=Volledige toegang+offlineToken=Offline Token+revoke=Toekenning terugtrekken+configureAuthenticators=Ingestelde authenticators+mobile=Mobiel nummer+totpStep1=Installeer <a href=""https://freeotp.github.io/"" target=""_blank"">FreeOTP</a> of Google Authenticator op uw apparaat. Beide toepassingen zijn beschikbaar in <a href=""https://play.google.com"">Google Play</a> en de Apple App Store.+totpStep2=Open de toepassing en scan de QR-code of voer de sleutel in.+totpStep3=Voer de door de toepassing gegeven eenmalige code in en klik op Opslaan om de configuratie af te ronden.+missingUsernameMessage=Geef gebruikersnaam alstublieft.+missingFirstNameMessage=Geef voornaam alstublieft.+invalidEmailMessage=Ongeldig emailadres.+missingLastNameMessage=Geef achternaam alstublieft.+missingEmailMessage=Specificeer email alstublieft.+missingPasswordMessage=Geef wachtwoord alstublieft.+notMatchPasswordMessage=Wachtwoorden komen niet overeen.+missingTotpMessage=Geef authenticatiecode alstublieft.+invalidPasswordExistingMessage=Ongeldig bestaand wachtwoord.+invalidPasswordConfirmMessage=Wachtwoordbevestiging komt niet overeen.+invalidTotpMessage=Ongeldige authenticatiecode.+emailExistsMessage=Emailadres bestaat reeds.+readOnlyUserMessage=U kunt uw account niet updaten aangezien het account alleen-lezen is.+readOnlyPasswordMessage=U kunt uw wachtwoord niet veranderen omdat uw account alleen-lezen is.+successTotpMessage=Mobiele authenticator geconfigureerd.+successTotpRemovedMessage=Mobiele authenticator verwijderd.+successGrantRevokedMessage=Gunning succesvol ingetrokken+accountUpdatedMessage=Uw account is gewijzigd.+accountPasswordUpdatedMessage=Uw wachtwoord is veranderd.+missingIdentityProviderMessage=Geen identity provider aangegeven.+invalidFederatedIdentityActionMessage=Ongeldige of ontbrekende actie op verenigde identiteit.+identityProviderNotFoundMessage=Gespecificeerde identity provider niet gevonden.+federatedIdentityLinkNotActiveMessage=Deze verenigde identiteit is niet langer geldig.+federatedIdentityRemovingLastProviderMessage=U kunt de laatste verenigde identiteit niet verwijderen aangezien u het wachtwoord niet heeft.","This message should be about removing providers, not identities. Looking at the code where this message is used, I think it should probably say something like ""U kunt de laatste provider niet verwijderen, omdat u dan niet langer zou kunnen authenticeren."" (You cannot remove the last provider, because you would no longer be able to authenticate)",
1345317,scranen,https://api.github.com/repos/keycloak/keycloak/pulls/4340,129401281,2017-07-25T19:24:22Z,themes/src/main/resources-community/theme/base/login/messages/messages_nl.properties,"@@ -0,0 +1,224 @@+doLogIn=Inloggen+doRegister=Registeer+doCancel=Annuleer+doSubmit=Verzenden+doYes=Ja+doNo=Nee+doContinue=Doorgaan+doAccept=Accepteren+doDecline=Afwijzen+doForgotPassword=Wachtwoord vergeten?+doClickHere=Klik hier+doImpersonate=Belichamen+kerberosNotConfigured=Kerberos niet geconfigureerd+kerberosNotConfiguredTitle=Kerberos niet geconfigureerd+bypassKerberosDetail=U bent niet ingelogd via Kerberos of uw browser kan geen Kerberos login aan. Klik op 'doorgaan' om via een andere manier in te loggen+kerberosNotSetUp=Kerberos is niet goed geconfigureerd. U kunt niet inloggen.+registerWithTitle=Registeer met {0}+registerWithTitleHtml={0}+loginTitle=Log in naar {0}+loginTitleHtml={0}+impersonateTitle={0} Belichaam gebruiker+impersonateTitleHtml=<strong>{0}</strong> Belichaam gebruiker</strong>+realmChoice=Realm+unknownUser=Onbekende gebruiker+loginTotpTitle=Mobile Authenticator Setup+loginProfileTitle=Update account informatie+loginTimeout=U bent te lang bezig geweest met inloggen. Het loginproces begint overnieuw.+oauthGrantTitle=Verleen Toegang+oauthGrantTitleHtml={0}+errorTitle=Er is een fout opgetreden...+errorTitleHtml=Er is een fout opgetreden...+emailVerifyTitle=Emailadres verificatie+emailForgotTitle=Wachtwoord vergeten?+updatePasswordTitle=Wachtwoord updaten+codeSuccessTitle=Succescode+codeErrorTitle=Foutcode: {0}++termsTitle=Voorwaarden+termsTitleHtml=Voorwaarden+termsText=<p>Gedefinieerde voorwaarden</p>+recaptchaFailed=Ongeldige Recaptcha+recaptchaNotConfigured=Recaptcha is verplicht, maar niet geconfigureerd+consentDenied=Toestemming geweigerd.++noAccount=Nieuwe gebruiker?+username=Gebruikersnaam+usernameOrEmail=Gebruikersnaam of e-mail+firstName=Voornaam+givenName=Voornaam+lastName=Achternaam+familyName=Familienaam+email=E-mailadres+password=Wachtwoord+passwordConfirm=Bevestig wachtwoord+passwordNew=Nieuw wachtwoord+passwordNewConfirm=Bevestiging nieuwe wachtwoord+rememberMe=Ingelogd blijven+authenticatorCode=One-time code+address=Adres+postal_code=Postcode+country=Land+emailVerified=E-mail geverifieerd+gssDelegationCredential=GSS delegatie Credential+loginTotpStep1=Installeer <a href=""https://fedorahosted.org/freeotp/"" target=""_blank"">FreeOTP</a> of Google Authenticator op uw mobiele telefoon. Beide applicaties zijn beschikbaar in de <a href=""https://play.google.com"">Google Play</a> en Apple App Store.+loginTotpStep2=Open de applicatie en scan de barcode of voer de sleutel in+loginTotpStep3=Voer de eenmalige code die door de applicatie is aangeleverd in en klik op 'Verzenden' om de setup te voltooien+loginTotpOneTime=Eenmalige code++oauthGrantRequest=Wilt u deze toegangsrechten verlenen?+inResource=in++emailVerifyInstruction1=Een e-mail met instructies om uw e-mailadres te verifiren is zojuist verzonden.+emailVerifyInstruction2=Heeft u geen verificatiecode ontvangen in uw e-mail?+emailVerifyInstruction3=om opnieuw een e-mail te versturen.++emailLinkIdpTitle=Link {0}+emailLinkIdp1=Er is een e-mail met instructies verzonden om {0} account {1} te koppelen met uw {2} account.+emailLinkIdp2=Heeft u geen verificatiecode ontvangen in uw e-mail?+emailLinkIdp3=om opnieuw een e-mail te versturen.++backToLogin=&laquo; Terug naar Inloggen++emailInstruction=Voer uw gebruikersnaam of e-mailadres in en wij sturen u een e-mailbericht met instructies voor het aanmaken van een nieuw wachtwoord.++copyCodeInstruction=Kopieer deze code en plak deze in uw applicatie:++personalInfo=Persoonlijke informatie:+role_realm-admin=Realm Beheerder+role_create-realm=Realm aanmaken+role_create-client=Client aanmaken+role_view-realm=Bekijk realm+role_view-users=Bekijk gebruikers+role_view-clients=Bekijk clients+role_view-events=Bekijk gebeurtenissen+role_view-identity-providers=Bekijk identity providers+role_manage-realm=Beheer realm+role_manage-users=Gebruikers beheren+role_manage-identity-providers=Beheer identity providers+role_manage-clients=Beheer clients+role_manage-events=Beheer gebeurtenissen+role_view-profile=Profiel bekijken+role_read-token=Lees token+role_offline-access=Offline toegang+client_account=Account+client_security-admin-console=Security Admin Console+client_admin-cli=Admin CLI+client_broker=Broker+invalidUserMessage=Ongeldige gebruikersnaam of wachtwoord.+invalidEmailMessage=Ongeldig e-mailadres.+accountDisabledMessage=Account is uitgeschakeld, neem contact op met beheer.+accountTemporarilyDisabledMessage=Account is tijdelijk uitgeschakeld, neem contact op met beheer of probeer het later opnieuw.+expiredCodeMessage=Login time-out. Gelieve opnieuw in te loggen.++missingFirstNameMessage=Voer uw voornaam in.+missingLastNameMessage=Voer uw achternaam in.+missingEmailMessage=Voer uw e-mailadres in.+missingUsernameMessage=Voer uw gebruikersnaam in.+missingPasswordMessage=Voer uw wachtwoord in.+missingTotpMessage=Voer uw authenticator code in.+notMatchPasswordMessage=Wachtwoorden komen niet overeen.+invalidPasswordExistingMessage=Ongeldig bestaand wachtwoord.+invalidPasswordConfirmMessage=Wachtwoordbevestiging komt niet overeen.+invalidTotpMessage=Ongeldige authenticator code.++usernameExistsMessage=Gebruikersnaam bestaat al.+emailExistsMessage=E-mail bestaat al.++federatedIdentityExistsMessage=Gebruiker met {0} {1} bestaat al. Log in met het beheer-account om het account te koppelen.++confirmLinkIdpTitle=Account bestaat al+federatedIdentityConfirmLinkMessage=Gebruiker met {0} {1} bestaat al. Hoe wilt u doorgaan?+federatedIdentityConfirmReauthenticateMessage=Authenticeer als {0} om uw account te koppelen {1}+confirmLinkIdpReviewProfile=Nalopen profiel+confirmLinkIdpContinue=Voeg toe aan bestaande account++configureTotpMessage=U moet de Mobile Authenticator configuren om uw account te activeren.+updateProfileMessage=U moet uw gebruikersprofiel bijwerken om uw account te activeren.+updatePasswordMessage=U moet uw wachtwoord wijzigen om uw account te activeren.+verifyEmailMessage=U moet uw e-mailadres verifiren om uw account te activeren.+linkIdpMessage=U moet uw e-mailadres verifiren om uw account te koppelen aan {0}.++emailSentMessage=U zult binnenkort een e-mail ontvangen met verdere instructies.+emailSendErrorMessage=Het versturen van de e-mail is mislukt, probeer het later opnieuw.++accountUpdatedMessage=Uw account is bijgewerkt.+accountPasswordUpdatedMessage=Uw wachtwoord is bijgewerkt.++noAccessMessage=Geen toegang++invalidPasswordMinLengthMessage=Ongeldig wachtwoord, de minimumlengte is {0} karakters.+invalidPasswordMinDigitsMessage=Ongeldig wachtwoord, deze moet minstens {0} cijfers bevatten.+invalidPasswordMinLowerCaseCharsMessage=Ongeldig wachtwoord, deze moet minstens {0} kleine letters bevatten.+invalidPasswordMinUpperCaseCharsMessage=Ongeldig wachtwoord, deze moet minstens {0} hoofdletters bevatten.+invalidPasswordMinSpecialCharsMessage=Ongeldig wachtwoord, deze moet minstens {0} speciale tekens bevatten.+invalidPasswordNotUsernameMessage=Ongeldig wachtwoord, deze mag niet gelijk zijn aan de gebruikersnaam.+invalidPasswordRegexPatternMessage=Ongeldig wachtwoord, deze komt niet overeen met opgegeven reguliere expressie(s).+invalidPasswordHistoryMessage=Ongeldig wachtwoord, deze mag niet gelijk zijn aan een van de laatste {0} wachtwoorden.++failedToProcessResponseMessage=Het verwerken van de respons is mislukt+httpsRequiredMessage=HTTPS vereist+realmNotEnabledMessage=Realm niet geactiveerd+invalidRequestMessage=Ongeldige request+failedLogout=Afmelden is mislukt+unknownLoginRequesterMessage=De login requester is onbekend+loginRequesterNotEnabledMessage=De login requester is niet geactiveerd+bearerOnlyMessage=Bearer-only applicaties mogen geen browser login initiren+standardFlowDisabledMessage=Client is mag geen browserlogin starten met het opgegeven response_type. Standard flow is uitgeschakeld voor de client.+implicitFlowDisabledMessage=Client is mag geen browserlogin starten met opgegeven response_type. Implicit flow is uitgeschakeld voor de klant.+invalidRedirectUriMessage=Ongeldige omleiding uri+unsupportedNameIdFormatMessage=Niet-ondersteunde NameIDFormat+invalidRequesterMessage=Ongeldige requester+registrationNotAllowedMessage=Registratie is niet toegestaan+resetCredentialNotAllowedMessage=Het resetten van de aanmeldgegevens is niet toegestaan+permissionNotApprovedMessage=Toestemming niet goedgekeurd.","Not sure what this means. This message also seems to be unused in the code, so no matter.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4370,131118526,2017-08-03T11:38:53Z,pom.xml,"@@ -88,6 +88,7 @@         <version.jboss-integration-platform>6.0.10.Final</version.jboss-integration-platform>          <!-- Others -->+        <commons.collections4.version>4.1</commons.collections4.version>","Apache commons collections 4 are not available in wildfly, this would need a new dependency which is not a trivial task. I think the only reason for including it is using Radix (Patricia) tree.",
3931112,Yaytay,https://api.github.com/repos/keycloak/keycloak/pulls/4386,133042399,2017-08-14T19:40:36Z,services/src/main/java/org/keycloak/protocol/oidc/AccessTokenIntrospectionProvider.java,"@@ -58,13 +61,18 @@ public Response introspect(String token) {                  PublicKey publicKey = session.keys().getRsaPublicKey(realm, verifier.getHeader().getKeyId());                 if (publicKey == null) {+                    logger.debug(""Verification failed: public key not found"");                     valid = false;                 } else {                     verifier.publicKey(publicKey);                     verifier.verify();                     toIntrospect = verifier.getToken();                 }             } catch (VerificationException e) {+                logger.debug(""Verification failed: "" + e.getMessage());","The reason I didn't was to avoid a massive stack trace that slf4j would produce, the message from the verification exception message concisely contains what I think is needed.Happy to change it if you think the stack trace is useful.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/4316,133127401,2017-08-15T07:00:26Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/AbstractAdminTest.java,"@@ -71,6 +75,16 @@ public void addTestRealms(List<RealmRepresentation> testRealms) {         config.put(""port"", ""3025"");         adminRealmRep.setSmtpServer(config); +        // add dummy federation provider",Don't add a dummy federation provider here as it affects a large amount of other tests. Use the admin client in the one test you need it in to add it,
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/4095,136161305,2017-08-30T19:03:31Z,authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/user/UserPolicyProviderFactory.java,"@@ -164,31 +163,34 @@ public void postInit(KeycloakSessionFactory factory) {                 UserModel removedUser = ((UserRemovedEvent) event).getUser();                 RealmModel realm = ((UserRemovedEvent) event).getRealm();                 ResourceServerStore resourceServerStore = storeFactory.getResourceServerStore();-                realm.getClients().forEach(clientModel -> {-                    ResourceServer resourceServer = resourceServerStore.findByClient(clientModel.getId()); -                    if (resourceServer != null) {-                        policyStore.findByType(getId(), resourceServer.getId()).forEach(policy -> {-                            List<String> users = new ArrayList<>();--                            for (String userId : getUsers(policy)) {-                                if (!userId.equals(removedUser.getId())) {-                                    users.add(userId);-                                }-                            }--                            try {-                                if (users.isEmpty()) {-                                    policyStore.delete(policy.getId());-                                } else {-                                    policy.getConfig().put(""users"", JsonSerialization.writeValueAsString(users));-                                }-                            } catch (IOException e) {-                                throw new RuntimeException(""Error while synchronizing users with policy ["" + policy.getName() + ""]."", e);","@hmlnarik, at the same time I rebase onto master, I'm looking at the code Alex did and I'm questionning this findByClients() (new method) thing entirely. First of all, he's not going through the storeFactory which will return the ""cached"" item first which will then delegate to the JPA provider if necessary. Pattern seen everywhere else. I'd get rid of that ORACLE_IN_LIMIT constant at the same time...What I'm guessing here (I'm not sure I have his test data anymore) is that the forEach() call that when through the clientModel objects to do resourceServerStore.findByClient() likely triggered multiple implicit flush making this part very slow with a large number of clients (what we were testing). That would be caused by the use of the ""findResourceServerIdByClient"" NamedQuery to find the ResourceServerEntity id, to then find the cached object (or load the entity directly through it's PK)My question here: Since the RESOURCE_SERVER has a unique constraint on CLIENT_ID, why not dropping the ID table and use the CLIENT_ID as the primary key? That would be flagged as the @Id in ResourceServerEntity and efficient Hibernate cache management would now be implicit (no more flush on query).Any reason not to have a FK as the PK for RESOURCE_SERVER? Also, it seems that a FK is missing on that table.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4095,136435627,2017-08-31T20:06:18Z,authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/user/UserPolicyProviderFactory.java,"@@ -164,31 +163,34 @@ public void postInit(KeycloakSessionFactory factory) {                 UserModel removedUser = ((UserRemovedEvent) event).getUser();                 RealmModel realm = ((UserRemovedEvent) event).getRealm();                 ResourceServerStore resourceServerStore = storeFactory.getResourceServerStore();-                realm.getClients().forEach(clientModel -> {-                    ResourceServer resourceServer = resourceServerStore.findByClient(clientModel.getId()); -                    if (resourceServer != null) {-                        policyStore.findByType(getId(), resourceServer.getId()).forEach(policy -> {-                            List<String> users = new ArrayList<>();--                            for (String userId : getUsers(policy)) {-                                if (!userId.equals(removedUser.getId())) {-                                    users.add(userId);-                                }-                            }--                            try {-                                if (users.isEmpty()) {-                                    policyStore.delete(policy.getId());-                                } else {-                                    policy.getConfig().put(""users"", JsonSerialization.writeValueAsString(users));-                                }-                            } catch (IOException e) {-                                throw new RuntimeException(""Error while synchronizing users with policy ["" + policy.getName() + ""]."", e);","@glavoie I'm uncertain why RESOURCE_SERVER is structured in this way, in fact it rather looks like extension of CLIENT table with new attributes (inheritance in a way). @pedroigor is the original author, he might have a deeper insight why there is a separate ID column.Re the missing FK - I understand benefits of ignoring the FK (performance) vs defining it (data consistency). Currently it is used inconsistently across DB, so the FK definition or undefinitions will be part of a bigger database schema cleanup that will need to come in future.",X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/4095,136444487,2017-08-31T20:45:40Z,authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/user/UserPolicyProviderFactory.java,"@@ -164,31 +163,34 @@ public void postInit(KeycloakSessionFactory factory) {                 UserModel removedUser = ((UserRemovedEvent) event).getUser();                 RealmModel realm = ((UserRemovedEvent) event).getRealm();                 ResourceServerStore resourceServerStore = storeFactory.getResourceServerStore();-                realm.getClients().forEach(clientModel -> {-                    ResourceServer resourceServer = resourceServerStore.findByClient(clientModel.getId()); -                    if (resourceServer != null) {-                        policyStore.findByType(getId(), resourceServer.getId()).forEach(policy -> {-                            List<String> users = new ArrayList<>();--                            for (String userId : getUsers(policy)) {-                                if (!userId.equals(removedUser.getId())) {-                                    users.add(userId);-                                }-                            }--                            try {-                                if (users.isEmpty()) {-                                    policyStore.delete(policy.getId());-                                } else {-                                    policy.getConfig().put(""users"", JsonSerialization.writeValueAsString(users));-                                }-                            } catch (IOException e) {-                                throw new RuntimeException(""Error while synchronizing users with policy ["" + policy.getName() + ""]."", e);",@glavoie @hmlnarik I can't remember right now a good reason for not using CLIENT_ID as PK. But change it now may introduce more critical changes (this PR by itself is full of them :)) and risks to existing functionality.Did you try configuring flush mode to COMMIT for that particular query ? It could avoid flushing to database on every single query.,
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/4095,136448245,2017-08-31T21:02:05Z,authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/user/UserPolicyProviderFactory.java,"@@ -164,31 +163,34 @@ public void postInit(KeycloakSessionFactory factory) {                 UserModel removedUser = ((UserRemovedEvent) event).getUser();                 RealmModel realm = ((UserRemovedEvent) event).getRealm();                 ResourceServerStore resourceServerStore = storeFactory.getResourceServerStore();-                realm.getClients().forEach(clientModel -> {-                    ResourceServer resourceServer = resourceServerStore.findByClient(clientModel.getId()); -                    if (resourceServer != null) {-                        policyStore.findByType(getId(), resourceServer.getId()).forEach(policy -> {-                            List<String> users = new ArrayList<>();--                            for (String userId : getUsers(policy)) {-                                if (!userId.equals(removedUser.getId())) {-                                    users.add(userId);-                                }-                            }--                            try {-                                if (users.isEmpty()) {-                                    policyStore.delete(policy.getId());-                                } else {-                                    policy.getConfig().put(""users"", JsonSerialization.writeValueAsString(users));-                                }-                            } catch (IOException e) {-                                throw new RuntimeException(""Error while synchronizing users with policy ["" + policy.getName() + ""]."", e);","@pedroigor, @hmlnarik: The change I want to submit has nothing to do with what is done in this PR (now closed/not merged). It's mostly removal of getByClient() to switch all calls to getId with the same call value and re-wire the id field on ResourceServerEntity to the CLIENT_ID column. The other part of the fix is to migrate the data in the database to use the client_id instead of the other PK.I was able to test/make the change in about 10 minutes, but I need to clean things up + create a Liquibase changset for the data migration. Planning on doing that tomorrow morning.I stopped thinking about changing the flush mode a long time ago in Keycloak, when working on performance. Most of the improvements I found in the past were easier to do by working a bit the JPA model. There are just too many locations where it would be necessary to do it and in my opinion, developers would just not think about it when working on new code areas where it could be necessary to do it. You also never know when a transaction could modify data that would need to be seen in a NamedQuery result right away, before commit.",X
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/4095,136647949,2017-09-01T19:19:45Z,authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/user/UserPolicyProviderFactory.java,"@@ -164,31 +163,34 @@ public void postInit(KeycloakSessionFactory factory) {                 UserModel removedUser = ((UserRemovedEvent) event).getUser();                 RealmModel realm = ((UserRemovedEvent) event).getRealm();                 ResourceServerStore resourceServerStore = storeFactory.getResourceServerStore();-                realm.getClients().forEach(clientModel -> {-                    ResourceServer resourceServer = resourceServerStore.findByClient(clientModel.getId()); -                    if (resourceServer != null) {-                        policyStore.findByType(getId(), resourceServer.getId()).forEach(policy -> {-                            List<String> users = new ArrayList<>();--                            for (String userId : getUsers(policy)) {-                                if (!userId.equals(removedUser.getId())) {-                                    users.add(userId);-                                }-                            }--                            try {-                                if (users.isEmpty()) {-                                    policyStore.delete(policy.getId());-                                } else {-                                    policy.getConfig().put(""users"", JsonSerialization.writeValueAsString(users));-                                }-                            } catch (IOException e) {-                                throw new RuntimeException(""Error while synchronizing users with policy ["" + policy.getName() + ""]."", e);","@pedroigor, we are in sync, I just pushed https://github.com/glavoie/keycloak/tree/KEYCLOAK-4858-ResourceServer with the new change I'd like to suggest for the ResourceServer. I'm currently running the tests suite locally.Don't be scared by the large amount of file modified, it's mostly to remove the get/setClientId and use get/setId() instead. There's also a Liquibase changeset to propagate the CLIENT_ID to all children tables of RESOURCE_SERVER and re-wire the PK/FKs. I still need to take some time to double check a few performance scenarios to make sure everything is covered.If you are OK with that single change, I'd open a PR with just this one. Any other change would be different PRs to keep it simple for tracking/merging.",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/4451,137500902,2017-09-07T10:19:43Z,model/jpa/src/main/resources/META-INF/jpa-changelog-authz-3.4.0.CR1.xml,"@@ -0,0 +1,93 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2017 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd"">+    <changeSet author=""psilva@redhat.com"" id=""authz-3.4.0.CR1-resource-server-pk-change"">+        <!-- Data migration to change the PK of RESOURCE_SERVER to use the CLIENT_ID. -->+        <addColumn tableName=""RESOURCE_SERVER_POLICY"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>+        <addColumn tableName=""RESOURCE_SERVER_RESOURCE"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>+        <addColumn tableName=""RESOURCE_SERVER_SCOPE"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>++        <sql>+            UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);",This SQL doesn't work on MSSQL:ERROR [org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider] (ServerService Thread Pool -- 55) Change Set META-INF/jpa-changelog-authz-3.4.0.CR1.xml::authz-3.4.0.CR1-resource-server-pk-change::psilva@redhat.com failed.  Error: Incorrect syntax near 'p'. [Failed SQL: UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID)]: liquibase.exception.DatabaseException: Incorrect syntax near 'p'. [Failed SQL: UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID)],
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4451,137510702,2017-09-07T11:14:29Z,model/jpa/src/main/resources/META-INF/jpa-changelog-authz-3.4.0.CR1.xml,"@@ -0,0 +1,93 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2017 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd"">+    <changeSet author=""psilva@redhat.com"" id=""authz-3.4.0.CR1-resource-server-pk-change"">+        <!-- Data migration to change the PK of RESOURCE_SERVER to use the CLIENT_ID. -->+        <addColumn tableName=""RESOURCE_SERVER_POLICY"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>+        <addColumn tableName=""RESOURCE_SERVER_RESOURCE"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>+        <addColumn tableName=""RESOURCE_SERVER_SCOPE"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>++        <sql>+            UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);","You might need to split the current changeset into three, extracting the <sql> part one into a separate one, and making variants of that changeset via <precondition> on <dbms> similarly to what is already used for db2 in https://github.com/hmlnarik/keycloak/blob/master/model/jpa/src/main/resources/META-INF/jpa-changelog-1.8.0.xml#L21-L25",X
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/4451,137544479,2017-09-07T13:53:27Z,model/jpa/src/main/resources/META-INF/jpa-changelog-authz-3.4.0.CR1.xml,"@@ -0,0 +1,93 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2017 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd"">+    <changeSet author=""psilva@redhat.com"" id=""authz-3.4.0.CR1-resource-server-pk-change"">+        <!-- Data migration to change the PK of RESOURCE_SERVER to use the CLIENT_ID. -->+        <addColumn tableName=""RESOURCE_SERVER_POLICY"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>+        <addColumn tableName=""RESOURCE_SERVER_RESOURCE"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>+        <addColumn tableName=""RESOURCE_SERVER_SCOPE"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>++        <sql>+            UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);","@hmlnarik, if I am to create an exception for a specific DBMS, do you want a separate changelog file for that dbms or two separate changesets in the same file?",
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/4451,137567338,2017-09-07T15:10:27Z,model/jpa/src/main/resources/META-INF/jpa-changelog-authz-3.4.0.CR1.xml,"@@ -0,0 +1,93 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2017 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd"">+    <changeSet author=""psilva@redhat.com"" id=""authz-3.4.0.CR1-resource-server-pk-change"">+        <!-- Data migration to change the PK of RESOURCE_SERVER to use the CLIENT_ID. -->+        <addColumn tableName=""RESOURCE_SERVER_POLICY"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>+        <addColumn tableName=""RESOURCE_SERVER_RESOURCE"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>+        <addColumn tableName=""RESOURCE_SERVER_SCOPE"">+            <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>+        </addColumn>++        <sql>+            UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);","@hmlnarik, will do this then. I've confirmed that 2 changesets will be required. My DBA helped me with tests on multiple DBMS and we can't find a portable solution. For now the exception would be ""Oracle"", but I would need your help to see what DB2 accepts. Will likely update the PR next Monday. ",
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/4451,137627350,2017-09-07T18:56:49Z,model/jpa/src/main/resources/META-INF/jpa-changelog-authz-3.4.0.CR1.xml,"@@ -28,13 +28,32 @@         <addColumn tableName=""RESOURCE_SERVER_SCOPE"">             <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>         </addColumn>+    </changeSet> +    <changeSet author=""glavoie@gmail.com"" id=""authz-3.4.0.CR1-resource-server-pk-change-part2"">+        <preConditions onSqlOutput=""TEST"" onFail=""MARK_RAN"">+            <not>+                <dbms type=""mssql"" />+            </not>+        </preConditions>         <sql>-            UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);-            UPDATE RESOURCE_SERVER_RESOURCE p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);-            UPDATE RESOURCE_SERVER_SCOPE p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);+            UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID = (SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);+            UPDATE RESOURCE_SERVER_RESOURCE p SET RESOURCE_SERVER_CLIENT_ID = (SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);+            UPDATE RESOURCE_SERVER_SCOPE p SET RESOURCE_SERVER_CLIENT_ID = (SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);         </sql>+    </changeSet>+    <changeSet author=""glavoie@gmail.com"" id=""authz-3.4.0.CR1-resource-server-pk-change-part2-mssql"">+        <preConditions onSqlOutput=""TEST"" onFail=""MARK_RAN"">+            <dbms type=""mssql"" />","@hmlnarik, after some testing, my DBA told me the Oracle syntax works on both PostgreSQL and MySQL, but the MSSQL syntax only on PostgreSQL. I did the exception for MSSQL. DB2 remains to be tested.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/4451,138036795,2017-09-11T10:47:11Z,model/jpa/src/main/resources/META-INF/jpa-changelog-authz-3.4.0.CR1.xml,"@@ -28,13 +28,32 @@         <addColumn tableName=""RESOURCE_SERVER_SCOPE"">             <column name=""RESOURCE_SERVER_CLIENT_ID"" type=""VARCHAR(36)""/>         </addColumn>+    </changeSet> +    <changeSet author=""glavoie@gmail.com"" id=""authz-3.4.0.CR1-resource-server-pk-change-part2"">+        <preConditions onSqlOutput=""TEST"" onFail=""MARK_RAN"">+            <not>+                <dbms type=""mssql"" />+            </not>+        </preConditions>         <sql>-            UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);-            UPDATE RESOURCE_SERVER_RESOURCE p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);-            UPDATE RESOURCE_SERVER_SCOPE p SET RESOURCE_SERVER_CLIENT_ID=(SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);+            UPDATE RESOURCE_SERVER_POLICY p SET RESOURCE_SERVER_CLIENT_ID = (SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);+            UPDATE RESOURCE_SERVER_RESOURCE p SET RESOURCE_SERVER_CLIENT_ID = (SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);+            UPDATE RESOURCE_SERVER_SCOPE p SET RESOURCE_SERVER_CLIENT_ID = (SELECT CLIENT_ID FROM RESOURCE_SERVER s WHERE s.ID = p.RESOURCE_SERVER_ID);         </sql>+    </changeSet>+    <changeSet author=""glavoie@gmail.com"" id=""authz-3.4.0.CR1-resource-server-pk-change-part2-mssql"">+        <preConditions onSqlOutput=""TEST"" onFail=""MARK_RAN"">+            <dbms type=""mssql"" />","There is DB2 result: ERROR [org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider] (ServerService Thread Pool -- 50) Change Set META-INF/jpa-changelog-authz-3.4.0.CR1.xml::authz-3.4.0.CR1-resource-server-pk-change-part3::glavoie@gmail.com failed.  Error: DB2 SQL Error: SQLCODE=-478, SQLSTATE=42893, SQLERRMC=COLUMN;PK_RESOURCE_SERVER;PRIMARY KEY, DRIVER=4.19.26 [Failed SQL: ALTER TABLE DBALLO14.RESOURCE_SERVER RENAME COLUMN CLIENT_ID TO ID]: liquibase.exception.DatabaseException: DB2 SQL Error: SQLCODE=-478, SQLSTATE=42893, SQLERRMC=COLUMN;PK_RESOURCE_SERVER;PRIMARY KEY, DRIVER=4.19.26 [Failed SQL: ALTER TABLE DBALLO14.RESOURCE_SERVER RENAME COLUMN CLIENT_ID TO ID]",
704239,patriot1burke,https://api.github.com/repos/keycloak/keycloak/pulls/4464,138186254,2017-09-11T20:45:14Z,distribution/server-dist/assembly.xml,"@@ -33,13 +33,28 @@             <includes>                 <include>**/module.xml</include>             </includes>+            <!-- unused resteasy providers eat up memory -->+            <excludes>",does changing an EAP module.xml file have similar patching issues?,X
704239,patriot1burke,https://api.github.com/repos/keycloak/keycloak/pulls/4464,138186852,2017-09-11T20:47:36Z,distribution/server-dist/assembly.xml,"@@ -33,13 +33,28 @@             <includes>                 <include>**/module.xml</include>             </includes>+            <!-- unused resteasy providers eat up memory -->+            <excludes>","Nevermind, jaxrs subsystem automatically includes those modules if they exist.  I thought they might be included via a module dependency.BTW, would be really curious to know if anybody actually uses our RPM or OpenShift images.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4461,138543300,2017-09-13T07:31:35Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.2.0.xml,"@@ -29,7 +29,11 @@             <changeSetExecuted id=""3.2.0"" author=""keycloak"" changeLogFile=""META-INF/jpa-changelog-3.2.0.xml""/>         </preConditions>","Id of this changeset (line 27) has to be changed to e.g. `3.2.0-fix-with-keycloak-5416`, and the following precondition needs to be added into `<preConditions>` tag:```xml<not>    <changeSetExecuted id=""3.2.0-fix"" author=""keycloak"" changeLogFile=""META-INF/jpa-changelog-3.2.0.xml""/></not>``` ",
335133,sebastienblanc,https://api.github.com/repos/keycloak/keycloak/pulls/4346,138557336,2017-09-13T08:39:35Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/config/KeycloakWebSecurityConfigurerAdapter.java,"@@ -117,6 +123,7 @@ protected void configure(HttpSecurity http) throws Exception {                 .and()                 .addFilterBefore(keycloakPreAuthActionsFilter(), LogoutFilter.class)                 .addFilterBefore(keycloakAuthenticationProcessingFilter(), BasicAuthenticationFilter.class)+                .addFilterBefore(keycloakAuthenticatedActionsFilter(), BasicAuthenticationFilter.class)","I wonder if we should not add a subclass of `KeycloakWebSecurityConfigurerAdapter` , like `SpringBootKeycloakWebSecurityConfigurerAdapter` that would just contain : ```     @Bean    public FilterRegistrationBean keycloakAuthenticationProcessingFilterRegistrationBean(            KeycloakAuthenticationProcessingFilter filter) {        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);        registrationBean.setEnabled(false);        return registrationBean;    }    @Bean    public FilterRegistrationBean keycloakPreAuthActionsFilterRegistrationBean(            KeycloakPreAuthActionsFilter filter) {        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);        registrationBean.setEnabled(false);        return registrationBean;    }   @Bean    public FilterRegistrationBean keycloakAuthenticatedActionsFilterRegistrationBean(            KeycloakAuthenticatedActionsFilter filter) {        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);        registrationBean.setEnabled(false);        return registrationBean;    }```",
3833769,sschu,https://api.github.com/repos/keycloak/keycloak/pulls/4471,138636989,2017-09-13T14:30:35Z,services/src/main/java/org/keycloak/authorization/admin/representation/PolicyEvaluationResponseBuilder.java,"@@ -55,6 +56,12 @@ public static PolicyEvaluationResponse build(List<Result> results, ResourceServe         authorizationData.setPermissions(Permissions.permits(results, null, authorization, resourceServer));         accessToken.setAuthorization(authorizationData); +        ClientModel clientModel = authorization.getRealm().getClientById(resourceServer.getId());++        if (!accessToken.hasAudience(clientModel.getClientId())) {+            accessToken.audience(clientModel.getClientId());+        }","The implementation suggests otherwise as aud is a string array and audience() is variadic, see JsonWebToken.java:@JsonProperty(""aud"")@JsonSerialize(using = StringOrArraySerializer.class)@JsonDeserialize(using = StringOrArrayDeserializer.class)protected String[] audience;public JsonWebToken audience(String... audience) {        this.audience = audience;        return this;    }public boolean hasAudience(String audience) {        if (this.audience == null) return false;        for (String a : this.audience) {            if (a.equals(audience)) {                return true;            }        }        return false;    }Even if it is always a one-element array currently, I am concerned it will come up as a bug if multiple audiences get supported. ",
335133,sebastienblanc,https://api.github.com/repos/keycloak/keycloak/pulls/4346,138825052,2017-09-14T08:15:29Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/config/KeycloakWebSecurityConfigurerAdapter.java,"@@ -117,6 +123,7 @@ protected void configure(HttpSecurity http) throws Exception {                 .and()                 .addFilterBefore(keycloakPreAuthActionsFilter(), LogoutFilter.class)                 .addFilterBefore(keycloakAuthenticationProcessingFilter(), BasicAuthenticationFilter.class)+                .addFilterBefore(keycloakAuthenticatedActionsFilter(), BasicAuthenticationFilter.class)","I found another issue : if we don't provide any bearer token, the response is still correct but under the hood we are getting a class cast exception because the `AnonymousAuthenticationFilter` returns a `AnonymousAuthenticationToken` . We can avoid that by adding in the `configure` method : ` http.anonymous().disable()` but not sure it's a good idea. Wdyt ? ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/4471,139136027,2017-09-15T12:30:33Z,services/src/main/java/org/keycloak/authorization/admin/representation/PolicyEvaluationResponseBuilder.java,"@@ -55,6 +56,12 @@ public static PolicyEvaluationResponse build(List<Result> results, ResourceServe         authorizationData.setPermissions(Permissions.permits(results, null, authorization, resourceServer));         accessToken.setAuthorization(authorizationData); +        ClientModel clientModel = authorization.getRealm().getClientById(resourceServer.getId());++        if (!accessToken.hasAudience(clientModel.getClientId())) {+            accessToken.audience(clientModel.getClientId());+        }","Yeah, you are right. The thing is that audience is something we are failing to do correctly. From token issuance to validation (e.g.: by built-in adapters) we are not dealing with it correctly.That would be a quite big change to existing code. There are some issues at this respect.My point is that for now, the changes in this PR should solve our initial problem. Where in the future we might want to revisit this part (and others) to properly handle audience.",
3833769,sschu,https://api.github.com/repos/keycloak/keycloak/pulls/4471,139364093,2017-09-18T08:42:39Z,services/src/main/java/org/keycloak/authorization/admin/representation/PolicyEvaluationResponseBuilder.java,"@@ -55,6 +56,12 @@ public static PolicyEvaluationResponse build(List<Result> results, ResourceServe         authorizationData.setPermissions(Permissions.permits(results, null, authorization, resourceServer));         accessToken.setAuthorization(authorizationData); +        ClientModel clientModel = authorization.getRealm().getClientById(resourceServer.getId());++        if (!accessToken.hasAudience(clientModel.getClientId())) {+            accessToken.audience(clientModel.getClientId());+        }",I am fine with that. Best place to support adding or removing audiences is probably in the token class anyway. You might want to add a TODO somewhere to revisit this once multiple audiences are supported more properly.,
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/4498,141611463,2017-09-28T13:07:42Z,core/src/main/java/org/keycloak/Feature.java,"@@ -0,0 +1,245 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak;++import org.keycloak.common.Version;++import java.io.File;+import java.io.FileInputStream;+import java.util.ArrayList;+import java.util.Arrays;+import java.util.HashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Properties;+import java.util.Set;+import java.util.logging.Level;+import java.util.logging.Logger;++/**+ * @author <a href=""mailto:mstrukel@redhat.com"">Marko Strukelj</a>+ */+public enum Feature {++    /**+     *+     *   When you add, remove, or change a feature, you also have to modify methods: fromCaption() and isEnabledByDefault()+     *+     *   The following files will have to be modified as well:+     *     - pom.xml (keycloak-parent - properties in 'community' and 'product' profiles)+     *     - wildfly/server-subsystem/src/main/config/default-server-subsys-config.properties (<features> section)+     *     - wildfly/server-subsystem/src/main/resources/subsystem-templates/keycloak-server.xml (<features> section)+     *     - wildfly/server-subsystem/src/main/resources/cli/default-keycloak-subsys-config.cli+     *     - wildfly/server-subsystem/src/test/java/org/keycloak/subsystem/server/extension/FeaturesTestCase.java (COMMUNITY_FEATURES, and PRODUCT_FEATURES constants)+     *     - distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-standalone.cli+     *     - distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-standalone-ha.cli+     *     - distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-domain-standalone.cli+     *     - distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-domain-clustered.cli+     *     - distribution/distribution-tests/src/test/java/org/keycloak/test/distribution/DistributionFeaturesTest.java  (COMMUNITY_FEATURES, and PRODUCT_FEATURES constants)+     *+     *   In addition, the following files may need to be modified to support tests:+     *     - testsuite/integration-arquillian/tests/base/src/test/resources/META-INF/keycloak-server.json (feature section)+     *     - testsuite/utils/src/main/resources/META-INF/keycloak-server.json (feature section)+     *+     */++    AUTHORIZATION(true), IMPERSONATION, SCRIPTS(true), DOCKER, ACCOUNT2(true), TOKEN_EXCHANGE;+++    private static final Logger log = Logger.getLogger(Feature.class.getName());++    private boolean preview;++    private static boolean foundBadConfig = false;++    Feature() {+        this.preview = false;+    }++    Feature(boolean preview) {+        this.preview = preview;+    }++    public String caption() {+        String s = name().toLowerCase().replace('_', '-');+        return preview ? s + ""-preview"" : s;+    }++    public static Set<Feature> getDisabledFeatures() {+        // by default all features are disabled+        HashSet<Feature> disabled = new HashSet(Arrays.asList(values()));+        Config.Scope config = Config.scope(""feature"");+        for (Feature f: values()) {+            Config.Scope featureScope = config.scope(f.caption());+            if (!featureScope.getBoolean(""enabled"", false)) {+                disabled.add(f);+            } else {+                disabled.remove(f);+            }+        }++        return disabled;+    }++    public static boolean isFeatureEnabled(Feature feature) {+        return Config.scope(""feature"", feature.caption()).getBoolean(""enabled"", false);+    }++    public static Feature fromCaption(String name) {+        Feature ret = AUTHORIZATION.caption().equals(name) ? AUTHORIZATION :+                IMPERSONATION.caption().equals(name) ? IMPERSONATION :+                SCRIPTS.caption().equals(name) ? SCRIPTS :+                DOCKER.caption().equals(name) ? DOCKER :+                ACCOUNT2.caption().equals(name) ? ACCOUNT2 :+                TOKEN_EXCHANGE.caption().equals(name) ? TOKEN_EXCHANGE : null;++        if (ret == null) {+            throw new IllegalArgumentException(""No such feature: "" + name);+        }+        return ret;+    }++    public static List<String> validCaptions() {+        Feature[] features = values();+        List<String> ret = new ArrayList<>(features.length);++        for (Feature f: features) {+            ret.add(f.caption());+        }+        return ret;+    }++    public boolean isEnabledByDefault() {+        // Value is dependent on whether this is a Keycloak release or some other",I overlooked the fact that this part is independent of Config so the only factor here is Version.NAME which is a static value. Will change like you suggest.,
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/4498,141617628,2017-09-28T13:31:25Z,core/src/main/java/org/keycloak/Feature.java,"@@ -0,0 +1,245 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak;++import org.keycloak.common.Version;++import java.io.File;+import java.io.FileInputStream;+import java.util.ArrayList;+import java.util.Arrays;+import java.util.HashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Properties;+import java.util.Set;+import java.util.logging.Level;+import java.util.logging.Logger;++/**+ * @author <a href=""mailto:mstrukel@redhat.com"">Marko Strukelj</a>+ */+public enum Feature {++    /**+     *+     *   When you add, remove, or change a feature, you also have to modify methods: fromCaption() and isEnabledByDefault()","Regarding all the places involved ... I'm not happy with that either but it has to do with how packaging is done, and with a decision to explicitly spell out the subsystem changes in .cli files. With regards to .cli files there are three options - we include all keycloak-server subsystem changes in them (ALL), we don't include any keycloak-server subsystem changes in them (NONE), or we include some keycloak-server subsystem changes in them (SOME). We've been practising option ALL. Effectively we could be practicing option NONE if we performed upgrades inside keycloak-server. One problem is that in order to ensure that model change is saved in standalone.xml file we would need to increment subsystem version every time we make changes. Without it it would, nevertheless, be reinitialised with defaults upon every start, and it would be visible to jboss-cli and runtime DMR config, just not visible in standalone.xml - but that is bad as users can't easily open the file and see available features, system properties through which they are controlled, and tweak it easily. Incrementing version also means changing all the docs with examples of subsystem xml. I think it's better to create another issue for that then. Option SOME would be to omit adding features to .cli files with same effect of them not being visible in standalone.xml, but we would not remove any existing keycloak-server subsystem entries from .cli files and add logic for their initialisation into the subsystem. For other files, we should go over each one, and consider if anything can be done to remove it. The danger is that while we might devise a plan how to have things in one place it would come with horrible scripting extras at maven plugin level to use and transform the same content in various places, which makes packaging hard to understand, hard to debug, hard to change. ",X
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/4498,141632627,2017-09-28T14:23:03Z,core/src/main/java/org/keycloak/Feature.java,"@@ -0,0 +1,245 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak;++import org.keycloak.common.Version;++import java.io.File;+import java.io.FileInputStream;+import java.util.ArrayList;+import java.util.Arrays;+import java.util.HashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Properties;+import java.util.Set;+import java.util.logging.Level;+import java.util.logging.Logger;++/**+ * @author <a href=""mailto:mstrukel@redhat.com"">Marko Strukelj</a>+ */+public enum Feature {++    /**+     *+     *   When you add, remove, or change a feature, you also have to modify methods: fromCaption() and isEnabledByDefault()+     *+     *   The following files will have to be modified as well:+     *     - pom.xml (keycloak-parent - properties in 'community' and 'product' profiles)+     *     - wildfly/server-subsystem/src/main/config/default-server-subsys-config.properties (<features> section)+     *     - wildfly/server-subsystem/src/main/resources/subsystem-templates/keycloak-server.xml (<features> section)+     *     - wildfly/server-subsystem/src/main/resources/cli/default-keycloak-subsys-config.cli+     *     - wildfly/server-subsystem/src/test/java/org/keycloak/subsystem/server/extension/FeaturesTestCase.java (COMMUNITY_FEATURES, and PRODUCT_FEATURES constants)+     *     - distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-standalone.cli+     *     - distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-standalone-ha.cli+     *     - distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-domain-standalone.cli+     *     - distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-domain-clustered.cli+     *     - distribution/distribution-tests/src/test/java/org/keycloak/test/distribution/DistributionFeaturesTest.java  (COMMUNITY_FEATURES, and PRODUCT_FEATURES constants)+     *+     *   In addition, the following files may need to be modified to support tests:+     *     - testsuite/integration-arquillian/tests/base/src/test/resources/META-INF/keycloak-server.json (feature section)+     *     - testsuite/utils/src/main/resources/META-INF/keycloak-server.json (feature section)+     *+     */++    AUTHORIZATION(true), IMPERSONATION, SCRIPTS(true), DOCKER, ACCOUNT2(true), TOKEN_EXCHANGE;+++    private static final Logger log = Logger.getLogger(Feature.class.getName());++    private boolean preview;++    private static boolean foundBadConfig = false;++    Feature() {+        this.preview = false;+    }++    Feature(boolean preview) {+        this.preview = preview;+    }++    public String caption() {+        String s = name().toLowerCase().replace('_', '-');+        return preview ? s + ""-preview"" : s;+    }++    public static Set<Feature> getDisabledFeatures() {+        // by default all features are disabled+        HashSet<Feature> disabled = new HashSet(Arrays.asList(values()));+        Config.Scope config = Config.scope(""feature"");+        for (Feature f: values()) {+            Config.Scope featureScope = config.scope(f.caption());+            if (!featureScope.getBoolean(""enabled"", false)) {+                disabled.add(f);+            } else {+                disabled.remove(f);+            }+        }++        return disabled;+    }++    public static boolean isFeatureEnabled(Feature feature) {+        return Config.scope(""feature"", feature.caption()).getBoolean(""enabled"", false);+    }++    public static Feature fromCaption(String name) {+        Feature ret = AUTHORIZATION.caption().equals(name) ? AUTHORIZATION :+                IMPERSONATION.caption().equals(name) ? IMPERSONATION :+                SCRIPTS.caption().equals(name) ? SCRIPTS :+                DOCKER.caption().equals(name) ? DOCKER :+                ACCOUNT2.caption().equals(name) ? ACCOUNT2 :+                TOKEN_EXCHANGE.caption().equals(name) ? TOKEN_EXCHANGE : null;++        if (ret == null) {+            throw new IllegalArgumentException(""No such feature: "" + name);+        }+        return ret;+    }++    public static List<String> validCaptions() {+        Feature[] features = values();+        List<String> ret = new ArrayList<>(features.length);++        for (Feature f: features) {+            ret.add(f.caption());+        }+        return ret;+    }++    public boolean isEnabledByDefault() {+        // Value is dependent on whether this is a Keycloak release or some other",BTW: I noticed that Version.XXX constants are almost all non-final. The reason is how they are initialised. Can I fix that as part of this issue - I want to add IS_COMMUNITY_VERSION constant to Version class? Or I can make a separate PR for that.,X
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/4510,141715074,2017-09-28T19:34:07Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -165,6 +165,9 @@ public static void importRealm(KeycloakSession session, RealmRepresentation rep,         if (rep.getRevokeRefreshToken() != null) newRealm.setRevokeRefreshToken(rep.getRevokeRefreshToken());         else newRealm.setRevokeRefreshToken(false); +        if (rep.getRefreshTokenMaxReuse() != null) newRealm.setRefreshTokenMaxReuse(rep.getRefreshTokenMaxReuse());+        else newRealm.setRefreshTokenMaxReuse(0);","@mposolda, as discussed, default database value is not picked (at least by MySQL) for existing data as the column was set to NULLABLE to be in line with other setting columns. The default value is picked from here and it keeps the current behaviour of revoking a refresh token after first use.",
13800915,glavoie,https://api.github.com/repos/keycloak/keycloak/pulls/4510,141715438,2017-09-28T19:35:45Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/AuthenticatedClientSessionAdapter.java,"@@ -156,6 +156,56 @@ public CrossDCMessageStatus getCrossDCMessageStatus(SessionEntityWrapper<UserSes     }      @Override+    public int getCurrentRefreshTokenUseCount() {+        return entity.getCurrentRefreshTokenUseCount();+    }++    @Override+    public void setCurrentRefreshTokenUseCount(int currentRefreshTokenUseCount) {+        UserSessionClientSessionUpdateTask task = new UserSessionClientSessionUpdateTask(client.getId()) {++            @Override+            protected void runClientSessionUpdate(AuthenticatedClientSessionEntity entity) {+                entity.setCurrentRefreshTokenUseCount(currentRefreshTokenUseCount);+            }++            @Override+            public CrossDCMessageStatus getCrossDCMessageStatus(SessionEntityWrapper<UserSessionEntity> sessionWrapper) {+                // We usually update lastSessionRefresh at the same time. That would handle it.+                return CrossDCMessageStatus.NOT_NEEDED;","Here, and in setCurrentRefreshToken I kept the same pattern as the timestamp as I understand that the update of the synchronization of the UserSessionEntity will synchronize the AuthenticatedClientSessionEntities by reference/cascade.",
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4518,142188964,2017-10-02T16:31:10Z,testsuite/performance/tests/pom.xml,"@@ -48,11 +48,25 @@         <keycloak.ds.max-pool-size>100</keycloak.ds.max-pool-size>         <keycloak.ds.pool-prefill>true</keycloak.ds.pool-prefill>         <keycloak.ds.ps-cache-size>100</keycloak.ds.ps-cache-size>-        +         <keycloak-lb.jvm.memory>-Xms64m -Xmx512m -XX:MetaspaceSize=96M -XX:MaxMetaspaceSize=256m</keycloak-lb.jvm.memory>         <keycloak-lb.http.max-connections>500</keycloak-lb.http.max-connections>         <keycloak-lb.worker.io-threads>2</keycloak-lb.worker.io-threads>         <keycloak-lb.worker.task-max-threads>16</keycloak-lb.worker.task-max-threads>++        <docker.db.cpuset>0-1</docker.db.cpuset>",Can we use the same naming scheme as for the other properties? `<SERVICE_NAME.docker.cpuset>` instead of `<docker.SERVICE_NAME.cpuset>`.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4524,142367403,2017-10-03T10:40:51Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/AuthServerTestEnricher.java,"@@ -164,16 +169,24 @@ public void initializeSuiteContext(@Observes(precedence = 2) BeforeSuite event)                 throw new IllegalStateException(""Frontend container (load balancer) misconfiguration"");             } +            boolean authServerJboss = Boolean.parseBoolean(System.getProperty(""auth.server.jboss.crossdc""));+            String containerPreffix;+            if (authServerJboss) {","Can the whole condition be replaced with `containerPrefix = ""auth-server-"" + System.getProperty(""node.name"") + ""-""`?",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/4528,142613645,2017-10-04T08:49:37Z,common/src/main/java/org/keycloak/common/util/FindFile.java,"@@ -29,28 +29,32 @@  * @version $Revision: 1 $  */ public class FindFile {-    public static InputStream findFile(String keycloakConfigFile) {-        if (keycloakConfigFile.startsWith(GenericConstants.PROTOCOL_CLASSPATH)) {-            String classPathLocation = keycloakConfigFile.replace(GenericConstants.PROTOCOL_CLASSPATH, """");-            // Try current class classloader first-            InputStream is = FindFile.class.getClassLoader().getResourceAsStream(classPathLocation);-            if (is == null) {-                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(classPathLocation);-            }+	public static InputStream findFile(String keycloakConfigFile) {+		if (keycloakConfigFile.startsWith(GenericConstants.PROTOCOL_CLASSPATH)) {+			String classPathLocation = keycloakConfigFile.replace(GenericConstants.PROTOCOL_CLASSPATH, """");+			// Try current class classloader first+			InputStream is = FindFile.class.getClassLoader().getResourceAsStream(classPathLocation);+			if (is == null) {+				is = Thread.currentThread().getContextClassLoader().getResourceAsStream(classPathLocation);+			} -            if (is != null) {-                return is;-            } else {-                throw new RuntimeException(""Unable to find config from classpath: "" + keycloakConfigFile);-            }-        } else {-            // Fallback to file-            try {-            	//Added support for the URL handling-                return new URL(keycloakConfigFile).openStream();-            } catch (Exception e) {-                throw new RuntimeException(e);-            }-        }-    }+			if (is != null) {+				return is;+			} else {+				throw new RuntimeException(""Unable to find config from classpath: "" + keycloakConfigFile);+			}+		} else {+			// Fallback to file+			try {+				// Added support for the URL handling+				if (!keycloakConfigFile.contains("":"")) {+					// assume file protocol","This class is for loading local resources, not going to the internet. Looking at this code - if I pass it ""http://www.keycloak.org/"" it will just go out and fetch it.I see the need for custom resource loading using 'protocol:' but a better place to solve that would be in [AbstractKeycloakLoginModule](https://github.com/keycloak/keycloak/blob/3.3.0.CR2/adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/jaas/AbstractKeycloakLoginModule.java#L85-L94)",X
22483381,RaiSaurabh,https://api.github.com/repos/keycloak/keycloak/pulls/4528,142653459,2017-10-04T12:18:16Z,common/src/main/java/org/keycloak/common/util/FindFile.java,"@@ -29,28 +29,32 @@  * @version $Revision: 1 $  */ public class FindFile {-    public static InputStream findFile(String keycloakConfigFile) {-        if (keycloakConfigFile.startsWith(GenericConstants.PROTOCOL_CLASSPATH)) {-            String classPathLocation = keycloakConfigFile.replace(GenericConstants.PROTOCOL_CLASSPATH, """");-            // Try current class classloader first-            InputStream is = FindFile.class.getClassLoader().getResourceAsStream(classPathLocation);-            if (is == null) {-                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(classPathLocation);-            }+	public static InputStream findFile(String keycloakConfigFile) {+		if (keycloakConfigFile.startsWith(GenericConstants.PROTOCOL_CLASSPATH)) {+			String classPathLocation = keycloakConfigFile.replace(GenericConstants.PROTOCOL_CLASSPATH, """");+			// Try current class classloader first+			InputStream is = FindFile.class.getClassLoader().getResourceAsStream(classPathLocation);+			if (is == null) {+				is = Thread.currentThread().getContextClassLoader().getResourceAsStream(classPathLocation);+			} -            if (is != null) {-                return is;-            } else {-                throw new RuntimeException(""Unable to find config from classpath: "" + keycloakConfigFile);-            }-        } else {-            // Fallback to file-            try {-            	//Added support for the URL handling-                return new URL(keycloakConfigFile).openStream();-            } catch (Exception e) {-                throw new RuntimeException(e);-            }-        }-    }+			if (is != null) {+				return is;+			} else {+				throw new RuntimeException(""Unable to find config from classpath: "" + keycloakConfigFile);+			}+		} else {+			// Fallback to file+			try {+				// Added support for the URL handling+				if (!keycloakConfigFile.contains("":"")) {+					// assume file protocol","I looked in to the resolveDeployment method of AbstractKeycloakLoginModule. It is using the class FindFile method findFile. Please correct me if I am wrong so, as per you I should update it to provide the inputstream via the URL openstream and not calling the FindFile method.",
22483381,RaiSaurabh,https://api.github.com/repos/keycloak/keycloak/pulls/4528,142655574,2017-10-04T12:29:10Z,common/src/main/java/org/keycloak/common/util/FindFile.java,"@@ -29,28 +29,32 @@  * @version $Revision: 1 $  */ public class FindFile {-    public static InputStream findFile(String keycloakConfigFile) {-        if (keycloakConfigFile.startsWith(GenericConstants.PROTOCOL_CLASSPATH)) {-            String classPathLocation = keycloakConfigFile.replace(GenericConstants.PROTOCOL_CLASSPATH, """");-            // Try current class classloader first-            InputStream is = FindFile.class.getClassLoader().getResourceAsStream(classPathLocation);-            if (is == null) {-                is = Thread.currentThread().getContextClassLoader().getResourceAsStream(classPathLocation);-            }+	public static InputStream findFile(String keycloakConfigFile) {+		if (keycloakConfigFile.startsWith(GenericConstants.PROTOCOL_CLASSPATH)) {+			String classPathLocation = keycloakConfigFile.replace(GenericConstants.PROTOCOL_CLASSPATH, """");+			// Try current class classloader first+			InputStream is = FindFile.class.getClassLoader().getResourceAsStream(classPathLocation);+			if (is == null) {+				is = Thread.currentThread().getContextClassLoader().getResourceAsStream(classPathLocation);+			} -            if (is != null) {-                return is;-            } else {-                throw new RuntimeException(""Unable to find config from classpath: "" + keycloakConfigFile);-            }-        } else {-            // Fallback to file-            try {-            	//Added support for the URL handling-                return new URL(keycloakConfigFile).openStream();-            } catch (Exception e) {-                throw new RuntimeException(e);-            }-        }-    }+			if (is != null) {+				return is;+			} else {+				throw new RuntimeException(""Unable to find config from classpath: "" + keycloakConfigFile);+			}+		} else {+			// Fallback to file+			try {+				// Added support for the URL handling+				if (!keycloakConfigFile.contains("":"")) {+					// assume file protocol",I think I get it now. You want me add my custom resolver for resource having protocol in  AbstractKeycloakLoginModule. If I understood correctly I will update this class with a method to resolve the same.,
22483381,RaiSaurabh,https://api.github.com/repos/keycloak/keycloak/pulls/4528,142922163,2017-10-05T12:25:07Z,adapters/oidc/adapter-core/src/test/java/org/keycloak/adapters/KeycloakConfigTest.java,"@@ -0,0 +1,61 @@+/**+ * + */+package org.keycloak.adapters;++import static org.junit.Assert.*;++import org.jboss.logging.Logger;+import org.junit.Test;+import org.keycloak.adapters.jaas.AbstractKeycloakLoginModule;+++/**+ * @author <a href=""mailto:sarai@redhat.com"">Saurabh Rai</a>+ *+ */+public class KeycloakConfigTest {",@stianst  I am not familiar with Keycloack testsuites any help or guidance would be appreciated.  The change is just to check if the keycloakConfigFile starts with profile only then it should load it via URL handler else it will throw exception. I have updated the changes accordingly and removed this Unit test class.,
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4518,142959833,2017-10-05T14:47:10Z,testsuite/performance/README.provisioning-parameters.md,"@@ -29,35 +29,18 @@ |-------------|-------------------------------|-------------------------|-----------------------------------------------------------------------------------------| | JVM         | Memory settings               | `infinispan.jvm.memory` | -Xms64m -Xmx512m -XX:MetaspaceSize=96M -XX:MaxMetaspaceSize=256m -XX:+DisableExplicitGC | -## CPUs--At the moment it is not possible to dynamically parametrize the number of CPUs for a service via Maven properties or environment variables.--To change the default value (`cpus: 1`) it is necessary to edit the Docker Compose file.---### Example: Keycloak service using 2 CPU cores--`docker-compose.yml` and `docker-compose-cluster.yml`:-```-services:-    ...-    keycloak:-        ...-        cpus: 2-        ...-```--`docker-compose-crossdc.yml`:-```-services:-    ...-    keycloak_dc1:-        ...-        cpus: 2-        ...-    keycloak_dc2:-        ...-        cpus: 2-        ...-```+## Docker settings++By default, there are 4 CPU cores allocated: core 0 for monitoring, core 1 for database (MariaDB), and cores 2 and 3 for Keycloak server.",We need to add some notes about how to set  the `cpuset` parameter together with cluster scaling. For the results to be comparable the value of the `cpuset` (range of cpu cores) needs to scale together with the size of the provisioned cluster (or clusters in case of the cross-dc deployment).,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4518,143020237,2017-10-05T18:30:01Z,testsuite/performance/README.provisioning-parameters.md,"@@ -29,35 +29,18 @@ |-------------|-------------------------------|-------------------------|-----------------------------------------------------------------------------------------| | JVM         | Memory settings               | `infinispan.jvm.memory` | -Xms64m -Xmx512m -XX:MetaspaceSize=96M -XX:MaxMetaspaceSize=256m -XX:+DisableExplicitGC | -## CPUs--At the moment it is not possible to dynamically parametrize the number of CPUs for a service via Maven properties or environment variables.--To change the default value (`cpus: 1`) it is necessary to edit the Docker Compose file.---### Example: Keycloak service using 2 CPU cores--`docker-compose.yml` and `docker-compose-cluster.yml`:-```-services:-    ...-    keycloak:-        ...-        cpus: 2-        ...-```--`docker-compose-crossdc.yml`:-```-services:-    ...-    keycloak_dc1:-        ...-        cpus: 2-        ...-    keycloak_dc2:-        ...-        cpus: 2-        ...-```+## Docker settings++By default, there are 4 CPU cores allocated: core 0 for monitoring, core 1 for database (MariaDB), and cores 2 and 3 for Keycloak server.","Added note for easier reference of what these parameters mean and how they map to docker-compose file values, but let me stress that this document is no performance-tuning guide. The knowledge of how to tune these parameters must come from understanding the impact of the parameter values that among other depends on underlying architecture - which is way beyond the scope of this description of parameters. ",X
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4518,143024547,2017-10-05T18:46:19Z,testsuite/performance/README.provisioning-parameters.md,"@@ -29,35 +29,18 @@ |-------------|-------------------------------|-------------------------|-----------------------------------------------------------------------------------------| | JVM         | Memory settings               | `infinispan.jvm.memory` | -Xms64m -Xmx512m -XX:MetaspaceSize=96M -XX:MaxMetaspaceSize=256m -XX:+DisableExplicitGC | -## CPUs--At the moment it is not possible to dynamically parametrize the number of CPUs for a service via Maven properties or environment variables.--To change the default value (`cpus: 1`) it is necessary to edit the Docker Compose file.---### Example: Keycloak service using 2 CPU cores--`docker-compose.yml` and `docker-compose-cluster.yml`:-```-services:-    ...-    keycloak:-        ...-        cpus: 2-        ...-```--`docker-compose-crossdc.yml`:-```-services:-    ...-    keycloak_dc1:-        ...-        cpus: 2-        ...-    keycloak_dc2:-        ...-        cpus: 2-        ...-```+## Docker settings++By default, there are 4 CPU cores allocated: core 0 for monitoring, core 1 for database (MariaDB), and cores 2 and 3 for Keycloak server.","Yes, the details are out of scope. I just wanted the users to be aware that for scalability testing they need to scale the cpuset together with the size of the Keycloak cluster. This is not apparent from reading the ""main"" README so when people will be scaling up and forget to increase the cpuset range accordingly they will get bad results.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/4528,143108459,2017-10-06T04:39:44Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/jaas/AbstractKeycloakLoginModule.java,"@@ -84,14 +88,30 @@ public void initialize(Subject subject, CallbackHandler callbackHandler, Map<Str      protected KeycloakDeployment resolveDeployment(String keycloakConfigFile) {         try {-            InputStream is = FindFile.findFile(keycloakConfigFile);+            InputStream is = null;","Ok, that makes sense. I would still suggest you do a string check first to see if keycloakConfigFile starts with 'profile:' rather than rely on exception being thrown.",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/4528,143147618,2017-10-06T09:33:03Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/jaas/AbstractKeycloakLoginModule.java,"@@ -84,14 +88,30 @@ public void initialize(Subject subject, CallbackHandler callbackHandler, Map<Str      protected KeycloakDeployment resolveDeployment(String keycloakConfigFile) {         try {-            InputStream is = FindFile.findFile(keycloakConfigFile);+            InputStream is = null;","My original suggestion with exception was to completely avoid checking for 'protocol:' in order to allow potential integration with other frameworks OOTB. In that sense if we want to prevent going to the internet we could just check for http, https, and ftp, and let all else through. Although actually that solution is not future proof - if some additional network protocol becomes available through URL class, we would have to keep an eye on it and add it to exclude list. So yeah, might be better to go with include list instead.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/4568,145520678,2017-10-18T19:41:53Z,distribution/pom.xml,"@@ -31,6 +31,10 @@     <artifactId>keycloak-distribution-parent</artifactId>     <packaging>pom</packaging> +    <properties>+        <keycloak.provisioning.xml>server-provisioning.xml</keycloak.provisioning.xml>+    </properties>+","Sorry, as long as it's ok to cover both independent changes in single PR, it looks ok.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/4621,147372886,2017-10-27T10:13:52Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.4.0.xml,"@@ -47,4 +47,63 @@         <addPrimaryKey columnNames=""CLIENT_ID,VALUE"" constraintName=""CONSTRAINT_WEB_ORIGINS"" tableName=""WEB_ORIGINS""/>     </changeSet> +    <changeSet author=""hmlnarik@redhat.com"" id=""3.4.0-KEYCLOAK-5230"">++        <createIndex tableName=""FED_USER_ATTRIBUTE"" indexName=""IDX_FED_USER_ATTRIBUTE"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""REALM_ID"" type=""VARCHAR(36)"" />+            <column name=""NAME"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_CONSENT"" indexName=""IDX_FED_USER_CONSENT"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""CLIENT_ID"" type=""VARCHAR(36)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_CONSENT"" indexName=""IDX_FED_USER_CONSENT_RU"">+            <column name=""REALM_ID"" type=""VARCHAR(36)"" />+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_CREDENTIAL"" indexName=""IDX_FED_USER_CREDENTIAL"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""TYPE"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_CREDENTIAL"" indexName=""IDX_FED_USER_CREDENTIAL_RU"">+            <column name=""REALM_ID"" type=""VARCHAR(36)"" />+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_GROUP_MEMBERSHIP"" indexName=""IDX_FED_USER_GROUP_MEMBERSHIP"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""GROUP_ID"" type=""VARCHAR(36)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_GROUP_MEMBERSHIP"" indexName=""IDX_FED_USER_GROUP_MEMBERSHIP_RU"">","indexName IDX_FED_USER_GROUP_MEMBERSHIP_RU is too long on Oracle DB, the limit is 30",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/4621,147372926,2017-10-27T10:14:00Z,model/jpa/src/main/resources/META-INF/jpa-changelog-3.4.0.xml,"@@ -47,4 +47,63 @@         <addPrimaryKey columnNames=""CLIENT_ID,VALUE"" constraintName=""CONSTRAINT_WEB_ORIGINS"" tableName=""WEB_ORIGINS""/>     </changeSet> +    <changeSet author=""hmlnarik@redhat.com"" id=""3.4.0-KEYCLOAK-5230"">++        <createIndex tableName=""FED_USER_ATTRIBUTE"" indexName=""IDX_FED_USER_ATTRIBUTE"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""REALM_ID"" type=""VARCHAR(36)"" />+            <column name=""NAME"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_CONSENT"" indexName=""IDX_FED_USER_CONSENT"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""CLIENT_ID"" type=""VARCHAR(36)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_CONSENT"" indexName=""IDX_FED_USER_CONSENT_RU"">+            <column name=""REALM_ID"" type=""VARCHAR(36)"" />+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_CREDENTIAL"" indexName=""IDX_FED_USER_CREDENTIAL"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""TYPE"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_CREDENTIAL"" indexName=""IDX_FED_USER_CREDENTIAL_RU"">+            <column name=""REALM_ID"" type=""VARCHAR(36)"" />+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_GROUP_MEMBERSHIP"" indexName=""IDX_FED_USER_GROUP_MEMBERSHIP"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""GROUP_ID"" type=""VARCHAR(36)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_GROUP_MEMBERSHIP"" indexName=""IDX_FED_USER_GROUP_MEMBERSHIP_RU"">+            <column name=""REALM_ID"" type=""VARCHAR(36)"" />+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_REQUIRED_ACTION"" indexName=""IDX_FED_USER_REQUIRED_ACTION"">+            <column name=""USER_ID"" type=""VARCHAR(255)"" />+            <column name=""REQUIRED_ACTION"" type=""VARCHAR(255)"" />+        </createIndex>++        <createIndex tableName=""FED_USER_REQUIRED_ACTION"" indexName=""IDX_FED_USER_REQUIRED_ACTION_RU"">","indexName IDX_FED_USER_REQUIRED_ACTION_RU is too long on Oracle DB, the limit is 30",X
111842,trecloux,https://api.github.com/repos/keycloak/keycloak/pulls/4346,149921699,2017-11-09T10:29:50Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/config/KeycloakWebSecurityConfigurerAdapter.java,"@@ -117,6 +123,7 @@ protected void configure(HttpSecurity http) throws Exception {                 .and()                 .addFilterBefore(keycloakPreAuthActionsFilter(), LogoutFilter.class)                 .addFilterBefore(keycloakAuthenticationProcessingFilter(), BasicAuthenticationFilter.class)+                .addFilterBefore(keycloakAuthenticatedActionsFilter(), BasicAuthenticationFilter.class)","@sebastienblanc, after our discussions and tests, I created issue KEYCLOAK-5808 to cover the spring boot configuration class",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4676,150506632,2017-11-13T11:03:10Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/RequiredActionEmailVerificationTest.java,"@@ -449,6 +448,93 @@ public void verifyEmailExpiredCode() throws IOException, MessagingException {     }      @Test+    public void verifyEmailExpiredCodedPerActionLifespan() throws IOException, MessagingException {+        final AtomicInteger originalValue = new AtomicInteger();++        RealmRepresentation realmRep = testRealm().toRepresentation();+        originalValue.set(realmRep.getActionTokenGeneratedByUserLifespan());+        realmRep.setAttributes(UserActionTokenBuilder.create().verifyEmailLifespan(60).build());+        testRealm().update(realmRep);",This update should be reverted in the **finally** part of this test similarly to ResetPasswordTest.The same comment applies to the other tests as well,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4676,150538935,2017-11-13T13:34:27Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/realm/TokensTest.java,"@@ -78,10 +96,94 @@ public void testLifespanOfRealmSession() throws InterruptedException {         assertCurrentUrlStartsWithLoginUrlOf(testRealmPage); // assert logged out (lifespan exceeded)     } +    @Test+    public void testLifespanOfVerifyEmailActionTokenPropagated() throws InterruptedException {+        tokenSettingsPage.form().setOperation(VerifyEmailActionToken.TOKEN_TYPE, TIMEOUT, TimeUnit.DAYS);+        tokenSettingsPage.form().save();+        assertAlertSuccess();++        loginToTestRealmConsoleAs(testUser);+        driver.navigate().refresh();++        tokenSettingsPage.navigateTo();+        tokenSettingsPage.form().selectOperation(VerifyEmailActionToken.TOKEN_TYPE);++        assertTrue(""User action token for verify e-mail expected"",+                tokenSettingsPage.form().isOperationEquals(VerifyEmailActionToken.TOKEN_TYPE, TIMEOUT, TimeUnit.DAYS));++    }++    @Test+    public void testLifespanActionTokenPropagatedForVerifyEmailAndResetPassword() throws InterruptedException {+        tokenSettingsPage.form().setOperation(VerifyEmailActionToken.TOKEN_TYPE, TIMEOUT, TimeUnit.DAYS);+        tokenSettingsPage.form().setOperation(ResetCredentialsActionToken.TOKEN_TYPE, TIMEOUT, TimeUnit.HOURS);+        tokenSettingsPage.form().save();+        assertAlertSuccess();++        loginToTestRealmConsoleAs(testUser);+        driver.navigate().refresh();++        tokenSettingsPage.navigateTo();+        assertTrue(""User action token for verify e-mail expected"",+                tokenSettingsPage.form().isOperationEquals(VerifyEmailActionToken.TOKEN_TYPE, TIMEOUT, TimeUnit.DAYS));++        assertTrue(""User action token for reset credentials expected"",+                tokenSettingsPage.form().isOperationEquals(ResetCredentialsActionToken.TOKEN_TYPE, TIMEOUT, TimeUnit.HOURS));++        //Verify if values were properly propagated+        Map<String, Integer> userActionTokens = getUserActionTokens();++        assertTrue(""Action Token attributes list should contain 2 items"", userActionTokens.size() == 2);","Better use```javaassertThat(""Action Token attributes list should contain 2 items"", userActionTokens, Matchers.hasSize(2));```as it gives more descriptive error messages on assertion failure.",
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4694,151134895,2017-11-15T14:08:28Z,testsuite/performance/tests/pom.xml,"@@ -253,6 +255,13 @@                     </execution>                 </executions>             </plugin>                    +            <plugin>",Most of the executions of `exec-maven-plugin` in this pom use: `<workingDirectory>${project.basedir}/..</workingDirectory>` because they run docker-compose or scripts in the parent directory. My intention was to move this configuration to the common plugin-level configuration and remove duplicate entries from the execution-level configruations.But it seems I didn't finish the job as I only removed the duplicate entries from within the import-dump profile. I need to remove the rest.,
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4684,151160818,2017-11-15T15:34:13Z,testsuite/performance/tests/src/test/scala/keycloak/DefaultSimulation.scala,"@@ -54,100 +49,94 @@ class DefaultSimulation extends Simulation {   val ACCEPT_ALL = Map(""Accept"" -> ""*/*"")    val userSession = exec(s => {-    // initialize session with host, user, client app, login failure ratio ...-    val realm = TestConfig.randomRealmsIterator().next()-    val userInfo = TestConfig.getUsersIterator(realm).next()-    val clientInfo = TestConfig.getConfidentialClientsIterator(realm).next()+      // initialize session with host, user, client app, login failure ratio ...+      val realm = TestConfig.randomRealmsIterator().next()+      val userInfo = TestConfig.getUsersIterator(realm).next()+      val clientInfo = TestConfig.getConfidentialClientsIterator(realm).next() -    AuthorizeAction.init(s)+      AuthorizeAction.init(s)       .setAll(""keycloakServer"" -> TestConfig.serverUrisIterator.next(),-        ""state"" -> Util.randomUUID(),-        ""wrongPasswordCount"" -> new AtomicInteger(TestConfig.badLoginAttempts),-        ""refreshTokenCount"" -> new AtomicInteger(TestConfig.refreshTokenCount),-        ""realm"" -> realm,-        ""username"" -> userInfo.username,-        ""password"" -> userInfo.password,-        ""clientId"" -> clientInfo.clientId,-        ""secret"" -> clientInfo.secret,-        ""appUrl"" -> clientInfo.appUrl+              ""state"" -> Util.randomUUID(),+              ""wrongPasswordCount"" -> new AtomicInteger(TestConfig.badLoginAttempts),+              ""refreshTokenCount"" -> new AtomicInteger(TestConfig.refreshTokenCount),+              ""realm"" -> realm,+              ""username"" -> userInfo.username,+              ""password"" -> userInfo.password,+              ""clientId"" -> clientInfo.clientId,+              ""secret"" -> clientInfo.secret,+              ""appUrl"" -> clientInfo.appUrl       )     })-    .exitHereIfFailed-    .exec(http(""Browser to Log In Endpoint"")-      .get(LOGIN_ENDPOINT)-      .headers(UI_HEADERS)-      .queryParam(""login"", ""true"")-      .queryParam(""response_type"", ""code"")-      .queryParam(""client_id"", ""${clientId}"")-      .queryParam(""state"", ""${state}"")-      .queryParam(""redirect_uri"", ""${appUrl}"")-      .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))+  .exitHereIfFailed+  .exec(http(""Browser to Log In Endpoint"")+        .get(LOGIN_ENDPOINT)+        .headers(UI_HEADERS)+        .queryParam(""login"", ""true"")+        .queryParam(""response_type"", ""code"")+        .queryParam(""client_id"", ""${clientId}"")+        .queryParam(""state"", ""${state}"")+        .queryParam(""redirect_uri"", ""${appUrl}"")+        .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))+  .exitHereIfFailed+  .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))++  .asLongAs(s => downCounterAboveZero(s, ""wrongPasswordCount"")) {+    exec(http(""Browser posts wrong credentials"")+         .post(""${login-form-uri}"")+         .headers(UI_HEADERS)+         .formParam(""username"", ""${username}"")+         .formParam(""password"", _ => Util.randomString(10))+         .formParam(""login"", ""Log in"")+         .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))     .exitHereIfFailed     .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))+  } -    .asLongAs(s => downCounterAboveZero(s, ""wrongPasswordCount"")) {-      exec(http(""Browser posts wrong credentials"")+  // Successful login+  .exec(http(""Browser posts correct credentials"")         .post(""${login-form-uri}"")         .headers(UI_HEADERS)         .formParam(""username"", ""${username}"")-        .formParam(""password"", _ => Util.randomString(10))+        .formParam(""password"", ""${password}"")         .formParam(""login"", ""Log in"")-        .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))-        .exitHereIfFailed-        .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))-    }--    // Successful login-    .exec(http(""Browser posts correct credentials"")-      .post(""${login-form-uri}"")-      .headers(UI_HEADERS)-      .formParam(""username"", ""${username}"")-      .formParam(""password"", ""${password}"")-      .formParam(""login"", ""Log in"")-      .check(status.is(302), header(""Location"").saveAs(""login-redirect"")))-    .exitHereIfFailed---    // Now act as client adapter - exchange code for keys-    .exec(oauth(""Adapter exchanges code for tokens"")-      .authorize(""${login-redirect}"",-      session => List(new Cookie(""OAuth_Token_Request_State"", session(""state"").as[String], 0, null, null)))-      .authServerUrl(""${keycloakServer}"")-      .resource(""${clientId}"")-      .clientCredentials(""${secret}"")-      .realm(""${realm}"")-    //.realmKey(Loader.realmRepresentation.getPublicKey)-    )--    // Refresh token several times-    .asLongAs(s => downCounterAboveZero(s, ""refreshTokenCount"")) {-      pause(TestConfig.refreshTokenPeriod, Normal(TestConfig.refreshTokenPeriod * 0.2))-      .exec(oauth(""Adapter refreshes token"").refresh())-    }+        .check(status.is(302), header(""Location"").saveAs(""login-redirect"")))+  .exitHereIfFailed+++  // Now act as client adapter - exchange code for keys+  .exec(oauth(""Adapter exchanges code for tokens"")+        .authorize(""${login-redirect}"",+                   session => List(new Cookie(""OAuth_Token_Request_State"", session(""state"").as[String], 0, null, null)))+        .authServerUrl(""${keycloakServer}"")+        .resource(""${clientId}"")+        .clientCredentials(""${secret}"")+        .realm(""${realm}"")+        //.realmKey(Loader.realmRepresentation.getPublicKey)+  )++  // Refresh token several times+  .asLongAs(s => downCounterAboveZero(s, ""refreshTokenCount"")) {+    pause(TestConfig.refreshTokenPeriod, Normal(TestConfig.refreshTokenPeriod * 0.2))+    .exec(oauth(""Adapter refreshes token"").refresh())+  } -    // Logout-    .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))-    .exec(http(""Browser logout"")-      .get(LOGOUT_ENDPOINT)-      .headers(UI_HEADERS)-      .queryParam(""redirect_uri"", ""${appUrl}"")-      .check(status.is(302), header(""Location"").is(""${appUrl}"")))+  // Logout+  .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))+  .exec(http(""Browser logout"")+        .get(LOGOUT_ENDPOINT)+        .headers(UI_HEADERS)+        .queryParam(""redirect_uri"", ""${appUrl}"")+        .check(status.is(302), header(""Location"").is(""${appUrl}"")))    val usersScenario = scenario(""users"")-    .repeat(TestConfig.numOfIterations) {-      userSession-    }--  setUp(usersScenario.inject( {-    if (TestConfig.rampUpPeriod > 0) {-      rampUsers(TestConfig.runUsers) over TestConfig.rampUpPeriod-    } else {-      atOnceUsers(TestConfig.runUsers)-    }-  }).protocols(httpDefault))--+  .asLongAs(s => rampDownPeriodNotReached(), null, TestConfig.rampDownASAP) {","I replaced the `.repeat(TestConfig.numOfIterations)` loop (which has a fixed number of iterations) with `.asLongAs(s => rampDownPeriodNotReached() ...)` loop which checks if the `rampUpPeriod + steadyLoadPeriod` has expired, and keeps repeating the scenario otherwise.When the `rampDownASAP` parameter is true the check will be done after each scenario step, otherwise it will be done at the end of each scenario iteration.",
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4684,151160896,2017-11-15T15:34:24Z,testsuite/performance/tests/src/test/scala/keycloak/DefaultSimulation.scala,"@@ -54,100 +49,94 @@ class DefaultSimulation extends Simulation {   val ACCEPT_ALL = Map(""Accept"" -> ""*/*"")    val userSession = exec(s => {-    // initialize session with host, user, client app, login failure ratio ...-    val realm = TestConfig.randomRealmsIterator().next()-    val userInfo = TestConfig.getUsersIterator(realm).next()-    val clientInfo = TestConfig.getConfidentialClientsIterator(realm).next()+      // initialize session with host, user, client app, login failure ratio ...+      val realm = TestConfig.randomRealmsIterator().next()+      val userInfo = TestConfig.getUsersIterator(realm).next()+      val clientInfo = TestConfig.getConfidentialClientsIterator(realm).next() -    AuthorizeAction.init(s)+      AuthorizeAction.init(s)       .setAll(""keycloakServer"" -> TestConfig.serverUrisIterator.next(),-        ""state"" -> Util.randomUUID(),-        ""wrongPasswordCount"" -> new AtomicInteger(TestConfig.badLoginAttempts),-        ""refreshTokenCount"" -> new AtomicInteger(TestConfig.refreshTokenCount),-        ""realm"" -> realm,-        ""username"" -> userInfo.username,-        ""password"" -> userInfo.password,-        ""clientId"" -> clientInfo.clientId,-        ""secret"" -> clientInfo.secret,-        ""appUrl"" -> clientInfo.appUrl+              ""state"" -> Util.randomUUID(),+              ""wrongPasswordCount"" -> new AtomicInteger(TestConfig.badLoginAttempts),+              ""refreshTokenCount"" -> new AtomicInteger(TestConfig.refreshTokenCount),+              ""realm"" -> realm,+              ""username"" -> userInfo.username,+              ""password"" -> userInfo.password,+              ""clientId"" -> clientInfo.clientId,+              ""secret"" -> clientInfo.secret,+              ""appUrl"" -> clientInfo.appUrl       )     })-    .exitHereIfFailed-    .exec(http(""Browser to Log In Endpoint"")-      .get(LOGIN_ENDPOINT)-      .headers(UI_HEADERS)-      .queryParam(""login"", ""true"")-      .queryParam(""response_type"", ""code"")-      .queryParam(""client_id"", ""${clientId}"")-      .queryParam(""state"", ""${state}"")-      .queryParam(""redirect_uri"", ""${appUrl}"")-      .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))+  .exitHereIfFailed+  .exec(http(""Browser to Log In Endpoint"")+        .get(LOGIN_ENDPOINT)+        .headers(UI_HEADERS)+        .queryParam(""login"", ""true"")+        .queryParam(""response_type"", ""code"")+        .queryParam(""client_id"", ""${clientId}"")+        .queryParam(""state"", ""${state}"")+        .queryParam(""redirect_uri"", ""${appUrl}"")+        .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))+  .exitHereIfFailed+  .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))++  .asLongAs(s => downCounterAboveZero(s, ""wrongPasswordCount"")) {+    exec(http(""Browser posts wrong credentials"")+         .post(""${login-form-uri}"")+         .headers(UI_HEADERS)+         .formParam(""username"", ""${username}"")+         .formParam(""password"", _ => Util.randomString(10))+         .formParam(""login"", ""Log in"")+         .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))     .exitHereIfFailed     .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))+  } -    .asLongAs(s => downCounterAboveZero(s, ""wrongPasswordCount"")) {-      exec(http(""Browser posts wrong credentials"")+  // Successful login+  .exec(http(""Browser posts correct credentials"")         .post(""${login-form-uri}"")         .headers(UI_HEADERS)         .formParam(""username"", ""${username}"")-        .formParam(""password"", _ => Util.randomString(10))+        .formParam(""password"", ""${password}"")         .formParam(""login"", ""Log in"")-        .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))-        .exitHereIfFailed-        .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))-    }--    // Successful login-    .exec(http(""Browser posts correct credentials"")-      .post(""${login-form-uri}"")-      .headers(UI_HEADERS)-      .formParam(""username"", ""${username}"")-      .formParam(""password"", ""${password}"")-      .formParam(""login"", ""Log in"")-      .check(status.is(302), header(""Location"").saveAs(""login-redirect"")))-    .exitHereIfFailed---    // Now act as client adapter - exchange code for keys-    .exec(oauth(""Adapter exchanges code for tokens"")-      .authorize(""${login-redirect}"",-      session => List(new Cookie(""OAuth_Token_Request_State"", session(""state"").as[String], 0, null, null)))-      .authServerUrl(""${keycloakServer}"")-      .resource(""${clientId}"")-      .clientCredentials(""${secret}"")-      .realm(""${realm}"")-    //.realmKey(Loader.realmRepresentation.getPublicKey)-    )--    // Refresh token several times-    .asLongAs(s => downCounterAboveZero(s, ""refreshTokenCount"")) {-      pause(TestConfig.refreshTokenPeriod, Normal(TestConfig.refreshTokenPeriod * 0.2))-      .exec(oauth(""Adapter refreshes token"").refresh())-    }+        .check(status.is(302), header(""Location"").saveAs(""login-redirect"")))+  .exitHereIfFailed+++  // Now act as client adapter - exchange code for keys+  .exec(oauth(""Adapter exchanges code for tokens"")+        .authorize(""${login-redirect}"",+                   session => List(new Cookie(""OAuth_Token_Request_State"", session(""state"").as[String], 0, null, null)))+        .authServerUrl(""${keycloakServer}"")+        .resource(""${clientId}"")+        .clientCredentials(""${secret}"")+        .realm(""${realm}"")+        //.realmKey(Loader.realmRepresentation.getPublicKey)+  )++  // Refresh token several times+  .asLongAs(s => downCounterAboveZero(s, ""refreshTokenCount"")) {+    pause(TestConfig.refreshTokenPeriod, Normal(TestConfig.refreshTokenPeriod * 0.2))+    .exec(oauth(""Adapter refreshes token"").refresh())+  } -    // Logout-    .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))-    .exec(http(""Browser logout"")-      .get(LOGOUT_ENDPOINT)-      .headers(UI_HEADERS)-      .queryParam(""redirect_uri"", ""${appUrl}"")-      .check(status.is(302), header(""Location"").is(""${appUrl}"")))+  // Logout+  .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))+  .exec(http(""Browser logout"")+        .get(LOGOUT_ENDPOINT)+        .headers(UI_HEADERS)+        .queryParam(""redirect_uri"", ""${appUrl}"")+        .check(status.is(302), header(""Location"").is(""${appUrl}"")))    val usersScenario = scenario(""users"")-    .repeat(TestConfig.numOfIterations) {-      userSession-    }--  setUp(usersScenario.inject( {-    if (TestConfig.rampUpPeriod > 0) {-      rampUsers(TestConfig.runUsers) over TestConfig.rampUpPeriod-    } else {-      atOnceUsers(TestConfig.runUsers)-    }-  }).protocols(httpDefault))--+  .asLongAs(s => rampDownPeriodNotReached(), null, TestConfig.rampDownASAP) {+    pace(TestConfig.pace)","The `pace` parameter adds an additional dynamic pause buffer. For example if a scenario takes 20s and the `pace` is set to 30s, the loop will wait additional 10s before the next iteration. (If the pace is shorter than the duration of the scenario, for example if it's set to 0, no additional pause will be added.)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4684,151418346,2017-11-16T13:54:45Z,testsuite/performance/README.md,"@@ -70,47 +70,74 @@ Provisioning/teardown is performed via `docker-compose` tool. More details in [R  ### Generate Test Data -Usage: `mvn verify -Pgenerate-data[,cluster] [-Ddataset=DATASET] [-Dexport-dump] [-D<dataset.property>=<value>]`.+Usage: `mvn verify -Pgenerate-data[,cluster] [-Ddataset=DATASET] [-D<dataset.property>=<value>] [-Dexport-dump]`.  Dataset properties are loaded from `datasets/${dataset}.properties` file. Individual properties can be overriden by specifying `-D` params.  Dataset data is first generated as a .json file, and then imported into Keycloak via Admin Client REST API. +#### Dataset Properties++| Property | Description | Value in the Default Dataset |+| --- | --- | --- | +| `numOfRealms` | Number of realms to be created. | `1`  |+| `usersPerRealm` | Number of users per realm. | `100`  |+| `clientsPerRealm` | Number of clients per realm. | `2`  |+| `realmRoles` | Number of realm-roles per realm. | `2`  |+| `realmRolesPerUser` | Number of realm-roles assigned to a created user. Has to be less than or equal to `realmRoles`. | `2`  |+| `clientRolesPerUser` | Number of client-roles assigned to a created user. Has to be less than or equal to `clientsPerRealm * clientRolesPerClient`. | `2`  |+| `clientRolesPerClient` | Number of client-roles per created client. | `2`  |+| `hashIterations` | Number of password hashing iterations. | `27500`  |++ #### Examples: - `mvn verify -Pgenerate-data` - generate default dataset - `mvn verify -Pgenerate-data -DusersPerRealm=5` - generate default dataset, override the `usersPerRealm` property - `mvn verify -Pgenerate-data -Ddataset=100u` - generate `100u` dataset - `mvn verify -Pgenerate-data -Ddataset=100r/default` - generate dataset based on `datasets/100r/default.properties` -The data can also be exported from the database, and stored locally as `datasets/${dataset}.sql.gz`-`DATASET=100u ./prepare-dump.sh`+#### Export / Import Database Dump  To speed up dataset initialization part, it is possible to pass `-Dexport-dump` option to have the generated dataset exported right after it has been generated. Then, if there is a data dump file available then `-Pimport-dump`  can be used to import the data directly into the database, bypassing Keycloak server completely. -Usage: `mvn verify -Pimport-dump [-Ddataset=DATASET]`+**Usage:** `mvn verify -Pimport-dump [-Ddataset=DATASET]` -#### Example:-- `mvn verify -Pimport-dump -Ddataset=100u` - import `datasets/100u.sql.gz` dump file created using `prepare-dump.sh`.+**For example:**+- `mvn verify -Pgenerate-data -Ddataset=100u -Dexport-dump` will generate data based on `datasets/100u.properties` and export a database dump to a file: `datasets/100u.sql.gz`.+- `mvn verify -Pimport-dump -Ddataset=100u` will import the database dump from a file: `datasets/100u.sql.gz`, and reboot the server(s)   ### Run Tests -Usage: `mvn verify -Ptest[,cluster] [-DrunUsers=N] [-DrampUpPeriod=SECONDS] [-DnumOfIterations=N] [-Ddataset=DATASET] [-D<dataset.property>=<value>]* [-D<test.property>=<value>]* `.+Usage: `mvn verify -Ptest[,cluster] [-DtestParameter=value]`. -_*Note:* The same dataset properties which were used for data generation/import should be supplied to the `test` phase._+#### Common Parameters -The default test `keycloak.DefaultSimulation` takes the following additional properties:+| Parameter | Description | Default Value |+| --- | --- | --- | +| `gatling.simulationClass` | Classname of the simulation to be run. | `keycloak.DefaultSimulation`  |+| `dataset` | Name of the dataset to use. (Individual dataset properties can be overridden with `-Ddataset.property=value`.) | `default` |+| `runUsers` | Number of users for the simulation run. | `1` |+| `rampUpPeriod` | Period during which the users will be ramped up. (seconds) | `0` |+| `steadyLoadPeriod` | A period of steady load. (seconds) | `30` |+| `rampDownASAP` | When `true` the test will be checking for ramp-down condition after each *scenario step*. When `false` the check will be done only at the end of a *scenario iteration*. | `false` |+| `pace` | A dynamic pause after each *scenario iteration*. For example if the pace is 30s and one scenario iteration takes only 20s, the simulation will wait additional 10s before continuing to the next iteration. | `0` |","This *pace* parameter completely spoils the results. That means that if there were 3000 requests within 20 seconds, then 10 seconds of ""pace"", the result is 3000/*30* = 1000 req/s instead of 3000/*20* = 1500 req/s.",
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4684,151430430,2017-11-16T14:39:33Z,testsuite/performance/tests/src/test/scala/keycloak/DefaultSimulation.scala,"@@ -54,100 +49,94 @@ class DefaultSimulation extends Simulation {   val ACCEPT_ALL = Map(""Accept"" -> ""*/*"")    val userSession = exec(s => {-    // initialize session with host, user, client app, login failure ratio ...-    val realm = TestConfig.randomRealmsIterator().next()-    val userInfo = TestConfig.getUsersIterator(realm).next()-    val clientInfo = TestConfig.getConfidentialClientsIterator(realm).next()+      // initialize session with host, user, client app, login failure ratio ...+      val realm = TestConfig.randomRealmsIterator().next()+      val userInfo = TestConfig.getUsersIterator(realm).next()+      val clientInfo = TestConfig.getConfidentialClientsIterator(realm).next() -    AuthorizeAction.init(s)+      AuthorizeAction.init(s)       .setAll(""keycloakServer"" -> TestConfig.serverUrisIterator.next(),-        ""state"" -> Util.randomUUID(),-        ""wrongPasswordCount"" -> new AtomicInteger(TestConfig.badLoginAttempts),-        ""refreshTokenCount"" -> new AtomicInteger(TestConfig.refreshTokenCount),-        ""realm"" -> realm,-        ""username"" -> userInfo.username,-        ""password"" -> userInfo.password,-        ""clientId"" -> clientInfo.clientId,-        ""secret"" -> clientInfo.secret,-        ""appUrl"" -> clientInfo.appUrl+              ""state"" -> Util.randomUUID(),+              ""wrongPasswordCount"" -> new AtomicInteger(TestConfig.badLoginAttempts),+              ""refreshTokenCount"" -> new AtomicInteger(TestConfig.refreshTokenCount),+              ""realm"" -> realm,+              ""username"" -> userInfo.username,+              ""password"" -> userInfo.password,+              ""clientId"" -> clientInfo.clientId,+              ""secret"" -> clientInfo.secret,+              ""appUrl"" -> clientInfo.appUrl       )     })-    .exitHereIfFailed-    .exec(http(""Browser to Log In Endpoint"")-      .get(LOGIN_ENDPOINT)-      .headers(UI_HEADERS)-      .queryParam(""login"", ""true"")-      .queryParam(""response_type"", ""code"")-      .queryParam(""client_id"", ""${clientId}"")-      .queryParam(""state"", ""${state}"")-      .queryParam(""redirect_uri"", ""${appUrl}"")-      .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))+  .exitHereIfFailed+  .exec(http(""Browser to Log In Endpoint"")+        .get(LOGIN_ENDPOINT)+        .headers(UI_HEADERS)+        .queryParam(""login"", ""true"")+        .queryParam(""response_type"", ""code"")+        .queryParam(""client_id"", ""${clientId}"")+        .queryParam(""state"", ""${state}"")+        .queryParam(""redirect_uri"", ""${appUrl}"")+        .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))+  .exitHereIfFailed+  .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))++  .asLongAs(s => downCounterAboveZero(s, ""wrongPasswordCount"")) {+    exec(http(""Browser posts wrong credentials"")+         .post(""${login-form-uri}"")+         .headers(UI_HEADERS)+         .formParam(""username"", ""${username}"")+         .formParam(""password"", _ => Util.randomString(10))+         .formParam(""login"", ""Log in"")+         .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))     .exitHereIfFailed     .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))+  } -    .asLongAs(s => downCounterAboveZero(s, ""wrongPasswordCount"")) {-      exec(http(""Browser posts wrong credentials"")+  // Successful login+  .exec(http(""Browser posts correct credentials"")         .post(""${login-form-uri}"")         .headers(UI_HEADERS)         .formParam(""username"", ""${username}"")-        .formParam(""password"", _ => Util.randomString(10))+        .formParam(""password"", ""${password}"")         .formParam(""login"", ""Log in"")-        .check(status.is(200), regex(""action=\""([^\""]*)\"""").find.transform(_.replaceAll(""&amp;"", ""&"")).saveAs(""login-form-uri"")))-        .exitHereIfFailed-        .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))-    }--    // Successful login-    .exec(http(""Browser posts correct credentials"")-      .post(""${login-form-uri}"")-      .headers(UI_HEADERS)-      .formParam(""username"", ""${username}"")-      .formParam(""password"", ""${password}"")-      .formParam(""login"", ""Log in"")-      .check(status.is(302), header(""Location"").saveAs(""login-redirect"")))-    .exitHereIfFailed---    // Now act as client adapter - exchange code for keys-    .exec(oauth(""Adapter exchanges code for tokens"")-      .authorize(""${login-redirect}"",-      session => List(new Cookie(""OAuth_Token_Request_State"", session(""state"").as[String], 0, null, null)))-      .authServerUrl(""${keycloakServer}"")-      .resource(""${clientId}"")-      .clientCredentials(""${secret}"")-      .realm(""${realm}"")-    //.realmKey(Loader.realmRepresentation.getPublicKey)-    )--    // Refresh token several times-    .asLongAs(s => downCounterAboveZero(s, ""refreshTokenCount"")) {-      pause(TestConfig.refreshTokenPeriod, Normal(TestConfig.refreshTokenPeriod * 0.2))-      .exec(oauth(""Adapter refreshes token"").refresh())-    }+        .check(status.is(302), header(""Location"").saveAs(""login-redirect"")))+  .exitHereIfFailed+++  // Now act as client adapter - exchange code for keys+  .exec(oauth(""Adapter exchanges code for tokens"")+        .authorize(""${login-redirect}"",+                   session => List(new Cookie(""OAuth_Token_Request_State"", session(""state"").as[String], 0, null, null)))+        .authServerUrl(""${keycloakServer}"")+        .resource(""${clientId}"")+        .clientCredentials(""${secret}"")+        .realm(""${realm}"")+        //.realmKey(Loader.realmRepresentation.getPublicKey)+  )++  // Refresh token several times+  .asLongAs(s => downCounterAboveZero(s, ""refreshTokenCount"")) {+    pause(TestConfig.refreshTokenPeriod, Normal(TestConfig.refreshTokenPeriod * 0.2))+    .exec(oauth(""Adapter refreshes token"").refresh())+  } -    // Logout-    .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))-    .exec(http(""Browser logout"")-      .get(LOGOUT_ENDPOINT)-      .headers(UI_HEADERS)-      .queryParam(""redirect_uri"", ""${appUrl}"")-      .check(status.is(302), header(""Location"").is(""${appUrl}"")))+  // Logout+  .pause(TestConfig.userThinkTime, Normal(TestConfig.userThinkTime * 0.2))+  .exec(http(""Browser logout"")+        .get(LOGOUT_ENDPOINT)+        .headers(UI_HEADERS)+        .queryParam(""redirect_uri"", ""${appUrl}"")+        .check(status.is(302), header(""Location"").is(""${appUrl}"")))    val usersScenario = scenario(""users"")-    .repeat(TestConfig.numOfIterations) {-      userSession-    }--  setUp(usersScenario.inject( {-    if (TestConfig.rampUpPeriod > 0) {-      rampUsers(TestConfig.runUsers) over TestConfig.rampUpPeriod-    } else {-      atOnceUsers(TestConfig.runUsers)-    }-  }).protocols(httpDefault))--+  .asLongAs(s => rampDownPeriodNotReached(), null, TestConfig.rampDownASAP) {+    pace(TestConfig.pace)","This is an optional parameter which lets us add additional pacing to the scenario, if needed. It's not directly related to KEYCLOAK-5372.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4739,152931721,2017-11-24T09:54:08Z,testsuite/performance/.gitignore,"@@ -0,0 +1,3 @@+docker-compose-cluster.yml+docker-compose-crossdc.yml+provisioned-system.properties",The files need to be excluded by full path not to affect any similarly named file in other directory.Note that the files should be generated to `target` directory and docker-compose should be run from within that dir.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4739,152936782,2017-11-24T10:20:15Z,testsuite/performance/docker-compose/crossdc/docker-compose-base.yml,"@@ -0,0 +1,154 @@+version: ""2.2""++networks:+    # DC 1+    dc1_keycloak:+        ipam:+            config:+            - subnet: 10.1.1.0/24+    # DC 2+    dc2_keycloak:+        ipam:+            config:+            - subnet: 10.2.1.0/24+#    # cross-DC+#    loadbalancing:+#        ipam:+#            config:+#            - subnet: 10.0.2.0/24+    # cross-DC+    db_replication:+        ipam:+            config:+            - subnet: 10.0.3.0/24+    # cross-DC+    ispn_replication:+        ipam:+            config:+            - subnet: 10.0.4.0/24+        +services:++    infinispan_dc1:+        build: +            context: infinispan+            args:+                LOCAL_SITE: dc1+                REMOTE_SITE: dc2+        image: keycloak_test_infinispan_dc1:${KEYCLOAK_VERSION:-latest}+        cpuset: ${INFINISPAN_DC1_CPUSET:-1}+        mem_limit: ${INFINISPAN_MEMLIMIT:-1g}+        networks:+            - ispn_replication+            - dc1_keycloak+        environment:+            PUBLIC_SUBNET: 10.1.1.0/24+            PRIVATE_SUBNET: 10.0.4.0/24+            MGMT_USER: admin+            MGMT_USER_PASSWORD: admin+            TCP_PING_INITIAL_HOSTS: infinispan_dc1[7600]+            JAVA_OPTS: ${INFINISPAN_JVM_MEMORY:--Xms64m -Xmx512m -XX:MetaspaceSize=96M -XX:MaxMetaspaceSize=256m -XX:+DisableExplicitGC} -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true+        ports:+            - ""9991:9990""++    infinispan_dc2:+        build: +            context: infinispan+            args:+                LOCAL_SITE: dc2+                REMOTE_SITE: dc1+        image: keycloak_test_infinispan_dc2:${KEYCLOAK_VERSION:-latest}+        depends_on:+            infinispan_dc1:+                condition: service_healthy+        cpuset: ${INFINISPAN_DC2_CPUSET:-1}+        mem_limit: ${INFINISPAN_MEMLIMIT:-1g}+        networks:+            - ispn_replication+            - dc2_keycloak+        environment:+            PUBLIC_SUBNET: 10.2.1.0/24+            PRIVATE_SUBNET: 10.0.4.0/24+            MGMT_USER: admin+            MGMT_USER_PASSWORD: admin+            TCP_PING_INITIAL_HOSTS: infinispan_dc1[7600],infinispan_dc2[7600]+            JAVA_OPTS: ${INFINISPAN_JVM_MEMORY:--Xms64m -Xmx512m -XX:MetaspaceSize=96M -XX:MaxMetaspaceSize=256m -XX:+DisableExplicitGC} -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true","would 512m be enough? It needs to hold all the cache contents. Better use larger default, maybe 1g",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4739,152938272,2017-11-24T10:27:39Z,testsuite/performance/README.md,"@@ -47,30 +47,36 @@ Keep reading for more information.  ## Provisioning +### Available provisioners:++- `docker-compose` *Default.* See [`docker-compose/README.md`](docker-compose/README.md) for more details.+ ### Provision -Usage: `mvn verify -Pprovision[,cluster] [-D<PARAM>=<VALUE> ...]`. +Usage: `mvn verify -Pprovision [-Dprovisioner=<PROVISIONER>] [-D<PARAMETER>=<VALUE>] `.  -- Single node deployment: `mvn verify -Pprovision`-- Cluster deployment: `mvn verify -Pprovision,cluster [-Dkeycloak.scale=N]`. Default `N=1`.+- Single node: `mvn verify -Pprovision`+- Cluster: `mvn verify -Pprovision,cluster [-Dkeycloak.scale=N] [-Dkeycloak.cpusets=""cpuset1 cpuset2  cpusetM""]`. `N  {1 .. M}`.","Can't keycloak.scale be clearly derived from keycloak.cpusets (number of elements)?Having two properties that are linked in this manner is too error-prone. I'd be much surprised that by setting  `keycloak.cpusets` to `4-7 8-11 12-15 16-19`, still the cluster does not use more than 2 instances (because I accidentally forgot to specify `keycloak.scale`).Please follow [KISS principle](https://en.wikipedia.org/wiki/KISS_principle).",X
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4739,152946129,2017-11-24T11:08:21Z,testsuite/performance/README.md,"@@ -47,30 +47,36 @@ Keep reading for more information.  ## Provisioning +### Available provisioners:++- `docker-compose` *Default.* See [`docker-compose/README.md`](docker-compose/README.md) for more details.+ ### Provision -Usage: `mvn verify -Pprovision[,cluster] [-D<PARAM>=<VALUE> ...]`. +Usage: `mvn verify -Pprovision [-Dprovisioner=<PROVISIONER>] [-D<PARAMETER>=<VALUE>] `.  -- Single node deployment: `mvn verify -Pprovision`-- Cluster deployment: `mvn verify -Pprovision,cluster [-Dkeycloak.scale=N]`. Default `N=1`.+- Single node: `mvn verify -Pprovision`+- Cluster: `mvn verify -Pprovision,cluster [-Dkeycloak.scale=N] [-Dkeycloak.cpusets=""cpuset1 cpuset2  cpusetM""]`. `N  {1 .. M}`.","I was considering merging those two parameters but in the end I decided not to. I would prefer to keep them separate because 1) the cpusets parameter is only used to derive the maximum scale to which we may want to scale up gradually, and 2) cpusets are docker-specific. In bare-metal lab or cloud the maximum scale can be derived from the list of remote hosts instead of cpusets.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4739,152983288,2017-11-24T14:41:13Z,testsuite/performance/README.md,"@@ -47,30 +47,36 @@ Keep reading for more information.  ## Provisioning +### Available provisioners:++- `docker-compose` *Default.* See [`docker-compose/README.md`](docker-compose/README.md) for more details.+ ### Provision -Usage: `mvn verify -Pprovision[,cluster] [-D<PARAM>=<VALUE> ...]`. +Usage: `mvn verify -Pprovision [-Dprovisioner=<PROVISIONER>] [-D<PARAMETER>=<VALUE>] `.  -- Single node deployment: `mvn verify -Pprovision`-- Cluster deployment: `mvn verify -Pprovision,cluster [-Dkeycloak.scale=N]`. Default `N=1`.+- Single node: `mvn verify -Pprovision`+- Cluster: `mvn verify -Pprovision,cluster [-Dkeycloak.scale=N] [-Dkeycloak.cpusets=""cpuset1 cpuset2  cpusetM""]`. `N  {1 .. M}`.","Ad 1) That should be taken care of by the runner script e.g. by including more and more cpusets, not left to the user to learn the hard wayAd 2) In that case these parameters should be described in docker-compose/README.md, not in generic testsuite/performance/README.mdThe current way is too prone to human error. Please reconsider your decision.",
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/4739,153728457,2017-11-29T09:15:22Z,testsuite/performance/README.md,"@@ -47,30 +47,36 @@ Keep reading for more information.  ## Provisioning +### Available provisioners:++- `docker-compose` *Default.* See [`docker-compose/README.md`](docker-compose/README.md) for more details.+ ### Provision -Usage: `mvn verify -Pprovision[,cluster] [-D<PARAM>=<VALUE> ...]`. +Usage: `mvn verify -Pprovision [-Dprovisioner=<PROVISIONER>] [-D<PARAMETER>=<VALUE>] `.  -- Single node deployment: `mvn verify -Pprovision`-- Cluster deployment: `mvn verify -Pprovision,cluster [-Dkeycloak.scale=N]`. Default `N=1`.+- Single node: `mvn verify -Pprovision`+- Cluster: `mvn verify -Pprovision,cluster [-Dkeycloak.scale=N] [-Dkeycloak.cpusets=""cpuset1 cpuset2  cpusetM""]`. `N  {1 .. M}`.","This should be solved, see README.provisioning-parameters.md --> Service Parameters --> Keycloak Server.",
546680,pskopek,https://api.github.com/repos/keycloak/keycloak/pulls/4833,156606673,2017-12-13T09:49:18Z,saml-core/src/main/java/org/keycloak/saml/common/util/StaxParserUtil.java,"@@ -75,24 +78,58 @@ public static void validate(InputStream doc, InputStream sch) throws ParsingExce     }      /**-     * Bypass an entire XML element block from startElement to endElement+     * Bypass an entire XML element block from startElement to endElement.+     * It is expected that the {@code xmlEventReader} is positioned at (has not yet read)+     * the start element of the block it should bypass.      *      * @param xmlEventReader      * @param tag Tag of the XML element that we need to bypass      *      * @throws org.keycloak.saml.common.exceptions.ParsingException      */     public static void bypassElementBlock(XMLEventReader xmlEventReader, String tag) throws ParsingException {-        while (xmlEventReader.hasNext()) {-            EndElement endElement = getNextEndElement(xmlEventReader);-            if (endElement == null)-                return;+        XMLEvent xmlEvent = bypassElementBlock(xmlEventReader); -            if (StaxParserUtil.matches(endElement, tag))-                return;+        if (! Objects.equals(((EndElement) xmlEvent).getName().getLocalPart(), tag)) {","bypassElementBlock(xmlEventReader) can return null which will lead to NPE.I suggest to test it for null and throw parsing exception (something like ""no more markup events"").",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4853,157039016,2017-12-14T19:27:30Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LogoutTest.java,"@@ -235,4 +238,22 @@ public void logoutUserByAdmin() {         }, 10, 200);     } ++    // KEYCLOAK-5982+    @Test+    public void testLogoutWhenAccountClientRenamed() {+        // Rename client ""account""","To prevent accidental failure of cleanup, needs to be `try { } finally { }` block or, even better, use [`ClientAttributeUpdater`](https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/updaters/ClientAttributeUpdater.java) enhanced with ""setClientId"" method (see e.g. [here](https://github.com/keycloak/keycloak/blob/ffc0d7fc7cf88ddc9af21be50151374441e78b60/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcSamlSignedBrokerTest.java#L139) for a sample)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4828,157178433,2017-12-15T11:23:32Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/AbstractExtendableRevisioned.java,"@@ -16,14 +16,36 @@  */ package org.keycloak.models.cache.infinispan.entities; +import org.jboss.logging.Logger;+ import java.util.concurrent.ConcurrentHashMap;+import java.util.concurrent.TimeUnit;+import java.util.concurrent.atomic.AtomicInteger;+import java.util.concurrent.locks.Condition;+import java.util.concurrent.locks.ReentrantLock;+  /**  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>  * @version $Revision: 1 $  */ public abstract class AbstractExtendableRevisioned extends AbstractRevisioned {-    protected ConcurrentHashMap cachedWith = new ConcurrentHashMap();++    private static final int UNINITIALISED = 0;+    private static final int INITIALISING = 1;+    private static final int INITIALISED = 2;++    private static Logger logger = Logger.getLogger(AbstractExtendableRevisioned.class);++    private static ThreadLocal<Boolean> weInitTL = ThreadLocal.withInitial(() -> false);++    protected CoordinatingMap cachedWith = new CoordinatingMap(this);","Due to lack of time, I'd rather have the changes in this sensitive part as conservative as possible. Hence while I believe introducing the `CoordinatingMap` might be good long-term, we might want to omit this now since that adds too much new untested complexity. For 3.4.2 to get ready soon, the original approach seemed to fix the most likely causes.(I'd even rather only add the `AtomicBoolean initialized` to the AbstractExtendableRevisioned and have the ReentrantLock be allocated dynamically by some per-user lock provider, but that optimization I'd leave for 4.x.)The `CoordinatingMap` also increases memory footprint compared to the `ConcurrentHashMap` which, together with three new properties, can negatively impact the performance since the number of users might be very large so we should try to keep the object as light memory-wise as possible.",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/4828,157430811,2017-12-18T09:14:14Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/AbstractExtendableRevisioned.java,"@@ -16,14 +16,36 @@  */ package org.keycloak.models.cache.infinispan.entities; +import org.jboss.logging.Logger;+ import java.util.concurrent.ConcurrentHashMap;+import java.util.concurrent.TimeUnit;+import java.util.concurrent.atomic.AtomicInteger;+import java.util.concurrent.locks.Condition;+import java.util.concurrent.locks.ReentrantLock;+  /**  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>  * @version $Revision: 1 $  */ public abstract class AbstractExtendableRevisioned extends AbstractRevisioned {-    protected ConcurrentHashMap cachedWith = new ConcurrentHashMap();++    private static final int UNINITIALISED = 0;+    private static final int INITIALISING = 1;+    private static final int INITIALISED = 2;++    private static Logger logger = Logger.getLogger(AbstractExtendableRevisioned.class);++    private static ThreadLocal<Boolean> weInitTL = ThreadLocal.withInitial(() -> false);++    protected CoordinatingMap cachedWith = new CoordinatingMap(this);","`CoordinatingMap` could indeed impact performance, hard to tell without doing some performance metrics. Its current implementation uses inheritance, but it would be better to use delegation approach so ensureInited() will be guaranteed to only be called once for every method - I'll change the implementation.About `ReentrantLock` I don't see how you can optimise it with lazy init (if I understand correctly) since that would in itself require an extra locking object as you need multiple threads to share the same instance of the lock.The benefit of `CoordinatingMap` is that it should (properly done) fix the problem completely -  no need for CredentialProvider to call `ensureInited()` before accessing `cachedWith`. But yes, for now we can find all CredentialProviders and fix their code. That won't fix race condition for any third party custom providers.@hmlnarik If I understand correctly you prefer for now my original PR proposal with synchronised blocks and without CoordinatingMap, and suggest to have a CoordinatingMap + ReentrantLock implementation in some branch and working on performance testing it?",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/4901,159420612,2018-01-03T13:07:45Z,services/src/test/java/org/keycloak/utils/TimePeriodFormatterTest.java,"@@ -0,0 +1,102 @@+/*+ * JBoss, Home of Professional Open Source+ * Copyright 2018 Red Hat Inc. and/or its affiliates and other contributors+ * as indicated by the @authors tag. All rights reserved.+ */+package org.keycloak.utils;++import org.junit.Assert;+import org.junit.Test;++/**+ * Unit test for {@link TimePeriodFormatter}+ *+ * @author Vlastimil Elias (velias at redhat dot com)+ */+public class TimePeriodFormatterTest {++    @Test+    public void second_zero() {+        TimePeriodFormatter tested = new TimePeriodFormatter(0);+        assertFormat(tested, 0, ""seconds"");+    }++    @Test+    public void second_one() {+        TimePeriodFormatter tested = new TimePeriodFormatter(1);+        assertFormat(tested, 1, ""second"");+    }++    @Test+    public void second_more() {+        TimePeriodFormatter tested = new TimePeriodFormatter(2);+        assertFormat(tested, 2, ""seconds"");+        tested = new TimePeriodFormatter(5);+        assertFormat(tested, 5, ""seconds"");+        tested = new TimePeriodFormatter(24);+        assertFormat(tested, 24, ""seconds"");+        tested = new TimePeriodFormatter(59);+        assertFormat(tested, 59, ""seconds"");+        tested = new TimePeriodFormatter(61);+        assertFormat(tested, 61, ""seconds"");+    }++    @Test+    public void minute_one() {+        TimePeriodFormatter tested = new TimePeriodFormatter(60);+        assertFormat(tested, 1, ""minute"");+    }++    @Test+    public void minute_more() {+        TimePeriodFormatter tested = new TimePeriodFormatter(2 * 60);+        assertFormat(tested, 2, ""minutes"");+        tested = new TimePeriodFormatter(5 * 60);+        assertFormat(tested, 5, ""minutes"");+        tested = new TimePeriodFormatter(24 * 60);+        assertFormat(tested, 24, ""minutes"");+        tested = new TimePeriodFormatter(59 * 60);+        assertFormat(tested, 59, ""minutes"");+        tested = new TimePeriodFormatter(61 * 60);+        assertFormat(tested, 61, ""minutes"");+    }++    @Test+    public void hour_one() {+        TimePeriodFormatter tested = new TimePeriodFormatter(60 * 60);+        assertFormat(tested, 1, ""hour"");+    }++    @Test+    public void hour_more() {+        TimePeriodFormatter tested = new TimePeriodFormatter(2 * 60 * 60);+        assertFormat(tested, 2, ""hours"");","Current implementation is aligned with Admin GUI, it also uses only one unit. These more complicated formats should bring even bigger burden to the i18n using current Freemarker templating engine. I'm really not sure if they should be in basic implementation which is OK for most cases.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4901,159453284,2018-01-03T15:37:09Z,services/src/test/java/org/keycloak/utils/TimePeriodFormatterTest.java,"@@ -0,0 +1,102 @@+/*+ * JBoss, Home of Professional Open Source+ * Copyright 2018 Red Hat Inc. and/or its affiliates and other contributors+ * as indicated by the @authors tag. All rights reserved.+ */+package org.keycloak.utils;++import org.junit.Assert;+import org.junit.Test;++/**+ * Unit test for {@link TimePeriodFormatter}+ *+ * @author Vlastimil Elias (velias at redhat dot com)+ */+public class TimePeriodFormatterTest {++    @Test+    public void second_zero() {+        TimePeriodFormatter tested = new TimePeriodFormatter(0);+        assertFormat(tested, 0, ""seconds"");+    }++    @Test+    public void second_one() {+        TimePeriodFormatter tested = new TimePeriodFormatter(1);+        assertFormat(tested, 1, ""second"");+    }++    @Test+    public void second_more() {+        TimePeriodFormatter tested = new TimePeriodFormatter(2);+        assertFormat(tested, 2, ""seconds"");+        tested = new TimePeriodFormatter(5);+        assertFormat(tested, 5, ""seconds"");+        tested = new TimePeriodFormatter(24);+        assertFormat(tested, 24, ""seconds"");+        tested = new TimePeriodFormatter(59);+        assertFormat(tested, 59, ""seconds"");+        tested = new TimePeriodFormatter(61);+        assertFormat(tested, 61, ""seconds"");+    }++    @Test+    public void minute_one() {+        TimePeriodFormatter tested = new TimePeriodFormatter(60);+        assertFormat(tested, 1, ""minute"");+    }++    @Test+    public void minute_more() {+        TimePeriodFormatter tested = new TimePeriodFormatter(2 * 60);+        assertFormat(tested, 2, ""minutes"");+        tested = new TimePeriodFormatter(5 * 60);+        assertFormat(tested, 5, ""minutes"");+        tested = new TimePeriodFormatter(24 * 60);+        assertFormat(tested, 24, ""minutes"");+        tested = new TimePeriodFormatter(59 * 60);+        assertFormat(tested, 59, ""minutes"");+        tested = new TimePeriodFormatter(61 * 60);+        assertFormat(tested, 61, ""minutes"");+    }++    @Test+    public void hour_one() {+        TimePeriodFormatter tested = new TimePeriodFormatter(60 * 60);+        assertFormat(tested, 1, ""hour"");+    }++    @Test+    public void hour_more() {+        TimePeriodFormatter tested = new TimePeriodFormatter(2 * 60 * 60);+        assertFormat(tested, 2, ""hours"");","That is my point. I'd rather think this through before accepting implementation of this feature.One way would be to introduce FreeMarker method e.g. `secondsToHumanReadable` (similarly to `msg`). So for example, the email-verification.ftl would read```${msg(""emailVerificationBodyHtml"", link, secondsToHumanReadable(linkExpiration), realmName)?no_esc}```There will be entry in messages_en.properties that would contain SPI name for the given language family```secondsToHumanReadable=default```The value of `secondsToHumanReadable` could then be `slavic`, `chinese` etc. The implementation of `secondsToHumanReadable` would look up the SPI by name (using `default` as fallback) and the other entries in the `messages_en.properties` would depend on this SPI requirements. For `default` implementation handling only singlular and plural, the entries would be e.g.:```timeUnitSecond=secondtimeUnitSeconds=secondstimeUnitMinute=minutetimeUnitMinutes=minutestimeUnitHour=hourtimeUnitHours=hourstimeUnitDay=daytimeUnitDays=daystimeUnitSeparator=, ```The provider method would be ""String getFormattedString(long seconds)"" where it would convert the seconds into the human readable string using the properties above, joining the partial times via timeUnitSeparator.This would be possible to use for English, German, French, etc. Similarly, for Slavic languages, there would be a single SPI with translations of ""hour(s)"", ""minute(s)"" etc. defined in the message_LL.properties. This would be possible to use for Czech, Slovak, Polish, Russian etc.It is more generic and would work for any language family, usually without necessity for the user to implement their own SPI.  ",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4917,161727403,2018-01-16T11:16:39Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/realm/RealmTest.java,"@@ -195,6 +196,36 @@ public void createRealmFromJson() {         adminClient.realms().realm(""admin-test-1"").remove();     } +    @Test+    public void createRealmWithPasswordPolicyFromJsonWithInvalidPasswords() {+        //try to create realm with password policies and users with plain-text passwords what doesn't met the policies+        RealmRepresentation rep = loadJson(getClass().getResourceAsStream(""/import/testrealm-keycloak-6146-error.json""), RealmRepresentation.class);+        +        boolean thrownBRException  = true;+                try {+            adminClient.realms().create(rep);+            thrownBRException = false;","Use `@Rule ExpectedException` instead, see e.g. https://github.com/keycloak/keycloak/blob/fd025ae76b96c0bc8798deb46b184115dd327fd0/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/group/GroupTest.java#L512",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/4915,161749128,2018-01-16T12:59:44Z,themes/src/main/resources/theme/base/account/totp.ftl,"@@ -30,7 +30,7 @@  <ol>     <li>-        <p>${msg(""totpStep1"")}</p>+        <p>${msg(""totpStep1"")?no_esc}</p>",There is no links in the message anymore as that has been removed:https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/base/account/messages/messages_en.properties#L101,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4908,161982806,2018-01-17T08:32:42Z,testsuite/performance/infinispan/pom.xml,"@@ -0,0 +1,213 @@+<?xml version=""1.0""?>+<!--+~ Copyright 2016 Red Hat, Inc. and/or its affiliates+~ and other contributors as indicated by the @author tags.+~+~ Licensed under the Apache License, Version 2.0 (the ""License"");+~ you may not use this file except in compliance with the License.+~ You may obtain a copy of the License at+~+~ http://www.apache.org/licenses/LICENSE-2.0+~+~ Unless required by applicable law or agreed to in writing, software+~ distributed under the License is distributed on an ""AS IS"" BASIS,+~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+~ See the License for the specific language governing permissions and+~ limitations under the License.+-->++<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>performance</artifactId>+        <version>4.0.0.CR1-SNAPSHOT</version>+        <relativePath>../pom.xml</relativePath>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>performance-keycloak-infinispan-server</artifactId>+    <name>Keycloak Performance TestSuite - Infinispan Server</name>+    <packaging>pom</packaging>+    +    <properties>+        <infinispan.groupId>org.infinispan.server</infinispan.groupId>+        <infinispan.artifactId>infinispan-server-build</infinispan.artifactId>+        <infinispan.version>8.2.8.Final</infinispan.version>",Can this use ${infinispan.version} from https://github.com/keycloak/keycloak/blob/master/pom.xml#L68?,X
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/4927,163035201,2018-01-22T19:01:19Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -32,7 +32,64 @@ </head>  <body class=""${properties.kcBodyClass!}"">-    <div id=""kc-logo""><a href=""${properties.kcLogoLink!'#'}""><div id=""kc-logo-wrapper""></div></a></div>+  <div class=""${properties.kcLoginClass!}"">+    <header class=""${properties.kcHeaderClass!}"">+      <a href=""${properties.kcLogoLink!'#'}"">+        <img class=""${properties.kcLogoClass!}"" src=""${url.resourcesPath}/img/keycloak-logo.png"" />","We should never point directly to an image.  Note how the line you deleted has <div id=""kc-logo-wrapper"">.  This class is in login.css under the Keycloak theme.  See https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/keycloak/login/resources/css/login.css#L77-L83.  Use kc-logo-wrapper instead of hard-coded keycloak-logo.png.This will allow customers to use their own logo by overriding login.css.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4932,163526519,2018-01-24T11:53:58Z,server-spi/src/main/java/org/keycloak/models/AuthenticationFlowBindings.java,"@@ -0,0 +1,28 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models;++/**+ * Defines constants for authentication flow bindings.  Strings used for lookup+ *+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>+ * @version $Revision: 1 $+ */+public interface AuthenticationFlowBindings {","Should this be rather turned into enum? Then the JPA `ClientEntity` class would use `@MapKeyEnumerated` rather than `@MapKeyColumn(EnumType.STRING)` and the `AuthenticationFlowResolver` methods could be implemented inside the enum:```javapublic enum AuthenticationFlowBindings {    BROWSER_BINDING {        @Override        public AuthenticationFlowModel resolveFlow(AuthenticationSessionModel authSession) {            ...        }    },    DIRECT_GRANT_BINDING {        @Override        public AuthenticationFlowModel resolveFlow(AuthenticationSessionModel authSession) {            ...        }    };    public abstract AuthenticationFlowModel resolveFlow(AuthenticationSessionModel authSession);}```That would rid of the String constants and ease adding the new flows in the future since all changes would be needed just in this single class (enum).",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4932,163562232,2018-01-24T14:29:45Z,server-spi/src/main/java/org/keycloak/models/AuthenticationFlowBindings.java,"@@ -0,0 +1,28 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models;++/**+ * Defines constants for authentication flow bindings.  Strings used for lookup+ *+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>+ * @version $Revision: 1 $+ */+public interface AuthenticationFlowBindings {","I see, `String`s make perfect sense then. Nit: would it be better to use `public static final String` fields and a regular class instead of `interface`?",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/4917,164991727,2018-01-31T09:14:30Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/updaters/RealmRemover.java,"@@ -0,0 +1,43 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.updaters;++import java.io.Closeable;+import javax.ws.rs.NotFoundException;+import org.keycloak.admin.client.resource.RealmResource;++/**+ *+ * @author <a href=""mailto:vramik@redhat.com"">Vlastislav Ramik</a>+ */+public class RealmRemover {","It would be more beneficial if the class automatically created the realm, cleaning the test code from all of the `adminClient.realms().create(rep);` boilerplate. Please provide a kind of `RealmCreator` instead of `RealmRemover`.",
546680,pskopek,https://api.github.com/repos/keycloak/keycloak/pulls/4931,165962801,2018-02-05T12:51:14Z,saml-core/src/main/java/org/keycloak/saml/common/util/SecurityActions.java,"@@ -37,7 +37,7 @@      *      * @return      */-    static Class<?> loadClass(final Class<?> theClass, final String fullQualifiedName) {+    public static Class<?> loadClass(final Class<?> theClass, final String fullQualifiedName) {         SecurityManager sm = System.getSecurityManager(); ",Each public static method call running privileged code should be guarded via checkPermission.This applies to all methods in this class.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/4983,167053911,2018-02-08T20:11:16Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -32,62 +32,55 @@ </head>  <body class=""${properties.kcBodyClass!}"">-    <div id=""kc-logo""><a href=""${properties.kcLogoLink!'#'}""><div id=""kc-logo-wrapper""></div></a></div>--    <div id=""kc-container"" class=""${properties.kcContainerClass!}"">-        <div id=""kc-container-wrapper"" class=""${properties.kcContainerWrapperClass!}"">--            <div id=""kc-header"" class=""${properties.kcHeaderClass!}"">-                <div id=""kc-header-wrapper"" class=""${properties.kcHeaderWrapperClass!}""><#nested ""header""></div>-            </div>--            <#if realm.internationalizationEnabled>-                <div id=""kc-locale"" class=""${properties.kcLocaleClass!}"">-                    <div id=""kc-locale-wrapper"" class=""${properties.kcLocaleWrapperClass!}"">-                        <div class=""kc-dropdown"" id=""kc-locale-dropdown"">-                            <a href=""#"" id=""kc-current-locale-link"">${locale.current}</a>-                            <ul>-                                <#list locale.supported as l>-                                    <li class=""kc-dropdown-item""><a href=""${l.url}"">${l.label}</a></li>-                                </#list>-                            </ul>-                        </div>+  <div class=""${properties.kcLoginClass!}"">+    <header class=""${properties.kcHeaderClass!}"">+      <div id=""kc-logo""><a href=""${properties.kcLogoLink!'#'}""><div id=""kc-logo-wrapper""></div></a></div>+    </header>+    <div class=""${properties.kcFormCardClass!} <#if realm.password && social.providers??>${properties.kcFormCardAccountClass!}</#if>"">","This is causing a problem on some pages as ""realm.password"" and ""social.providers"" are not available on all pages. I don't quite understand what this is doing and why it adds this class like this. Can you explain?",
701009,junezhang,https://api.github.com/repos/keycloak/keycloak/pulls/4983,167149815,2018-02-09T06:36:36Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -32,62 +32,55 @@ </head>  <body class=""${properties.kcBodyClass!}"">-    <div id=""kc-logo""><a href=""${properties.kcLogoLink!'#'}""><div id=""kc-logo-wrapper""></div></a></div>--    <div id=""kc-container"" class=""${properties.kcContainerClass!}"">-        <div id=""kc-container-wrapper"" class=""${properties.kcContainerWrapperClass!}"">--            <div id=""kc-header"" class=""${properties.kcHeaderClass!}"">-                <div id=""kc-header-wrapper"" class=""${properties.kcHeaderWrapperClass!}""><#nested ""header""></div>-            </div>--            <#if realm.internationalizationEnabled>-                <div id=""kc-locale"" class=""${properties.kcLocaleClass!}"">-                    <div id=""kc-locale-wrapper"" class=""${properties.kcLocaleWrapperClass!}"">-                        <div class=""kc-dropdown"" id=""kc-locale-dropdown"">-                            <a href=""#"" id=""kc-current-locale-link"">${locale.current}</a>-                            <ul>-                                <#list locale.supported as l>-                                    <li class=""kc-dropdown-item""><a href=""${l.url}"">${l.label}</a></li>-                                </#list>-                            </ul>-                        </div>+  <div class=""${properties.kcLoginClass!}"">+    <header class=""${properties.kcHeaderClass!}"">+      <div id=""kc-logo""><a href=""${properties.kcLogoLink!'#'}""><div id=""kc-logo-wrapper""></div></a></div>+    </header>+    <div class=""${properties.kcFormCardClass!} <#if realm.password && social.providers??>${properties.kcFormCardAccountClass!}</#if>"">","Sure, @stianst. The logical of this piece of code is the login box width is different, when no social provide, the width is 500px. and when adding the social provider the width of login box is 840px.As here, I need a class to control the width, if social provider existing, then adding this class, if not, then no more class.Do you have any suggestion?",X
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/5018,169589528,2018-02-21T10:17:59Z,testsuite/performance/tests/src/test/scala/keycloak/DefaultSimulation.scala,"@@ -1,30 +1,18 @@ package keycloak -import java.util.concurrent.atomic.AtomicInteger- import io.gatling.core.Predef._-import io.gatling.core.pause.Normal-import io.gatling.core.session._-import io.gatling.core.validation.Validation import io.gatling.http.Predef._-import org.jboss.perf.util.Util-import org.keycloak.adapters.spi.HttpFacade.Cookie-import org.keycloak.gatling.AuthorizeAction-import org.keycloak.gatling.Predef._+import keycloak.DefaultScenarioBuilder._+ import org.keycloak.performance.TestConfig + /**   * @author Radim Vansa &lt;rvansa@redhat.com&gt;   * @author Marko Strukelj &lt;mstrukel@redhat.com&gt;   */ class DefaultSimulation extends Simulation {","Should we also rename the the `DefaultSimulation` class (and `DefaultScenarioBuilder`) to something more descriptive, like: `OIDCLoginLogoutSimulation`, `BasicOIDCSimulation`, or maybe just `OIDCSimulation`?",
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/5018,169643996,2018-02-21T14:00:23Z,testsuite/performance/tests/src/test/scala/keycloak/DefaultSimulation.scala,"@@ -1,30 +1,18 @@ package keycloak -import java.util.concurrent.atomic.AtomicInteger- import io.gatling.core.Predef._-import io.gatling.core.pause.Normal-import io.gatling.core.session._-import io.gatling.core.validation.Validation import io.gatling.http.Predef._-import org.jboss.perf.util.Util-import org.keycloak.adapters.spi.HttpFacade.Cookie-import org.keycloak.gatling.AuthorizeAction-import org.keycloak.gatling.Predef._+import keycloak.DefaultScenarioBuilder._+ import org.keycloak.performance.TestConfig + /**   * @author Radim Vansa &lt;rvansa@redhat.com&gt;   * @author Marko Strukelj &lt;mstrukel@redhat.com&gt;   */ class DefaultSimulation extends Simulation {","Can you please also update class names in `README.md`, comments in `TestConfig.java` and also property `gatling.simulationClass` in `tests/pom.xml` which still references `keycloak.DefaultSimulation`?",X
141285,muehlburger,https://api.github.com/repos/keycloak/keycloak/pulls/5002,170191011,2018-02-23T08:27:59Z,themes/src/main/resources-community/theme/base/account/messages/messages_de.properties,"@@ -133,15 +150,20 @@ federatedIdentityLinkNotActiveMessage=Diese Identit\u00E4t ist nicht mehr aktiv. federatedIdentityRemovingLastProviderMessage=Sie k\u00F6nnen den letzten Eintrag nicht entfernen, da Sie kein Passwort haben. identityProviderRedirectErrorMessage=Fehler bei der Weiterleitung zum Identity Provider. identityProviderRemovedMessage=Identity Provider erfolgreich entfernt.+identityProviderAlreadyLinkedMessage=Die f\u00F6derierte Identit\u00E4t von {0} ist bereits einem anderen Benutzer zugewiesen.+staleCodeAccountMessage=Diese Seite ist nicht mehr gltig, bitte versuchen Sie es noch einmal.+consentDenied=Einverst\u00E4ndnis verweigert. -accountDisabledMessage=Benutzerkonto ist gesperrt, bitte kontaktieren Sie den Admin.+accountDisabledMessage=Ihr Benutzerkonto ist gesperrt, bitte kontaktieren Sie den Admin. -accountTemporarilyDisabledMessage=Benutzerkonto ist tempor\u00E4r gesperrt, bitte kontaktieren Sie den Admin oder versuchen Sie es sp\u00E4ter noch einmal.+accountTemporarilyDisabledMessage=Ihr Benutzerkonto ist tempor\u00E4r gesperrt, bitte kontaktieren Sie den Admin oder versuchen Sie es sp\u00E4ter noch einmal. invalidPasswordMinLengthMessage=Ung\u00FCltiges Passwort\: Minimall\u00E4nge {0}.-invalidPasswordMinDigitsMessage=Ung\u00FCltiges Passwort\: muss mindestens {0} Zahl(en) beinhalten. invalidPasswordMinLowerCaseCharsMessage=Ung\u00FCltiges Passwort\: muss mindestens {0} Kleinbuchstaben beinhalten.+invalidPasswordMinDigitsMessage=Ung\u00FCltiges Passwort\: muss mindestens {0} Zahl(en) beinhalten. invalidPasswordMinUpperCaseCharsMessage=Ung\u00FCltiges Passwort\: muss mindestens {0} Grossbuchstaben beinhalten. invalidPasswordMinSpecialCharsMessage=Ung\u00FCltiges Passwort\: muss mindestens {0} Spezialzeichen beinhalten.-invalidPasswordNotUsernameMessage=Ung\u00FCltiges Passwort\: darf nicht gleich sein wie Benutzername.+invalidPasswordNotUsernameMessage=Ung\u00FCltiges Passwort\: darf nicht gleich sein wie der Benutzername. invalidPasswordRegexPatternMessage=Ung\u00FCltiges Passwort\: nicht Regex-Muster (n) entsprechen.-invalidPasswordHistoryMessage=Ung\u00FCltiges Passwort: darf nicht einem der letzten {0} Passw\u00F6rter entsprechen.\ No newline at end of file+invalidPasswordHistoryMessage=Ung\u00FCltiges Passwort: darf nicht einem der letzten {0} Passw\u00F6rter entsprechen.+invalidPasswordBlacklistedMessage=Ung\u00FCltiges Passwort: Das Passwort ist in der Schwarzen Liste enthalten.",Ung\u00FCltiges Passwort: Das Passwort steht auf der Blocklist (schwarzen Liste).,
782072,ferdinandhuebner,https://api.github.com/repos/keycloak/keycloak/pulls/5002,170229316,2018-02-23T11:28:15Z,themes/src/main/resources-community/theme/base/account/messages/messages_de.properties,"@@ -94,29 +97,43 @@ revoke=Berechtigung widerrufen  configureAuthenticators=Authenticatoren konfigurieren","I'm happy to change that. However, I would suggest rewording ""Authentifikatoren"" and ""Authenticatoren"" to ""Mehrfachauthentifizierung"" throughout the entire theme. It would be strange if we call it ""Mehrfachauthentifizierung"" when displaying the result of activating or deactivating it, but call it ""Authentifikatoren"" in the menu and page title. TOTP labels are used in the login theme as well. However, it is called ""Mobile Authentifizierung"" in that theme. For the sake of consistency, the same phrase should be used in both themes. Would you prefer ""Mobile Authentifizierung"" or ""Mehrfachauthentifizierung""?I'll go through the translations of the other themes, because they seem incomplete. Would you prefer that I open another pull-request for that or update this one?",X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5021,170296186,2018-02-23T16:21:16Z,server-spi-private/src/main/java/org/keycloak/authorization/policy/evaluation/DefaultPolicyEvaluator.java,"@@ -77,11 +77,6 @@ public void evaluate(ResourcePermission permission, EvaluationContext executionC             if (resource.getType() != null) {                 evaluatePolicies(() -> policyStore.findByResourceType(resource.getType(), resourceServer.getId()), consumer);","I've added a comment on https://issues.jboss.org/browse/KEYCLOAK-6621. In general, you should not have too many permissions for a single type. At least not that impact performance so badly as you are suggesting.I think we can also cache this query. Currently it is hitting the database every time.",
19988460,abhishekraghav,https://api.github.com/repos/keycloak/keycloak/pulls/4172,170938733,2018-02-27T14:28:31Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -683,11 +688,35 @@ protected boolean isNewRequest(AuthenticationSessionModel authSession, ClientMod     @NoCache     @Consumes({""application/soap+xml"",MediaType.TEXT_XML})     public Response soapBinding(InputStream inputStream) {-        SamlEcpProfileService bindingService = new SamlEcpProfileService(realm, event);+        SamlEcpProfileService bindingService = new SamlEcpProfileService(realm, event, knownPorts, knownProtocols);          ResteasyProviderFactory.getInstance().injectProperties(bindingService);          return bindingService.authenticate(inputStream);     } +    private boolean isValidDestination(URI destination) {+        if (destination == null) {+            return false;+        }++        URI expected = uriInfo.getAbsolutePath();++        if (Objects.equals(expected, destination)) {+            return true;+        }++        Integer portByScheme = knownPorts.get(expected.getScheme());+        if (expected.getPort() < 0 && portByScheme != null) {+            return Objects.equals(uriInfo.getRequestUriBuilder().port(portByScheme).build(), destination);","It should be return Objects.equals(uriInfo.getAbsolutePathBuilder().port(portByScheme).build(), destination); Reason : uriInfo.getRequestUriBuilder() return the URIBuilder object initialized with request uri which would contain the SAMLrequest query parameter in the URL but the destination does not have a query parameter hence it will fail.uriInfo.getAbsolutePathBuilder() will return the builder initialized with absolute path (query param will be dropped here). Hence it will match with the destination URL.",
213880,mstruk,https://api.github.com/repos/keycloak/keycloak/pulls/5049,172252313,2018-03-05T16:47:27Z,testsuite/performance/README.md,"@@ -49,19 +49,34 @@ Keep reading for more information.  ## Provisioning -### Available provisioners:+### Provision -- `docker-compose` **Default.** See [`README.docker-compose.md`](README.docker-compose.md) for more details.+Usage: `mvn verify -P provision[,DEPLOYMENT_PROFILE] [-Dprovisioning.parameters=PARAMETER_SET]`.  -### Provision+The parameters are loaded from `tests/parameters/provisioning/${provisioning.parameters}.properties` file.+Individual parameters can be overriden from command line via `-D` params.++To use a custom properties file specify `-Dprovisioning.parameters.properties.file=ABSOLUTE_PATH_TO_FILE` instead of `-Dprovisioning.parameters`.","Maybe just call it -Dprovisioning.parameters.file (it's shorter), or maybe -Dprovisioning.properties.file.Although it doesn't really make much of a difference since the whole provisioning is quite complex.",
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/5049,172259745,2018-03-05T17:09:21Z,testsuite/performance/README.md,"@@ -49,19 +49,34 @@ Keep reading for more information.  ## Provisioning -### Available provisioners:+### Provision -- `docker-compose` **Default.** See [`README.docker-compose.md`](README.docker-compose.md) for more details.+Usage: `mvn verify -P provision[,DEPLOYMENT_PROFILE] [-Dprovisioning.parameters=PARAMETER_SET]`.  -### Provision+The parameters are loaded from `tests/parameters/provisioning/${provisioning.parameters}.properties` file.+Individual parameters can be overriden from command line via `-D` params.++To use a custom properties file specify `-Dprovisioning.parameters.properties.file=ABSOLUTE_PATH_TO_FILE` instead of `-Dprovisioning.parameters`.","Ok, but lets do it for all 3 files to be consistent. So maybe like this?`provisioning.properties` - `provisioning.properties.file``dataset.properties` - `dataset.properties.file``test.properties` - `test.properties.file`Or an alternative with ""parameters"" instead of ""properties"".",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5063,173719408,2018-03-12T08:29:38Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/SamlClient.java,"@@ -121,12 +121,17 @@ public HttpPost createSamlUnsignedResponse(URI samlEndpoint, String relayState,                 return createSamlPostMessage(samlEndpoint, relayState, samlRequest, GeneralConstants.SAML_RESPONSE_KEY, null, null);             } +            @Override+            public HttpUriRequest createSamlSignedResponse(URI samlEndpoint, String relayState, Document samlRequest, String realmPrivateKey, String realmPublicKey) {+                return null;+            }+             @Override             public HttpPost createSamlSignedRequest(URI samlEndpoint, String relayState, Document samlRequest, String realmPrivateKey, String realmPublicKey) {                 return createSamlPostMessage(samlEndpoint, relayState, samlRequest, GeneralConstants.SAML_REQUEST_KEY, realmPrivateKey, realmPublicKey);             } -            private HttpPost createSamlPostMessage(URI samlEndpoint, String relayState, Document samlRequest, String messageType, String privateKeyStr, String publicKeyStr) {+            private HttpPost createSamlPostMessage(URI samlEndpoint, String relayState, Document samlRequest, String messageType, String realmPrivateKeyStr, String realmPublicKey) {",Sorry I thought this method is overwriting the one in parent class which does have arguments with realm* prefix. I will revert it.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/5077,174774470,2018-03-15T13:07:52Z,server-spi-private/src/main/java/org/keycloak/authorization/policy/evaluation/DefaultEvaluation.java,"@@ -102,4 +124,128 @@ void denyIfNoEffect() {             deny();         }     }++    private Realm createRealm() {+        return new Realm() {++            @Override+            public boolean isUserInGroup(String id, String groupId, boolean checkParent) {+                KeycloakSession session = authorizationProvider.getKeycloakSession();+                UserModel user = getUser(id, session);++                if (Objects.isNull(user)) {","While this can be just a technicality, Objects.isNull() exists so it can be used as a Predicate. I don't see any major advantage of using it here instead of the (user == null) kind of check. Just pointing this out although I'm fine with leaving it as is.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5085,176052420,2018-03-21T11:37:45Z,saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/assertion/SAMLConditionsParser.java,"@@ -64,6 +65,11 @@ protected void processSubElement(XMLEventReader xmlEventReader, ConditionsType t                 target.addCondition(oneTimeUseCondition);                 break; +            case PROXY_RESTRICTION:+                ProxyRestrictionType proxyRestriction = new ProxyRestrictionType();","The XML stream needs to handle this element properly. You should introduce a new `SAMLProxyRestrictionParser` class (almost the same as [`SAMLAudienceRestrictionParser`](https://github.com/keycloak/keycloak/blob/master/saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/assertion/SAMLAudienceRestrictionParser.java)), and parse the `ProxyRestriction` tag instead of creating empty `ProxyRestrictionType`:```javaProxyRestrictionType proxyRestriction = SAMLAudienceRestrictionParser.getInstance().parse(xmlEventReader);```Note that `SAMLProxyRestrictionParser` should handle `ProxyRestriction` attributes, namely `Count` (see e.g. [here](https://github.com/keycloak/keycloak/blob/master/saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/metadata/SAMLIndexedEndpointTypeParser.java#L32) for sample of this task)",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5085,176079364,2018-03-21T13:27:29Z,saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/assertion/SAMLProxyRestrictionParser.java,"@@ -0,0 +1,45 @@+package org.keycloak.saml.processing.core.parsers.saml.assertion;++import org.keycloak.dom.saml.v2.assertion.ProxyRestrictionType;+import org.keycloak.saml.common.exceptions.ParsingException;+import org.keycloak.saml.common.util.StaxParserUtil;++import javax.xml.stream.XMLEventReader;+import javax.xml.stream.events.StartElement;+import java.math.BigInteger;++/**+ * Parse the <ProxyRestriction Count=\""\""> tag+ *+ * @author Patric Vormstein+ * @since 21.03.2018+ */+public class SAMLProxyRestrictionParser extends AbstractStaxSamlAssertionParser<ProxyRestrictionType> {++    private static final SAMLProxyRestrictionParser INSTANCE = new SAMLProxyRestrictionParser();++    public SAMLProxyRestrictionParser() {+        super(SAMLAssertionQNames.PROXY_RESTRICTION);+    }++    public static SAMLProxyRestrictionParser getInstance() {+        return INSTANCE;+    }++    @Override+    protected ProxyRestrictionType instantiateElement(XMLEventReader xmlEventReader, StartElement element) throws ParsingException {+        ProxyRestrictionType proxyRestriction = new ProxyRestrictionType();+        Integer count = StaxParserUtil.getIntegerAttributeValue(element, SAMLAssertionQNames.ATTR_COUNT);+        proxyRestriction.setCount(BigInteger.valueOf(count));",This throws NPE if `count == null` since `Count` attribute is optional. Needs to be guarded by a condition.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5079,176326962,2018-03-22T07:26:23Z,model/jpa/src/main/resources/META-INF/jpa-changelog-authz-4.0.0.CR1.xml,"@@ -74,5 +74,21 @@                 <constraints nullable=""false""/>             </column>         </addColumn>++        <createTable tableName=""RESOURCE_ATTRIBUTE"">+            <column name=""ID"" type=""VARCHAR(36)"" defaultValue=""sybase-needs-something-here"">+                <constraints nullable=""false""/>+            </column>+            <column name=""NAME"" type=""VARCHAR(255)"">+                <constraints nullable=""false""/>+            </column>+            <column name=""VALUE"" type=""VARCHAR(255)""/>+            <column name=""RESOURCE_ID"" type=""VARCHAR(36)"">+                <constraints nullable=""false""/>+            </column>+        </createTable>++        <addPrimaryKey columnNames=""ID"" constraintName=""CONSTRAINT_RESOURCE_ATTRIBUTE_PK"" tableName=""RESOURCE_ATTRIBUTE""/>","The CONSTRAINT_RESOURCE_ATTRIBUTE_PK identifier is too long for Oracle databases, 30 characters is max value",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5087,177158215,2018-03-26T16:41:30Z,services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticator.java,"@@ -0,0 +1,122 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.authenticators.console;++import org.keycloak.authentication.*;+import org.keycloak.authentication.authenticators.browser.AbstractUsernameFormAuthenticator;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.net.URI;++/**+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>+ * @version $Revision: 1 $+ */+public class ConsoleUsernamePasswordAuthenticator extends AbstractUsernameFormAuthenticator implements Authenticator {++    public static final ConsoleUsernamePasswordAuthenticator SINGLETON = new ConsoleUsernamePasswordAuthenticator();++    @Override+    public boolean requiresUser() {+        return false;+    }++    protected TextChallenge challenge(AuthenticationFlowContext context) {+        return TextChallenge.challenge(context)+                .header()+                .param(""username"")","I find this a bit confusing. It's hard to see what belongs to what as there's no connection between the param and the label, as well as the mask. So you kinda have to guess which belongs together.",X
704239,patriot1burke,https://api.github.com/repos/keycloak/keycloak/pulls/5087,177231302,2018-03-26T20:54:00Z,services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticator.java,"@@ -0,0 +1,122 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.authenticators.console;++import org.keycloak.authentication.*;+import org.keycloak.authentication.authenticators.browser.AbstractUsernameFormAuthenticator;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.net.URI;++/**+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>+ * @version $Revision: 1 $+ */+public class ConsoleUsernamePasswordAuthenticator extends AbstractUsernameFormAuthenticator implements Authenticator {++    public static final ConsoleUsernamePasswordAuthenticator SINGLETON = new ConsoleUsernamePasswordAuthenticator();++    @Override+    public boolean requiresUser() {+        return false;+    }++    protected TextChallenge challenge(AuthenticationFlowContext context) {+        return TextChallenge.challenge(context)+                .header()+                .param(""username"")","Don't see what's so confusing.  Its a fluent builder and really no different than what we have for the component SPI.  Start the challenge, add a header, add params to the header, params are made up of a name,  label and mask, finish it with the message blob you want to render before prompting.  I'll improve the javadocs, but other than that it stays the way it is.",
704239,patriot1burke,https://api.github.com/repos/keycloak/keycloak/pulls/5087,177232994,2018-03-26T20:59:58Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/IdentityProviderAuthenticator.java,"@@ -66,8 +70,11 @@ private void redirect(AuthenticationFlowContext context, String providerId) {                 String accessCode = new ClientSessionCode<>(context.getSession(), context.getRealm(), context.getAuthenticationSession()).getOrGenerateCode();                 String clientId = context.getAuthenticationSession().getClient().getClientId();                 String tabId = context.getAuthenticationSession().getTabId();-                Response response = Response.seeOther(-                        Urls.identityProviderAuthnRequest(context.getUriInfo().getBaseUri(), providerId, context.getRealm().getName(), accessCode, clientId, tabId))+                URI location = Urls.identityProviderAuthnRequest(context.getUriInfo().getBaseUri(), providerId, context.getRealm().getName(), accessCode, clientId, tabId);","No, doesn't work yet with broker.  Its on my todo list and there' s a jira for it.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5087,177313919,2018-03-27T05:48:58Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/IdentityProviderAuthenticator.java,"@@ -66,8 +70,11 @@ private void redirect(AuthenticationFlowContext context, String providerId) {                 String accessCode = new ClientSessionCode<>(context.getSession(), context.getRealm(), context.getAuthenticationSession()).getOrGenerateCode();                 String clientId = context.getAuthenticationSession().getClient().getClientId();                 String tabId = context.getAuthenticationSession().getTabId();-                Response response = Response.seeOther(-                        Urls.identityProviderAuthnRequest(context.getUriInfo().getBaseUri(), providerId, context.getRealm().getName(), accessCode, clientId, tabId))+                URI location = Urls.identityProviderAuthnRequest(context.getUriInfo().getBaseUri(), providerId, context.getRealm().getName(), accessCode, clientId, tabId);",If it doesn't work yet why are there changes to this class then? I don't think it has to work with brokering as that's really a web side flow so I would just drop that from the priority list.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5087,177314335,2018-03-27T05:52:03Z,services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticator.java,"@@ -0,0 +1,122 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.authenticators.console;++import org.keycloak.authentication.*;+import org.keycloak.authentication.authenticators.browser.AbstractUsernameFormAuthenticator;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.net.URI;++/**+ * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>+ * @version $Revision: 1 $+ */+public class ConsoleUsernamePasswordAuthenticator extends AbstractUsernameFormAuthenticator implements Authenticator {++    public static final ConsoleUsernamePasswordAuthenticator SINGLETON = new ConsoleUsernamePasswordAuthenticator();++    @Override+    public boolean requiresUser() {+        return false;+    }++    protected TextChallenge challenge(AuthenticationFlowContext context) {+        return TextChallenge.challenge(context)+                .header()+                .param(""username"")","Usually a fluent API is more along the lines of:.field(""username"").mask(true).add()That gives a clear start and end to a new field. What you have is just a long list of things that are not connected in any way. I had to read this line several times and apply some logic to what labels belonged to what parameters as well as what label the mask was related to. It's hard to read and understand the way it is now.",X
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/5093,177538689,2018-03-27T19:08:01Z,authz/client/src/main/java/org/keycloak/authorization/client/resource/ProtectedResource.java,"@@ -167,7 +167,7 @@ public ResourceRepresentation findByName(String name, String ownerId) {      * @param maxResult the maximum number of resources to retrieve      * @return an array of strings with the resource ids",Javadoc is missing the new parameter matchingUri,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5130,179414844,2018-04-05T10:16:50Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/javascript/AbstractJavascriptTest.java,"@@ -114,6 +118,26 @@ public void addTestRealms(List<RealmRepresentation> testRealms) {         ));     } +    protected JavascriptStateValidator retryValidation(JavascriptStateValidator validator) {",Take a look at org.keycloak.common.util.Retry. We have a generic class that can do retries.,X
20323348,oridox,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180682489,2018-04-11T09:02:06Z,testsuite/integration-arquillian/tests/base/src/test/resources/authorization-test/enforcer-config-claims-provider.json,"@@ -0,0 +1,81 @@+{+  ""realm"": ""test-realm-authz"",+  ""realm-public-key"": ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",+  ""auth-server-url"": ""http://localhost:8180/auth"",+  ""ssl-required"": ""external"",+  ""resource"": ""test-app-authz"",+  ""bearer-only"": true,+  ""credentials"": {+    ""secret"": ""secret""+  },+  ""policy-enforcer"": {+    ""paths"": [+      {+        ""path"": ""/claims-provider"",+        ""methods"": [+          {+            ""method"": ""POST"",+            ""scopes"": [+              ""create""+            ]+          }+        ],+        ""claim-information-point"": {+          ""claims"": {+            ""claim-from-request-parameter"": ""{request.parameter['a']}"",+            ""claim-from-header"": ""{request.header['b']}"",+            ""claim-from-cookie"": ""{request.cookie['c']}"",+            ""claim-from-remoteAddr"": ""{request.remoteAddr}"",+            ""claim-from-method"": ""{request.method}"",+            ""claim-from-uri"": ""{request.uri}"",+            ""claim-from-relativePath"": ""{request.relativePath}"",+            ""claim-from-secure"": ""{request.secure}"",+            ""claim-from-json-body-object"": ""{request.body['/a/b/c']}"",+            ""claim-from-json-body-array"": ""{request.body['/d/1']}"",+            ""claim-from-body"": ""{request.body}"",+            ""claim-from-static-value"": ""static value"",+            ""claim-from-multiple-static-value"": [""static"", ""value""]+          }+        }+      },+      {+        ""path"": ""/http-post-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/post-claim-information-provider"",+            ""method"": ""POST"",","if POST is supported and not only GET, there should be an option to set also the body as a JSON and not only as url-encoded parameters",
20323348,oridox,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180683389,2018-04-11T09:05:20Z,testsuite/integration-arquillian/tests/base/src/test/resources/authorization-test/enforcer-config-claims-provider.json,"@@ -0,0 +1,81 @@+{+  ""realm"": ""test-realm-authz"",+  ""realm-public-key"": ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",+  ""auth-server-url"": ""http://localhost:8180/auth"",+  ""ssl-required"": ""external"",+  ""resource"": ""test-app-authz"",+  ""bearer-only"": true,+  ""credentials"": {+    ""secret"": ""secret""+  },+  ""policy-enforcer"": {+    ""paths"": [+      {+        ""path"": ""/claims-provider"",+        ""methods"": [+          {+            ""method"": ""POST"",+            ""scopes"": [+              ""create""+            ]+          }+        ],+        ""claim-information-point"": {+          ""claims"": {+            ""claim-from-request-parameter"": ""{request.parameter['a']}"",+            ""claim-from-header"": ""{request.header['b']}"",+            ""claim-from-cookie"": ""{request.cookie['c']}"",+            ""claim-from-remoteAddr"": ""{request.remoteAddr}"",+            ""claim-from-method"": ""{request.method}"",+            ""claim-from-uri"": ""{request.uri}"",+            ""claim-from-relativePath"": ""{request.relativePath}"",+            ""claim-from-secure"": ""{request.secure}"",+            ""claim-from-json-body-object"": ""{request.body['/a/b/c']}"",+            ""claim-from-json-body-array"": ""{request.body['/d/1']}"",+            ""claim-from-body"": ""{request.body}"",+            ""claim-from-static-value"": ""static value"",+            ""claim-from-multiple-static-value"": [""static"", ""value""]+          }+        }+      },+      {+        ""path"": ""/http-post-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/post-claim-information-provider"",+            ""method"": ""POST"",+            ""headers"": {+              ""Content-Type"": ""application/x-www-form-urlencoded"",+              ""header-b"": [""header-b-value1"", ""header-b-value2""],+              ""Authorization"": ""Bearer {keycloak.access_token}""+            },+            ""parameters"": {+              ""param-a"": [""param-a-value1"", ""param-a-value2""],+              ""param-subject"": ""{keycloak.subject}"",+              ""param-user-name"": ""{keycloak.preferred_username}""+            }+          }+        }+      },+      {+        ""path"": ""/http-get-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/get-claim-information-provider"",+            ""method"": ""get"",+            ""headers"": {+              ""Content-Type"": ""application/x-www-form-urlencoded"",+              ""header-b"": [""header-b-value1"", ""header-b-value2""],+              ""Authorization"": ""Bearer {keycloak.access_token}""+            },+            ""parameters"": {+              ""param-a"": [""param-a-value1"", ""param-a-value2""],+              ""param-subject"": ""{keycloak.subject}"",","parameters' and their parsing (placeholders) should be richer. For example, I should be able to specify any attribute of the access token and not only the full token. Also, I'd like to have an option to set as a parameter any part of the request. For example, ""request.header['a']"" (just like it is specified in the claims configuration)",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180729191,2018-04-11T12:05:53Z,testsuite/integration-arquillian/tests/base/src/test/resources/authorization-test/enforcer-config-claims-provider.json,"@@ -0,0 +1,81 @@+{+  ""realm"": ""test-realm-authz"",+  ""realm-public-key"": ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",+  ""auth-server-url"": ""http://localhost:8180/auth"",+  ""ssl-required"": ""external"",+  ""resource"": ""test-app-authz"",+  ""bearer-only"": true,+  ""credentials"": {+    ""secret"": ""secret""+  },+  ""policy-enforcer"": {+    ""paths"": [+      {+        ""path"": ""/claims-provider"",+        ""methods"": [+          {+            ""method"": ""POST"",+            ""scopes"": [+              ""create""+            ]+          }+        ],+        ""claim-information-point"": {+          ""claims"": {+            ""claim-from-request-parameter"": ""{request.parameter['a']}"",+            ""claim-from-header"": ""{request.header['b']}"",+            ""claim-from-cookie"": ""{request.cookie['c']}"",+            ""claim-from-remoteAddr"": ""{request.remoteAddr}"",+            ""claim-from-method"": ""{request.method}"",+            ""claim-from-uri"": ""{request.uri}"",+            ""claim-from-relativePath"": ""{request.relativePath}"",+            ""claim-from-secure"": ""{request.secure}"",+            ""claim-from-json-body-object"": ""{request.body['/a/b/c']}"",+            ""claim-from-json-body-array"": ""{request.body['/d/1']}"",+            ""claim-from-body"": ""{request.body}"",+            ""claim-from-static-value"": ""static value"",+            ""claim-from-multiple-static-value"": [""static"", ""value""]+          }+        }+      },+      {+        ""path"": ""/http-post-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/post-claim-information-provider"",+            ""method"": ""POST"",","You mean, support a property which you can set the body when using POST ? FYI, if using POST you can already use the configuration to define request parameters.",
20323348,oridox,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180732642,2018-04-11T12:19:27Z,testsuite/integration-arquillian/tests/base/src/test/resources/authorization-test/enforcer-config-claims-provider.json,"@@ -0,0 +1,81 @@+{+  ""realm"": ""test-realm-authz"",+  ""realm-public-key"": ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",+  ""auth-server-url"": ""http://localhost:8180/auth"",+  ""ssl-required"": ""external"",+  ""resource"": ""test-app-authz"",+  ""bearer-only"": true,+  ""credentials"": {+    ""secret"": ""secret""+  },+  ""policy-enforcer"": {+    ""paths"": [+      {+        ""path"": ""/claims-provider"",+        ""methods"": [+          {+            ""method"": ""POST"",+            ""scopes"": [+              ""create""+            ]+          }+        ],+        ""claim-information-point"": {+          ""claims"": {+            ""claim-from-request-parameter"": ""{request.parameter['a']}"",+            ""claim-from-header"": ""{request.header['b']}"",+            ""claim-from-cookie"": ""{request.cookie['c']}"",+            ""claim-from-remoteAddr"": ""{request.remoteAddr}"",+            ""claim-from-method"": ""{request.method}"",+            ""claim-from-uri"": ""{request.uri}"",+            ""claim-from-relativePath"": ""{request.relativePath}"",+            ""claim-from-secure"": ""{request.secure}"",+            ""claim-from-json-body-object"": ""{request.body['/a/b/c']}"",+            ""claim-from-json-body-array"": ""{request.body['/d/1']}"",+            ""claim-from-body"": ""{request.body}"",+            ""claim-from-static-value"": ""static value"",+            ""claim-from-multiple-static-value"": [""static"", ""value""]+          }+        }+      },+      {+        ""path"": ""/http-post-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/post-claim-information-provider"",+            ""method"": ""POST"",+            ""headers"": {+              ""Content-Type"": ""application/x-www-form-urlencoded"",+              ""header-b"": [""header-b-value1"", ""header-b-value2""],+              ""Authorization"": ""Bearer {keycloak.access_token}""+            },+            ""parameters"": {+              ""param-a"": [""param-a-value1"", ""param-a-value2""],+              ""param-subject"": ""{keycloak.subject}"",+              ""param-user-name"": ""{keycloak.preferred_username}""+            }","mapping all the claims from the JSON response into PermissionRequest claims is an overkill and will have bad performance. The JSON in http response might be large while usually one needs only a single attribute as a claim. Therefore, the better approach is to use a JSON path format (RFC 6901) to parse the response.Just like it was done with simple claims mapped from the HTTP request directly (""/a/b/1"" etc.)",
20323348,oridox,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180734000,2018-04-11T12:24:28Z,testsuite/integration-arquillian/tests/base/src/test/resources/authorization-test/enforcer-config-claims-provider.json,"@@ -0,0 +1,81 @@+{+  ""realm"": ""test-realm-authz"",+  ""realm-public-key"": ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",+  ""auth-server-url"": ""http://localhost:8180/auth"",+  ""ssl-required"": ""external"",+  ""resource"": ""test-app-authz"",+  ""bearer-only"": true,+  ""credentials"": {+    ""secret"": ""secret""+  },+  ""policy-enforcer"": {+    ""paths"": [+      {+        ""path"": ""/claims-provider"",+        ""methods"": [+          {+            ""method"": ""POST"",+            ""scopes"": [+              ""create""+            ]+          }+        ],+        ""claim-information-point"": {+          ""claims"": {+            ""claim-from-request-parameter"": ""{request.parameter['a']}"",+            ""claim-from-header"": ""{request.header['b']}"",+            ""claim-from-cookie"": ""{request.cookie['c']}"",+            ""claim-from-remoteAddr"": ""{request.remoteAddr}"",+            ""claim-from-method"": ""{request.method}"",+            ""claim-from-uri"": ""{request.uri}"",+            ""claim-from-relativePath"": ""{request.relativePath}"",+            ""claim-from-secure"": ""{request.secure}"",+            ""claim-from-json-body-object"": ""{request.body['/a/b/c']}"",+            ""claim-from-json-body-array"": ""{request.body['/d/1']}"",+            ""claim-from-body"": ""{request.body}"",+            ""claim-from-static-value"": ""static value"",+            ""claim-from-multiple-static-value"": [""static"", ""value""]+          }+        }+      },+      {+        ""path"": ""/http-post-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/post-claim-information-provider"",+            ""method"": ""POST"",","yes, add a property in the configuration to specify the POST request body (with placeholders). At the moment, as I understand, the only option to set the POST request body is by ""parameters"", which are sent as the body in the format of url-encoded params (i.e., A=1&b=2&c=3 )",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180908530,2018-04-11T21:47:57Z,testsuite/integration-arquillian/tests/base/src/test/resources/authorization-test/enforcer-config-claims-provider.json,"@@ -0,0 +1,81 @@+{+  ""realm"": ""test-realm-authz"",+  ""realm-public-key"": ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",+  ""auth-server-url"": ""http://localhost:8180/auth"",+  ""ssl-required"": ""external"",+  ""resource"": ""test-app-authz"",+  ""bearer-only"": true,+  ""credentials"": {+    ""secret"": ""secret""+  },+  ""policy-enforcer"": {+    ""paths"": [+      {+        ""path"": ""/claims-provider"",+        ""methods"": [+          {+            ""method"": ""POST"",+            ""scopes"": [+              ""create""+            ]+          }+        ],+        ""claim-information-point"": {+          ""claims"": {+            ""claim-from-request-parameter"": ""{request.parameter['a']}"",+            ""claim-from-header"": ""{request.header['b']}"",+            ""claim-from-cookie"": ""{request.cookie['c']}"",+            ""claim-from-remoteAddr"": ""{request.remoteAddr}"",+            ""claim-from-method"": ""{request.method}"",+            ""claim-from-uri"": ""{request.uri}"",+            ""claim-from-relativePath"": ""{request.relativePath}"",+            ""claim-from-secure"": ""{request.secure}"",+            ""claim-from-json-body-object"": ""{request.body['/a/b/c']}"",+            ""claim-from-json-body-array"": ""{request.body['/d/1']}"",+            ""claim-from-body"": ""{request.body}"",+            ""claim-from-static-value"": ""static value"",+            ""claim-from-multiple-static-value"": [""static"", ""value""]+          }+        }+      },+      {+        ""path"": ""/http-post-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/post-claim-information-provider"",+            ""method"": ""POST"",+            ""headers"": {+              ""Content-Type"": ""application/x-www-form-urlencoded"",+              ""header-b"": [""header-b-value1"", ""header-b-value2""],+              ""Authorization"": ""Bearer {keycloak.access_token}""+            },+            ""parameters"": {+              ""param-a"": [""param-a-value1"", ""param-a-value2""],+              ""param-subject"": ""{keycloak.subject}"",+              ""param-user-name"": ""{keycloak.preferred_username}""+            }+          }+        }+      },+      {+        ""path"": ""/http-get-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/get-claim-information-provider"",+            ""method"": ""get"",+            ""headers"": {+              ""Content-Type"": ""application/x-www-form-urlencoded"",+              ""header-b"": [""header-b-value1"", ""header-b-value2""],+              ""Authorization"": ""Bearer {keycloak.access_token}""+            },+            ""parameters"": {+              ""param-a"": [""param-a-value1"", ""param-a-value2""],+              ""param-subject"": ""{keycloak.subject}"",",You can now use any claims from access or id tokens by providing a placeholder like this: `{keycloak.access_token['/preferred_username']}`.Same is true when defining parameters. Both `request` and `keycloak` placeholders are available there.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180910393,2018-04-11T21:56:14Z,testsuite/integration-arquillian/tests/base/src/test/resources/authorization-test/enforcer-config-claims-provider.json,"@@ -0,0 +1,81 @@+{+  ""realm"": ""test-realm-authz"",+  ""realm-public-key"": ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",+  ""auth-server-url"": ""http://localhost:8180/auth"",+  ""ssl-required"": ""external"",+  ""resource"": ""test-app-authz"",+  ""bearer-only"": true,+  ""credentials"": {+    ""secret"": ""secret""+  },+  ""policy-enforcer"": {+    ""paths"": [+      {+        ""path"": ""/claims-provider"",+        ""methods"": [+          {+            ""method"": ""POST"",+            ""scopes"": [+              ""create""+            ]+          }+        ],+        ""claim-information-point"": {+          ""claims"": {+            ""claim-from-request-parameter"": ""{request.parameter['a']}"",+            ""claim-from-header"": ""{request.header['b']}"",+            ""claim-from-cookie"": ""{request.cookie['c']}"",+            ""claim-from-remoteAddr"": ""{request.remoteAddr}"",+            ""claim-from-method"": ""{request.method}"",+            ""claim-from-uri"": ""{request.uri}"",+            ""claim-from-relativePath"": ""{request.relativePath}"",+            ""claim-from-secure"": ""{request.secure}"",+            ""claim-from-json-body-object"": ""{request.body['/a/b/c']}"",+            ""claim-from-json-body-array"": ""{request.body['/d/1']}"",+            ""claim-from-body"": ""{request.body}"",+            ""claim-from-static-value"": ""static value"",+            ""claim-from-multiple-static-value"": [""static"", ""value""]+          }+        }+      },+      {+        ""path"": ""/http-post-claim-provider"",+        ""claim-information-point"": {+          ""http"": {+            ""url"": ""http://localhost:8989/post-claim-information-provider"",+            ""method"": ""POST"",",I'm not sure about this one. Do you really think parameters/headers are not enough to query the external service ?,
30826028,alnemo,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180978808,2018-04-12T06:44:35Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/util/RequestPlaceHolderResolver.java,"@@ -0,0 +1,151 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.adapters.authorization.util;++import static org.keycloak.adapters.authorization.util.PlaceHolders.getParameter;++import java.io.BufferedReader;+import java.io.IOException;+import java.io.InputStream;+import java.io.InputStreamReader;+import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.List;++import com.fasterxml.jackson.databind.JsonNode;+import org.keycloak.adapters.spi.HttpFacade;+import org.keycloak.adapters.spi.HttpFacade.Cookie;+import org.keycloak.adapters.spi.HttpFacade.Request;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class RequestPlaceHolderResolver implements PlaceHolderResolver {++    static String NAME = ""request"";++    @Override+    public List<String> resolve(String placeHolder, HttpFacade httpFacade) {+        String source = placeHolder.substring(placeHolder.indexOf('.') + 1);+        Request request = httpFacade.getRequest();++        if (source.startsWith(""parameter"")) {+            String parameterName = getParameter(source, ""Could not obtain parameter name from placeholder ["" + source + ""]"");+            String parameterValue = request.getQueryParamValue(parameterName);++            if (parameterValue == null) {+                parameterValue = request.getFirstParam(parameterName);+            }++            if (parameterValue != null) {+                return Arrays.asList(parameterValue);+            }+        } else if (source.startsWith(""header"")) {+            String headerName = getParameter(source, ""Could not obtain header name from placeholder ["" + source + ""]"");+            List<String> headerValue = request.getHeaders(headerName);++            if (headerValue != null) {+                return headerValue;+            }+        } else if (source.startsWith(""cookie"")) {+            String cookieName = getParameter(source, ""Could not obtain cookie name from placeholder ["" + source + ""]"");+            Cookie cookieValue = request.getCookie(cookieName);++            if (cookieValue != null) {+                return Arrays.asList(cookieValue.getValue());+            }+        } else if (source.startsWith(""remoteAddr"")) {+            String value = request.getRemoteAddr();++            if (value != null) {+                return Arrays.asList(value);+            }+        } else if (source.startsWith(""method"")) {+            String value = request.getMethod();++            if (value != null) {+                return Arrays.asList(value);+            }+        } else if (source.startsWith(""uri"")) {+            String value = request.getURI();++            if (value != null) {+                return Arrays.asList(value);+            }+        } else if (source.startsWith(""relativePath"")) {+            String value = request.getRelativePath();++            if (value != null) {+                return Arrays.asList(value);+            }+        } else if (source.startsWith(""secure"")) {+            return Arrays.asList(String.valueOf(request.isSecure()));+        } else if (source.startsWith(""body"")) {+            String contentType = request.getHeader(""Content-Type"");++            if (contentType == null) {+                contentType = """";+            }++            InputStream body = request.getInputStream();","When I implemented this functionality I found reading the request body like this does not really work - it reads once for policy evaluation and then request arrives to Camel with empty body, the actual input stream implementations don't support marking and reseting either, so it had to be wrapped into another class, saving the request in internal buffer for multiple reads.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5144,180996594,2018-04-12T08:08:05Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/cip/HttpClaimInformationPointProvider.java,"@@ -0,0 +1,259 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.adapters.authorization.cip;++import java.io.BufferedInputStream;+import java.io.BufferedReader;+import java.io.IOException;+import java.io.InputStream;+import java.io.InputStreamReader;+import java.io.OutputStream;+import java.net.HttpURLConnection;+import java.net.URI;+import java.net.URL;+import java.util.ArrayList;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.List;+import java.util.Map;+import java.util.Map.Entry;++import javax.net.ssl.HostnameVerifier;+import javax.net.ssl.HttpsURLConnection;+import javax.net.ssl.SSLContext;++import com.fasterxml.jackson.databind.JsonNode;+import org.keycloak.adapters.authorization.ClaimInformationPointProvider;+import org.keycloak.adapters.authorization.util.JsonUtils;+import org.keycloak.adapters.authorization.util.PlaceHolders;+import org.keycloak.adapters.spi.HttpFacade;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class HttpClaimInformationPointProvider implements ClaimInformationPointProvider {++    private final Map<String, Object> config;++    public HttpClaimInformationPointProvider(Map<String, Object> config) {+        this.config = config;+    }++    @Override+    public Map<String, List<String>> resolve(HttpFacade httpFacade) {+        try {+            InputStream responseStream = openConnection(httpFacade).getInputStream();++            try (InputStream inputStream = new BufferedInputStream(responseStream)) {+                JsonNode jsonNode = JsonSerialization.mapper.readTree(inputStream);+                Map<String, List<String>> claims = new HashMap<>();+                Map<String, Object> claimsDef = (Map<String, Object>) config.get(""claims"");++                if (claimsDef == null) {+                    Iterator<String> nodeNames = jsonNode.fieldNames();++                    while (nodeNames.hasNext()) {+                        String nodeName = nodeNames.next();+                        claims.put(nodeName, JsonUtils.getValues(jsonNode.get(nodeName)));+                    }+                } else {+                    for (Entry<String, Object> claimDef : claimsDef.entrySet()) {+                        List<String> jsonPaths = new ArrayList<>();++                        if (claimDef.getValue() instanceof Collection) {+                            jsonPaths.addAll(Collection.class.cast(claimDef.getValue()));+                        } else {+                            jsonPaths.add(claimDef.getValue().toString());+                        }++                        List<String> claimValues = new ArrayList<>();++                        for (String path : jsonPaths) {+                            claimValues.addAll(JsonUtils.getValues(jsonNode, path));+                        }++                        claims.put(claimDef.getKey(), claimValues);+                    }+                }++                return claims;+            }+        } catch (IOException cause) {+            throw new RuntimeException(""Could not obtain claims from http claim information point ["" + config.get(""url"") + ""] response"", cause);+        }+    }++    private HttpURLConnection openConnection(HttpFacade httpFacade) {+        HttpURLConnection connection = null;++        try {+            String method = config.get(""method"").toString();++            if (method == null) {+                method = ""GET"";+            }++            StringBuilder url = new StringBuilder(config.get(""url"").toString());+            String parameters = parseParameters(httpFacade);++            if (""get"".equalsIgnoreCase(method) && parameters != null) {+                if (url.indexOf(""?"") != -1) {+                    url.append(""&"").append(parameters);+                } else {+                    url.append(""?"").append(parameters);+                }+            }++            SSLContext sslContext = getSslContext();+            HostnameVerifier hostnameVerifier = getHostNameVerifier();+            URL httpUrl = URI.create(url.toString()).toURL();+            boolean isHttps = httpUrl.getProtocol().equalsIgnoreCase(""https"");+            connection = (HttpURLConnection) httpUrl.openConnection();++            if (isHttps && sslContext != null) {+                HttpsURLConnection https = (HttpsURLConnection) connection;++                https.setSSLSocketFactory(sslContext.getSocketFactory());++                if (hostnameVerifier != null) {+                    https.setHostnameVerifier(hostnameVerifier);+                }+            }++            connection.setDoOutput(true);+            connection.setRequestMethod(method.toUpperCase());++            if (""post"".equalsIgnoreCase(method)) {",Looks useless,X
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5150,181791579,2018-04-16T15:51:37Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/example/cors/AbstractCorsExampleAdapterTest.java,"@@ -117,12 +119,32 @@ public void angularCorsProductTest() {         angularCorsProductPage.loadPublicRealmInfo();         waitUntilElement(angularCorsProductPage.getOutput()).text().contains(""Realm name: cors""); -        Client client = ClientBuilder.newClient();-        WebTarget target = client.target(authServerPage.createUriBuilder()).path(""version"");-        VersionRepresentation version = target.request().get(VersionRepresentation.class);+        String serverVersion = getAuthServerVersion(); +        assertNotNull(serverVersion);++        angularCorsProductPage.navigateTo();+        WaitUtils.pause(2000);         angularCorsProductPage.loadVersion();-        waitUntilElement(angularCorsProductPage.getOutput()).text().contains(""Keycloak version: "" + version.getVersion());+        waitUntilElement(angularCorsProductPage.getOutput()).text().contains(""Keycloak version: "" + serverVersion);+    }++    @Nullable+    private String getAuthServerVersion() {+        driver.navigate().to(suiteContext.getAuthServerInfo().getContextRoot().toString() ++                ""/auth/admin/master/console/#/server-info"");+        testRealmLoginPage.form().login(""admin"", ""admin"");","I think there might be a problem with htmlunit on this test. I think we need to rewrite it so that those tests were using Javascript browser, because Javascript adapter doesn't work with htmlunit (admin console uses Javascript Adapter).We need to do it similarly to this:https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/javascript/JavascriptAdapterTest.javawhich is using driver annotated with @JavascriptBrowserhttps://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/javascript/AbstractJavascriptTest.java#L54I can do it for you if you want. I am working on making all tests which are using Javascript adapter to use driver annotated with @JavascriptAdapter and I have forgotten about CORS tests. So we can merge this like it is and I will update it.   ",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5161,183292992,2018-04-23T07:07:14Z,model/jpa/src/main/resources/META-INF/jpa-changelog-1.0.0.Final.xml,"@@ -17,8 +17,11 @@   -->  <databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd"">-    <changeSet author=""sthorger@redhat.com"" id=""1.0.0.Final"">-        <preConditions onSqlOutput=""TEST"" onFail=""MARK_RAN""> +    <changeSet author=""sthorger@redhat.com"" id=""1.0.0.Final-KEYCLOAK-5461"">+        <preConditions onSqlOutput=""TEST"" onFail=""MARK_RAN"">+            <not>+                <changeSetExecuted id=""1.0.0.Final-KEYCLOAK-5461"" author=""sthorger@redhat.com"" changeLogFile=""META-INF/jpa-changelog-1.0.0.Final.xml""/>","@martin-kanis @hmlnarik I've re-run the tests and now I get liquibase.exception.MigrationFailedException: Migration failed for change set META-INF/jpa-changelog-1.0.0.Final.xml::1.0.0.Final-KEYCLOAK-5461::sthorger@redhat.com:.........Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table 'client' already existsThe problem is IMO in the change of changelog IDs on this file (the same for other changes). This precondition has to assume that changeset id=""1.0.0.Final"" was not executed.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5163,183326524,2018-04-23T09:21:40Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/ClientParameterForwardIdPAuthenticator.java,"@@ -0,0 +1,124 @@+package org.keycloak.authentication.authenticators.browser;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.Authenticator;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.sessions.AuthenticationSessionModel;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import java.util.ArrayList;+import java.util.List;+import java.util.Map;++public class ClientParameterForwardIdPAuthenticator implements Authenticator {+	// must be the same as defined in ClientParameterForwardOIDCIdentityProvider+    static final String FWD_PREFIX = ""fwd_"";+    +    private static final Logger LOG = Logger.getLogger(ClientParameterForwardIdPAuthenticator.class);++    @Override+    public void authenticate(AuthenticationFlowContext context) {+        if (context.getUriInfo().getQueryParameters().containsKey(AdapterConstants.KC_IDP_HINT)) {+            String providerId = context.getUriInfo().getQueryParameters().getFirst(AdapterConstants.KC_IDP_HINT);+            if (providerId == null || providerId.equals("""")) {+            	LOG.tracef(""Skipping: kc_idp_hint query parameter is empty"");+                context.attempted();+            } else {+            	LOG.tracef(""Redirecting: %s set to %s"", AdapterConstants.KC_IDP_HINT, providerId);+                redirect(context, providerId);+            }+        } else if (context.getAuthenticatorConfig() != null && context.getAuthenticatorConfig().getConfig().containsKey(ClientParameterForwardIdPAuthenticatorFactory.DEFAULT_PROVIDER)) {+            String defaultProvider = context.getAuthenticatorConfig().getConfig().get(ClientParameterForwardIdPAuthenticatorFactory.DEFAULT_PROVIDER);+            LOG.tracef(""Redirecting: default provider set to %s"", defaultProvider);+            storeForwardedParameters(context);+            redirect(context, defaultProvider);+        } else {+        	LOG.tracef(""No default provider set or %s query parameter provided"", AdapterConstants.KC_IDP_HINT);+            context.attempted();+        }+    }+    +    private void redirect(AuthenticationFlowContext context, String providerId) {+        List<IdentityProviderModel> identityProviders = context.getRealm().getIdentityProviders();+        for (IdentityProviderModel identityProvider : identityProviders) {+            if (identityProvider.isEnabled() && providerId.equals(identityProvider.getAlias())) {+                String accessCode = new ClientSessionCode<>(context.getSession(), context.getRealm(), context.getAuthenticationSession()).getOrGenerateCode();+                String clientId = context.getAuthenticationSession().getClient().getClientId();+                String tabId = context.getAuthenticationSession().getTabId();+                Response response = Response.seeOther(+                        Urls.identityProviderAuthnRequest(context.getUriInfo().getBaseUri(), providerId, context.getRealm().getName(), accessCode, clientId, tabId))+                        .build();++                LOG.debugf(""Redirecting to %s"", providerId);+                context.forceChallenge(response);+                return;+            }+        }++        LOG.warnf(""Provider not found or not enabled for realm %s"", providerId);+        context.attempted();+    }++    @Override+    public void action(AuthenticationFlowContext context) {+    }++    @Override+    public boolean requiresUser() {+        return false;+    }++    @Override+    public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {+        return true;+    }++    @Override+    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {+    }++    @Override+    public void close() {+    }++    private void storeForwardedParameters(AuthenticationFlowContext context) {+        HttpRequest httpRequest = context.getHttpRequest();+        Map<String, String> config = context.getAuthenticatorConfig().getConfig();+        +        // .setNote() can only contains String. Therefore, read and put each item of forwarding parameters from loaded Properties.+        MultivaluedMap<String, String> queryParameters = httpRequest.getUri().getQueryParameters();","These parameters do not originate from client but from the authentication flow url. Client parameters are available at protocol endpoints, see e.g. https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java#L97",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5163,183335812,2018-04-23T09:52:51Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/ClientParameterForwardIdPAuthenticator.java,"@@ -0,0 +1,124 @@+package org.keycloak.authentication.authenticators.browser;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.Authenticator;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.sessions.AuthenticationSessionModel;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import java.util.ArrayList;+import java.util.List;+import java.util.Map;++public class ClientParameterForwardIdPAuthenticator implements Authenticator {+	// must be the same as defined in ClientParameterForwardOIDCIdentityProvider+    static final String FWD_PREFIX = ""fwd_"";","FWD_PREFIX should be more discriminating, e.g. ""forwarded.param.""/""forwarded.hdr."" (similarly to e.g. existing `CLIENT_LOGOUT_STATE`)",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5144,184020934,2018-04-25T11:11:34Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/cip/HttpClaimInformationPointProvider.java,"@@ -0,0 +1,210 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.adapters.authorization.cip;++import java.io.BufferedInputStream;+import java.io.ByteArrayInputStream;+import java.io.IOException;+import java.io.InputStream;+import java.nio.charset.Charset;+import java.util.ArrayList;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.List;+import java.util.Map;+import java.util.Map.Entry;++import com.fasterxml.jackson.databind.JsonNode;+import org.apache.http.HttpEntity;+import org.apache.http.HttpResponse;+import org.apache.http.StatusLine;+import org.apache.http.client.HttpClient;+import org.apache.http.client.methods.RequestBuilder;+import org.apache.http.util.EntityUtils;+import org.keycloak.adapters.authorization.ClaimInformationPointProvider;+import org.keycloak.adapters.authorization.PolicyEnforcer;+import org.keycloak.adapters.authorization.util.JsonUtils;+import org.keycloak.adapters.authorization.util.PlaceHolders;+import org.keycloak.adapters.spi.HttpFacade;+import org.keycloak.authorization.client.util.HttpResponseException;+import org.keycloak.common.util.StreamUtil;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class HttpClaimInformationPointProvider implements ClaimInformationPointProvider {++    private final Map<String, Object> config;+    private final HttpClient httpClient;++    public HttpClaimInformationPointProvider(Map<String, Object> config, PolicyEnforcer policyEnforcer) {+        this.config = config;+        this.httpClient = policyEnforcer.getDeployment().getClient();+    }++    @Override+    public Map<String, List<String>> resolve(HttpFacade httpFacade) {+        try {+            InputStream responseStream = executeRequest(httpFacade);++            try (InputStream inputStream = new BufferedInputStream(responseStream)) {+                JsonNode jsonNode = JsonSerialization.mapper.readTree(inputStream);+                Map<String, List<String>> claims = new HashMap<>();+                Map<String, Object> claimsDef = (Map<String, Object>) config.get(""claims"");++                if (claimsDef == null) {+                    Iterator<String> nodeNames = jsonNode.fieldNames();++                    while (nodeNames.hasNext()) {+                        String nodeName = nodeNames.next();+                        claims.put(nodeName, JsonUtils.getValues(jsonNode.get(nodeName)));+                    }+                } else {+                    for (Entry<String, Object> claimDef : claimsDef.entrySet()) {+                        List<String> jsonPaths = new ArrayList<>();++                        if (claimDef.getValue() instanceof Collection) {+                            jsonPaths.addAll(Collection.class.cast(claimDef.getValue()));+                        } else {+                            jsonPaths.add(claimDef.getValue().toString());+                        }++                        List<String> claimValues = new ArrayList<>();++                        for (String path : jsonPaths) {+                            claimValues.addAll(JsonUtils.getValues(jsonNode, path));+                        }++                        claims.put(claimDef.getKey(), claimValues);+                    }+                }++                return claims;+            }+        } catch (IOException cause) {+            throw new RuntimeException(""Could not obtain claims from http claim information point ["" + config.get(""url"") + ""] response"", cause);+        }+    }++    private InputStream executeRequest(HttpFacade httpFacade) {+        String method = config.get(""method"").toString();++        if (method == null) {+            method = ""GET"";+        }++        RequestBuilder builder = null;++        if (""GET"".equalsIgnoreCase(method)) {+            builder = RequestBuilder.get();+        } else {+            builder = RequestBuilder.post();+        }++        builder.setUri(config.get(""url"").toString());++        byte[] bytes = new byte[0];++        try {+            setParameters(builder, httpFacade);++            if (config.containsKey(""headers"")) {+                setHeaders(builder, httpFacade);+            }++            HttpResponse response = httpClient.execute(builder.build());+            HttpEntity entity = response.getEntity();++            if (entity != null) {+                bytes = EntityUtils.toByteArray(entity);+            }++            StatusLine statusLine = response.getStatusLine();+            int statusCode = statusLine.getStatusCode();++            if (statusCode < 200 || statusCode >= 300) {+                throw new HttpResponseException(""Unexpected response from server: "" + statusCode + "" / "" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);+            }++            return new ByteArrayInputStream(bytes);+        } catch (Exception cause) {+            try {+                throw new RuntimeException(""Error executing http method ["" + builder + ""]. Response : "" + StreamUtil.readString(new ByteArrayInputStream(bytes), Charset.forName(""UTF-8"")), cause);+            } catch (Exception e) {+                throw new RuntimeException(""Error executing http method ["" + builder + ""]"", cause);+            }+        }+    }++    private void setHeaders(RequestBuilder builder, HttpFacade httpFacade) {+        Object headersDef = config.get(""headers"");++        if (headersDef != null) {+            Map<String, Object> headers = Map.class.cast(headersDef);++            for (Entry<String, Object> header : headers.entrySet()) {+                Object value = header.getValue();+                List<String> headerValues = new ArrayList<>();++                if (value instanceof Collection) {+                    Collection values = Collection.class.cast(value);+                    Iterator iterator = values.iterator();++                    while (iterator.hasNext()) {+                        headerValues.addAll(PlaceHolders.resolve(iterator.next().toString(), httpFacade));+                    }+                } else {+                    headerValues.addAll(PlaceHolders.resolve(value.toString(), httpFacade));",Please check whether PlaceHolders.resolve returned null. It fails with exception in case for example request.parameter['a'] is not given.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5144,184021926,2018-04-25T11:15:57Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/cip/HttpClaimInformationPointProvider.java,"@@ -0,0 +1,210 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.adapters.authorization.cip;++import java.io.BufferedInputStream;+import java.io.ByteArrayInputStream;+import java.io.IOException;+import java.io.InputStream;+import java.nio.charset.Charset;+import java.util.ArrayList;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.List;+import java.util.Map;+import java.util.Map.Entry;++import com.fasterxml.jackson.databind.JsonNode;+import org.apache.http.HttpEntity;+import org.apache.http.HttpResponse;+import org.apache.http.StatusLine;+import org.apache.http.client.HttpClient;+import org.apache.http.client.methods.RequestBuilder;+import org.apache.http.util.EntityUtils;+import org.keycloak.adapters.authorization.ClaimInformationPointProvider;+import org.keycloak.adapters.authorization.PolicyEnforcer;+import org.keycloak.adapters.authorization.util.JsonUtils;+import org.keycloak.adapters.authorization.util.PlaceHolders;+import org.keycloak.adapters.spi.HttpFacade;+import org.keycloak.authorization.client.util.HttpResponseException;+import org.keycloak.common.util.StreamUtil;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class HttpClaimInformationPointProvider implements ClaimInformationPointProvider {++    private final Map<String, Object> config;+    private final HttpClient httpClient;++    public HttpClaimInformationPointProvider(Map<String, Object> config, PolicyEnforcer policyEnforcer) {+        this.config = config;+        this.httpClient = policyEnforcer.getDeployment().getClient();+    }++    @Override+    public Map<String, List<String>> resolve(HttpFacade httpFacade) {+        try {+            InputStream responseStream = executeRequest(httpFacade);++            try (InputStream inputStream = new BufferedInputStream(responseStream)) {+                JsonNode jsonNode = JsonSerialization.mapper.readTree(inputStream);+                Map<String, List<String>> claims = new HashMap<>();+                Map<String, Object> claimsDef = (Map<String, Object>) config.get(""claims"");++                if (claimsDef == null) {+                    Iterator<String> nodeNames = jsonNode.fieldNames();++                    while (nodeNames.hasNext()) {+                        String nodeName = nodeNames.next();+                        claims.put(nodeName, JsonUtils.getValues(jsonNode.get(nodeName)));+                    }+                } else {+                    for (Entry<String, Object> claimDef : claimsDef.entrySet()) {+                        List<String> jsonPaths = new ArrayList<>();++                        if (claimDef.getValue() instanceof Collection) {+                            jsonPaths.addAll(Collection.class.cast(claimDef.getValue()));+                        } else {+                            jsonPaths.add(claimDef.getValue().toString());+                        }++                        List<String> claimValues = new ArrayList<>();++                        for (String path : jsonPaths) {+                            claimValues.addAll(JsonUtils.getValues(jsonNode, path));+                        }++                        claims.put(claimDef.getKey(), claimValues);+                    }+                }++                return claims;+            }+        } catch (IOException cause) {+            throw new RuntimeException(""Could not obtain claims from http claim information point ["" + config.get(""url"") + ""] response"", cause);+        }+    }++    private InputStream executeRequest(HttpFacade httpFacade) {+        String method = config.get(""method"").toString();++        if (method == null) {+            method = ""GET"";+        }++        RequestBuilder builder = null;++        if (""GET"".equalsIgnoreCase(method)) {+            builder = RequestBuilder.get();+        } else {+            builder = RequestBuilder.post();+        }++        builder.setUri(config.get(""url"").toString());++        byte[] bytes = new byte[0];++        try {+            setParameters(builder, httpFacade);++            if (config.containsKey(""headers"")) {+                setHeaders(builder, httpFacade);+            }++            HttpResponse response = httpClient.execute(builder.build());+            HttpEntity entity = response.getEntity();++            if (entity != null) {+                bytes = EntityUtils.toByteArray(entity);+            }++            StatusLine statusLine = response.getStatusLine();+            int statusCode = statusLine.getStatusCode();++            if (statusCode < 200 || statusCode >= 300) {+                throw new HttpResponseException(""Unexpected response from server: "" + statusCode + "" / "" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);","Just a notion, this returns quite a big [stacktrace](https://pastebin.com/nwMc3XVa) in case request return for example 400. I was wondering whether it wouldn't be nicer to continue, but without claims. I assume it would fail later when checking claims for access denied or something similar. WDYT? ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5144,184053417,2018-04-25T13:15:20Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/cip/HttpClaimInformationPointProvider.java,"@@ -0,0 +1,210 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.adapters.authorization.cip;++import java.io.BufferedInputStream;+import java.io.ByteArrayInputStream;+import java.io.IOException;+import java.io.InputStream;+import java.nio.charset.Charset;+import java.util.ArrayList;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.List;+import java.util.Map;+import java.util.Map.Entry;++import com.fasterxml.jackson.databind.JsonNode;+import org.apache.http.HttpEntity;+import org.apache.http.HttpResponse;+import org.apache.http.StatusLine;+import org.apache.http.client.HttpClient;+import org.apache.http.client.methods.RequestBuilder;+import org.apache.http.util.EntityUtils;+import org.keycloak.adapters.authorization.ClaimInformationPointProvider;+import org.keycloak.adapters.authorization.PolicyEnforcer;+import org.keycloak.adapters.authorization.util.JsonUtils;+import org.keycloak.adapters.authorization.util.PlaceHolders;+import org.keycloak.adapters.spi.HttpFacade;+import org.keycloak.authorization.client.util.HttpResponseException;+import org.keycloak.common.util.StreamUtil;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class HttpClaimInformationPointProvider implements ClaimInformationPointProvider {++    private final Map<String, Object> config;+    private final HttpClient httpClient;++    public HttpClaimInformationPointProvider(Map<String, Object> config, PolicyEnforcer policyEnforcer) {+        this.config = config;+        this.httpClient = policyEnforcer.getDeployment().getClient();+    }++    @Override+    public Map<String, List<String>> resolve(HttpFacade httpFacade) {+        try {+            InputStream responseStream = executeRequest(httpFacade);++            try (InputStream inputStream = new BufferedInputStream(responseStream)) {+                JsonNode jsonNode = JsonSerialization.mapper.readTree(inputStream);+                Map<String, List<String>> claims = new HashMap<>();+                Map<String, Object> claimsDef = (Map<String, Object>) config.get(""claims"");++                if (claimsDef == null) {+                    Iterator<String> nodeNames = jsonNode.fieldNames();++                    while (nodeNames.hasNext()) {+                        String nodeName = nodeNames.next();+                        claims.put(nodeName, JsonUtils.getValues(jsonNode.get(nodeName)));+                    }+                } else {+                    for (Entry<String, Object> claimDef : claimsDef.entrySet()) {+                        List<String> jsonPaths = new ArrayList<>();++                        if (claimDef.getValue() instanceof Collection) {+                            jsonPaths.addAll(Collection.class.cast(claimDef.getValue()));+                        } else {+                            jsonPaths.add(claimDef.getValue().toString());+                        }++                        List<String> claimValues = new ArrayList<>();++                        for (String path : jsonPaths) {+                            claimValues.addAll(JsonUtils.getValues(jsonNode, path));+                        }++                        claims.put(claimDef.getKey(), claimValues);+                    }+                }++                return claims;+            }+        } catch (IOException cause) {+            throw new RuntimeException(""Could not obtain claims from http claim information point ["" + config.get(""url"") + ""] response"", cause);+        }+    }++    private InputStream executeRequest(HttpFacade httpFacade) {+        String method = config.get(""method"").toString();++        if (method == null) {+            method = ""GET"";+        }++        RequestBuilder builder = null;++        if (""GET"".equalsIgnoreCase(method)) {+            builder = RequestBuilder.get();+        } else {+            builder = RequestBuilder.post();+        }++        builder.setUri(config.get(""url"").toString());++        byte[] bytes = new byte[0];++        try {+            setParameters(builder, httpFacade);++            if (config.containsKey(""headers"")) {+                setHeaders(builder, httpFacade);+            }++            HttpResponse response = httpClient.execute(builder.build());+            HttpEntity entity = response.getEntity();++            if (entity != null) {+                bytes = EntityUtils.toByteArray(entity);+            }++            StatusLine statusLine = response.getStatusLine();+            int statusCode = statusLine.getStatusCode();++            if (statusCode < 200 || statusCode >= 300) {+                throw new HttpResponseException(""Unexpected response from server: "" + statusCode + "" / "" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);+            }++            return new ByteArrayInputStream(bytes);+        } catch (Exception cause) {+            try {+                throw new RuntimeException(""Error executing http method ["" + builder + ""]. Response : "" + StreamUtil.readString(new ByteArrayInputStream(bytes), Charset.forName(""UTF-8"")), cause);+            } catch (Exception e) {+                throw new RuntimeException(""Error executing http method ["" + builder + ""]"", cause);+            }+        }+    }++    private void setHeaders(RequestBuilder builder, HttpFacade httpFacade) {+        Object headersDef = config.get(""headers"");++        if (headersDef != null) {+            Map<String, Object> headers = Map.class.cast(headersDef);++            for (Entry<String, Object> header : headers.entrySet()) {+                Object value = header.getValue();+                List<String> headerValues = new ArrayList<>();++                if (value instanceof Collection) {+                    Collection values = Collection.class.cast(value);+                    Iterator iterator = values.iterator();++                    while (iterator.hasNext()) {+                        headerValues.addAll(PlaceHolders.resolve(iterator.next().toString(), httpFacade));+                    }+                } else {+                    headerValues.addAll(PlaceHolders.resolve(value.toString(), httpFacade));","It does not return null anymore, but an empty list.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5173,185448080,2018-05-02T10:02:50Z,common/src/main/java/org/keycloak/common/util/PathMatcher.java,"@@ -204,6 +213,13 @@ public String buildUriFromTemplate(String expectedUri, String targetUri) {             }              if (matchingUri[matchingUri.length - 1] == '\u0000') {+                if (template.endsWith(""*"")) {","Do we want to support here patterns like: ""/keycloak-7148/{id}/*/ending"". Because at the moment something like this doesn't work as the template doesn't end with the asterisk.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5206,190232848,2018-05-23T12:51:09Z,core/src/main/java/org/keycloak/representations/idm/authorization/UmaPermissionTypeRepresentation.java,"@@ -0,0 +1,77 @@+/*+ * JBoss, Home of Professional Open Source.+ * Copyright 2016 Red Hat, Inc., and individual contributors+ * as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.representations.idm.authorization;++import com.fasterxml.jackson.annotation.JsonIgnore;+import java.util.Set;++/**+ * @author <a href=""mailto:federico@martel-innovate.com"">Federico M. Facca</a>+ */++public class UmaPermissionTypeRepresentation {","You should override ```getType``` and return ""uma"" just like we do with other types of permissions. See https://github.com/pedroigor/keycloak/blob/54ebc1918c0249384877a9d6b2c3f12919cbff36/core/src/main/java/org/keycloak/representations/idm/authorization/ResourcePermissionRepresentation.java#L22.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5220,190270992,2018-05-23T14:33:57Z,adapters/oidc/adapter-core/pom.xml,"@@ -36,7 +36,16 @@         </keycloak.osgi.export>         <keycloak.osgi.import>             org.keycloak.*;version=""${project.version}"",-            org.apache.http.*;version=${apache.httpcomponents.version},+            org.apache.http.auth.*;version=${apache.httpcomponents.version},",Isn't ${apache.httpcomponents.version} a bit too strict?,
777218,chicco785,https://api.github.com/repos/keycloak/keycloak/pulls/5206,190373836,2018-05-23T19:37:31Z,core/src/main/java/org/keycloak/representations/idm/authorization/UmaPolicyRepresentation.java,"@@ -0,0 +1,60 @@+/*+ * JBoss, Home of Professional Open Source.+ * Copyright 2016 Red Hat, Inc., and individual contributors+ * as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.representations.idm.authorization;++import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;++/**+ * @author <a href=""mailto:federico@martel-innovate.com"">Federico M. Facca</a>+ */++public class UmaPolicyRepresentation extends AbstractPolicyRepresentation {","while at creation time many things can be implied, the internal representation is still richer, and some how we have to deal with that (or with assumptions, or with ""optional fields"").currently, for example to share with more groups, you will create something like that via the api:```{    ""scopes"": [        ""read""    ],    ""policies"": [	{        ""type"": ""group"",        ""subjects"": [            ""a759a3a2-95b9-4f88-9c5e-c2b9ea2f1211"",            ""d14d66e5-3341-439a-9da4-60944487a158""        ]    }    ]}```or for users```{    ""scopes"": [        ""read""    ],    ""policies"": [	{        ""type"": ""user"",        ""subjects"": [            ""a759a3a2-95b9-4f88-9c5e-c2b9ea2f1211"",            ""d14d66e5-3341-439a-9da4-60944487a158""        ]    }    ]}```The response will include the enriched json (including optional parameters - but probably we can have a way to not return them, unless they are different from the ""default""):```{    ""logic"": ""POSITIVE"",    ""decisionStrategy"": ""UNANIMOUS"",    ""scopes"": [        ""read""    ],    ""policies"": [        {            ""id"": ""94c61cd8-6d64-4e08-91e7-7066809db190"",            ""type"": ""group"",            ""logic"": ""POSITIVE"",            ""decisionStrategy"": ""UNANIMOUS"",            ""subjects"": [               ""a759a3a2-95b9-4f88-9c5e-c2b9ea2f1211"",               ""d14d66e5-3341-439a-9da4-60944487a158""            ],            ""options"": {                ""groupsClaim"": [                    ""groups""                ]            }        }    ],    ""id"": ""d59d7e08-1448-4a65-894a-ee921987b348""}```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5206,190385258,2018-05-23T20:18:12Z,services/src/main/java/org/keycloak/authorization/protection/policy/PolicyService.java,"@@ -0,0 +1,244 @@+/*+ * JBoss, Home of Professional Open Source.+ * Copyright 2016 Red Hat, Inc., and individual contributors+ * as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.authorization.protection.policy;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.stream.Collectors;+import javax.ws.rs.Consumes;+import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.POST;+import javax.ws.rs.PUT;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.Response;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.keycloak.authorization.AuthorizationProvider;+import org.keycloak.authorization.identity.Identity;+import org.keycloak.authorization.model.Policy;+import org.keycloak.authorization.model.Resource;+import org.keycloak.authorization.model.ResourceServer;+import org.keycloak.authorization.store.PolicyStore;+import org.keycloak.authorization.store.ResourceStore;+import org.keycloak.models.Constants;+import org.keycloak.models.utils.ModelToRepresentation;+import org.keycloak.models.utils.RepresentationToModel;+import org.keycloak.representations.idm.authorization.UmaPermissionTypeRepresentation;+import org.keycloak.services.ErrorResponseException;++/**+ * @author <a href=""mailto:federico@martel-innovate.com"">Federico M. Facca</a>+ */+public class PolicyService {++    private final ResourceServer resourceServer;+    private final Identity identity;+    private final AuthorizationProvider authorization;+    private final ResourceStore resourceStore;+    private final PolicyStore policyStore;++    public PolicyService(Identity identity, ResourceServer resourceServer, AuthorizationProvider authorization) {+        this.identity = identity;+        this.resourceServer = resourceServer;+        this.authorization = authorization;+        this.resourceStore = this.authorization.getStoreFactory().getResourceStore();+        this.policyStore = this.authorization.getStoreFactory().getPolicyStore();+    }++    @POST+    @Path(""{resourceId}"")+    @Consumes(""application/json"")+    @Produces(""application/json"")+    public Response create(@PathParam(""resourceId"") String resourceId, UmaPermissionTypeRepresentation policy) {",My point is that the user won't be able to revoke permissions created using APIs if they are using Account Services. By Account Services I mean this https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_authorization_api_aapi.If you look that documentation you`ll see that we allow users to manage permissions to their resources through Keycloak Account Service. But there we only allow users to revoke the permissions created as consequence of approving/granting a permission ticket.Makes more sense now ?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5206,190597160,2018-05-24T14:01:39Z,services/src/main/java/org/keycloak/authorization/protection/policy/PolicyService.java,"@@ -0,0 +1,244 @@+/*+ * JBoss, Home of Professional Open Source.+ * Copyright 2016 Red Hat, Inc., and individual contributors+ * as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.authorization.protection.policy;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.stream.Collectors;+import javax.ws.rs.Consumes;+import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.POST;+import javax.ws.rs.PUT;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.Response;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.keycloak.authorization.AuthorizationProvider;+import org.keycloak.authorization.identity.Identity;+import org.keycloak.authorization.model.Policy;+import org.keycloak.authorization.model.Resource;+import org.keycloak.authorization.model.ResourceServer;+import org.keycloak.authorization.store.PolicyStore;+import org.keycloak.authorization.store.ResourceStore;+import org.keycloak.models.Constants;+import org.keycloak.models.utils.ModelToRepresentation;+import org.keycloak.models.utils.RepresentationToModel;+import org.keycloak.representations.idm.authorization.UmaPermissionTypeRepresentation;+import org.keycloak.services.ErrorResponseException;++/**+ * @author <a href=""mailto:federico@martel-innovate.com"">Federico M. Facca</a>+ */+public class PolicyService {++    private final ResourceServer resourceServer;+    private final Identity identity;+    private final AuthorizationProvider authorization;+    private final ResourceStore resourceStore;+    private final PolicyStore policyStore;++    public PolicyService(Identity identity, ResourceServer resourceServer, AuthorizationProvider authorization) {+        this.identity = identity;+        this.resourceServer = resourceServer;+        this.authorization = authorization;+        this.resourceStore = this.authorization.getStoreFactory().getResourceStore();+        this.policyStore = this.authorization.getStoreFactory().getPolicyStore();+    }++    @POST+    @Path(""{resourceId}"")+    @Consumes(""application/json"")+    @Produces(""application/json"")+    public Response create(@PathParam(""resourceId"") String resourceId, UmaPermissionTypeRepresentation policy) {+        validateRequest(resourceId);+        validateUmaPermissionTypeRepresentation(resourceId, false, policy);+        validateScopes(resourceId, policy.getScopes());+        Policy model = RepresentationToModel.createPolicyfromUmaPermissionTypeRepresentation(policy, resourceId, resourceServer, authorization, identity);+        return Response.ok().entity(ModelToRepresentation.toUmaPermissionTypeRepresentation(model, authorization)).build();+    }++    @Path(""{resourceId}/{policyId}"")+    @PUT+    @Consumes(""application/json"")+    @Produces(""application/json"")+    public Response update(@PathParam(""resourceId"") String resourceId, @PathParam(""policyId"") String policyId, UmaPermissionTypeRepresentation policy) {","My changes are all about the ""normal"" UMA flow, where a requester is asking access to the owner of a resource.So, yeah, we have different UMA permissions for Resource Z each one specific for User A and User C. It is easier to identify those permissions, as you just need to know the resource and the requester, so you can obtain a ticket which is then associated with the UMA permission.That is what I have commented here about adding the requester to your ```/uma-policy```, so you could manage a specific policy for a specific requester/user. But that won't work for you, as you need to define additional policies to a resource that are not necessarily linked to a requester. For instance, if you define group or role policies.Now think about this scenario. You have created a UMA permission using ```/uma-policy``` granting access to a specific role or group. Now you want to check if a user has access to the resource associated with this permission. As you know, you can ask for permissions using a ticket (UMA flow), using a permission request and passing the resource(s) or just obtain all permissions from the server. The two first methods are OK since you know the resource you need to check for permissions. But what about the last method ? Obtain all permissions from the server ? How we would perform this evaluation without iterating over all existing resources in the server ? That may impact performance ....",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5206,190599281,2018-05-24T14:07:38Z,services/src/main/java/org/keycloak/authorization/protection/policy/PolicyService.java,"@@ -0,0 +1,244 @@+/*+ * JBoss, Home of Professional Open Source.+ * Copyright 2016 Red Hat, Inc., and individual contributors+ * as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.authorization.protection.policy;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.stream.Collectors;+import javax.ws.rs.Consumes;+import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.POST;+import javax.ws.rs.PUT;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.Response;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.keycloak.authorization.AuthorizationProvider;+import org.keycloak.authorization.identity.Identity;+import org.keycloak.authorization.model.Policy;+import org.keycloak.authorization.model.Resource;+import org.keycloak.authorization.model.ResourceServer;+import org.keycloak.authorization.store.PolicyStore;+import org.keycloak.authorization.store.ResourceStore;+import org.keycloak.models.Constants;+import org.keycloak.models.utils.ModelToRepresentation;+import org.keycloak.models.utils.RepresentationToModel;+import org.keycloak.representations.idm.authorization.UmaPermissionTypeRepresentation;+import org.keycloak.services.ErrorResponseException;++/**+ * @author <a href=""mailto:federico@martel-innovate.com"">Federico M. Facca</a>+ */+public class PolicyService {++    private final ResourceServer resourceServer;+    private final Identity identity;+    private final AuthorizationProvider authorization;+    private final ResourceStore resourceStore;+    private final PolicyStore policyStore;++    public PolicyService(Identity identity, ResourceServer resourceServer, AuthorizationProvider authorization) {+        this.identity = identity;+        this.resourceServer = resourceServer;+        this.authorization = authorization;+        this.resourceStore = this.authorization.getStoreFactory().getResourceStore();+        this.policyStore = this.authorization.getStoreFactory().getPolicyStore();+    }++    @POST+    @Path(""{resourceId}"")+    @Consumes(""application/json"")+    @Produces(""application/json"")+    public Response create(@PathParam(""resourceId"") String resourceId, UmaPermissionTypeRepresentation policy) {","Yeah and that is a big thing, you know :)And there are some things to consider that are not so simple or don't make sense:* How the UI will look like in order to allow users to manage these additional policies ?* Does it makes sense to allow users (we are talking about end-users) to manage role, group and client policies. Think about it, as a end-user I really don't need to know about roles in the application I'm using. ",
777218,chicco785,https://api.github.com/repos/keycloak/keycloak/pulls/5206,190608669,2018-05-24T14:31:22Z,services/src/main/java/org/keycloak/authorization/protection/policy/PolicyService.java,"@@ -0,0 +1,244 @@+/*+ * JBoss, Home of Professional Open Source.+ * Copyright 2016 Red Hat, Inc., and individual contributors+ * as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.authorization.protection.policy;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.stream.Collectors;+import javax.ws.rs.Consumes;+import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.POST;+import javax.ws.rs.PUT;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.Response;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.keycloak.authorization.AuthorizationProvider;+import org.keycloak.authorization.identity.Identity;+import org.keycloak.authorization.model.Policy;+import org.keycloak.authorization.model.Resource;+import org.keycloak.authorization.model.ResourceServer;+import org.keycloak.authorization.store.PolicyStore;+import org.keycloak.authorization.store.ResourceStore;+import org.keycloak.models.Constants;+import org.keycloak.models.utils.ModelToRepresentation;+import org.keycloak.models.utils.RepresentationToModel;+import org.keycloak.representations.idm.authorization.UmaPermissionTypeRepresentation;+import org.keycloak.services.ErrorResponseException;++/**+ * @author <a href=""mailto:federico@martel-innovate.com"">Federico M. Facca</a>+ */+public class PolicyService {++    private final ResourceServer resourceServer;+    private final Identity identity;+    private final AuthorizationProvider authorization;+    private final ResourceStore resourceStore;+    private final PolicyStore policyStore;++    public PolicyService(Identity identity, ResourceServer resourceServer, AuthorizationProvider authorization) {+        this.identity = identity;+        this.resourceServer = resourceServer;+        this.authorization = authorization;+        this.resourceStore = this.authorization.getStoreFactory().getResourceStore();+        this.policyStore = this.authorization.getStoreFactory().getPolicyStore();+    }++    @POST+    @Path(""{resourceId}"")+    @Consumes(""application/json"")+    @Produces(""application/json"")+    public Response create(@PathParam(""resourceId"") String resourceId, UmaPermissionTypeRepresentation policy) {","* client, i agree, it does not make sense in the ui.* role, may have, depending on the complexity of roles in your app.* groups, makes definitively sense.",
777218,chicco785,https://api.github.com/repos/keycloak/keycloak/pulls/5206,190609888,2018-05-24T14:34:40Z,services/src/main/java/org/keycloak/authorization/protection/policy/PolicyService.java,"@@ -0,0 +1,244 @@+/*+ * JBoss, Home of Professional Open Source.+ * Copyright 2016 Red Hat, Inc., and individual contributors+ * as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *     http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.authorization.protection.policy;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.stream.Collectors;+import javax.ws.rs.Consumes;+import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.POST;+import javax.ws.rs.PUT;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.Response;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.keycloak.authorization.AuthorizationProvider;+import org.keycloak.authorization.identity.Identity;+import org.keycloak.authorization.model.Policy;+import org.keycloak.authorization.model.Resource;+import org.keycloak.authorization.model.ResourceServer;+import org.keycloak.authorization.store.PolicyStore;+import org.keycloak.authorization.store.ResourceStore;+import org.keycloak.models.Constants;+import org.keycloak.models.utils.ModelToRepresentation;+import org.keycloak.models.utils.RepresentationToModel;+import org.keycloak.representations.idm.authorization.UmaPermissionTypeRepresentation;+import org.keycloak.services.ErrorResponseException;++/**+ * @author <a href=""mailto:federico@martel-innovate.com"">Federico M. Facca</a>+ */+public class PolicyService {++    private final ResourceServer resourceServer;+    private final Identity identity;+    private final AuthorizationProvider authorization;+    private final ResourceStore resourceStore;+    private final PolicyStore policyStore;++    public PolicyService(Identity identity, ResourceServer resourceServer, AuthorizationProvider authorization) {+        this.identity = identity;+        this.resourceServer = resourceServer;+        this.authorization = authorization;+        this.resourceStore = this.authorization.getStoreFactory().getResourceStore();+        this.policyStore = this.authorization.getStoreFactory().getPolicyStore();+    }++    @POST+    @Path(""{resourceId}"")+    @Consumes(""application/json"")+    @Produces(""application/json"")+    public Response create(@PathParam(""resourceId"") String resourceId, UmaPermissionTypeRepresentation policy) {+        validateRequest(resourceId);+        validateUmaPermissionTypeRepresentation(resourceId, false, policy);+        validateScopes(resourceId, policy.getScopes());+        Policy model = RepresentationToModel.createPolicyfromUmaPermissionTypeRepresentation(policy, resourceId, resourceServer, authorization, identity);+        return Response.ok().entity(ModelToRepresentation.toUmaPermissionTypeRepresentation(model, authorization)).build();+    }++    @Path(""{resourceId}/{policyId}"")+    @PUT+    @Consumes(""application/json"")+    @Produces(""application/json"")+    public Response update(@PathParam(""resourceId"") String resourceId, @PathParam(""policyId"") String policyId, UmaPermissionTypeRepresentation policy) {","1. we can add requester for ticket permission generated UMA permissions as query parameter.1. we can use in a ""tricky"" way requester for the other policies. e.g. if it is not a uma permission, requester is used to find all the policy where related to ""requesterId"" via user, group or role.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5163,192670805,2018-06-04T09:01:44Z,services/src/main/java/org/keycloak/broker/oidc/AbstractOAuth2IdentityProvider.java,"@@ -327,6 +332,15 @@ protected UriBuilder createAuthorizationUrl(AuthenticationRequest request) {         if (acr != null) {             uriBuilder.queryParam(OAuth2Constants.ACR_VALUES, acr);         }+        String forwardParameterConfig = getConfig().getForwardParameters() != null ? getConfig().getForwardParameters(): """";+        List<String> forwardParameters = Arrays.asList(forwardParameterConfig.split(""\\s*,\\s*""));+        for(String forwardParameter: forwardParameters) {+            String name = AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX + forwardParameter.trim();","I think this will support just forwarding of custom parameters not defined in the specs (EG. parameter ""forwarded_parameter"" you used in the test), but no forwarding of standard parameters (EG. ""nonce""). If we want to support also forwarding of standard parameters (which IMO we should), this line can be potentially refactored to something like:```String forwardParameter = forwardParameter.trim();String name = AuthzEndpointRequestParser.KNOWN_REQ_PARAMS.contains(forwardParameter) ? forwardParameter : AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX + forwardParameter;```Also the test would be good for some of standard parameters (EG. nonce).",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5163,192672034,2018-06-04T09:05:56Z,services/src/test/java/org/keycloak/test/broker/oidc/AbstractOAuth2IdentityProviderTest.java,"@@ -121,9 +137,54 @@ public void getFederatedIdentity_responseUrlLine() { 	}  	private TestProvider getTested() {		-		return new TestProvider(getConfig(null, null, null, Boolean.FALSE));+		return new TestProvider(getConfig(""https://localhost:8080/callback"", null, ""clientId"", Boolean.FALSE)); 	} +    @Test",My vote is to rather remove all the tests you added in AbstractOAuth2IdentityProviderTest. You are already testing this feature more properly in the integration test KcOidcBrokerParameterForwardTest and it's no need to duplicate stuff and create another place for unecessary maintenance.,X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5163,192673314,2018-06-04T09:10:34Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties,"@@ -563,6 +563,8 @@ validating-public-key-id=Validating Public Key Id identity-provider.validating-public-key-id.tooltip=Explicit ID of the validating public key given above if the key ID. Leave blank if the key above should be used always, regardless of key ID specified by external IDP; set it if the key should only be used for verifying if key ID from external IDP matches. identity-provider.allowed-clock-skew=Allowed clock skew identity-provider.allowed-clock-skew.tooltip=Clock skew in seconds that is tolerated when validating identity provider tokens. Default value is zero.+forwarded-query-parameters=Forwarded Query Parameters+identity-provider.forwarded-query-parameters.tooltip=Query parameters to be forwarded to external IDP. Multiple parameters can be entered, separated by comma (,).","I am not sure if this tooltip could be made more clear to specify from which place are parameters forwarded? For example something like: Query parameters to be forwarded to external IDP from the initial application request to Authorization Endpoint. Multiple parameters can be entered, separated by comma (,).",
26590043,tmogi001,https://api.github.com/repos/keycloak/keycloak/pulls/5163,192954202,2018-06-05T06:01:54Z,services/src/main/java/org/keycloak/broker/oidc/AbstractOAuth2IdentityProvider.java,"@@ -327,6 +332,15 @@ protected UriBuilder createAuthorizationUrl(AuthenticationRequest request) {         if (acr != null) {             uriBuilder.queryParam(OAuth2Constants.ACR_VALUES, acr);         }+        String forwardParameterConfig = getConfig().getForwardParameters() != null ? getConfig().getForwardParameters(): """";+        List<String> forwardParameters = Arrays.asList(forwardParameterConfig.split(""\\s*,\\s*""));+        for(String forwardParameter: forwardParameters) {+            String name = AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX + forwardParameter.trim();","In my opinion, standard parameters should not be **simply** forwarded to avoid errors in external IdP.- Duplicate parametersFor example, if ""client_id"" is specified in configuration, keycloak send an own ""client_id"" and a client requested ""client_id"". I think most of external IdP cannot handle these request.- Default valueThere is some difference in handling default values. ignoring parameters, generating parameters or using parameters from the configuration (""nonce"" is generated if not specified ). I think we need to handle default behavior for each parameter.I plan to create another PR to forward standard parameters.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5163,193088270,2018-06-05T14:15:31Z,services/src/main/java/org/keycloak/broker/oidc/AbstractOAuth2IdentityProvider.java,"@@ -327,6 +332,15 @@ protected UriBuilder createAuthorizationUrl(AuthenticationRequest request) {         if (acr != null) {             uriBuilder.queryParam(OAuth2Constants.ACR_VALUES, acr);         }+        String forwardParameterConfig = getConfig().getForwardParameters() != null ? getConfig().getForwardParameters(): """";+        List<String> forwardParameters = Arrays.asList(forwardParameterConfig.split(""\\s*,\\s*""));+        for(String forwardParameter: forwardParameters) {+            String name = AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX + forwardParameter.trim();","Yes, for ""client_id"" it probably doesn't have much sense, but for some others, it maybe has? Also the UriBuilder has method ""replaceQueryParam"" to avoid duplicated query parameters. But on other hand, in AbstractOAuth2IdentityProvider.createAuthorizationUrl method, I see that most of the parameters where forwarding makes sense (prompt, nonce, acr_values) are already automatically forwarded to IDP. So maybe just improve tooltip that forwarding is supported just for non-standard OpenID Connect parameters and leave support just for custom parameters?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5245,193314995,2018-06-06T07:25:19Z,testsuite/integration-arquillian/servers/auth-server/jboss/pom.xml,"@@ -782,33 +782,46 @@                                         </transformationSets>                                     </configuration>                                 </execution>+                            </executions>+                        </plugin>+                        +                        <plugin>+                            <groupId>org.codehaus.mojo</groupId>+                            <artifactId>exec-maven-plugin</artifactId>+                            <executions>                                 <execution>-                                    <id>mod-cluster-configuration</id>+                                    <id>mod-cluster-setup</id>                                     <phase>process-resources</phase>                                     <goals>-                                        <goal>transform</goal>+                                        <goal>exec</goal>                                     </goals>                                     <configuration>-                                        <transformationSets>-                                            <transformationSet>-                                                <dir>${auth.server.home}/standalone/configuration</dir>-                                                <includes>-                                                    <include>standalone-ha.xml</include>-                                                </includes>-                                                <stylesheet>${common.resources}/mod_cluster.xsl</stylesheet>-                                                <outputDir>${auth.server.home}/standalone/configuration</outputDir>-                                                <parameters>-                                                    <parameter>-                                                        <name>load.metric</name>-                                                        <value>${load.metric}</value>-                                                    </parameter>-                                                </parameters>-                                            </transformationSet>-                                        </transformationSets>+                                        <executable>${auth.server.home}/bin/jboss-cli.sh</executable>",I like the platform independence as was implemented below in wildfly-balancer/pom.xml. This one however introduces platform dependency (.sh). Could it be done the same way?,X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5245,193315116,2018-06-06T07:25:52Z,testsuite/integration-arquillian/servers/auth-server/jboss/pom.xml,"@@ -782,33 +782,46 @@                                         </transformationSets>                                     </configuration>                                 </execution>+                            </executions>+                        </plugin>+                        +                        <plugin>+                            <groupId>org.codehaus.mojo</groupId>+                            <artifactId>exec-maven-plugin</artifactId>+                            <executions>                                 <execution>-                                    <id>mod-cluster-configuration</id>+                                    <id>mod-cluster-setup</id>                                     <phase>process-resources</phase>                                     <goals>-                                        <goal>transform</goal>+                                        <goal>exec</goal>                                     </goals>                                     <configuration>-                                        <transformationSets>-                                            <transformationSet>-                                                <dir>${auth.server.home}/standalone/configuration</dir>-                                                <includes>-                                                    <include>standalone-ha.xml</include>-                                                </includes>-                                                <stylesheet>${common.resources}/mod_cluster.xsl</stylesheet>-                                                <outputDir>${auth.server.home}/standalone/configuration</outputDir>-                                                <parameters>-                                                    <parameter>-                                                        <name>load.metric</name>-                                                        <value>${load.metric}</value>-                                                    </parameter>-                                                </parameters>-                                            </transformationSet>-                                        </transformationSets>+                                        <executable>${auth.server.home}/bin/jboss-cli.sh</executable>+                                        <arguments>+                                            <argument>--file=${common.resources}/modcluster-simple-load-provider.cli</argument>+                                        </arguments>+                                    </configuration>+                                </execution>+                                <execution>+                                    <id>mod-cluster-setup-cleanup</id>+                                    <phase>process-resources</phase>+                                    <goals>+                                        <goal>exec</goal>+                                    </goals>+                                    <configuration>+                                        <workingDirectory>${auth.server.home}/standalone/</workingDirectory>+                                        <executable>rm</executable>",Prefer ant to shell commands for this type of tasks - it's platform independent.,
26590043,tmogi001,https://api.github.com/repos/keycloak/keycloak/pulls/5163,193316416,2018-06-06T07:31:08Z,services/src/main/java/org/keycloak/broker/oidc/AbstractOAuth2IdentityProvider.java,"@@ -327,6 +332,15 @@ protected UriBuilder createAuthorizationUrl(AuthenticationRequest request) {         if (acr != null) {             uriBuilder.queryParam(OAuth2Constants.ACR_VALUES, acr);         }+        String forwardParameterConfig = getConfig().getForwardParameters() != null ? getConfig().getForwardParameters(): """";+        List<String> forwardParameters = Arrays.asList(forwardParameterConfig.split(""\\s*,\\s*""));+        for(String forwardParameter: forwardParameters) {+            String name = AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX + forwardParameter.trim();","I will improve the tooltip message as follows.`Non OpenID Connect/OAuth standard query parameters to be forwarded to external IDP from the initial application request to Authorization Endpoint. Multiple parameters can be entered, separated by comma (,).`Does this make sense?",
335133,sebastienblanc,https://api.github.com/repos/keycloak/keycloak/pulls/5258,194645143,2018-06-12T07:57:17Z,adapters/oidc/spring-boot-adapter-core/src/main/java/org/keycloak/adapters/springboot/KeycloakBaseSpringBootConfiguration.java,"@@ -25,27 +25,17 @@ import org.apache.tomcat.util.descriptor.web.SecurityConstraint; import org.eclipse.jetty.security.ConstraintMapping; import org.eclipse.jetty.security.ConstraintSecurityHandler;+import org.eclipse.jetty.server.Handler; import org.eclipse.jetty.server.Server;+import org.eclipse.jetty.server.handler.HandlerCollection;+import org.eclipse.jetty.server.handler.HandlerList;+import org.eclipse.jetty.server.handler.HandlerWrapper; import org.eclipse.jetty.util.security.Constraint; import org.eclipse.jetty.webapp.WebAppContext; import org.keycloak.adapters.jetty.KeycloakJettyAuthenticator;-import org.keycloak.adapters.tomcat.KeycloakAuthenticatorValve; import org.keycloak.adapters.undertow.KeycloakServletExtension; import org.springframework.beans.factory.annotation.Autowired;-import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;-import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;-import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;-import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;-import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;-import org.springframework.boot.context.embedded.jetty.JettyEmbeddedServletContainerFactory;-import org.springframework.boot.context.embedded.jetty.JettyServerCustomizer;-import org.springframework.boot.context.embedded.tomcat.TomcatContextCustomizer;-import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;-import org.springframework.boot.context.embedded.undertow.UndertowDeploymentInfoCustomizer;-import org.springframework.boot.context.embedded.undertow.UndertowEmbeddedServletContainerFactory;-import org.springframework.boot.context.properties.EnableConfigurationProperties;-import org.springframework.context.annotation.Bean;-import org.springframework.context.annotation.Configuration;+import sun.plugin.dom.exception.InvalidStateException;","This import is making travis failing the compilation ```[ERROR] /home/travis/build/keycloak/keycloak/adapters/oidc/spring-boot-adapter-core/src/main/java/org/keycloak/adapters/springboot/KeycloakBaseSpringBootConfiguration.java:[38,32] package sun.plugin.dom.exception does not exist``` ",
701009,junezhang,https://api.github.com/repos/keycloak/keycloak/pulls/5277,195655452,2018-06-15T07:45:46Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/linked-accounts-page/linked-accounts-page.component.html,"@@ -1 +1,126 @@-<h1>Placeholder for Linked Accounts Page (formerly known as Federated Identity)</h1>\ No newline at end of file+<!--content-->+<div class=""page-header"">+  <h1>Linked Accounts</h1>+</div>+<div class=""col-sm-12 card-pf card-linked-account"">+  <div class=""card-pf-body row"">+    <div class=""col-md-3"">+      <div class=""card-pf-subtitle"">+        Authorized Provider+      </div>+      <div class=""introMessage"">+        <p>Authorized Providers linked with your account.</p>+      </div>+    </div>+    <div class=""col-md-9 linked-account-list"">","Do we need to add the second new css ""linked-account-list"", as above I found you already added ""card-linked-account""?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5311,197825596,2018-06-25T14:49:21Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/HardcodedLDAPGroupStorageMapperFactory.java,"@@ -0,0 +1,79 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.storage.ldap.mappers;++import org.keycloak.component.ComponentModel;+import org.keycloak.component.ComponentValidationException;+import org.keycloak.models.GroupModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.storage.ldap.LDAPStorageProvider;++import java.util.ArrayList;+import java.util.List;++/**+ * @author <a href=""mailto:jean-loup.maillet@yesitis.fr"">Jean-Loup Maillet</a>+ */+public class HardcodedLDAPGroupStorageMapperFactory extends AbstractLDAPStorageMapperFactory {++    public static final String PROVIDER_ID = ""hardcoded-ldap-group-mapper"";+    protected static final List<ProviderConfigProperty> configProperties = new ArrayList<ProviderConfigProperty>();++    static {+        ProviderConfigProperty groupAttr = createConfigProperty(HardcodedLDAPGroupStorageMapper.GROUP, ""Group"",+                ""Group to add the user in.  Click 'Select Group' button to browse groups, or just type it in the textbox."",","I think this tooltip, which will be shown in the admin console, is not correct. The type of the configuration property is String, so there won'be anything like ""Select Group"" combobox if I am correct? User will need to type the group manually including group path. Could you change the tooltip to something like: ``Group to add the user in.  Fill the full path of the group including path. For example '/root-group/child-group' . ``WDYT?If you want, you can contribute ""Group Selector"" angular component to our admin console. Something like ""Role Selector"" is currently doing. But that would be separate PR (and separate JIRA) if you want to do this :)",
22762,jloupdef,https://api.github.com/repos/keycloak/keycloak/pulls/5311,197829147,2018-06-25T14:58:59Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/HardcodedLDAPGroupStorageMapperFactory.java,"@@ -0,0 +1,79 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.storage.ldap.mappers;++import org.keycloak.component.ComponentModel;+import org.keycloak.component.ComponentValidationException;+import org.keycloak.models.GroupModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.storage.ldap.LDAPStorageProvider;++import java.util.ArrayList;+import java.util.List;++/**+ * @author <a href=""mailto:jean-loup.maillet@yesitis.fr"">Jean-Loup Maillet</a>+ */+public class HardcodedLDAPGroupStorageMapperFactory extends AbstractLDAPStorageMapperFactory {++    public static final String PROVIDER_ID = ""hardcoded-ldap-group-mapper"";+    protected static final List<ProviderConfigProperty> configProperties = new ArrayList<ProviderConfigProperty>();++    static {+        ProviderConfigProperty groupAttr = createConfigProperty(HardcodedLDAPGroupStorageMapper.GROUP, ""Group"",+                ""Group to add the user in.  Click 'Select Group' button to browse groups, or just type it in the textbox."",","Yes, you are perfectly right.I wanted to do the group selection component but postponed it... Did not think of correcting the tooltip.I changed it as you proposed.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5303,197932482,2018-06-25T20:33:29Z,adapters/saml/wildfly/wildfly-subsystem/src/main/java/org/keycloak/subsystem/adapter/saml/extension/Elytron.java,"@@ -0,0 +1,60 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.subsystem.adapter.saml.extension;++import org.jboss.as.controller.capability.CapabilityServiceSupport;+import org.jboss.as.server.deployment.Attachments;",unused imports,X
39477523,mingjliu9,https://api.github.com/repos/keycloak/keycloak/pulls/5293,198150609,2018-06-26T13:50:39Z,pom.xml,"@@ -705,8 +707,18 @@             <dependency>                 <groupId>org.jboss.aesh</groupId>","If my understanding is right, we no longer need this `org.jboss.aesh` dependency now.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5293,199071478,2018-06-29T07:07:53Z,pom.xml,"@@ -705,8 +707,18 @@             <dependency>                 <groupId>org.jboss.aesh</groupId>","@mingjliu9 It's unfortunately still needed as keycloak-admin-cli and keycloak-client-registration-cli are still using it. Both CLIs are packed in server distribution in directory KEYCLOAK_HOME/bin/client/ in the ""fat"" jars, which among other things, contain the classes of old aesh. I've created https://issues.jboss.org/browse/KEYCLOAK-7737 . Fortunately org.jboss.aesh is not needed in jboss modules, so IMO KEYCLOAK-7737 is not a blocker for this PR, but can be done later.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5293,199134642,2018-06-29T11:46:52Z,distribution/feature-packs/server-feature-pack/src/main/resources/content/bin/migrate-domain-standalone.cli,"@@ -47,6 +47,7 @@ if (result == undefined) of /profile=$standaloneProfile/subsystem=infinispan/cac   echo Updating authorization cache container..   /profile=$standaloneProfile/subsystem=infinispan/cache-container=keycloak/local-cache=authorization/component=eviction/:write-attribute(name=strategy,value=LRU)   /profile=$standaloneProfile/subsystem=infinispan/cache-container=keycloak/local-cache=authorization/component=eviction/:write-attribute(name=max-entries,value=100)+  echo",That's just for adding another line to the output of the CLI command. I've just tried without echo and the output doesn't look so nice. Also the pattern with empty echo is used in whole file and all the previous instructions.,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/5284,199841530,2018-07-03T15:03:29Z,services/src/main/java/org/keycloak/services/resources/admin/UserResource.java,"@@ -195,6 +195,7 @@ public static void updateUserFromRep(UserModel user, UserRepresentation rep, Set             user.setUsername(rep.getUsername());         }         if (rep.getEmail() != null) user.setEmail(rep.getEmail());+        if (rep.getEmail() == """") user.setEmail(null);",@pedroigor That's actually a completely different issue.  You should never be allowed to set an email address to a string of spaces.  But right now you can.  We don't check to see if the email has a valid format.The thing this JIRA addresses is the case where you want to get rid of the email all together.  It used to save the address as empty string.  Then if you want to get rid of the email on another user it would try to save it as empty string and it would think that it was a duplicate email address.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5314,200438836,2018-07-05T17:57:43Z,themes/src/main/resources/theme/base/admin/resources/partials/authz/resource-server-resource-list.html,"@@ -144,6 +145,11 @@                                     <span data-ng-show=""resource.policies && !resource.policies.length"">{{:: 'authz-no-permission-assigned' | translate}}</span>                                     <span ng-repeat=""policy in resource.policies"" data-ng-show=""resource.policies.length > 0""><a href=""#/realms/{{realm.realm}}/clients/{{client.id}}/authz/resource-server/permission/{{policy.type}}/{{policy.id}}"">{{policy.name}}</a>{{$last ? '' : ', '}}</span>                                 </dd>+                                <dt>{{:: 'authz-uris' | translate}}</dt>+                                <dd>+                                    <span data-ng-show=""resource.policies && !resource.policies.length"">{{:: 'authz-no-uri-defined' | translate}}</span>","You probably need to change this to:```html<span data-ng-show=""resource.uris && !resource.uris.length"">{{:: 'authz-no-uri-defined' | translate}}</span>```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5319,201289164,2018-07-10T10:14:28Z,adapters/oidc/osgi-adapter/src/main/java/org/keycloak/adapters/osgi/PathBasedKeycloakConfigResolver.java,"@@ -31,10 +34,117 @@  public class PathBasedKeycloakConfigResolver implements KeycloakConfigResolver { +    protected static final Logger log = Logger.getLogger(PaxWebIntegrationService.class);",Nit: should be `Logger.getLogger(PathBasedKeycloakConfigResolver.class);`,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5319,201289359,2018-07-10T10:15:12Z,adapters/oidc/osgi-adapter/src/main/java/org/keycloak/adapters/osgi/HierarchicalPathBasedKeycloakConfigResolver.java,"@@ -0,0 +1,89 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.adapters.osgi;++import java.net.URI;+import java.util.ArrayList;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.adapters.KeycloakConfigResolver;+import org.keycloak.adapters.KeycloakDeployment;+import org.keycloak.adapters.OIDCHttpFacade;++/**+ * This {@link KeycloakConfigResolver} tries to resolve most specific configuration for given URI path. If not found,+ * <em>parent</em> path is checked up to top-level path.+ */+public class HierarchicalPathBasedKeycloakConfigResolver extends PathBasedKeycloakConfigResolver {++    protected static final Logger log = Logger.getLogger(PaxWebIntegrationService.class);",Nit: should be `Logger.getLogger(HierarchicalPathBasedKeycloakConfigResolver.class);`,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5352,202309793,2018-07-13T10:29:12Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/OAuthRequestAuthenticator.java,"@@ -335,28 +336,26 @@ protected AuthChallenge resolveCode(String code) {             String httpSessionId = deployment.getTokenStore() == TokenStore.SESSION ? reqAuthenticator.changeHttpSessionId(true) : null;             tokenResponse = ServerRequest.invokeAccessCodeToToken(deployment, code, rewrittenRedirectUri(strippedOauthParametersRequestUri), httpSessionId);         } catch (ServerRequest.HttpFailure failure) {-            log.error(""failed to turn code into token"");-            log.error(""status from server: "" + failure.getStatus());+            log.log(Level.SEVERE,""failed to turn code into token"");+            log.log(Level.SEVERE,""status from server: "" + failure.getStatus());             if (failure.getError() != null) {-                log.error(""   "" + failure.getError());+                log.log(Level.SEVERE,""   "" + failure.getError());             }             return challenge(403, OIDCAuthenticationError.Reason.CODE_TO_TOKEN_FAILURE, null);          } catch (IOException e) {-            log.error(""failed to turn code into token"", e);+            log.log(Level.SEVERE,""failed to turn code into token"", e);             return challenge(403, OIDCAuthenticationError.Reason.CODE_TO_TOKEN_FAILURE, null);         }          tokenString = tokenResponse.getToken();         refreshToken = tokenResponse.getRefreshToken();         idTokenString = tokenResponse.getIdToken(); -        log.debug(""Verifying tokens"");-        if (log.isTraceEnabled()) {-            logToken(""\taccess_token"", tokenString);-            logToken(""\tid_token"", idTokenString);-            logToken(""\trefresh_token"", refreshToken);-        }+        log.log(Level.FINE, ""Verifying tokens"");+        logToken(""\taccess_token"", tokenString);",Don't remove the condition here.,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5335,202774235,2018-07-16T18:13:24Z,distribution/feature-packs/server-feature-pack/pom.xml,"@@ -72,6 +72,16 @@                 </exclusion>             </exclusions>         </dependency>+        <dependency>",Did you check if this dependency is available in Brew? If not we'll need to build it in Brew before we can merge so it doesn't break RH-SSO builds,
13701445,dteleguin,https://api.github.com/repos/keycloak/keycloak/pulls/5383,202866806,2018-07-17T00:43:45Z,adapters/oidc/servlet-filter/pom.xml,"@@ -30,6 +30,16 @@     <name>Keycloak Servlet Filter Adapter Integration</name>     <description/> +    <properties>+        <keycloak.osgi.export>+            org.keycloak.adapters.servlet.*+        </keycloak.osgi.export>+        <keycloak.osgi.import>+            org.keycloak.*;version=""${project.version}"",","Yes, that's correct. The complete list of the deps is the following:* keycloak-adapter-core* keycloak-adapter-spi* keycloak-authz-client* keycloak-common* keycloak-core* keycloak-osgi-thirdparty (pre-4.2.0)* keycloak-servlet-adapter-spiAll the modules, except for keycloak-servlet-adapter-spi, have been previously published as OSGi bundles. This PR fills the missing piece.",
419425,gtudan,https://api.github.com/repos/keycloak/keycloak/pulls/5387,202993470,2018-07-17T12:01:14Z,examples/cordova-native/www/index.html,"@@ -0,0 +1,123 @@+<!DOCTYPE html>+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<html>+<head>+    <title>Authentication Example</title>++    <meta http-equiv=""Content-Security-Policy"" content=""default-src * gap://ready; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' 'unsafe-eval'"">++    <script type=""text/javascript"" charset=""utf-8"" src=""cordova.js""></script>+    <script type=""text/javascript"" charset=""utf-8"" src=""keycloak.js""></script>+    <script type=""text/javascript"" charset=""utf-8"">+        var keycloak = new Keycloak();++        keycloak.onAuthSuccess = updateState;+        keycloak.onAuthRefreshSuccess = updateState;+        keycloak.onAuthLogout = updateState;++        function updateState() {+            if (keycloak.authenticated) {+                document.getElementById('authenticated').style.display = 'block';+                document.getElementById('not-authenticated').style.display = 'none';++                document.getElementById('subject').innerText = keycloak.subject;+                document.getElementById('username').innerText = keycloak.idTokenParsed.preferred_username;+                document.getElementById('tokenExpires').innerText = new Date(keycloak.tokenParsed.exp * 1000).toLocaleString();+                document.getElementById('tokenRefreshExpires').innerText = new Date(keycloak.refreshTokenParsed.exp * 1000).toLocaleString();+                document.getElementById('token').innerText = JSON.stringify(keycloak.tokenParsed, null, '  ');+                document.getElementById('idToken').innerText = JSON.stringify(keycloak.idTokenParsed, null, '  ');+            } else {+                document.getElementById('authenticated').style.display = 'none';+                document.getElementById('not-authenticated').style.display = 'block';+            }+        }++        function error() {+            document.getElementById('authenticated').style.display = 'none';+            document.getElementById('not-authenticated').style.display = 'block';+            document.getElementById('error').innerText = 'Failed to initialize Keycloak adapter';+        }++        document.addEventListener(""deviceready"", function() {+            keycloak.init({+              adapter: 'cordova-native',+              responseMode: 'query',+              onLoad: 'check-sso',+              redirectUri: 'android-app://org.keycloak.examples.cordova/https/keycloak-cordova-example.github.io/login'+            }).success(updateState).error(error);+        }, false);+    </script>+    <style>+        td {+            vertical-align: top;+        }++        tr.odd td {+            background-color: #eee;+        }+    </style>+</head>+<body>+<div id=""authenticated"" style=""display: none;"">+    <div>+        <button onclick=""keycloak.logout()"">Log out</button>","Logout will bounce the user to http://keycloak-cordova-example.github.io/login which is fine from a technical point of view, but might look strange if the redirect back to the app doesn't work and the user ends here. I'd suggest setting an explicit redirect url to /logout in here. The URL would need to be registered in the `config.xml`",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5383,203014084,2018-07-17T13:12:19Z,adapters/oidc/servlet-filter/pom.xml,"@@ -30,6 +30,16 @@     <name>Keycloak Servlet Filter Adapter Integration</name>     <description/> +    <properties>+        <keycloak.osgi.export>+            org.keycloak.adapters.servlet.*+        </keycloak.osgi.export>+        <keycloak.osgi.import>+            org.keycloak.*;version=""${project.version}"",",Would you add explicit dependency to `javax.servlet` package similarly to [this](https://github.com/AcutusPro/keycloak/blob/42e6337954996275389cf70494a3b313816494e0/adapters/oidc/osgi-adapter/pom.xml#L40)? (Thanks @grgrzybek for pointin this out),
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5389,203280610,2018-07-18T07:47:17Z,services/src/main/java/org/keycloak/services/resources/AbstractSecuredLocalService.java,"@@ -88,13 +89,25 @@ public Response loginRedirect(@QueryParam(""code"") String code,                                   @QueryParam(""referrer"") String referrer,                                   @Context HttpHeaders headers) {         try {-            if (error != null) {-                logger.debug(""error from oauth"");-                throw new ForbiddenException(""error"");-            }             if (path != null && !getValidPaths().contains(path)) {                 throw new BadRequestException(""Invalid path"");             }+            KeycloakUriBuilder redirect = KeycloakUriBuilder.fromUri(getBaseRedirectUri());+            if (path != null) {+                redirect.path(path);+            }+            if (referrer != null) {+                redirect.queryParam(""referrer"", referrer);+            }+            if (error != null) {+                if (OAuthErrorException.ACCESS_DENIED.equals(error)) {+                    // cased by CANCELLED_BY_USER or CONSENT_DENIED, just redirect back to login page+                    return Response.status(302).location(redirect.build()).build();","Show error page with link ""back to application"".Something like```javareturn session.getProvider(LoginFormsProvider.class).setError(Messages.NO_ACCESS).createErrorPage(Response.Status.FORBIDDEN);`",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5377,203394620,2018-07-18T14:12:56Z,services/src/main/java/org/keycloak/authorization/authorization/AuthorizationTokenService.java,"@@ -403,63 +426,49 @@ private KeycloakEvaluationContext createEvaluationContext(AuthorizationRequest a             }         } -        String rpt = request.getRpt();--        if (rpt != null) {-            if (!Tokens.verifySignature(getKeycloakSession(), getRealm(), rpt)) {-                throw new CorsErrorResponseException(cors, ""invalid_rpt"", ""RPT signature is invalid"", Status.FORBIDDEN);-            }+        AccessToken rpt = request.getRpt(); -            AccessToken requestingPartyToken;+        if (rpt != null && rpt.isActive()) {+            AccessToken.Authorization authorizationData = rpt.getAuthorization(); -            try {-                requestingPartyToken = new JWSInput(rpt).readJsonContent(AccessToken.class);-            } catch (JWSInputException e) {-                throw new CorsErrorResponseException(cors, ""invalid_rpt"", ""Invalid RPT"", Status.FORBIDDEN);-            }+            if (authorizationData != null) {+                List<Permission> permissions = authorizationData.getPermissions(); -            if (requestingPartyToken.isActive()) {-                AccessToken.Authorization authorizationData = requestingPartyToken.getAuthorization();--                if (authorizationData != null) {-                    List<Permission> permissions = authorizationData.getPermissions();+                if (permissions != null) {+                    for (Permission grantedPermission : permissions) {+                        if (limit != null && limit <= 0) {+                            break;+                        } -                    if (permissions != null) {-                        for (Permission grantedPermission : permissions) {-                            if (limit != null && limit <= 0) {-                                break;-                            }+                        Resource resourcePermission = resourceStore.findById(grantedPermission.getResourceId(), ticket.getAudience()[0]);","Again some confusing variable naming. There is Resource object which is named resourcePermission, and a bit later (line 446) there is ResourcePermission object named permission. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5392,205024317,2018-07-25T08:32:24Z,server-spi/src/main/java/org/keycloak/models/RealmModel.java,"@@ -307,7 +307,7 @@     List<IdentityProviderModel> getIdentityProviders();     IdentityProviderModel getIdentityProviderByAlias(String alias);     void addIdentityProvider(IdentityProviderModel identityProvider);-    void removeIdentityProviderByAlias(String alias);+    boolean removeIdentityProviderByAlias(String alias);","This change is not needed, the `removeIdentityProviderByAlias` either succeeds or throws an exception.",X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/5260,209156522,2018-08-10T06:31:53Z,services/src/main/java/org/keycloak/keys/FailsafeEcdsaKeyProvider.java,"@@ -0,0 +1,66 @@+package org.keycloak.keys;++import java.security.KeyPair;+import java.util.Collections;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.common.util.KeyUtils;+import org.keycloak.common.util.Time;+import org.keycloak.crypto.Algorithm;+import org.keycloak.crypto.KeyStatus;+import org.keycloak.crypto.KeyType;+import org.keycloak.crypto.KeyUse;+import org.keycloak.crypto.KeyWrapper;++// KEYCLOAK-7560 Refactoring Token Signing and Verifying by Token Signature SPI++public class FailsafeEcdsaKeyProvider implements KeyProvider {++    private static final Logger logger = Logger.getLogger(FailsafeEcdsaKeyProvider.class);++    private static KeyWrapper KEY;++    private static long EXPIRES;","It seems that KEY and EXPIRES are guarded against multiple accesses concurrently by synchronized (FailsafeEcdsaKeyProvider.class) block in the constructor and also make them visible   out of this block from other threads. Moreover, KEY and EXPIRES are not accessed other than the constructor. Does it already suffice to guard KEY and EXPIRE static members against simultaneous multiple accesses and make them visible from other threads ?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5260,209173616,2018-08-10T07:53:18Z,services/src/main/java/org/keycloak/jose/jws/TokenSignature.java,"@@ -0,0 +1,97 @@+package org.keycloak.jose.jws;++import java.security.Key;+import java.util.LinkedList;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.crypto.KeyUse;+import org.keycloak.crypto.KeyWrapper;+import org.keycloak.jose.jws.JWSSignatureProvider;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.provider.ProviderFactory;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.representations.RefreshToken;+import org.keycloak.util.TokenUtil;++// KEYCLOAK-7560 Refactoring Token Signing and Verifying by Token Signature SPI++public class TokenSignature {++    private static final Logger logger = Logger.getLogger(TokenSignature.class);++    KeycloakSession session;+    RealmModel realm;+    String sigAlgName;++    public static TokenSignature getInstance(KeycloakSession session, RealmModel realm, String sigAlgName) {+        return new TokenSignature(session, realm, sigAlgName);+    }++    public TokenSignature(KeycloakSession session, RealmModel realm, String sigAlgName) {+        this.session = session;+        this.realm = realm;+        this.sigAlgName = sigAlgName;+    }++    public String sign(JsonWebToken jwt) {+        TokenSignatureProvider tokenSignatureProvider = getTokenSignatureProvider(sigAlgName);+        if (tokenSignatureProvider == null) return null;++        KeyWrapper keyWrapper = session.keys().getActiveKey(realm, KeyUse.SIG, sigAlgName);+        if (keyWrapper == null) return null;++        String keyId = keyWrapper.getKid();+        Key signKey = keyWrapper.getSignKey();+        String encodedToken = new JWSBuilder().type(""JWT"").kid(keyId).jsonContent(jwt).sign((JWSSignatureProvider)tokenSignatureProvider, sigAlgName, signKey);+        return encodedToken;+    }++    public boolean verify(JWSInput jws) throws JWSInputException {+        TokenSignatureProvider tokenSignatureProvider = getTokenSignatureProvider(sigAlgName);+        if (tokenSignatureProvider == null) return false;++        KeyWrapper keyWrapper = null;+        // Backwards compatibility. Old offline tokens didn't have KID in the header+        if (jws.getHeader().getKeyId() == null && isOfflineToken(jws)) {+            logger.debugf(""KID is null in offline token. Using the realm active key to verify token signature."");+            keyWrapper = session.keys().getActiveKey(realm, KeyUse.SIG, sigAlgName);+        } else {+            keyWrapper = session.keys().getKey(realm, jws.getHeader().getKeyId(), KeyUse.SIG, sigAlgName);+        }+        if (keyWrapper == null) return false;++        return tokenSignatureProvider.verify(jws, keyWrapper.getVerifyKey());+    }++    private static final String COMPONENT_SIGNATURE_ALGORITHM_KEY = ""org.keycloak.jose.jws.TokenSignatureProvider.algorithm"";++    @SuppressWarnings(""rawtypes"")+    private TokenSignatureProvider getTokenSignatureProvider(String sigAlgName) {+        List<ComponentModel> components = new LinkedList<>(realm.getComponents(realm.getId(), TokenSignatureProvider.class.getName()));",Good idea yet it would also need a mechanism for invalidating the provider instances upon change of the component configuration. Let's leave this out for this PR for now and file a JIRA (once this PR would be merged ) with this optimization later.,
859697,leoluk,https://api.github.com/repos/keycloak/keycloak/pulls/5454,209428596,2018-08-11T14:44:33Z,services/src/main/java/org/keycloak/social/slack/SlackIdentityProvider.java,"@@ -0,0 +1,82 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.social.slack;++import com.fasterxml.jackson.databind.JsonNode;+import org.keycloak.broker.oidc.AbstractOAuth2IdentityProvider;+import org.keycloak.broker.oidc.OAuth2IdentityProviderConfig;+import org.keycloak.broker.oidc.mappers.AbstractJsonUserAttributeMapper;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.broker.provider.BrokeredIdentityContext;+import org.keycloak.broker.provider.IdentityBrokerException;+import org.keycloak.broker.social.SocialIdentityProvider;+import org.keycloak.models.KeycloakSession;++/**+ * @author Leopold Schabel+ */+public class SlackIdentityProvider extends AbstractOAuth2IdentityProvider implements SocialIdentityProvider {++	public static final String AUTH_URL = ""https://slack.com/oauth/authorize"";+	public static final String TOKEN_URL = ""https://slack.com/api/oauth.access"";+	public static final String PROFILE_URL = ""https://slack.com/api/users.identity"";+	public static final String DEFAULT_SCOPE = ""identity.basic identity.email identity.team"";++	public SlackIdentityProvider(KeycloakSession session, OAuth2IdentityProviderConfig config) {+		super(session, config);+		config.setAuthorizationUrl(AUTH_URL);+		config.setTokenUrl(TOKEN_URL);+		config.setUserInfoUrl(PROFILE_URL);+	}++	protected BrokeredIdentityContext doGetFederatedIdentity(String accessToken) {+		try {+			JsonNode raw = SimpleHttp.doGet(PROFILE_URL,session).param(""token"", accessToken).asJson();+			+			JsonNode user = raw.get(""user"");+			JsonNode team = raw.get(""team"");++			logger.debug(user.toString());++			String id = getJsonProperty(user, ""id"");+			String team_id = getJsonProperty(team, ""id"");++			BrokeredIdentityContext profile = new BrokeredIdentityContext(String.format(""%s-%s"", team_id, id));++			String displayname = getJsonProperty(user, ""name"");++			String email = getJsonProperty(user, ""email"");++			profile.setUsername(displayname);+			profile.setEmail(email);+			profile.setIdpConfig(getConfig());+			profile.setIdp(this);++			AbstractJsonUserAttributeMapper.storeUserProfileForMapper(profile, user, getConfig().getAlias());",Slack has both `user` and `team` metadata. Can we just store the whole `raw` object here instead of only `user`?,
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/5475,211207531,2018-08-20T10:06:27Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/realm/RealmTest.java,"@@ -282,6 +283,59 @@ public void renameRealmTest() throws Exception {         adminClient.realms().realm(""test-immutable"").remove();     } +    private RealmEventsConfigRepresentation copyRealmEventsConfigRepresentation(RealmEventsConfigRepresentation rep) {+        RealmEventsConfigRepresentation recr = new RealmEventsConfigRepresentation();+        recr.setEnabledEventTypes(rep.getEnabledEventTypes());+        recr.setEventsListeners(rep.getEventsListeners());+        recr.setEventsExpiration(rep.getEventsExpiration());+        recr.setEventsEnabled(rep.isEventsEnabled());+        recr.setAdminEventsEnabled(rep.isAdminEventsEnabled());+        recr.setAdminEventsDetailsEnabled(rep.isAdminEventsDetailsEnabled());+        return recr;+    }+    +    private void checkRealmEventsConfigRepresentation(RealmEventsConfigRepresentation expected,+            RealmEventsConfigRepresentation actual) {+        assertEquals(expected.getEnabledEventTypes().size(), actual.getEnabledEventTypes().size());+        assertTrue(actual.getEnabledEventTypes().containsAll(expected.getEnabledEventTypes()));+        assertEquals(expected.getEventsListeners().size(), actual.getEventsListeners().size());+        assertTrue(actual.getEventsListeners().containsAll(expected.getEventsListeners()));+        assertEquals(expected.getEventsExpiration(), actual.getEventsExpiration());+        assertEquals(expected.isEventsEnabled(), actual.isEventsEnabled());+        assertEquals(expected.isAdminEventsEnabled(), actual.isAdminEventsEnabled());+        assertEquals(expected.isAdminEventsDetailsEnabled(), actual.isAdminEventsDetailsEnabled());+    }+    +    @Test+    public void updateRealmEventsConfig() {+        RealmEventsConfigRepresentation rep = realm.getRealmEventsConfig();+        RealmEventsConfigRepresentation repOrig = copyRealmEventsConfigRepresentation(rep);+        // first modification => remove ""event-queue"", should be sent to the queue","Hi @hmlnarik,The ""event-queue"" is the audit listener that stores the events in memory for testing. There is also a ws endpoint to retrieve the event for the queue (only for testing). If it was not set almost all the tests in that class would fail (the ""assertAdminEvents"" class checks that part). If you want I can set it first but it makes no sense, if it was not there, ""updateRealm"", ""updateRealmWithNewRepresentation"" or ""updateRealmAttributes"" would fail too, they depend on that test listener.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5439,211262045,2018-08-20T13:32:02Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/realm/RealmRolesTest.java,"@@ -257,5 +257,43 @@ public void roleMembershipAfterUserRemoval() {         assertEquals(0, roleResource.getRoleUserMembers().size());      }-    ++    /**+     *+     */+    @Test+    public void testRoleMembershipWithPagination() {+        RoleResource role = resource.get(""role-with-users"");++        // Add a second user+        UserRepresentation userRep2 = new UserRepresentation();+        userRep2.setUsername(""test-role-member2"");+        userRep2.setEmail(""test-role-member2@test-role-member.com"");+        userRep2.setRequiredActions(Collections.<String>emptyList());+        userRep2.setEnabled(true);+        adminClient.realm(REALM_NAME).users().create(userRep2);++        List<UserRepresentation> users = adminClient.realm(REALM_NAME).users().search(""test-role-member"", null, null, null, null, null);+        assertEquals(2, users.size());+        for (UserRepresentation userRepFromList : users) {+            UserResource user = adminClient.realm(REALM_NAME).users().get(userRepFromList.getId());+            UserRepresentation userRep = user.toRepresentation();++            RoleResource roleResource = adminClient.realm(REALM_NAME).roles().get(role.toRepresentation().getName());+            List<RoleRepresentation> rolesToAdd = new LinkedList<>();+            rolesToAdd.add(roleResource.toRepresentation());+            adminClient.realm(REALM_NAME).users().get(userRep.getId()).roles().realmLevel().add(rolesToAdd);+        }++        RoleResource roleResource = adminClient.realm(REALM_NAME).roles().get(role.toRepresentation().getName());+        Set<UserRepresentation> roleUserMembers = roleResource.getRoleUserMembers(0, 1);+        assertEquals(roleUserMembers.size(), 1);++        roleUserMembers = roleResource.getRoleUserMembers(1, 1);+        assertEquals(roleUserMembers.size(), 1);","In addition, please check a detail of the users, not only size of the result list, since the two calls (lines 290, 293) could potentially return the same user due to some bug - and we want to catch it here.Also prefer `assertThat(roleUserMembers, hasSize(1));` to `assertEquals`. (similarly on l. 277, 290)",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5293,212589000,2018-08-24T10:39:05Z,testsuite/integration-arquillian/servers/app-server/jboss/eap/src/main/java/org/keycloak/testsuite/arquillian/eap/container/EAPAppServerProvider.java,"@@ -40,6 +40,7 @@     private final String startupTimeoutInSeconds;      public EAPAppServerProvider() {+        containerName = System.getProperty(""app.server"");",Wouldn't be better to also test that property is not null or empty? I know it is set by property in pom.xml but in case someone accidentally removes it it will start failing with NPE. See the lines below.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5501,212874083,2018-08-27T06:13:18Z,services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java,"@@ -0,0 +1,208 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.services.resources.account;++import java.net.URI;+import java.nio.charset.StandardCharsets;+import java.security.MessageDigest;+import java.util.UUID;+import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;+import javax.ws.rs.core.UriBuilder;+import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.common.util.Base64Url;+import org.keycloak.credential.CredentialModel;+import org.keycloak.events.Details;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.FederatedIdentityModel;+import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.ErrorResponse;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.Auth;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.validation.Validation;++/**+ * API for linking/unlinking social login accounts+ *+ * @author Stan Silvert+ */+public class LinkedAccountsResource {+    private static final Logger logger = Logger.getLogger(LinkedAccountsResource.class);+    +    private final KeycloakSession session;+    private final HttpRequest request;+    private final ClientModel client;+    private final EventBuilder event;+    private final UserModel user;+    private final RealmModel realm;+    private final Auth auth;++    public LinkedAccountsResource(KeycloakSession session, +                                  HttpRequest request, +                                  ClientModel client,+                                  Auth auth, +                                  EventBuilder event, +                                  UserModel user) {+        this.session = session;+        this.request = request;+        this.client = client;+        this.auth = auth;+        this.event = event;+        this.user = user;+        realm = session.getContext().getRealm();+    }+    +    @GET+    @Path(""/"")+    @Produces(MediaType.APPLICATION_JSON)+    public Response linkedAccounts() {+        LinkedAccountsBean linkedAccounts = new LinkedAccountsBean(this.session, this.realm, this.user);","Should have a LinkedAccountRepresentation class with plain getters/setters like all other REST endpoints do. This will allow us to create proper API docs. Also, would help to allow creating a Java account service client lib.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5533,215610227,2018-09-06T12:44:45Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCConfigAttributes.java,"@@ -0,0 +1,26 @@+package org.keycloak.protocol.oidc;++public interface OIDCConfigAttributes {",Could this be turned into a class with `public static final String` fields instead?,X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5533,215611950,2018-09-06T12:50:04Z,themes/src/main/resources/theme/base/admin/resources/partials/realm-tokens.html,"@@ -3,6 +3,19 @@      <form class=""form-horizontal"" name=""realmForm"" novalidate kc-read-only=""!access.manageRealm""> +        <div class=""form-group"">+            <label class=""col-md-2 control-label"" for=""defaultSignatureAlgorithm"">{{:: 'default-signature-algorithm' | translate}}</label>++            <div class=""col-md-6"">+                <select id=""defaultSignatureAlgorithm"" class=""form-control"" ng-model=""realm.defaultSignatureAlgorithm""+                        ng-options=""provider for provider in serverInfo.listProviderIds('signature')"">+                </select>+            </div>++            <kc-tooltip>{{:: 'default-signature-algorithm.tooltip' | translate}}+            </kc-tooltip>+        </div>+","I wonder whether we should extend ""Tokens"" page with similar settings for SAML client defaults (as another issue)",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5533,215651513,2018-09-06T14:39:36Z,server-spi/src/main/java/org/keycloak/models/KeycloakSession.java,"@@ -178,4 +178,11 @@      */     ThemeManager theme(); +    /**+     * JWT manager+     *+     * @return+     */+    JWTManager jwt();","Not a blocker, but as we discussed, a `token()` method and `TokenManager` (or similar) makes more sense. Or even just a `Token` or `KeycloakToken` interface which acts as a facade for any operation on keycloak tokens.",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5533,215736846,2018-09-06T18:46:26Z,core/src/main/java/org/keycloak/jose/jws/JWSBuilder.java,"@@ -101,13 +106,30 @@ protected void encode(Algorithm alg, byte[] data, StringBuffer encoding) {     }      public class EncodingBuilder {++        public String sign(SignatureContext signer) {+            kid = signer.getKid();++            StringBuffer buffer = new StringBuffer();",Good point. Rest of the class used StringBuffer that's why it ended up like that. Will change it though.,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5533,216208645,2018-09-10T06:20:41Z,services/src/main/java/org/keycloak/jose/jws/DefaultTokenManager.java,"@@ -0,0 +1,105 @@+package org.keycloak.jose.jws;++import org.jboss.logging.Logger;+import org.keycloak.Token;+import org.keycloak.TokenCategory;+import org.keycloak.crypto.Algorithm;+import org.keycloak.crypto.KeyUse;+import org.keycloak.crypto.SignatureProvider;+import org.keycloak.crypto.SignatureSignerContext;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.TokenManager;+import org.keycloak.protocol.oidc.OIDCConfigAttributes;++public class DefaultTokenManager implements TokenManager {++    private static final Logger logger = Logger.getLogger(DefaultTokenManager.class);++    private static String DEFAULT_ALGORITHM_NAME = Algorithm.RS256;++    private final KeycloakSession session;++    public DefaultTokenManager(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public String encode(Token token) {+        String signatureAlgorithm = signatureAlgorithm(token.getCategory());++        SignatureProvider signatureProvider = session.getProvider(SignatureProvider.class, signatureAlgorithm);+        SignatureSignerContext signer = signatureProvider.signer();++        String encodedToken = new JWSBuilder().type(""JWT"").jsonContent(token).sign(signer);+        return encodedToken;+    }++    @Override+    public <T extends Token> T decode(String token, Class<T> clazz) {+        if (token == null) {+            return null;+        }++        try {+            JWSInput jws = new JWSInput(token);++            String signatureAlgorithm = jws.getHeader().getAlgorithm().name();++            SignatureProvider signatureProvider = session.getProvider(SignatureProvider.class, signatureAlgorithm);+            if (signatureProvider == null) {+                return null;+            }++            String kid = jws.getHeader().getKeyId();+            // Backwards compatibility. Old offline tokens and cookies didn't have KID in the header+            if (kid == null) {+                logger.debugf(""KID is null in token. Using the realm active key to verify token signature."");+                kid = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.SIG, signatureAlgorithm).getKid();+            }++            boolean valid = signatureProvider.verifier(kid).verify(jws.getEncodedSignatureInput().getBytes(""UTF-8""), jws.getSignature());+            return valid ? jws.readJsonContent(clazz) : null;+        } catch (Exception e) {+            logger.debug(""Failed to decode token"", e);+            return null;+        }+    }++    @Override+    public String signatureAlgorithm(TokenCategory category) {+        switch (category) {+            case INTERNAL:+                return Algorithm.HS256;+            case ADMIN:+                return getSignatureAlgorithm(null);+            case ACCESS:+                return getSignatureAlgorithm(OIDCConfigAttributes.ACCESS_TOKEN_SIGNED_RESPONSE_ALG);","If an app wants to be able to invoke different services with different tokens that is not a trivial setup. The app would either have to do the login flow multiple times or more likely rely on token exchange. It's certainly a more complex use-cases than what is addressed in this PR, so would be a follow-up later and most likely on demand.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5533,216225102,2018-09-10T07:46:31Z,services/src/main/java/org/keycloak/jose/jws/DefaultTokenManager.java,"@@ -0,0 +1,105 @@+package org.keycloak.jose.jws;++import org.jboss.logging.Logger;+import org.keycloak.Token;+import org.keycloak.TokenCategory;+import org.keycloak.crypto.Algorithm;+import org.keycloak.crypto.KeyUse;+import org.keycloak.crypto.SignatureProvider;+import org.keycloak.crypto.SignatureSignerContext;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.TokenManager;+import org.keycloak.protocol.oidc.OIDCConfigAttributes;++public class DefaultTokenManager implements TokenManager {++    private static final Logger logger = Logger.getLogger(DefaultTokenManager.class);++    private static String DEFAULT_ALGORITHM_NAME = Algorithm.RS256;++    private final KeycloakSession session;++    public DefaultTokenManager(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public String encode(Token token) {+        String signatureAlgorithm = signatureAlgorithm(token.getCategory());++        SignatureProvider signatureProvider = session.getProvider(SignatureProvider.class, signatureAlgorithm);+        SignatureSignerContext signer = signatureProvider.signer();++        String encodedToken = new JWSBuilder().type(""JWT"").jsonContent(token).sign(signer);+        return encodedToken;+    }++    @Override+    public <T extends Token> T decode(String token, Class<T> clazz) {+        if (token == null) {+            return null;+        }++        try {+            JWSInput jws = new JWSInput(token);++            String signatureAlgorithm = jws.getHeader().getAlgorithm().name();++            SignatureProvider signatureProvider = session.getProvider(SignatureProvider.class, signatureAlgorithm);+            if (signatureProvider == null) {+                return null;+            }++            String kid = jws.getHeader().getKeyId();+            // Backwards compatibility. Old offline tokens and cookies didn't have KID in the header+            if (kid == null) {+                logger.debugf(""KID is null in token. Using the realm active key to verify token signature."");+                kid = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.SIG, signatureAlgorithm).getKid();+            }++            boolean valid = signatureProvider.verifier(kid).verify(jws.getEncodedSignatureInput().getBytes(""UTF-8""), jws.getSignature());+            return valid ? jws.readJsonContent(clazz) : null;+        } catch (Exception e) {+            logger.debug(""Failed to decode token"", e);+            return null;+        }+    }++    @Override+    public String signatureAlgorithm(TokenCategory category) {+        switch (category) {+            case INTERNAL:+                return Algorithm.HS256;+            case ADMIN:+                return getSignatureAlgorithm(null);+            case ACCESS:+                return getSignatureAlgorithm(OIDCConfigAttributes.ACCESS_TOKEN_SIGNED_RESPONSE_ALG);","This is related to the ""resource"" specs I mentioned with the relation to the audience support. One cool thing about this ""resource"" parameter is that it is added in the code-to-token or refresh token requests. No need to re-trigger whole login flow. And it specifically mentions that accessToken may be signed/encrypted based on the ""resource"" (target service, which accessToken will be used against). Some cite from that specs:```The ""resource"" parameter indicates the physical location of resource   server, typically as an https URL, where the client intends to use   the requested access token.  This enables the authorization server to   apply policy as appropriate for the resource, such as determining the   type and content of the token to be issued, if and how the token is   to be encrypted, and applying appropriate audience restrictions to   the token.```+1 to address this as a future requirement. Just wanted to point and discuss a bit :)",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5559,217002675,2018-09-12T12:05:20Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oidc/AudienceTest.java,"@@ -0,0 +1,221 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.oidc;++import java.util.Arrays;+import java.util.Collection;++import javax.ws.rs.core.Response;++import org.jboss.arquillian.container.test.api.Deployment;+import org.jboss.shrinkwrap.api.spec.WebArchive;+import org.junit.Test;+import org.keycloak.admin.client.resource.ClientResource;+import org.keycloak.admin.client.resource.ClientScopeResource;+import org.keycloak.events.Details;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.ClientScopeRepresentation;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.ProtocolMapperRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.RoleRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.Assert;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.runonserver.RunOnServerDeployment;+import org.keycloak.testsuite.util.ProtocolMapperUtil;+import org.keycloak.testsuite.util.UserBuilder;++/**+ * Test for the 'aud' claim in tokens+ *+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class AudienceTest extends AbstractOIDCScopeTest {++    @Deployment+    public static WebArchive deploy() {+        return RunOnServerDeployment.create(OIDCAdvancedRequestParamsTest.class, AbstractTestRealmKeycloakTest.class);+    }++    private static String userId = KeycloakModelUtils.generateId();+++    @Override+    public void configureTestRealm(RealmRepresentation testRealm) {+        // Create service client with some client role+        ClientRepresentation client1 = new ClientRepresentation();+        client1.setClientId(""service-client"");+        client1.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);+        client1.setBearerOnly(true);+        client1.setBaseUrl(""http://foo/service-client"");+        testRealm.getClients().add(client1);++        RoleRepresentation role1 = new RoleRepresentation();+        role1.setName(""role1"");+        testRealm.getRoles().getClient().put(""service-client"", Arrays.asList(role1));++        // Create client scope 'audience-scope' and add as optional scope to the 'test-app' client+        ClientScopeRepresentation clientScope = new ClientScopeRepresentation();+        clientScope.setName(""audience-scope"");+        clientScope.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);+        testRealm.setClientScopes(Arrays.asList(clientScope));++        ClientRepresentation testApp = testRealm.getClients().stream().filter((ClientRepresentation client) -> {+            return ""test-app"".equals(client.getClientId());+        }).findFirst().get();+        testApp.setOptionalClientScopes(Arrays.asList(""audience-scope""));++        testApp.setFullScopeAllowed(false);++        // Create sample user+        UserRepresentation user = UserBuilder.create()+                .id(userId)+                .username(""john"")+                .enabled(true)+                .email(""john@email.cz"")+                .firstName(""John"")+                .lastName(""Doe"")+                .password(""password"")+                .role(""account"", ""manage-account"")+                .role(""account"", ""view-profile"")+                .role(""service-client"", ""role1"")+                .build();+        testRealm.getUsers().add(user);+    }+++    @Test+    public void testAudienceProtocolMapperWithClientAudience() throws Exception {+        // Add audience protocol mapper to the clientScope ""audience-scope""+        ProtocolMapperRepresentation audienceMapper = ProtocolMapperUtil.createAudienceMapper(""audience mapper"", ""service-client"",+                null, true, false);+        ClientScopeResource clientScope = ApiUtil.findClientScopeByName(testRealm(), ""audience-scope"");+        Response resp = clientScope.getProtocolMappers().createMapper(audienceMapper);+        String mapperId = ApiUtil.getCreatedId(resp);+        resp.close();++        // Login and check audiences in the token (just accessToken contains it)+        oauth.scope(""openid audience-scope"");+        oauth.doLogin(""john"", ""password"");+        EventRepresentation loginEvent = events.expectLogin()+                .user(userId)+                .assertEvent();+        Tokens tokens = sendTokenRequest(loginEvent, userId,""openid audience-scope"", ""test-app"");+        // TODO: Frontend client itself should not be in the audiences of access token. Will be fixed in the future+        assertAudiences(tokens.accessToken, ""test-app"", ""service-client"");+        assertAudiences(tokens.idToken, ""test-app"");++        // Revert+        clientScope.getProtocolMappers().delete(mapperId);+    }+++    @Test+    public void testAudienceProtocolMapperWithCustomAudience() throws Exception {+        // Add audience protocol mapper to the clientScope ""audience-scope""+        ProtocolMapperRepresentation audienceMapper = ProtocolMapperUtil.createAudienceMapper(""audience mapper 1"", null,+                ""http://host/service/ctx1"", true, false);+        ClientScopeResource clientScope = ApiUtil.findClientScopeByName(testRealm(), ""audience-scope"");+        Response resp = clientScope.getProtocolMappers().createMapper(audienceMapper);+        String mapper1Id = ApiUtil.getCreatedId(resp);+        resp.close();++        audienceMapper = ProtocolMapperUtil.createAudienceMapper(""audience mapper 2"", null,+                ""http://host/service/ctx2"", true, true);+        resp = clientScope.getProtocolMappers().createMapper(audienceMapper);+        String mapper2Id = ApiUtil.getCreatedId(resp);+        resp.close();++        // Login and check audiences in the token+        oauth.scope(""openid audience-scope"");+        oauth.doLogin(""john"", ""password"");+        EventRepresentation loginEvent = events.expectLogin()+                .user(userId)+                .assertEvent();+        Tokens tokens = sendTokenRequest(loginEvent, userId,""openid audience-scope"", ""test-app"");+        // TODO: Frontend client itself should not be in the audiences of access token. Will be fixed in the future",Is it possible to change this behavior somehow and avoid having the frontend in the list of audiences ? Asking because people may want to have in access tokens only the audiences representing the resource servers where token will be used.,X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5559,217037804,2018-09-12T13:48:41Z,core/src/main/java/org/keycloak/representations/JsonWebToken.java,"@@ -161,6 +162,17 @@ public JsonWebToken audience(String... audience) {         return this;     } +    public JsonWebToken addAudience(String audience) {+        if (this.audience == null) {+            this.audience = new String[] { audience };","Yes, Set is better. But it will require to change signature of JsonWebToken.getAudience/setAudience methods, so kept the String[] in the signatures for backwards compatibility (people may already use JsonWebToken directly in their application). Also the ""aud"" can be single String or an Array per JSON and hence we use this custom ""StringOrArraySerializer"" / ""StringOrArrayDeserializer"", which would probably need to be rewritten or different serializer used etc.So the easiest would be to handle duplicates in the ""addAudience"" method. If you prefer to change it to Set, I can take a look at it (will require some work with the Serializer. For backwards compatibility it is probably ok if we just document in the migration guide). WDYT?",X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5559,217040043,2018-09-12T13:53:52Z,core/src/main/java/org/keycloak/representations/JsonWebToken.java,"@@ -161,6 +162,17 @@ public JsonWebToken audience(String... audience) {         return this;     } +    public JsonWebToken addAudience(String audience) {+        if (this.audience == null) {+            this.audience = new String[] { audience };","I think that handle duplicates is enough. Didn't consider backward compatibility, good point.",X
335133,sebastienblanc,https://api.github.com/repos/keycloak/keycloak/pulls/5515,217051694,2018-09-12T14:20:18Z,adapters/oidc/spring-boot-adapter-core/src/main/java/org/keycloak/adapters/springboot/KeycloakSpringBootConfigResolver.java,"@@ -17,29 +17,39 @@  package org.keycloak.adapters.springboot; +import org.keycloak.adapters.KeycloakConfigResolver; import org.keycloak.adapters.KeycloakDeployment; import org.keycloak.adapters.KeycloakDeploymentBuilder; import org.keycloak.adapters.OIDCHttpFacade; import org.keycloak.representations.adapters.config.AdapterConfig;  public class KeycloakSpringBootConfigResolver implements org.keycloak.adapters.KeycloakConfigResolver { -    private KeycloakDeployment keycloakDeployment;-     private static AdapterConfig adapterConfig;+    private static KeycloakConfigResolver delegateConfigResolver;++    private KeycloakDeployment keycloakDeployment;      @Override     public KeycloakDeployment resolve(OIDCHttpFacade.Request request) {-        if (keycloakDeployment != null) {+        if (delegateConfigResolver == null) {","I wonder if we could not add an additional check if there is a `keycloak.json` config available in the classpath. This way we also fix the issue that `keycloak.json` can not be used. In fact it will first check for config in the properties, if not then look for a keycloak.json and finally if non of those are there using the custom resolver. WDYT ? ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5559,217111683,2018-09-12T16:57:48Z,core/src/main/java/org/keycloak/representations/JsonWebToken.java,"@@ -161,6 +162,17 @@ public JsonWebToken audience(String... audience) {         return this;     } +    public JsonWebToken addAudience(String audience) {+        if (this.audience == null) {+            this.audience = new String[] { audience };",@pedroigor I've updated PR to handle duplicates.,X
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5544,219159615,2018-09-20T13:20:04Z,misc/keycloak-test-helper/src/main/java/org/keycloak/test/TestsHelper.java,"@@ -38,207 +40,307 @@  import javax.ws.rs.WebApplicationException; import javax.ws.rs.core.Response;++import java.io.File;+import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.net.URI; import java.util.Arrays;+import java.util.HashMap;+import java.util.Map;  import static org.keycloak.test.builders.ClientBuilder.AccessType.PUBLIC; +/**+ * A helper class that makes creating tests a bit easier.+ *+ * <p>+ *    Usage example:+ *    <pre>{@code+ *    new TestsHelper()+ *        .init()+ *        .createDirectGrantClient(""direct-grant-client"")+ *        .deleteClient(""direct-grant-client"")+ *        .createTestUser(""seb"", ""seb"")+ *        .assignRoleWithUser(""seb"", ""user"")+ *        .deleteTestUser(""seb"")+ *        .deleteRole(""user"");+ *    }</pre>+ * </p>+ */ public class TestsHelper { -    public static String baseUrl;+    protected static class ClientData {+        private final ClientRepresentation clientRepresentation;+        private final String registrationCode; -    public static String keycloakBaseUrl = ""http://localhost:8180/auth"";+        public ClientData(ClientRepresentation clientRepresentation, String registrationCode) {+            this.clientRepresentation = clientRepresentation;+            this.registrationCode = registrationCode;+        } -    public static String testRealm = ""test-realm"";+        public ClientRepresentation getClientRepresentation() {+            return clientRepresentation;+        } -    public static String initialAccessCode;+        public String getRegistrationCode() {+            return registrationCode;+        }+    } -    public static String appName;-    -    public static int initialAccessTokenCount = 2; +    public static final String DEFAULT_KEYCLOAK_URL = ""http://localhost:8080/auth"";+    public static final String DEFAULT_ADMIN_USERNAME = ""admin"";+    public static final String DEFAULT_ADMIN_PASSWORD = ""admin"";+    public static final String DEFAULT_ADMIN_REALM = ""master"";+    public static final String DEFAULT_ADMIN_CLIENT = ""admin-cli"";+    public static final String DEFAULT_TEST_REALM = DEFAULT_ADMIN_REALM;+    public static final String DEFAULT_USER_ROLE = ""user"";++    protected final String keycloakBaseUrl;+    protected final String adminUserName;+    protected final String adminPassword;+    protected final String adminClient;+    protected final String adminRealm;++    protected String testRealm;+    protected Keycloak keycloak;+    protected String accessToken;+    protected volatile boolean isInitialized;+    protected Map<String, ClientData> createdClients = new HashMap<>();++    /**+     * Creates a new helper instance.+     */+    public TestsHelper() {+        this(DEFAULT_ADMIN_USERNAME, DEFAULT_ADMIN_PASSWORD);+    } -    protected static String clientConfiguration;+    /**+     * Creates a new helper instance.+     *+     * @param adminUserName Admin username.+     * @param adminPassword Admin password.+     */+    public TestsHelper(String adminUserName, String adminPassword) {+        this(DEFAULT_KEYCLOAK_URL, adminUserName, adminPassword, DEFAULT_ADMIN_REALM, DEFAULT_ADMIN_CLIENT, DEFAULT_TEST_REALM);+    } -    protected static String registrationAccessCode;+    /**+     * Creates a new helper instance.+     *+     * @param keycloakBaseUrl Full keycloak URL.+     * @param adminUserName Admin username.+     * @param adminPassword Admin password.+     * @param adminRealm Master realm name.+     * @param adminClient Admin Client name.+     * @param testRealm new instance.+     */+    public TestsHelper(String keycloakBaseUrl, String adminUserName, String adminPassword, String adminRealm, String adminClient, String testRealm) {+        this.keycloakBaseUrl = keycloakBaseUrl;+        this.testRealm = testRealm;+        this.adminUserName = adminUserName;+        this.adminPassword = adminPassword;+        this.adminRealm = adminRealm;+        this.adminClient = adminClient;+    } -    public static String createClient(ClientRepresentation clientRepresentation) {-        ClientRegistration reg = ClientRegistration.create()-                .url(keycloakBaseUrl, testRealm)-                .build();+    /**+     * Initialization method.+     *+     * @return <code>this</code>+     */+    public TestsHelper init() {","Yeah, we could do it in the constructor but calling non-final method in the constructor is general an antipattern (I think even Josh wrote on it in Effective Java but my old memory might not be accurate here). And making those methods final would make this whole class less flexible (as you probably noticed, there are plenty of protected methods and fields to encourage inheritance there). So when I summed all the above up, I though the best approach is to use a good old `#init()` method :)",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5544,219162544,2018-09-20T13:27:25Z,misc/keycloak-test-helper/src/main/java/org/keycloak/test/TestsHelper.java,"@@ -38,207 +40,307 @@  import javax.ws.rs.WebApplicationException; import javax.ws.rs.core.Response;++import java.io.File;+import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.net.URI; import java.util.Arrays;+import java.util.HashMap;+import java.util.Map;  import static org.keycloak.test.builders.ClientBuilder.AccessType.PUBLIC; +/**+ * A helper class that makes creating tests a bit easier.+ *+ * <p>+ *    Usage example:+ *    <pre>{@code+ *    new TestsHelper()+ *        .init()+ *        .createDirectGrantClient(""direct-grant-client"")+ *        .deleteClient(""direct-grant-client"")+ *        .createTestUser(""seb"", ""seb"")+ *        .assignRoleWithUser(""seb"", ""user"")+ *        .deleteTestUser(""seb"")+ *        .deleteRole(""user"");+ *    }</pre>+ * </p>+ */ public class TestsHelper { -    public static String baseUrl;+    protected static class ClientData {+        private final ClientRepresentation clientRepresentation;+        private final String registrationCode; -    public static String keycloakBaseUrl = ""http://localhost:8180/auth"";+        public ClientData(ClientRepresentation clientRepresentation, String registrationCode) {+            this.clientRepresentation = clientRepresentation;+            this.registrationCode = registrationCode;+        } -    public static String testRealm = ""test-realm"";+        public ClientRepresentation getClientRepresentation() {+            return clientRepresentation;+        } -    public static String initialAccessCode;+        public String getRegistrationCode() {+            return registrationCode;+        }+    } -    public static String appName;-    -    public static int initialAccessTokenCount = 2; +    public static final String DEFAULT_KEYCLOAK_URL = ""http://localhost:8080/auth"";+    public static final String DEFAULT_ADMIN_USERNAME = ""admin"";+    public static final String DEFAULT_ADMIN_PASSWORD = ""admin"";+    public static final String DEFAULT_ADMIN_REALM = ""master"";+    public static final String DEFAULT_ADMIN_CLIENT = ""admin-cli"";+    public static final String DEFAULT_TEST_REALM = DEFAULT_ADMIN_REALM;+    public static final String DEFAULT_USER_ROLE = ""user"";++    protected final String keycloakBaseUrl;+    protected final String adminUserName;+    protected final String adminPassword;+    protected final String adminClient;+    protected final String adminRealm;++    protected String testRealm;+    protected Keycloak keycloak;+    protected String accessToken;+    protected volatile boolean isInitialized;+    protected Map<String, ClientData> createdClients = new HashMap<>();++    /**+     * Creates a new helper instance.+     */+    public TestsHelper() {+        this(DEFAULT_ADMIN_USERNAME, DEFAULT_ADMIN_PASSWORD);+    } -    protected static String clientConfiguration;+    /**+     * Creates a new helper instance.+     *+     * @param adminUserName Admin username.+     * @param adminPassword Admin password.+     */+    public TestsHelper(String adminUserName, String adminPassword) {+        this(DEFAULT_KEYCLOAK_URL, adminUserName, adminPassword, DEFAULT_ADMIN_REALM, DEFAULT_ADMIN_CLIENT, DEFAULT_TEST_REALM);+    } -    protected static String registrationAccessCode;+    /**+     * Creates a new helper instance.+     *+     * @param keycloakBaseUrl Full keycloak URL.+     * @param adminUserName Admin username.+     * @param adminPassword Admin password.+     * @param adminRealm Master realm name.+     * @param adminClient Admin Client name.+     * @param testRealm new instance.+     */+    public TestsHelper(String keycloakBaseUrl, String adminUserName, String adminPassword, String adminRealm, String adminClient, String testRealm) {+        this.keycloakBaseUrl = keycloakBaseUrl;+        this.testRealm = testRealm;+        this.adminUserName = adminUserName;+        this.adminPassword = adminPassword;+        this.adminRealm = adminRealm;+        this.adminClient = adminClient;+    } -    public static String createClient(ClientRepresentation clientRepresentation) {-        ClientRegistration reg = ClientRegistration.create()-                .url(keycloakBaseUrl, testRealm)-                .build();+    /**+     * Initialization method.+     *+     * @return <code>this</code>+     */+    public TestsHelper init() {","I would avoid exposing too much public/protected methods and I still don't see a reason behind that `init` method. But you know the requirements better (especially those behind encouraging inheritance), so ... LGTM.",X
823594,devoto13,https://api.github.com/repos/keycloak/keycloak/pulls/5554,219690008,2018-09-23T06:52:58Z,themes/src/main/resources/theme/base/login/login.ftl,"@@ -35,18 +35,18 @@                                 </label>                             </div>                         </#if>-                        </div>","Thanks for you review and feedback, @junezhang! I did it this way because tags are structured [same way](https://github.com/keycloak/keycloak/blob/eda09d2b323ac4c612c6b746e52e1af4534b3b80/themes/src/main/resources/theme/base/login/register.ftl#L73-L83) in the `register.ftl` template. If you're sure that this should be done differently in this case, please confirm. I'll update PR according to your screenshot.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5576,219742640,2018-09-24T07:11:24Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java,"@@ -617,20 +626,11 @@ public int getUsersCount(RealmModel realm) {      @Override     public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {-        String queryName = includeServiceAccounts ? ""getAllUsersByRealm"" : ""getAllUsersByRealmExcludeServiceAccount"" ;+        Map<String, String> filters = new HashMap<>();","We want Hibernate to provide values of the fillters as parameters, hence values should be `Object`s, not `String`s.",
3833769,sschu,https://api.github.com/repos/keycloak/keycloak/pulls/5576,219786770,2018-09-24T10:13:27Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -238,4 +248,22 @@ public Integer getUsersCount() {          return session.users().getUsersCount(realm);     }++    private List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, Integer firstResult, Integer maxResults, Boolean includeServiceAccounts) {+        if (!auth.users().canView()) {+            List<GroupModel> groupModels = auth.groups().canViewMembers(realm.getGroups());","The realm.getGroups() call is very expensive on the DB. In our scenario it times out (3061 groups in the DB currently). It fetches all Groups with associated attributes, group roles and child groups as n+1 selects. This is nearly 10K queries. Ideally, only IDs of groups with permissions enabled would be fetched. Isn't there a way to identify groups with permissions enabled directly in the database using some kind of join?",
3833769,sschu,https://api.github.com/repos/keycloak/keycloak/pulls/5576,219833495,2018-09-24T13:25:13Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -238,4 +248,22 @@ public Integer getUsersCount() {          return session.users().getUsersCount(realm);     }++    private List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, Integer firstResult, Integer maxResults, Boolean includeServiceAccounts) {+        if (!auth.users().canView()) {+            List<GroupModel> groupModels = auth.groups().canViewMembers(realm.getGroups());",I was a bit curious why the lazy loading of the groups is triggered in the first place because loading the 3061 group entities is not a problem. As it turns out the call to realm.getGroups() calls RealmCacheSession.getGroupById() for every group which in turn creates a CachedGroup for every Group. This has the side effect of triggering the lazy loading for all groups. In this case I guess it is really better to bypass the cache if this is possible. I can imagine there are more cases like this and a more general solution would be necessary to not trigger lazy loading of large collections by populating the cache. @hmlnarik I guess this is your domain?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5576,220032529,2018-09-25T00:56:17Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -238,4 +248,22 @@ public Integer getUsersCount() {          return session.users().getUsersCount(realm);     }++    private List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, Integer firstResult, Integer maxResults, Boolean includeServiceAccounts) {+        if (!auth.users().canView()) {+            List<GroupModel> groupModels = auth.groups().canViewMembers(realm.getGroups());","@sschu, I did something different. Groups are obtained based on the existence of a resource with a `Group` type. I also tried to remove N+1 queries when retrieving resources and policies from the database.Initial tests using a database with 7500 groups show a significant improvement (each group with permission enabled) in response time. You should see a delay during the first load, but it should not hang. Wondering if you can test the new changes and give some feedback ...In order to test my changes, you will need to execute the following UPDATE:```update keycloak.RESOURCE_SERVER_RESOURCE set type = 'Group' where name like 'group.resource.%'```If we agree about these initial changes, the command above will be part of the migration.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5576,220032765,2018-09-25T00:58:19Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java,"@@ -617,20 +626,11 @@ public int getUsersCount(RealmModel realm) {      @Override     public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {-        String queryName = includeServiceAccounts ? ""getAllUsersByRealm"" : ""getAllUsersByRealmExcludeServiceAccount"" ;+        Map<String, String> filters = new HashMap<>();",Do you mean changing https://github.com/keycloak/keycloak/blob/5e779bda842a7c725e7c09eb0499930e538dd5ed/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java#L703 signature ?,X
2461648,kinjelom,https://api.github.com/repos/keycloak/keycloak/pulls/5560,220149769,2018-09-25T11:11:25Z,themes/src/main/resources-community/theme/base/email/messages/messages_pl.properties,"@@ -0,0 +1,56 @@+# encoding: UTF-8+emailVerificationSubject=Zweryfikuj email+emailVerificationBody=Kto utworzy konto {2} z tym adresem e-mail. Jeli to Ty, kliknij poniszy link, aby zweryfikowa swj adres e-mail \n\n{0}\n\nLink ten wyganie w cigu {3}.\n\nJeli nie utworzye tego konta, po prostu zignoruj t wiadomo.+emailVerificationBodyHtml=<p>Kto utworzy konto {2} z tym adresem e-mail. Jeli to Ty, kliknij <a href=""{0}"">ten link</a> aby zweryfikowa swj adres e-mail</p><p>Link ten wyganie w cigu {3}</p><p>Jeli nie utworzye tego konta, po prostu zignoruj t wiadomo.</p>+emailTestSubject=[KEYCLOAK] - wiadomo testowa SMTP+emailTestBody=To jest wiadomo testowa+emailTestBodyHtml=<p>To jest wiadomo testowa</p>+identityProviderLinkSubject=Link {0}+identityProviderLinkBody=Kto chce poczy Twoje konto ""{1}"" z kontem ""{0}"" uytkownika {2}. Jeli to Ty, kliknij poniszy link by poczy konta\n\n{3}\n\nTen link wyganie w cigu {5}.\n\nJeli nie chcesz poczy konta to zignoruj t wiadomo. Jeli poczysz konta, bdziesz mg si zalogowa na {1} przez {0}.","I think that a dot after link is useless, please take a look at this: https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/base/email/messages/messages_en.properties#L8",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5576,220155503,2018-09-25T11:34:11Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java,"@@ -617,20 +626,11 @@ public int getUsersCount(RealmModel realm) {      @Override     public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {-        String queryName = includeServiceAccounts ? ""getAllUsersByRealm"" : ""getAllUsersByRealmExcludeServiceAccount"" ;+        Map<String, String> filters = new HashMap<>();","I believe we should.The current changes in `UsersResources` are beyond the API contract already, since according to the JavaDoc documentation, the `attributes` can only contain `first`, `last`, `username`, and `email`, and for these the type would stay `String`.So if we are to fix this issue, we need to change the API contract anyway. Hence my take is to change the signature to make it compile time rather than runtime issue, add a big fat note into migration guide that this change takes place and that the attributes can contain other attribute names than what has been specified in `org.keycloak.storage.user.UserQueryProvider.searchForUser` javadocs, and that the code needs to check value type as well.@stianst Do you agree with this change? Could you please comment here?",X
3833769,sschu,https://api.github.com/repos/keycloak/keycloak/pulls/5576,220188170,2018-09-25T13:19:20Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -238,4 +248,22 @@ public Integer getUsersCount() {          return session.users().getUsersCount(realm);     }++    private List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, Integer firstResult, Integer maxResults, Boolean includeServiceAccounts) {+        if (!auth.users().canView()) {+            List<GroupModel> groupModels = auth.groups().canViewMembers(realm.getGroups());","I just retested this with our current dataset. I can confirm thata) Retrieving the group resources is as efficient as it can get on the DB looking for resources of type ""Group"", i.e. no N+1 triggering of lazy-loaded associations.b) The caching works so the second and all follow-up requests are reasonably fast.c) However, evaluating evaluating the permissions on the first request still takes quite some time ~ 2 minutes with ca. 200 groups. I can see that for every group 11 queries are generated, that's 2K+ DB queries in our case. To me, it looks like they are partly redundant, i.e. I suspect some data is fetched because lazy loading is triggered by caching and not because the data is actually needed in the computation. The responsible code is in the generic authz part. Not sure it is possible to somehow eager-load and cache all necessary entities and if that is faster in the end. Currently, these are the queries per resource:Hibernate:     select        policyenti0_.ID as ID1_66_0_,        policyenti4_.ID as ID1_66_1_,        policyenti0_.DECISION_STRATEGY as DECISION2_66_0_,        policyenti0_.DESCRIPTION as DESCRIPT3_66_0_,        policyenti0_.LOGIC as LOGIC4_66_0_,        policyenti0_.NAME as NAME5_66_0_,        policyenti0_.OWNER as OWNER6_66_0_,        policyenti0_.RESOURCE_SERVER_ID as RESOURCE8_66_0_,        policyenti0_.TYPE as TYPE7_66_0_,        config5_.POLICY_ID as POLICY_I1_46_1__,        config5_.VALUE as VALUE2_46_1__,        config5_.NAME as NAME3_1__,        policyenti4_.DECISION_STRATEGY as DECISION2_66_1_,        policyenti4_.DESCRIPTION as DESCRIPT3_66_1_,        policyenti4_.LOGIC as LOGIC4_66_1_,        policyenti4_.NAME as NAME5_66_1_,        policyenti4_.OWNER as OWNER6_66_1_,        policyenti4_.RESOURCE_SERVER_ID as RESOURCE8_66_1_,        policyenti4_.TYPE as TYPE7_66_1_,        associated3_.POLICY_ID as POLICY_I1_1_0__,        associated3_.ASSOCIATED_POLICY_ID as ASSOCIAT2_1_0__,        config5_.POLICY_ID as POLICY_I1_46_1__,        config5_.VALUE as VALUE2_46_1__,        config5_.NAME as NAME3_1__     from        RESOURCE_SERVER_POLICY policyenti0_     inner join        RESOURCE_POLICY resources1_             on policyenti0_.ID=resources1_.POLICY_ID     inner join        RESOURCE_SERVER_RESOURCE resourceen2_             on resources1_.RESOURCE_ID=resourceen2_.ID     inner join        ASSOCIATED_POLICY associated3_             on policyenti0_.ID=associated3_.POLICY_ID     inner join        RESOURCE_SERVER_POLICY policyenti4_             on associated3_.ASSOCIATED_POLICY_ID=policyenti4_.ID     left outer join        POLICY_CONFIG config5_             on policyenti0_.ID=config5_.POLICY_ID     where        policyenti0_.RESOURCE_SERVER_ID=?         and resourceen2_.RESOURCE_SERVER_ID=?         and resourceen2_.ID=?Hibernate:     select        config0_.POLICY_ID as POLICY_I1_46_0_,        config0_.VALUE as VALUE2_46_0_,        config0_.NAME as NAME3_0_     from        POLICY_CONFIG config0_     where        config0_.POLICY_ID=?Hibernate:     select        associated0_.POLICY_ID as POLICY_I1_1_0_,        associated0_.ASSOCIATED_POLICY_ID as ASSOCIAT2_1_0_,        policyenti1_.ID as ID1_66_1_,        policyenti1_.DECISION_STRATEGY as DECISION2_66_1_,        policyenti1_.DESCRIPTION as DESCRIPT3_66_1_,        policyenti1_.LOGIC as LOGIC4_66_1_,        policyenti1_.NAME as NAME5_66_1_,        policyenti1_.OWNER as OWNER6_66_1_,        policyenti1_.RESOURCE_SERVER_ID as RESOURCE8_66_1_,        policyenti1_.TYPE as TYPE7_66_1_     from        ASSOCIATED_POLICY associated0_     inner join        RESOURCE_SERVER_POLICY policyenti1_             on associated0_.ASSOCIATED_POLICY_ID=policyenti1_.ID     where        associated0_.POLICY_ID=?Hibernate:     select        resources0_.POLICY_ID as POLICY_I1_62_0_,        resources0_.RESOURCE_ID as RESOURCE2_62_0_,        resourceen1_.ID as ID1_67_1_,        resourceen1_.DISPLAY_NAME as DISPLAY_2_67_1_,        resourceen1_.ICON_URI as ICON_URI3_67_1_,        resourceen1_.NAME as NAME4_67_1_,        resourceen1_.OWNER as OWNER5_67_1_,        resourceen1_.OWNER_MANAGED_ACCESS as OWNER_MA6_67_1_,        resourceen1_.RESOURCE_SERVER_ID as RESOURCE8_67_1_,        resourceen1_.TYPE as TYPE7_67_1_     from        RESOURCE_POLICY resources0_     inner join        RESOURCE_SERVER_RESOURCE resourceen1_             on resources0_.RESOURCE_ID=resourceen1_.ID     where        resources0_.POLICY_ID=?Hibernate:     select        scopes0_.POLICY_ID as POLICY_I1_71_0_,        scopes0_.SCOPE_ID as SCOPE_ID2_71_0_,        scopeentit1_.ID as ID1_68_1_,        scopeentit1_.DISPLAY_NAME as DISPLAY_2_68_1_,        scopeentit1_.ICON_URI as ICON_URI3_68_1_,        scopeentit1_.NAME as NAME4_68_1_,        scopeentit1_.RESOURCE_SERVER_ID as RESOURCE5_68_1_     from        SCOPE_POLICY scopes0_     inner join        RESOURCE_SERVER_SCOPE scopeentit1_             on scopes0_.SCOPE_ID=scopeentit1_.ID     where        scopes0_.POLICY_ID=?Hibernate:     select        roleentity0_.ID as ID1_42_0_,        roleentity0_.CLIENT as CLIENT7_42_0_,        roleentity0_.CLIENT_REALM_CONSTRAINT as CLIENT_R2_42_0_,        roleentity0_.CLIENT_ROLE as CLIENT_R3_42_0_,        roleentity0_.DESCRIPTION as DESCRIPT4_42_0_,        roleentity0_.NAME as NAME5_42_0_,        roleentity0_.REALM as REALM8_42_0_,        roleentity0_.REALM_ID as REALM_ID6_42_0_     from        KEYCLOAK_ROLE roleentity0_     where        roleentity0_.ID=?Hibernate:     select        compositer0_.COMPOSITE as COMPOSIT1_19_0_,        compositer0_.CHILD_ROLE as CHILD_RO2_19_0_,        roleentity1_.ID as ID1_42_1_,        roleentity1_.CLIENT as CLIENT7_42_1_,        roleentity1_.CLIENT_REALM_CONSTRAINT as CLIENT_R2_42_1_,        roleentity1_.CLIENT_ROLE as CLIENT_R3_42_1_,        roleentity1_.DESCRIPTION as DESCRIPT4_42_1_,        roleentity1_.NAME as NAME5_42_1_,        roleentity1_.REALM as REALM8_42_1_,        roleentity1_.REALM_ID as REALM_ID6_42_1_     from        COMPOSITE_ROLE compositer0_     inner join        KEYCLOAK_ROLE roleentity1_             on compositer0_.CHILD_ROLE=roleentity1_.ID     where        compositer0_.COMPOSITE=?Hibernate:     select        roleentity0_.ID as col_0_0_     from        KEYCLOAK_ROLE roleentity0_     where        roleentity0_.CLIENT_ROLE=0         and roleentity0_.NAME=?         and roleentity0_.REALM=?Hibernate:     select        scopes0_.POLICY_ID as POLICY_I1_71_0_,        scopes0_.SCOPE_ID as SCOPE_ID2_71_0_,        scopeentit1_.ID as ID1_68_1_,        scopeentit1_.DISPLAY_NAME as DISPLAY_2_68_1_,        scopeentit1_.ICON_URI as ICON_URI3_68_1_,        scopeentit1_.NAME as NAME4_68_1_,        scopeentit1_.RESOURCE_SERVER_ID as RESOURCE5_68_1_     from        SCOPE_POLICY scopes0_     inner join        RESOURCE_SERVER_SCOPE scopeentit1_             on scopes0_.SCOPE_ID=scopeentit1_.ID     where        scopes0_.POLICY_ID=?Hibernate:     select        scopes0_.POLICY_ID as POLICY_I1_71_0_,        scopes0_.SCOPE_ID as SCOPE_ID2_71_0_,        scopeentit1_.ID as ID1_68_1_,        scopeentit1_.DISPLAY_NAME as DISPLAY_2_68_1_,        scopeentit1_.ICON_URI as ICON_URI3_68_1_,        scopeentit1_.NAME as NAME4_68_1_,        scopeentit1_.RESOURCE_SERVER_ID as RESOURCE5_68_1_     from        SCOPE_POLICY scopes0_     inner join        RESOURCE_SERVER_SCOPE scopeentit1_             on scopes0_.SCOPE_ID=scopeentit1_.ID     where        scopes0_.POLICY_ID=?Hibernate:     select        scopes0_.POLICY_ID as POLICY_I1_71_0_,        scopes0_.SCOPE_ID as SCOPE_ID2_71_0_,        scopeentit1_.ID as ID1_68_1_,        scopeentit1_.DISPLAY_NAME as DISPLAY_2_68_1_,        scopeentit1_.ICON_URI as ICON_URI3_68_1_,        scopeentit1_.NAME as NAME4_68_1_,        scopeentit1_.RESOURCE_SERVER_ID as RESOURCE5_68_1_     from        SCOPE_POLICY scopes0_     inner join        RESOURCE_SERVER_SCOPE scopeentit1_             on scopes0_.SCOPE_ID=scopeentit1_.ID     where        scopes0_.POLICY_ID=?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5576,220235071,2018-09-25T15:13:59Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -238,4 +248,22 @@ public Integer getUsersCount() {          return session.users().getUsersCount(realm);     }++    private List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, Integer firstResult, Integer maxResults, Boolean includeServiceAccounts) {+        if (!auth.users().canView()) {+            List<GroupModel> groupModels = auth.groups().canViewMembers(realm.getGroups());","Glad for #1 and #2. Regarding #3, I also tried to remove unnecessary fetches when caching entries and only keep what is going to be used during the processing, I'll check again any other place we can improve. Will let you know once I have something. I think the difference between your test environment and mine is that most of the permissions I have for groups have no policies. Will change that.Regarding your dataset, you have almost 4k groups but only ~300 of them have permissions enabled, right? ",
3833769,sschu,https://api.github.com/repos/keycloak/keycloak/pulls/5576,220515067,2018-09-26T10:52:16Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -238,4 +231,44 @@ public Integer getUsersCount() {          return session.users().getUsersCount(realm);     }++    private List<UserRepresentation> searchForUser(Map<String, String> attributes, RealmModel realm, UserPermissionEvaluator usersEvaluator, Boolean briefRepresentation, Integer firstResult, Integer maxResults, Boolean includeServiceAccounts) {+        if (!usersEvaluator.canView()) {+            List<String> groupModels = auth.groups().canViewMembers();++            if (!groupModels.isEmpty()) {+                try {+                    attributes.put(UserModel.GROUPS, JsonSerialization.writeValueAsPrettyString(groupModels));+                } catch (IOException cause) {+                    throw new RuntimeException(""Failed to create groups filter"", cause);+                }+            }+        }++        attributes.put(UserModel.INCLUDE_SERVICE_ACCOUNT, includeServiceAccounts.toString());++        List<UserModel> userModels = session.users().searchForUser(attributes, realm, firstResult, maxResults);","This triggers the lazy-loading of all user associations (attributes, credentials) so the effect of the briefRepresentation-change from @hmlnarik in L252 is lost. The loading is triggered in JpaUserProvider.java L784 calling UserModel getUserById(String id, RealmModel realm) that caches the user.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5576,220848113,2018-09-27T09:10:12Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/authorization/entities/CachedPolicy.java,"@@ -38,27 +40,91 @@     private String type;     private DecisionStrategy decisionStrategy;     private Logic logic;-    private Map<String, String> config;     private String name;     private String description;     private String resourceServerId;-    private Set<String> associatedPoliciesIds;-    private Set<String> resourcesIds;-    private Set<String> scopesIds;+    private Function<Supplier<Policy>, Set<String>> associatedPoliciesIds;+    private Function<Supplier<Policy>, Set<String>> resourcesIds;+    private Function<Supplier<Policy>, Set<String>> scopesIds;+    private Function<Supplier<Policy>, Map<String, String>> config;     private final String owner;      public CachedPolicy(Long revision, Policy policy) {         super(revision, policy.getId());         this.type = policy.getType();         this.decisionStrategy = policy.getDecisionStrategy();         this.logic = policy.getLogic();-        this.config = new HashMap(policy.getConfig());         this.name = policy.getName();         this.description = policy.getDescription();         this.resourceServerId = policy.getResourceServer().getId();-        this.associatedPoliciesIds = policy.getAssociatedPolicies().stream().map(Policy::getId).collect(Collectors.toSet());-        this.resourcesIds = policy.getResources().stream().map(Resource::getId).collect(Collectors.toSet());-        this.scopesIds = policy.getScopes().stream().map(Scope::getId).collect(Collectors.toSet());++        if (policy.isFetched(""associatedPolicies"")) {+            Set<String> cached = policy.getAssociatedPolicies().stream().map(Policy::getId).collect(Collectors.toSet());+            this.associatedPoliciesIds = supplier -> cached;+        } else {+            this.associatedPoliciesIds = new Function<Supplier<Policy>, Set<String>>() {+                Set<String> cached;",All the introduced `cached` fields in this class should be `private final AtomicReference`s. The update logic needs to count on possibility of `cached` being computed by two concurrent threads (see below).,
10031576,fschmager,https://api.github.com/repos/keycloak/keycloak/pulls/5452,220932590,2018-09-27T13:55:10Z,adapters/oidc/spring-security/src/test/java/org/keycloak/adapters/springsecurity/filter/KeycloakPreAuthActionsFilterTest.java,"@@ -0,0 +1,90 @@+package org.keycloak.adapters.springsecurity.filter;++import static org.mockito.Matchers.any;+import static org.mockito.Mockito.verify;+import static org.mockito.Mockito.verifyZeroInteractions;+import static org.mockito.Mockito.when;+import static org.mockito.MockitoAnnotations.initMocks;++import javax.servlet.FilterChain;+import javax.servlet.http.HttpServletRequest;+import javax.servlet.http.HttpServletResponse;++import org.junit.After;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.adapters.AdapterDeploymentContext;+import org.keycloak.adapters.KeycloakDeployment;+import org.keycloak.adapters.NodesRegistrationManagement;+import org.keycloak.adapters.PreAuthActionsHandler;+import org.keycloak.adapters.spi.HttpFacade;+import org.keycloak.adapters.spi.UserSessionManagement;+import org.keycloak.adapters.springsecurity.filter.KeycloakPreAuthActionsFilter.PreAuthActionsHandlerFactory;+import org.mockito.Mock;+import org.springframework.context.ApplicationContext;++public class KeycloakPreAuthActionsFilterTest {++    private KeycloakPreAuthActionsFilter filter;","I would have loved to not mock all those things, but `KeycloakPreAuthActionsFilter` is a very social creature, talking to lots of folks. Too much responsibility, anyone? To me, a less-than-optimal unit test is a sign of a class-under-test in want of refactoring. Don't blame the test, blame the class. Not religiously defending my test. Blow it away if you want. I just felt it should be covered, otherwise how would I know my change doesn't break anything.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5597,221551603,2018-10-01T09:52:36Z,model/jpa/src/main/java/org/keycloak/models/jpa/ClientAdapter.java,"@@ -613,27 +598,45 @@ public void setServiceAccountsEnabled(boolean serviceAccountsEnabled) {      @Override     public RoleModel getRole(String name) {-        return session.realms().getClientRole(realm, this, name);+        for(RoleModel role : getRoles()) {+            if(name != null && name.equals(role.getName())) {+                return role;+            }+        }+        return null;     }      @Override     public RoleModel addRole(String name) {-        return session.realms().addClientRole(realm, this, name);+        return addRole(KeycloakModelUtils.generateId(), name);","Not 100% sure, but I think this can result in missing cache invalidations. The reason why we use methods on the provider-level is to ensure that cache invalidations are not missed. Note that it can be the case when for example, client is not cached, but client roles are cached. In this case, roles list need to be invalidated from the cache. Etc.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/5595,221592212,2018-10-01T12:36:20Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -274,11 +278,22 @@ public Response sessionLogout(@QueryParam(""id"") String id) {      @Path(""/credentials"")     public AccountCredentialResource credentials() {+        checkAccount2Enabled();         return new AccountCredentialResource(session, event, user);     }     // TODO Federated identities     // TODO Applications     // TODO Logs+    +    private static void checkAccount2Enabled() {+        if (!isAccount2Enabled()) {+            throw new BadRequestException(Messages.INVALID_REQUEST);","I'm looking at this and it turns out to be more complicated than expected.I can throw NotFoundException, but if I do that you will actually get a 200 instead of 404.If I don't use an exception, I can manually build and return a Response object with status of 404.  The problem there is that it won't work for endpoints that return a custom object instead of a Response object.I see other places in the code where we throw NotFoundException and I wonder if the developer knew it was really returning 200.There is a way to change this behavior with a RestEasy ExceptionMapper, but I don't think that's what we want to do.WDYT?  Is it OK to just throw NotFoundException?",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/5595,221605337,2018-10-01T13:20:34Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -274,11 +278,22 @@ public Response sessionLogout(@QueryParam(""id"") String id) {      @Path(""/credentials"")     public AccountCredentialResource credentials() {+        checkAccount2Enabled();         return new AccountCredentialResource(session, event, user);     }     // TODO Federated identities     // TODO Applications     // TODO Logs+    +    private static void checkAccount2Enabled() {+        if (!isAccount2Enabled()) {+            throw new BadRequestException(Messages.INVALID_REQUEST);",I've tried both the javax one and the deprecated RestEasy one.  Both returned 200.Wondering now if someone set up an ExceptionMapper to return 200.  That would sort of make sense given how it is sometimes used in other parts of the code.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5576,221841243,2018-10-02T06:58:28Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedGroup.java,"@@ -21,50 +21,56 @@ import org.keycloak.models.GroupModel; import org.keycloak.models.RealmModel; import org.keycloak.models.RoleModel;+import org.keycloak.models.cache.infinispan.DefaultLazyLoader;+import org.keycloak.models.cache.infinispan.LazyLoader; -import java.util.HashSet;+import java.util.Collections; import java.util.Set;+import java.util.function.Supplier;+import java.util.stream.Collectors;  /**  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>  * @version $Revision: 1 $  */ public class CachedGroup extends AbstractRevisioned implements InRealm {-    private String realm;-    private String name;-    private String parentId;-    private MultivaluedHashMap<String, String> attributes = new MultivaluedHashMap<>();-    private Set<String> roleMappings = new HashSet<>();-    private Set<String> subGroups = new HashSet<>();++    private final String realm;+    private final String name;+    private final String parentId;+    private final LazyLoader<GroupModel, MultivaluedHashMap<String, String>> attributes;+    private final LazyLoader<GroupModel, Set<String>> roleMappings;+    private final LazyLoader<GroupModel, Set<String>> subGroups;      public CachedGroup(Long revision, RealmModel realm, GroupModel group) {         super(revision, group.getId());         this.realm = realm.getId();         this.name = group.getName();         this.parentId = group.getParentId();--        this.attributes.putAll(group.getAttributes());-        for (RoleModel role : group.getRoleMappings()) {-            roleMappings.add(role.getId());-        }-        Set<GroupModel> subGroups1 = group.getSubGroups();-        if (subGroups1 != null) {-            for (GroupModel subGroup : subGroups1) {-                subGroups.add(subGroup.getId());+        this.attributes = new DefaultLazyLoader<>(source -> new MultivaluedHashMap<>(source.getAttributes()));+        this.roleMappings = new DefaultLazyLoader<>(source -> source.getRoleMappings().stream().map(RoleModel::getId).collect(Collectors.toSet()));+        this.subGroups = new DefaultLazyLoader<>(source -> {+            if (source == null) {","This applies to the rest of the lazy loaders as well. Maybe worth adding a logic to `DefaultLazyLoader` (a `Producer` in constructor) for case of `source == null`.e.g. ```javathis.subGroups = new DefaultLazyLoader<>(Collections::emptySet, source -> source.getSubGroups().stream().map(GroupModel::getId).collect(Collectors.toSet()));```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5584,222198614,2018-10-03T06:41:55Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/rule/LoggingRule.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.rule;++import org.jboss.logging.Logger;+import org.junit.rules.TestRule;+import org.junit.runner.Description;+import org.junit.runners.model.Statement;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class LoggingRule implements TestRule {","I think this file don't need to be added to the new testsuite as well. Sorry, I probably did not point this file in previous review, but it is same/similar thing like all the other files (AbstractKeycloakRule, KeycloakRule etc). In the new testsuite, there is very similar thing (logging before/after test method) provided by the class TestEventsLogger, so no need to have same thing again in the new testsuite.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5594,222346801,2018-10-03T15:02:24Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/saml/BasicSamlTest.java,"@@ -156,7 +156,7 @@ public void testNoPortInDestination() throws Exception {      @Test     public void testExplicitPortInDestination() throws Exception {-        testWithOverriddenPort(Integer.valueOf(System.getProperty(""auth.server.http.port"")), Response.Status.OK, containsString(""login""));+        testWithOverriddenPort(Integer.valueOf(System.getProperty(""auth.server.https.port"")), Response.Status.OK, containsString(""login""));",This needs to be conditioned on whether ssl tests are enabled or not.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5620,223584400,2018-10-09T07:22:47Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -154,10 +154,14 @@                     case 'check-sso':                         if (loginIframe.enable) {                             setupCheckLoginIframe().success(function() {-                                checkLoginIframe().success(function () {-                                    doLogin(false);+                                checkLoginIframe().success(function (unchanged) {+                                    if (!unchanged) {+                                        doLogin(false);+                                    } else {+                                        initPromise.setSuccess();+                                    }                                 }).error(function () {-                                    initPromise.setSuccess();","Humm, not bad and you call this improvement? Seems like a bug to me :sweat_smile: ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5615,223611023,2018-10-09T08:51:20Z,core/src/main/java/org/keycloak/representations/idm/RoleRepresentation.java,"@@ -138,4 +138,25 @@ public String getContainerId() {     public void setContainerId(String containerId) {         this.containerId = containerId;     }++    public Map<String, List<String>> getAttributes() {+        return attributes;+    }++    public void setAttributes(Map<String, List<String>> attributes) {+        this.attributes = attributes;+    }++    public boolean addAttribute(String name, String value) {","Is it possible to use the same pattern for RoleRepresentation like is used for the existing ""attributed"" implementations like UserRepresentation or GroupRepresentation? So for example:- have method ""singleAttribute"" instead of ""addAttribute""- Don't automatically create ""attributes"" map when constructing object etc.I wonder if it's even possible to create common subclass for representation classes like ""AttributedRepresentation"" and make GroupRepresentation, UserRepresentation and RoleRepresentation to inherit from it?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5615,223612087,2018-10-09T08:54:32Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedRole.java,"@@ -46,7 +49,7 @@ public CachedRole(Long revision, RoleModel model, RealmModel realm) {                 composites.add(child.getId());             }         }-+        attributes = model.getAttributes();","In latest master, there is ""DefaultLazyLoader"" pattern used to load the attributes of groups and users (CachedGroup and CachedUser). Is it possible to change CachedRole to align with same pattern?",X
4183757,unly,https://api.github.com/repos/keycloak/keycloak/pulls/5615,223681791,2018-10-09T12:39:36Z,core/src/main/java/org/keycloak/representations/idm/RoleRepresentation.java,"@@ -138,4 +138,25 @@ public String getContainerId() {     public void setContainerId(String containerId) {         this.containerId = containerId;     }++    public Map<String, List<String>> getAttributes() {+        return attributes;+    }++    public void setAttributes(Map<String, List<String>> attributes) {+        this.attributes = attributes;+    }++    public boolean addAttribute(String name, String value) {",Also I shared your thoughts on the superclass. There is lots of code duplication or same functionality. I didn't want to introduce new classes and modify other classes that are not part of my feature. But if you agree on this I could implement such a shared superclass. Are attributes the only thing they share? I assume there is more than that.,X
4183757,unly,https://api.github.com/repos/keycloak/keycloak/pulls/5615,223686656,2018-10-09T12:52:23Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedRole.java,"@@ -46,7 +49,7 @@ public CachedRole(Long revision, RoleModel model, RealmModel realm) {                 composites.add(child.getId());             }         }-+        attributes = model.getAttributes();",I'll check if I can update the pattern as well.,
734834,dbayub,https://api.github.com/repos/keycloak/keycloak/pulls/5627,224062618,2018-10-10T12:54:02Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/AbstractPolicyEnforcer.java,"@@ -309,7 +310,15 @@ private MethodConfig getRequiredScopes(PathConfig pathConfig, Request request) {         MethodConfig methodConfig = new MethodConfig();          methodConfig.setMethod(request.getMethod());-        methodConfig.setScopes(pathConfig.getScopes());+        List<String> scopes = new ArrayList<>(pathConfig.getScopes());++        if (Boolean.TRUE.equals(getEnforcerConfig().getHttpMethodAsScope())) {+            if (scopes.isEmpty()) {","Since this still loads all of the scopes associated with the resource as defined in the server, you would never get an empty scopes list. You have to associate the scopes with the resource in order to be able to define a scope based permission (unless something else has changed.) So I think that the code should be:List<String> scopes = new ArrayList<>();if (Boolean.TRUE.equals(getEnforcerConfig().getHttpMethodAsScope())) {    scopes.add(request.getMethod());} else {    scopes.addAll(pathConfig.getScopes());}",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5636,224692769,2018-10-12T07:25:40Z,services/src/main/java/org/keycloak/social/microsoft/MicrosoftIdentityProvider.java,"@@ -71,58 +65,62 @@ protected String getProfileEndpointForValidation(EventBuilder event) {         return PROFILE_URL;     } -    @Override-    protected SimpleHttp buildUserInfoRequest(String subjectToken, String userInfoUrl) {-        String URL = null;-        try {-            URL = PROFILE_URL + ""?access_token="" + URLEncoder.encode(subjectToken, ""UTF-8"");-        } catch (UnsupportedEncodingException e) {-            throw new RuntimeException(e);-        }-        return SimpleHttp.doGet(URL, session);-    }-     @Override     protected BrokeredIdentityContext doGetFederatedIdentity(String accessToken) {         try {-            String URL = PROFILE_URL + ""?access_token="" + URLEncoder.encode(accessToken, ""UTF-8"");-            if (log.isDebugEnabled()) {-                log.debug(""Microsoft Live user profile request to: "" + URL);-            }-            JsonNode profile = SimpleHttp.doGet(URL, session).asJson();-+            JsonNode profile = SimpleHttp.doGet(PROFILE_URL, session).auth(accessToken).asJson();             return extractIdentityFromProfile(null, profile);         } catch (Exception e) {-            throw new IdentityBrokerException(""Could not obtain user profile from Microsoft Live ID."", e);+            throw new IdentityBrokerException(""Could not obtain user profile from Microsoft Graph"", e);         }     }      @Override     protected BrokeredIdentityContext extractIdentityFromProfile(EventBuilder event, JsonNode profile) {         String id = getJsonProperty(profile, ""id"");--        String email = null;-        if (profile.has(""emails"")) {-            email = getJsonProperty(profile.get(""emails""), ""preferred"");-        }-         BrokeredIdentityContext user = new BrokeredIdentityContext(id); +        String email = getJsonProperty(profile, ""mail"");+        if (email == null && profile.has(""userPrincipalName"")) {+            String username = getJsonProperty(profile, ""userPrincipalName"");+            if (this.isValidEmail(username)) {+                email = username;+            }+        }         user.setUsername(email != null ? email : id);-        user.setFirstName(getJsonProperty(profile, ""first_name""));-        user.setLastName(getJsonProperty(profile, ""last_name""));+        user.setFirstName(getJsonProperty(profile, ""givenName""));+        user.setLastName(getJsonProperty(profile, ""surname""));         if (email != null)             user.setEmail(email);         user.setIdpConfig(getConfig());         user.setIdp(this);          AbstractJsonUserAttributeMapper.storeUserProfileForMapper(user, profile, getConfig().getAlias());-         return user;     }      @Override     protected String getDefaultScopes() {         return DEFAULT_SCOPE;     }++    /**+     * Verifies if the supplied string is a valid e-mail address using the regex specified in the+     * <a href=""https://www.owasp.org/index.php/OWASP_Validation_Regex_Repository"">OWASP Validation Regex repository</a>+     *+     * @param email the string to be verified.+     * @return {@code true} if the supplied string is a valid e-mail address; {@code false} otherwise.+     */+    public boolean isValidEmail(String email)+    {+        String emailRegex = ""^[a-zA-Z0-9_+&*-]+(?:\\.""++                ""[a-zA-Z0-9_+&*-]+)*@"" ++                ""(?:[a-zA-Z0-9-]+\\.)+[a-z"" ++                ""A-Z]{2,7}$"";++        Pattern pat = Pattern.compile(emailRegex);","AFAIK there is some performance penalty in always compile regex in each run. Is it possible to declare ""pat"" as static final variable?From the long term, it will be probably even better if we just use org.keycloak.services.validation.Validation.isEmailValid(String email) for all the places where we want to validate email address. It will be good if we replace the Validation.EMAIL_PATTERN regex with yours, as it seems that yours is much better regex and officially proposed by owasp? However this will be probably for future, as we probably don't want to risk changing the behaviour of Validation.isEmailValid in ""prod"" .",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5603,224699398,2018-10-12T07:53:53Z,server-spi-private/src/main/java/org/keycloak/crypto/SignatureProvider.java,"@@ -25,6 +27,9 @@      SignatureVerifierContext verifier(String kid) throws VerificationException; +    // KEYCLOAK-8460 client signed signature verification+    SignatureVerifierContext verifier(ClientModel client, JWSInput input) throws VerificationException;",Verifying signatures for clients should not be added to the SignatureProvider. Instead a new ClientSignatureVerifierProvider should be introduced. This will also enable listing supported algorithms properly rather than hard-coding the lists.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5603,224701895,2018-10-12T08:03:46Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oidc/OIDCWellKnownProviderTest.java,"@@ -126,7 +126,7 @@ public void testDiscovery() {             Assert.assertNames(oidcConfig.getSubjectTypesSupported(), ""pairwise"", ""public"");             Assert.assertNames(oidcConfig.getIdTokenSigningAlgValuesSupported(), Algorithm.RS256, Algorithm.RS384, Algorithm.RS512, Algorithm.ES256, Algorithm.ES384, Algorithm.ES512, Algorithm.HS256, Algorithm.HS384, Algorithm.HS512);             Assert.assertNames(oidcConfig.getUserInfoSigningAlgValuesSupported(), ""none"", Algorithm.RS256, Algorithm.RS384, Algorithm.RS512, Algorithm.ES256, Algorithm.ES384, Algorithm.ES512, Algorithm.HS256, Algorithm.HS384, Algorithm.HS512);-            Assert.assertNames(oidcConfig.getRequestObjectSigningAlgValuesSupported(), ""none"", Algorithm.RS256);+            Assert.assertNames(oidcConfig.getRequestObjectSigningAlgValuesSupported(), ""none"", Algorithm.RS256, Algorithm.RS384, Algorithm.RS512, Algorithm.ES256, Algorithm.ES384, Algorithm.ES512);",See above. Do not hardcode list of algorithms.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5603,224701928,2018-10-12T08:03:55Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/clients.js,"@@ -929,10 +929,16 @@ module.controller('ClientDetailCtrl', function($scope, realm, client, flows, $ro         {name: ""INCLUSIVE_WITH_COMMENTS"", value: ""http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments""}     ]; +    // KEYCLOAK-8460 Request Object Signature Verification Other Than RS256     $scope.requestObjectSignatureAlgorithms = [         ""any"",         ""none"",-        ""RS256""+        ""RS256"",",See above. Do not hardcode list of algorithms.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5638,224748290,2018-10-12T11:02:40Z,testsuite/integration-arquillian/pom.xml,"@@ -73,6 +73,8 @@         <migration.70.version>1.9.8.Final</migration.70.version>         <migration.70.authz.version>2.2.1.Final</migration.70.authz.version>",I believe this property and the profile `<id>test-70-authz-migration</id>` is no longer needed.,X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5615,224764477,2018-10-12T12:17:57Z,server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java,"@@ -223,13 +223,21 @@ public static AuthDetailsRepresentation toRepresentation(AuthDetails authDetails     }      public static RoleRepresentation toRepresentation(RoleModel role) {+        return toRepresentation(role, false);+    }++    public static RoleRepresentation toRepresentation(RoleModel role, boolean full) {","Prefer consistency here, should be two methods - toRepresentation (full = true) and toBriefRepresentation (full = false) - cf UserRepresentation representation https://github.com/keycloak/keycloak/blob/master/server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java#L169",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5615,224824653,2018-10-12T15:29:07Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -424,7 +424,7 @@ private static PolicyRepresentation createPolicyRepresentation(AuthorizationProv      * @return RoleRepresentation with all stuff filled (including composite roles)      */     public static RoleRepresentation exportRole(RoleModel role) {-        RoleRepresentation roleRep = ModelToRepresentation.toRepresentation(role);+        RoleRepresentation roleRep = ModelToRepresentation.toBriefRepresentation(role);","I checked the rest and it looks good to me. I did not realize that one earlier so it was really good that you performed the renaming that revealed this issue. The full `toRepresentation` should be used for the export/import and role detail only, not for any other place. So IMHO, the rest of the code should stay as it is.",X
4183757,unly,https://api.github.com/repos/keycloak/keycloak/pulls/5615,224838958,2018-10-12T16:08:07Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -424,7 +424,7 @@ private static PolicyRepresentation createPolicyRepresentation(AuthorizationProv      * @return RoleRepresentation with all stuff filled (including composite roles)      */     public static RoleRepresentation exportRole(RoleModel role) {-        RoleRepresentation roleRep = ModelToRepresentation.toRepresentation(role);+        RoleRepresentation roleRep = ModelToRepresentation.toBriefRepresentation(role);",I was looking for an import function mapping representations to models. So far the closest thing I found was https://github.com/keycloak/keycloak/blob/master/server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java#L1033 but that looks to me like it only imports the name and id... Is that right? Also is there another place? The previously discussed `exportRole` I'll fix.,X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/5603,225396094,2018-10-16T04:45:38Z,services/src/main/java/org/keycloak/keys/loader/PublicKeyStorageManager.java,"@@ -46,6 +47,19 @@ public static PublicKey getClientPublicKey(KeycloakSession session, ClientModel         return keyStorage.getPublicKey(modelKey, kid, loader);     } +    // KEYCLOAK-8460 client signed signature verification+    // key is wrapped by KeyWrapper in order to use refactored token signature verification mechanism+    public static KeyWrapper getClientPublicKeyWrapper(KeycloakSession session, ClientModel client, JWSInput input) {+        String kid = input.getHeader().getKeyId();+        PublicKey verifyKey = getClientPublicKey(session, client, input);+        if (verifyKey == null) return null;++        KeyWrapper keyWrapper = new KeyWrapper();+        keyWrapper.setKid(kid);+        keyWrapper.setAlgorithm(input.getHeader().getAlgorithm().name());","I agree with. To do so with current client's public key management implementation (PublicKeyStorageManager, ClientPublicKeyLoader, InfinispanPublicKeyStorageProvider, PublicKeysEntry), I think that those might treat KeyWrapper (including key and its metadata) instead of PublicKey to retrieve the algorithm associated with the key. How do you think about it?I've tried to retrieve and cache key information as KeyWrapper instead of PublicKey, but found that it needs to modify a lot of codes.",X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/5603,225404891,2018-10-16T05:51:26Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oidc/OIDCWellKnownProviderTest.java,"@@ -126,7 +126,7 @@ public void testDiscovery() {             Assert.assertNames(oidcConfig.getSubjectTypesSupported(), ""pairwise"", ""public"");             Assert.assertNames(oidcConfig.getIdTokenSigningAlgValuesSupported(), Algorithm.RS256, Algorithm.RS384, Algorithm.RS512, Algorithm.ES256, Algorithm.ES384, Algorithm.ES512, Algorithm.HS256, Algorithm.HS384, Algorithm.HS512);             Assert.assertNames(oidcConfig.getUserInfoSigningAlgValuesSupported(), ""none"", Algorithm.RS256, Algorithm.RS384, Algorithm.RS512, Algorithm.ES256, Algorithm.ES384, Algorithm.ES512, Algorithm.HS256, Algorithm.HS384, Algorithm.HS512);-            Assert.assertNames(oidcConfig.getRequestObjectSigningAlgValuesSupported(), ""none"", Algorithm.RS256);+            Assert.assertNames(oidcConfig.getRequestObjectSigningAlgValuesSupported(), ""none"", Algorithm.RS256, Algorithm.RS384, Algorithm.RS512, Algorithm.ES256, Algorithm.ES384, Algorithm.ES512);","Looking at ID Token signing algorithm supported, supported algorithms need to be specified explicitly in this test class while need not in the provider class (OIDCWellKnownProvider). What do you think about that? ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5637,225812947,2018-10-17T07:47:40Z,services/src/main/java/org/keycloak/services/filters/KeycloakStringEntityFilter.java,"@@ -0,0 +1,46 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.filters;++import java.io.IOException;+import java.nio.charset.StandardCharsets;++import javax.ws.rs.container.ContainerRequestContext;+import javax.ws.rs.container.ContainerResponseContext;+import javax.ws.rs.container.ContainerResponseFilter;++/**+ * Workaround for KEYCLOAK-8461+ *+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class KeycloakStringEntityFilter implements ContainerResponseFilter {++    @Override+    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {+        // Assuming status 400 or more is problematic. Not sure it is correct assumption...","Yes, it is due only 400 is checked in [MessageSanitizerContainerResponseFilter](https://github.com/resteasy/Resteasy/blob/09323d40e101e8a7d49e027a2d98e15856229b58/resteasy-core/src/main/java/org/jboss/resteasy/plugins/interceptors/MessageSanitizerContainerResponseFilter.java#L43)",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/5603,226159235,2018-10-18T03:31:43Z,services/src/main/java/org/keycloak/keys/loader/PublicKeyStorageManager.java,"@@ -46,6 +47,19 @@ public static PublicKey getClientPublicKey(KeycloakSession session, ClientModel         return keyStorage.getPublicKey(modelKey, kid, loader);     } +    // KEYCLOAK-8460 client signed signature verification+    // key is wrapped by KeyWrapper in order to use refactored token signature verification mechanism+    public static KeyWrapper getClientPublicKeyWrapper(KeycloakSession session, ClientModel client, JWSInput input) {+        String kid = input.getHeader().getKeyId();+        PublicKey verifyKey = getClientPublicKey(session, client, input);+        if (verifyKey == null) return null;++        KeyWrapper keyWrapper = new KeyWrapper();+        keyWrapper.setKid(kid);+        keyWrapper.setAlgorithm(input.getHeader().getAlgorithm().name());","So, I will try to retrieve and cache the client public key information as KeyWrapper.Current implementation gets the client public key from the following 3 sources.* client's jwks_url location* pre-registered certificate* pre-registered public keyThe first source might be tractable because I can map JWK formatted information onto KeyWrapper directly.The second and third sources might not be tractable because no such metadata is registerd explicitly.I've investigated them and found that keys from these two sources are for JWS Client Assertion for client authentication, and seemed to be that those key type is RSA, key use is for signature, algorithm is RS256 implicitly. Therefore, I will map keys' metadata which are from those two sources onto KeyWrapper as such. What do you think about it?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5603,226568104,2018-10-19T08:23:45Z,services/src/main/java/org/keycloak/keys/loader/PublicKeyStorageManager.java,"@@ -46,6 +47,19 @@ public static PublicKey getClientPublicKey(KeycloakSession session, ClientModel         return keyStorage.getPublicKey(modelKey, kid, loader);     } +    // KEYCLOAK-8460 client signed signature verification+    // key is wrapped by KeyWrapper in order to use refactored token signature verification mechanism+    public static KeyWrapper getClientPublicKeyWrapper(KeycloakSession session, ClientModel client, JWSInput input) {+        String kid = input.getHeader().getKeyId();",+1 to refactor PublicKeyStorageProvider (and related support classes it uses like PublicKeyLoader) to return KeyWrapper rather than PublicKey. That means that things like kid and algorithm don't need to be set here in the PublicKeyStorageManager.,X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5614,227433745,2018-10-23T15:00:10Z,themes/src/main/resources/theme/base/admin/resources/js/app.js,"@@ -1419,19 +1413,7 @@ module.config([ '$routeProvider', function($routeProvider) {             },             controller : 'ClientDetailCtrl'         })-        .when('/create/client-scope/step-1/:realm', {","It seems you did not correctly rebased with the latest master? You seem to remove some existing functionality, which was added in the meantime.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5669,228150906,2018-10-25T12:25:35Z,testsuite/integration-arquillian/servers/app-server/undertow/src/main/java/org/keycloak/testsuite/arquillian/undertow/UndertowAppServer.java,"@@ -115,7 +121,14 @@ public ProtocolMetaData deploy(Archive<?> archive) throws DeploymentException {         if (archive instanceof UndertowWebArchive) {             di = ((UndertowWebArchive) archive).getDeploymentInfo();         } else if (archive instanceof WebArchive) {-            di = new UndertowDeployerHelper().getDeploymentInfo(configuration, (WebArchive)archive);+            String applicationPath = getResteasyApplicationPath((WebArchive) archive);","What about a bit different approach? Something like: ```        Class<?> applicationClass = webArchive.getContent(archivePath ->                 archivePath.get().startsWith(""/WEB-INF/classes/"") &&                        archivePath.get().endsWith("".class"")        ).values().stream()                .filter(node -> node.getAsset() instanceof ClassAsset)                .map(node -> ((ClassAsset)node.getAsset()).getSource())                .filter(clazz -> clazz.isAssignableFrom(Application.class))                .findFirst()                .orElseThrow(() -> new IllegalStateException(""some message""));```could work as well and imho it's better than parsing class name from ArchivePath string, wdyt?",
4183757,unly,https://api.github.com/repos/keycloak/keycloak/pulls/5614,228171622,2018-10-25T13:26:47Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserAdapter.java,"@@ -357,9 +349,41 @@ public void deleteRoleMapping(RoleModel role) {             groups.add(groupModel);          }+        groups.sort(Comparator.comparing(GroupModel::getName));         return groups;     } +    @Override+    public List<GroupModel> getGroups(Integer first, Integer max) {+        return getGroups().stream()+                .sorted(Comparator.comparing(GroupModel::getName))",One option could be to pass a comparator along to the function call like `Set<GroupModel> getGroups(Comparator<GroupModel> c)`. This way you could set it based on your needs. But changing the interface would affect other classes as well. What do you think is the preferred option?,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5700,231785518,2018-11-08T07:29:50Z,authz/policy/drools/src/main/java/org/keycloak/authorization/policy/provider/drools/DroolsPolicyProviderFactory.java,"@@ -150,4 +158,10 @@ void remove(Policy policy) {     KieContainer getKieContainer(String groupId, String artifactId, String version) {         return this.ks.newKieContainer(this.ks.newReleaseId(groupId, artifactId, version));     }++    private void checkIfFeatureIsEnabled() {",Would it not be better to use the approach used by other providers:https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/authentication/authenticators/browser/ScriptBasedAuthenticatorFactory.java#L155,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5700,231785681,2018-11-08T07:30:40Z,server-spi-private/src/main/java/org/keycloak/authorization/policy/provider/PolicyProviderFactory.java,"@@ -38,6 +38,10 @@ default boolean isInternal() {         return false;     } +    default boolean isEnabled() {",See above we already have support to enable/disable providers - see https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/authentication/authenticators/browser/ScriptBasedAuthenticatorFactory.java#L155,X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5681,232041095,2018-11-08T19:59:35Z,server-spi/src/main/java/org/keycloak/models/ClientScopeModel.java,"@@ -93,5 +93,22 @@ default void setIncludeInTokenScope(boolean includeInTokenScope) {         setAttribute(INCLUDE_IN_TOKEN_SCOPE, String.valueOf(includeInTokenScope));     } +    /**+     * Indicates whether or not this scope is persistent. If {@code false} the scope is considered a transient scope, indicating that any reference+     * to this scope should not be persisted (e.g: user consents)+     *+     * @return {@code true} if this is a persistent scope, otherwise {@code false}. Defaults to {@code true}+     */+    default boolean isPersistent() {+        return true;+    } +    /**","It was related to method ""isDefaultScope()"" . I see it is used just in TokenManager. However is it any bad if you add client itself to clientScopes in TokenManager considering that it won't be shown on consent screen?",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5681,232599494,2018-11-12T10:15:51Z,server-spi/src/main/java/org/keycloak/models/ClientScopeModel.java,"@@ -93,5 +93,22 @@ default void setIncludeInTokenScope(boolean includeInTokenScope) {         setAttribute(INCLUDE_IN_TOKEN_SCOPE, String.valueOf(includeInTokenScope));     } +    /**+     * Indicates whether or not this scope is persistent. If {@code false} the scope is considered a transient scope, indicating that any reference+     * to this scope should not be persisted (e.g: user consents)+     *+     * @return {@code true} if this is a persistent scope, otherwise {@code false}. Defaults to {@code true}+     */+    default boolean isPersistent() {+        return true;+    } +    /**","Yes, which looks like a bug. I've created https://issues.jboss.org/browse/KEYCLOAK-8790 for it (more details in the email). I think that as easiest possibility, we can change the LoginActionsService.processConsent method to persist just those clientScopes, which require consent (clientScopeModel.isDisplayOnConsentScreen() )? This won't handle the corner case I described in the KEYCLOAK-8790 (Case when admin changed the clientScope to require consent in the meantime between consent screen was shown for the user and user confirmed it), however it is sufficient for most cases IMO.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5696,233589844,2018-11-14T19:34:56Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java,"@@ -0,0 +1,630 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.model;++import org.jboss.arquillian.container.test.api.Deployment;+import org.jboss.arquillian.container.test.api.TargetsContainer;+import org.jboss.shrinkwrap.api.spec.WebArchive;+import org.junit.After;+import org.junit.Assert;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.admin.client.resource.UserResource;+import org.keycloak.common.util.Time;+import org.keycloak.models.*;+import org.keycloak.models.session.UserSessionPersisterProvider;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.services.managers.ClientManager;+import org.keycloak.services.managers.RealmManager;+import org.keycloak.services.managers.UserSessionManager;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.arquillian.annotation.ModelTest;+import org.keycloak.testsuite.runonserver.RunOnServerDeployment;++import java.util.*;+import java.util.concurrent.atomic.AtomicReference;++import static org.junit.Assert.assertEquals;+import static org.junit.Assert.assertTrue;+import static org.keycloak.testsuite.arquillian.DeploymentTargetModifier.AUTH_SERVER_CURRENT;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class UserSessionProviderOfflineTest extends AbstractTestRealmKeycloakTest {+    private static KeycloakSession currentSession;+    private static RealmModel realm;+    private static UserSessionManager sessionManager;+    private static UserSessionPersisterProvider persister;++    @Deployment+    @TargetsContainer(AUTH_SERVER_CURRENT)+    public static WebArchive deploy() {+        return RunOnServerDeployment.create(UserResource.class, UserSessionProviderOfflineTest.class)+                .addPackages(true,+                        ""org.keycloak.testsuite"",+                        ""org.keycloak.testsuite.model"");+    }++    private static Set<String> createOfflineSessionIncludeClientSessions(KeycloakSession session, UserSessionModel userSession) {+        Set<String> offlineSessions = new HashSet<>();+        UserSessionManager localManager = new UserSessionManager(session);+        for (AuthenticatedClientSessionModel clientSession : userSession.getAuthenticatedClientSessions().values()) {+            localManager.createOrUpdateOfflineSession(clientSession, userSession);+            offlineSessions.add(clientSession.getClient().getId());+        }++        return offlineSessions;+    }++    private static void resetSession(KeycloakSession session) {+        /*KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionReset) -> {+            currentSession.close();+            currentSession = sessionReset;+            realm = currentSession.realms().getRealm(""test"");+            sessionManager = new UserSessionManager(currentSession);+            persister = currentSession.getProvider(UserSessionPersisterProvider.class);+        });*/+    }++    public static void assertSession(UserSessionModel session, UserModel user, String ipAddress, int started, int lastRefresh, String... clients) {+        assertEquals(user.getId(), session.getUser().getId());+        assertEquals(ipAddress, session.getIpAddress());+        assertEquals(user.getUsername(), session.getLoginUsername());+        assertEquals(""form"", session.getAuthMethod());+        assertTrue(session.isRememberMe());+        //assertTrue(session.getStarted() >= started - 1 && session.getStarted() <= started + 1);+        //assertTrue(session.getLastSessionRefresh() >= lastRefresh - 1 && session.getLastSessionRefresh() <= lastRefresh + 1);++        String[] actualClients = new String[session.getAuthenticatedClientSessions().size()];+        int i = 0;+        for (Map.Entry<String, AuthenticatedClientSessionModel> entry : session.getAuthenticatedClientSessions().entrySet()) {+            String clientUUID = entry.getKey();+            AuthenticatedClientSessionModel clientSession = entry.getValue();+            Assert.assertEquals(clientUUID, clientSession.getClient().getId());+            actualClients[i] = clientSession.getClient().getClientId();+            i++;+        }+    }++    private static AuthenticatedClientSessionModel createClientSession(KeycloakSession sessionParam, ClientModel client, UserSessionModel userSession, String redirect, String state) {+        AuthenticatedClientSessionModel clientSession = sessionParam.sessions().createClientSession(client.getRealm(), client, userSession);+        clientSession.setRedirectUri(redirect);+        if (state != null) clientSession.setNote(OIDCLoginProtocol.STATE_PARAM, state);+        return clientSession;+    }++    private static UserSessionModel[] createSessions(KeycloakSession session) {+        UserSessionModel[] sessions = new UserSessionModel[3];+        sessions[0] = session.sessions().createUserSession(realm, currentSession.users().getUserByUsername(""user1"", realm), ""user1"", ""127.0.0.1"", ""form"", true, null, null);++        Set<String> roles = new HashSet<String>();+        roles.add(""one"");+        roles.add(""two"");++        Set<String> protocolMappers = new HashSet<String>();+        protocolMappers.add(""mapper-one"");+        protocolMappers.add(""mapper-two"");++        createClientSession(session, realm.getClientByClientId(""test-app""), sessions[0], ""http://redirect"", ""state"");+        createClientSession(session, realm.getClientByClientId(""third-party""), sessions[0], ""http://redirect"", ""state"");++        sessions[1] = session.sessions().createUserSession(realm, session.users().getUserByUsername(""user1"", realm), ""user1"", ""127.0.0.2"", ""form"", true, null, null);+        createClientSession(session, realm.getClientByClientId(""test-app""), sessions[1], ""http://redirect"", ""state"");++        sessions[2] = session.sessions().createUserSession(realm, session.users().getUserByUsername(""user2"", realm), ""user2"", ""127.0.0.3"", ""form"", true, null, null);+        createClientSession(session, realm.getClientByClientId(""test-app""), sessions[2], ""http://redirect"", ""state"");++        return sessions;+    }++    public static void reloadState(KeycloakSession session) {+        reloadState(session, false);+    }++    public static void reloadState(KeycloakSession session, Boolean initialConfig) {+        currentSession = session;+        realm = currentSession.realms().getRealm(""test"");+        if (initialConfig == true) {+            currentSession.users().addUser(realm, ""user1"").setEmail(""user1@localhost"");+            currentSession.users().addUser(realm, ""user2"").setEmail(""user2@localhost"");+        }+        sessionManager = new UserSessionManager(currentSession);+        persister = currentSession.getProvider(UserSessionPersisterProvider.class);+    }++    @Before+    public void before() {+        testingClient.server().run(session -> {+            KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionBefore) -> {+                reloadState(sessionBefore, true);+            });+        });+    }++    @After+    public void after() {+        testingClient.server().run(session -> {+            RealmModel realm = session.realms().getRealmByName(""test"");+            session.sessions().removeUserSessions(realm);+            UserModel user1 = session.users().getUserByUsername(""user1"", realm);+            UserModel user2 = session.users().getUserByUsername(""user2"", realm);++            UserManager um = new UserManager(session);+            if (user1 != null) {+                um.removeUser(realm, user1);+            }+            if (user2 != null) {+                um.removeUser(realm, user2);+            }+        });+    }++    @Test+    @ModelTest+    public void testOfflineSessionsCrud(KeycloakSession session) {+        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionCrud) -> {+            // Create some online sessions in infinispan+            int started = Time.currentTime();++            reloadState(sessionCrud);++            UserSessionModel[] origSessions = createSessions(currentSession);+            sessionCrud.getTransactionManager().commit();",This applies for many places in this class,X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5732,234532103,2018-11-19T08:48:24Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/RequiredActionEmailVerificationTest.java,"@@ -868,6 +877,45 @@ public void verifyEmailWhileLoggedIn() throws IOException, MessagingException {         Assert.assertThat(user.getRequiredActions(), Matchers.empty());     } +    @Test+    public void verifyEmailViaAuthSessionWhileLoggedIn() throws IOException, MessagingException {+        UserAttributeUpdater userAttributeUpdater = new UserAttributeUpdater(testRealm().users().get(testUserId));+        userAttributeUpdater.setEmailVerified(false).update();++        final String testRealmName = testRealm().toRepresentation().getRealm();+        accountPage.setAuthRealm(testRealmName);+        oauth.realm(testRealmName).clientId(""account"").redirectUri(getAuthServerRoot() + ""realms/"" + testRealmName + ""/account"");+        loginPage.open();++        String authSessionId = AuthenticationSessionFailoverClusterTest.getAuthSessionCookieValue(driver);","Did you test on Wildfly? Not 100% sure, but AFAIR this probably won't work on Wildfly (authSessionId and realmId may not be visible in the inner block, which is executed on completely different VM than test).I think for long term perspective, it will be good to have some better support for transfer the state between test and VM. I think that ATM it is not so well supported...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5763,238611833,2018-12-04T10:47:59Z,core/src/main/java/org/keycloak/crypto/KeyWrapper.java,"@@ -34,6 +37,17 @@     private Key verifyKey;     private X509Certificate certificate; +    public KeyWrapper(JWK k) {+        kid = k.getKeyId();+        algorithm = k.getAlgorithm();+        verifyKey = JWKParser.create(k).toPublicKey();+        use = KeyUse.SIG;","JWK class has ""publicKeyUse"" defined on it. Could be ""use"" retrieved from it rather than hardcoded to KeyUse.SIG? Maybe it's not the problem for the current use-case, just wondering about the future use-cases too and the possibility to avoid surprises for someone calling this constructor, who expects that KeyUse will be properly retrieved based on the info from the JWK. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5763,238623855,2018-12-04T11:27:33Z,services/src/main/java/org/keycloak/crypto/ServerAsymmetricSignatureVerifierContext.java,"@@ -16,21 +16,54 @@  */ package org.keycloak.crypto; +import org.keycloak.broker.provider.util.SimpleHttp; import org.keycloak.common.VerificationException;+import org.keycloak.jose.jwk.JSONWebKeySet;+import org.keycloak.jose.jwk.JWK; import org.keycloak.models.KeycloakSession;+import org.keycloak.util.JsonSerialization;  public class ServerAsymmetricSignatureVerifierContext extends AsymmetricSignatureVerifierContext { -    public ServerAsymmetricSignatureVerifierContext(KeycloakSession session, String kid, String algorithm) throws VerificationException {-        super(getKey(session, kid, algorithm));+    public ServerAsymmetricSignatureVerifierContext(KeycloakSession session, String kid, String jwksUrl, String algorithm) throws VerificationException {+        super(getKey(session, kid, jwksUrl, algorithm));     } -    private static KeyWrapper getKey(KeycloakSession session, String kid, String algorithm) throws VerificationException {+    private static KeyWrapper getKey(KeycloakSession session, String kid, String jwksUrl, String algorithm) throws VerificationException {         KeyWrapper key = session.keys().getKey(session.getContext().getRealm(), kid, KeyUse.SIG, algorithm);         if (key == null) {-            throw new VerificationException(""Key not found"");+            if (jwksUrl != null) {","IMO the possible issue with this approach is, that the request to jwksUrl need to be possibly sent always when you need to verify signature. No caching support. Also the key of identityProvider can be retrieved from the hardcoded ""pem"" format, not just jwksUrl as I mentioned above.I wonder if we can just unify to use the same approach as used for clients? So change the signature of PublicKeyStorageManager.getIdentityProviderPublicKey to return ""KeyWrapper"" rather than ""PublicKey"" and possibly have some provider similar to ClientSignatureVerifierProvider (the verifies created by this provider are able to consume the PublicKeyStorageManager.getClientPublicKeyWrapper).An (easier) alternative can be to just retrieve the key in similar like OIDCIdentityProvider.verify is doing. That's not so good use of SPI, but at least there is caching of the keys and the ability to load the keys from both jwksUrl and hardcoded.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5696,238998576,2018-12-05T10:00:49Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java,"@@ -0,0 +1,584 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.model;++import org.jboss.arquillian.container.test.api.Deployment;+import org.jboss.arquillian.container.test.api.TargetsContainer;+import org.jboss.shrinkwrap.api.spec.WebArchive;+import org.junit.After;+import org.junit.Assert;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.admin.client.resource.UserResource;+import org.keycloak.common.util.Time;+import org.keycloak.models.*;+import org.keycloak.models.session.UserSessionPersisterProvider;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.services.managers.ClientManager;+import org.keycloak.services.managers.RealmManager;+import org.keycloak.services.managers.UserSessionManager;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.arquillian.annotation.ModelTest;+import org.keycloak.testsuite.runonserver.RunOnServerDeployment;++import java.util.*;+import java.util.concurrent.atomic.AtomicReference;++import static org.junit.Assert.assertEquals;+import static org.junit.Assert.assertTrue;+import static org.keycloak.testsuite.arquillian.DeploymentTargetModifier.AUTH_SERVER_CURRENT;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class UserSessionProviderOfflineTest extends AbstractTestRealmKeycloakTest {+    private static KeycloakSession currentSession;+    private static RealmModel realm;+    private static UserSessionManager sessionManager;+    private static UserSessionPersisterProvider persister;++    @Deployment+    @TargetsContainer(AUTH_SERVER_CURRENT)+    public static WebArchive deploy() {+        return RunOnServerDeployment.create(UserResource.class, UserSessionProviderOfflineTest.class)+                .addPackages(true,+                        ""org.keycloak.testsuite"",+                        ""org.keycloak.testsuite.model"");+    }++    private static Set<String> createOfflineSessionIncludeClientSessions(KeycloakSession session, UserSessionModel userSession) {+        Set<String> offlineSessions = new HashSet<>();+        UserSessionManager localManager = new UserSessionManager(session);+        for (AuthenticatedClientSessionModel clientSession : userSession.getAuthenticatedClientSessions().values()) {+            localManager.createOrUpdateOfflineSession(clientSession, userSession);+            offlineSessions.add(clientSession.getClient().getId());+        }++        return offlineSessions;+    }++    public static void assertSession(UserSessionModel session, UserModel user, String ipAddress, int started, int lastRefresh, String... clients) {+        assertEquals(user.getId(), session.getUser().getId());+        assertEquals(ipAddress, session.getIpAddress());+        assertEquals(user.getUsername(), session.getLoginUsername());+        assertEquals(""form"", session.getAuthMethod());+        assertTrue(session.isRememberMe());+        //assertTrue(session.getStarted() >= started - 1 && session.getStarted() <= started + 1);+        //assertTrue(session.getLastSessionRefresh() >= lastRefresh - 1 && session.getLastSessionRefresh() <= lastRefresh + 1);++        String[] actualClients = new String[session.getAuthenticatedClientSessions().size()];+        int i = 0;+        for (Map.Entry<String, AuthenticatedClientSessionModel> entry : session.getAuthenticatedClientSessions().entrySet()) {+            String clientUUID = entry.getKey();+            AuthenticatedClientSessionModel clientSession = entry.getValue();+            Assert.assertEquals(clientUUID, clientSession.getClient().getId());+            actualClients[i] = clientSession.getClient().getClientId();+            i++;+        }+    }++    private static AuthenticatedClientSessionModel createClientSession(KeycloakSession sessionParam, ClientModel client, UserSessionModel userSession, String redirect, String state) {+        AuthenticatedClientSessionModel clientSession = sessionParam.sessions().createClientSession(client.getRealm(), client, userSession);+        clientSession.setRedirectUri(redirect);+        if (state != null) clientSession.setNote(OIDCLoginProtocol.STATE_PARAM, state);+        return clientSession;+    }++    private static UserSessionModel[] createSessions(KeycloakSession session) {+        UserSessionModel[] sessions = new UserSessionModel[3];+        sessions[0] = session.sessions().createUserSession(realm, currentSession.users().getUserByUsername(""user1"", realm), ""user1"", ""127.0.0.1"", ""form"", true, null, null);++        Set<String> roles = new HashSet<String>();+        roles.add(""one"");+        roles.add(""two"");++        Set<String> protocolMappers = new HashSet<String>();+        protocolMappers.add(""mapper-one"");+        protocolMappers.add(""mapper-two"");++        createClientSession(session, realm.getClientByClientId(""test-app""), sessions[0], ""http://redirect"", ""state"");+        createClientSession(session, realm.getClientByClientId(""third-party""), sessions[0], ""http://redirect"", ""state"");++        sessions[1] = session.sessions().createUserSession(realm, session.users().getUserByUsername(""user1"", realm), ""user1"", ""127.0.0.2"", ""form"", true, null, null);+        createClientSession(session, realm.getClientByClientId(""test-app""), sessions[1], ""http://redirect"", ""state"");++        sessions[2] = session.sessions().createUserSession(realm, session.users().getUserByUsername(""user2"", realm), ""user2"", ""127.0.0.3"", ""form"", true, null, null);+        createClientSession(session, realm.getClientByClientId(""test-app""), sessions[2], ""http://redirect"", ""state"");++        return sessions;+    }++    public static void reloadState(KeycloakSession session) {+        reloadState(session, false);+    }++    public static void reloadState(KeycloakSession session, Boolean initialConfig) {+        currentSession = session;+        realm = currentSession.realms().getRealm(""test"");+        if (initialConfig == true) {+            currentSession.users().addUser(realm, ""user1"").setEmail(""user1@localhost"");+            currentSession.users().addUser(realm, ""user2"").setEmail(""user2@localhost"");+        }+        sessionManager = new UserSessionManager(currentSession);+        persister = currentSession.getProvider(UserSessionPersisterProvider.class);+    }++    @Before+    public void before() {+        testingClient.server().run(session -> {+            KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionBefore) -> {+                reloadState(sessionBefore, true);+            });+        });+    }++    @After+    public void after() {+        testingClient.server().run(session -> {+            RealmModel realm = session.realms().getRealmByName(""test"");+            session.sessions().removeUserSessions(realm);+            UserModel user1 = session.users().getUserByUsername(""user1"", realm);+            UserModel user2 = session.users().getUserByUsername(""user2"", realm);++            UserManager um = new UserManager(session);+            if (user1 != null) {+                um.removeUser(realm, user1);+            }+            if (user2 != null) {+                um.removeUser(realm, user2);+            }+        });+    }++    @Test+    @ModelTest+    public void testOfflineSessionsCrud(KeycloakSession session) {++        UserModel[] user1 = new UserModel[1];+        UserModel[] user2 = new UserModel[1];+        Set<ClientModel>[] clients = new Set[1];+        UserSessionModel[][] origSessions = new UserSessionModel[1][1];+        Map<String, Set<String>> offlineSessions = new HashMap<>();+        ClientModel[] testApp = new ClientModel[1];+        ClientModel[] thirdparty = new ClientModel[1];+++        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionCrud) -> {+            // Create some online sessions in infinispan+            int started = Time.currentTime();++            reloadState(sessionCrud);++            origSessions[0] = createSessions(sessionCrud);+        });++        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionCrud2) -> {+            currentSession = sessionCrud2;+            realm = currentSession.realms().getRealm(""test"");+            sessionManager = new UserSessionManager(currentSession);+            persister = currentSession.getProvider(UserSessionPersisterProvider.class);++            // Key is userSession ID, values are client UUIDS+            //  ***** offlineSessions is declared here *****+            // Persist 3 created userSessions and clientSessions as offline+            testApp[0] = realm.getClientByClientId(""test-app"");+            List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp[0]);+            for (UserSessionModel userSession : userSessions) {+                offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession)); // ***** offline sessions is populated here *****+            }+            sessionCrud2.getTransactionManager().commit(); // <-- ***** without this commit offLineSessions.size() will return zero below in the for loop starting at line 220+            sessionCrud2.close(); // <-- This is because I need to end the transacton+        });+        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionCrud3) -> {  // <-- ***** New transaction here because it offlineSession.size() will return 0 *****+            currentSession = sessionCrud3;+            realm = currentSession.realms().getRealm(""test"");+            sessionManager = new UserSessionManager(currentSession);+            persister = currentSession.getProvider(UserSessionPersisterProvider.class);+++            // Assert all previously saved offline sessions found+            for (Map.Entry<String, Set<String>> entry : offlineSessions.entrySet()) {  // <-- ***** Otherwise offlineSessions goes out of scope!  *****+                UserSessionModel offlineSession = sessionManager.findOfflineUserSession(realm, entry.getKey());+                Assert.assertNotNull(offlineSession);+                Assert.assertEquals(offlineSession.getAuthenticatedClientSessions().keySet(), entry.getValue());+            }+++            // Find clients with offline token+            user1[0] = currentSession.users().getUserByUsername(""user1"", realm);+            clients[0] = sessionManager.findClientsWithOfflineToken(realm, user1[0]);+            Assert.assertEquals(clients[0].size(), 2);+            for (ClientModel client : clients[0]) {+                Assert.assertTrue(client.getClientId().equals(""test-app"") || client.getClientId().equals(""third-party""));+            }++            user2[0] = currentSession.users().getUserByUsername(""user2"", realm);+            clients[0] = sessionManager.findClientsWithOfflineToken(realm, user2[0]);+            Assert.assertEquals(clients[0].size(), 1);+            Assert.assertEquals(""test-app"", clients[0].iterator().next().getClientId());++            // Test count+            testApp[0] = realm.getClientByClientId(""test-app"");+            thirdparty[0] = realm.getClientByClientId(""third-party"");+            Assert.assertEquals(3, currentSession.sessions().getOfflineSessionsCount(realm, testApp[0]));+            Assert.assertEquals(1, currentSession.sessions().getOfflineSessionsCount(realm, thirdparty[0]));+            // Revoke ""test-app"" for user1+            sessionManager.revokeOfflineToken(user1[0], testApp[0]);++            // Assert userSession revoked+            testApp[0] = realm.getClientByClientId(""test-app"");+            thirdparty[0] = realm.getClientByClientId(""third-party"");++        });++        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionCrud4) -> {+            currentSession = sessionCrud4;+            realm = currentSession.realms().getRealm(""test"");+            sessionManager = new UserSessionManager(currentSession);+            persister = currentSession.getProvider(UserSessionPersisterProvider.class);++            // Still 2 sessions. The count of sessions by client may not be accurate after revoke due the+            // performance optimizations (the ""127.0.0.1"" currentSession still has another client ""thirdparty"" in it)+            Assert.assertEquals(2, currentSession.sessions().getOfflineSessionsCount(realm, testApp[0]));+            Assert.assertEquals(1, currentSession.sessions().getOfflineSessionsCount(realm, thirdparty[0]));++            List<UserSessionModel> thirdpartySessions = currentSession.sessions().getOfflineUserSessions(realm, thirdparty[0], 0, 10);+            Assert.assertEquals(1, thirdpartySessions.size());+            Assert.assertEquals(""127.0.0.1"", thirdpartySessions.get(0).getIpAddress());+            Assert.assertEquals(""user1"", thirdpartySessions.get(0).getUser().getUsername());++            user1[0] = currentSession.users().getUserByUsername(""user1"", realm);+            user2[0] = currentSession.users().getUserByUsername(""user2"", realm);+            clients[0] = sessionManager.findClientsWithOfflineToken(realm, user1[0]);+            Assert.assertEquals(1, clients[0].size());+            Assert.assertEquals(""third-party"", clients[0].iterator().next().getClientId());+            clients[0] = sessionManager.findClientsWithOfflineToken(realm, user2[0]);+            Assert.assertEquals(1, clients[0].size());+            Assert.assertEquals(""test-app"", clients[0].iterator().next().getClientId());++            // Revoke the second currentSession for user1 too.+            sessionManager.revokeOfflineToken(user1[0], thirdparty[0]);++        });++        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionCrud5) -> {+            currentSession = sessionCrud5;+            realm = currentSession.realms().getRealm(""test"");+            sessionManager = new UserSessionManager(currentSession);+            persister = currentSession.getProvider(UserSessionPersisterProvider.class);++            testApp[0] = realm.getClientByClientId(""test-app"");+            thirdparty[0] = realm.getClientByClientId(""third-party"");++            // Accurate count now. All sessions of user1 cleared+            Assert.assertEquals(1, currentSession.sessions().getOfflineSessionsCount(realm, testApp[0]));+            Assert.assertEquals(0, currentSession.sessions().getOfflineSessionsCount(realm, thirdparty[0]));++            List<UserSessionModel> testAppSessions = currentSession.sessions().getOfflineUserSessions(realm, testApp[0], 0, 10);++            Assert.assertEquals(1, testAppSessions.size());+            Assert.assertEquals(""127.0.0.3"", testAppSessions.get(0).getIpAddress());+            Assert.assertEquals(""user2"", testAppSessions.get(0).getUser().getUsername());++            clients[0] = sessionManager.findClientsWithOfflineToken(realm, user1[0]);+            Assert.assertEquals(0, clients[0].size());++        });+    }+++    @Test+    @ModelTest+    public void testOnRealmRemoved(KeycloakSession session) {++        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionRR) -> {++            currentSession = sessionRR;+            int started = Time.currentTime();+            sessionManager = new UserSessionManager(currentSession);+            persister = currentSession.getProvider(UserSessionPersisterProvider.class);+            RealmModel fooRealm = currentSession.realms().createRealm(""foo"", ""foo"");+            fooRealm.addClient(""foo-app"");+            currentSession.users().addUser(fooRealm, ""user3"");++            UserSessionModel userSession = currentSession.sessions().createUserSession(fooRealm, currentSession.users().getUserByUsername(""user3"", fooRealm), ""user3"", ""127.0.0.1"", ""form"", true, null, null);+            AuthenticatedClientSessionModel clientSession = createClientSession(currentSession, fooRealm.getClientByClientId(""foo-app""), userSession, ""http://redirect"", ""state"");++++            // Persist offline session+            fooRealm = currentSession.realms().getRealm(""foo"");+            userSession = currentSession.sessions().getUserSession(fooRealm, userSession.getId());+            createOfflineSessionIncludeClientSessions(currentSession, userSession);++++            UserSessionModel offlineUserSession = sessionManager.findOfflineUserSession(fooRealm, userSession.getId());+            Assert.assertEquals(offlineUserSession.getAuthenticatedClientSessions().size(), 1);+            AuthenticatedClientSessionModel offlineClientSession = offlineUserSession.getAuthenticatedClientSessions().values().iterator().next();+            Assert.assertEquals(""foo-app"", offlineClientSession.getClient().getClientId());+            Assert.assertEquals(""user3"", offlineClientSession.getUserSession().getUser().getUsername());++            // Remove realm+            RealmManager realmMgr = new RealmManager(currentSession);+            realmMgr.removeRealm(realmMgr.getRealm(""foo""));++++            fooRealm = currentSession.realms().createRealm(""foo"", ""foo"");+            fooRealm.addClient(""foo-app"");+            currentSession.users().addUser(fooRealm, ""user3"");++++            // Assert nothing loaded+            fooRealm = currentSession.realms().getRealm(""foo"");+            // Tests for Null seem to break always under the new testsuite, we test for the right number of things below so no need to test for null+            //Assert.assertNull(sessionManager.findOfflineUserSession(fooRealm, userSession.getId()));+            Assert.assertEquals(0, currentSession.sessions().getOfflineSessionsCount(fooRealm, fooRealm.getClientByClientId(""foo-app"")));++            // Cleanup+            realmMgr = new RealmManager(currentSession);+            realmMgr.removeRealm(realmMgr.getRealm(""foo""));+        });+    }++    @Test+    @ModelTest+    public void testOnClientRemoved(KeycloakSession session) {+        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionCR) -> {+            try {++                currentSession = sessionCR;+                int started = Time.currentTime();+                sessionManager = new UserSessionManager(currentSession);+                persister = currentSession.getProvider(UserSessionPersisterProvider.class);+                RealmModel fooRealm = currentSession.realms().createRealm(""foo"", ""foo"");+                fooRealm.addClient(""foo-app"");+                fooRealm.addClient(""bar-app"");+                currentSession.users().addUser(fooRealm, ""user3"");++                UserSessionModel userSession = currentSession.sessions().createUserSession(fooRealm, currentSession.users().getUserByUsername(""user3"", fooRealm), ""user3"", ""127.0.0.1"", ""form"", true, null, null);+                createClientSession(currentSession, fooRealm.getClientByClientId(""foo-app""), userSession, ""http://redirect"", ""state"");+                createClientSession(currentSession, fooRealm.getClientByClientId(""bar-app""), userSession, ""http://redirect"", ""state"");+++                // Create offline currentSession+                fooRealm = currentSession.realms().getRealm(""foo"");+                userSession = currentSession.sessions().getUserSession(fooRealm, userSession.getId());+                createOfflineSessionIncludeClientSessions(currentSession, userSession);++                RealmManager realmMgr = new RealmManager(currentSession);+                ClientManager clientMgr = new ClientManager(realmMgr);+                fooRealm = realmMgr.getRealm(""foo"");++                // Assert currentSession was persisted with both clientSessions+                UserSessionModel offlineSession = currentSession.sessions().getOfflineUserSession(fooRealm, userSession.getId());+                assertSession(offlineSession, currentSession.users().getUserByUsername(""user3"", fooRealm), ""127.0.0.1"", started, started, ""foo-app"", ""bar-app"");++                // Remove foo-app client+                ClientModel client = fooRealm.getClientByClientId(""foo-app"");+                clientMgr.removeClient(fooRealm, client);++                realmMgr = new RealmManager(currentSession);+                clientMgr = new ClientManager(realmMgr);+                fooRealm = realmMgr.getRealm(""foo"");++                // Assert just one bar-app clientSession persisted now+                offlineSession = currentSession.sessions().getOfflineUserSession(fooRealm, userSession.getId());+                Assert.assertEquals(1, offlineSession.getAuthenticatedClientSessions().size());+                Assert.assertEquals(""bar-app"", offlineSession.getAuthenticatedClientSessions().values().iterator().next().getClient().getClientId());++                // Remove bar-app client+                client = fooRealm.getClientByClientId(""bar-app"");+                clientMgr.removeClient(fooRealm, client);++                // Assert nothing loaded - userSession was removed as well because it was last userSession+                realmMgr = new RealmManager(currentSession);+                fooRealm = realmMgr.getRealm(""foo"");+                offlineSession = currentSession.sessions().getOfflineUserSession(fooRealm, userSession.getId());+                Assert.assertEquals(0, offlineSession.getAuthenticatedClientSessions().size());+            } catch (Exception e) {+                throw new RuntimeException(e);+            } finally {++                RealmManager realmMgr = new RealmManager(currentSession);+                RealmModel fooRealm = realmMgr.getRealm(""foo"");+                UserModel user3 = currentSession.users().getUserByUsername(""user3"", fooRealm);++                // Remove user3+                new UserManager(currentSession).removeUser(fooRealm, user3);++                // Cleanup+                realmMgr = new RealmManager(currentSession);+                realmMgr.removeRealm(realmMgr.getRealm(""foo""));+            }++        });+    }+++    @Test+    @ModelTest+    public void testOnUserRemoved(KeycloakSession session) {+        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionUR) -> {+            try {+                int started = Time.currentTime();++                RealmModel fooRealm = sessionUR.realms().createRealm(""foo"", ""foo"");+                fooRealm.addClient(""foo-app"");+                sessionUR.users().addUser(fooRealm, ""user3"");++                UserSessionModel userSession = sessionUR.sessions().createUserSession(fooRealm, sessionUR.users().getUserByUsername(""user3"", fooRealm), ""user3"", ""127.0.0.1"", ""form"", true, null, null);+                AuthenticatedClientSessionModel clientSession = createClientSession(sessionUR, fooRealm.getClientByClientId(""foo-app""), userSession, ""http://redirect"", ""state"");++                // Create offline session+                fooRealm = sessionUR.realms().getRealm(""foo"");+                userSession = sessionUR.sessions().getUserSession(fooRealm, userSession.getId());+                createOfflineSessionIncludeClientSessions(sessionUR, userSession);++                RealmManager realmMgr = new RealmManager(sessionUR);+                fooRealm = realmMgr.getRealm(""foo"");+                UserModel user3 = sessionUR.users().getUserByUsername(""user3"", fooRealm);++                // Assert session was persisted with both clientSessions+                UserSessionModel offlineSession = sessionUR.sessions().getOfflineUserSession(fooRealm, userSession.getId());+                assertSession(offlineSession, user3, ""127.0.0.1"", started, started, ""foo-app"");+++            } catch (Exception e) {+                throw new RuntimeException(e);+            } finally {++                RealmManager realmMgr = new RealmManager(sessionUR);+                RealmModel fooRealm = realmMgr.getRealm(""foo"");+                UserModel user3 = sessionUR.users().getUserByUsername(""user3"", fooRealm);++                // Remove user3+                new UserManager(sessionUR).removeUser(fooRealm, user3);++                // Cleanup+                realmMgr = new RealmManager(sessionUR);+                realmMgr.removeRealm(realmMgr.getRealm(""foo""));+            }+        });+    }++    @Test+    @ModelTest+    public void testExpired(KeycloakSession session) {","The ""testExpired"" test was updated in the master due some offlineSessions preloading work. Could you try to rebase and doublecheck that new bits added to the test in the meantime are reflected in the migrated test too?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5785,239394712,2018-12-06T10:11:06Z,testsuite/integration-arquillian/tests/pom.xml,"@@ -1693,6 +1697,20 @@             </properties>         </profile> +        <profile>+            <id>java11-auth-server</id> <!-- a temporary workaround; TODO remove this once Java 11 is officially supported by Arquillian -->",Wouldn't be possible to activate the profile automatically using```suggestion            <id>java11-auth-server</id> <!-- a temporary workaround; TODO remove this once Java 11 is officially supported by Arquillian -->            <activation>                <jdk>11</jdk>            </activation>```to avoid the need to select the profiles manually?,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5785,239396555,2018-12-06T10:16:48Z,testsuite/integration-arquillian/tests/pom.xml,"@@ -1693,6 +1697,20 @@             </properties>         </profile> +        <profile>+            <id>java11-auth-server</id> <!-- a temporary workaround; TODO remove this once Java 11 is officially supported by Arquillian -->","I'm not sure if is is 11 or e.g. 1.11, as far as I was able to find out it's derived from system property java.version [1][1] https://github.com/apache/maven/blob/maven-3.6.0/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java#L63",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/5785,239397001,2018-12-06T10:18:12Z,testsuite/integration-arquillian/tests/pom.xml,"@@ -1693,6 +1697,20 @@             </properties>         </profile> +        <profile>+            <id>java11-auth-server</id> <!-- a temporary workaround; TODO remove this once Java 11 is officially supported by Arquillian -->","As far as I know, It's not possible, unfortunately. At normal conditions, we don't run the tests as such (i.e. `mvn` command) under JDK 11, only the auth/app server is using that JDK. Or am I wrong?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/5594,240283689,2018-12-10T16:31:52Z,testsuite/integration-arquillian/test-apps/servlets/src/main/java/org/keycloak/testsuite/adapter/servlet/SamlSPFacade.java,"@@ -90,7 +90,7 @@ private void handler(HttpServletRequest req, HttpServletResponse resp) throws Se     */     private String getSamlRequest() {         if (System.getProperty(""auth.server.ssl.required"", ""false"").equals(""true"")) {-            return ""jVLbTgIxEP2Vpu9Ly3JZbFgSlBhJUDeAPvhianeQJt127XS9%2FL1lwWiiokkfms6ZOZfpGGVlajFtwtYu4akBDOS1MhZFW8hp461wEjUKKytAEZRYTS8XIu1wUXsXnHKG7luOgyUi%2BKCdpWT6cT1zFpsK%2FAr8s1Zws1zkdBtCjYIx45Q0W4dBjIb9HoOqNu4NgFEyiyK1lbsBP8IHES6jIeZBmgpZCZVjH1rZzhcl584raF3ndCMNAiXzWU7ns%2Ft%2BOYKBgjTJUj5M%2Bln6kMjRSZak5aiX8ROuOB9EMBbRkH6Gz3bEBuYWg7QhpynvDhLeS%2FhwnaYinm7WicLuKCkOQk61LbV9PB7awx6E4mK9LpLierWm5BY8ttYjgE7IeGdItOz%2By%2Br%2Bu4zJX3mP2ReCA10truLI%2BaxwRqs3MjXGvZzFtEOMI%2FgG2nwrGX4X0e102xddJpsWKhqLNSi90VBSFnnY9585eQc%3D"";+            return ""jVJLbxshEL5Xyn9A3Ndg%2FNgN8lpyYkW1lDYr2%2B2hl4qw4xiJhQ3Dus2%2FD17HSqqoaQUHBN%2FM9xhmqBrbykUX924Njx1gJL8b61D2DyXtgpNeoUHpVAMoo5abxZdbKQZctsFHr72lp5KPwQoRQjTeUbI4H6%2B9w66BsIFwMBq%2BrW9Luo%2BxlYxZr5Xde4yyEAVn0LTWPwEwSpZJo3HqWH9C45%2FwyXjEVPLDAijbIKuh8ewslR1tUXLjg4bedEl3yiJQslqWdLX8Oa4LmGgQWS74NBvn4j5TxWWeiboY5fySa84nCYxV8mMO8FqO2MHKYVQullTw4STjo4xPt0LItIf5IAn7QUn1IuTKuNq4h48zuz%2BBUH7ebqusuttsKfkOAXvrCUDnZHY0JHv28GZy%2FzuL%2BT%2FinrE3%2FV%2FYWvk1dVwtK2%2BNfiILa%2F2v6xR2TGnE0EEfb6Pi3zUMB8P%2BxtTZrofKzmEL2uwM1JQlHvb%2BX84vPh3XMw%3D%3D"";","During 7.3 testing I've discovered that this change broke `SAMLServletAdapterTest` when SSL is on for app server.Usually, we test with SSL on for both app and auth server (or off for both). So imho as a temporary workaround we should hardcode this for this scenario. Currently, this change works only with SSL on for auth server and off for app server (or off for both).",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5807,241033658,2018-12-12T14:26:55Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -655,19 +655,47 @@ public Response idpInitiatedSSO(@PathParam(""client"") String clientUrlName, @Quer             event.error(Errors.INVALID_CLIENT);             return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, ""Wrong client protocol."");         }-        if (client.getManagementUrl() == null && client.getAttribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_POST_ATTRIBUTE) == null && client.getAttribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_REDIRECT_ATTRIBUTE) == null) {+        String[] bindingProperties = getUrlAndBindingForIdpInitiatedSso(client);+        if (bindingProperties == null) {             logger.error(""SAML assertion consumer url not set up"");             event.error(Errors.INVALID_REDIRECT_URI);             return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REDIRECT_URI);         }          session.getContext().setClient(client); -        AuthenticationSessionModel authSession = getOrCreateLoginSessionForIdpInitiatedSso(this.session, this.realm, client, relayState);+        AuthenticationSessionModel authSession = getOrCreateLoginSessionForIdpInitiatedSso(+                this.session, this.realm, client, relayState, bindingProperties[0], bindingProperties[1]);          return newBrowserAuthentication(authSession, false, false);     } +    /**+     * Checks the client configuration to return the redirect URL and the binding type.+     * POST is preferred, only if the SAML_ASSERTION_CONSUMER_URL_POST_ATTRIBUTE+     * and management URL are empty REDIRECT is chosen.+     *+     * @param client Client to create client session for+     * @return a two string array [redirectUrl, bindingType] or null if error+     */+    private String[] getUrlAndBindingForIdpInitiatedSso(ClientModel client) {+        String redirectPost = client.getAttribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_POST_ATTRIBUTE);","Please rename to `aclPost` or similar, `redirect` has a different meaning in this context. (The same below for `redirectGet`)",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5807,241037090,2018-12-12T14:35:40Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/saml/IdpInitiatedLoginTest.java,"@@ -71,6 +69,70 @@ public void testIdpInitiatedLogin() {         ;     } +    @Test+    public void testIdpInitiatedLoginPostAdminUrl() {+        ClientRepresentation clientRep = adminClient.realm(REALM_NAME).clients().findByClientId(SAML_CLIENT_ID_SALES_POST).get(0);+        String url = clientRep.getAttributes().get(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_POST_ATTRIBUTE);+        adminClient.realm(REALM_NAME).clients().get(clientRep.getId())+                .update(ClientBuilder.edit(clientRep)+                        .adminUrl(url)+                        .attribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_POST_ATTRIBUTE, null)+                        .attribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_REDIRECT_ATTRIBUTE, null)+                        .build());+        try {","replace the lines 74-82 with```java        try (Closeable c = ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_SALES_POST)          .setAdminUrl(url)          .setAttribute(SamlConfigAttributes.SAML_ASSERTION_CONSUMER_URL_POST_ATTRIBUTE, null)          .setAttribute(SamlConfigAttributes.SAML_ASSERTION_CONSUMER_URL_REDIRECT_ATTRIBUTE, null)          .update()) {```(add `ClientAttributeUpdater.setAdminUrl` method similarly to other ones in `ClientAttributeUpdater` class)Then you can remove the `finally` part.",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/5807,241086385,2018-12-12T16:28:30Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -680,26 +708,33 @@ public Response idpInitiatedSSO(@PathParam(""client"") String clientUrlName, @Quer      * @return      */     public AuthenticationSessionModel getOrCreateLoginSessionForIdpInitiatedSso(KeycloakSession session, RealmModel realm, ClientModel client, String relayState) {-        String bindingType = SamlProtocol.SAML_POST_BINDING;-        if (client.getManagementUrl() == null && client.getAttribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_POST_ATTRIBUTE) == null && client.getAttribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_REDIRECT_ATTRIBUTE) != null) {-            bindingType = SamlProtocol.SAML_REDIRECT_BINDING;-        }--        String redirect;-        if (bindingType.equals(SamlProtocol.SAML_REDIRECT_BINDING)) {-            redirect = client.getAttribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_REDIRECT_ATTRIBUTE);-        } else {-            redirect = client.getAttribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_POST_ATTRIBUTE);-        }-        if (redirect == null) {-            redirect = client.getManagementUrl();+        String[] bindingProperties = getUrlAndBindingForIdpInitiatedSso(client);+        if (bindingProperties == null) {+            throw new RuntimeException(""SAML assertion consumer url not set up"");","I didn't want to modify something that affected the other class. Previously I suppose it got some type of error (because the logic to get the URLs were the same but defaulted to ""adminUrl"" that can be null or empty anyway). Now the method return null and both methods check the result and return an error if no auth session is returned. But check this because I don't know very well what IdentityBrokerService is doing.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5820,244730294,2019-01-02T13:02:02Z,services/src/main/java/org/keycloak/protocol/AuthorizationEndpointBase.java,"@@ -161,7 +162,7 @@ protected void checkRealm() {         }     } -    protected AuthenticationSessionModel createAuthenticationSession(ClientModel client, String requestState) {+    protected AuthenticationSessionModel createAuthenticationSession(ClientModel client, String relayState) {","This change is not necessary, please keep the original name. The parameter is not SAML-specific, the method is called from OIDC and Docker auth protocol implementations as well.Actually, you can override this method in SamlService to move the [setting RELAY_STATE into the session](https://github.com/keycloak/keycloak/blob/4.8.3.Final/services/src/main/java/org/keycloak/protocol/saml/SamlService.java#L724-L729) there (with your updates in SamlService)",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5795,246670020,2019-01-10T08:32:23Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/OAuthClient.java,"@@ -725,7 +725,7 @@ public URI getCurrentUri() {      public Map<String, String> getCurrentQuery() {         Map<String, String> m = new HashMap<>();-        List<NameValuePair> pairs = URLEncodedUtils.parse(getCurrentUri(), Charset.forName(""UTF-8""));+        List<NameValuePair> pairs = URLEncodedUtils.parse(getCurrentUri(), ""UTF-8"");","There is only `public static List <NameValuePair> parse(final URI uri, final String charset)` in [httpclient-4.5.2.Final URLEncodedUtils](https://github.com/apache/httpcomponents-client/blob/4.5.2/httpclient/src/main/java/org/apache/http/client/utils/URLEncodedUtils.java#L90) so it seems we are not able to prevent repeating looups for now. I can replace with `StandardCharsets.UTF_8.name()` if your prefer it.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5850,248218050,2019-01-16T10:02:44Z,testsuite/integration-arquillian/util/src/main/java/org/keycloak/testsuite/utils/io/IOUtil.java,"@@ -184,7 +184,10 @@ public static void modifyDocElementValue(Document doc, String tagName, String re             return;         } -        node.setTextContent(node.getTextContent().replaceFirst(regex, replacement));+        if (node.getTextContent().contains(regex)) {","This changes semantics. `contains` uses direct comparison, `replaceFirst` uses regexps. Please stick to the regexps, they are richer in expressiveness.Feel free to use `"".*infinispan\\.InfinispanSessionCacheIdMapperUpdater""` instead of `""wildfly.infinispan.InfinispanSessionCacheIdMapperUpdater""` on L64",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5594,250569755,2019-01-24T11:37:32Z,integration/admin-client/src/main/java/org/keycloak/admin/client/Keycloak.java,"@@ -81,6 +83,16 @@ public static Keycloak getInstance(String serverUrl, String realm, String userna         return new Keycloak(serverUrl, realm, username, password, clientId, clientSecret, PASSWORD, clientBuilder.build(), null);     } +    protected static ResteasyClient newSSLAwareRestEasyClient(boolean disableTrustManager) {+        ResteasyClientBuilder builder = new ResteasyClientBuilder();+        if (disableTrustManager) {+            // Disable PKIX path validation errors when running tests using SSL+            HostnameVerifier hostnameVerifier = (hostName, session) -> true;","Isn't this the same as `hostnameVerification(ResteasyClientBuilder.HostnameVerificationPolicy.WILDCARD)` ? This class is also building client instances from `getInstance`, I'm wondering if is not the case to consolidate creation of client instances using this new method that you added. Besides, it seems you have removed the connection pool setting, which is still being defined in the `getInstance` method.",X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5594,250577284,2019-01-24T12:00:57Z,integration/client-cli/client-registration-cli/src/main/java/org/keycloak/client/registration/cli/util/HttpUtil.java,"@@ -185,4 +189,22 @@ public static void setTruststore(File file, String password) throws CertificateE                 .build();         sslsf = new SSLConnectionSocketFactory(theContext);     }++    public static void setSkipCertificateValidation() {","If my comments to the other `HttpUtil` class are valid, they also apply here.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5594,250912094,2019-01-25T09:14:03Z,testsuite/integration-arquillian/test-apps/cors/angular-product/src/main/webapp/keycloak.json,"@@ -1,8 +1,9 @@ {   ""realm"" : ""cors"",   ""realm-public-key"" : ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",-  ""auth-server-url"" : ""http://localhost-auth:8180/auth"",+  ""auth-server-url"" : ""https://localhost-auth:8543/auth"",",I believe this should be rather done by the deployment processor instead of Maven static build. See https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/DeploymentArchiveProcessor.java#L170-L183,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5811,250934919,2019-01-25T10:24:09Z,saml-core-api/src/main/java/org/keycloak/saml/common/constants/JBossSAMLConstants.java,"@@ -55,6 +55,7 @@     RESPONSE__PROTOCOL(PROTOCOL_NSURI, ""Response""),     SCOPING(PROTOCOL_NSURI, ""Scoping""),     SESSION_INDEX(PROTOCOL_NSURI, ""SessionIndex""),+    SESSION_NOT_ON_OR_AFTER(PROTOCOL_NSURI, ""SessionNotOnOrAfter""),",Please move this constant to `org.keycloak.saml.processing.core.parsers.saml.assertion.SAMLAssertionQNames` as an `ATTR_SESSION_NOT_ON_OR_AFTER` constant similarly to other `ATTR_*` constants declared there. `JBossSAMLConstants` is eventually going to be removed.,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5594,250950766,2019-01-25T11:19:05Z,testsuite/integration-arquillian/test-apps/cors/angular-product/src/main/webapp/keycloak.json,"@@ -1,8 +1,9 @@ {   ""realm"" : ""cors"",   ""realm-public-key"" : ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"",-  ""auth-server-url"" : ""http://localhost-auth:8180/auth"",+  ""auth-server-url"" : ""https://localhost-auth:8543/auth"",",I don't have much knowledge about the testing of adapters at all. This is probably a conversation for the team mailing list.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5860,251732689,2019-01-29T08:32:28Z,testsuite/integration-arquillian/pom.xml,"@@ -320,6 +320,157 @@                 </pluginManagement>             </build>         </profile>+        <profile>+            <id>mysql</id>+            <properties>+                <keycloak.connectionsJpa.database>keycloak</keycloak.connectionsJpa.database>+                <keycloak.connectionsJpa.user>keycloak</keycloak.connectionsJpa.user>+                <keycloak.connectionsJpa.password>keycloak</keycloak.connectionsJpa.password>+                <keycloak.connectionsJpa.url>jdbc:mysql://${auth.server.db.host}/${keycloak.connectionsJpa.database}</keycloak.connectionsJpa.url>+                <jdbc.mvn.groupId>mysql</jdbc.mvn.groupId>+                <jdbc.mvn.artifactId>mysql-connector-java</jdbc.mvn.artifactId>+                <jdbc.mvn.version>5.1.29</jdbc.mvn.version>+                <docker.database.image>mysql:5.7.25</docker.database.image>+            </properties>+            <build>+                <pluginManagement>","The plugins should be part of the generic flow, just plugin execution would be conditioned on existence of `docker.database.image`. The only issue is that the various containers need their specific env variables, e.g.  MYSQL_DATABASE, POSTGRES_DB - and all of those can be specified for `start-container` execution (rather renamed to `start-db-container` to allow other container types like LDAP to be handled similarly).The profiles `db-postgres`, `db-mysql` would only define the `docker.database.image` and `jdbc.mvn.*` properties.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5860,251735325,2019-01-29T08:41:46Z,testsuite/integration-arquillian/tests/pom.xml,"@@ -1201,41 +1201,6 @@             </build>         </profile> -",Do not remove this part. This is useful for non-docker databases.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5860,251793910,2019-01-29T11:28:15Z,testsuite/integration-arquillian/pom.xml,"@@ -320,6 +320,157 @@                 </pluginManagement>             </build>         </profile>+        <profile>+            <id>mysql</id>+            <properties>+                <keycloak.connectionsJpa.database>keycloak</keycloak.connectionsJpa.database>+                <keycloak.connectionsJpa.user>keycloak</keycloak.connectionsJpa.user>+                <keycloak.connectionsJpa.password>keycloak</keycloak.connectionsJpa.password>+                <keycloak.connectionsJpa.url>jdbc:mysql://${auth.server.db.host}/${keycloak.connectionsJpa.database}</keycloak.connectionsJpa.url>+                <jdbc.mvn.groupId>mysql</jdbc.mvn.groupId>+                <jdbc.mvn.artifactId>mysql-connector-java</jdbc.mvn.artifactId>+                <jdbc.mvn.version>5.1.29</jdbc.mvn.version>",This is the JDBC driver version. These are defaults that can be overridden by passing their respective system property during the build. The same goes for the actual server version which is related with the `docker.database.image` property.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5860,251800341,2019-01-29T11:50:28Z,testsuite/integration-arquillian/pom.xml,"@@ -320,6 +320,157 @@                 </pluginManagement>             </build>         </profile>+        <profile>+            <id>mysql</id>+            <properties>+                <keycloak.connectionsJpa.database>keycloak</keycloak.connectionsJpa.database>+                <keycloak.connectionsJpa.user>keycloak</keycloak.connectionsJpa.user>+                <keycloak.connectionsJpa.password>keycloak</keycloak.connectionsJpa.password>+                <keycloak.connectionsJpa.url>jdbc:mysql://${auth.server.db.host}/${keycloak.connectionsJpa.database}</keycloak.connectionsJpa.url>+                <jdbc.mvn.groupId>mysql</jdbc.mvn.groupId>+                <jdbc.mvn.artifactId>mysql-connector-java</jdbc.mvn.artifactId>+                <jdbc.mvn.version>5.1.29</jdbc.mvn.version>","We have the same intention :) ${mysql.version} is already available (same for postgres), and I agree the name is unfortunate but it's already there: see e.g.https://github.com/keycloak/keycloak/blob/master/pom.xml#L112https://github.com/keycloak/keycloak/blob/master/testsuite/jetty/jetty93/pom.xml#L346",X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/5860,251811627,2019-01-29T12:28:35Z,testsuite/integration-arquillian/pom.xml,"@@ -320,6 +320,157 @@                 </pluginManagement>             </build>         </profile>+        <profile>+            <id>mysql</id>+            <properties>+                <keycloak.connectionsJpa.database>keycloak</keycloak.connectionsJpa.database>+                <keycloak.connectionsJpa.user>keycloak</keycloak.connectionsJpa.user>+                <keycloak.connectionsJpa.password>keycloak</keycloak.connectionsJpa.password>+                <keycloak.connectionsJpa.url>jdbc:mysql://${auth.server.db.host}/${keycloak.connectionsJpa.database}</keycloak.connectionsJpa.url>+                <jdbc.mvn.groupId>mysql</jdbc.mvn.groupId>+                <jdbc.mvn.artifactId>mysql-connector-java</jdbc.mvn.artifactId>+                <jdbc.mvn.version>5.1.29</jdbc.mvn.version>+                <docker.database.image>mysql:5.7.25</docker.database.image>+            </properties>+            <build>+                <pluginManagement>+                    <plugins>+                        <plugin>+                            <artifactId>maven-surefire-plugin</artifactId>+                            <configuration>+                                <systemPropertyVariables>+                                    <auth.server.db.host>${docker.container.testdb.ip}</auth.server.db.host>+                                </systemPropertyVariables>+                            </configuration>+                        </plugin>+                        <plugin>+                            <groupId>io.fabric8</groupId>+                            <artifactId>docker-maven-plugin</artifactId>+                            <version>0.28.0</version>+                            <executions>+                                <execution>+                                    <id>start-container</id>+                                    <phase>process-test-classes</phase>+                                    <goals>+                                        <goal>start</goal>+                                    </goals>+                                    <configuration>+                                        <showLogs>true</showLogs>+                                        <images>+                                            <image>+                                                <alias>testdb</alias>+                                                <name>${docker.database.image}</name>+                                                <run>+                                                    <ports>+                                                        <port>3306</port>+                                                    </ports>+                                                    <env>+                                                        <MYSQL_DATABASE>${keycloak.connectionsJpa.database}</MYSQL_DATABASE>+                                                        <MYSQL_USER>${keycloak.connectionsJpa.user}</MYSQL_USER>+                                                        <MYSQL_PASSWORD>${keycloak.connectionsJpa.password}</MYSQL_PASSWORD>+                                                        <MYSQL_RANDOM_ROOT_PASSWORD>true</MYSQL_RANDOM_ROOT_PASSWORD>+                                                    </env>+                                                    <wait>+                                                        <tcp>+                                                            <ports>+                                                                <port>3306</port>+                                                            </ports>+                                                        </tcp>+                                                        <time>30000</time>+                                                    </wait>+                                                </run>+                                            </image>+                                        </images>+                                    </configuration>+                                </execution>+                                <execution>+                                    <id>stop-container</id>+                                    <phase>post-integration-test</phase>+                                    <goals>+                                        <goal>stop</goal>+                                    </goals>+                                </execution>+                            </executions>+                        </plugin>+                    </plugins>+                </pluginManagement>+            </build>+        </profile>+        <profile>",I'm trying to get in whatever database we support in our docker image. Do you think we can leave that as a separated task and add support later for these two databases ?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5860,251822123,2019-01-29T13:02:31Z,testsuite/integration-arquillian/pom.xml,"@@ -320,6 +320,157 @@                 </pluginManagement>             </build>         </profile>+        <profile>+            <id>mysql</id>+            <properties>+                <keycloak.connectionsJpa.database>keycloak</keycloak.connectionsJpa.database>+                <keycloak.connectionsJpa.user>keycloak</keycloak.connectionsJpa.user>+                <keycloak.connectionsJpa.password>keycloak</keycloak.connectionsJpa.password>+                <keycloak.connectionsJpa.url>jdbc:mysql://${auth.server.db.host}/${keycloak.connectionsJpa.database}</keycloak.connectionsJpa.url>+                <jdbc.mvn.groupId>mysql</jdbc.mvn.groupId>+                <jdbc.mvn.artifactId>mysql-connector-java</jdbc.mvn.artifactId>+                <jdbc.mvn.version>5.1.29</jdbc.mvn.version>+                <docker.database.image>mysql:5.7.25</docker.database.image>+            </properties>+            <build>+                <pluginManagement>+                    <plugins>+                        <plugin>+                            <artifactId>maven-surefire-plugin</artifactId>+                            <configuration>+                                <systemPropertyVariables>+                                    <auth.server.db.host>${docker.container.testdb.ip}</auth.server.db.host>+                                </systemPropertyVariables>+                            </configuration>+                        </plugin>+                        <plugin>+                            <groupId>io.fabric8</groupId>+                            <artifactId>docker-maven-plugin</artifactId>+                            <version>0.28.0</version>+                            <executions>+                                <execution>+                                    <id>start-container</id>+                                    <phase>process-test-classes</phase>+                                    <goals>+                                        <goal>start</goal>+                                    </goals>+                                    <configuration>+                                        <showLogs>true</showLogs>+                                        <images>+                                            <image>+                                                <alias>testdb</alias>+                                                <name>${docker.database.image}</name>+                                                <run>+                                                    <ports>+                                                        <port>3306</port>+                                                    </ports>+                                                    <env>+                                                        <MYSQL_DATABASE>${keycloak.connectionsJpa.database}</MYSQL_DATABASE>+                                                        <MYSQL_USER>${keycloak.connectionsJpa.user}</MYSQL_USER>+                                                        <MYSQL_PASSWORD>${keycloak.connectionsJpa.password}</MYSQL_PASSWORD>+                                                        <MYSQL_RANDOM_ROOT_PASSWORD>true</MYSQL_RANDOM_ROOT_PASSWORD>+                                                    </env>+                                                    <wait>+                                                        <tcp>+                                                            <ports>+                                                                <port>3306</port>+                                                            </ports>+                                                        </tcp>+                                                        <time>30000</time>+                                                    </wait>+                                                </run>+                                            </image>+                                        </images>+                                    </configuration>+                                </execution>+                                <execution>+                                    <id>stop-container</id>+                                    <phase>post-integration-test</phase>+                                    <goals>+                                        <goal>stop</goal>+                                    </goals>+                                </execution>+                            </executions>+                        </plugin>+                    </plugins>+                </pluginManagement>+            </build>+        </profile>+        <profile>","If this PR would be ready in terms that the definition of a new database would be matter of creating a profile which would only consist of properties definition (`docker.database.image` alike) and adding env variables to docker run part, then yes, it can be done as a follow-up task.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/5870,253446153,2019-02-04T12:14:03Z,testsuite/integration-arquillian/tests/base/src/test/resources/arquillian.xml,"@@ -36,13 +36,19 @@         <property name=""firefoxBinary"">${firefox_binary}</property> <!-- we need to use 'firefoxBinary' instead of 'firefox_binary' due to some weird conflict with Appium -->         <property name=""firefoxLogLevel"">OFF</property>         <property name=""firefoxLegacy"">${firefoxLegacyDriver}</property>+        <property name=""firefoxDriverBinary"">${firefoxDriverBinary}</property>","Why to add another properties for path to driver binary? Drone has already some built-in ones, see https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/HOW-TO-RUN.md#automatic-driver-downloads",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/5594,254238718,2019-02-06T11:47:06Z,testsuite/integration-arquillian/HOW-TO-RUN.md,"@@ -475,38 +480,17 @@ To use a mobile browser you need to create a virtual device. The most convenient * **Supported mobile OS version:** iOS 11.x * **Run with:** `mvn clean test -Pios -Dappium.deviceName=device_name` where the device name is your device identification (e.g. `iPhone X`) -## Run X.509 tests","Ok, in this case I'm for removing:https://github.com/keycloak/keycloak/blob/08a3f85e6da57de15945c0ae5aa7c9bf72d45206/testsuite/integration-arquillian/tests/base/pom.xml#L45This is what makes the X.509 tests disabled no matter what. ;)",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5594,254590018,2019-02-07T08:53:36Z,testsuite/integration-arquillian/HOW-TO-RUN.md,"@@ -475,38 +480,17 @@ To use a mobile browser you need to create a virtual device. The most convenient * **Supported mobile OS version:** iOS 11.x * **Run with:** `mvn clean test -Pios -Dappium.deviceName=device_name` where the device name is your device identification (e.g. `iPhone X`) -## Run X.509 tests","It seems those tests are broken. Did we ever execute them (apart from manual execution)? They also seem to be disabled from executing SSL in Travis: https://github.com/keycloak/keycloak/blob/master/travis-run-tests.sh#L108 If the answer is `no`, perhaps we could implement it in a separate JIRA?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5880,257658247,2019-02-18T11:32:10Z,testsuite/integration-arquillian/servers/app-server/tomcat/tomcat7/src/main/java/org/keycloak/testsuite/arquillian/tomcat/Tomcat7AppServerArquillianExtension.java,"@@ -0,0 +1,34 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.arquillian.tomcat;++import org.jboss.arquillian.container.test.spi.client.deployment.ApplicationArchiveProcessor;+import org.jboss.arquillian.core.spi.LoadableExtension;+import org.keycloak.testsuite.arquillian.tomcat.container.Tomcat7DeploymentArchiveProcessor;++/**+ *+ * @author <a href=""mailto:vramik@redhat.com"">Vlasta Ramik</a>",nit: wrong author? The same for others copied classes.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5880,257660939,2019-02-18T11:40:20Z,testsuite/integration-arquillian/util/src/main/java/org/keycloak/testsuite/utils/arquillian/tomcat/TomcatAppServerConfigurationUtils.java,"@@ -0,0 +1,49 @@+package org.keycloak.testsuite.utils.arquillian.tomcat;++import org.jboss.shrinkwrap.descriptor.spi.node.Node;++/**+ * @author mhajas+ */+public class TomcatAppServerConfigurationUtils {++    private static void createChild(Node configuration, String name, String text) {+        configuration.createChild(""property"").attribute(""name"", name).text(text);+    }++    /**+     * Original XSL transformation+     * <p>+     * <container qualifier=""app-server-${{app.server}}"" mode=""manual"" >+     * <configuration>+     * <property name=""enabled"">true</property>+     * <property name=""adapterImplClass"">org.jboss.arquillian.container.tomcat.managed_7.TomcatManagedContainer</property>+     * <property name=""catalinaHome"">${app.server.home}</property>+     * <property name=""catalinaBase"">${app.server.home}</property>+     * <property name=""bindHttpPort"">${app.server.http.port}</property>+     * <property name=""jmxPort"">${app.server.management.port}</property>+     * <property name=""user"">manager</property>+     * <property name=""pass"">arquillian</property>+     * <property name=""javaVmArguments"">${adapter.test.props}</property>+     * </configuration>+     * </container>+     *+     * @return arquillian configuration for tomcat container+     */+    public static Node getStandaloneConfiguration(Node container, String adapterImplClass,+                                             String catalinaHome, String bindHttpPort, String jmxPort,+                                             String user, String pass) {+        Node configuration = container.createChild(""configuration"");+        createChild(configuration, ""enabled"", ""true"");+        createChild(configuration, ""adapterImplClass"", adapterImplClass);+        createChild(configuration, ""catalinaHome"", catalinaHome);+        createChild(configuration, ""catalinaBase"", catalinaHome);+        createChild(configuration, ""bindHttpPort"", bindHttpPort);+        createChild(configuration, ""jmxPort"", jmxPort);+        createChild(configuration, ""user"", user);+        createChild(configuration, ""pass"", pass);+        createChild(configuration, ""javaVmArguments"", System.getProperty(""adapter.test.props"", "" ""));+","Shouldn't be there also ""startupTimeoutInSeconds"" parameter?",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5885,257982012,2019-02-19T10:38:48Z,testsuite/integration-arquillian/servers/app-server/jetty/pom.xml,"@@ -0,0 +1,37 @@+<?xml version=""1.0""?>+<!--+~ Copyright 2018 Red Hat, Inc. and/or its affiliates+~ and other contributors as indicated by the @author tags.+~+<?xml version=""1.0""?>+~ http://www.apache.org/licenses/LICENSE-2.0+~+~ Unless required by applicable law or agreed to in writing, software+~ distributed under the License is distributed on an ""AS IS"" BASIS,+~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+~ See the License for the specific language governing permissions and+~ limitations under the License.+-->++<project xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"" xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>integration-arquillian-servers-app-server</artifactId>+        <version>4.8.3.Final-SNAPSHOT</version>+    </parent>++    <modelVersion>4.0.0</modelVersion>++    <artifactId>integration-arquillian-servers-app-server-jetty</artifactId>+    <packaging>pom</packaging>++    <modules>+        <module>common</module>+        <module>81</module>+        <module>94</module>","I think we should include the modules in profile definition, it would otherwise build all jetty app servers each time the testsuite is built. Check https://github.com/keycloak/keycloak/blob/22e160136c37d73b05b7f4d77de5a2d1fcb7cef5/testsuite/integration-arquillian/servers/app-server/jboss/pom.xml#L710-L785",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5880,257986636,2019-02-19T10:51:50Z,testsuite/integration-arquillian/servers/app-server/tomcat/tomcat9/pom.xml,"@@ -26,19 +26,37 @@     <modelVersion>4.0.0</modelVersion>      <artifactId>integration-arquillian-servers-app-server-tomcat9</artifactId>-    <packaging>pom</packaging>+    <packaging>jar</packaging>     <name>App Server - Tomcat - Tomcat 9</name>      <properties>         <app.server.tomcat>tomcat9</app.server.tomcat>-        +         <app.server.tomcat.groupId>org.apache.tomcat</app.server.tomcat.groupId>         <app.server.tomcat.artifactId>tomcat</app.server.tomcat.artifactId>         <app.server.tomcat.version>${tomcat9.version}</app.server.tomcat.version>         <app.server.tomcat.unpacked.folder.name>apache-tomcat-${tomcat9.version}</app.server.tomcat.unpacked.folder.name>-        +         <app.server.oidc.adapter.artifactId>keycloak-tomcat8-adapter-dist</app.server.oidc.adapter.artifactId>         <app.server.saml.adapter.artifactId>keycloak-saml-tomcat8-adapter-dist</app.server.saml.adapter.artifactId>     </properties> +    <dependencies>+        <dependency>+            <groupId>org.keycloak.testsuite</groupId>+            <artifactId>integration-arquillian-servers-app-server-spi</artifactId>+            <version>${project.version}</version>+        </dependency>+        <dependency>+            <groupId>org.jboss.arquillian.container</groupId>+            <artifactId>arquillian-tomcat-managed-7</artifactId>","It looks like this artifact contains only some common classes for all versions of tomcat containers. However, there is no managed container for Tomcat 9 yet. I used the container for Tomcat 8, but we should upgrade for Tomcat 9 once it is released.  ",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5885,258391195,2019-02-20T09:14:39Z,testsuite/integration-arquillian/servers/app-server/jetty/81/src/test/java/org/keycloak/testsuite/arquillian/jetty/Jetty81AppServerTest.java,"@@ -0,0 +1,5 @@+package org.keycloak.testsuite.arquillian.jetty;++public class Jetty81AppServerTest extends AbstractJettyAppServerTest {","Yes, I accidentally broke it just before the push. Yesterday I spoke with @hmlnarik that we won't migrate 8.1 version to the new testsuite (due to [KEYCLOAK-8356](https://issues.jboss.org/browse/KEYCLOAK-8356)). I will remove this part shortly.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5879,258406756,2019-02-20T09:54:38Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/PermissionsTest.java,"@@ -295,12 +295,12 @@ public void invoke(RealmResource realm) {         }, Resource.REALM, false, true);         assertGettersEmpty(clients.get(AdminRoles.QUERY_REALMS).realm(REALM_NAME).toRepresentation()); -        // this should throw forbidden as ""query-users"" role isn't enough+        // this should pass given that users granted with ""query"" roles are allowed to access the realm with limited access         invoke(new Invocation() {             public void invoke(RealmResource realm) {                 clients.get(AdminRoles.QUERY_USERS).realm(REALM_NAME).toRepresentation();             }-        }, clients.get(AdminRoles.QUERY_USERS), false);+        }, clients.get(AdminRoles.QUERY_USERS), true);","I think we need similar test for each of query-* role. Something like this:````for (String role : AdminRoles.ALL_QUERY_ROLES) {    invoke(realm -> clients.get(role).realms().realm(REALM_NAME).toRepresentation(), clients.get(role), true);}````",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5885,258517997,2019-02-20T14:54:59Z,testsuite/integration-arquillian/tests/base/pom.xml,"@@ -416,6 +416,65 @@                 </plugins>             </build>         </profile>++        <profile>+            <id>app-server-jetty81</id>+            <activation>+                <property>+                    <name>app.server</name>+                    <value>jetty</value>","APP_SERVER_ annotations should correspond to available app server modules, i.e. should differentiate between the version. APP_SERVER_JETTY81, APP_SERVER_JETTY92, APP_SERVER_JETTY93, APP_SERVER_JETTY94. Cf. [APP_SERVER_WILDFLY](https://github.com/keycloak/keycloak/blob/24b7d080af6ea554e346aa4ab770f00450696e4d/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/containers/ContainerConstants.java#L24) and [APP_SERVER_WILDFLY_DEPRECATED](https://github.com/keycloak/keycloak/blob/24b7d080af6ea554e346aa4ab770f00450696e4d/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/containers/ContainerConstants.java#L25):",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5886,258668816,2019-02-20T20:47:02Z,CONTRIBUTING.md,"@@ -0,0 +1,99 @@+# Keycloak Community++Keycloak is an Open Source Identity and Access Management solution for modern Applications and Services.++## Building and working with the codebase++Details for building from source and working with the codebase are provided in the [building and working with the code base](docs/building.md) guide.++## Contributing to Keycloak++Keycloak is an Open Source community-driven project and we welcome contributions as well as feedback from the community.++We do have a few guidelines in place to help you be successful with your contribution to Keycloak.++Here's a quick checklist for a good PR, more details below:++1. [Keycloak Dev Mailing List](https://lists.jboss.org/mailman/listinfo/keycloak-dev)+2. A JIRA associated with the PR+3. One feature/change per PR+4. One commit per PR+5. PR rebased on master (`git rebase`, not `git pull`) +5. Commit message includes JIRA number+6. No changes to code not directly related to your PR+7. Includes functional/integration test+8. Includes documentation++Once you have submitted your PR please monitor it for comments/feedback. We reserve the right to close inactive PRs if+you do not respond within 2 weeks (bear in mind you can always open a new PR if it is closed due to inactivity).++Also, please remember that we do receive a fairly large amount of PRs and also have code to write ourselves, so we may+not be able to respond to your PR immediately. The best place to ping us is on the thread you started on the dev mailing list.++### Finding something to work on++If you would like to contribute to Keycloak, but are not sure exactly what to work on, you can find a number of [open+issues|https://issues.jboss.org/projects/KEYCLOAK/versions/12340167] that are awaiting contributions in the +[Keycloak JIRA](https://issues.jboss.org/projects/KEYCLOAK/versions/12340167).++### Open a discussion on Keycloak Dev Mailing List++As Keycloak is a community-driven project we require contributors to send a description of what they are planning to +work on to the [Keycloak Dev Mailing List](https://lists.jboss.org/mailman/listinfo/keycloak-dev).++We recommending starting the discussion prior to submitting your PR. Through the mailing list you can get valuable",```suggestionWe recommend starting the discussion prior to submitting your PR. Through the mailing list you can get valuable```,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5885,258937119,2019-02-21T13:57:58Z,testsuite/integration-arquillian/servers/app-server/jetty/pom.xml,"@@ -0,0 +1,37 @@+<?xml version=""1.0""?>+<!--+~ Copyright 2018 Red Hat, Inc. and/or its affiliates+~ and other contributors as indicated by the @author tags.+~+<?xml version=""1.0""?>+~ http://www.apache.org/licenses/LICENSE-2.0+~+~ Unless required by applicable law or agreed to in writing, software+~ distributed under the License is distributed on an ""AS IS"" BASIS,+~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+~ See the License for the specific language governing permissions and+~ limitations under the License.+-->++<project xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"" xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>integration-arquillian-servers-app-server</artifactId>+        <version>4.8.3.Final-SNAPSHOT</version>+    </parent>++    <modelVersion>4.0.0</modelVersion>++    <artifactId>integration-arquillian-servers-app-server-jetty</artifactId>+    <packaging>pom</packaging>++    <modules>+        <module>common</module>+        <module>81</module>+        <module>94</module>",But have you tested it without the dependencies downloaded to your local maven repo? I know the server is not that big as a wildfly but still.,
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5885,259787738,2019-02-25T11:43:46Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/AdapterTestExecutionDecider.java,"@@ -35,42 +35,34 @@ public class AdapterTestExecutionDecider implements TestExecutionDecider {","This change is fun... hold on tight!The cache in this method doesn't work properly in a situation we have in this PR, such as `DemoServletsAdapterTest` runs on several app servers, whereas `JettyDemoServletsAdapterTest` runs on a single server which is not mentioned in `DemoServletsAdapterTest`. If `DemoServletsAdapterTest` is executed first, it caches, which methods should run. Let's assume we test with Undertow app server, so the result is `true` for all methods. Next, we execute `JettyDemoServletsAdapterTest` again with Undertow app server. Since, this class is for Jetty, the testsuite shouldn't execute any of these methods (remember, we assumed app server is Undertow). However it tries to do that...Let me explain why...The `Method#equals` method uses declaring class (and parameters) to do equality check. Note that the declaring (!!!) method is still the same for both classes - it's `DemoServletsAdapterTest`. This is why it reuses cached entry from `DemoServletsAdapterTest` run instead of re-evaluating whether the test should run or not. Also note, that this caching may introduce more damage that we are not aware of. There are some methods that possible were not executed in our testsuite (or were executed but shouldn't, but if they passed, that's fine). It all depends on the order that Surefire picks.I decided to remove the cache altogether. What we do in this method is checking a bunch of `if` statements plus traversing test class hierarchy. Both things are blazing fast on modern JVM and CPUs.",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5885,259827126,2019-02-25T13:42:47Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/AdapterTestExecutionDecider.java,"@@ -35,42 +35,34 @@ public class AdapterTestExecutionDecider implements TestExecutionDecider {","Yes, that's the case. The tricky part is that by default we executed with app server Undertow. However, `JettyDemoServletsAdapterTest` doesn't support it. That's why this tests shouldn't be executed but Surefire was trying to run it. I believe we didn't have similar situation before (Undertow is supported by all the adapters, Jetty is a bit special one).Yes, I also checked the logs. They look fine. Thanks a lot for the comment!",X
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/5885,261115437,2019-02-28T09:45:33Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/javascript/JavascriptAdapterTest.java,"@@ -52,9 +54,12 @@ import static org.keycloak.testsuite.util.WaitUtils.waitForPageToLoad; import static org.keycloak.testsuite.util.WaitUtils.waitUntilElement; -/**- * @author mhajas- */+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY)+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY_DEPRECATED)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP6)+@AppServerContainer(ContainerConstants.APP_SERVER_UNDERTOW)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP71)","Do you have some reason why you are adding those annotations? As far as I know, Javascript Tests are not actually running on application container. Instead of that, it runs within the auth server, and it is deployed as part of testsuite-providers [1]. Therefore those annotations should be unnecessary as it should be ok to run those in all cases.[1] https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/rest/resource/TestJavascriptResource.java",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5885,261173153,2019-02-28T12:30:15Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/javascript/JavascriptAdapterTest.java,"@@ -52,9 +54,12 @@ import static org.keycloak.testsuite.util.WaitUtils.waitForPageToLoad; import static org.keycloak.testsuite.util.WaitUtils.waitUntilElement; -/**- * @author mhajas- */+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY)+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY_DEPRECATED)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP6)+@AppServerContainer(ContainerConstants.APP_SERVER_UNDERTOW)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP71)","This change has been specifically introduced for my Pull Request against the pipeline. Please have a quick glance at the before reading below.Before this change, the Javascript adapter tests were invoked with each App Server. This was absolutely fine, since we tested only Wildfly App Server in the pipeline. However, with matrix-like approach to the adapter tests (we execute the adapter tests with different App Servers such as Wildfly, Jetty 9.2, Jetty 9.3 etc) this becomes wasteful (especially in terms of testing time). While working on this, I wasn't sure with what App Servers combinations we want to run Javascript adapter tests. I only knew, they don't make sense (and probably nobody expects them to run) with Jetty. That's why there are all App Servers on the list except the new one - Jetty. With your explanation, I think we can enhance this solution a bit more. Perhaps Javascript Adapter test should only run with the default App Server (Undertow). However, we would also need to add Undertow to the pipeline. If you agree with me, I would like to create a JIRA for it. We are approaching to the end of the sprint and my Pull Request against the pipeline hasn't been reviewed so far, so it's a bit risky to do this change now.Alternatively, if you don't like this approach, I can remove all the annotations and allow this test to execute always. But as I mentioned before, it seems a bit wasteful to me.",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5930,263714054,2019-03-08T09:26:21Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/x509/X509BrowserLoginSubjectAltNameEmailTest.java,"@@ -38,14 +42,26 @@ public class X509BrowserLoginSubjectAltNameEmailTest extends AbstractX509AuthenticationTest {      @Page+    @PhantomJSBrowser     protected AppPage appPage;      @Page+    @PhantomJSBrowser     protected X509IdentityConfirmationPage loginConfirmationPage;      @Page+    @PhantomJSBrowser     protected LoginPage loginPage; +    @Drone+    @PhantomJSBrowser+    private WebDriver phantomJS;++    @Before+    public void replaceTheDefaultDriver() {+        replaceDefaultWebDriver(phantomJS);","@hmlnarik @vmuzikar This part is a bit tricky and maybe you guys know better way...One of the features in Graphene is to use a custom Web Driver for specific pages (see [manual](http://arquillian.org/arquillian-graphene/#browser-instantiation)). This is why I had to add `@PhantomJSBrowser` annotation on each page object. However, all our pages use injected Web Driver ([see the code here](https://github.com/keycloak/keycloak/blob/8b628bda266ac5a459acd848085c450523911ef9/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/AbstractPage.java#L40)). As the injected Web Driver (the one we inject into `AbstractPage`) doesn't use any annotations, an `HTMLUnit` Driver gets injected. From there, it's very easy to confuse Graphene, because we use two different drivers to navigate things on the same page object. This often (but not always) leads to an exception.I noticed that we used to use `DroneUtils.addWebDriver` to solve similar problems but this doesn't solve the problem entirely, since only a small portion of our pages use `DroneUtils.getCurrentDriver`. In the vast majority of the cases, we use injected Web Driver.So in order to make sure I switch the driver to Phantom JS completely, I had to:* Add `@PhantomJSBrowser` annotation to page objects for Graphene.* Add proper driver to `DroneUtils`.* Iterate over all page objects in test class and replace the driver previously injected by Arquillian.If this is the first (and only) time you see this kind of problem, I guess it's OK to leave it like that. But if we struggle with this more often, I think we need do something about it. My guess is either to remove injected Web Driver into page objects (and force using `DroneUtils.getCurrentDriver` instead) or develop some extension to force Arquillian to inject proper driver where we want.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5930,264560096,2019-03-12T08:14:20Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/x509/X509BrowserLoginSubjectAltNameEmailTest.java,"@@ -38,14 +42,26 @@ public class X509BrowserLoginSubjectAltNameEmailTest extends AbstractX509AuthenticationTest {      @Page+    @PhantomJSBrowser     protected AppPage appPage;      @Page+    @PhantomJSBrowser     protected X509IdentityConfirmationPage loginConfirmationPage;      @Page+    @PhantomJSBrowser     protected LoginPage loginPage; +    @Drone+    @PhantomJSBrowser+    private WebDriver phantomJS;++    @Before+    public void replaceTheDefaultDriver() {+        replaceDefaultWebDriver(phantomJS);","I overally agree with the PR and with a way to have the X509 tests executed by default. So from my PoV, I am approving.Just a note that in the meantime, I sent PR for some additional X509 feature https://github.com/keycloak/keycloak/pull/5937 and I think that in my PR, I may have a conflict with you - I renamed the class ""X509BrowserLoginSubjectAltNameEmailTest"" to ""X509BrowserLoginSubjectAltNameTest"" as I needed more tests for SubjectAlternativeName (not just specific to email) and adding additional class looked to me as an unecessary overhead... I don't mind if your PR is merged first and I will then rebase on top of that :)I am leaving the low-level details regarding WebDriver to clarify with @vmuzikar , @hmlnarik or someone else. Just a note that we have annotation @Different used in some tests (for example SSOTest) and it looks that it's trying to solve the similar problem to yours - even if it is a bit different as you always need the PhantomJSDriver. But it looks that the approach with @Different has similar problem you mentioned - the ""driver"" injected inside pages is not correct.I am just pointing that in case if it makes sense to do something and ""merge"" both approaches? But I am not sure if it would simplify things or if it will be rather more complicated. Just asking and leaving to you guys :)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5907,265322949,2019-03-13T20:43:21Z,server-spi-private/src/main/java/org/keycloak/events/admin/AdminEvent.java,"@@ -144,10 +146,26 @@ public void setError(String error) {      * @return      */     public ResourceType getResourceType() {-        return resourceType;+        return Arrays.stream(ResourceType.values()).filter(r -> r.toString().equals(resourceType)).findFirst().orElse(null);","I believe `ResourceType` should introduce `CUSTOM` constant and return that instead of `null` which means just ""unset"".Furthermore, using `ResourceType.valueOf(resourceType)` and catching exception should have better performance than linear search since `valueOf` uses `Map` of enum constant name internally",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5947,266610325,2019-03-18T19:42:04Z,server-spi-private/src/main/java/org/keycloak/models/Constants.java,"@@ -73,5 +74,12 @@      int DEFAULT_MAX_RESULTS = 100; +    // Delimiter to be used in the configuration of authenticators (and some other components) in case that we need to save+    // multiple values into single string+    String CFG_DELIMITER = ""##"";","`public static`Since `Constants` is an interface, this is not an option, and the Pattern below would be instantiated with every `Constants` instantiations. Could this be placed rather to a proper class or - even better - `Constants` be turned into a final class?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5947,266613147,2019-03-18T19:49:46Z,services/src/main/java/org/keycloak/authentication/authenticators/x509/AbstractX509ClientCertificateAuthenticatorFactory.java,"@@ -138,14 +139,18 @@         crlDPEnabled.setName(ENABLE_CRLDP);         crlDPEnabled.setDefaultValue(false);         crlDPEnabled.setLabel(""Enable CRL Distribution Point to check certificate revocation status"");-        crlDPEnabled.setHelpText(""CRL Distribution Point is a starting point for CRL. CDP is optional, but most PKI authorities include CDP in their certificates."");+        crlDPEnabled.setHelpText(""CRL Distribution Point is a starting point for CRL. If this is ON, then CRL checking will be done based on the CRL distribution points included"" ++                "" in the checked certificates. CDP is optional, but most PKI authorities include CDP in their certificates."");          ProviderConfigProperty cRLRelativePath = new ProviderConfigProperty();-        cRLRelativePath.setType(STRING_TYPE);+        cRLRelativePath.setType(MULTIVALUED_STRING_TYPE);         cRLRelativePath.setName(CRL_RELATIVE_PATH);         cRLRelativePath.setDefaultValue(""crl.pem"");-        cRLRelativePath.setLabel(""CRL File path"");-        cRLRelativePath.setHelpText(""The path to a CRL file that contains a list of revoked certificates. Paths are assumed to be relative to $jboss.server.config.dir"");+        cRLRelativePath.setLabel(""CRL Path"");+        cRLRelativePath.setHelpText(""Applied just if CRL checking is ON and CRL Distribution point is OFF. It contains the URL (typically 'http' or 'ldap') "" ++                "" where the CRL is available. Alternatively it can contain the path to a CRL file that contains a list of revoked certificates. Paths are assumed to be relative to $jboss.server.config.dir ."" +","Together with end of previous row, two spaces; at the end there should be dot and space swapped.```suggestion                ""where the CRL is available. Alternatively it can contain the path to a CRL file that contains a list of revoked certificates. Paths are assumed to be relative to $jboss.server.config.dir. "" +```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5878,266619475,2019-03-18T20:06:04Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/x509/X509BrowserLoginSubjectDnTest.java,"@@ -0,0 +1,129 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.x509;++import java.io.FileInputStream;+import java.io.IOException;+import java.net.URL;+import java.security.cert.CertificateFactory;+import java.security.cert.X509Certificate;++import javax.security.auth.x500.X500Principal;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Assert;+import org.junit.BeforeClass;+import org.junit.Test;+import org.keycloak.OAuth2Constants;+import org.keycloak.authentication.authenticators.x509.X509AuthenticatorConfigModel;+import org.keycloak.events.Details;+import org.keycloak.representations.idm.AuthenticatorConfigRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.pages.AppPage;+import org.keycloak.testsuite.pages.LoginPage;+import org.keycloak.testsuite.pages.x509.X509IdentityConfirmationPage;++/**+ * @author Sebastian Loesch+ * @date 02/14/2019+ */++public class X509BrowserLoginSubjectDnTest extends AbstractX509AuthenticationTest {++    @Page+    protected AppPage appPage;++    @Page+    protected X509IdentityConfirmationPage loginConfirmationPage;++    @Page+    protected LoginPage loginPage;++    @BeforeClass+    public static void onBeforeTestClass() {+        if (Boolean.parseBoolean(System.getProperty(""auth.server.jboss""))) {+            String authServerHome = System.getProperty(""auth.server.home"");++            if (authServerHome != null && System.getProperty(""auth.server.ssl.required"") != null) {+                authServerHome = authServerHome + ""/standalone/configuration"";+                StringBuilder cliArgs = new StringBuilder();++                cliArgs.append(""--ignore-ssl-errors=true "");+                cliArgs.append(""--web-security=false "");+                cliArgs.append(""--ssl-certificates-path="" + authServerHome + ""/ca.crt "");+                cliArgs.append(""--ssl-client-certificate-file="" + authServerHome + ""/certs/clients/test-user-san-email@localhost.cert.pem "");+                cliArgs.append(""--ssl-client-key-file="" + authServerHome + ""/certs/clients/test-user@localhost.key.pem "");+                cliArgs.append(""--ssl-client-key-passphrase=password"");++                System.setProperty(""keycloak.phantomjs.cli.args"", cliArgs.toString());+            }+        }+    }++    private String setup(boolean canonicalDnEnabled) throws Exception {+        String clientCertFilePath = ""x509/test-user-san-email@localhost.cert.pem"";+        URL clientCertUrl = (getClass().getClassLoader().getResource(clientCertFilePath));+        if (clientCertUrl == null) {+            throw new IOException(""File not found: "" + clientCertFilePath);+        }+        CertificateFactory cf = CertificateFactory.getInstance(""X.509"", ""SUN"");","This will fail with e.g. IBM Java. Ensure that there is appropriate `Assume` in a `BeforeClass` method, or use `Assume.assumeNoException` for case this statement throws an exception ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5947,266630620,2019-03-18T20:36:20Z,server-spi-private/src/main/java/org/keycloak/models/Constants.java,"@@ -73,5 +74,12 @@      int DEFAULT_MAX_RESULTS = 100; +    // Delimiter to be used in the configuration of authenticators (and some other components) in case that we need to save+    // multiple values into single string+    String CFG_DELIMITER = ""##"";","I don't think this will be the case as fields declared on interface are automatically considered with modifiers ""public static final"" . Even if there are some instantiations of objects, which inherit from Constants interface, the pattern will be compiled just once. However AFAIK ""constant interface"" is not good pattern and I don't like it too, so I treat this as an opportunity to change this to ""final class"" :)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5947,266766290,2019-03-19T08:03:42Z,server-spi-private/src/main/java/org/keycloak/models/Constants.java,"@@ -73,5 +74,12 @@      int DEFAULT_MAX_RESULTS = 100; +    // Delimiter to be used in the configuration of authenticators (and some other components) in case that we need to save+    // multiple values into single string+    String CFG_DELIMITER = ""##"";","You're indeed right, I should stop doing reviews that late in the evening :-) Double thanks for turning this interface into a final class!",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5878,266788493,2019-03-19T09:12:25Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/x509/X509BrowserLoginSubjectDnTest.java,"@@ -0,0 +1,129 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.x509;++import java.io.FileInputStream;+import java.io.IOException;+import java.net.URL;+import java.security.cert.CertificateFactory;+import java.security.cert.X509Certificate;++import javax.security.auth.x500.X500Principal;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Assert;+import org.junit.BeforeClass;+import org.junit.Test;+import org.keycloak.OAuth2Constants;+import org.keycloak.authentication.authenticators.x509.X509AuthenticatorConfigModel;+import org.keycloak.events.Details;+import org.keycloak.representations.idm.AuthenticatorConfigRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.pages.AppPage;+import org.keycloak.testsuite.pages.LoginPage;+import org.keycloak.testsuite.pages.x509.X509IdentityConfirmationPage;++/**+ * @author Sebastian Loesch+ * @date 02/14/2019+ */++public class X509BrowserLoginSubjectDnTest extends AbstractX509AuthenticationTest {++    @Page+    protected AppPage appPage;++    @Page+    protected X509IdentityConfirmationPage loginConfirmationPage;++    @Page+    protected LoginPage loginPage;++    @BeforeClass+    public static void onBeforeTestClass() {+        if (Boolean.parseBoolean(System.getProperty(""auth.server.jboss""))) {+            String authServerHome = System.getProperty(""auth.server.home"");++            if (authServerHome != null && System.getProperty(""auth.server.ssl.required"") != null) {+                authServerHome = authServerHome + ""/standalone/configuration"";+                StringBuilder cliArgs = new StringBuilder();++                cliArgs.append(""--ignore-ssl-errors=true "");+                cliArgs.append(""--web-security=false "");+                cliArgs.append(""--ssl-certificates-path="" + authServerHome + ""/ca.crt "");+                cliArgs.append(""--ssl-client-certificate-file="" + authServerHome + ""/certs/clients/test-user-san-email@localhost.cert.pem "");+                cliArgs.append(""--ssl-client-key-file="" + authServerHome + ""/certs/clients/test-user@localhost.key.pem "");+                cliArgs.append(""--ssl-client-key-passphrase=password"");++                System.setProperty(""keycloak.phantomjs.cli.args"", cliArgs.toString());","yup, thanks. There is `org.keycloak.testsuite.updaters.SetSystemProperty` class that could be of use here.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5951,267636729,2019-03-21T06:45:04Z,testsuite/integration-arquillian/db-allocator-plugin/pom.xml,"@@ -0,0 +1,86 @@+<?xml version=""1.0""?>+<!--+~ Copyright 2019 Red Hat, Inc. and/or its affiliates+~ and other contributors as indicated by the @author tags.+~+~ Licensed under the Apache License, Version 2.0 (the ""License"");+~ you may not use this file except in compliance with the License.+~ You may obtain a copy of the License at+~+~ http://www.apache.org/licenses/LICENSE-2.0+~+~ Unless required by applicable law or agreed to in writing, software+~ distributed under the License is distributed on an ""AS IS"" BASIS,+~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+~ See the License for the specific language governing permissions and+~ limitations under the License.+-->++<project xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"" xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>integration-arquillian</artifactId>+        <version>6.0.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>db-allocator-plugin</artifactId>+    <packaging>maven-plugin</packaging>+    <name>DB Allocator Plugin</name>++    <properties>+        <maven.version>3.6.0</maven.version>+    </properties>++    <dependencies>+        <dependency>+            <groupId>org.apache.maven</groupId>+            <artifactId>maven-plugin-api</artifactId>+            <version>${maven.version}</version>+        </dependency>+        <dependency>+            <groupId>org.apache.maven.plugin-tools</groupId>+            <artifactId>maven-plugin-annotations</artifactId>+            <version>${maven.version}</version>+            <scope>provided</scope>+        </dependency>+        <dependency>+            <groupId>org.apache.maven</groupId>+            <artifactId>maven-core</artifactId>+            <version>${maven.version}</version>+        </dependency>+        <dependency>+            <groupId>org.jboss.resteasy</groupId>+            <artifactId>resteasy-client</artifactId>+        </dependency>++        <dependency>+            <groupId>junit</groupId>+            <artifactId>junit</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.jboss.arquillian.container</groupId>+            <artifactId>undertow-embedded</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.keycloak.testsuite</groupId>+            <artifactId>integration-arquillian-servers-app-server-undertow</artifactId>+            <version>6.0.0-SNAPSHOT</version>",The version should be inherited from parent dependencyManagement,X
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5951,267678673,2019-03-21T09:42:02Z,testsuite/integration-arquillian/db-allocator-plugin/pom.xml,"@@ -0,0 +1,86 @@+<?xml version=""1.0""?>+<!--+~ Copyright 2019 Red Hat, Inc. and/or its affiliates+~ and other contributors as indicated by the @author tags.+~+~ Licensed under the Apache License, Version 2.0 (the ""License"");+~ you may not use this file except in compliance with the License.+~ You may obtain a copy of the License at+~+~ http://www.apache.org/licenses/LICENSE-2.0+~+~ Unless required by applicable law or agreed to in writing, software+~ distributed under the License is distributed on an ""AS IS"" BASIS,+~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+~ See the License for the specific language governing permissions and+~ limitations under the License.+-->++<project xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"" xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>integration-arquillian</artifactId>+        <version>6.0.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>db-allocator-plugin</artifactId>+    <packaging>maven-plugin</packaging>+    <name>DB Allocator Plugin</name>++    <properties>+        <maven.version>3.6.0</maven.version>+    </properties>++    <dependencies>+        <dependency>+            <groupId>org.apache.maven</groupId>+            <artifactId>maven-plugin-api</artifactId>+            <version>${maven.version}</version>+        </dependency>+        <dependency>+            <groupId>org.apache.maven.plugin-tools</groupId>+            <artifactId>maven-plugin-annotations</artifactId>+            <version>${maven.version}</version>+            <scope>provided</scope>+        </dependency>+        <dependency>+            <groupId>org.apache.maven</groupId>+            <artifactId>maven-core</artifactId>+            <version>${maven.version}</version>+        </dependency>+        <dependency>+            <groupId>org.jboss.resteasy</groupId>+            <artifactId>resteasy-client</artifactId>+        </dependency>++        <dependency>+            <groupId>junit</groupId>+            <artifactId>junit</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.jboss.arquillian.container</groupId>+            <artifactId>undertow-embedded</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.keycloak.testsuite</groupId>+            <artifactId>integration-arquillian-servers-app-server-undertow</artifactId>+            <version>6.0.0-SNAPSHOT</version>","hmmm this one is much more tricky than I thought!It seems I introduced a cycle reference through `integration-arquillian-servers-app-server-spi`. I knew Maven will sort Undertor App Server correctly, but I haven't though about one layer below. This means I'll need to rework the testsuite for this module. I'll probably use Mockito to avoid similar ""surprise""...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5959,268522258,2019-03-25T08:10:28Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/containers/KeycloakContainerEventsController.java,"@@ -66,8 +79,98 @@ public void execute(@Observes(precedence = 3) AfterClass event) {         } finally {             container.fire(new StopClassContainers());         }+        if (event.getTestClass().isAnnotationPresent(RestartContainer.class)) {+            afterContainerStop(event.getTestClass().getAnnotation(RestartContainer.class).value());+        }     } +    @Override+    public void execute(BeforeClass event) {+        if (event.getTestClass().isAnnotationPresent(RestartContainer.class)) {+            container.fire(new StopManualContainers());+            container.fire(new StopSuiteContainers());++            beforeContainerStart(event.getTestClass().getAnnotation(RestartContainer.class).value());++            container.fire(new StartClassContainers());+            container.fire(new StartSuiteContainers());+        }+        super.execute(event);+    }++    /**+     * Actions to take after the original container stops.+     * @param value passed from annotation {@link RestartContainer} which triggered this behaviour+     */+    protected void afterContainerStop(String value) {+        copyKeycloakAddUserFile();+    }++    /**+     * Actions to take before new container starts.+     * @param value passed from annotation {@link RestartContainer} which triggered this behaviour+     */+    protected void beforeContainerStart(String value) {+        removeKeycloakAddUserFile();","I wonder if to add the condition like ""if (WELCOME_PAGE_TEST.equals(value)) {"" (same for afterContainerStopMethod) and use the annotation on WelcomePageTest like @RestartContainer(value = WELCOME_PAGE_TEST) ? If I understand correctly, the value can be left empty now as WelcomePAgeTest is the only test, which uses it right now, however if more tests are added in the future, it would need to be changed anyway. I am not 100% sure about this, so leaving to you how to do it in the end :)",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5951,269002504,2019-03-26T09:15:13Z,testsuite/integration-arquillian/servers/auth-server/jboss/pom.xml,"@@ -416,16 +416,19 @@                                     <configuration>                                         <target>                                             <ant antfile=""${common.resources}/ant/configure.xml"" target=""configure-server-jpa"">+                                                <!-- I'm intentionally leaving this as a comment. Before this gets integrated,+                                                     I need to speak with Tomas and Vlasta if their use cases work -->+                                                 <!-- These properties become equivalent to properties defined on the command line. -->                                                 <!-- Without specifying those the default values would be used regardless what is -->                                                 <!-- defined via -Dproperty=value when executing maven command -->-                                                <property name=""jdbc.driver.tmp.dir"">${jdbc.driver.tmp.dir}</property>-                                                <property name=""jdbc.mvn.artifactId"">${jdbc.mvn.artifactId}</property>-                                                <property name=""jdbc.mvn.version"">${jdbc.mvn.version}</property>-                                                <property name=""keycloak.connectionsJpa.url"">${keycloak.connectionsJpa.url}</property>-                                                <property name=""keycloak.connectionsJpa.user"">${keycloak.connectionsJpa.user}</property>-                                                <property name=""keycloak.connectionsJpa.password"">${keycloak.connectionsJpa.password}</property>-                                                <property name=""keycloak.connectionsJpa.schema"">${keycloak.connectionsJpa.schema}</property>+<!--                                                <property name=""jdbc.driver.tmp.dir"" value=""${jdbc.driver.tmp.dir}"" />-->","@vramik @tkyjovsk Here goes a very tricky part and I would like to know your opinion about it. However, before diving into my explanation, please read these two articles:* https://technotes.khitrenovich.com/properties-resolution-maven-implications-antrun-plugin/* https://books.sonatype.com/mvnref-book/reference/resource-filtering-sect-properties.htmlThe comment here suggests that you have been struggling with property resolution here. I also encountered some difficulties, because Maven resolves expressions when rendering the Effective POM. Since the DB Allocator Plugin manipulates `keycloak.connectionsJpa.*` properties in the runtime, resolving them for the Ant Plugin happened too quickly. This resulted in picking up properties defined [here](https://github.com/keycloak/keycloak/blob/31b767567e2c2940766c054a3298b73cfa8a7ec5/testsuite/integration-arquillian/pom.xml#L91-L96), instead of those changed by the DB Allocator Plugin.The solution I propose is to force the Ant Plugin to resolve the properties instead of relying on the mechanism provided by Maven. Here's an example:Maven resolution example:```xml<property name=""jdbc.driver.tmp.dir"">${jdbc.driver.tmp.dir}</property>```Ant Plugin resolution example:```xml<property name=""jdbc.driver.tmp.dir"" value=""${jdbc.driver.tmp.dir}"" />```Note, that the plugin now receives ''${jdbc.driver.tmp.dir}"" and needs to resolve this based on the properties passed by Maven. So this time, the resolution happens in the runtime instead of rendering an Effective POM.I'm not entirely sure if I didn't break anything with this change. So if you guys are invoking something manually somewhere, please check if it still works.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/5951,269433978,2019-03-27T07:35:33Z,testsuite/integration-arquillian/servers/auth-server/jboss/pom.xml,"@@ -416,16 +416,19 @@                                     <configuration>                                         <target>                                             <ant antfile=""${common.resources}/ant/configure.xml"" target=""configure-server-jpa"">+                                                <!-- I'm intentionally leaving this as a comment. Before this gets integrated,+                                                     I need to speak with Tomas and Vlasta if their use cases work -->+                                                 <!-- These properties become equivalent to properties defined on the command line. -->                                                 <!-- Without specifying those the default values would be used regardless what is -->                                                 <!-- defined via -Dproperty=value when executing maven command -->-                                                <property name=""jdbc.driver.tmp.dir"">${jdbc.driver.tmp.dir}</property>-                                                <property name=""jdbc.mvn.artifactId"">${jdbc.mvn.artifactId}</property>-                                                <property name=""jdbc.mvn.version"">${jdbc.mvn.version}</property>-                                                <property name=""keycloak.connectionsJpa.url"">${keycloak.connectionsJpa.url}</property>-                                                <property name=""keycloak.connectionsJpa.user"">${keycloak.connectionsJpa.user}</property>-                                                <property name=""keycloak.connectionsJpa.password"">${keycloak.connectionsJpa.password}</property>-                                                <property name=""keycloak.connectionsJpa.schema"">${keycloak.connectionsJpa.schema}</property>+<!--                                                <property name=""jdbc.driver.tmp.dir"" value=""${jdbc.driver.tmp.dir}"" />-->",If I understand it correctly the mechanisms you're proposing is already used e.g. [here](https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/servers/auth-server/jboss/pom.xml#L219-L229),X
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5951,269477374,2019-03-27T09:49:05Z,testsuite/integration-arquillian/db-allocator-plugin/pom.xml,"@@ -0,0 +1,86 @@+<?xml version=""1.0""?>+<!--+~ Copyright 2019 Red Hat, Inc. and/or its affiliates+~ and other contributors as indicated by the @author tags.+~+~ Licensed under the Apache License, Version 2.0 (the ""License"");+~ you may not use this file except in compliance with the License.+~ You may obtain a copy of the License at+~+~ http://www.apache.org/licenses/LICENSE-2.0+~+~ Unless required by applicable law or agreed to in writing, software+~ distributed under the License is distributed on an ""AS IS"" BASIS,+~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+~ See the License for the specific language governing permissions and+~ limitations under the License.+-->++<project xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"" xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>integration-arquillian</artifactId>+        <version>6.0.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>db-allocator-plugin</artifactId>+    <packaging>maven-plugin</packaging>+    <name>DB Allocator Plugin</name>++    <properties>+        <maven.version>3.6.0</maven.version>+    </properties>++    <dependencies>+        <dependency>+            <groupId>org.apache.maven</groupId>+            <artifactId>maven-plugin-api</artifactId>+            <version>${maven.version}</version>+        </dependency>+        <dependency>+            <groupId>org.apache.maven.plugin-tools</groupId>+            <artifactId>maven-plugin-annotations</artifactId>+            <version>${maven.version}</version>+            <scope>provided</scope>+        </dependency>+        <dependency>+            <groupId>org.apache.maven</groupId>+            <artifactId>maven-core</artifactId>+            <version>${maven.version}</version>+        </dependency>+        <dependency>+            <groupId>org.jboss.resteasy</groupId>+            <artifactId>resteasy-client</artifactId>+        </dependency>++        <dependency>+            <groupId>junit</groupId>+            <artifactId>junit</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.jboss.arquillian.container</groupId>+            <artifactId>undertow-embedded</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.keycloak.testsuite</groupId>+            <artifactId>integration-arquillian-servers-app-server-undertow</artifactId>+            <version>6.0.0-SNAPSHOT</version>+            <scope>test</scope>+        </dependency>++    </dependencies>++        <build>+        <plugins>+            <plugin>+                <groupId>org.apache.maven.plugins</groupId>+                <artifactId>maven-plugin-plugin</artifactId>+                <version>3.6.0</version>","Unfortunately it seems my approach was wrong. Since I'm using a more recent of Maven Core dependency, Maven freaked out when invoked on the prod pipeline. It seems using `${maven.version}` as you adviced might be a better choice (although we might run into some problems in the future, but I hope not :imp: ).",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/5951,269540842,2019-03-27T12:42:57Z,testsuite/db-allocator-plugin/pom.xml,"@@ -0,0 +1,82 @@+<?xml version=""1.0""?>+<!--+~ Copyright 2019 Red Hat, Inc. and/or its affiliates+~ and other contributors as indicated by the @author tags.+~+~ Licensed under the Apache License, Version 2.0 (the ""License"");+~ you may not use this file except in compliance with the License.+~ You may obtain a copy of the License at+~+~ http://www.apache.org/licenses/LICENSE-2.0+~+~ Unless required by applicable law or agreed to in writing, software+~ distributed under the License is distributed on an ""AS IS"" BASIS,+~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+~ See the License for the specific language governing permissions and+~ limitations under the License.+-->++<project xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd""+         xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">+    <parent>+        <artifactId>keycloak-testsuite-pom</artifactId>+        <groupId>org.keycloak</groupId>+        <version>6.0.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>db-allocator-plugin</artifactId>+    <packaging>maven-plugin</packaging>+    <name>DB Allocator Plugin</name>++    <properties>+        <maven.version>3.6.0</maven.version>+    </properties>++    <dependencies>+        <dependency>+            <groupId>org.apache.maven</groupId>+            <artifactId>maven-plugin-api</artifactId>+            <version>${maven.version}</version>+        </dependency>+        <dependency>+            <groupId>org.apache.maven.plugin-tools</groupId>+            <artifactId>maven-plugin-annotations</artifactId>+            <version>${maven.version}</version>+            <scope>provided</scope>+        </dependency>+        <dependency>+            <groupId>org.apache.maven</groupId>+            <artifactId>maven-core</artifactId>","This dependency might be redundant, see https://maven.apache.org/guides/plugin/guide-java-plugin-development.html",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5959,270185386,2019-03-28T20:26:34Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -638,4 +640,65 @@ protected static InputStream httpsAwareConfigurationStream(InputStream input) th         }         return in;     }++    /**+     * This static method can be used to change default {@ode WebDriver} to different one if the test is able to run","You mentioned ""static"" method, but this method is not static? How about declare it ""static""? and maybe also move to some utils class like DroneUtils?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5951,270385910,2019-03-29T12:21:47Z,testsuite/integration-arquillian/pom.xml,"@@ -363,7 +398,7 @@             </build>         </profile>         <profile>-            <id>db-mysql</id>+            <id>db-mysql57</id>",https://github.com/keycloak/keycloak/blob/master/docs/tests-db.md#using-built-in-profiles-to-run-database-tests-using-docker-containers needs to be updated as well,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5951,270388660,2019-03-29T12:31:07Z,testsuite/integration-arquillian/HOW-TO-RUN.md,"@@ -717,6 +717,37 @@ The exact steps to configure Docker depend on the operating system. By default, the test will run against Undertow based embedded Keycloak Server, thus no distribution build is required beforehand. The exact command line arguments depend on the operating system. ++## Using DB Allocator Service",This section belongs to https://github.com/keycloak/keycloak/blob/master/docs/tests-db.md,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5951,270389017,2019-03-29T12:32:30Z,testsuite/integration-arquillian/HOW-TO-RUN.md,"@@ -717,6 +717,37 @@ The exact steps to configure Docker depend on the operating system. By default, the test will run against Undertow based embedded Keycloak Server, thus no distribution build is required beforehand. The exact command line arguments depend on the operating system. ++## Using DB Allocator Service++The testsuite can use the DB Allocator Service to allocate and release desired database automatically.+Since some of the database properties (such as JDBC URL, Username or Password) need to be used when building the Auth Server,+the allocation and deallocation need to happen when building the `integration-arquillian` project (instead of `tests/base` as+it happens in other cases).++In order to use the DB Allocator Service, you must use the `jpa` profile with one of the `db-allocator-*`. Here's a full example to+run JPA with Auth Server Wildfly and MSSQL 2016:++```+mvn -f testsuite/integration-arquillian/pom.xml \+    -Pjpa,auth-server-wildfly,db-allocator-db-mssql2016 \+    -Ddballocator.uri=<<db-allocator-servlet-url>> \+    -Ddballocator.user=<<db-allocator-user>> \+    -Dmaven.test.failure.ignore=true+```++Using `-Dmaven.test.failure.ignore=true` is not strictly required but highly recommended. After running the tests,+the DB Allocator Plugin should release the allocated database.++Other implemented profiles:","Since this will be changing over time, I suggest to put one or two profiles here and refer user to the output of the following command to get the list of available db profiles:```bashmvn help:all-profiles -pl testsuite/integration-arquillian | grep -- db-```",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/5255,271041022,2019-04-01T20:38:11Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -242,6 +255,54 @@             return adapter.login(options);         } +        function generateRandomData(len) {+            // use web crypto APIs if possible+            var array = null;+            var crypto = window.crypto || window.msCrypto;+            if (crypto && crypto.getRandomValues && window.Uint8Array) {+                array = new Uint8Array(len);+                crypto.getRandomValues(array);+                return array;+            }++            // fallback to Math random","@thomasdarimont @mposolda `Math.random` is not considered cryptographically secure and I don't think is a good idea use it as fallbac. If Webcrypto is not supported in the browser, I believe would be better to provide a warning message like ""Not supported"" or something similar.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/5255,271049963,2019-04-01T21:02:27Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -1554,3 +1625,25 @@         }     } })( window );++/** Additional support libraries */++/**+ * [js-sha256]{@link https://github.com/emn178/js-sha256}",@thomasdarimont any reason to prefer a third party library over `crypto.subtle.digest`?,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/5255,271058381,2019-04-01T21:29:38Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -242,6 +255,54 @@             return adapter.login(options);         } +        function generateRandomData(len) {+            // use web crypto APIs if possible+            var array = null;+            var crypto = window.crypto || window.msCrypto;+            if (crypto && crypto.getRandomValues && window.Uint8Array) {+                array = new Uint8Array(len);+                crypto.getRandomValues(array);+                return array;+            }++            // fallback to Math random","Yes, `Math.random` does not provide secure randomness, but isn't a little less random 96 char long `codeVerifier` string better than no `codeVerifier` at all? I see your point of just providing secure options, but a `console.warn(..)` message about not strong enough crypto might not help the user very much, because they usually don't look in the developer console :)Further more this would only happen for old browsers or Opera Mini (see. https://caniuse.com/#search=getRandomValues). Btw. the length of 96 chars was also just a guess along the recommended size of > 43 and < 128 (see: https://tools.ietf.org/html/rfc7636).",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/5255,271062829,2019-04-01T21:44:47Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -1554,3 +1625,25 @@         }     } })( window );++/** Additional support libraries */++/**+ * [js-sha256]{@link https://github.com/emn178/js-sha256}","That's what I tried first, but when I contributed the feature `crypto.subtle.digest` function wasn't available in the major browsers. Perhaps the situation changed in the meantime...It's a similar story for the the base64-js library, which I needed because the `btoa` base64 encodings cannot deal with Uint8ArrayBuffer's and unicode.See my original commit:https://github.com/thomasdarimont/keycloak/commit/f05066d430f6504246f7e518a124aef2ef5195b8",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/5255,271064794,2019-04-01T21:51:19Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -115,6 +115,19 @@                 if(initOptions.redirectUri) {                     kc.redirectUri = initOptions.redirectUri;                 }++                if (initOptions.pkceMethod) {+                    switch(initOptions.pkceMethod) {+                        case ""plain"":","btw. other libaries, e.g. [openid/AppAuth-JS](https://github.com/openid/AppAuth-JS/blob/a8c2962d7a24010ec1b4eb0e6eb3a9b0234f5733/src/authorization_request.ts#L96) explicitly don't support the pkce method `plain`.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5974,271631835,2019-04-03T08:32:54Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/InitialAccessTokenTest.java,"@@ -70,28 +65,6 @@ public void create() throws ClientRegistrationException, InterruptedException {         }     } -    @Test","@tnorimat IMO it is fine to keep just the ES256 test. There is always some value in introducing new test, however there are also some not-good side effects to it (EG. testsuite running for longer time and consume more resources etc). So in this case, my vote is to just keep the current test :)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5661,272062055,2019-04-04T08:09:49Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -268,6 +297,96 @@ protected Response handleSamlRequest(String samlRequest, String relayState) {             }         } +        /**+         * Handle a received artifact message. This means finding the client based on the content of the artifact,+         * sending an ArtifactResolve, receiving an ArtifactResponse, and handling its content based on the ""standard""+         * workflows.+         *+         * @param artifact the received artifact+         * @param relayState the current relay state+         * @return a Response based on the content of the ArtifactResponse's content+         */+        protected Response handleArtifact(String artifact, String relayState) {+            //Find client+            ClientModel client = null;+            try {+                byte[] source = getSourceFromArtifact(artifact);+                MessageDigest sha1Digester = MessageDigest.getInstance(""SHA-1"");+                for (ClientModel aClient :realm.getClients()) {+                    byte[] clientBytes = sha1Digester.digest(aClient.getClientId().getBytes(Charsets.UTF_8));+                    if (Arrays.equals(source, clientBytes)) {+                        client = aClient;+                        break;+                    }+                }+                if (client == null) {",All the checks that are done in `handleSamlRequest` for the client validity (https://github.com/keycloak/keycloak/blob/5.0.0/services/src/main/java/org/keycloak/protocol/saml/SamlService.java#L213-L251) needs to be done here as well as in artifact resolution part. Feel free to extract them from `handleSamlRequest()` into a common method.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5661,272064655,2019-04-04T08:17:18Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -268,6 +297,96 @@ protected Response handleSamlRequest(String samlRequest, String relayState) {             }         } +        /**+         * Handle a received artifact message. This means finding the client based on the content of the artifact,+         * sending an ArtifactResolve, receiving an ArtifactResponse, and handling its content based on the ""standard""+         * workflows.+         *+         * @param artifact the received artifact+         * @param relayState the current relay state+         * @return a Response based on the content of the ArtifactResponse's content+         */+        protected Response handleArtifact(String artifact, String relayState) {+            //Find client+            ClientModel client = null;+            try {+                byte[] source = getSourceFromArtifact(artifact);+                MessageDigest sha1Digester = MessageDigest.getInstance(""SHA-1"");+                for (ClientModel aClient :realm.getClients()) {+                    byte[] clientBytes = sha1Digester.digest(aClient.getClientId().getBytes(Charsets.UTF_8));+                    if (Arrays.equals(source, clientBytes)) {+                        client = aClient;+                        break;+                    }+                }+                if (client == null) {+                    event.event(EventType.LOGIN);+                    event.detail(Details.REASON, ""Cannot_match_source_hash"");+                    event.error(Errors.CLIENT_NOT_FOUND);+                    return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REQUEST);+                }+            } catch (ProcessingException e) {+                event.event(EventType.LOGIN);+                event.detail(Details.REASON, ""Incorrect_artifact"");+                event.error(Errors.INVALID_SAML_ARTIFACT);+                return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REQUEST);+            } catch (NoSuchAlgorithmException e) {+                event.event(EventType.LOGIN);+                event.detail(Details.REASON, e.getMessage());+                event.error(Errors.CLIENT_NOT_FOUND);+                return ErrorPage.error(session, null, Response.Status.INTERNAL_SERVER_ERROR, Messages.UNEXPECTED_ERROR_HANDLING_REQUEST);+            }++            try {+                //send artifact resolve+                Document doc = createArtifactResolve(client.getClientId(), artifact);+                BaseSAML2BindingBuilder binding = new BaseSAML2BindingBuilder();+                SamlClient samlClient = new SamlClient(client);+                if (samlClient.requiresRealmSignature()) {+                    KeyManager keyManager = session.keys();+                    KeyManager.ActiveRsaKey keys = keyManager.getActiveRsaKey(realm);+                    String keyName = samlClient.getXmlSigKeyInfoKeyNameTransformer().getKeyName(keys.getKid(), keys.getCertificate());+                    String canonicalization = samlClient.getCanonicalizationMethod();+                    if (canonicalization != null) {+                        binding.canonicalizationMethod(canonicalization);+                    }+                    binding.signatureAlgorithm(samlClient.getSignatureAlgorithm()).signWith(keyName, keys.getPrivateKey(), keys.getPublicKey(), keys.getCertificate()).signDocument(doc);+                }+                String clientArtifactBindingURL = client.getAttribute(SamlProtocol.SAML_ARTIFACT_RESOLUTION_SERVICE_URL_ATTRIBUTE);++                if (clientArtifactBindingURL == null || clientArtifactBindingURL.isEmpty()) {+                    throw new ConfigurationException(""There is no configured artifact resolution service for the client "" + client.getClientId());+                }+                SOAPMessage returnedMessage = Soap.createMessage().addToBody(doc).call(clientArtifactBindingURL);","1. The call obviously needs to be resolved before continuing but it cannot block the current worker thread. JAX-RS `@Suspended final AsyncResponse response` should work here2. The thread pool to offload the call and its processing to would be the one obtained from `session.getProvider(ExecutorsProvider.class).getExecutor(""saml-artifact-pool"")`3. The `call` needs to either use the existing http client infrastructure (see `session.getProvider(HttpClientProvider.class).getHttpClient()`) or set connection/reply timeouts explicitly.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/5661,272084771,2019-04-04T09:07:55Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -295,7 +414,11 @@ protected Response loginRequest(String relayState, AuthnRequestType requestAbstr             if (redirectUri != null && ! ""null"".equals(redirectUri.toString())) { // ""null"" is for testing purposes                 redirect = RedirectUtils.verifyRedirectUri(session.getContext().getUri(), redirectUri.toString(), realm, client);             } else {-                if (bindingType.equals(SamlProtocol.SAML_POST_BINDING)) {+                if ((requestAbstractType.getProtocolBinding() != null && JBossSAMLURIConstants.SAML_HTTP_ARTIFACT_BINDING.getUri()+                        .compareTo(requestAbstractType.getProtocolBinding()) == 0)+                        || new SamlClient(client).forceArtifactBinding()) {",Let's only bind the condition on the `requestAbstractType.getProtocolBinding()` and extract the `forceArtifactBinding` and the related UI logic to a separate PR for https://issues.jboss.org/browse/KEYCLOAK-9995 after this one would be good to go.,X
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/5993,274739399,2019-04-12T02:14:13Z,services/src/main/java/org/keycloak/protocol/AuthorizationEndpointBase.java,"@@ -196,4 +215,49 @@ protected AuthenticationSessionModel createAuthenticationSession(ClientModel cli      } +    /**+     * Checks if the request should be redirected to the default identity provider or not. This method returns {@code true}+     * If a default identity provider is found (i.e. it was either explicitly set as the default provider for the realm or+     * specified as the default provider for the auth request using the {@code kc_idp_hint} query parameter) and if this provider+     * supports redirects with the {@code prompt=none} query parameter; it returns {@code false} otherwise.+     *+     * @param authSession a reference to the authentication session.+     * @param protocol a reference to the login protocol.+     * @return {@code true} if the request if {@code prompt=none} query parameter should be redirected to the default+     * provider (if one exists); {@code false} otherwise.+     */+    private boolean redirectToDefaultProvider(final AuthenticationSessionModel authSession, final LoginProtocol protocol) {+        if (protocol instanceof OIDCLoginProtocol) {++            // check if ""kc_idp_hint"" query parameter has been set to set or override the default provider.+            if (session.getContext().getUri().getQueryParameters().containsKey(AdapterConstants.KC_IDP_HINT)) {+                String providerId = session.getContext().getUri().getQueryParameters().getFirst(AdapterConstants.KC_IDP_HINT);+                if (providerId != null && !providerId.isEmpty()) {+                    IdentityProviderModel provider = authSession.getRealm().getIdentityProviderByAlias(providerId);+                    if (provider != null && provider.isEnabled() && Boolean.valueOf(provider.getConfig().get(SUPPORTS_PROMPT_NONE))) {+                        return true;+                    }+                }+                else {+                    // ""kc_idp_hint"" was set with an empty value - cannot assume a default provider for the request.+                    return false;+                }+            }++            // check if we have a default identity provider configured in the realm.+            List<AuthenticatorConfigModel> authConfigs = authSession.getRealm().getAuthenticatorConfigs();+            if (authConfigs != null) {+                for (AuthenticatorConfigModel authConfig : authConfigs) {+                    if (authConfig.getConfig().containsKey(DEFAULT_PROVIDER)) {+                        String providerId = authConfig.getConfig().get(DEFAULT_PROVIDER);+                        if (providerId != null && !providerId.isEmpty()) {+                            IdentityProviderModel provider = authSession.getRealm().getIdentityProviderByAlias(providerId);+                            return provider != null && provider.isEnabled() && Boolean.valueOf(provider.getConfig().get(SUPPORTS_PROMPT_NONE));+                        }+                    }+                }+            }+        }+        return false;+    }","This code kinda duplicates to some extent the logic from the IdentityProviderAuthenticator to determine the default provider. An alternative would be to work on the Response that is returned when we call authenticateOnly() and see if that response contains a redirect (302) to the broker. We could then parse the Location URI to extract the provider alias and use it to check if the provider supports prompt=none redirects. In other words, if we get a 302 and URL matches the /broker/idp_alias/login structure we know it was assembled by the IdentityProviderAuthenticator and we can extract the idp_alias from the URL and use it.I've attempted this alternative way but the resulting code looked a bit hacky to be honest with the URL manipulation. It is, however, the most efficient way to obtain the default IdP alias without going through the realm config or re-checking the kc_idp_hint param, so if you feel this is better than the code above I can switch to it.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5998,274951736,2019-04-12T15:15:11Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/ClientTokenExchangeTest.java,"@@ -482,9 +504,80 @@ public void testDirectImpersonation() throws Exception {             Assert.assertTrue(response.getStatus() >= 400);             response.close();         }+    }++    private static void addDirectExchanger(KeycloakSession session) {","Is it possible to somehow ""merge"" this code with the code used in the method ""setupRealm"" method to avoid having same/similar code on 2 places? Maybe introduce some private method (with some parameters like clientId etc if needed) and call it from both ""setupRealm"" and ""addDirectImpersonation"" ?",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/5255,278201444,2019-04-24T16:01:28Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -313,6 +374,14 @@                 url += '&kc_locale=' + encodeURIComponent(options.kcLocale);             } +            if (options && kc.pkceMethod) {+                var codeVerifier = generateCodeVerifier(96);+                localStorage.setItem('kc-pkceCodeVerifier', codeVerifier);","localStorage isn't always available. That is what we used for the callback initially, but then we added this thing https://github.com/keycloak/keycloak/blob/master/adapters/oidc/js/src/main/resources/keycloak.js#L1537 which uses localstorage if avail, or cookie storage if not. I would just use the callbackStorage, or add a codeVerifierStorage that uses the same  createCallbackStorage.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5993,278418289,2019-04-25T07:06:08Z,services/src/main/java/org/keycloak/protocol/AuthorizationEndpointBase.java,"@@ -196,4 +215,49 @@ protected AuthenticationSessionModel createAuthenticationSession(ClientModel cli      } +    /**+     * Checks if the request should be redirected to the default identity provider or not. This method returns {@code true}+     * If a default identity provider is found (i.e. it was either explicitly set as the default provider for the realm or+     * specified as the default provider for the auth request using the {@code kc_idp_hint} query parameter) and if this provider+     * supports redirects with the {@code prompt=none} query parameter; it returns {@code false} otherwise.+     *+     * @param authSession a reference to the authentication session.+     * @param protocol a reference to the login protocol.+     * @return {@code true} if the request if {@code prompt=none} query parameter should be redirected to the default+     * provider (if one exists); {@code false} otherwise.+     */+    private boolean redirectToDefaultProvider(final AuthenticationSessionModel authSession, final LoginProtocol protocol) {+        if (protocol instanceof OIDCLoginProtocol) {++            // check if ""kc_idp_hint"" query parameter has been set to set or override the default provider.+            if (session.getContext().getUri().getQueryParameters().containsKey(AdapterConstants.KC_IDP_HINT)) {+                String providerId = session.getContext().getUri().getQueryParameters().getFirst(AdapterConstants.KC_IDP_HINT);+                if (providerId != null && !providerId.isEmpty()) {+                    IdentityProviderModel provider = authSession.getRealm().getIdentityProviderByAlias(providerId);+                    if (provider != null && provider.isEnabled() && Boolean.valueOf(provider.getConfig().get(SUPPORTS_PROMPT_NONE))) {+                        return true;+                    }+                }+                else {+                    // ""kc_idp_hint"" was set with an empty value - cannot assume a default provider for the request.+                    return false;+                }+            }++            // check if we have a default identity provider configured in the realm.+            List<AuthenticatorConfigModel> authConfigs = authSession.getRealm().getAuthenticatorConfigs();+            if (authConfigs != null) {+                for (AuthenticatorConfigModel authConfig : authConfigs) {+                    if (authConfig.getConfig().containsKey(DEFAULT_PROVIDER)) {+                        String providerId = authConfig.getConfig().get(DEFAULT_PROVIDER);+                        if (providerId != null && !providerId.isEmpty()) {+                            IdentityProviderModel provider = authSession.getRealm().getIdentityProviderByAlias(providerId);+                            return provider != null && provider.isEnabled() && Boolean.valueOf(provider.getConfig().get(SUPPORTS_PROMPT_NONE));+                        }+                    }+                }+            }+        }+        return false;+    }","+1 that this code duplicates the login in IdentityProviderAuthenticator. I suggest another alternative, which won't require AuthorizationEndpointBase to be aware of any IDP specific logic - see description for more details.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5255,284233397,2019-05-15T12:40:01Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -242,6 +255,54 @@             return adapter.login(options);         } +        function generateRandomData(len) {+            // use web crypto APIs if possible+            var array = null;+            var crypto = window.crypto || window.msCrypto;+            if (crypto && crypto.getRandomValues && window.Uint8Array) {+                array = new Uint8Array(len);+                crypto.getRandomValues(array);+                return array;+            }++            // fallback to Math random","IMO it will be good to use the most secured function available in current browser and fallback to the less secure alternative if the more secure is not available.The `Math.random` is already used for createUUID BTV. I don't think we need to skip functionality if more secure alternative is not available, I don't see the fact that `Math.random` is not 100% cryptographically secure as a major potential for attack vectors.Will be good to have unified ""random"" function for all the functionality in the JS library, which don't need whole alphabet as an argument. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6045,284769432,2019-05-16T15:33:23Z,common/src/main/java/org/keycloak/common/util/HttpPostRedirect.java,"@@ -25,6 +25,7 @@  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>  * @version $Revision: 1 $  */+@Deprecated","Since this is deprecated, Javadoc should contain `@deprecated` part with description what to use instead.",X
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6053,285343864,2019-05-18T14:16:31Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/my-resources-page/ShareResourceModal.tsx,"@@ -0,0 +1,81 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++import * as React from 'react';+import {Button, Form, FormGroup, Modal, TextInput} from '@patternfly/react-core';+import {Msg} from ""../../widgets/Msg"";++export interface ShareResourceModalState {+    isModalOpen: boolean+}++export interface ShareResourceModalProps {+    resource: any;+}++export class ShareResourceModal extends React.Component<ShareResourceModalProps, ShareResourceModalState> {++    constructor(props: ShareResourceModalProps) {+        super(props);+        this.state = {isModalOpen: false}+    }++    render(): React.ReactNode {+        return (+            <React.Fragment>+                <button className=""pf-c-button pf-m-tertiary"" onClick={this.handleModalToggle}>+                    Share+                </button>",Why not use <Button> component here?,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6053,285343980,2019-05-18T14:20:05Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/my-resources-page/ShareResourceModal.tsx,"@@ -0,0 +1,81 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++import * as React from 'react';+import {Button, Form, FormGroup, Modal, TextInput} from '@patternfly/react-core';+import {Msg} from ""../../widgets/Msg"";++export interface ShareResourceModalState {+    isModalOpen: boolean+}++export interface ShareResourceModalProps {+    resource: any;+}++export class ShareResourceModal extends React.Component<ShareResourceModalProps, ShareResourceModalState> {++    constructor(props: ShareResourceModalProps) {+        super(props);+        this.state = {isModalOpen: false}+    }++    render(): React.ReactNode {+        return (+            <React.Fragment>+                <button className=""pf-c-button pf-m-tertiary"" onClick={this.handleModalToggle}>+                    Share+                </button>+                <Modal+                    isSmall+                    title={""Share the resource "" + this.props.resource[0]}","I'm probably guilty of this too, but let's start to define all of our text in the resource bundle.  That way we won't have to go back through all the code and find the hard-coded strings.We should probably start using our own bundle for this app instead of inheriting the old one.  The longer we wait to do this the worse of a task it will be.  Maybe I'll go ahead and get it done next week.  WDYT?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6053,286172647,2019-05-21T18:47:48Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/my-resources-page/ShareResourceModal.tsx,"@@ -0,0 +1,81 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++import * as React from 'react';+import {Button, Form, FormGroup, Modal, TextInput} from '@patternfly/react-core';+import {Msg} from ""../../widgets/Msg"";++export interface ShareResourceModalState {+    isModalOpen: boolean+}++export interface ShareResourceModalProps {+    resource: any;+}++export class ShareResourceModal extends React.Component<ShareResourceModalProps, ShareResourceModalState> {++    constructor(props: ShareResourceModalProps) {+        super(props);+        this.state = {isModalOpen: false}+    }++    render(): React.ReactNode {+        return (+            <React.Fragment>+                <button className=""pf-c-button pf-m-tertiary"" onClick={this.handleModalToggle}>+                    Share+                </button>+                <Modal+                    isSmall+                    title={""Share the resource "" + this.props.resource[0]}","For the long term, it should be better to have another one. But until both versions of the console exist I think that having a second one will make life harder when you need to update messages.  ",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/6050,286363287,2019-05-22T08:12:58Z,adapters/saml/core/src/main/java/org/keycloak/adapters/saml/config/parsers/DeploymentBuilder.java,"@@ -214,6 +220,25 @@ public SamlDeployment build(InputStream xml, ResourceLoader resourceLoader) thro         return deployment;     } +    private int convertClockSkewInMillis(int duration, TimeUnit unit) {","I'd suggest to just cut the rest from nanoseconds and microsecods, It'd simplify the method. We also doesn't need `long` here, `int` would be sufficient. And the INFO log message with value in ms should be added.```suggestion    private int convertClockSkewInMillis(int duration, TimeUnit unit) {        int durationMillis = (int) unit.toMillis(duration);        switch (unit) {            case NANOSECONDS:            case MICROSECONDS:                log.warn(""Clock skew value will be rounded down."");            default:                log.info(""Clock skew set to "" + durationMillis + ""ms."");        }        return durationMillis;    }```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6041,286920892,2019-05-23T12:38:23Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/OIDCAttributeMapperHelper.java,"@@ -144,6 +153,18 @@ private static Boolean getBoolean(Object attributeValue) {         if (attributeValue instanceof String) return Boolean.valueOf((String) attributeValue);         return null;     }+    +    private static JsonNode getJsonNode(Object attributeValue) {+        if (attributeValue instanceof JsonNode) return (JsonNode) attributeValue;+        if (attributeValue instanceof String) {+            try {+                final ObjectMapper mapper = new ObjectMapper();",You should consider using `org.keycloak.util.JsonSerialization` instead of creating a new `ObjectMapper` instance.Don't you want to throw an exception in case the `attribute` value is not a `JsonNode`. Why you need to convert the string to a json object ?,X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6038,286948421,2019-05-23T13:41:58Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties,"@@ -968,6 +968,7 @@ ldap.connection-pooling.prefsize.tooltip=The string representation of an integer ldap.connection-pooling.protocol.tooltip=A list of space-separated protocol types of connections that may be pooled. Valid types are ""plain"" and ""ssl"". ldap.connection-pooling.timeout.tooltip=The string representation of an integer that represents the number of milliseconds that an idle connection may remain in the pool without being closed and removed from the pool. ldap.pagination.tooltip=Does the LDAP server support pagination.+ldap.tls.tooltip=Does the LDAP server require STARTTLS.","Is it possible to improve the tooltip and add also the information that enabling ""Use STARTTLS"" will also effectively disable connection pooling? Also is it possible to add the validation check to the LDAPStorageProviderFactory.validateConfiguration method and throw an exception if both ""Use StartTLS"" and connection pooling is enabled? This will make sure that it's more ""hard"" to wrongly configure things.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6038,286949243,2019-05-23T13:43:45Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/idm/store/ldap/LDAPOperationManager.java,"@@ -39,12 +39,7 @@ import javax.naming.directory.ModificationItem; import javax.naming.directory.SearchControls; import javax.naming.directory.SearchResult;-import javax.naming.ldap.Control;-import javax.naming.ldap.InitialLdapContext;-import javax.naming.ldap.LdapContext;-import javax.naming.ldap.LdapName;-import javax.naming.ldap.PagedResultsControl;-import javax.naming.ldap.PagedResultsResponseControl;+import javax.naming.ldap.*;","Please remove ""star import"". We intentionally want to avoid star imports and have the individual classes mentioned.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6016,287234493,2019-05-24T06:50:43Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/lock/CustomLockService.java,"@@ -78,8 +79,19 @@ public void init() throws DatabaseException {         }  -        if (!isDatabaseChangeLogLockTableInitialized(createdTable)) {+        int rows = numberOfRowsInDatabaseChangeLogLockTable();+        if (rows != DBLockProvider.Namespace.values().length) {             try {+                if (rows > 0) {+                    log.trace(""Deleting rows in Lock Table"");+                    executor.execute(new RawSqlStatement(""DELETE FROM ""","I think deleting rows at this stage is not very good. AFAIR there were issues with that, which were seen with some databases when transaction1 just inserted row and trying to run ""SELECT FOR UPDATE"" on it and transaction2 tried to delete the row at the same time. This is exactly the reason why we need to change the CustomInsertLockRecordGenerator to avoid deletion as it was causing issues with some DBs.I understand why you want to delete the rows - I guess the migration from previous version is also complication as in that case you have just the single row in the table, but not the second. But it will be good if it's done in a way that avoids deletion of rows.",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/6016,287387827,2019-05-24T14:35:10Z,server-spi-private/src/main/java/org/keycloak/models/dblock/DBLockProvider.java,"@@ -27,12 +27,30 @@  */ public interface DBLockProvider extends Provider { +    /**+     * Lock namespace to have different lock types or contexts.+     */+    public enum Namespace {++        GENERAL(1),+        OFFLINE_SESSIONS(1000);++        private final int id;++        private Namespace(int id) {+            this.id = id;+        }++        public int getId() {+            return id;+        }+    };      /**      * Try to retrieve DB lock or wait if retrieve was unsuccessful. Throw exception if lock can't be retrieved within specified timeout (900 seconds by default)+     * @param lock The lock namespace to use      */-    void waitForLock();-+    void waitForLock(Namespace lock);","@mposolda I didn't think about nested locks... But I think that the ""hasLock"" method has the meaning if this node has the lock (previously the only one that was possible). So it should be ""hasLock(Namespace)"" for example is used [here](https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/connections/jpa/DefaultJpaConnectionProviderFactory.java#L330) without specifying any ""waitForLock"" before. Maybe it's better if we add the Namespace to the three methods (waitForLock, releaseLock and hasLock). WDYT?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6076,288272195,2019-05-28T19:46:26Z,testsuite/integration-arquillian/pom.xml,"@@ -534,12 +530,12 @@             </properties>         </profile>         <profile>-            <id>db-allocator-db-oracle11g</id>+            <id>db-allocator-db-oracle12cR1RAC</id>","Shouldn't Keycloak support at least a single non-RAC (non-clustered) Oracle database? I'd like @pdrozd to chime in whether this is intended. (OTOH, I don't mind having oracle12cR1 instead of 11g there in db allocator mode.)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6076,288426703,2019-05-29T07:27:28Z,testsuite/integration-arquillian/pom.xml,"@@ -534,12 +530,12 @@             </properties>         </profile>         <profile>-            <id>db-allocator-db-oracle11g</id>+            <id>db-allocator-db-oracle12cR1RAC</id>","Adding @pdrozd as reviewer of the PR. My hope is to not test/certify with more databases, which we already support right now, but that's maybe just me and I am not the right person to decide this :)",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/6076,288427435,2019-05-29T07:29:51Z,testsuite/integration-arquillian/pom.xml,"@@ -534,12 +530,12 @@             </properties>         </profile>         <profile>-            <id>db-allocator-db-oracle11g</id>+            <id>db-allocator-db-oracle12cR1RAC</id>",I also hope not to add more databases.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5779,288939658,2019-05-30T10:32:02Z,core/src/main/java/org/keycloak/jose/jwe/JWE.java,"@@ -153,6 +151,36 @@ public String encodeJwe() throws JWEException {         }     } +    public String encodeJwe(JWEAlgorithmProvider algorithmProvider, JWEEncryptionProvider encryptionProvider) throws JWEException {","Is it possible to ""merge"" some new methods with existing code to avoid some duplicated code? For example change the existing method JWE.encodeJwe() to just parse the algorithmProvider and encryptionProvider from the header and then delegate to the newly introduced method you introduced ""encodeJwe(JWEAlgorithmProvider algorithmProvider, JWEEncryptionProvider encryptionProvider)"" ?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5779,288939834,2019-05-30T10:32:41Z,core/src/main/java/org/keycloak/jose/jwe/JWE.java,"@@ -192,7 +220,42 @@ public JWE verifyAndDecodeJwe(String jweStr) throws JWEException {              keyStorage.setEncryptionProvider(encryptionProvider); -            byte[] decodedCek = algorithmProvider.decodeCek(Base64Url.decode(base64Cek), keyStorage.getEncryptionKey());+            byte[] decodedCek = algorithmProvider.decodeCek(Base64Url.decode(base64Cek), keyStorage.getDecryptionKey());+            keyStorage.setCEKBytes(decodedCek);++            encryptionProvider.verifyAndDecodeJwe(this);++            return this;+        } catch (Exception e) {+            throw new JWEException(e);+        }+    }++    public JWE verifyAndDecodeJwe(String jweStr, JWEAlgorithmProvider algorithmProvider, JWEEncryptionProvider encryptionProvider) throws JWEException {","Similarly as above, will be nice if existing ""verifyAndDecodeJwe((String jweStr)"" delegates to the new ""verifyAndDecodeJwe(String jweStr, JWEAlgorithmProvider algorithmProvider, JWEEncryptionProvider encryptionProvider)"" to avoid duplicated code as much as possible.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5779,288941455,2019-05-30T10:38:49Z,core/src/main/java/org/keycloak/jose/jwe/enc/AesGcmEncryptionProvider.java,"@@ -0,0 +1,156 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.jose.jwe.enc;++import java.security.GeneralSecurityException;+import java.security.InvalidKeyException;+import java.security.Key;+import java.security.NoSuchAlgorithmException;++import javax.crypto.Cipher;+import javax.crypto.spec.GCMParameterSpec;+import javax.crypto.spec.SecretKeySpec;++import org.keycloak.jose.jwe.JWE;+import org.keycloak.jose.jwe.JWEKeyStorage;+import org.keycloak.jose.jwe.JWEUtils;++public abstract class AesGcmEncryptionProvider implements JWEEncryptionProvider {++    // 96 bits of IV is required+    // Authentication Tag size must be 128 bits+    // https://tools.ietf.org/html/rfc7518#section-5.3+    private static final int AUTH_TAG_SIZE_BYTE = 16;+    private static final int IV_SIZE_BYTE = 12;++    @Override+    public void encodeJwe(JWE jwe) throws Exception {++        byte[] contentBytes = jwe.getContent();++        // IV must be nonce (number used once)+        byte[] initializationVector = JWEUtils.generateSecret(IV_SIZE_BYTE);++        Key aesKey = jwe.getKeyStorage().getCEKKey(JWEKeyStorage.KeyUse.ENCRYPTION, false);+        if (aesKey == null) {+            throw new IllegalArgumentException(""AES CEK key not present"");+        }++        int expectedAesKeyLength = getExpectedAesKeyLength();+        if (expectedAesKeyLength != aesKey.getEncoded().length) {+            throw new IllegalStateException(""Length of aes key should be "" + expectedAesKeyLength +"", but was "" + aesKey.getEncoded().length);+        }++        // https://tools.ietf.org/html/rfc7516#appendix-A.1.5+        byte[] aad = jwe.getBase64Header().getBytes(""UTF-8"");++        byte[] cipherBytes = encryptBytes(contentBytes, initializationVector, aesKey, aad);+        byte[] authenticationTag = getAuthenticationTag(cipherBytes);+        byte[] encryptedContent = getEncryptedContent(cipherBytes);+        jwe.setEncryptedContentInfo(initializationVector, encryptedContent, authenticationTag);++    }++    @Override+    public void verifyAndDecodeJwe(JWE jwe) throws Exception {+        Key aesKey = jwe.getKeyStorage().getCEKKey(JWEKeyStorage.KeyUse.ENCRYPTION, false);+        if (aesKey == null) {+            throw new IllegalArgumentException(""AES CEK key not present"");+        }++        int expectedAesKeyLength = getExpectedAesKeyLength();+        if (expectedAesKeyLength != aesKey.getEncoded().length) {+            throw new IllegalStateException(""Length of aes key should be "" + expectedAesKeyLength +"", but was "" + aesKey.getEncoded().length);+        }++        // https://tools.ietf.org/html/rfc7516#appendix-A.1.5+        byte[] aad = jwe.getBase64Header().getBytes(""UTF-8"");+        byte[] decryptedTargetContent = getAeadDecryptedTargetContent(jwe);+        byte[] contentBytes = decryptBytes(decryptedTargetContent, jwe.getInitializationVector(), aesKey, aad);++        jwe.content(contentBytes);+    }++    private byte[] encryptBytes(byte[] contentBytes, byte[] ivBytes, Key aesKey, byte[] aad) throws GeneralSecurityException {+        Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");","Not sure if we rather want Cipher.getInstance with second argument to be ""BC"" security provider as used for example in AesCbcHmacShaEncryptionProvider? AFAIK that may have bigger probability to avoid issues that some stuff doesn't work as expected on various JVM versions etc.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5779,288944027,2019-05-30T10:48:05Z,core/src/test/java/org/keycloak/jose/JWETest.java,"@@ -233,4 +238,157 @@ public void externalJweAes128KeyWrapTest() throws Exception {      } +    @Test+    public void testRSA1_5_A128GCM() throws Exception {+        testKeyEncryption_ContentEncryptionAesGcm(JWEConstants.RSA1_5, JWEConstants.A128GCM);+    }++    @Test+    public void testRSAOAEP_A128GCM() throws Exception {+        testKeyEncryption_ContentEncryptionAesGcm(JWEConstants.RSA_OAEP, JWEConstants.A128GCM);+    }++    @Test+    public void testRSA1_5_A128CBCHS256() throws Exception {+        testKeyEncryption_ContentEncryptionAesHmacSha(JWEConstants.RSA1_5, JWEConstants.A128CBC_HS256);+    }++    @Test+    public void testRSAOAEP_A128CBCHS256() throws Exception {+        testKeyEncryption_ContentEncryptionAesHmacSha(JWEConstants.RSA_OAEP, JWEConstants.A128CBC_HS256);+    }+ +    private void testKeyEncryption_ContentEncryptionAesGcm(String jweAlgorithmName, String jweEncryptionName) throws Exception {+        // generate key pair for KEK+        KeyPair keyPair = KeyUtils.generateRsaKeyPair(2048);+        JWEAlgorithmProvider jweAlgorithmProvider = new RsaKeyEncryptionJWEAlgorithmProvider(jweAlgorithmName);+        JWEEncryptionProvider jweEncryptionProvider = new AesGcmJWEEncryptionProvider(jweEncryptionName);++        JWEHeader jweHeader = new JWEHeader(jweAlgorithmName, jweEncryptionName, null);+        JWE jwe = new JWE()+                .header(jweHeader)+                .content(PAYLOAD.getBytes(""UTF-8""));++        jwe.getKeyStorage()+                .setEncryptionKey(keyPair.getPublic());++        String encodedContent = jwe.encodeJwe(jweAlgorithmProvider, jweEncryptionProvider);+        System.out.println(""Encoded content: "" + encodedContent);+        System.out.println(""Encoded content length: "" + encodedContent.length());++        jwe = new JWE();+        jwe.getKeyStorage()+                .setDecryptionKey(keyPair.getPrivate());+        jwe.verifyAndDecodeJwe(encodedContent, jweAlgorithmProvider, jweEncryptionProvider);+        String decodedContent = new String(jwe.getContent(), ""UTF-8"");+        System.out.println(""Decoded content: "" + decodedContent);+        System.out.println(""Decoded content length: "" + decodedContent.length());++        Assert.assertEquals(PAYLOAD, decodedContent);+    }++    private void testKeyEncryption_ContentEncryptionAesHmacSha(String jweAlgorithmName, String jweEncryptionName) throws Exception {+        // generate key pair for KEK+        KeyPair keyPair = KeyUtils.generateRsaKeyPair(2048);+        // generate CEK+        final SecretKey aesKey = new SecretKeySpec(AES_128_KEY, ""AES"");+        final SecretKey hmacKey = new SecretKeySpec(HMAC_SHA256_KEY, ""HMACSHA2"");++        JWEAlgorithmProvider jweAlgorithmProvider = new RsaKeyEncryptionJWEAlgorithmProvider(jweAlgorithmName);+        JWEEncryptionProvider jweEncryptionProvider = new AesCbcHmacShaJWEEncryptionProvider(jweEncryptionName);++        JWEHeader jweHeader = new JWEHeader(jweAlgorithmName, jweEncryptionName, null);+        JWE jwe = new JWE()+                .header(jweHeader)+                .content(PAYLOAD.getBytes(""UTF-8""));++        jwe.getKeyStorage()+                .setEncryptionKey(keyPair.getPublic());++        jwe.getKeyStorage()+                .setCEKKey(aesKey, JWEKeyStorage.KeyUse.ENCRYPTION)+                .setCEKKey(hmacKey, JWEKeyStorage.KeyUse.SIGNATURE);++        String encodedContent = jwe.encodeJwe(jweAlgorithmProvider, jweEncryptionProvider);+        System.out.println(""Encoded content: "" + encodedContent);+        System.out.println(""Encoded content length: "" + encodedContent.length());++        jwe = new JWE();+        jwe.getKeyStorage()+            .setDecryptionKey(keyPair.getPrivate());+        jwe.getKeyStorage()+            .setCEKKey(aesKey, JWEKeyStorage.KeyUse.ENCRYPTION)+            .setCEKKey(hmacKey, JWEKeyStorage.KeyUse.SIGNATURE);+        jwe.verifyAndDecodeJwe(encodedContent, jweAlgorithmProvider, jweEncryptionProvider);+        String decodedContent = new String(jwe.getContent(), ""UTF-8"");+        System.out.println(""Decoded content: "" + decodedContent);+        System.out.println(""Decoded content length: "" + decodedContent.length());++        Assert.assertEquals(PAYLOAD, decodedContent);+    }+ +    private class RsaKeyEncryptionJWEAlgorithmProvider extends KeyEncryptionJWEAlgorithmProvider {+        private final String jweAlgorithmName;+        public RsaKeyEncryptionJWEAlgorithmProvider(String jweAlgorithmName) {+            this.jweAlgorithmName = jweAlgorithmName;+        }+        @Override+        protected Cipher getCipherProvider() throws Exception {+            String jcaAlgorithmName = null;+            if (JWEConstants.RSA1_5.equals(jweAlgorithmName)) {","This code snippet is duplicated with some code in RsaCekManagementProvider. Maybe it is possible to have this class RsaKeyEncryptionJWEAlgorithmProvider available as public class in the ""core"" module and remove the class RsaKeyEncryptionJWEAlgorithmProvider you added to the services module? Then RsaCekManagementProvider can just call ""new RsaKeyEncryptionJWEAlgorithmProvider(jweAlgorithmName)""",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6081,289326184,2019-05-31T09:49:34Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/BrokerLinkAndTokenExchangeTest.java,"@@ -736,6 +721,50 @@ private void navigateTo(String uri) {         WaitUtils.waitForPageToLoad();     } -    +    private void checkFeature(int statusCode) throws Exception {+        String accessToken = oauth.doGrantAccessTokenRequest(PARENT_IDP, PARENT2_USERNAME, ""password"", null, PARENT_CLIENT, ""password"").getAccessToken();++        if (statusCode != Response.Status.NOT_IMPLEMENTED.getStatusCode()) {+            Assert.assertEquals(0, adminClient.realm(CHILD_IDP).getClientSessionStats().size());+        }++        Client httpClient = ClientBuilder.newClient();","Closing the client on line 766 would mean that client is closed just if condition on line 750 (if (statusCode != Response.Status.NOT_IMPLEMENTED.getStatusCode())) is true. Maybe will be good to replace with the auto-closeable try block? Something like ""try (Client httpClient = ClientBuilder.newClient()) {"" . That should ensure client always closed.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/5779,296112286,2019-06-21T06:36:03Z,core/src/main/java/org/keycloak/crypto/KeyWrapper.java,"@@ -99,19 +99,19 @@ public void setSecretKey(SecretKey secretKey) {     }      public Key getSignKey() {-        return signKey;+        return privateKey;","IMO, it might be good that KeyWrapper does not provide usage-dependent methods (namely, get/setSignKey(), get/setVerifyKey()).On behalf of them, it provides algorithm-dependent method (namely, get/setPublicKey(), get/setPrivateKey(), get/setSecretKey()).The reason are as follows:1) current KeyWrapper assumes that keys of public key cryptography be used as signing/verifying. But this PR introduces new usage of such keys, namely, encrypting/decrypting.2) On signing/verifying, current KeyWrapper provides  usage-dependent methods for public key cryptography while algorithm-dependent method for shared key cryptography. There is such the difference between algorithms of key.It might be good that the role of  KeyWrapper is treating algorithms of keys while the role of users of KeyWrapper is treating their usage.  (e.g. when encrypting in public key cryptography, the user of KeyWrapper calls KeyWrapper.getPublicKey().when signing in public key cryptography, the user of KeyWrapper calls KeyWrapper.getPrivateKey().when signing in shared key cryptography, the user of KeyWrapper calls KeyWrapper.getSecretKey().)",
6824163,br0xpl,https://api.github.com/repos/keycloak/keycloak/pulls/6115,297345329,2019-06-25T19:00:03Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -1365,39 +1368,6 @@ public static void updateClient(ClientRepresentation rep, ClientModel resource)         resource.updateClient();     } -    public static void updateClientProtocolMappers(ClientRepresentation rep, ClientModel resource) {","This is totally bad.. sorry, it must be some leftover.. the only difference should be the above added lines.. Will fix it in a few minutes.Sorry, I don't know what happened here :-)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5779,297574895,2019-06-26T09:44:18Z,core/src/main/java/org/keycloak/crypto/KeyWrapper.java,"@@ -99,19 +99,19 @@ public void setSecretKey(SecretKey secretKey) {     }      public Key getSignKey() {-        return signKey;+        return privateKey;","I completely agree with that. Just a note that in my comment above, I suggested to remove the get/setSignKey(), get/setVerifyKey() from the KeyWrapper class and replace the existing invocations of those methods in Keycloak codebase with the get/setPublicKey(), get/setPrivateKey() if possible. Do you think you can do it in this PR? Sorry if it was unclear in my previous comment.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5779,297578707,2019-06-26T09:52:37Z,core/src/main/java/org/keycloak/jose/jwk/JWKBuilder.java,"@@ -77,6 +78,13 @@ public JWK rsa(Key key) {         return k;     } +    public JWK rsa(Key key, KeyUse keyUse) {+        JWK k = rsa(key);+        String keyUseString = DEFAULT_PUBLIC_KEY_USE;+        if (KeyUse.ENC == keyUse) keyUseString = ""enc"";","Regarding to what you mentioned, the java constants are usually upper-case. However the option could be to refactor the KeyUse class like this:```public enum KeyUse {        SIG(""sig""),    ENC(""enc"");        private String specName;        KeyUse(String specName) {        this.specName = specName;    }    public String getSpecName() {        return specName;    }}```Then you can ""getSpecName()"" . But if you prefer to not change it this way in this PR, I am fine with the ""toLowerCase"" as well.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6102,298306438,2019-06-27T18:15:18Z,model/jpa/src/main/java/org/keycloak/authorization/jpa/entities/ResourceServerEntity.java,"@@ -66,6 +70,17 @@ public void setPolicyEnforcementMode(PolicyEnforcementMode policyEnforcementMode         this.policyEnforcementMode = policyEnforcementMode;     } +    public void setDecisionStrategy(DecisionStrategy decisionStrategy) {+        if (DecisionStrategy.CONSENSUS.equals(decisionStrategy)) {+            throw new IllegalArgumentException(""Strategy "" + decisionStrategy + "" not supported"");+        }+        this.decisionStrategy = decisionStrategy;+    }",@pedroigor based on the change above. Would make sense to remove CONSENSUS from https://github.com/keycloak/keycloak-documentation/blob/532a46f60f04ef709776d1599359bc9ab24e10a4/authorization_services/topics/policy-aggregated-policy.adoc#decision-strategy-for-aggregated-policies  and https://github.com/keycloak/keycloak-documentation/blob/532a46f60f04ef709776d1599359bc9ab24e10a4/authorization_services/topics/permission-decision-strategy.adoc#policy-decision-strategies ?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6135,299006054,2019-07-01T11:51:28Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties,"@@ -1551,3 +1551,9 @@ tls-client-certificate-bound-access-tokens=OAuth 2.0 Mutual TLS Certificate Boun tls-client-certificate-bound-access-tokens.tooltip=This enables support for OAuth 2.0 Mutual TLS Certificate Bound Access Tokens, which means that keycloak bind an access token and a refresh token with a X.509 certificate of a token requesting client exchanged in mutual TLS between keycloak's Token Endpoint and this client. These tokens can be treated as Holder-of-Key tokens instead of bearer tokens. subjectdn=Subject DN subjectdn-tooltip=A regular expression for validating Subject DN in the Client Certificate. Use ""(.*?)(?:$)"" to match all kind of expressions.++# KEYCLOAK-10747 Explicit Proof Key for Code Exchange Activation Settings+pkce-activation=Proof Key for Code Exchange Activation+pkce-activation.tooltip=If On, keycloak refuses client's authorization request without PKCE's code challenge.+pkce-code-challenge-method=Proof Key for Code Exchange Code Challenge Method","I suggest to not have 2 properties, but have only single property ""Requested PKCE Method"" . It can be empty, plain or S256. In case that empty value is used (which is by default), the PKCE method is not enforced and would be just read from the ""code_challenge_method"" parameter as it is now. It will be good to add this information to the tooltip as well. This will allow us to have one less configuration parameter, which is always better :)",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6135,299256960,2019-07-01T23:47:34Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties,"@@ -1551,3 +1551,9 @@ tls-client-certificate-bound-access-tokens=OAuth 2.0 Mutual TLS Certificate Boun tls-client-certificate-bound-access-tokens.tooltip=This enables support for OAuth 2.0 Mutual TLS Certificate Bound Access Tokens, which means that keycloak bind an access token and a refresh token with a X.509 certificate of a token requesting client exchanged in mutual TLS between keycloak's Token Endpoint and this client. These tokens can be treated as Holder-of-Key tokens instead of bearer tokens. subjectdn=Subject DN subjectdn-tooltip=A regular expression for validating Subject DN in the Client Certificate. Use ""(.*?)(?:$)"" to match all kind of expressions.++# KEYCLOAK-10747 Explicit Proof Key for Code Exchange Activation Settings+pkce-activation=Proof Key for Code Exchange Activation+pkce-activation.tooltip=If On, keycloak refuses client's authorization request without PKCE's code challenge.+pkce-code-challenge-method=Proof Key for Code Exchange Code Challenge Method","Yes, you are right. I'll implement only one configuration parameter as you said.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6135,299257229,2019-07-01T23:48:57Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/clients.js,"@@ -966,6 +966,12 @@ module.controller('ClientDetailCtrl', function($scope, realm, client, flows, $ro         ""request_uri only""     ]; +    // KEYCLOAK-10747 Explicit Proof Key for Code Exchange Activation Settings","I see, I'll get rid of JIRA reference comments from codebase other than arquillian integration test class.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/5779,300198344,2019-07-04T01:02:01Z,core/src/main/java/org/keycloak/jose/jwe/JWE.java,"@@ -192,7 +220,42 @@ public JWE verifyAndDecodeJwe(String jweStr) throws JWEException {              keyStorage.setEncryptionProvider(encryptionProvider); -            byte[] decodedCek = algorithmProvider.decodeCek(Base64Url.decode(base64Cek), keyStorage.getEncryptionKey());+            byte[] decodedCek = algorithmProvider.decodeCek(Base64Url.decode(base64Cek), keyStorage.getDecryptionKey());+            keyStorage.setCEKBytes(decodedCek);++            encryptionProvider.verifyAndDecodeJwe(this);++            return this;+        } catch (Exception e) {+            throw new JWEException(e);+        }+    }++    public JWE verifyAndDecodeJwe(String jweStr, JWEAlgorithmProvider algorithmProvider, JWEEncryptionProvider encryptionProvider) throws JWEException {","I looked into this code and found that my proposed codes just above did not work. At first, it need to parse jose header and construct JWE header. And to avoid duplicate codes, what do you think about the following codes?```java    private String getEncodedJweString() {        StringBuilder builder = new StringBuilder();        builder.append(base64Header).append(""."")                .append(base64Cek).append(""."")                .append(Base64Url.encode(initializationVector)).append(""."")                .append(Base64Url.encode(encryptedContent)).append(""."")                .append(Base64Url.encode(authenticationTag));        return builder.toString();    }    private void setupJWEHeader(String jweStr) throws IllegalStateException {        String[] parts = jweStr.split(""\\."");        if (parts.length != 5) {            throw new IllegalStateException(""Not a JWE String"");        }        this.base64Header = parts[0];        this.base64Cek = parts[1];        this.initializationVector = Base64Url.decode(parts[2]);        this.encryptedContent = Base64Url.decode(parts[3]);        this.authenticationTag = Base64Url.decode(parts[4]);        this.header = getHeader();    }    private JWE getProcessedJWE(JWEAlgorithmProvider algorithmProvider, JWEEncryptionProvider encryptionProvider) throws Exception {        if (algorithmProvider == null) {            throw new IllegalArgumentException(""No provider for alg "");        }        if (encryptionProvider == null) {            throw new IllegalArgumentException(""No provider for enc "");        }        keyStorage.setEncryptionProvider(encryptionProvider);        byte[] decodedCek = algorithmProvider.decodeCek(Base64Url.decode(base64Cek), keyStorage.getDecryptionKey());        keyStorage.setCEKBytes(decodedCek);        encryptionProvider.verifyAndDecodeJwe(this);        return this;    }    public JWE verifyAndDecodeJwe(String jweStr) throws JWEException {        try {            setupJWEHeader(jweStr);            return getProcessedJWE(JWERegistry.getAlgProvider(header.getAlgorithm()), JWERegistry.getEncProvider(header.getEncryptionAlgorithm()));        } catch (Exception e) {            throw new JWEException(e);        }    }    public JWE verifyAndDecodeJwe(String jweStr, JWEAlgorithmProvider algorithmProvider, JWEEncryptionProvider encryptionProvider) throws JWEException {        try {            setupJWEHeader(jweStr);            return getProcessedJWE(algorithmProvider, encryptionProvider);        } catch (Exception e) {            throw new JWEException(e);        }    }```",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/5779,300244985,2019-07-04T06:29:38Z,services/src/main/java/org/keycloak/jose/jws/DefaultTokenManager.java,"@@ -142,4 +155,96 @@ private String getSignatureAlgorithm(String clientAttribute) {         return DEFAULT_ALGORITHM_NAME;     } +    @Override+    public String encodeAndEncrypt(Token token) {+        String encodedToken = encode(token);+        if (isTokenEncyptRequired(token.getCategory())) {+            encodedToken = getEncryptedToken(token.getCategory(), encodedToken);+        }+        return encodedToken;+    }++    private boolean isTokenEncyptRequired(TokenCategory category) {+        if (cekManagementAlgorithm(category) == null) return false;+        if (encryptAlgorithm(category) == null) return false;+        return true;+    }++    private String getEncryptedToken(TokenCategory category, String encodedToken) {+        String encryptedToken = null;++        String algAlgorithm = cekManagementAlgorithm(category);+        String encAlgorithm = encryptAlgorithm(category);++        CekManagementProvider cekManagementProvider = session.getProvider(CekManagementProvider.class, algAlgorithm);+        JWEAlgorithmProvider jweAlgorithmProvider = cekManagementProvider.jweAlgorithmProvider();++        ContentEncryptionProvider contentEncryptionProvider = session.getProvider(ContentEncryptionProvider.class, encAlgorithm);+        JWEEncryptionProvider jweEncryptionProvider = contentEncryptionProvider.jweEncryptionProvider();++        ClientModel client = session.getContext().getClient();++        KeyWrapper keyWrapper = getEncryptionKekWrapper(algAlgorithm, client);+        if (keyWrapper == null) {+            throw new RuntimeException(""can not get encryption KEK"");+        }+        Key encryptionKek = keyWrapper.getPublicKey();+        String encryptionKekId = keyWrapper.getKid();+        try {+            encryptedToken = TokenUtil.jweKeyEncryptionEncode(encryptionKek, encodedToken.getBytes(""UTF-8""), algAlgorithm, encAlgorithm, encryptionKekId, jweAlgorithmProvider, jweEncryptionProvider);+        } catch (JWEException | UnsupportedEncodingException e) {+            throw new RuntimeException(e);+        }+        return encryptedToken;+    }++    private KeyWrapper getEncryptionKekWrapper(String algAlgorithm, ClientModel client) {+        if (algAlgorithm == null) return null;+        switch (algAlgorithm) {","What do you think about the following codes?```java    private KeyWrapper getEncryptionKekWrapper(String algAlgorithm, ClientModel client) {        if (algAlgorithm == null) return null;        List<String> providerIds = new LinkedList<>(session.listProviderIds(CekManagementProvider.class));        if (providerIds.contains(algAlgorithm)) return PublicKeyStorageManager.getClientPublicKeyWrapper(session, client, JWK.Use.ENCRYPTION);        return null;    }```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5779,300297815,2019-07-04T08:55:04Z,services/src/main/java/org/keycloak/jose/jws/DefaultTokenManager.java,"@@ -142,4 +155,96 @@ private String getSignatureAlgorithm(String clientAttribute) {         return DEFAULT_ALGORITHM_NAME;     } +    @Override+    public String encodeAndEncrypt(Token token) {+        String encodedToken = encode(token);+        if (isTokenEncyptRequired(token.getCategory())) {+            encodedToken = getEncryptedToken(token.getCategory(), encodedToken);+        }+        return encodedToken;+    }++    private boolean isTokenEncyptRequired(TokenCategory category) {+        if (cekManagementAlgorithm(category) == null) return false;+        if (encryptAlgorithm(category) == null) return false;+        return true;+    }++    private String getEncryptedToken(TokenCategory category, String encodedToken) {+        String encryptedToken = null;++        String algAlgorithm = cekManagementAlgorithm(category);+        String encAlgorithm = encryptAlgorithm(category);++        CekManagementProvider cekManagementProvider = session.getProvider(CekManagementProvider.class, algAlgorithm);+        JWEAlgorithmProvider jweAlgorithmProvider = cekManagementProvider.jweAlgorithmProvider();++        ContentEncryptionProvider contentEncryptionProvider = session.getProvider(ContentEncryptionProvider.class, encAlgorithm);+        JWEEncryptionProvider jweEncryptionProvider = contentEncryptionProvider.jweEncryptionProvider();++        ClientModel client = session.getContext().getClient();++        KeyWrapper keyWrapper = getEncryptionKekWrapper(algAlgorithm, client);+        if (keyWrapper == null) {+            throw new RuntimeException(""can not get encryption KEK"");+        }+        Key encryptionKek = keyWrapper.getPublicKey();+        String encryptionKekId = keyWrapper.getKid();+        try {+            encryptedToken = TokenUtil.jweKeyEncryptionEncode(encryptionKek, encodedToken.getBytes(""UTF-8""), algAlgorithm, encAlgorithm, encryptionKekId, jweAlgorithmProvider, jweEncryptionProvider);+        } catch (JWEException | UnsupportedEncodingException e) {+            throw new RuntimeException(e);+        }+        return encryptedToken;+    }++    private KeyWrapper getEncryptionKekWrapper(String algAlgorithm, ClientModel client) {+        if (algAlgorithm == null) return null;+        switch (algAlgorithm) {","I am sorry I did not spot this before, but now when thinking about it and looking at it one more, I can see some potential issues with this approach. IMO the possible issue is, that algorithm is not passed to the PublicKeyStorageManager. There can be scenario when the ""jwk"" set returned from the client ""jwks_url"" contains more keys for the KeyUse.ENC for example. In that case, it would be a risk that bad key would be returned for different algorithm that you want. Filtering algorithms this way you did may not be sufficient as there can be keys and all of them could be of the algorithms, which are actually supported by Keycloak. There can be even more keys with the usage of KeyUse.ENC and for the same algorithm. The combination (keyUse, algorithm) is not guaranteed to be unique within JWK Set. Only guaranteed unique thing is ""kid"" AFAIK.I wonder if we can remove method ""getEncryptionKekWrapper(algAlgorithm, client)"" on the DefaultTokenManager class at all. In the method ""getEncryptedToken(TokenCategory category, String encodedToken)"" there can be a possibility to first retrieve ""kid"" from the encoded token? Maybe some more changes will be needed in the class ""JWE"" to achieve this, but I guess this may be possible? I am seeing that retrieving ""kid"" first is done for example in the method ""decode(String token, Class<T> clazz)"", so I hope this may be possible in our case as well. Then we can lookup PublicKeyStorageManager.getClientPublicKeyWrapper by ""kid"". This will actually mean that PR can be simplified if I look correctly as there won't be a need to change anything in the class PublicKeyStorageManager.getClientPublicKeyWrapper and all the related classes used from that. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6122,300311019,2019-07-04T09:24:49Z,services/src/main/java/org/keycloak/broker/oidc/mappers/AbstractClaimMapper.java,"@@ -122,6 +120,12 @@ public boolean valueEquals(String desiredValue, Object value) {             for (Object val : list) {             	if (valueEquals(desiredValue, val)) return true;             }+        } else if (value instanceof JsonNode) {+            try {+                JsonSerialization.readValue(desiredValue, JsonNode.class).equals(value);","Isn't there something missing here? Like: ""if (JsonSerialization.readValue(desiredValue, JsonNode.class).equals(value)) return true"" like in other types? As it is currently, it will always fall to the bottom in case that ""value"" is JsonNode and method will return false always.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/5779,301044271,2019-07-08T11:24:14Z,services/src/main/java/org/keycloak/jose/jws/DefaultTokenManager.java,"@@ -142,4 +155,96 @@ private String getSignatureAlgorithm(String clientAttribute) {         return DEFAULT_ALGORITHM_NAME;     } +    @Override+    public String encodeAndEncrypt(Token token) {+        String encodedToken = encode(token);+        if (isTokenEncyptRequired(token.getCategory())) {+            encodedToken = getEncryptedToken(token.getCategory(), encodedToken);+        }+        return encodedToken;+    }++    private boolean isTokenEncyptRequired(TokenCategory category) {+        if (cekManagementAlgorithm(category) == null) return false;+        if (encryptAlgorithm(category) == null) return false;+        return true;+    }++    private String getEncryptedToken(TokenCategory category, String encodedToken) {+        String encryptedToken = null;++        String algAlgorithm = cekManagementAlgorithm(category);+        String encAlgorithm = encryptAlgorithm(category);++        CekManagementProvider cekManagementProvider = session.getProvider(CekManagementProvider.class, algAlgorithm);+        JWEAlgorithmProvider jweAlgorithmProvider = cekManagementProvider.jweAlgorithmProvider();++        ContentEncryptionProvider contentEncryptionProvider = session.getProvider(ContentEncryptionProvider.class, encAlgorithm);+        JWEEncryptionProvider jweEncryptionProvider = contentEncryptionProvider.jweEncryptionProvider();++        ClientModel client = session.getContext().getClient();++        KeyWrapper keyWrapper = getEncryptionKekWrapper(algAlgorithm, client);+        if (keyWrapper == null) {+            throw new RuntimeException(""can not get encryption KEK"");+        }+        Key encryptionKek = keyWrapper.getPublicKey();+        String encryptionKekId = keyWrapper.getKid();+        try {+            encryptedToken = TokenUtil.jweKeyEncryptionEncode(encryptionKek, encodedToken.getBytes(""UTF-8""), algAlgorithm, encAlgorithm, encryptionKekId, jweAlgorithmProvider, jweEncryptionProvider);+        } catch (JWEException | UnsupportedEncodingException e) {+            throw new RuntimeException(e);+        }+        return encryptedToken;+    }++    private KeyWrapper getEncryptionKekWrapper(String algAlgorithm, ClientModel client) {+        if (algAlgorithm == null) return null;+        switch (algAlgorithm) {","I see and agree that using ""kid"" is not very ideal though. Will be good to use the ""alg"" + ""enc"" combination as you proposed. Will be probably good to add some more new methods, for example add new method to PublicKeyStorageProvider, which will avoid to pass null ""kid"" as an argument. So maybe something along the lines PublicKeyStorageProvider.getFirstPublicKey(modelKey, algorithm, loader); OR PublicKeyStorageProvider.getFirstPublicKey(modelKey, KeyUse.ENC, algorithm, loader); ?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/5779,301439672,2019-07-09T07:45:42Z,services/src/main/java/org/keycloak/jose/jws/DefaultTokenManager.java,"@@ -142,4 +155,96 @@ private String getSignatureAlgorithm(String clientAttribute) {         return DEFAULT_ALGORITHM_NAME;     } +    @Override+    public String encodeAndEncrypt(Token token) {+        String encodedToken = encode(token);+        if (isTokenEncyptRequired(token.getCategory())) {+            encodedToken = getEncryptedToken(token.getCategory(), encodedToken);+        }+        return encodedToken;+    }++    private boolean isTokenEncyptRequired(TokenCategory category) {+        if (cekManagementAlgorithm(category) == null) return false;+        if (encryptAlgorithm(category) == null) return false;+        return true;+    }++    private String getEncryptedToken(TokenCategory category, String encodedToken) {+        String encryptedToken = null;++        String algAlgorithm = cekManagementAlgorithm(category);+        String encAlgorithm = encryptAlgorithm(category);++        CekManagementProvider cekManagementProvider = session.getProvider(CekManagementProvider.class, algAlgorithm);+        JWEAlgorithmProvider jweAlgorithmProvider = cekManagementProvider.jweAlgorithmProvider();++        ContentEncryptionProvider contentEncryptionProvider = session.getProvider(ContentEncryptionProvider.class, encAlgorithm);+        JWEEncryptionProvider jweEncryptionProvider = contentEncryptionProvider.jweEncryptionProvider();++        ClientModel client = session.getContext().getClient();++        KeyWrapper keyWrapper = getEncryptionKekWrapper(algAlgorithm, client);+        if (keyWrapper == null) {+            throw new RuntimeException(""can not get encryption KEK"");+        }+        Key encryptionKek = keyWrapper.getPublicKey();+        String encryptionKekId = keyWrapper.getKid();+        try {+            encryptedToken = TokenUtil.jweKeyEncryptionEncode(encryptionKek, encodedToken.getBytes(""UTF-8""), algAlgorithm, encAlgorithm, encryptionKekId, jweAlgorithmProvider, jweEncryptionProvider);+        } catch (JWEException | UnsupportedEncodingException e) {+            throw new RuntimeException(e);+        }+        return encryptedToken;+    }++    private KeyWrapper getEncryptionKekWrapper(String algAlgorithm, ClientModel client) {+        if (algAlgorithm == null) return null;+        switch (algAlgorithm) {","I agree with your idea saying that method's name (`getFirstPublicKey`) explicitly tell its behavior (if multiple client public key are found, first one is retrieved).I think PublicKeyStorageProvider.getFirstPublicKey(modelKey, algorithm, loader) seems better.the reasons are as follows :* JWK's ""alg"" implicitly determines ""use"" (e.g. ""alg"" = ""RSA-OAEP"" implies ""use""=""enc"", ""alg"" = ""RS256"" implies ""use""=""sig"") that means specifying usage of key in .getFirstPublicKey() seems redundant.* Looking into `PublicKeyStorageManager.getClientPublicKeyWrapper(KeycloakSession session, ClientModel client, JWK.Use keyUse)` and `ClientPublicKeyLoader`, the loaded client public keys have already filtered out by key usage (if key use = ""enc"", only client public keys with ""use"" = ""enc"" are loaded). Therefore, it seems that no need to considering ""use"" when calling PublicKeyStorageProvider.getFirstPublicKey().```java    // Algorithm need to be specified    public static KeyWrapper getClientPublicKeyWrapper(KeycloakSession session, ClientModel client, JWK.Use keyUse, String algAlgorithm) {        PublicKeyStorageProvider keyStorage = session.getProvider(PublicKeyStorageProvider.class);        String modelKey = PublicKeyStorageUtils.getClientModelCacheKey(client.getRealm().getId(), client.getId(), keyUse);        // here client's pubic keys are loaded and filtered out by key usage        ClientPublicKeyLoader loader = new ClientPublicKeyLoader(session, client, keyUse);        // here only need to consider algorithm        return keyStorage.getFirstPublicKey(modelKey, algAlgorithm, loader);    }```What do you think about it?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6127,303603658,2019-07-15T19:43:55Z,server-spi-private/src/main/java/org/keycloak/models/session/PersistentUserSessionAdapter.java,"@@ -268,6 +275,9 @@ public int hashCode() {         @JsonProperty(""ipAddress"")         private String ipAddress; +        @JsonProperty(""deviceInfo"")+        private DeviceInfo device;","For example here. If this is kept inside `notes`, there is no need to change this inner class.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6127,303603780,2019-07-15T19:44:17Z,server-spi-private/src/main/java/org/keycloak/models/session/PersistentUserSessionAdapter.java,"@@ -145,6 +147,11 @@ public String getIpAddress() {         return getData().getIpAddress();     } +    @Override+    public DeviceInfo getDeviceInfo() {","For example here. If this is kept inside `notes`, there is no need to change this class.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6024,304569584,2019-07-17T18:05:11Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/clients.js,"@@ -758,6 +758,65 @@ module.controller('ClientRoleDetailCtrl', function($scope, realm, client, role,  }); +module.controller('ClientRoleMembersCtrl', function($scope, realm, client, role, ClientRoleMembership, Dialog, Notifications, $location) {+    $scope.realm = realm;+    $scope.page = 0;+    $scope.role = role;+    $scope.client = client;++    $scope.query = {+        realm: realm.realm,+        role: role.name,+        client: client.id,+        max : 5,+        first : 0+    }+","@unly, can you take a look at this?  I think it might be some dead code we can get rid of.I don't see any ""remove"" functionality on the screen.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6176,304831829,2019-07-18T09:51:40Z,services/src/main/java/org/keycloak/services/resources/LoginActionsService.java,"@@ -988,7 +991,12 @@ public void ignore() {           Response response;-        provider.processAction(context);+        +        if (isCancelAppInitiatedAction(authSession, context)) {+            context.failure();","I like the idea of having LoginActionsService handle the cancel rather than require all actions to do it, but there may be a need to have cancel handled by the action itself. It may add something temporary to the user, session, or something that should be cleared. Perhaps we should add a cancel method to required actions with a default empty implementation?",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6176,304838388,2019-07-18T10:07:26Z,themes/src/main/resources/theme/base/login/login-config-totp.ftl,"@@ -58,7 +58,12 @@             <#if mode??><input type=""hidden"" id=""mode"" name=""mode"" value=""${mode}""/></#if>         </div> -        <input class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}"" type=""submit"" value=""${msg(""doSubmit"")}""/>+        <#if isAppInitiatedAction??>+        <input class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}"" type=""submit"" value=""${msg(""doSubmit"")}"" />",Why is the submit button duplicated? Isn't it better to just wrap the cancel button with isAppInitated?,X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6114,304989884,2019-07-18T15:45:49Z,services/src/main/java/org/keycloak/services/resources/admin/GroupsResource.java,"@@ -77,17 +78,37 @@ public GroupsResource(RealmModel realm, KeycloakSession session, AdminPermission                                                @QueryParam(""max"") Integer maxResults) {         auth.groups().requireList(); -        List<GroupRepresentation> results;+        List<GroupModel> results; +        /**+         * For now fetching (as in UsersResource) all groups and filtering in Java+         * TODO: IMHO we should consider different pagination technique:+         * (1) REST return filtered results (in some cases even epty page) and JS+         * client retrieves next pages until it gets all page of results or reaches the end of list+         * (2) or we fetch results in backend page by page until we get all required results.+         */         if (Objects.nonNull(search)) {-            results = ModelToRepresentation.searchForGroupByName(realm, search.trim(), firstResult, maxResults);-        } else if(Objects.nonNull(firstResult) && Objects.nonNull(maxResults)) {-            results = ModelToRepresentation.toGroupHierarchy(realm, false, firstResult, maxResults);+            results = realm.searchForGroupByName(search.trim(),null, null);","@br0xpl, another option would be:* Check if the user has permissions to view groups (granted by view-users or manage-users)* If not, obtain the groups that have permission enabled and return those that the user can view* You can then use the list of groups to filter the results when searching by nameLook at this code in users https://github.com/keycloak/keycloak/blob/b4b3527df7656bfaaee351ec414e56c683c134c2/services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java#L239. We set the list of groups that the user has view permission in the `KeycloakSession`. Then we use this list to filter results in the database.You should also consider filtering top level groups. Just like it is done today.",
6824163,br0xpl,https://api.github.com/repos/keycloak/keycloak/pulls/6114,306685823,2019-07-24T08:25:02Z,services/src/main/java/org/keycloak/services/resources/admin/GroupsResource.java,"@@ -77,17 +78,37 @@ public GroupsResource(RealmModel realm, KeycloakSession session, AdminPermission                                                @QueryParam(""max"") Integer maxResults) {         auth.groups().requireList(); -        List<GroupRepresentation> results;+        List<GroupModel> results; +        /**+         * For now fetching (as in UsersResource) all groups and filtering in Java+         * TODO: IMHO we should consider different pagination technique:+         * (1) REST return filtered results (in some cases even epty page) and JS+         * client retrieves next pages until it gets all page of results or reaches the end of list+         * (2) or we fetch results in backend page by page until we get all required results.+         */         if (Objects.nonNull(search)) {-            results = ModelToRepresentation.searchForGroupByName(realm, search.trim(), firstResult, maxResults);-        } else if(Objects.nonNull(firstResult) && Objects.nonNull(maxResults)) {-            results = ModelToRepresentation.toGroupHierarchy(realm, false, firstResult, maxResults);+            results = realm.searchForGroupByName(search.trim(),null, null);","@pedroigor , @mposolda : I've fixed it according to your description - please see it. I've used the getGroupsWithViewPermission function of GroupPermissions but I have a doubt about it's behaviour, see here:https://github.com/keycloak/keycloak/blob/b4b3527df7656bfaaee351ec414e56c683c134c2/services/src/main/java/org/keycloak/services/resources/admin/permissions/GroupPermissions.java#L306-L329and line 323 - it is checking if user has manage **_members** or view **_members** permission. Shouldn't it be checking if user has view or manage permission for that group? The function name suggest just ""view"", not view_members..? Seems we need to either change function name and create another function with view or we need to change this function?",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6176,307458508,2019-07-25T19:12:49Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/AppInitiatedActionCancelTest.java,"@@ -0,0 +1,61 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.actions;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Test;+import org.keycloak.models.UserModel;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.testsuite.pages.LoginUpdateProfileEditUsernameAllowedPage;++/**+ * Test makes sure that sending a cancel signal does not remove a non-AIA+ * required action+ *+ * @author Stan Silvert+ */+public class AppInitiatedActionCancelTest extends AbstractAppInitiatedActionTest {+    +    @Page+    protected LoginUpdateProfileEditUsernameAllowedPage updateProfilePage;+    +    public AppInitiatedActionCancelTest() {+        super(""update_profile"");+    }+    +    @Override+    public void configureTestRealm(RealmRepresentation testRealm) {+        ActionUtil.addRequiredActionForUser(testRealm, ""test-user@localhost"", UserModel.RequiredAction.UPDATE_PROFILE.name());+    }+    +    @Test+    // Verify that sending a ""cancel"" does not remove the required action.+    public void cancelUpdateProfile() {+        doAIA();+        loginPage.login(""test-user@localhost"", ""password"");+        updateProfilePage.assertCurrent();+        updateProfilePage.cancel();+        assertRedirectSuccess();","I implemented this.  It only works for OIDC, not SAML.Also, I added a silent mode.  This is needed because the OIDC error message screws up the URL.  For the account console, this looks really bad.  So I give the option to not add the message in case of cancel.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6207,310427300,2019-08-05T03:17:37Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/openshift/OpenShiftTokenReviewEndpointTest.java,"@@ -220,13 +227,9 @@ public void emptyScope() {         ClientRepresentation clientRep = testRealm().clients().findByClientId(""test-app"").get(0);          List<String> scopes = new LinkedList<>();-        for (ClientScopeRepresentation s : testRealm().clients().get(clientRep.getId()).getDefaultClientScopes()) {","When refactoring these tests, use `ClientAttributeUpdater` instead of rewriting the try-finally. See https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountFormServiceTest.java#L1082-L1087",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6217,310622409,2019-08-05T14:07:15Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -98,4 +98,19 @@      void preRemove(RealmModel realm, ComponentModel component); +    default List<DeviceModel> getDevices(UserModel user) {","Good point. A specific interface looks better for me too. Just like we have for query, lookup, registration, etc.Just noticed that this should be similar to what I did to federated storage, where I'm using a specific interface.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6223,311107615,2019-08-06T14:51:22Z,services/src/test/java/org/keycloak/vault/PlainTextVaultProviderFactoryTest.java,"@@ -0,0 +1,124 @@+package org.keycloak.vault;++import org.junit.Test;+import org.keycloak.Config;++import static org.junit.Assert.*;++/**+ * Tests for {@link PlainTextVaultProviderFactory}.+ *+ * @author Sebastian askawiec+ */+public class PlainTextVaultProviderFactoryTest {++    @Test+    public void shouldInitializeVaultCorrectly() {+        //given+        VaultConfig config = new VaultConfig(Scenario.EXISTING.getAbsolutePathAsString(), Boolean.FALSE);+        PlainTextVaultProviderFactory factory = new PlainTextVaultProviderFactory();++        //when+        factory.init(config);+        VaultProvider provider = factory.create(null);++        //then+        assertNotNull(provider);+    }++    @Test+    public void shouldThrowAnExceptionWhenTryingToCreateProviderOnDisabledFactory() {","For expected exceptions, use `@Rule ExpectedException` instead. See e.g. https://github.com/keycloak/keycloak/blob/6.0.0/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/group/GroupTest.java#L79",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6225,311518553,2019-08-07T12:13:53Z,services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java,"@@ -585,7 +585,7 @@ public Response processPasswordUpdate(final MultivaluedMap<String, String> formD             ServicesLogger.LOGGER.failedToUpdatePassword(me);             setReferrerOnPage();             errorEvent.detail(Details.REASON, me.getMessage()).error(Errors.PASSWORD_REJECTED);-            return account.setError(Response.Status.INTERNAL_SERVER_ERROR, me.getMessage(), me.getParameters()).createResponse(AccountPages.PASSWORD);+            return account.setError(Response.Status.OK, me.getMessage(), me.getParameters()).createResponse(AccountPages.PASSWORD);","I am not sure about status OK, could it be changed to BAD_REQUEST similarly like in the previous block of read-only error?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6222,311530829,2019-08-07T12:43:07Z,travis-run-tests.sh,"@@ -39,6 +39,13 @@ function should-tests-run-crossdc-adapter() {     should-tests-run-crossdc-server } +function should-tests-run-adapter-tests-authz() {","@abstractj There is some bash ""reflection"" magic used in the script. If there is function like ""should-tests-run-foo"", it can be used to skip the group called ""foo"". See https://github.com/keycloak/keycloak/blob/master/travis-run-tests.sh#L47",
28707619,farmersmurf,https://api.github.com/repos/keycloak/keycloak/pulls/6225,311531367,2019-08-07T12:44:27Z,services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java,"@@ -585,7 +585,7 @@ public Response processPasswordUpdate(final MultivaluedMap<String, String> formD             ServicesLogger.LOGGER.failedToUpdatePassword(me);             setReferrerOnPage();             errorEvent.detail(Details.REASON, me.getMessage()).error(Errors.PASSWORD_REJECTED);-            return account.setError(Response.Status.INTERNAL_SERVER_ERROR, me.getMessage(), me.getParameters()).createResponse(AccountPages.PASSWORD);+            return account.setError(Response.Status.OK, me.getMessage(), me.getParameters()).createResponse(AccountPages.PASSWORD);","Hi, Sounds good, as that could be handled better than a 500. Is it a bad request if the validation policy is wrong. I was assuming the request itself was ok, but just that the policy validation didn't match the rulesHappy to update the PR to BAD_REQUEST once I test it locally ",X
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/6210,311973972,2019-08-08T10:55:09Z,services/src/main/java/org/keycloak/vault/DefaultVaultRawSecret.java,"@@ -0,0 +1,49 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.vault;++import java.util.Optional;+import java.util.concurrent.ThreadLocalRandom;++/**+ * Default raw secret implementation for {@code byte[]}.+ * @author hmlnarik+ */+public class DefaultVaultRawSecret implements VaultRawSecret {++    private final Optional<byte[]> rawSecret;","In general, I don't like `Optional`s as field. We've had a lengthy discussion about them in Infinispan. A very quick summary is the following:- `Optional`s don't implement `Serializable`, their intention is to be used as a return type, not as a field.- `Optional`s used as fields are extremely likely (unless you're using non-standard JVM parameters) to be JIT'ted out. The C2 compiler eliminates even the object creation.- When you use `Optional` as a field, it's very likely that it will cost you at least an object allocation. The `Optional` object will stay there until it's `reachable` from GC perspective. Of course, if we assume that `DefaultVaultRawSecret` is a short-lived object, that doesn't apply here.Of course, I'm not insisting to change it here (I've taken part in a flame war around `Optional`s once and I'm not doing this again). I can give you some links if you wish but the `Optional` was often turns into `tabs vs spaces`-type of war.But as a final thought - you do check if the `Optional` is present and then if the `buffer` is not null, which would get even simpler is the `buffer` was just a nullable `byte[]`.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6217,312535158,2019-08-09T15:32:43Z,server-spi-private/src/main/java/org/keycloak/device/DeviceActivityManager.java,"@@ -0,0 +1,215 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.device;++import java.io.IOException;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.common.Profile;+import org.keycloak.models.DeviceModel;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserDeviceStore;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserProvider;+import org.keycloak.models.UserSessionModel;+import ua_parser.Client;+import ua_parser.Parser;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DeviceActivityManager {++    private static final Parser parser;+    +    static {+        try {+            parser = new Parser();+        } catch (IOException cause) {+            throw new RuntimeException(""Failed to create user agent parser"", cause);+        }+    }+    +    private static final Logger logger = Logger.getLogger(DeviceActivityManager.class);+    private static final int USER_AGENT_MAX_LENGTH = 512;+    private static final String DEVICE_UPDATED_FLAG = ""DEVICE_UPDATED"";++    public static void createOrUpdateDevice(UserSessionModel userSession, KeycloakSession session) {+        if (!Profile.isFeatureEnabled(Profile.Feature.DEVICE_ACTIVITY)) {+            return;+        } +        UserDeviceStore deviceProvider = getDeviceProvider(session);+        +        if (deviceProvider == null) {+            return;+        }+        +        UserModel user = userSession.getUser();+        +        if (user == null) {+            return;+        }+        +        if (session.getAttribute(DEVICE_UPDATED_FLAG) == null) {+            DeviceModel current = getCurrentDevice(session);++            if (current != null) {+                DeviceModel device = getUserDevice(userSession, current, deviceProvider);++                if (device == null) {+                    registerDevice(userSession, current, deviceProvider);+                } else {+                    updateDevice(userSession, current, device, deviceProvider);+                }++                session.setAttribute(DEVICE_UPDATED_FLAG, true);+            }+        }+    }+    +    private static UserDeviceStore getDeviceProvider(KeycloakSession session) {+        UserProvider userProvider = session.users();++        if (userProvider instanceof UserDeviceStore) {+            return (UserDeviceStore) userProvider;+        }++        return null;+    }++    private static DeviceModel getUserDevice(UserSessionModel userSession, DeviceModel current, UserDeviceStore deviceProvider) {+        List<DeviceModel> devices = deviceProvider.getDevices(userSession.getUser());++        if (devices.isEmpty()) {+            return null;+        }++        String attached = userSession.getNote(DeviceModel.DEVICE_ID);++        if (attached != null) {+            DeviceModel device = deviceProvider.getDeviceById(userSession.getUser(), attached);++            if (device != null) {+                // TODO: if current device is different than the one associated with the session, we just return what is in session. ","IMO that's ok as you pointed on the ML. But I would add some more trace logging for various ""if"" branches to have some more logging available in case of troubleshooting etc. But not a big deal.",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/6223,312804734,2019-08-12T07:39:17Z,services/src/main/java/org/keycloak/vault/PlainTextVaultProvider.java,"@@ -0,0 +1,59 @@+package org.keycloak.vault;++import org.jboss.logging.Logger;++import java.io.IOException;+import java.io.InputStream;+import java.lang.invoke.MethodHandles;+import java.nio.file.Files;+import java.nio.file.Path;+import java.nio.file.Paths;+import java.util.Optional;++/**+ * A text-based vault provider, which stores each secret in a separate file. The file name needs to match a+ * vault secret id (or a key for short). A typical vault directory layout looks like this:+ * <pre>+ *     ${VAULT}/key1 (contains secret for key 1)+ *     ${VAULT}/key2 (contains secret for key 2)+ *     etc...+ * </pre>+ * This kind of layout is used by Kubernetes by default (when mounting a volume into the pod).+ * See https://kubernetes.io/docs/concepts/configuration/secret/+ *+ * @author Sebastian askawiec+ */+public class PlainTextVaultProvider implements VaultProvider {++    private static final Logger logger = Logger.getLogger(MethodHandles.lookup().lookupClass());++    private final Path vaultPath;++    public PlainTextVaultProvider(Path path) {+        vaultPath = path;+        logger.debugf(""PlainTextVaultProvider will operate in %s directory"", vaultPath.toAbsolutePath().toString());+    }++    @Override+    public Optional<byte[]> obtainSecret(String vaultSecretId) {+        Path secretPath = vaultPath.resolve(Paths.get(vaultSecretId));+        if (!Files.exists(secretPath)) {+            return Optional.empty();+        }++        try {+            try(InputStream is = Files.newInputStream(secretPath)) {","> The double try block is not necessary, they can be squashed into a single try-catch with resourcesFixed.> Also prefer memory-mapped file access to file input stream. See e.g. https://www.baeldung.com/java-mapped-byte-bufferThat sounds like a good idea. Nevertheless, I have never used it so please give a day or two to experiment with it. I'd like to take a couple of heapdumps and play with them. In the meantime I just rebased my implementation on top of the latest changes.",X
28707619,farmersmurf,https://api.github.com/repos/keycloak/keycloak/pulls/6225,312867042,2019-08-12T10:48:52Z,services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java,"@@ -585,7 +585,7 @@ public Response processPasswordUpdate(final MultivaluedMap<String, String> formD             ServicesLogger.LOGGER.failedToUpdatePassword(me);             setReferrerOnPage();             errorEvent.detail(Details.REASON, me.getMessage()).error(Errors.PASSWORD_REJECTED);-            return account.setError(Response.Status.INTERNAL_SERVER_ERROR, me.getMessage(), me.getParameters()).createResponse(AccountPages.PASSWORD);+            return account.setError(Response.Status.OK, me.getMessage(), me.getParameters()).createResponse(AccountPages.PASSWORD);",Hi @mposolda didn't hear anything back. I tried changing the value you recommended but it didn't work. The response was unrendered suggesting that the bad request isn't handled by the ui.,
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/6223,312903146,2019-08-12T12:39:26Z,services/src/main/java/org/keycloak/vault/PlainTextVaultProvider.java,"@@ -0,0 +1,62 @@+package org.keycloak.vault;++import org.jboss.logging.Logger;++import java.io.IOException;+import java.io.InputStream;+import java.lang.invoke.MethodHandles;+import java.nio.file.Files;+import java.nio.file.Path;+import java.nio.file.Paths;++/**+ * A text-based vault provider, which stores each secret in a separate file. The file name needs to match a+ * vault secret id (or a key for short). A typical vault directory layout looks like this:+ * <pre>+ *     ${VAULT}/key1 (contains secret for key 1)+ *     ${VAULT}/key2 (contains secret for key 2)+ *     etc...+ * </pre>+ * This kind of layout is used by Kubernetes by default (when mounting a volume into the pod).+ * See https://kubernetes.io/docs/concepts/configuration/secret/+ *+ * @author Sebastian askawiec+ */+public class PlainTextVaultProvider implements VaultProvider {++    private static final Logger logger = Logger.getLogger(MethodHandles.lookup().lookupClass());++    private final Path vaultPath;++    public PlainTextVaultProvider(Path path) {+        vaultPath = path;+        logger.debugf(""PlainTextVaultProvider will operate in %s directory"", vaultPath.toAbsolutePath().toString());+    }++    @Override+    public VaultRawSecret obtainSecret(String vaultSecretId) {+        Path secretPath = vaultPath.resolve(Paths.get(vaultSecretId));+        if (!Files.exists(secretPath)) {+            //FIXME: I'm not sure if this distinguishes empty and non-existing secret enough.+            //       Maybe, VaultProvider should have the following signature:+            //       Optional<VaultRawSecret> obtainSecret(String vaultSecretId);+            //       Or another idea is that VaultRawSecret would have a methods:+            //       - #isEmpty() - true if the secret was created from byte[0]+            //       - #exists() - true if the secret simply doesn't exist+            return DefaultVaultRawSecret.empty();","Ok, sorry my bad. I misinterpreted the API. Now it should be better.",
6824163,br0xpl,https://api.github.com/repos/keycloak/keycloak/pulls/6114,313131049,2019-08-12T21:13:07Z,services/src/main/java/org/keycloak/services/resources/admin/GroupsResource.java,"@@ -118,14 +140,20 @@ public GroupResource getGroupById(@PathParam(""id"") String id) {     @Produces(MediaType.APPLICATION_JSON)     public Map<String, Long> getGroupCount(@QueryParam(""search"") String search,",Thanks. I've updated the count method similarily to the other method.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6217,313584572,2019-08-13T19:57:21Z,server-spi-private/src/main/java/org/keycloak/device/DeviceActivityManager.java,"@@ -0,0 +1,215 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.device;++import java.io.IOException;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.common.Profile;+import org.keycloak.models.DeviceModel;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserDeviceStore;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserProvider;+import org.keycloak.models.UserSessionModel;+import ua_parser.Client;+import ua_parser.Parser;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DeviceActivityManager {++    private static final Parser parser;+    +    static {+        try {+            parser = new Parser();+        } catch (IOException cause) {+            throw new RuntimeException(""Failed to create user agent parser"", cause);+        }+    }+    +    private static final Logger logger = Logger.getLogger(DeviceActivityManager.class);+    private static final int USER_AGENT_MAX_LENGTH = 512;+    private static final String DEVICE_UPDATED_FLAG = ""DEVICE_UPDATED"";++    public static void createOrUpdateDevice(UserSessionModel userSession, KeycloakSession session) {+        if (!Profile.isFeatureEnabled(Profile.Feature.DEVICE_ACTIVITY)) {+            return;+        } +        UserDeviceStore deviceProvider = getDeviceProvider(session);+        +        if (deviceProvider == null) {+            return;+        }+        +        UserModel user = userSession.getUser();+        +        if (user == null) {+            return;+        }+        +        if (session.getAttribute(DEVICE_UPDATED_FLAG) == null) {+            DeviceModel current = getCurrentDevice(session);++            if (current != null) {+                DeviceModel device = getUserDevice(userSession, current, deviceProvider);++                if (device == null) {+                    registerDevice(userSession, current, deviceProvider);+                } else {+                    updateDevice(userSession, current, device, deviceProvider);+                }++                session.setAttribute(DEVICE_UPDATED_FLAG, true);+            }+        }+    }+    +    private static UserDeviceStore getDeviceProvider(KeycloakSession session) {+        UserProvider userProvider = session.users();++        if (userProvider instanceof UserDeviceStore) {+            return (UserDeviceStore) userProvider;+        }++        return null;+    }++    private static DeviceModel getUserDevice(UserSessionModel userSession, DeviceModel current, UserDeviceStore deviceProvider) {+        List<DeviceModel> devices = deviceProvider.getDevices(userSession.getUser());++        if (devices.isEmpty()) {+            return null;+        }++        String attached = userSession.getNote(DeviceModel.DEVICE_ID);++        if (attached != null) {+            DeviceModel device = deviceProvider.getDeviceById(userSession.getUser(), attached);++            if (device != null) {+                // TODO: if current device is different than the one associated with the session, we just return what is in session. +                //  See how to handle this situation+                return device; +            }+        } else {+            for (DeviceModel existing : devices) {+                if (isSameDevice(userSession, current, existing)) {+                    return existing;+                }+            }+        }++        return null;+    }++    private static void registerDevice(UserSessionModel userSession, DeviceModel current, UserDeviceStore deviceProvider) {+        current.setSession(userSession.getId());+        deviceProvider.addDevice(userSession.getRealm(), userSession.getUser(), current);+        if (userSession.getNote(DeviceModel.DEVICE_ID) == null) {+            userSession.setNote(DeviceModel.DEVICE_ID, current.getId());+        }+    }++    private static void updateDevice(UserSessionModel userSession, DeviceModel current, DeviceModel device, UserDeviceStore deviceProvider) {+        if (!device.getBrowser().contains(current.getBrowser())) {+            device.addBrowser(current.getBrowser());+        }+        device.setIp(current.getIp());","Sounds interesting. Currently, you have a write whenever the device's `lastAccess` differs from the session it is attached to. For regular sessions, that means writing to the DB every time you set the last session refresh. I've looked at how you did for offline sessions and I think we can have a similar solution and avoid this problem.In addition to `lastAccess` we also update the IP address and the browser. But these are only updated when they actually change, not every time. So I think we can keep them that way and focus on avoiding the `lastAccess` problem. WDYT ?In any case, I'll be working now with the cache layer.",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/6223,313885487,2019-08-14T13:52:25Z,services/src/main/java/org/keycloak/vault/PlainTextVaultProvider.java,"@@ -0,0 +1,84 @@+package org.keycloak.vault;++import org.jboss.logging.Logger;++import javax.annotation.Nonnull;+import java.io.IOException;+import java.lang.invoke.MethodHandles;+import java.nio.MappedByteBuffer;+import java.nio.channels.FileChannel;+import java.nio.file.Files;+import java.nio.file.Path;+import java.nio.file.StandardOpenOption;+import java.util.EnumSet;+import java.util.Optional;+import java.util.function.BiFunction;++/**+ * A text-based vault provider, which stores each secret in a separate file. The file name needs to match a+ * vault secret id (or a key for short). A typical vault directory layout looks like this:+ * <pre>+ *     ${VAULT}/realma__key1 (contains secret for key 1)+ *     ${VAULT}/realma__key2 (contains secret for key 2)+ *     etc...+ * </pre>+ * Note, that each key needs is prefixed by realm name. This kind of layout is used by Kubernetes by default+ * (when mounting a volume into the pod).+ *+ * See https://kubernetes.io/docs/concepts/configuration/secret/+ * See https://github.com/keycloak/keycloak-community/blob/master/design/secure-credentials-store.md#plain-text-file-per-secret-kubernetes--openshift+ *+ * @author Sebastian askawiec+ */+public class PlainTextVaultProvider implements VaultProvider {++    private static final Logger logger = Logger.getLogger(MethodHandles.lookup().lookupClass());++    private final Path vaultPath;+    private final BiFunction<Path, String, Path> secretMappingFunction;++    /**+     * Creates a new {@link PlainTextVaultProvider}.+     *+     * @param path A path to a vault. Can not be null.+     * @param realmName A realm name. Can not be null.+     */+    public PlainTextVaultProvider(@Nonnull Path path, @Nonnull String realmName) {+        vaultPath = path;+        secretMappingFunction = (vaultDirectory, secretId) -> vaultDirectory.resolve(realmName + ""__"" + secretId);","> a) Is the anonymous method really necessary here for the initial implementation? Why not use simple private final String prefix = realmName.replaceAll(""_"", ""__"") + ""_"" field instead?@hmlnarik This is very flexible approach I think, where the caller can define whatever mapping he wants. It's also very useful for tests, where I'm using a temporary files generated by the JVM+OS and I have very little control on the name of this file. See https://github.com/keycloak/keycloak/pull/6223/files#diff-3b6b8f2966e0b136c01bbbe19263670cR97. I would prefer to leave it as is - I think it's useful.> b) The function to obtain path from realm name to secret needs to be in line with the design. Currently it is other way round: it does not escape underscores, and it adds two additional ones. It would not work for realm with double underscore in it.@hmlnarik Ohhh yes, now I see the design. Sorry for that, for some reason I must have read it in a wrong way. ",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6223,314221556,2019-08-15T08:42:17Z,services/src/main/java/org/keycloak/vault/PlainTextVaultProviderFactory.java,"@@ -0,0 +1,72 @@+package org.keycloak.vault;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;++import java.lang.invoke.MethodHandles;+import java.nio.file.Files;+import java.nio.file.Path;+import java.nio.file.Paths;++/**+ * Creates and configures {@link PlainTextVaultProvider}.+ *+ * @author Sebastian askawiec+ */+public class PlainTextVaultProviderFactory implements VaultProviderFactory {++    private static final Logger logger = Logger.getLogger(MethodHandles.lookup().lookupClass());++    public static final String PROVIDER_ID = ""plaintext"";++    private String vaultDirectory;+    private Boolean disabled;+    private Path vaultPath;++    @Override+    public VaultProvider create(KeycloakSession session) {+        if ((disabled != null && disabled) || vaultDirectory == null) {+            //init method not called?+            throw new IllegalStateException(""Can not create a vault since it's disabled or not initialized correctly"");+        }+        return new PlainTextVaultProvider(vaultPath, session.getContext().getRealm().getName());+    }++    @Override+    public void init(Config.Scope config) {+        vaultDirectory = config.get(""dir"");+        disabled = config.getBoolean(""disabled"", null);++        if (vaultDirectory == null && disabled == null) {","Why we are checking `disabled == null` in this condition? I would say we should first check if `disabled == true` and `return;` if disabled, then check if vaultDirectory == null. At the moment we are checking if file exists even if vaultDirectory is null if disabled is false.",X
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/6223,315037581,2019-08-19T04:50:25Z,services/src/main/java/org/keycloak/vault/PlainTextVaultProvider.java,"@@ -0,0 +1,80 @@+package org.keycloak.vault;++import org.jboss.logging.Logger;++import javax.annotation.Nonnull;+import java.io.IOException;+import java.lang.invoke.MethodHandles;+import java.nio.MappedByteBuffer;+import java.nio.channels.FileChannel;+import java.nio.file.Files;+import java.nio.file.Path;+import java.nio.file.StandardOpenOption;+import java.util.EnumSet;+import java.util.Optional;++/**+ * A text-based vault provider, which stores each secret in a separate file. The file name needs to match a+ * vault secret id (or a key for short). A typical vault directory layout looks like this:+ * <pre>+ *     ${VAULT}/realma__key1 (contains secret for key 1)+ *     ${VAULT}/realma__key2 (contains secret for key 2)+ *     etc...+ * </pre>+ * Note, that each key needs is prefixed by realm name. This kind of layout is used by Kubernetes by default+ * (when mounting a volume into the pod).+ *+ * See https://kubernetes.io/docs/concepts/configuration/secret/+ * See https://github.com/keycloak/keycloak-community/blob/master/design/secure-credentials-store.md#plain-text-file-per-secret-kubernetes--openshift+ *+ * @author Sebastian askawiec+ */+public class PlainTextVaultProvider implements VaultProvider {++    private static final Logger logger = Logger.getLogger(MethodHandles.lookup().lookupClass());++    private final Path vaultPath;+    private String realmName;++    /**+     * Creates a new {@link PlainTextVaultProvider}.+     *+     * @param path A path to a vault. Can not be null.+     * @param realmName A realm name. Can not be null.+     */+    public PlainTextVaultProvider(@Nonnull Path path, @Nonnull String realmName) {","I believe that's fine. Since `PlainTextVaultProviderFactory` creates `PlainTextVaultProvider`, it is the factory class responsibility to validate arguments. In the provider I only used `@Nonnull`, that integrate with [IDE pretty nicely](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html). Putting additional validation into `PlainTextVaultProvider` would mean validating things two times. I'm not sure if this buys us anything.The only doubt I had was obtaining a realm name from the session (`session.getContext().getRealm().getName()`). I would validate all pieces in (obtaining context, obtaining realm, and finally, obtaining a realm name) in steps but I would need to throw a `RuntimeException` there. So I though there is no sense in doing that and decided to rely on `NullPointerException` there.",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/6223,315041520,2019-08-19T05:19:27Z,services/src/test/java/org/keycloak/vault/PlainTextVaultProviderFactoryTest.java,"@@ -0,0 +1,1300 @@+package org.keycloak.vault;++import org.junit.Rule;+import org.junit.Test;+import org.junit.rules.ExpectedException;+import org.keycloak.Config;+import org.keycloak.common.enums.SslRequired;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.AuthenticationFlowModel;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.GroupModel;+import org.keycloak.models.IdentityProviderMapperModel;+import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OTPPolicy;+import org.keycloak.models.PasswordPolicy;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RequiredActionProviderModel;+import org.keycloak.models.RequiredCredentialModel;+import org.keycloak.models.RoleModel;+import org.keycloak.services.DefaultKeycloakSession;+import org.keycloak.services.DefaultKeycloakSessionFactory;++import java.util.List;+import java.util.Map;+import java.util.Set;++import static org.junit.Assert.assertNotNull;++/**+ * Tests for {@link PlainTextVaultProviderFactory}.+ *+ * @author Sebastian askawiec+ */+public class PlainTextVaultProviderFactoryTest {++    @Rule+    public ExpectedException expectedException = ExpectedException.none();++    @Test+    public void shouldInitializeVaultCorrectly() {+        //given+        VaultConfig config = new VaultConfig(Scenario.EXISTING.getAbsolutePathAsString(), Boolean.FALSE);+        PlainTextVaultProviderFactory factory = new PlainTextVaultProviderFactory();++        KeycloakSession session = new DefaultKeycloakSession(new DefaultKeycloakSessionFactory());+        session.getContext().setRealm(new VaultRealmModel());++        //when+        factory.init(config);+        VaultProvider provider = factory.create(session);++        //then+        assertNotNull(provider);+    }++    @Test+    public void shouldThrowAnExceptionWhenTryingToCreateProviderOnDisabledFactory() {+        //given+        VaultConfig config = new VaultConfig(Scenario.EXISTING.getAbsolutePathAsString(), Boolean.TRUE);+        PlainTextVaultProviderFactory factory = new PlainTextVaultProviderFactory();++        expectedException.expect(IllegalStateException.class);++        //when+        factory.init(config);+        factory.create(null);++        //then - verified by the ExpectedException rule+    }++    @Test+    public void shouldThrowAnExceptionWhenUsingNonExistingDirectory() {+        //given+        VaultConfig config = new VaultConfig(Scenario.NON_EXISTING.getAbsolutePathAsString(), Boolean.FALSE);+        PlainTextVaultProviderFactory factory = new PlainTextVaultProviderFactory();++        expectedException.expect(VaultNotFoundException.class);++        //when+        factory.init(config);++        //then - verified by the ExpectedException rule+    }+","Let's consider the latter parameter first - it's a boolean flag indicates that the provider is disabled. it's a `Boolean`, so it can be `true`, `false` or `null`:* `true` is tested in `shouldThrowAnExceptionWhenTryingToCreateProviderOnDisabledFactory`.* `false` is tested in `shouldInitializeVaultCorrectly`.* `null` is tested in `shouldInitializeVaultCorrectlyWithNullDisabledFlag` (I've just added it). This one is a bit silly as someone would have to explicitly put `null` in a `boolean` configuration param. But I decided to handle it rather than throw a `NullPointerException` from autoboxing.The second parameter is a `String`, so it can be `null`, represent proper path and a non-existing path:* `null` is tested in `shouldThrowAnExceptionWhenWithNullDirectory` (just added). This one is tricky since we can not tell if someone misconfigured the provider, or it's just not configured. So the only way to check it, is to try to create a `PlainTextVaultProvider`. If we get an exception, that's a misconfiguration. In an unconfigured case, `PlainTextVaultProviderFactory#create` would never be called.* existing path is tested in `shouldInitializeVaultCorrectly`* non-existing path is tested in `shouldThrowAnExceptionWhenUsingNonExistingDirectory`.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315519814,2019-08-20T06:12:31Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/webauthn/LoginPage.java,"@@ -0,0 +1,190 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.pages.webauthn;++import org.jboss.arquillian.test.api.ArquillianResource;+import org.keycloak.testsuite.pages.LanguageComboboxAwarePage;+import org.keycloak.testsuite.util.OAuthClient;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIUtils.clickLink;++public class LoginPage extends LanguageComboboxAwarePage {","I vote for rename to ""WebAuthnLoginPage"" to not confuse with 2 other classes called ""LoginPage"". I know package is different, but having separate class names will be even better IMO :) Same applies to all other page objects in the package ""webauthn"".",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315521619,2019-08-20T06:20:09Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/webauthn/AppPage.java,"@@ -0,0 +1,66 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.pages.webauthn;++import org.keycloak.OAuth2Constants;+import org.keycloak.protocol.oidc.OIDCLoginProtocolService;+import org.keycloak.testsuite.pages.AbstractPage;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import javax.ws.rs.core.UriBuilder;++/**+ * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>+ */+public class AppPage extends AbstractPage {",Does this page class needs to be duplicated?,X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315523509,2019-08-20T06:28:23Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/webauthn/RegisterAndLoginTest.java,"@@ -0,0 +1,285 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.webauthn;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.After;+import org.junit.Assert;+import org.junit.Before;+import org.junit.BeforeClass;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.WebAuthnConstants;+import org.keycloak.authentication.authenticators.browser.WebAuthnAuthenticatorFactory;+import org.keycloak.authentication.requiredactions.WebAuthnRegisterFactory;+import org.keycloak.common.util.RandomString;+import org.keycloak.events.Details;+import org.keycloak.events.EventType;+import org.keycloak.representations.idm.AuthenticationExecutionInfoRepresentation;+import org.keycloak.representations.idm.AuthenticatorConfigRepresentation;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.AbstractAdminTest;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.pages.webauthn.LoginPage;+import org.keycloak.testsuite.pages.webauthn.RegisterPage;+import org.keycloak.testsuite.pages.webauthn.AppPage;+import org.keycloak.testsuite.pages.webauthn.AppPage.RequestType;++import org.openqa.selenium.WebDriver;+import org.openqa.selenium.chrome.ChromeDriver;+import org.openqa.selenium.chrome.ChromeOptions;+import org.openqa.selenium.support.ui.WebDriverWait;++import io.github.bonigarcia.wdm.WebDriverManager;++import static org.junit.Assert.assertEquals;++import java.util.Arrays;+import java.util.List;+import java.util.Map;+import java.util.concurrent.TimeUnit;++public class RegisterAndLoginTest extends AbstractTestRealmKeycloakTest {","I suggest also to rename this class to ""WebAuthnRegisterAndLoginTest"" similarly like pages. Bigger issue is, that test didn't pass at all on my laptop (T580, Ubuntu 18.04, Chrome 76). More details in the comment replying to your ""Issue 2"" ",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315525860,2019-08-20T06:37:44Z,testsuite/integration-arquillian/tests/base/pom.xml,"@@ -44,6 +44,11 @@     </properties>          <dependencies>+        <dependency>","I think that from longer term perspective, it will be good to avoid this dependency. We're managing WebDriver with arquillian/drone and already have some tests, which replace default WebDriver. For example AbstractX509AuthenticationTest. I hope it will be possible to use something similar to ensure that WebAuthn is tested with ChromeDriver and enabled webauthn testing API. Moreover the current RegisterAndLoginTest doesn't currently work on my laptop anyway (See some other comments).I think it is fine to keep the dependency in this PR to not block it, but will be good to doublecheck to create follow-up JIRA then to remove it and make sure that test is passing on all platforms.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315527160,2019-08-20T06:42:17Z,services/src/main/java/org/keycloak/models/jpa/converter/AttestationStatementConverter.java,"@@ -0,0 +1,38 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.jpa.converter;++import com.webauthn4j.converter.util.CborConverter;+import com.webauthn4j.data.attestation.statement.AttestationStatement;+import com.webauthn4j.util.Base64UrlUtil;++import javax.persistence.AttributeConverter;++public class AttestationStatementConverter implements AttributeConverter<AttestationStatement, String> {++    private CborConverter converter = new CborConverter(); //TODO: Inject by CDI to make it singleton","there is no CDI in Keycloak. However you can keep the ""singleton"" as an object in WebAuthnCredentialProviderFactory (which itself is kind of a singleton) and then pass to the WebAuthnCredentialProvider constructor and AttestationStatementConverter constructor and CredentialPublicKeyConverter constructor?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315529991,2019-08-20T06:52:06Z,services/src/main/java/org/keycloak/credential/WebAuthnCredentialProvider.java,"@@ -0,0 +1,257 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.credential;++import java.io.IOException;+import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.List;+import java.util.Set;++import org.jboss.logging.Logger;+import org.keycloak.WebAuthnConstants;+import org.keycloak.common.util.Base64;+import org.keycloak.common.util.MultivaluedHashMap;+import org.keycloak.common.util.Time;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.jpa.converter.AttestationStatementConverter;+import org.keycloak.models.jpa.converter.CredentialPublicKeyConverter;++import com.webauthn4j.authenticator.Authenticator;+import com.webauthn4j.authenticator.AuthenticatorImpl;+import com.webauthn4j.data.WebAuthnAuthenticationContext;+import com.webauthn4j.data.attestation.authenticator.AAGUID;+import com.webauthn4j.data.attestation.authenticator.AttestedCredentialData;+import com.webauthn4j.data.attestation.authenticator.CredentialPublicKey;+import com.webauthn4j.data.attestation.statement.AttestationStatement;+import com.webauthn4j.util.exception.WebAuthnException;+import com.webauthn4j.validator.WebAuthnAuthenticationContextValidationResponse;+import com.webauthn4j.validator.WebAuthnAuthenticationContextValidator;++public class WebAuthnCredentialProvider implements CredentialProvider, CredentialInputValidator, CredentialInputUpdater {++    private static final Logger logger = Logger.getLogger(WebAuthnCredentialProvider.class);++    private static final String ATTESTATION_STATEMENT = ""ATTESTATION_STATEMENT"";+    private static final String AAGUID = ""AAGUID"";+    private static final String CREDENTIAL_ID = ""CREDENTIAL_ID"";+    private static final String CREDENTIAL_PUBLIC_KEY = ""CREDENTIAL_PUBLIC_KEY"";++    private KeycloakSession session;++    public WebAuthnCredentialProvider(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {+        if (input == null) return false;+        CredentialModel model = createCredentialModel(input);+        if (model == null) return false;+        session.userCredentialManager().createCredential(realm, user, model);+        return true;+    }++    private CredentialModel createCredentialModel(CredentialInput input) {+        if (!supportsCredentialType(input.getType())) return null;++        WebAuthnCredentialModel webAuthnModel = (WebAuthnCredentialModel) input;+        CredentialModel model = new CredentialModel();+        model.setType(WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE);+        model.setCreatedDate(Time.currentTimeMillis());++        MultivaluedHashMap<String, String> credential = new MultivaluedHashMap<>();++        AttestationStatementConverter attConv = new AttestationStatementConverter();+        credential.add(ATTESTATION_STATEMENT, attConv.convertToDatabaseColumn(webAuthnModel.getAttestationStatement()));++        credential.add(AAGUID, webAuthnModel.getAttestedCredentialData().getAaguid().toString());++        credential.add(CREDENTIAL_ID, Base64.encodeBytes(webAuthnModel.getAttestedCredentialData().getCredentialId()));++        CredentialPublicKeyConverter credConv = new CredentialPublicKeyConverter();+        credential.add(CREDENTIAL_PUBLIC_KEY, credConv.convertToDatabaseColumn(webAuthnModel.getAttestedCredentialData().getCredentialPublicKey()));++        model.setId(webAuthnModel.getAuthenticatorId());++        model.setConfig(credential);++        // authenticator's counter+        model.setValue(String.valueOf(webAuthnModel.getCount()));++        dumpCredentialModel(model);+        dumpWebAuthnCredentialModel(webAuthnModel);++        return model;+    }++    @Override+    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {+        if (!supportsCredentialType(credentialType)) return;+        // detele webauthn authenticator's credential itself+        for (CredentialModel credential : session.userCredentialManager().getStoredCredentialsByType(realm, user, credentialType)) {+            logger.infov(""Delete public key credential. username = {0}, credentialType = {1}"", user.getUsername(), credentialType);+            dumpCredentialModel(credential);+            session.userCredentialManager().removeStoredCredential(realm, user, credential.getId());+        }+        // delete webauthn authenticator's metadata+        user.removeAttribute(WebAuthnConstants.PUBKEY_CRED_AAGUID_ATTR);+        user.removeAttribute(WebAuthnConstants.PUBKEY_CRED_ID_ATTR);+        user.removeAttribute(WebAuthnConstants.PUBKEY_CRED_LABEL_ATTR);+    }++    @Override+    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {+        return isConfiguredFor(realm, user, WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE) ? Collections.singleton(WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE) : Collections.emptySet();+    }++    @Override+    public boolean supportsCredentialType(String credentialType) {+        return WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE.equals(credentialType);+    }++    @Override+    public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {+        if (!supportsCredentialType(credentialType)) return false;+        return !session.userCredentialManager().getStoredCredentialsByType(realm, user, credentialType).isEmpty();+    }++    @Override+    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {+        if (!WebAuthnCredentialModel.class.isInstance(input)) return false;++        WebAuthnCredentialModel context = WebAuthnCredentialModel.class.cast(input);+        List<WebAuthnCredentialModel> auths = getWebAuthnCredentialModelList(realm, user);++        WebAuthnAuthenticationContextValidator webAuthnAuthenticationContextValidator =+                new WebAuthnAuthenticationContextValidator();+        try {+            for (WebAuthnCredentialModel auth : auths) {++                byte[] credentialId = auth.getAttestedCredentialData().getCredentialId();+                if (Arrays.equals(credentialId, context.getAuthenticationContext().getCredentialId())) {+                    Authenticator authenticator = new AuthenticatorImpl(+                            auth.getAttestedCredentialData(),+                            auth.getAttestationStatement(),+                            auth.getCount()+                    );++                    // WebAuthnException is thrown if validation fails+                    WebAuthnAuthenticationContextValidationResponse response =+                            webAuthnAuthenticationContextValidator.validate(+                                    context.getAuthenticationContext(),+                                    authenticator);++                    logger.infov(""response.getAuthenticatorData().getFlags() = {0}"", response.getAuthenticatorData().getFlags());++                    // update authenticator counter+                    long count = auth.getCount();+                    auth.setCount(count + 1);+                    CredentialModel cred = createCredentialModel(auth);+                    session.userCredentialManager().updateCredential(realm, user, cred);++                    dumpCredentialModel(cred);+                    dumpWebAuthnCredentialModel(auth);++                    return true;+                }+            }+        } catch (WebAuthnException wae) {+            wae.printStackTrace();+            throw(wae);+        }+        // no authenticator matched+        return false;+    }++    private List<WebAuthnCredentialModel> getWebAuthnCredentialModelList(RealmModel realm, UserModel user) {+        List<WebAuthnCredentialModel> auths = new ArrayList<>();+        for (CredentialModel credential : session.userCredentialManager().getStoredCredentialsByType(realm, user, WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE)) {+            WebAuthnCredentialModel auth = new WebAuthnCredentialModel();+            MultivaluedHashMap<String, String> attributes = credential.getConfig();++            AttestationStatementConverter attConv = new AttestationStatementConverter();+            AttestationStatement attrStatement = attConv.convertToEntityAttribute(attributes.getFirst(ATTESTATION_STATEMENT));+            auth.setAttestationStatement(attrStatement);++            AAGUID aaguid = new AAGUID(attributes.getFirst(AAGUID));++            byte[] credentialId = null;+            try {+                credentialId = Base64.decode(attributes.getFirst(CREDENTIAL_ID));+            } catch (IOException ioe) {+                // NOP+            }++            CredentialPublicKeyConverter credConv = new CredentialPublicKeyConverter();+            CredentialPublicKey pubKey = credConv.convertToEntityAttribute(attributes.getFirst(CREDENTIAL_PUBLIC_KEY));++            AttestedCredentialData attrCredData = new AttestedCredentialData(aaguid, credentialId, pubKey);++            auth.setAttestedCredentialData(attrCredData);++            long count = Long.parseLong(credential.getValue());+            auth.setCount(count);++            auth.setAuthenticatorId(credential.getId());++            auths.add(auth);+        }+        return auths;+    }++    private void dumpCredentialModel(CredentialModel credential) {+        logger.debugv(""  Persisted Credential Info::"");+        MultivaluedHashMap<String, String> attributes = credential.getConfig();+        logger.debugv(""    ATTESTATION_STATEMENT = {0}"", attributes.getFirst(ATTESTATION_STATEMENT));+        logger.debugv(""    AAGUID = {0}"", attributes.getFirst(AAGUID));+        logger.debugv(""    CREDENTIAL_ID = {0}"", attributes.getFirst(CREDENTIAL_ID));+        logger.debugv(""    CREDENTIAL_PUBLIC_KEY = {0}"", attributes.getFirst(CREDENTIAL_PUBLIC_KEY));+        logger.debugv(""    count = {0}"", credential.getValue());+        logger.debugv(""    authenticator_id = {0}"", credential.getId());+    }++    private void dumpWebAuthnCredentialModel(WebAuthnCredentialModel auth) {+        logger.debugv(""  Context Credential Info::"");","Just a very minor issue related to logging. I vote to wrap this method inside ""if (logger.isDebugEnabled()"" to avoid some unecessary calls to Base64 encode in case that debug logging is not enabled anyway. Maybe even slightly better is to implement the method ""toString()"" on WebAuthnCredentialModel. This will allow to use just ""logger.debug(auth)"" and in case that debug is not enabled, the ""toString()"" won't be called (hence no call to unecessary Base64 encodings etc). Also it will mean that same/similar code doesn't need to be duplicated in WebAuthnRegister class.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315530547,2019-08-20T06:53:50Z,services/src/main/java/org/keycloak/authentication/requiredactions/WebAuthnRegister.java,"@@ -0,0 +1,297 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import java.util.Base64;+import java.util.List;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.keycloak.WebAuthnConstants;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.UriUtils;+import org.keycloak.credential.WebAuthnCredentialModel;+import org.keycloak.crypto.Algorithm;+import org.keycloak.events.Errors;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserModel;+import org.keycloak.models.WebAuthnPolicy;++import com.webauthn4j.data.WebAuthnRegistrationContext;+import com.webauthn4j.data.attestation.authenticator.AttestedCredentialData;+import com.webauthn4j.data.attestation.statement.AttestationStatement;+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;+import com.webauthn4j.data.client.Origin;+import com.webauthn4j.data.client.challenge.Challenge;+import com.webauthn4j.data.client.challenge.DefaultChallenge;+import com.webauthn4j.server.ServerProperty;+import com.webauthn4j.util.exception.WebAuthnException;+import com.webauthn4j.validator.WebAuthnRegistrationContextValidationResponse;+import com.webauthn4j.validator.WebAuthnRegistrationContextValidator;++public class WebAuthnRegister implements RequiredActionProvider {++    private static final Logger logger = Logger.getLogger(WebAuthnRegister.class);+    private KeycloakSession session;++    public WebAuthnRegister(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public void requiredActionChallenge(RequiredActionContext context) {+        UserModel userModel = context.getUser();+        String userid = userModel.getId();+        String username = userModel.getUsername();+        Challenge challenge = new DefaultChallenge();+        String challengeValue = Base64Url.encode(challenge.getValue());+        context.getAuthenticationSession().setAuthNote(WebAuthnConstants.AUTH_CHALLENGE_NOTE, challengeValue);++        // construct parameters for calling WebAuthn API navigator.credential.create()++        // mandatory+        WebAuthnPolicy policy = context.getRealm().getWebAuthnPolicy();+        List<String> signatureAlgorithmsList = policy.getSignatureAlgorithm();+        String signatureAlgorithms = stringifySignatureAlgorithms(signatureAlgorithmsList);+        String rpEntityName = policy.getRpEntityName();++        // optional+        String rpId = policy.getRpId();+        if (rpId == null || rpId.isEmpty()) rpId =  context.getUriInfo().getBaseUri().getHost();+        String attestationConveyancePreference = policy.getAttestationConveyancePreference();+        String authenticatorAttachment = policy.getAuthenticatorAttachment();+        String requireResidentKey = policy.getRequireResidentKey();+        String userVerificationRequirement = policy.getUserVerificationRequirement();+        long createTimeout = policy.getCreateTimeout();+        boolean avoidSameAuthenticatorRegister = policy.isAvoidSameAuthenticatorRegister();+        String excludeCredentialIds = avoidSameAuthenticatorRegister == true ? stringifyExcludeCredentialIds(userModel.getAttribute(WebAuthnConstants.PUBKEY_CRED_ID_ATTR)) : """";++        Response form = context.form()+                .setAttribute(WebAuthnConstants.CHALLENGE, challengeValue)+                .setAttribute(WebAuthnConstants.USER_ID, userid)+                .setAttribute(WebAuthnConstants.USER_NAME, username)+                .setAttribute(WebAuthnConstants.RP_ENTITY_NAME, rpEntityName)+                .setAttribute(WebAuthnConstants.SIGNATURE_ALGORITHMS, signatureAlgorithms)+                .setAttribute(WebAuthnConstants.RP_ID, rpId)+                .setAttribute(WebAuthnConstants.ATTESTATION_CONVEYANCE_PREFERENCE, attestationConveyancePreference)+                .setAttribute(WebAuthnConstants.AUTHENTICATOR_ATTACHMENT, authenticatorAttachment)+                .setAttribute(WebAuthnConstants.REQUIRE_RESIDENT_KEY, requireResidentKey)+                .setAttribute(WebAuthnConstants.USER_VERIFICATION_REQUIREMENT, userVerificationRequirement)+                .setAttribute(WebAuthnConstants.CREATE_TIMEOUT, createTimeout)+                .setAttribute(WebAuthnConstants.EXCLUDE_CREDENTIAL_IDS, excludeCredentialIds.toString())+                .createForm(""webauthn-register.ftl"");+        context.challenge(form);+    }++    @Override+    public void processAction(RequiredActionContext context) {++        MultivaluedMap<String, String> params = context.getHttpRequest().getDecodedFormParameters();++        // receive error from navigator.credentials.create()+        String errorMsgFromWebAuthnApi = params.getFirst(WebAuthnConstants.ERROR);+        if (errorMsgFromWebAuthnApi != null && !errorMsgFromWebAuthnApi.isEmpty()) {+            setErrorResponse(context, ERR_WEBAUTHN_API_CREATE, errorMsgFromWebAuthnApi);+            return;+        }++        WebAuthnPolicy policy = context.getRealm().getWebAuthnPolicy();+        String rpId = policy.getRpId();+        if (rpId == null || rpId.isEmpty()) rpId =  context.getUriInfo().getBaseUri().getHost();+        String label = params.getFirst(WebAuthnConstants.AUTHENTICATOR_LABEL);+        byte[] clientDataJSON = Base64.getUrlDecoder().decode(params.getFirst(WebAuthnConstants.CLIENT_DATA_JSON));+        byte[] attestationObject = Base64.getUrlDecoder().decode(params.getFirst(WebAuthnConstants.ATTESTATION_OBJECT));+        String publicKeyCredentialId = params.getFirst(WebAuthnConstants.PUBLIC_KEY_CREDENTIAL_ID);++        Origin origin = new Origin(UriUtils.getOrigin(context.getUriInfo().getBaseUri()));+        Challenge challenge = new DefaultChallenge(context.getAuthenticationSession().getAuthNote(WebAuthnConstants.AUTH_CHALLENGE_NOTE));+        ServerProperty serverProperty = new ServerProperty(origin, rpId, challenge, null);+        // check User Verification by considering a malicious user might modify the result of calling WebAuthn API+        boolean isUserVerificationRequired = policy.getUserVerificationRequirement().equals(WebAuthnConstants.OPTION_REQUIRED) == true ? true : false;++        try {+            WebAuthnRegistrationContext registrationContext = new WebAuthnRegistrationContext(clientDataJSON, attestationObject, serverProperty, isUserVerificationRequired);+            // NOTE: not yet verify Attestation Statement based on certificates+            WebAuthnRegistrationContextValidator webAuthnRegistrationContextValidator = WebAuthnRegistrationContextValidator.createNonStrictRegistrationContextValidator();+            WebAuthnRegistrationContextValidationResponse response = webAuthnRegistrationContextValidator.validate(registrationContext);++            showInfoAfterWebAuthnApiCreate(response);++            checkAcceptedAuthenticator(response, policy);++            WebAuthnCredentialModel credential = new WebAuthnCredentialModel();++            credential.setAttestedCredentialData(response.getAttestationObject().getAuthenticatorData().getAttestedCredentialData());+            credential.setAttestationStatement(response.getAttestationObject().getAttestationStatement());+            credential.setCount(response.getAttestationObject().getAuthenticatorData().getSignCount());++            this.session.userCredentialManager().updateCredential(context.getRealm(), context.getUser(), credential);++            // store received Credential ID on Registration onto UserModel in order to be used on Authentication+            String aaguid = response.getAttestationObject().getAuthenticatorData().getAttestedCredentialData().getAaguid().toString();+            context.getUser().setSingleAttribute(WebAuthnConstants.PUBKEY_CRED_ID_ATTR, publicKeyCredentialId);+            context.getUser().setSingleAttribute(WebAuthnConstants.PUBKEY_CRED_LABEL_ATTR, label);+            context.getUser().setSingleAttribute(WebAuthnConstants.PUBKEY_CRED_AAGUID_ATTR, aaguid);+            logger.infov(""WebAuthn Registration successed. publicKeyCredentialId = {0}, publicKeyCredentialLabel = {1}, publicKeyCredentialAAGUID = {2}"",publicKeyCredentialId, label, aaguid);++            context.getEvent()+                .detail(""public_key_credential_id"", publicKeyCredentialId)+                .detail(""public_key_credential_label"", label)+                .detail(""public_key_credential_aaguid"", aaguid);+            context.success();+        } catch (WebAuthnException wae) {+            setErrorResponse(context, ERR_WEBAUTHN_API_CREATE, wae.getMessage());","Minor: Is it possible to log the exception stacktrace at least in the ""Debug"" level? It may help to possibly debug some issues as exception stacktraces might be always the best source for troubleshooting IMO :)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315531156,2019-08-20T06:55:53Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/WebAuthnAuthenticator.java,"@@ -0,0 +1,261 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.authenticators.browser;++import com.webauthn4j.data.WebAuthnAuthenticationContext;+import com.webauthn4j.data.client.Origin;+import com.webauthn4j.data.client.challenge.Challenge;+import com.webauthn4j.data.client.challenge.DefaultChallenge;+import com.webauthn4j.server.ServerProperty;+import com.webauthn4j.util.exception.WebAuthnException;++import org.jboss.logging.Logger;+import org.keycloak.WebAuthnConstants;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.authentication.Authenticator;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.UriUtils;+import org.keycloak.credential.WebAuthnCredentialModel;+import org.keycloak.events.Errors;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.forms.login.freemarker.model.WebAuthnAuthenticatorsBean;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++public class WebAuthnAuthenticator implements Authenticator {++    private static final Logger logger = Logger.getLogger(WebAuthnAuthenticator.class);+    private KeycloakSession session;++    public WebAuthnAuthenticator(KeycloakSession session) {+        this.session = session;+    }++    public void authenticate(AuthenticationFlowContext context) {+        LoginFormsProvider form = context.form();+ +        Challenge challenge = new DefaultChallenge();+        String challengeValue = Base64Url.encode(challenge.getValue());+        context.getAuthenticationSession().setAuthNote(WebAuthnConstants.AUTH_CHALLENGE_NOTE, challengeValue);+        form.setAttribute(WebAuthnConstants.CHALLENGE, challengeValue);++        String rpId = context.getRealm().getWebAuthnPolicy().getRpId();+        if (rpId == null || rpId.isEmpty()) rpId =  context.getUriInfo().getBaseUri().getHost();+        form.setAttribute(WebAuthnConstants.RP_ID, rpId);++        UserModel user = context.getUser();+        boolean isUserIdentified = false;+        if (user != null) {+            // in 2 Factor Scenario where the user has already been identified+            WebAuthnAuthenticatorsBean authenticators = new WebAuthnAuthenticatorsBean(user);+            if (authenticators.getAuthenticators().isEmpty()) {+                setErrorResponse(context, ERR_NO_AUTHENTICATORS_REGISTERED, null);+                return;+            }+            isUserIdentified = true;+            form.setAttribute(WebAuthnConstants.ALLOWED_AUTHENTICATORS, authenticators);+        } else {+            // in ID-less & Password-less Scenario+            // NOP+        }+        form.setAttribute(WebAuthnConstants.IS_USER_IDENTIFIED, Boolean.toString(isUserIdentified));++        // read options from authenticator config+        AuthenticatorConfigModel config = context.getAuthenticatorConfig();+        String userVerificationRequirement = config.getConfig().get(WebAuthnAuthenticatorFactory.USER_VERIFICATION_REQUIREMENT);","I had NullPointerException thrown on this line during testing. It was caused by the fact that ""config"" wasn't present on the authenticator. Is it possible to use the default when config is not yet created? Or maybe re-use same config from WebAuthnPolicy rather than having it duplicated on the authenticator? See some other comment...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315534188,2019-08-20T07:05:20Z,themes/src/main/resources/theme/base/login/webauthn-register.ftl,"@@ -0,0 +1,136 @@+    <#import ""template.ftl"" as layout>+    <@layout.registrationLayout; section>+    <#if section = ""title"">+     title+    <#elseif section = ""header"">+    ${msg(""loginTitleHtml"", realm.name)}+    <#elseif section = ""form"">+    <form id=""register"" class=""${properties.kcFormClass!}"" action=""${url.loginAction}"" method=""post"">+        <div class=""${properties.kcFormGroupClass!}"">+            <input type=""hidden"" id=""clientDataJSON"" name=""clientDataJSON""/>+            <input type=""hidden"" id=""attestationObject"" name=""attestationObject""/>+            <input type=""hidden"" id=""publicKeyCredentialId"" name=""publicKeyCredentialId""/>+            <input type=""hidden"" id=""authenticatorLabel"" name=""authenticatorLabel""/>+            <input type=""hidden"" id=""error"" name=""error""/>+        </div>+    </form>+    <script type=""text/javascript"" src=""${url.resourcesPath}/node_modules/jquery/dist/jquery.min.js""></script>+    <script type=""text/javascript"" src=""${url.resourcesPath}/js/base64url.js""></script>+    <script type=""text/javascript"">+        // mandatory parameters+        let challenge = ""${challenge}"";+        let userid = ""${userid}"";+        let username = ""${username}"";++        let signatureAlgorithms = ""${signatureAlgorithms}"";+        let pubKeyCredParams = getPubKeyCredParams(signatureAlgorithms);++        let rpEntityName = ""${rpEntityName}"";+        let rp = {name: rpEntityName};++        let publicKey = {+            challenge: base64url.decode(challenge, { loose: true }),+            rp: rp,+            user: {+                id:  base64url.decode(userid, { loose: true }),+                name: username,+                displayName: username+            },+            pubKeyCredParams: pubKeyCredParams,+        }++        // optional parameters+        let rpId = ""${rpId}"";+        publicKey.rp.id = rpId;++        let attestationConveyancePreference = ""${attestationConveyancePreference}"";+        if(attestationConveyancePreference !== 'not specified') publicKey.attestation = attestationConveyancePreference;++        let authenticatorSelection = {};+        let isAuthenticatorSelectionSpecified = false;++        let authenticatorAttachment = ""${authenticatorAttachment}"";+        if(authenticatorAttachment !== 'not specified') {+            authenticatorSelection.authenticatorAttachment = authenticatorAttachment;+            isAuthenticatorSelectionSpecified = true;+        }++        let requireResidentKey = ""${requireResidentKey}"";+        if(requireResidentKey !== 'not specified') {+            if(requireResidentKey === 'Yes')+                authenticatorSelection.requireResidentKey = true;+            else+                authenticatorSelection.requireResidentKey = false;+            isAuthenticatorSelectionSpecified = true;+        }++        let userVerificationRequirement = ""${userVerificationRequirement}"";+        if(userVerificationRequirement !== 'not specified') {+            authenticatorSelection.userVerification = userVerificationRequirement;+            isAuthenticatorSelectionSpecified = true;+        }++        if(isAuthenticatorSelectionSpecified) publicKey.authenticatorSelection = authenticatorSelection;++        let createTimeout = ${createTimeout};+        if(createTimeout != 0) publicKey.timeout = createTimeout * 1000;++        let excludeCredentialIds = ""${excludeCredentialIds}"";+        let excludeCredentials = getExcludeCredentials(excludeCredentialIds);+        if (excludeCredentials.length > 0) publicKey.excludeCredentials = excludeCredentials;++        navigator.credentials.create({publicKey})+            .then(function(result) {+                window.result = result;+                let clientDataJSON = result.response.clientDataJSON;+                let attestationObject = result.response.attestationObject;+                let publicKeyCredentialId = result.rawId;++                $(""#clientDataJSON"").val(base64url.encode(new Uint8Array(clientDataJSON), { pad: false }));+                $(""#attestationObject"").val(base64url.encode(new Uint8Array(attestationObject), { pad: false }));+                $(""#publicKeyCredentialId"").val(base64url.encode(new Uint8Array(publicKeyCredentialId), { pad: false }));++                let initLabel = ""WebAuthn Authenticator (Default Label)"";+                let labelResult = window.prompt(""Please input your registered authenticator's label"", initLabel);+                if (labelResult === null) labelResult = initLabel;+                $(""#authenticatorLabel"").val(labelResult);++                $(""#register"").submit();++            })+            .catch(function(err) {+                $(""#error"").val(err);+                $(""#register"").submit();++            });++        function getPubKeyCredParams(signatureAlgorithms) {","Minor thing again, but I wonder if it's possible to move this function to the java class instead of have the business logic inside UI template? Also there is possibility to wrap all the informations inside single bean class (EG. WebAuthnBean) instead of pass many single strings to freemarker.  Bean just needs to have fields available through getter/setter and those can be referenced in freemarker template. See some existing beans in the codebase for the details. Depends if it is easily possible to convert the freemarker bean into the JSON object useful by javascript script, but I suppose that yes.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,315536760,2019-08-20T07:13:26Z,services/src/main/java/org/keycloak/models/jpa/converter/AAGUIDConverter.java,"@@ -0,0 +1,33 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.jpa.converter;++import com.webauthn4j.data.attestation.authenticator.AAGUID;++import javax.persistence.AttributeConverter;++public class AAGUIDConverter implements AttributeConverter<AAGUID, byte[]> {","I think we don't want to have JPA dependency in the ""services"" module. Is it possible to move those Converter classes inside the ""model-jpa"" module? If the ""model-jpa"" has some dependency on webauthn4j it is fine.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6225,315578707,2019-08-20T08:56:52Z,services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java,"@@ -585,7 +585,7 @@ public Response processPasswordUpdate(final MultivaluedMap<String, String> formD             ServicesLogger.LOGGER.failedToUpdatePassword(me);             setReferrerOnPage();             errorEvent.detail(Details.REASON, me.getMessage()).error(Errors.PASSWORD_REJECTED);-            return account.setError(Response.Status.INTERNAL_SERVER_ERROR, me.getMessage(), me.getParameters()).createResponse(AccountPages.PASSWORD);+            return account.setError(Response.Status.OK, me.getMessage(), me.getParameters()).createResponse(AccountPages.PASSWORD);","BTV. There is the issue https://issues.jboss.org/browse/KEYCLOAK-11000 about the bad response seeing unrendered HTML. However when this bug is fixed, we should return 400 rather than 200 IMO.",
8414918,iankko,https://api.github.com/repos/keycloak/keycloak/pulls/6261,316800896,2019-08-22T17:34:14Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/membership/group/GroupLDAPStorageMapper.java,"@@ -192,21 +194,37 @@ public String getStatus() {             Set<String> visitedGroupIds = new HashSet<>();              // Just add flat structure of groups with all groups at top-level-            for (Map.Entry<String, LDAPObject> groupEntry : ldapGroupsMap.entrySet()) {-                String groupName = groupEntry.getKey();-                GroupModel kcExistingGroup = KeycloakModelUtils.findGroupByPath(realm, ""/"" + groupName);--                if (kcExistingGroup != null) {-                    updateAttributesOfKCGroup(kcExistingGroup, groupEntry.getValue());-                    syncResult.increaseUpdated();-                    visitedGroupIds.add(kcExistingGroup.getId());-                } else {-                    GroupModel kcGroup = realm.createGroup(groupName);-                    updateAttributesOfKCGroup(kcGroup, groupEntry.getValue());-                    realm.moveGroup(kcGroup, null);-                    syncResult.increaseAdded();-                    visitedGroupIds.add(kcGroup.getId());-                }+            final int GROUPS_PER_TRANSACTION = 1000;","JFTR, this constant can be taken into the Keycloak configuration file as the parameter / setting, allowing to tune the count of records to be processed within one transaction, if desired / needed.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6214,317098058,2019-08-23T11:58:16Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/SAMLServletAdapterTest.java,"@@ -1795,6 +1812,34 @@ public void testInvalidCredentialsEcpFlow() throws Exception {         Assert.assertThat(statusCode.getStatusCode().getValue().toString(), is(not(JBossSAMLURIConstants.STATUS_SUCCESS.get())));     } +    /**+     * Tests that the adapter is using the configured role mappings provider to map the roles extracted from the assertion+     * into roles that exist in the application domain. In this test we are relying on the default provider, which uses a+     * properties file to perform the role to role and principal to role mappings.+     *+     * @throws Exception if an error occurs while running the test.+     */+    @Test+    public void testAdapterRoleMappings() throws Exception {","Maybe it is not important, but in this test, I am missing checking roles by the container. I mean setting checking roles in web.xml. Checking roles in Servlet makes sense only for the filter. I did a commit with test suggestion: https://github.com/mhajas/keycloak/commit/c39d5a0670869ea4806af4b1153593bad4662fed. WDYT? ",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6214,317293446,2019-08-23T20:37:20Z,adapters/saml/core/src/main/java/org/keycloak/adapters/saml/PropertiesBasedRoleMapper.java,"@@ -0,0 +1,177 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.adapters.saml;++import java.io.File;+import java.io.FileInputStream;+import java.io.InputStream;+import java.util.Collections;+import java.util.HashSet;+import java.util.Properties;+import java.util.Set;++import org.jboss.logging.Logger;+import org.keycloak.adapters.saml.config.parsers.ResourceLoader;++/**+ * A {@code RoleMappingsProvider} implementation that uses a {@code properties} file to determine the mappings that should be applied+ * to the SAML principal and roles.+ *+ * This is the default {@code RoleMappingsProvider} implementation and the adapter will always install this implementation+ * for applications that don't configure a {@code RoleMappingsProvider}. By default, it attempts to load a file named+ * {@code role-mappings.properties} from the {@code WEB-INF} directory of the application but it provides a configuration option+ * named {@code properties.file.location} that can be used to customize the {@code properties} file name and its location within the+ * WAR file or in the filesystem. The following snippet shows how to use this option in {@code keycloak-saml.xml}:+ *+ * <pre>+ *     <RoleMappingsProvider id=""properties-based-role-mapper"">+ *         <Property name=""properties.file.location"" value=""/WEB-INF/conf/roles.properties""/>+ *     </RoleMappingsProvider>+ * </pre>+ *+ * The {@code PropertiesBasedRoleMapper} is always identified by the id {@code properties-based-role-mapper} in {@code keycloak-saml.xml}.+ * In the configuration shown above, the {@code properties.file.location} configuration property is used to tell the provider that+ * it will find the {@code properties} file containing the mappings in {@code /WEB-INF/conf/roles.properties}.+ *+ * The {@code properties} file can contain both roles and principals as keys, and a list of zero or more roles separated by comma as values.+ * When the {@code {@link #map(String, Set)}} method is called, the implementation iterates through the set of roles that were+ * extracted from the assertion and checks, for eache role, if a mapping exists. If the role maps to an empty role, it is discarded. If+ * it maps to a set of one ore more different roles, then these roles are set in the result set. If no mapping is found for the role+ * then it is included as is in the result set.+ *+ * Once the roles have been processed, the implementation checks if the principal extracted from the assertion contains an entry+ * in the {@code properties} file. If a mapping for the principal exists, any roles listed as value are added to the result set. This+ * allows the assignment of extra roles to a principal.+ *+ * For example, consider the following {@code role-mappings.properties}:+ *+ * <pre>+ *     # role to roles mappings+ *     samlRoleA=jeeRoleX,jeeRoleY+ *     samlRoleB=+ *+ *     # principal to roles mappings+ *     kc-user=jeeRoleZ+ * </pre>+ *+ * If the {@code {@link #map(String, Set)}} method is called with {@code kc-user} as principal and a set containing roles+ * {@code samlRoleA,samlRoleB,samlRoleC}, the result set will be formed by the roles {@code jeeRoleX,jeeRoleY,samlRoleC,jeeRoleZ}.+ * In this case, {@code samlRoleA} is mapped to two roles ({@code jeeRoleX,jeeRoleY}), {@code samlRoleB} is discarded as it is+ * mapped to an empty role, {@code samlRoleC} is used as is and the principal is also assigned {@code jeeRoleZ}.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class PropertiesBasedRoleMapper implements RoleMappingsProvider {++    private static final Logger logger = Logger.getLogger(PropertiesBasedRoleMapper.class);++    public static final String PROVIDER_ID = ""properties-based-role-mapper"";++    private static final String PROPERTIES_LOCATION = ""properties.file.location"";++    private static final String DEFAULT_LOCATION = ""/WEB-INF/role-mappings.properties"";++    private Properties roleMappings;++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    @Override+    public void init(final SamlDeployment deployment, final ResourceLoader loader, final Properties config) {+        String path = DEFAULT_LOCATION;+        if (config.getProperty(PROPERTIES_LOCATION) != null) {+            path = config.getProperty(PROPERTIES_LOCATION);+        }+        InputStream is = loader.getResourceAsStream(path);+        // load properties file - first try to find the file in the WAR using the resoure loader, if that fails look in the filesystem.+        this.roleMappings = new Properties();+        boolean loaded = false;+        try {+            this.roleMappings.load(is);+            loaded = true;+            if (logger.isDebugEnabled()) {+                logger.debugf(""Resource loader successfully loaded role mappings from %s"", path);+            }+        } catch(Exception e) {+            if (logger.isDebugEnabled()) {+                logger.debugv(e, ""Resource loader unable to load role mappings from %s"", path);+            }+        }+        if (!loaded && !DEFAULT_LOCATION.equals(path)) {+            // try to load the file directly from the filesystem if a location other than the default was provided and the+            // resource loader was unable to load it.+            File file = new File(path);+            if (file.exists()) {+                try {+                    this.roleMappings.load(new FileInputStream(file));+                    if (logger.isDebugEnabled()) {+                        logger.debugf(""Successfully loaded role mappings from %s"", path);+                    }+                } catch(Exception e) {+                    if (logger.isDebugEnabled()) {+                        logger.debugv(e, ""Unable to load role mappings from %s"", path);+                    }+                }+            }+            else {+                if (logger.isDebugEnabled()) {+                    logger.debugf(""Unable to load role mappings from %s: file does not exist in filesystem"", path);+                }+            }+        }+    }++    @Override+    public Set<String> map(final String principalName, final Set<String> roles) {+        if (this.roleMappings == null || this.roleMappings.isEmpty())+            return roles;++        Set<String> resolvedRoles = new HashSet<>();+        // first check if we have role -> role(s) mappings.+        for (String role : roles) {+            if (this.roleMappings.containsKey(role)) {+                // role that was mapped to empty string is not considered (it is discarded from the set of specified roles).+                String value = this.roleMappings.getProperty(role);+                if (!value.isEmpty()) {+                    String[] mappedRoles = value.split("","");+                    for (String mappedRole : mappedRoles) {+                        String trimmedRole = mappedRole.trim();+                        if (!trimmedRole.isEmpty()) {+                            resolvedRoles.add(trimmedRole);+                        }+                    }+                }+            } else {+                // no mapping found for role - add it as is.+                resolvedRoles.add(role);+            }+        }++        // now check if we have a principal -> role(s) mapping with additional roles to be added.+        if (this.roleMappings.containsKey(principalName)) {+            String value = this.roleMappings.getProperty(principalName);+            if (value != null && !value.isEmpty()) {","Yes, definitely need to use trim() here as well. What is not needed is the check value != null as I've already checked if the properties contains the key and a properties entry cannot have a null value. I will look into extracting the similar functionalities into a separate method.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6214,317296716,2019-08-23T20:48:25Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/SAMLServletAdapterTest.java,"@@ -462,6 +468,17 @@ private void assertForbiddenLogin(AbstractPage page, String username, String pas                 || driver.getPageSource().contains(WEBSPHERE_FORBIDDEN_TEXT)); // WebSphere     } +    private void assertForbiddenLogin(AbstractPage page, UserRepresentation user, Login loginPage, String expectedNotContains) {+        page.navigateTo();","You are absolutely right, don't know what I was thinking. Removed the duplicated method and adapted the test to use the one that takes username and pw.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6214,317471346,2019-08-26T06:49:57Z,adapters/saml/core/src/main/java/org/keycloak/adapters/saml/RoleMappingsProviderUtils.java,"@@ -0,0 +1,86 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.adapters.saml;++import java.util.HashMap;+import java.util.Map;+import java.util.Properties;+import java.util.ServiceLoader;++import org.jboss.logging.Logger;+import org.keycloak.adapters.saml.config.SP;+import org.keycloak.adapters.saml.config.parsers.ResourceLoader;++/**+ * Utility class that allows for the instantiation and configuration of role mappings providers.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class RoleMappingsProviderUtils {++    private static final Logger logger = Logger.getLogger(RoleMappingsProviderUtils.class);++    /**+     * Loads the available implementations of {@code RoleMappingsProvider} and selects the provider that matches the id+     * that was configured in {@code keycloak-saml.xml}. If no provider was configured for the SP then the default+     * {@code PropertiesBasedRoleMapper} is instantiated. The selected provider is then initialized with the specified+     * {@code SamlDeployment}, {@code ResourceLoader} and configuration as specified in {@code keycloak-saml.xml}.+     *+     * @param deployment a reference to the {@code SamlDeployment} that is being built.+     * @param loader a reference to the {@code ResourceLoader} that allows the provider implementation to load additional+     *               resources from the SP application WAR.+     * @param providerConfig the provider configuration properties as configured in {@code keycloak-saml.xml}. Can contain+ *                   an empty properties object if no configuration was specified for the provider.+     * @return the configured+     */+    public static RoleMappingsProvider bootstrapRoleMappingsProvider(final SamlDeployment deployment, final ResourceLoader loader, final SP.RoleMappingsProviderConfig providerConfig) {+        String providerId;+        if (providerConfig == null || providerConfig.getId() == null) {","I see your point. However, if you are adding a new role-mappings.properties file, it is not a big step to add also `<RoleMappingsProvider id=""properties-based-role-mapper"" />` to keycloak-saml.xml. To make things even more simple, it might be possible to make it work even like this: `<RoleMappingsProvider>` with id defaulting to `properties-based-role-mapper.`",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6262,318429601,2019-08-28T07:29:29Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/vault/KeycloakVaultTest.java,"@@ -0,0 +1,98 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.vault;++import java.lang.ref.WeakReference;+import java.util.List;+import java.util.Optional;++import org.jboss.arquillian.container.test.api.Deployment;+import org.jboss.shrinkwrap.api.spec.WebArchive;+import org.junit.Assert;+import org.junit.Test;+import org.keycloak.models.KeycloakSession;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.testsuite.AbstractKeycloakTest;+import org.keycloak.testsuite.runonserver.RunOnServer;+import org.keycloak.testsuite.runonserver.RunOnServerDeployment;+import org.keycloak.testsuite.utils.io.IOUtil;+import org.keycloak.vault.VaultTranscriber;++/**+ * Tests the usage of the {@link VaultTranscriber} on the server side. The tests attempt to obtain the transcriber from+ * the session and then use it to obtain secrets from the configured provider.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class KeycloakVaultTest extends AbstractKeycloakTest {++    @Deployment+    public static WebArchive deploy() {+        return RunOnServerDeployment.create();+    }++    @Override+    public void addTestRealms(List<RealmRepresentation> testRealms) {+        testRealms.add(IOUtil.loadRealm(""/testrealm.json""));+    }++    @Test+    public void testKeycloakVault() throws Exception {",I believe it can be done here: https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/servers/auth-server/jboss/common/jboss-cli/keycloak-server-subsystem.cli,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6262,318496842,2019-08-28T10:04:05Z,services/src/test/java/org/keycloak/vault/VaultTranscriberTest.java,"@@ -0,0 +1,210 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.lang.ref.WeakReference;+import java.nio.ByteBuffer;+import java.nio.CharBuffer;+import java.nio.charset.StandardCharsets;+import java.util.Arrays;+import java.util.HashMap;+import java.util.Map;+import java.util.Optional;++import org.junit.Assert;+import org.junit.Test;++/**+ * Tests for the {@link DefaultVaultTranscriber} implementation.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class VaultTranscriberTest {++    private final VaultTranscriber transcriber = new DefaultVaultTranscriber(new TestVaultProvider());++    @Test+    public void testDetectVaultExpressions() throws Exception {+        String[] validExpressions = new String[]{""${vault.vault-id}"", ""${vault.${.id-!@#$%^&*_()}}""};+        for (String expression : validExpressions) {+            Assert.assertTrue(transcriber.isVaultExpression(expression));+        }++        String[] invalidExpressions = new String[]{""${vault.}"",""$vault.id}"", ""{vault.id}"", ""${vault.id"", ""${vaultid}"", """"};+        for (String expression : invalidExpressions) {+            Assert.assertFalse(transcriber.isVaultExpression(expression));+        }+    }++    @Test+    public void testExtractVaultEntryId() throws Exception {+        // entry containing simple text.+        String entryId = transcriber.getVaultEntryKey(""${vault.entrytext}"");+        Assert.assertNotNull(entryId);+        Assert.assertEquals(""entrytext"", entryId);+        // entry with underscores.+        entryId = transcriber.getVaultEntryKey(""${vault.entry_id_with_underscore}"");+        Assert.assertNotNull(entryId);+        Assert.assertEquals(""entry_id_with_underscore"", entryId);+        // entry with special characters, starting with ${ and ending in }.+        entryId = transcriber.getVaultEntryKey(""${vault.${.id-!@#$%^&*_()}}"");+        Assert.assertNotNull(entryId);+        Assert.assertEquals(""${.id-!@#$%^&*_()}"", entryId);+    }++    @Test+    public void testRetrieveRawSecret() throws Exception {+        ByteBuffer secretBuffer;++        // first attempt to obtain a secret using a proper vault string with an existing key.+        try (VaultRawSecret secret = transcriber.getRawSecret(""${vault.vault_key_1}"")) {+            Optional<ByteBuffer> optional = secret.getRawSecret();+            Assert.assertTrue(optional.isPresent());+            secretBuffer = optional.get();+            Assert.assertTrue(Arrays.equals(""secret1"".getBytes(StandardCharsets.UTF_8), secretBuffer.array()));+        }+        // after the try-with-resources block the secret should have been overridden+        Assert.assertFalse(Arrays.equals(""secret1"".getBytes(StandardCharsets.UTF_8), secretBuffer.array()));++        // now attempt to obtain a secret using a proper vault string with a non-existing key. The string itself should be encoded.+        try (VaultRawSecret secret = transcriber.getRawSecret(""${vault.non_existing_key}"")) {+            Optional<ByteBuffer> optional = secret.getRawSecret();+            Assert.assertFalse(optional.isPresent());+        }++        // finally try to obtain a secret using a string that is not a vault string.+        try (VaultRawSecret secret = transcriber.getRawSecret(""non_vault_secret"")) {+            Optional<ByteBuffer> optional = secret.getRawSecret();+            Assert.assertTrue(optional.isPresent());+            secretBuffer = optional.get();+            Assert.assertTrue(Arrays.equals(""non_vault_secret"".getBytes(StandardCharsets.UTF_8), secretBuffer.array()));+        }+        // after the try-with-resources block the secret should have been overridden+        Assert.assertFalse(Arrays.equals(""non_vault_secret"".getBytes(StandardCharsets.UTF_8), secretBuffer.array()));++        // check that a null expression results in an empty optional instance.+        try (VaultRawSecret secret = transcriber.getRawSecret(null)) {+            Assert.assertFalse(secret.getRawSecret().isPresent());+        }+    }++    @Test+    public void testRetrieveCharSecret() throws Exception {+        CharBuffer secretBuffer;++        // first attempt to obtain a secret using a proper vault string with an existing key.+        try (VaultCharSecret secret = transcriber.getCharSecret(""${vault.vault_key_2}"")) {+            Optional<CharBuffer> optional = secret.getCharSecret();+            Assert.assertTrue(optional.isPresent());+            secretBuffer = optional.get();+            Assert.assertTrue(Arrays.equals(""secret2"".toCharArray(), secretBuffer.array()));+        }+        // after the try-with-resources block the secret should have been overridden+        Assert.assertFalse(Arrays.equals(""secret2"".toCharArray(), secretBuffer.array()));++        // now attempt to obtain a secret using a proper vault string with a non-existing key.+        try (VaultCharSecret secret = transcriber.getCharSecret(""${vault.non_existing_key}"")) {+            Optional<CharBuffer> optional = secret.getCharSecret();+            Assert.assertFalse(optional.isPresent());+        }++        // finally try to obtain a secret using a string that is not a vault string. The string itself should be encoded.+        try (VaultCharSecret secret = transcriber.getCharSecret(""non_vault_secret"")) {+            Optional<CharBuffer> optional = secret.getCharSecret();+            Assert.assertTrue(optional.isPresent());+            secretBuffer = optional.get();+            Assert.assertTrue(Arrays.equals(""non_vault_secret"".toCharArray(), secretBuffer.array()));+        }+        // after the try-with-resources block the secret should have been overridden+        Assert.assertFalse(Arrays.equals(""non_vault_secret"".toCharArray(), secretBuffer.array()));++        // check that a null expression results in an empty optional instance.+        try (VaultCharSecret secret = transcriber.getCharSecret(null)) {+            Assert.assertFalse(secret.getCharSecret().isPresent());+        }+    }++    @Test+    public void testRetrieveStringSecret() throws Exception {++        // first attempt to obtain a secret using a proper vault string with an existing key.+        Optional<WeakReference<String>> optional = transcriber.getStringSecret(""${vault.vault_key_1}"");+        Assert.assertTrue(optional.isPresent());+        WeakReference<String> stringSecret = optional.get();+        Assert.assertEquals(""secret1"", stringSecret.get());++        // now attempt to obtain a secret using a proper vault string with a non-existing key.+        optional = transcriber.getStringSecret(""${vault.non_existing_key}"");+        Assert.assertFalse(optional.isPresent());++        // finally try to obtain a secret using a string that is not a vault string. The string itself should be returned.+        optional = transcriber.getStringSecret(""non_vault_secret"");+        Assert.assertTrue(optional.isPresent());+        stringSecret = optional.get();+        Assert.assertEquals(""non_vault_secret"", stringSecret.get());++        // check that a null expression results in an empty optional instance.+        optional = transcriber.getStringSecret(null);+        Assert.assertFalse(optional.isPresent());+    }++    @Test+    public void testTranscriberWithNullProvider() {+        VaultTranscriber transcriber = new DefaultVaultTranscriber(null);+        // attempt to use the transcriber to obtain a secret using a valid vault expression (i.e. requires a proper provider)+        try {",Please do not use this way of testing expected exception. Use `@Rule ExpectedException` instead as illustrated e.g. here:https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/realm/RealmTest.java#L228,
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6273,318597833,2019-08-28T14:00:53Z,services/src/main/java/org/keycloak/services/resources/account/SessionResource.java,"@@ -0,0 +1,222 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.services.resources.account;++import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;+import java.util.HashMap;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;++import org.jboss.resteasy.annotations.cache.NoCache;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.representations.account.ClientRepresentation;+import org.keycloak.representations.account.DeviceRepresentation;+import org.keycloak.representations.account.SessionRepresentation;+import org.keycloak.services.managers.Auth;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.resources.Cors;++/**+ * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>","@pedroigor no big deal, but I believe worth to change the author here.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6262,318701285,2019-08-28T17:23:52Z,server-spi/src/main/java/org/keycloak/vault/VaultTranscriber.java,"@@ -0,0 +1,112 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.lang.ref.WeakReference;+import java.nio.CharBuffer;+import java.util.Optional;++/**+ * A facade to the configured vault provider that exposes utility methods for obtaining the vault secrets in different+ * formats (such as {@link VaultRawSecret}, {@link VaultCharSecret} or {@link WeakReference<String>}).+ *+ * @see VaultRawSecret+ * @see VaultCharSecret+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public interface VaultTranscriber {++    /**+     * Obtains the raw secret from the vault that matches the entry in the specified value string. The value must follow+     * the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in the vault. If the value doesn't follow+     * the vault expression format, it is assumed to be the secret itself and is encoded into a {@link VaultRawSecret}.+     * <p/>+     * To avoid unnecessary encoding it is recommended that the {@link #isVaultExpression(String)} method is used to check+     * if the value is a vault expression and then call this method only when that is true.+     * <p/>+     * The returned {@link VaultRawSecret} extends {@link AutoCloseable} and it is strongly recommended that it is used in+     * try-with-resources blocks to ensure the raw secret is overridden (destroyed) when the calling code is finished using+     * it.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return a {@link VaultRawSecret} representing the secret that was read from the vault. If the specified value is not+     *         a vault expression then the returned secret is the value itself encoded as a {@link VaultRawSecret}.+     */+    VaultRawSecret getRawSecret(final String value);++    /**+     * Obtains the secret represented as a {@link VaultCharSecret} from the vault that matches the entry in the specified+     * value string. The value must follow the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in+     * the vault. If the value doesn't follow the vault expression format, it is assumed to be the secret itself and is+     * encoded into a {@link VaultCharSecret}.+     * <p/>+     * To avoid unnecessary encoding it is recommended that the {@link #isVaultExpression(String)} method is used to check+     * if the value is a vault expression and then call this method only when that is true.+     * <p/>+     * The returned {@link VaultCharSecret} extends {@link AutoCloseable} and it is strongly recommended that it is used in+     * try-with-resources blocks to ensure the raw secret is overridden (destroyed) when the calling code is finished using+     * it.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return a {@link VaultRawSecret} representing the secret that was read from the vault. If the specified value is not+     *         a vault expression then the returned secret is the value itself encoded as a {@link VaultRawSecret}.+     */+    VaultCharSecret getCharSecret(final String value);++    /**+     * Obtains the secret represented as a {@link String} from the vault that matches the entry in the specified value.+     * The value must follow the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in the vault. If+     * the value doesn't follow the vault expression format, it is assumed to be the secret itself.+     * <p/>+     * To avoid unnecessary manipulation of the value string it is recommended that the {@link #isVaultExpression(String)}+     * method is used to check if the value is a vault entry string and then call this method only when that is true.+     * <p/>+     * <b>WARNING:</b> this method, unlike the other variations, doesn't return an {@link AutoCloseable} secret because+     * strings cannot be overridden (destroyed) so there's no point in having a special type to enclose the secret+     * string for usage in try-with-resources blocks. This means the secret might be visible in memory for as long as the+     * string object exists. For this reason, the constructed string is returned as a {@link WeakReference} to convey that+     * the secret string shouldn't be held longer than needed and to make sure it is available for the GC as soon as possible.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return an {@link Optional} holding the weak reference to the constructed secret string. If the specified value is not+     *         a vault expression then the returned secret is the value itself enclosed in a {@link WeakReference}.+     */+    Optional<WeakReference<String>> getStringSecret(final String value);","Yeah, we've discussed this on a call when I said I would likely drop the secret class for the String case. Looking at it now, I also agree that consistency is important so I will add it back.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6262,318911074,2019-08-29T06:54:35Z,server-spi/src/main/java/org/keycloak/vault/VaultTranscriber.java,"@@ -0,0 +1,112 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.lang.ref.WeakReference;+import java.nio.CharBuffer;+import java.util.Optional;++/**+ * A facade to the configured vault provider that exposes utility methods for obtaining the vault secrets in different+ * formats (such as {@link VaultRawSecret}, {@link VaultCharSecret} or {@link WeakReference<String>}).+ *+ * @see VaultRawSecret+ * @see VaultCharSecret+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public interface VaultTranscriber {++    /**+     * Obtains the raw secret from the vault that matches the entry in the specified value string. The value must follow+     * the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in the vault. If the value doesn't follow+     * the vault expression format, it is assumed to be the secret itself and is encoded into a {@link VaultRawSecret}.+     * <p/>+     * To avoid unnecessary encoding it is recommended that the {@link #isVaultExpression(String)} method is used to check+     * if the value is a vault expression and then call this method only when that is true.+     * <p/>+     * The returned {@link VaultRawSecret} extends {@link AutoCloseable} and it is strongly recommended that it is used in+     * try-with-resources blocks to ensure the raw secret is overridden (destroyed) when the calling code is finished using+     * it.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return a {@link VaultRawSecret} representing the secret that was read from the vault. If the specified value is not+     *         a vault expression then the returned secret is the value itself encoded as a {@link VaultRawSecret}.+     */+    VaultRawSecret getRawSecret(final String value);++    /**+     * Obtains the secret represented as a {@link VaultCharSecret} from the vault that matches the entry in the specified+     * value string. The value must follow the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in+     * the vault. If the value doesn't follow the vault expression format, it is assumed to be the secret itself and is+     * encoded into a {@link VaultCharSecret}.+     * <p/>+     * To avoid unnecessary encoding it is recommended that the {@link #isVaultExpression(String)} method is used to check+     * if the value is a vault expression and then call this method only when that is true.+     * <p/>+     * The returned {@link VaultCharSecret} extends {@link AutoCloseable} and it is strongly recommended that it is used in+     * try-with-resources blocks to ensure the raw secret is overridden (destroyed) when the calling code is finished using+     * it.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return a {@link VaultRawSecret} representing the secret that was read from the vault. If the specified value is not+     *         a vault expression then the returned secret is the value itself encoded as a {@link VaultRawSecret}.+     */+    VaultCharSecret getCharSecret(final String value);++    /**+     * Obtains the secret represented as a {@link String} from the vault that matches the entry in the specified value.+     * The value must follow the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in the vault. If+     * the value doesn't follow the vault expression format, it is assumed to be the secret itself.+     * <p/>+     * To avoid unnecessary manipulation of the value string it is recommended that the {@link #isVaultExpression(String)}+     * method is used to check if the value is a vault entry string and then call this method only when that is true.+     * <p/>+     * <b>WARNING:</b> this method, unlike the other variations, doesn't return an {@link AutoCloseable} secret because+     * strings cannot be overridden (destroyed) so there's no point in having a special type to enclose the secret+     * string for usage in try-with-resources blocks. This means the secret might be visible in memory for as long as the+     * string object exists. For this reason, the constructed string is returned as a {@link WeakReference} to convey that+     * the secret string shouldn't be held longer than needed and to make sure it is available for the GC as soon as possible.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return an {@link Optional} holding the weak reference to the constructed secret string. If the specified value is not+     *         a vault expression then the returned secret is the value itself enclosed in a {@link WeakReference}.+     */+    Optional<WeakReference<String>> getStringSecret(final String value);++    /**+     * Determines if the specified value is a vault expression referencing a vault entry key or not. A vault entry key is+     * specified using the format {@code ${vault.<KEY>}}. For example, the string {@code ${vault.smtp_secret}} identifies+     * an entry in the vault whose key is {@code smtp_secret}.+     *+     * @param value the {@code String} to be checked.+     * @return {@code true} if the given value is a vault expression following the {@code ${vault.<KEY>}} format;+     *          {@code false} otherwise.+     */+    boolean isVaultExpression(final String value);",I would probably vote for removing this. In the state how it is now one need to double-treat the same else branch (basically two very similar ifs). One `isVaultExpression` and the second `Optional.isPresent()`. I don't think this will have a lot of performance issues with encoding all values to *Secret since this will not be used so often.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6262,319258725,2019-08-29T20:31:08Z,server-spi/src/main/java/org/keycloak/vault/VaultTranscriber.java,"@@ -0,0 +1,112 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.lang.ref.WeakReference;+import java.nio.CharBuffer;+import java.util.Optional;++/**+ * A facade to the configured vault provider that exposes utility methods for obtaining the vault secrets in different+ * formats (such as {@link VaultRawSecret}, {@link VaultCharSecret} or {@link WeakReference<String>}).+ *+ * @see VaultRawSecret+ * @see VaultCharSecret+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public interface VaultTranscriber {++    /**+     * Obtains the raw secret from the vault that matches the entry in the specified value string. The value must follow+     * the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in the vault. If the value doesn't follow+     * the vault expression format, it is assumed to be the secret itself and is encoded into a {@link VaultRawSecret}.+     * <p/>+     * To avoid unnecessary encoding it is recommended that the {@link #isVaultExpression(String)} method is used to check+     * if the value is a vault expression and then call this method only when that is true.+     * <p/>+     * The returned {@link VaultRawSecret} extends {@link AutoCloseable} and it is strongly recommended that it is used in+     * try-with-resources blocks to ensure the raw secret is overridden (destroyed) when the calling code is finished using+     * it.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return a {@link VaultRawSecret} representing the secret that was read from the vault. If the specified value is not+     *         a vault expression then the returned secret is the value itself encoded as a {@link VaultRawSecret}.+     */+    VaultRawSecret getRawSecret(final String value);++    /**+     * Obtains the secret represented as a {@link VaultCharSecret} from the vault that matches the entry in the specified+     * value string. The value must follow the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in+     * the vault. If the value doesn't follow the vault expression format, it is assumed to be the secret itself and is+     * encoded into a {@link VaultCharSecret}.+     * <p/>+     * To avoid unnecessary encoding it is recommended that the {@link #isVaultExpression(String)} method is used to check+     * if the value is a vault expression and then call this method only when that is true.+     * <p/>+     * The returned {@link VaultCharSecret} extends {@link AutoCloseable} and it is strongly recommended that it is used in+     * try-with-resources blocks to ensure the raw secret is overridden (destroyed) when the calling code is finished using+     * it.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return a {@link VaultRawSecret} representing the secret that was read from the vault. If the specified value is not+     *         a vault expression then the returned secret is the value itself encoded as a {@link VaultRawSecret}.+     */+    VaultCharSecret getCharSecret(final String value);++    /**+     * Obtains the secret represented as a {@link String} from the vault that matches the entry in the specified value.+     * The value must follow the format {@code ${vault.<KEY>}} where {@code <KEY>} identifies the entry in the vault. If+     * the value doesn't follow the vault expression format, it is assumed to be the secret itself.+     * <p/>+     * To avoid unnecessary manipulation of the value string it is recommended that the {@link #isVaultExpression(String)}+     * method is used to check if the value is a vault entry string and then call this method only when that is true.+     * <p/>+     * <b>WARNING:</b> this method, unlike the other variations, doesn't return an {@link AutoCloseable} secret because+     * strings cannot be overridden (destroyed) so there's no point in having a special type to enclose the secret+     * string for usage in try-with-resources blocks. This means the secret might be visible in memory for as long as the+     * string object exists. For this reason, the constructed string is returned as a {@link WeakReference} to convey that+     * the secret string shouldn't be held longer than needed and to make sure it is available for the GC as soon as possible.+     *+     * @param value a {@link String} that might be a vault expression containing a vault entry key.+     * @return an {@link Optional} holding the weak reference to the constructed secret string. If the specified value is not+     *         a vault expression then the returned secret is the value itself enclosed in a {@link WeakReference}.+     */+    Optional<WeakReference<String>> getStringSecret(final String value);",Reintroduced the VaultStringSecret class.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6262,319259013,2019-08-29T20:31:57Z,server-spi/src/main/java/org/keycloak/vault/VaultCharSecret.java,"@@ -0,0 +1,42 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.nio.CharBuffer;+import java.util.Optional;++/**+ * A {@link CharBuffer} based representation of the secret obtained from the vault that supports automated cleanup of memory.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public interface VaultCharSecret extends AutoCloseable {++    /**+     * Returns the secret enclosed in a {@code CharBuffer}.+     * @return If the secret was successfully resolved by vault, returns an {@link Optional} containing the value returned+     *         by the vault as a {@code CharBuffer} (a valid value can be {@code null}), or an empty {@link Optional}+     */+    Optional<CharBuffer> getCharSecret();",I've changed the get* methods on all secret classes to just get() to avoid the above situation of having transcriber.get*Secret().get*Secret();,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6262,319375159,2019-08-30T06:44:16Z,services/src/main/java/org/keycloak/vault/DefaultVaultTranscriber.java,"@@ -0,0 +1,106 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.lang.ref.WeakReference;+import java.nio.ByteBuffer;+import java.nio.CharBuffer;+import java.nio.charset.StandardCharsets;+import java.util.Optional;+import java.util.regex.Matcher;+import java.util.regex.Pattern;++/**+ * Default {@link VaultTranscriber} implementation that uses the configured {@link VaultProvider} to obtain raw secrets+ * and convert them into other types. By default, the {@link VaultProvider} provides raw secrets through a {@link ByteBuffer}.+ * This class offers methods to convert the raw secrets into other types (such as {@link VaultCharSecret} or {@link WeakReference<String>}).+ *+ * @see VaultRawSecret+ * @see VaultCharSecret+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class DefaultVaultTranscriber implements VaultTranscriber {++    private static final Pattern pattern = Pattern.compile(""^\\$\\{vault\\.(.+)}$"");","Nit: should have been```suggestion    private static final Pattern pattern = Pattern.compile(""^\\$\\{vault\\.(.+?)}$"");```But can go in this way as well.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6262,319569476,2019-08-30T15:40:40Z,services/src/main/java/org/keycloak/vault/DefaultVaultTranscriber.java,"@@ -0,0 +1,106 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.lang.ref.WeakReference;+import java.nio.ByteBuffer;+import java.nio.CharBuffer;+import java.nio.charset.StandardCharsets;+import java.util.Optional;+import java.util.regex.Matcher;+import java.util.regex.Pattern;++/**+ * Default {@link VaultTranscriber} implementation that uses the configured {@link VaultProvider} to obtain raw secrets+ * and convert them into other types. By default, the {@link VaultProvider} provides raw secrets through a {@link ByteBuffer}.+ * This class offers methods to convert the raw secrets into other types (such as {@link VaultCharSecret} or {@link WeakReference<String>}).+ *+ * @see VaultRawSecret+ * @see VaultCharSecret+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class DefaultVaultTranscriber implements VaultTranscriber {++    private static final Pattern pattern = Pattern.compile(""^\\$\\{vault\\.(.+)}$"");++    private final VaultProvider provider;++    public DefaultVaultTranscriber(final VaultProvider provider) {+        this.provider = provider;+    }++    @Override+    public VaultRawSecret getRawSecret(final String value) {+        String entryId = this.getVaultEntryKey(value);+        if (entryId != null) {+            if (this.provider == null) {+                throw new IllegalStateException(""Required VaultProvider not found - check vault configuration"");+            }+            // we have a valid ${vault.<KEY>} string, use the provider to retrieve the entry.+            return this.provider.obtainSecret(entryId);+        } else {+            // not a vault expression - encode the value itself as a byte buffer.+            ByteBuffer buffer = value != null ? ByteBuffer.wrap(value.getBytes(StandardCharsets.UTF_8)) : null;+            return DefaultVaultRawSecret.forBuffer(Optional.ofNullable(buffer));+        }+    }++    @Override+    public VaultCharSecret getCharSecret(final String value) {+        // obtain the raw secret and convert it into a char secret.+        try (VaultRawSecret rawSecret = this.getRawSecret(value)) {+            if (!rawSecret.get().isPresent()) {+                return DefaultVaultCharSecret.forBuffer(Optional.empty());+            }+            ByteBuffer rawSecretBuffer = rawSecret.get().get();+            CharBuffer charSecretBuffer = StandardCharsets.UTF_8.decode(rawSecretBuffer);+            return DefaultVaultCharSecret.forBuffer(Optional.of(charSecretBuffer));+        }+    }++    @Override+    public VaultStringSecret getStringSecret(final String value) {+        // obtain the raw secret and convert it into a string string.+        try (VaultRawSecret rawSecret = this.getRawSecret(value)) {+            if (!rawSecret.get().isPresent()) {+                return DefaultVaultStringSecret.forString(Optional.empty());+            }+            ByteBuffer rawSecretBuffer = rawSecret.get().get();+            return DefaultVaultStringSecret.forString(Optional.of(StandardCharsets.UTF_8.decode(rawSecretBuffer).toString()));","Can't build a string using the ByteBuffer as a parameter, only bytes. And we can't just do rawSecretBuffer.array() because that can be null when a direct buffer is used, so the right way to obtain the internal array would be to create a byte[] with the buffer capacity and use rawSecretBuffer.get(byte[]). Not sure it is worth doing it here though.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6273,319609071,2019-08-30T17:30:38Z,services/src/main/java/org/keycloak/services/resources/account/SessionResource.java,"@@ -0,0 +1,222 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.services.resources.account;++import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;+import java.util.HashMap;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;++import org.jboss.resteasy.annotations.cache.NoCache;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.representations.account.ClientRepresentation;+import org.keycloak.representations.account.DeviceRepresentation;+import org.keycloak.representations.account.SessionRepresentation;+import org.keycloak.services.managers.Auth;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.resources.Cors;++/**+ * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>+ */+public class SessionResource {++    private final KeycloakSession session;+    private final Auth auth;+    private final RealmModel realm;+    private final UserModel user;+    private HttpRequest request;++    public SessionResource(KeycloakSession session, Auth auth, HttpRequest request) {+        this.session = session;+        this.auth = auth;+        this.realm = auth.getRealm();+        this.user = auth.getUser();+        this.request = request;+    }++    /**+     * Get session information.+     *+     * @return+     */+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response sessions() {+        List<SessionRepresentation> reps = new LinkedList<>();+        List<UserSessionModel> sessions = session.sessions().getUserSessions(realm, user);+        UserSessionModel currentSession = auth.getSession();++        for (UserSessionModel s : sessions) {+            SessionRepresentation rep = new SessionRepresentation();+            rep.setId(s.getId());+            rep.setIpAddress(s.getIpAddress());+            rep.setStarted(s.getStarted());+            rep.setLastAccess(s.getLastSessionRefresh());+            rep.setExpires(s.getStarted() + realm.getSsoSessionMaxLifespan());+            rep.setClients(new LinkedList());++            if (currentSession.getId().equals(s.getId())) {+                rep.setCurrent(true);+            }++            for (String clientUUID : s.getAuthenticatedClientSessions().keySet()) {+                ClientModel client = realm.getClientById(clientUUID);+                ClientRepresentation clientRep = new ClientRepresentation();+                clientRep.setClientId(client.getClientId());+                clientRep.setClientName(client.getName());+                rep.getClients().add(clientRep);+            }++            reps.add(rep);+        }++        return Cors.add(request, Response.ok(reps)).auth().allowedOrigins(auth.getToken()).build();+    }++    /**+     * Get device activity information based on the active sessions.+     *+     * @return+     */+    @Path(""devices"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response devices() {+        Map<String, DeviceRepresentation> reps = new HashMap<>();+        List<UserSessionModel> sessions = session.sessions().getUserSessions(realm, user);+        UserSessionModel currentSession = auth.getSession();++        for (UserSessionModel s : sessions) {+            DeviceRepresentation device = DeviceActivityManager.getCurrentDevice(s);++            if (device != null) {+                DeviceRepresentation deviceRep = reps+                        .computeIfAbsent(device.getOs() + device.getOsVersion(), s1 -> {+                            DeviceRepresentation representation = new DeviceRepresentation();+                            +                            representation.setLastAccess(device.getLastAccess());+                            representation.setOs(device.getOs());+                            representation.setOsVersion(device.getOsVersion());+                            representation.setDevice(device.getDevice());+                            representation.setMobile(device.isMobile());+                            +                            return representation;+                        });++                if (deviceRep.getCurrent() == null || Boolean.FALSE.equals(deviceRep.getCurrent())) {+                    deviceRep.setCurrent(s.getId().equals(currentSession.getId()));+                }+                +                if (Boolean.TRUE.equals(deviceRep.getCurrent())) {+                    deviceRep.setBrowser(device.getBrowser());+                    deviceRep.setIpAddress(device.getIpAddress());+                }","What does it mean for the device to have a ""browser"".  I would expect the browser to belong only to the session and not the device.Also, I'm not sure we have clarified what it means for the device to have a single IP address.  Right now in the UI, I consider the device IP to be the IP from the first session in the list.  That is because this code only sets the IP for the current device, so I can't count on it being present for all devices.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6273,319667122,2019-08-30T20:36:25Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/SessionRestServiceTest.java,"@@ -0,0 +1,390 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.account;++import static org.junit.Assert.assertEquals;+import static org.junit.Assert.assertNotNull;+import static org.junit.Assert.assertThat;+import static org.junit.Assert.assertTrue;+import static org.keycloak.common.Profile.Feature.ACCOUNT_API;+import static org.keycloak.common.Profile.Feature.DEVICE_ACTIVITY;+import static org.keycloak.testsuite.ProfileAssume.assumeFeatureEnabled;++import javax.ws.rs.core.Response;+import java.io.IOException;+import java.util.List;+import java.util.stream.Collectors;++import com.fasterxml.jackson.core.type.TypeReference;+import org.hamcrest.Matchers;+import org.jboss.arquillian.drone.api.annotation.Drone;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.OAuth2Constants;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.representations.account.ClientRepresentation;+import org.keycloak.representations.account.DeviceRepresentation;+import org.keycloak.representations.account.SessionRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.testsuite.util.ClientBuilder;+import org.keycloak.testsuite.util.ContainerAssume;+import org.keycloak.testsuite.util.OAuthClient;+import org.keycloak.testsuite.util.SecondBrowser;+import org.keycloak.testsuite.util.ThirdBrowser;+import org.keycloak.testsuite.util.TokenUtil;+import org.openqa.selenium.WebDriver;++/**+ * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>+ */+public class SessionRestServiceTest extends AbstractRestServiceTest {++    @Drone+    @SecondBrowser+    protected WebDriver secondBrowser;++    @Drone+    @ThirdBrowser+    protected WebDriver thirdBrowser;++    @Override+    public void configureTestRealm(RealmRepresentation testRealm) {+        super.configureTestRealm(testRealm);++        testRealm.getClients().add(ClientBuilder.create()+                .clientId(""public-client-0"")+                .name(""Public Client 0"")+                .baseUrl(""http://client0.example.com"")+                .redirectUris(OAuthClient.APP_ROOT + ""/auth"")+                .publicClient().build());++        testRealm.getClients().add(ClientBuilder.create()+                .clientId(""public-client-1"")+                .name(""Public Client 1"")+                .baseUrl(""http://client1.example.com"")+                .redirectUris(OAuthClient.APP_ROOT + ""/auth"")+                .publicClient().build());+    }++    @Test+    public void testProfilePreviewPermissions() throws IOException {+        assumeFeatureEnabled(ACCOUNT_API);++        TokenUtil noaccessToken = new TokenUtil(""no-account-access"", ""password"");+        TokenUtil viewToken = new TokenUtil(""view-account-access"", ""password"");++        // Read sessions with no access+        assertEquals(403, SimpleHttp.doGet(getAccountUrl(""sessions""), httpClient).header(""Accept"", ""application/json"")+                .auth(noaccessToken.getToken()).asStatus());++        // Delete all sessions with no access+        assertEquals(403, SimpleHttp.doDelete(getAccountUrl(""sessions""), httpClient).header(""Accept"", ""application/json"")+                .auth(noaccessToken.getToken()).asStatus());++        // Delete all sessions with read only+        assertEquals(403, SimpleHttp.doDelete(getAccountUrl(""sessions""), httpClient).header(""Accept"", ""application/json"")+                .auth(viewToken.getToken()).asStatus());++        // Delete single session with no access+        assertEquals(403,+                SimpleHttp.doDelete(getAccountUrl(""sessions/bogusId""), httpClient).header(""Accept"", ""application/json"")+                        .auth(noaccessToken.getToken()).asStatus());++        // Delete single session with read only+        assertEquals(403,+                SimpleHttp.doDelete(getAccountUrl(""sessions/bogusId""), httpClient).header(""Accept"", ""application/json"")+                        .auth(viewToken.getToken()).asStatus());+    }++    @Before+    @Override+    public void before() {+        super.before();+        try {+            Response response = testingClient.testing().enableFeature(DEVICE_ACTIVITY.toString());+            assertEquals(200, response.getStatus());+        } catch (Exception e) {+            throw e;+        }+        assumeFeatureEnabled(ACCOUNT_API);+    }++    @Test+    public void testGetSessions() throws Exception {+        oauth.setDriver(secondBrowser);+        codeGrant(""public-client-0"");++        List<SessionRepresentation> sessions = getSessions();+        assertEquals(2, sessions.size());++        for (SessionRepresentation session : sessions) {+            assertNotNull(session.getId());+            assertEquals(""127.0.0.1"", session.getIpAddress());+            assertTrue(session.getLastAccess() > 0);+            assertTrue(session.getExpires() > 0);+            assertTrue(session.getStarted() > 0);+            assertThat(session.getClients(), Matchers.hasItem(Matchers.hasProperty(""clientId"",+                    Matchers.anyOf(Matchers.is(""direct-grant""), Matchers.is(""public-client-0"")))));+        }+    }++    @Test+    public void testGetDevicesResponse() throws Exception {+        ContainerAssume.assumeAuthServerUndertow();+        assumeFeatureEnabled(DEVICE_ACTIVITY);++        oauth.setBrowserHeader(""User-Agent"", ""Mozilla/5.0 (Windows NT 10.0) Gecko/20100101 Firefox/15.0.1"");+        OAuthClient.AccessTokenResponse tokenResponse = codeGrant(""public-client-0"");+        joinSsoSession(""public-client-1"");+        +        List<DeviceRepresentation> devices = getDevices(tokenResponse.getAccessToken());++        assertEquals(""Should have a single device"", 1, devices.size());++        DeviceRepresentation device = devices.get(0);++        assertTrue(device.getCurrent());+        assertEquals(""Windows"", device.getOs());+        assertEquals(""10"", device.getOsVersion());+        assertEquals(""Other"", device.getDevice());++        List<SessionRepresentation> sessions = device.getSessions();+        assertEquals(1, sessions.size());+        SessionRepresentation session = sessions.get(0);+        assertEquals(""127.0.0.1"", session.getIpAddress());+        assertEquals(session.getIpAddress(), device.getIpAddress());+        assertTrue(device.getLastAccess() == session.getLastAccess());+        assertEquals(""Firefox/15.0.1"", device.getBrowser());+        assertEquals(session.getBrowser(), device.getBrowser());++        List<ClientRepresentation> clients = session.getClients();+        assertEquals(2, clients.size());+        assertThat(session.getClients(), Matchers.hasItem(Matchers.hasProperty(""clientId"",+                Matchers.anyOf(Matchers.is(""public-client-0""), Matchers.is(""public-client-1"")))));+        assertThat(session.getClients(), Matchers.hasItem(Matchers.hasProperty(""clientName"",+                Matchers.anyOf(Matchers.is(""Public Client 0""), Matchers.is(""Public Client 1"")))));+    }++    @Test+    public void testGetDevicesSessions() throws Exception {+        ContainerAssume.assumeAuthServerUndertow();+        assumeFeatureEnabled(DEVICE_ACTIVITY);++        WebDriver firstBrowser = oauth.getDriver();++        // first browser authenticates from Fedora","Could you please provide more details how tests crash after setting  `oauth.setBrowserHeader("""", """");`. It seems to me that when doing that you are actually breaking the webdriver and not really checking the behavior.Did you get this?```org.openqa.selenium.NoSuchElementException: Unable to locate element by id for com.gargoylesoftware.htmlunit.TextPage@4e5dcc50For documentation on this error, please visit: http://seleniumhq.org/exceptions/no_such_element.htmlBuild info: version: '3.14.0', revision: 'aacccce0', time: '2018-08-02T20:19:58.91Z'System info: host: 'localhost.localdomain', ip: '127.0.0.1', os.name: 'Linux', os.arch: 'amd64', os.version: '5.2.9-200.fc30.x86_64', java.version: '1.8.0_151'Driver info: driver.version: HtmlUnitDriver```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6268,319887508,2019-09-02T09:52:20Z,server-spi-private/src/main/java/org/keycloak/broker/provider/util/SimpleHttp.java,"@@ -20,21 +20,14 @@ import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper;-import org.apache.http.Header;-import org.apache.http.HeaderIterator;-import org.apache.http.HttpEntity;-import org.apache.http.HttpResponse;-import org.apache.http.NameValuePair;+import org.apache.http.*;","Please remove star imports - from all java classes in the PR. In Keycloak, we prefer to avoid star imports.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6285,319958974,2019-09-02T13:29:31Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/AbstractLDAPTest.java,"@@ -78,9 +80,11 @@ public void importTestRealms() {         afterImportTestRealm();     } +    private static final String VAULT_EXPRESSION = ""${vault.ldap_bindCredential}"";      protected void createLDAPProvider() {         Map<String, String> cfg = getLDAPRule().getConfig();+        cfg.put(BIND_CREDENTIAL, VAULT_EXPRESSION);","This makes all LDAP tests to use vault secret. I would say we should remove it and use it only for some subset of LDAP tests to just confirm vault functionality. For these purposes, I created LDAPVaultCredentialsTest class. ",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,320157761,2019-09-03T08:47:33Z,testsuite/integration-arquillian/tests/base/pom.xml,"@@ -44,6 +44,11 @@     </properties>          <dependencies>+        <dependency>","I agree with you. I also would like to remove this dependency. I think it might be sufficient to realize the following:* On conducting tests under webauthn package, use ChromeDriver and set ""--enable-web-authentication-testing-api"" option.It is better to do that using exsinging arquillian/drone system. However, I'm not sure how to do it.Therefore, I've implement the test codes by other way that actually run for the moment. As you advised, I'll look into AbstractX509AuthenticationTest.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6262,320377662,2019-09-03T16:57:43Z,testsuite/integration-arquillian/servers/auth-server/jboss/common/vault/master_smtp__key,"@@ -0,0 +1 @@+secure_master_smtp_secret","Good point, I will see if I can update the poms to avoid duplication.",X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,320555290,2019-09-04T03:05:48Z,services/src/main/java/org/keycloak/models/jpa/converter/AttestationStatementConverter.java,"@@ -0,0 +1,38 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.jpa.converter;++import com.webauthn4j.converter.util.CborConverter;+import com.webauthn4j.data.attestation.statement.AttestationStatement;+import com.webauthn4j.util.Base64UrlUtil;++import javax.persistence.AttributeConverter;++public class AttestationStatementConverter implements AttributeConverter<AttestationStatement, String> {++    private CborConverter converter = new CborConverter(); //TODO: Inject by CDI to make it singleton","I'll check whether it can be realized as singleton, and if so, I would like to make it singleton in the way as you said.",X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,320555347,2019-09-04T03:06:08Z,services/src/main/java/org/keycloak/models/jpa/converter/CredentialPublicKeyConverter.java,"@@ -0,0 +1,38 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.jpa.converter;++import com.webauthn4j.converter.util.CborConverter;+import com.webauthn4j.data.attestation.authenticator.CredentialPublicKey;+import com.webauthn4j.util.Base64UrlUtil;++import javax.persistence.AttributeConverter;++public class CredentialPublicKeyConverter implements AttributeConverter<CredentialPublicKey, String> {++    private CborConverter converter = new CborConverter(); //TODO: Inject by CDI to make it singleton","I'll check whether it can be realized as singleton, and if so, I would like to make it singleton in the way as you said.",X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,320590162,2019-09-04T06:25:48Z,services/src/main/java/org/keycloak/models/jpa/converter/AAGUIDConverter.java,"@@ -0,0 +1,33 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.jpa.converter;++import com.webauthn4j.data.attestation.authenticator.AAGUID;++import javax.persistence.AttributeConverter;++public class AAGUIDConverter implements AttributeConverter<AAGUID, byte[]> {","I'll try not to use javax.persistence for AAGUIDConverter, AttestationStatementConverter and CredentialPublicKeyConverter, and I'll also remove JPA dependency in the ""services"" module.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,320654655,2019-09-04T09:13:25Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/webauthn/AppPage.java,"@@ -0,0 +1,66 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.pages.webauthn;++import org.keycloak.OAuth2Constants;+import org.keycloak.protocol.oidc.OIDCLoginProtocolService;+import org.keycloak.testsuite.pages.AbstractPage;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import javax.ws.rs.core.UriBuilder;++/**+ * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>+ */+public class AppPage extends AbstractPage {","Yes, +1 for new class and override only openAccount(). Hope we can manage to have ChromeDriver managed by arquillian/drone, but that's not a blocker for this PR and can be a done as a follow-up task IMO.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,320656622,2019-09-04T09:17:42Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/webauthn/RegisterAndLoginTest.java,"@@ -0,0 +1,285 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.webauthn;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.After;+import org.junit.Assert;+import org.junit.Before;+import org.junit.BeforeClass;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.WebAuthnConstants;+import org.keycloak.authentication.authenticators.browser.WebAuthnAuthenticatorFactory;+import org.keycloak.authentication.requiredactions.WebAuthnRegisterFactory;+import org.keycloak.common.util.RandomString;+import org.keycloak.events.Details;+import org.keycloak.events.EventType;+import org.keycloak.representations.idm.AuthenticationExecutionInfoRepresentation;+import org.keycloak.representations.idm.AuthenticatorConfigRepresentation;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.AbstractAdminTest;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.pages.webauthn.LoginPage;+import org.keycloak.testsuite.pages.webauthn.RegisterPage;+import org.keycloak.testsuite.pages.webauthn.AppPage;+import org.keycloak.testsuite.pages.webauthn.AppPage.RequestType;++import org.openqa.selenium.WebDriver;+import org.openqa.selenium.chrome.ChromeDriver;+import org.openqa.selenium.chrome.ChromeOptions;+import org.openqa.selenium.support.ui.WebDriverWait;++import io.github.bonigarcia.wdm.WebDriverManager;++import static org.junit.Assert.assertEquals;++import java.util.Arrays;+import java.util.List;+import java.util.Map;+import java.util.concurrent.TimeUnit;++public class RegisterAndLoginTest extends AbstractTestRealmKeycloakTest {","Thanks for renaming class.I will try to do some more investigation about Web Authentication Testing API and why the test doesn't work in my environment. I know that when using Web Authentication Testing API manually with my chrome browser, it works fine.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,320939596,2019-09-04T19:40:19Z,services/src/main/java/org/keycloak/authentication/requiredactions/WebAuthnRegister.java,"@@ -0,0 +1,297 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import java.util.Base64;+import java.util.List;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.keycloak.WebAuthnConstants;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.UriUtils;+import org.keycloak.credential.WebAuthnCredentialModel;+import org.keycloak.crypto.Algorithm;+import org.keycloak.events.Errors;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserModel;+import org.keycloak.models.WebAuthnPolicy;++import com.webauthn4j.data.WebAuthnRegistrationContext;+import com.webauthn4j.data.attestation.authenticator.AttestedCredentialData;+import com.webauthn4j.data.attestation.statement.AttestationStatement;+import com.webauthn4j.data.attestation.statement.COSEAlgorithmIdentifier;+import com.webauthn4j.data.client.Origin;+import com.webauthn4j.data.client.challenge.Challenge;+import com.webauthn4j.data.client.challenge.DefaultChallenge;+import com.webauthn4j.server.ServerProperty;+import com.webauthn4j.util.exception.WebAuthnException;+import com.webauthn4j.validator.WebAuthnRegistrationContextValidationResponse;+import com.webauthn4j.validator.WebAuthnRegistrationContextValidator;++public class WebAuthnRegister implements RequiredActionProvider {++    private static final Logger logger = Logger.getLogger(WebAuthnRegister.class);+    private KeycloakSession session;++    public WebAuthnRegister(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public void requiredActionChallenge(RequiredActionContext context) {+        UserModel userModel = context.getUser();+        String userid = userModel.getId();+        String username = userModel.getUsername();+        Challenge challenge = new DefaultChallenge();+        String challengeValue = Base64Url.encode(challenge.getValue());+        context.getAuthenticationSession().setAuthNote(WebAuthnConstants.AUTH_CHALLENGE_NOTE, challengeValue);++        // construct parameters for calling WebAuthn API navigator.credential.create()++        // mandatory+        WebAuthnPolicy policy = context.getRealm().getWebAuthnPolicy();+        List<String> signatureAlgorithmsList = policy.getSignatureAlgorithm();+        String signatureAlgorithms = stringifySignatureAlgorithms(signatureAlgorithmsList);+        String rpEntityName = policy.getRpEntityName();++        // optional+        String rpId = policy.getRpId();+        if (rpId == null || rpId.isEmpty()) rpId =  context.getUriInfo().getBaseUri().getHost();+        String attestationConveyancePreference = policy.getAttestationConveyancePreference();+        String authenticatorAttachment = policy.getAuthenticatorAttachment();+        String requireResidentKey = policy.getRequireResidentKey();+        String userVerificationRequirement = policy.getUserVerificationRequirement();+        long createTimeout = policy.getCreateTimeout();+        boolean avoidSameAuthenticatorRegister = policy.isAvoidSameAuthenticatorRegister();+        String excludeCredentialIds = avoidSameAuthenticatorRegister == true ? stringifyExcludeCredentialIds(userModel.getAttribute(WebAuthnConstants.PUBKEY_CRED_ID_ATTR)) : """";++        Response form = context.form()+                .setAttribute(WebAuthnConstants.CHALLENGE, challengeValue)+                .setAttribute(WebAuthnConstants.USER_ID, userid)+                .setAttribute(WebAuthnConstants.USER_NAME, username)+                .setAttribute(WebAuthnConstants.RP_ENTITY_NAME, rpEntityName)+                .setAttribute(WebAuthnConstants.SIGNATURE_ALGORITHMS, signatureAlgorithms)+                .setAttribute(WebAuthnConstants.RP_ID, rpId)+                .setAttribute(WebAuthnConstants.ATTESTATION_CONVEYANCE_PREFERENCE, attestationConveyancePreference)+                .setAttribute(WebAuthnConstants.AUTHENTICATOR_ATTACHMENT, authenticatorAttachment)+                .setAttribute(WebAuthnConstants.REQUIRE_RESIDENT_KEY, requireResidentKey)+                .setAttribute(WebAuthnConstants.USER_VERIFICATION_REQUIREMENT, userVerificationRequirement)+                .setAttribute(WebAuthnConstants.CREATE_TIMEOUT, createTimeout)+                .setAttribute(WebAuthnConstants.EXCLUDE_CREDENTIAL_IDS, excludeCredentialIds.toString())+                .createForm(""webauthn-register.ftl"");+        context.challenge(form);+    }++    @Override+    public void processAction(RequiredActionContext context) {++        MultivaluedMap<String, String> params = context.getHttpRequest().getDecodedFormParameters();++        // receive error from navigator.credentials.create()+        String errorMsgFromWebAuthnApi = params.getFirst(WebAuthnConstants.ERROR);+        if (errorMsgFromWebAuthnApi != null && !errorMsgFromWebAuthnApi.isEmpty()) {+            setErrorResponse(context, ERR_WEBAUTHN_API_CREATE, errorMsgFromWebAuthnApi);+            return;+        }++        WebAuthnPolicy policy = context.getRealm().getWebAuthnPolicy();+        String rpId = policy.getRpId();+        if (rpId == null || rpId.isEmpty()) rpId =  context.getUriInfo().getBaseUri().getHost();+        String label = params.getFirst(WebAuthnConstants.AUTHENTICATOR_LABEL);+        byte[] clientDataJSON = Base64.getUrlDecoder().decode(params.getFirst(WebAuthnConstants.CLIENT_DATA_JSON));+        byte[] attestationObject = Base64.getUrlDecoder().decode(params.getFirst(WebAuthnConstants.ATTESTATION_OBJECT));+        String publicKeyCredentialId = params.getFirst(WebAuthnConstants.PUBLIC_KEY_CREDENTIAL_ID);++        Origin origin = new Origin(UriUtils.getOrigin(context.getUriInfo().getBaseUri()));+        Challenge challenge = new DefaultChallenge(context.getAuthenticationSession().getAuthNote(WebAuthnConstants.AUTH_CHALLENGE_NOTE));+        ServerProperty serverProperty = new ServerProperty(origin, rpId, challenge, null);+        // check User Verification by considering a malicious user might modify the result of calling WebAuthn API+        boolean isUserVerificationRequired = policy.getUserVerificationRequirement().equals(WebAuthnConstants.OPTION_REQUIRED) == true ? true : false;++        try {+            WebAuthnRegistrationContext registrationContext = new WebAuthnRegistrationContext(clientDataJSON, attestationObject, serverProperty, isUserVerificationRequired);+            // NOTE: not yet verify Attestation Statement based on certificates+            WebAuthnRegistrationContextValidator webAuthnRegistrationContextValidator = WebAuthnRegistrationContextValidator.createNonStrictRegistrationContextValidator();+            WebAuthnRegistrationContextValidationResponse response = webAuthnRegistrationContextValidator.validate(registrationContext);++            showInfoAfterWebAuthnApiCreate(response);++            checkAcceptedAuthenticator(response, policy);++            WebAuthnCredentialModel credential = new WebAuthnCredentialModel();++            credential.setAttestedCredentialData(response.getAttestationObject().getAuthenticatorData().getAttestedCredentialData());+            credential.setAttestationStatement(response.getAttestationObject().getAttestationStatement());+            credential.setCount(response.getAttestationObject().getAuthenticatorData().getSignCount());++            this.session.userCredentialManager().updateCredential(context.getRealm(), context.getUser(), credential);++            // store received Credential ID on Registration onto UserModel in order to be used on Authentication+            String aaguid = response.getAttestationObject().getAuthenticatorData().getAttestedCredentialData().getAaguid().toString();+            context.getUser().setSingleAttribute(WebAuthnConstants.PUBKEY_CRED_ID_ATTR, publicKeyCredentialId);+            context.getUser().setSingleAttribute(WebAuthnConstants.PUBKEY_CRED_LABEL_ATTR, label);+            context.getUser().setSingleAttribute(WebAuthnConstants.PUBKEY_CRED_AAGUID_ATTR, aaguid);+            logger.infov(""WebAuthn Registration successed. publicKeyCredentialId = {0}, publicKeyCredentialLabel = {1}, publicKeyCredentialAAGUID = {2}"",publicKeyCredentialId, label, aaguid);++            context.getEvent()+                .detail(""public_key_credential_id"", publicKeyCredentialId)+                .detail(""public_key_credential_label"", label)+                .detail(""public_key_credential_aaguid"", aaguid);+            context.success();+        } catch (WebAuthnException wae) {+            setErrorResponse(context, ERR_WEBAUTHN_API_CREATE, wae.getMessage());","I vote for something like:```        } catch (WebAuthnException wae) {            if (logger.isDebugEnabled()) logger.debug(wae.getMessage(), wae);            setErrorResponse(context, ERR_WEBAUTHN_API_CREATE, wae.getMessage());            return;```This will mean that exception will be logged to the logger, not to the error output like with ""wae.printStackTrace()""",X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,321046146,2019-09-05T01:57:47Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/WebAuthnAuthenticator.java,"@@ -0,0 +1,261 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.authenticators.browser;++import com.webauthn4j.data.WebAuthnAuthenticationContext;+import com.webauthn4j.data.client.Origin;+import com.webauthn4j.data.client.challenge.Challenge;+import com.webauthn4j.data.client.challenge.DefaultChallenge;+import com.webauthn4j.server.ServerProperty;+import com.webauthn4j.util.exception.WebAuthnException;++import org.jboss.logging.Logger;+import org.keycloak.WebAuthnConstants;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.authentication.Authenticator;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.UriUtils;+import org.keycloak.credential.WebAuthnCredentialModel;+import org.keycloak.events.Errors;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.forms.login.freemarker.model.WebAuthnAuthenticatorsBean;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++public class WebAuthnAuthenticator implements Authenticator {++    private static final Logger logger = Logger.getLogger(WebAuthnAuthenticator.class);+    private KeycloakSession session;++    public WebAuthnAuthenticator(KeycloakSession session) {+        this.session = session;+    }++    public void authenticate(AuthenticationFlowContext context) {+        LoginFormsProvider form = context.form();+ +        Challenge challenge = new DefaultChallenge();+        String challengeValue = Base64Url.encode(challenge.getValue());+        context.getAuthenticationSession().setAuthNote(WebAuthnConstants.AUTH_CHALLENGE_NOTE, challengeValue);+        form.setAttribute(WebAuthnConstants.CHALLENGE, challengeValue);++        String rpId = context.getRealm().getWebAuthnPolicy().getRpId();+        if (rpId == null || rpId.isEmpty()) rpId =  context.getUriInfo().getBaseUri().getHost();+        form.setAttribute(WebAuthnConstants.RP_ID, rpId);++        UserModel user = context.getUser();+        boolean isUserIdentified = false;+        if (user != null) {+            // in 2 Factor Scenario where the user has already been identified+            WebAuthnAuthenticatorsBean authenticators = new WebAuthnAuthenticatorsBean(user);+            if (authenticators.getAuthenticators().isEmpty()) {+                setErrorResponse(context, ERR_NO_AUTHENTICATORS_REGISTERED, null);+                return;+            }+            isUserIdentified = true;+            form.setAttribute(WebAuthnConstants.ALLOWED_AUTHENTICATORS, authenticators);+        } else {+            // in ID-less & Password-less Scenario+            // NOP+        }+        form.setAttribute(WebAuthnConstants.IS_USER_IDENTIFIED, Boolean.toString(isUserIdentified));++        // read options from authenticator config+        AuthenticatorConfigModel config = context.getAuthenticatorConfig();+        String userVerificationRequirement = config.getConfig().get(WebAuthnAuthenticatorFactory.USER_VERIFICATION_REQUIREMENT);+        if (WebAuthnConstants.OPTION_NOT_SPECIFIED.equals(userVerificationRequirement)) userVerificationRequirement = Constants.DEFAULT_WEBAUTHN_POLICY_NOT_SPECIFIED;+        form.setAttribute(WebAuthnConstants.USER_VERIFICATION, userVerificationRequirement);++        context.challenge(form.createForm(""webauthn-authenticate.ftl""));+    }++    public void action(AuthenticationFlowContext context) {+        MultivaluedMap<String, String> params = context.getHttpRequest().getDecodedFormParameters();++        // receive error from navigator.credentials.get()+        String errorMsgFromWebAuthnApi = params.getFirst(WebAuthnConstants.ERROR);+        if (errorMsgFromWebAuthnApi != null && !errorMsgFromWebAuthnApi.isEmpty()) {+            setErrorResponse(context, ERR_WEBAUTHN_API_GET, errorMsgFromWebAuthnApi);+            return;+        }++        String baseUrl = UriUtils.getOrigin(context.getUriInfo().getBaseUri());+        String rpId = context.getUriInfo().getBaseUri().getHost();++        Origin origin = new Origin(baseUrl);+        Challenge challenge = new DefaultChallenge(context.getAuthenticationSession().getAuthNote(WebAuthnConstants.AUTH_CHALLENGE_NOTE));+        ServerProperty server = new ServerProperty(origin, rpId, challenge, null);++        byte[] credentialId = Base64Url.decode(params.getFirst(WebAuthnConstants.CREDENTIAL_ID));+        byte[] clientDataJSON = Base64Url.decode(params.getFirst(WebAuthnConstants.CLIENT_DATA_JSON));+        byte[] authenticatorData = Base64Url.decode(params.getFirst(WebAuthnConstants.AUTHENTICATOR_DATA));+        byte[] signature = Base64Url.decode(params.getFirst(WebAuthnConstants.SIGNATURE));++        String userId = params.getFirst(WebAuthnConstants.USER_HANDLE);+        boolean isUVFlagChecked = false;+        AuthenticatorConfigModel config = context.getAuthenticatorConfig();+        String userVerificationRequirement = config.getConfig().get(WebAuthnAuthenticatorFactory.USER_VERIFICATION_REQUIREMENT);+        if (WebAuthnConstants.OPTION_REQUIRED.equals(userVerificationRequirement)) isUVFlagChecked = true;++        // existing User Handle means that the authenticator used Resident Key supported public key credential+        if (userId == null || userId.isEmpty()) {+            // Resident Key not supported public key credential was used+            // so rely on the user that has already been authenticated+            userId = context.getUser().getId();","I think NPE does not happen in the following block :```java        // existing User Handle means that the authenticator used Resident Key supported public key credential        if (userId == null || userId.isEmpty()) {            // Resident Key not supported public key credential was used            // so rely on the user that has already been authenticated            userId = context.getUser().getId();        } else {```The reason is as follows:When NPE occurs, the follwing two condition need be met :1. `context.getUser()` is null   which means that no user is not yet authenticated on keycloak2. `userId` is null or empty   which means that `navigator.credentials.get()` returns successful response, but it does not include `User Handle`.Considering 1, in `WebAutnAuthenticator.authenticate()`, keycloak can not set the `navigator.credentials.get()`'s parameter `PublicKeyCredentialRequestOptions.allowCredentials`.`Credential ID` has to be set to this, however, keycloak can not determine whose `Credential ID` has to set to it because keycloak does not yet authenticate any user at that time.Therefore, the browser call `navigator.credentials.get()` without the parameter `PublicKeyCredentialRequestOptions.allowCredentials`.After calling `navigator.credentials.get()`, in order for keycloak to reach the codes above, the following conditions has to be met :- `navigator.credentials.get()` returns a successful response- `userId` is null or emptyTo get a successful response by calling `navigator.credentials.get()` without `PublicKeyCredentialRequestOptions.allowCredentials`, the following condition need to be met at least :- The webauthn authenticator has the capability of `Resident Key`- The webauthn authenticator has already created the public key credential as `client-side-resident public key credential` on `navigator.credentials.create()`and, such the webauthn authenticator returns successful response with `User Handle`. (refer to https://www.w3.org/TR/webauthn/#op-make-cred 7-4-4)Considering all above, if `context.getUser()` is null, `userId` is not null on the codes above.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,321055182,2019-09-05T02:50:26Z,themes/src/main/resources/theme/base/login/webauthn-register.ftl,"@@ -0,0 +1,136 @@+    <#import ""template.ftl"" as layout>+    <@layout.registrationLayout; section>+    <#if section = ""title"">+     title+    <#elseif section = ""header"">+    ${msg(""loginTitleHtml"", realm.name)}+    <#elseif section = ""form"">+    <form id=""register"" class=""${properties.kcFormClass!}"" action=""${url.loginAction}"" method=""post"">+        <div class=""${properties.kcFormGroupClass!}"">+            <input type=""hidden"" id=""clientDataJSON"" name=""clientDataJSON""/>+            <input type=""hidden"" id=""attestationObject"" name=""attestationObject""/>+            <input type=""hidden"" id=""publicKeyCredentialId"" name=""publicKeyCredentialId""/>+            <input type=""hidden"" id=""authenticatorLabel"" name=""authenticatorLabel""/>+            <input type=""hidden"" id=""error"" name=""error""/>+        </div>+    </form>+    <script type=""text/javascript"" src=""${url.resourcesPath}/node_modules/jquery/dist/jquery.min.js""></script>+    <script type=""text/javascript"" src=""${url.resourcesPath}/js/base64url.js""></script>+    <script type=""text/javascript"">+        // mandatory parameters+        let challenge = ""${challenge}"";+        let userid = ""${userid}"";+        let username = ""${username}"";++        let signatureAlgorithms = ""${signatureAlgorithms}"";+        let pubKeyCredParams = getPubKeyCredParams(signatureAlgorithms);++        let rpEntityName = ""${rpEntityName}"";+        let rp = {name: rpEntityName};++        let publicKey = {+            challenge: base64url.decode(challenge, { loose: true }),+            rp: rp,+            user: {+                id:  base64url.decode(userid, { loose: true }),+                name: username,+                displayName: username+            },+            pubKeyCredParams: pubKeyCredParams,+        }++        // optional parameters+        let rpId = ""${rpId}"";+        publicKey.rp.id = rpId;++        let attestationConveyancePreference = ""${attestationConveyancePreference}"";+        if(attestationConveyancePreference !== 'not specified') publicKey.attestation = attestationConveyancePreference;++        let authenticatorSelection = {};+        let isAuthenticatorSelectionSpecified = false;++        let authenticatorAttachment = ""${authenticatorAttachment}"";+        if(authenticatorAttachment !== 'not specified') {+            authenticatorSelection.authenticatorAttachment = authenticatorAttachment;+            isAuthenticatorSelectionSpecified = true;+        }++        let requireResidentKey = ""${requireResidentKey}"";+        if(requireResidentKey !== 'not specified') {+            if(requireResidentKey === 'Yes')+                authenticatorSelection.requireResidentKey = true;+            else+                authenticatorSelection.requireResidentKey = false;+            isAuthenticatorSelectionSpecified = true;+        }++        let userVerificationRequirement = ""${userVerificationRequirement}"";+        if(userVerificationRequirement !== 'not specified') {+            authenticatorSelection.userVerification = userVerificationRequirement;+            isAuthenticatorSelectionSpecified = true;+        }++        if(isAuthenticatorSelectionSpecified) publicKey.authenticatorSelection = authenticatorSelection;++        let createTimeout = ${createTimeout};+        if(createTimeout != 0) publicKey.timeout = createTimeout * 1000;++        let excludeCredentialIds = ""${excludeCredentialIds}"";+        let excludeCredentials = getExcludeCredentials(excludeCredentialIds);+        if (excludeCredentials.length > 0) publicKey.excludeCredentials = excludeCredentials;++        navigator.credentials.create({publicKey})+            .then(function(result) {+                window.result = result;+                let clientDataJSON = result.response.clientDataJSON;+                let attestationObject = result.response.attestationObject;+                let publicKeyCredentialId = result.rawId;++                $(""#clientDataJSON"").val(base64url.encode(new Uint8Array(clientDataJSON), { pad: false }));+                $(""#attestationObject"").val(base64url.encode(new Uint8Array(attestationObject), { pad: false }));+                $(""#publicKeyCredentialId"").val(base64url.encode(new Uint8Array(publicKeyCredentialId), { pad: false }));++                let initLabel = ""WebAuthn Authenticator (Default Label)"";+                let labelResult = window.prompt(""Please input your registered authenticator's label"", initLabel);+                if (labelResult === null) labelResult = initLabel;+                $(""#authenticatorLabel"").val(labelResult);++                $(""#register"").submit();++            })+            .catch(function(err) {+                $(""#error"").val(err);+                $(""#register"").submit();++            });++        function getPubKeyCredParams(signatureAlgorithms) {","As for using single bean class, I would like to try it as you said.As for moving the business logic inside UI template onto java class, I'm afraid it takes a relatively lot of time compared with other tasks.I've already confirmed it before as follows :- create the business logic implemented endpoint in the REST manner that receives the user's input about the options for WebAuthn API,  and returns the option itself for WebAuthn API (navigator.credentials.create(), .get())- create the UI template which receives the user's input and access the above endpoint  in the asynchronous manner, and call WebAuthn API (navigator.credentials.create(), .get()).However, I'm not sure how to secure this endpoint like other endpoints (e.g. login-actions). Therefore I've decided that this feature has not been included in this PR.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,321162564,2019-09-05T09:31:07Z,services/src/main/java/org/keycloak/credential/WebAuthnCredentialProvider.java,"@@ -0,0 +1,257 @@+/*+ * Copyright 2002-2019 the original author or authors.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.credential;++import java.io.IOException;+import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.List;+import java.util.Set;++import org.jboss.logging.Logger;+import org.keycloak.WebAuthnConstants;+import org.keycloak.common.util.Base64;+import org.keycloak.common.util.MultivaluedHashMap;+import org.keycloak.common.util.Time;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.jpa.converter.AttestationStatementConverter;+import org.keycloak.models.jpa.converter.CredentialPublicKeyConverter;++import com.webauthn4j.authenticator.Authenticator;+import com.webauthn4j.authenticator.AuthenticatorImpl;+import com.webauthn4j.data.WebAuthnAuthenticationContext;+import com.webauthn4j.data.attestation.authenticator.AAGUID;+import com.webauthn4j.data.attestation.authenticator.AttestedCredentialData;+import com.webauthn4j.data.attestation.authenticator.CredentialPublicKey;+import com.webauthn4j.data.attestation.statement.AttestationStatement;+import com.webauthn4j.util.exception.WebAuthnException;+import com.webauthn4j.validator.WebAuthnAuthenticationContextValidationResponse;+import com.webauthn4j.validator.WebAuthnAuthenticationContextValidator;++public class WebAuthnCredentialProvider implements CredentialProvider, CredentialInputValidator, CredentialInputUpdater {++    private static final Logger logger = Logger.getLogger(WebAuthnCredentialProvider.class);++    private static final String ATTESTATION_STATEMENT = ""ATTESTATION_STATEMENT"";+    private static final String AAGUID = ""AAGUID"";+    private static final String CREDENTIAL_ID = ""CREDENTIAL_ID"";+    private static final String CREDENTIAL_PUBLIC_KEY = ""CREDENTIAL_PUBLIC_KEY"";++    private KeycloakSession session;++    public WebAuthnCredentialProvider(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {+        if (input == null) return false;+        CredentialModel model = createCredentialModel(input);+        if (model == null) return false;+        session.userCredentialManager().createCredential(realm, user, model);+        return true;+    }++    private CredentialModel createCredentialModel(CredentialInput input) {+        if (!supportsCredentialType(input.getType())) return null;++        WebAuthnCredentialModel webAuthnModel = (WebAuthnCredentialModel) input;+        CredentialModel model = new CredentialModel();+        model.setType(WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE);+        model.setCreatedDate(Time.currentTimeMillis());++        MultivaluedHashMap<String, String> credential = new MultivaluedHashMap<>();++        AttestationStatementConverter attConv = new AttestationStatementConverter();+        credential.add(ATTESTATION_STATEMENT, attConv.convertToDatabaseColumn(webAuthnModel.getAttestationStatement()));++        credential.add(AAGUID, webAuthnModel.getAttestedCredentialData().getAaguid().toString());++        credential.add(CREDENTIAL_ID, Base64.encodeBytes(webAuthnModel.getAttestedCredentialData().getCredentialId()));++        CredentialPublicKeyConverter credConv = new CredentialPublicKeyConverter();+        credential.add(CREDENTIAL_PUBLIC_KEY, credConv.convertToDatabaseColumn(webAuthnModel.getAttestedCredentialData().getCredentialPublicKey()));++        model.setId(webAuthnModel.getAuthenticatorId());++        model.setConfig(credential);++        // authenticator's counter+        model.setValue(String.valueOf(webAuthnModel.getCount()));++        dumpCredentialModel(model);+        dumpWebAuthnCredentialModel(webAuthnModel);++        return model;+    }++    @Override+    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {+        if (!supportsCredentialType(credentialType)) return;+        // detele webauthn authenticator's credential itself+        for (CredentialModel credential : session.userCredentialManager().getStoredCredentialsByType(realm, user, credentialType)) {+            logger.infov(""Delete public key credential. username = {0}, credentialType = {1}"", user.getUsername(), credentialType);+            dumpCredentialModel(credential);+            session.userCredentialManager().removeStoredCredential(realm, user, credential.getId());+        }+        // delete webauthn authenticator's metadata+        user.removeAttribute(WebAuthnConstants.PUBKEY_CRED_AAGUID_ATTR);+        user.removeAttribute(WebAuthnConstants.PUBKEY_CRED_ID_ATTR);+        user.removeAttribute(WebAuthnConstants.PUBKEY_CRED_LABEL_ATTR);+    }++    @Override+    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {+        return isConfiguredFor(realm, user, WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE) ? Collections.singleton(WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE) : Collections.emptySet();+    }++    @Override+    public boolean supportsCredentialType(String credentialType) {+        return WebAuthnCredentialModel.WEBAUTHN_CREDENTIAL_TYPE.equals(credentialType);+    }++    @Override+    public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {+        if (!supportsCredentialType(credentialType)) return false;+        return !session.userCredentialManager().getStoredCredentialsByType(realm, user, credentialType).isEmpty();+    }++    @Override+    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {+        if (!WebAuthnCredentialModel.class.isInstance(input)) return false;++        WebAuthnCredentialModel context = WebAuthnCredentialModel.class.cast(input);+        List<WebAuthnCredentialModel> auths = getWebAuthnCredentialModelList(realm, user);++        WebAuthnAuthenticationContextValidator webAuthnAuthenticationContextValidator =+                new WebAuthnAuthenticationContextValidator();+        try {+            for (WebAuthnCredentialModel auth : auths) {++                byte[] credentialId = auth.getAttestedCredentialData().getCredentialId();+                if (Arrays.equals(credentialId, context.getAuthenticationContext().getCredentialId())) {+                    Authenticator authenticator = new AuthenticatorImpl(+                            auth.getAttestedCredentialData(),+                            auth.getAttestationStatement(),+                            auth.getCount()+                    );++                    // WebAuthnException is thrown if validation fails+                    WebAuthnAuthenticationContextValidationResponse response =+                            webAuthnAuthenticationContextValidator.validate(+                                    context.getAuthenticationContext(),+                                    authenticator);++                    logger.infov(""response.getAuthenticatorData().getFlags() = {0}"", response.getAuthenticatorData().getFlags());++                    // update authenticator counter+                    long count = auth.getCount();+                    auth.setCount(count + 1);+                    CredentialModel cred = createCredentialModel(auth);+                    session.userCredentialManager().updateCredential(realm, user, cred);",">Firstly in 6.1.1, it is mentioned that ""Authenticators SHOULD implement a signature counter feature."" . So implemeting it is not mandatory for authenticators per my understanding. I wonder that when authenticator doesn't support counter and will still return value 0, but credential stored on Keycloak side will have value greater than 0, what will happen during validation? Won't the WebAuthnException be thrown in that case? If yes, I am not sure if it is good behaviour as we should take into account that some authenticators may not support the counters?It does not happen that keycloak throws WebAuthnException in such the situation. WebAuthn4j implemented WebAuthn specification rigorously. https://github.com/webauthn4j/webauthn4j/blob/a166a383b038fc2edbb9859f9540cfae1db8ce2a/webauthn4j-core/src/main/java/com/webauthn4j/validator/WebAuthnAuthenticationContextValidator.java#L170",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,321167682,2019-09-05T09:43:35Z,themes/src/main/resources/theme/base/login/webauthn-register.ftl,"@@ -0,0 +1,136 @@+    <#import ""template.ftl"" as layout>+    <@layout.registrationLayout; section>+    <#if section = ""title"">+     title+    <#elseif section = ""header"">+    ${msg(""loginTitleHtml"", realm.name)}+    <#elseif section = ""form"">+    <form id=""register"" class=""${properties.kcFormClass!}"" action=""${url.loginAction}"" method=""post"">+        <div class=""${properties.kcFormGroupClass!}"">+            <input type=""hidden"" id=""clientDataJSON"" name=""clientDataJSON""/>+            <input type=""hidden"" id=""attestationObject"" name=""attestationObject""/>+            <input type=""hidden"" id=""publicKeyCredentialId"" name=""publicKeyCredentialId""/>+            <input type=""hidden"" id=""authenticatorLabel"" name=""authenticatorLabel""/>+            <input type=""hidden"" id=""error"" name=""error""/>+        </div>+    </form>+    <script type=""text/javascript"" src=""${url.resourcesPath}/node_modules/jquery/dist/jquery.min.js""></script>+    <script type=""text/javascript"" src=""${url.resourcesPath}/js/base64url.js""></script>+    <script type=""text/javascript"">+        // mandatory parameters+        let challenge = ""${challenge}"";+        let userid = ""${userid}"";+        let username = ""${username}"";++        let signatureAlgorithms = ""${signatureAlgorithms}"";+        let pubKeyCredParams = getPubKeyCredParams(signatureAlgorithms);++        let rpEntityName = ""${rpEntityName}"";+        let rp = {name: rpEntityName};++        let publicKey = {+            challenge: base64url.decode(challenge, { loose: true }),+            rp: rp,+            user: {+                id:  base64url.decode(userid, { loose: true }),+                name: username,+                displayName: username+            },+            pubKeyCredParams: pubKeyCredParams,+        }++        // optional parameters+        let rpId = ""${rpId}"";+        publicKey.rp.id = rpId;++        let attestationConveyancePreference = ""${attestationConveyancePreference}"";+        if(attestationConveyancePreference !== 'not specified') publicKey.attestation = attestationConveyancePreference;++        let authenticatorSelection = {};+        let isAuthenticatorSelectionSpecified = false;++        let authenticatorAttachment = ""${authenticatorAttachment}"";+        if(authenticatorAttachment !== 'not specified') {+            authenticatorSelection.authenticatorAttachment = authenticatorAttachment;+            isAuthenticatorSelectionSpecified = true;+        }++        let requireResidentKey = ""${requireResidentKey}"";+        if(requireResidentKey !== 'not specified') {+            if(requireResidentKey === 'Yes')+                authenticatorSelection.requireResidentKey = true;+            else+                authenticatorSelection.requireResidentKey = false;+            isAuthenticatorSelectionSpecified = true;+        }++        let userVerificationRequirement = ""${userVerificationRequirement}"";+        if(userVerificationRequirement !== 'not specified') {+            authenticatorSelection.userVerification = userVerificationRequirement;+            isAuthenticatorSelectionSpecified = true;+        }++        if(isAuthenticatorSelectionSpecified) publicKey.authenticatorSelection = authenticatorSelection;++        let createTimeout = ${createTimeout};+        if(createTimeout != 0) publicKey.timeout = createTimeout * 1000;++        let excludeCredentialIds = ""${excludeCredentialIds}"";+        let excludeCredentials = getExcludeCredentials(excludeCredentialIds);+        if (excludeCredentials.length > 0) publicKey.excludeCredentials = excludeCredentials;++        navigator.credentials.create({publicKey})+            .then(function(result) {+                window.result = result;+                let clientDataJSON = result.response.clientDataJSON;+                let attestationObject = result.response.attestationObject;+                let publicKeyCredentialId = result.rawId;++                $(""#clientDataJSON"").val(base64url.encode(new Uint8Array(clientDataJSON), { pad: false }));+                $(""#attestationObject"").val(base64url.encode(new Uint8Array(attestationObject), { pad: false }));+                $(""#publicKeyCredentialId"").val(base64url.encode(new Uint8Array(publicKeyCredentialId), { pad: false }));++                let initLabel = ""WebAuthn Authenticator (Default Label)"";+                let labelResult = window.prompt(""Please input your registered authenticator's label"", initLabel);+                if (labelResult === null) labelResult = initLabel;+                $(""#authenticatorLabel"").val(labelResult);++                $(""#register"").submit();++            })+            .catch(function(err) {+                $(""#error"").val(err);+                $(""#register"").submit();++            });++        function getPubKeyCredParams(signatureAlgorithms) {","Yep, ok. That's fine.I personally wouldn't try to use REST API for this. At least not in this PR. Binding the parameters to the freemarker is fine IMO.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,321528807,2019-09-05T23:45:56Z,themes/src/main/resources/theme/base/login/webauthn-register.ftl,"@@ -0,0 +1,136 @@+    <#import ""template.ftl"" as layout>+    <@layout.registrationLayout; section>+    <#if section = ""title"">+     title+    <#elseif section = ""header"">+    ${msg(""loginTitleHtml"", realm.name)}+    <#elseif section = ""form"">+    <form id=""register"" class=""${properties.kcFormClass!}"" action=""${url.loginAction}"" method=""post"">+        <div class=""${properties.kcFormGroupClass!}"">+            <input type=""hidden"" id=""clientDataJSON"" name=""clientDataJSON""/>+            <input type=""hidden"" id=""attestationObject"" name=""attestationObject""/>+            <input type=""hidden"" id=""publicKeyCredentialId"" name=""publicKeyCredentialId""/>+            <input type=""hidden"" id=""authenticatorLabel"" name=""authenticatorLabel""/>+            <input type=""hidden"" id=""error"" name=""error""/>+        </div>+    </form>+    <script type=""text/javascript"" src=""${url.resourcesPath}/node_modules/jquery/dist/jquery.min.js""></script>+    <script type=""text/javascript"" src=""${url.resourcesPath}/js/base64url.js""></script>+    <script type=""text/javascript"">+        // mandatory parameters+        let challenge = ""${challenge}"";+        let userid = ""${userid}"";+        let username = ""${username}"";++        let signatureAlgorithms = ""${signatureAlgorithms}"";+        let pubKeyCredParams = getPubKeyCredParams(signatureAlgorithms);++        let rpEntityName = ""${rpEntityName}"";+        let rp = {name: rpEntityName};++        let publicKey = {+            challenge: base64url.decode(challenge, { loose: true }),+            rp: rp,+            user: {+                id:  base64url.decode(userid, { loose: true }),+                name: username,+                displayName: username+            },+            pubKeyCredParams: pubKeyCredParams,+        }++        // optional parameters+        let rpId = ""${rpId}"";+        publicKey.rp.id = rpId;++        let attestationConveyancePreference = ""${attestationConveyancePreference}"";+        if(attestationConveyancePreference !== 'not specified') publicKey.attestation = attestationConveyancePreference;++        let authenticatorSelection = {};+        let isAuthenticatorSelectionSpecified = false;++        let authenticatorAttachment = ""${authenticatorAttachment}"";+        if(authenticatorAttachment !== 'not specified') {+            authenticatorSelection.authenticatorAttachment = authenticatorAttachment;+            isAuthenticatorSelectionSpecified = true;+        }++        let requireResidentKey = ""${requireResidentKey}"";+        if(requireResidentKey !== 'not specified') {+            if(requireResidentKey === 'Yes')+                authenticatorSelection.requireResidentKey = true;+            else+                authenticatorSelection.requireResidentKey = false;+            isAuthenticatorSelectionSpecified = true;+        }++        let userVerificationRequirement = ""${userVerificationRequirement}"";+        if(userVerificationRequirement !== 'not specified') {+            authenticatorSelection.userVerification = userVerificationRequirement;+            isAuthenticatorSelectionSpecified = true;+        }++        if(isAuthenticatorSelectionSpecified) publicKey.authenticatorSelection = authenticatorSelection;++        let createTimeout = ${createTimeout};+        if(createTimeout != 0) publicKey.timeout = createTimeout * 1000;++        let excludeCredentialIds = ""${excludeCredentialIds}"";+        let excludeCredentials = getExcludeCredentials(excludeCredentialIds);+        if (excludeCredentials.length > 0) publicKey.excludeCredentials = excludeCredentials;++        navigator.credentials.create({publicKey})+            .then(function(result) {+                window.result = result;+                let clientDataJSON = result.response.clientDataJSON;+                let attestationObject = result.response.attestationObject;+                let publicKeyCredentialId = result.rawId;++                $(""#clientDataJSON"").val(base64url.encode(new Uint8Array(clientDataJSON), { pad: false }));+                $(""#attestationObject"").val(base64url.encode(new Uint8Array(attestationObject), { pad: false }));+                $(""#publicKeyCredentialId"").val(base64url.encode(new Uint8Array(publicKeyCredentialId), { pad: false }));++                let initLabel = ""WebAuthn Authenticator (Default Label)"";+                let labelResult = window.prompt(""Please input your registered authenticator's label"", initLabel);+                if (labelResult === null) labelResult = initLabel;+                $(""#authenticatorLabel"").val(labelResult);++                $(""#register"").submit();++            })+            .catch(function(err) {+                $(""#error"").val(err);+                $(""#register"").submit();++            });++        function getPubKeyCredParams(signatureAlgorithms) {","Yes, at this PR, I'll try to bind parameters to the freemarker as you said.I think if there is a method which can convert FreeMarker's bean onto JavaScript's object easily, I can move the business logic for constructing JavaScript's object from the template. If not, I need to construct a JavaScript's object on the template the same as the current template, which can not improve the current template.Therefore, I think finding a method which can convert FreeMarker's bean onto JavaScript's object easily is the most important. However, I've not yet found it. I'm afraid it takes slightly a lot of time.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6285,321655691,2019-09-06T09:36:29Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/idm/store/ldap/LDAPContextManager.java,"@@ -0,0 +1,182 @@+package org.keycloak.storage.ldap.idm.store.ldap;++import org.jboss.logging.Logger;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.LDAPConstants;+import org.keycloak.storage.ldap.LDAPConfig;+import org.keycloak.vault.VaultCharSecret;++import javax.naming.Context;+import javax.naming.NamingException;+import javax.naming.ldap.InitialLdapContext;+import javax.naming.ldap.LdapContext;+import javax.naming.ldap.StartTlsRequest;+import javax.naming.ldap.StartTlsResponse;+import java.nio.CharBuffer;+import java.util.HashMap;+import java.util.Hashtable;+import java.util.Map;+import java.util.Properties;++import static javax.naming.Context.SECURITY_CREDENTIALS;++/**+ * @author mhajas+ */+public final class LDAPContextManager implements AutoCloseable {++    private static final Logger logger = Logger.getLogger(LDAPContextManager.class);++    private final KeycloakSession session;+    private final LDAPConfig ldapConfig;+    private  VaultCharSecret vaultCharSecret;+    private LdapContext ldapContext;+    private static HashMap<String, Object> connectionProperties;++    public LDAPContextManager(KeycloakSession session, LDAPConfig connectionProperties) {+        this.session = session;+        this.ldapConfig = connectionProperties;+    }++    public static LDAPContextManager create(KeycloakSession session, LDAPConfig connectionProperties) {+        return new LDAPContextManager(session, connectionProperties);+    }++    private void createLdapContext() throws NamingException {+        Hashtable<Object, Object> connProp = getConnectionProperties(ldapConfig);++        if (!LDAPConstants.AUTH_TYPE_NONE.equals(ldapConfig.getAuthType())) {+            vaultCharSecret = getVaultSecret();++            if (vaultCharSecret != null) {+                connProp.put(SECURITY_CREDENTIALS, vaultCharSecret.getAsArray()+                        .orElse(ldapConfig.getBindCredential().toCharArray()));+            }+        }++        ldapContext = new InitialLdapContext(connProp, null);+        if (ldapConfig.isStartTls()) {+            startTLS(ldapContext);+        }++    }++    public LdapContext getLdapContext() throws NamingException {+        if (ldapContext == null) createLdapContext();++        return ldapContext;+    }++    private VaultCharSecret getVaultSecret() {+        return LDAPConstants.AUTH_TYPE_NONE.equals(ldapConfig.getAuthType())+                ? null+                : session.vault().getCharSecret(ldapConfig.getBindCredential());+    }++    public static void startTLS(LdapContext ldapContext) throws NamingException {+        try {+            StartTlsResponse tls = (StartTlsResponse) ldapContext.extendedOperation(new StartTlsRequest());","@mhajas Thanks for doublecheck the startTLS with me.I think that if ""startTLS"" is enabled, it is needed to add credentials again to the environment after tls.negotiate() is called. See the https://docs.oracle.com/javase/jndi/tutorial/ldap/ext/starttls.html and especially the sentence, which mentions that:```Note that the username and cleartext password are now encrypted because the authentication is being performed after establishment of the TLS session. ```The StartTLS support was community contribution and I don't have a chance to easily test it. You can try to setup some LDAP server with startTLS support and doublecheck it works. But my vote would be to do it similarly like was the old behaviour and add credentials again to the environment.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,322127486,2019-09-09T08:48:28Z,themes/src/main/resources/theme/base/login/webauthn-register.ftl,"@@ -0,0 +1,136 @@+    <#import ""template.ftl"" as layout>+    <@layout.registrationLayout; section>+    <#if section = ""title"">+     title+    <#elseif section = ""header"">+    ${msg(""loginTitleHtml"", realm.name)}+    <#elseif section = ""form"">+    <form id=""register"" class=""${properties.kcFormClass!}"" action=""${url.loginAction}"" method=""post"">+        <div class=""${properties.kcFormGroupClass!}"">+            <input type=""hidden"" id=""clientDataJSON"" name=""clientDataJSON""/>+            <input type=""hidden"" id=""attestationObject"" name=""attestationObject""/>+            <input type=""hidden"" id=""publicKeyCredentialId"" name=""publicKeyCredentialId""/>+            <input type=""hidden"" id=""authenticatorLabel"" name=""authenticatorLabel""/>+            <input type=""hidden"" id=""error"" name=""error""/>+        </div>+    </form>+    <script type=""text/javascript"" src=""${url.resourcesPath}/node_modules/jquery/dist/jquery.min.js""></script>+    <script type=""text/javascript"" src=""${url.resourcesPath}/js/base64url.js""></script>+    <script type=""text/javascript"">+        // mandatory parameters+        let challenge = ""${challenge}"";+        let userid = ""${userid}"";+        let username = ""${username}"";++        let signatureAlgorithms = ""${signatureAlgorithms}"";+        let pubKeyCredParams = getPubKeyCredParams(signatureAlgorithms);++        let rpEntityName = ""${rpEntityName}"";+        let rp = {name: rpEntityName};++        let publicKey = {+            challenge: base64url.decode(challenge, { loose: true }),+            rp: rp,+            user: {+                id:  base64url.decode(userid, { loose: true }),+                name: username,+                displayName: username+            },+            pubKeyCredParams: pubKeyCredParams,+        }++        // optional parameters+        let rpId = ""${rpId}"";+        publicKey.rp.id = rpId;++        let attestationConveyancePreference = ""${attestationConveyancePreference}"";+        if(attestationConveyancePreference !== 'not specified') publicKey.attestation = attestationConveyancePreference;++        let authenticatorSelection = {};+        let isAuthenticatorSelectionSpecified = false;++        let authenticatorAttachment = ""${authenticatorAttachment}"";+        if(authenticatorAttachment !== 'not specified') {+            authenticatorSelection.authenticatorAttachment = authenticatorAttachment;+            isAuthenticatorSelectionSpecified = true;+        }++        let requireResidentKey = ""${requireResidentKey}"";+        if(requireResidentKey !== 'not specified') {+            if(requireResidentKey === 'Yes')+                authenticatorSelection.requireResidentKey = true;+            else+                authenticatorSelection.requireResidentKey = false;+            isAuthenticatorSelectionSpecified = true;+        }++        let userVerificationRequirement = ""${userVerificationRequirement}"";+        if(userVerificationRequirement !== 'not specified') {+            authenticatorSelection.userVerification = userVerificationRequirement;+            isAuthenticatorSelectionSpecified = true;+        }++        if(isAuthenticatorSelectionSpecified) publicKey.authenticatorSelection = authenticatorSelection;++        let createTimeout = ${createTimeout};+        if(createTimeout != 0) publicKey.timeout = createTimeout * 1000;++        let excludeCredentialIds = ""${excludeCredentialIds}"";+        let excludeCredentials = getExcludeCredentials(excludeCredentialIds);+        if (excludeCredentials.length > 0) publicKey.excludeCredentials = excludeCredentials;++        navigator.credentials.create({publicKey})+            .then(function(result) {+                window.result = result;+                let clientDataJSON = result.response.clientDataJSON;+                let attestationObject = result.response.attestationObject;+                let publicKeyCredentialId = result.rawId;++                $(""#clientDataJSON"").val(base64url.encode(new Uint8Array(clientDataJSON), { pad: false }));+                $(""#attestationObject"").val(base64url.encode(new Uint8Array(attestationObject), { pad: false }));+                $(""#publicKeyCredentialId"").val(base64url.encode(new Uint8Array(publicKeyCredentialId), { pad: false }));++                let initLabel = ""WebAuthn Authenticator (Default Label)"";+                let labelResult = window.prompt(""Please input your registered authenticator's label"", initLabel);+                if (labelResult === null) labelResult = initLabel;+                $(""#authenticatorLabel"").val(labelResult);++                $(""#register"").submit();++            })+            .catch(function(err) {+                $(""#error"").val(err);+                $(""#register"").submit();++            });++        function getPubKeyCredParams(signatureAlgorithms) {","Yes, I would like to work on the other task (especially, not using UserModel's attribute for public key credential's metadata) and will back to this issue later on. What do you think about it? ",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6248,322536196,2019-09-10T03:13:54Z,testsuite/integration-arquillian/tests/base/pom.xml,"@@ -44,6 +44,11 @@     </properties>          <dependencies>+        <dependency>","I've removed this dependency of Web Driver manager and use Arquillian Drone managing Chrome Driver. If you want to run the test, please do the following : `mvn -f testsuite/integration-arquillian/tests/base/pom.xml test -Dtest=org.keycloak.testsuite.webauthn.WebAuthnRegisterAndLoginTest -Dbrowser=chrome  -DchromeArguments=""--headless --enable-web-authentication-testing-api""`I've looked into http://arquillian.org/arquillian-extension-drone/#chrome-options and integration-arquillian-tests-base/src/test/resources/arquillian.xml .",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6248,322705204,2019-09-10T12:10:50Z,testsuite/integration-arquillian/tests/base/pom.xml,"@@ -44,6 +44,11 @@     </properties>          <dependencies>+        <dependency>","Thanks, in my environment it unfortunately didn't help. Still the same behaviour. But thanks for this change anyway. Removing the dependency from the testsuite and using arquillian instead is always good.",
243027,micedre,https://api.github.com/repos/keycloak/keycloak/pulls/6287,322941106,2019-09-10T20:15:11Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/theme/ThemeResourceProviderTest.java,"@@ -50,4 +51,18 @@ public void getResourceAsStream() {         });     } +    @Test+    public void getMessages() {+        testingClient.server().run(session -> {+            try {+                ThemeProvider extending = session.getProvider(ThemeProvider.class, ""extending"");+                Theme theme = extending.getTheme(""base"", Theme.Type.LOGIN);+                System.out.println(theme.getMessages(""messages"", Locale.ENGLISH));+                Assert.assertNotNull(theme.getMessages(""messages"", Locale.ENGLISH).get(""test.keycloak-8818""));+                Assert.assertEquals(""Keycloak Admin Console (from theme-resources)"", theme.getMessages(""admin-messages"", Locale.ENGLISH).get(""consoleTitle""));","done, I had to use another key as the bundle admin-messages is not in the LOGIN theme so the test was bad anyway.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6044,323949480,2019-09-12T21:06:45Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -352,6 +353,9 @@ protected Response loginRequest(String relayState, AuthnRequestType requestAbstr                  }             }+            +            SamlAuthenticationPreprocessor.getProvider(session).preprocess(authSession, requestAbstractType);",This should rather enumerate all registered `SamlAuthenticationPreprocessor` providers and call each of them (see e.g. `org.keycloak.credential.UserCredentialStoreManager.getCredentialProviders()` on similar enumeration).,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6311,324104213,2019-09-13T09:14:58Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/RegisterTest.java,"@@ -187,11 +189,11 @@ public void registerPasswordPolicy() {         /*keycloakRule.configure(new KeycloakRule.KeycloakSetup() {             @Override             public void config(RealmManager manager, RealmModel adminstrationRealm, RealmModel appRealm) {-                appRealm.setPasswordPolicy(new PasswordPolicy(""length""));+                appRealm.setPasswordPolicy(new PasswordPolicy(LengthPasswordPolicyProviderFactory.ID));","Please remove this. Tests are by intent using a string and not a constant here. When using a constant one example would be that someone by mistake renames the ID of the provider resulting in the test passing, but existing password policy strings would no longer work.",
3079540,Captain-P-Goldfish,https://api.github.com/repos/keycloak/keycloak/pulls/6311,324307610,2019-09-13T18:09:54Z,server-spi-private/src/main/java/org/keycloak/policy/DigitsPasswordPolicyProviderFactory.java,"@@ -26,7 +26,7 @@  */ public class DigitsPasswordPolicyProviderFactory implements PasswordPolicyProviderFactory { -    static final String ID = ""digits"";+    public static final String ID = ""digits"";",By the way I am fully aware that this is actually a violation of the purpose of the ID constants but these were the only constants wihtin the keycloak implementation that were matching the effective keys.,
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6308,325292331,2019-09-17T17:26:06Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -464,6 +463,15 @@ private UserConsentModel createConsent(ClientModel client, ConsentRepresentation         return consent;     } +    @Path(""/applications"")","@douglaspalmer while I was reviewing your PR, just reading the sources I found out something similar to what you implemented https://github.com/keycloak/keycloak/blob/c6c5a427537b868640d31310505f7a6411bd861c/services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java#L251Do we really need the code for applications in both places? Maybe we could merge the logic of this code in a single place?",X
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6308,325292611,2019-09-17T17:26:44Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -464,6 +463,15 @@ private UserConsentModel createConsent(ClientModel client, ConsentRepresentation         return consent;     } +    @Path(""/applications"")+    public ApplicationResource applications() {+        checkAccountApiEnabled();+//        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);",@douglaspalmer is this comment temporary?,
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6308,325317423,2019-09-17T18:21:12Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -464,6 +463,15 @@ private UserConsentModel createConsent(ClientModel client, ConsentRepresentation         return consent;     } +    @Path(""/applications"")+    public ApplicationResource applications() {+        checkAccountApiEnabled();+//        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);","Btw I commented out the following snippet:```@Path(""/applications"")    public ApplicationResource applications() {        checkAccountApiEnabled();//        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);        return new ApplicationResource(session, user, auth, request);    }```And I could confirm that the endpoint responding is https://github.com/keycloak/keycloak/blob/c6c5a427537b868640d31310505f7a6411bd861c/services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java#L251",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6308,325819419,2019-09-18T18:09:15Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/ApplicationRestServiceTest.java,"@@ -0,0 +1,94 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.account;++import static org.hamcrest.Matchers.hasItems;+import static org.hamcrest.Matchers.hasProperty;+import static org.hamcrest.Matchers.is;++import java.io.IOException;+import java.util.List;++import com.fasterxml.jackson.core.type.TypeReference;+import org.jboss.arquillian.graphene.page.Page;+import org.junit.Assert;+import org.junit.Test;+import org.keycloak.OAuth2Constants;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.AccountRoles;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.services.resources.account.ApplicationResource;+import org.keycloak.testsuite.pages.OAuthGrantPage;+import org.keycloak.testsuite.util.ClientBuilder;+import org.keycloak.testsuite.util.OAuthClient;+import org.keycloak.testsuite.util.TokenUtil;+import org.keycloak.testsuite.util.UserBuilder;++/**+ * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>+ */+public class ApplicationRestServiceTest extends AbstractRestServiceTest {++    private static final String THIRD_PARTY_APP = ""third-party"";+    private static final String REALM_NAME = ""test"";++    @Page+    protected OAuthGrantPage grantPage;++    @Override+    public void configureTestRealm(RealmRepresentation testRealm) {+        super.configureTestRealm(testRealm);++        testRealm.getClients().add(ClientBuilder.create()+                .clientId(""app-1"")+                .name(""app-1"")+                .baseUrl(""http://client0.example.com"")+                .redirectUris(OAuthClient.APP_ROOT + ""/auth"")+                .consentRequired(true)+                .fullScopeEnabled(false)+                .publicClient().build());++        testRealm.getUsers().add(UserBuilder.create().username(""alice"").password(""password"").enabled(true)+                .role(""account"", AccountRoles.VIEW_APPLICATIONS).build());+    }++    @Test+    public void testGetApplications() throws IOException {+        TokenUtil viewToken = new TokenUtil(""alice"", ""password"");+        oauth.doLogin(""alice"", ""password"");++        List<ApplicationResource.ApplicationRepresentation> sessions = SimpleHttp+                .doGet(getAccountUrl(""applications""), httpClient).auth(viewToken.getToken())+                .asJson(new TypeReference<List<ApplicationResource.ApplicationRepresentation>>() {+                });++        //TODO: assert response",Looks like this test is incomplete?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6268,326052582,2019-09-19T08:35:28Z,themes/src/main/resources/theme/base/admin/resources/partials/realm-identity-provider-oidc.html,"@@ -138,6 +138,20 @@                 </div>                 <kc-tooltip>{{:: 'token-url.tooltip' | translate}}</kc-tooltip>             </div>+            <div class=""form-group clearfix"">","Switch was already added and in the other PR, you already uncommented the line allowing clientAuth_basic in the existing switch. That should be sufficient to uncomment that line. No need to add the switch again to have it duplicated on the page. Could you please remove the duplicated switch from your PR?",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6327,326552234,2019-09-20T09:43:59Z,services/src/main/java/org/keycloak/theme/ExtendingThemeManager.java,"@@ -172,6 +176,8 @@ private Theme findTheme(String name, Theme.Type type) {     }      public static class ExtendingTheme implements Theme {+        private final static Pattern ENVIRONMENT_VARIABLE_SUBSTITUTE_PATTERN = Pattern.compile(""\\$\\{env.([A-Za-z0-9_.-]+)(?::([^\\}]*))?\\}"");",This code doesn't belong here. Take a look at:* org.keycloak.common.util.SystemEnvProperties* org.keycloak.common.util.StringPropertyReplacer,X
6153672,Opa-,https://api.github.com/repos/keycloak/keycloak/pulls/6327,326581569,2019-09-20T11:12:26Z,services/src/main/java/org/keycloak/theme/ExtendingThemeManager.java,"@@ -172,6 +176,8 @@ private Theme findTheme(String name, Theme.Type type) {     }      public static class ExtendingTheme implements Theme {+        private final static Pattern ENVIRONMENT_VARIABLE_SUBSTITUTE_PATTERN = Pattern.compile(""\\$\\{env.([A-Za-z0-9_.-]+)(?::([^\\}]*))?\\}"");",Ok thanks for the advice ! With these two classes I got rid of the dirty things I added to ExtendingTheme class ,
12050544,Cracky5457,https://api.github.com/repos/keycloak/keycloak/pulls/6339,329074349,2019-09-27T13:35:13Z,services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java,"@@ -164,7 +164,7 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede      @Override     public boolean supportsCredentialType(String credentialType) {-        return credentialType.equals(CredentialModel.PASSWORD);+        return credentialType == null || credentialType.equals(CredentialModel.PASSWORD);","I'm not a reviewer but FYI ` CredentialModel.PASSWORD.equals(credentialType)` in that order can't throw a null pointer exception, usually always the constants first because equals accept ""null"" but null don't have equals function.",X
12050544,Cracky5457,https://api.github.com/repos/keycloak/keycloak/pulls/6339,329468313,2019-09-30T08:47:20Z,services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java,"@@ -164,7 +164,7 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede      @Override     public boolean supportsCredentialType(String credentialType) {-        return credentialType.equals(CredentialModel.PASSWORD);+        return credentialType == null || credentialType.equals(CredentialModel.PASSWORD);","Ok, I see what you mean, I though you was trying to avoid a null pointer exception.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6353,330176206,2019-10-01T17:20:16Z,themes/src/main/resources/theme/keycloak-preview/account/resources/systemjs.config.js,"@@ -88,11 +88,19 @@               './Card/CardBody': '@empty',               './Card/CardHeader': '@empty',               './Card/CardFooter': '@empty',-              './Checkbox': '@empty', //'./Checkbox/index.js',+              './Checkbox': './Checkbox/index.js', //'./Checkbox/index.js',               './ChipGroup': '@empty', //'./ChipGroup/index.js',               './ClipboardCopy': '@empty', //'./ClipboardCopy/index.js,               './ContextSelector': '@empty', //'./ContextSelector/index.js',-              './DataList': '@empty', //'./DataList/index.js',+              './DataList': './DataList/index.js', +              './DataList/DataListItem': './DataList/DataListItem.js', +              './DataList/DataListItemRow': './DataList/DataListItemRow.js', +              './DataList/DataListCell': './DataList/DataListCell.js', +              './DataList/DataListCheck': './DataList/DataListCheck.js', +              './DataList/DataListAction': './DataList/DataListAction.js',+              './DataList/DataListToggle': './DataList/DataListToggle.js', +              './DataList/DataListContent': './DataList/DataListContent.js',+              './DataList/DataListItemCells': './DataList/DataListItemCells.js', ",You only need ./DataList/index.js.  You shouldn't need an entry for each component because index.js already takes care of those.,X
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6353,330249737,2019-10-01T20:05:47Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,273 @@  */  import * as React from 'react';- +import {AxiosResponse} from 'axios';++import {+  Title,+  Button,+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListCheck,+  DataListAction,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Dropdown,+  DropdownPosition,+  DropdownToggle,+  DropdownItem,+  Checkbox,+  KebabToggle,+  TextInput,+  Toolbar,+  ToolbarGroup,+  ToolbarItem,+  ToolbarSection,+  Modal+} from '@patternfly/react-core';++import {InfoAltIcon, LinkIcon, BuilderImageIcon} from '@patternfly/react-icons';+import {ContentPage} from '../ContentPage'; +import {ContinueCancelModal} from '../../widgets/ContinueCancelModal';+import {AccountServiceClient} from '../../account-service/account.service';++let dropdownApplicationTypeList = [+  <DropdownItem key=""list-item-1"">All apps</DropdownItem>,+  <DropdownItem key=""list-item-2"">Internal app</DropdownItem>,+  <DropdownItem key=""list-item-3"">Third party app</DropdownItem>+]+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++interface Application {+  clientId: string;+  clientName: string;+  internal: boolean;+  inUse: boolean;+  url: string;+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private doSomething = () => {+    //TODO+    //console.log(""Test"");+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({isRowOpen: newIsRowOpen});+  };++  private handleChange = () => {+    //TODO+  };++  private filterApplications = () => {+    console.log('Search applications');+  };++  private buildSearchBox () {+    return (+      <TextInput value='' type=""search"" aria-label=""search text input"" placeholder=""Search by name"" />+    );+  };+  +  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+    .then((response: AxiosResponse<Object>) => {+      let applications = response.data as Application[];+      this.setState({+        isRowOpen: this.collapseRows(applications),+        applications: applications+      });+    });+  }++  private collapseRows(applications: Application[]): boolean[] {+    const openRows: boolean[] = new Array<boolean>().fill(true);+    applications.forEach((application: Application, appIndex: number) => {+      openRows[appIndex] = false;+    });+    return openRows;+  }++  public render(): React.ReactNode {+    return (+      <ContentPage title=""applications"">+        <Toolbar className=""pf-l-toolbar pf-u-justify-content-space-between pf-u-mx-xl pf-u-my-md"">+          <ToolbarGroup>+            <ToolbarItem className=""pf-u-mr-xl"">{this.buildSearchBox()}</ToolbarItem>+          </ToolbarGroup>+          <ToolbarGroup>+            <ToolbarItem className=""pf-u-mr-md"">+              <DropdownWrapper+                dropdownWrapperItems={dropdownApplicationTypeList}+                dropdownWrapperTitle='Application Type'+                onDropdownSelect={this.doSomething}+              />+            </ToolbarItem>+          </ToolbarGroup>+          <ToolbarGroup>+            <ToolbarItem className=""pf-u-mx-md"">+              <Button aria-label=""search-button"" onClick={this.filterApplications}>Search</Button>+            </ToolbarItem> +          </ToolbarGroup>+          <ToolbarGroup>+            <ToolbarItem>+              {/*TODO implement the logic for checkbox*/}+              <Checkbox+                label=""In-use app only""+                isChecked={false}+                onChange={this.handleChange}+                aria-label=""In-use app only""+                id=""inUseCheckbox""+                name=""inUseCheckbox""+              />+            </ToolbarItem>+          </ToolbarGroup>+          <ToolbarSection aria-label=""Toolbar Section"">+            <ToolbarGroup>+              <ToolbarItem>{this.state.applications.length} {this.state.applications.length > 1 ? 'items' : 'item'}</ToolbarItem>+            </ToolbarGroup>+            <ToolbarGroup>+              <ToolbarItem>Active Filters: None</ToolbarItem>+            </ToolbarGroup>+          </ToolbarSection>+        </Toolbar>+        <DataList aria-label=""device-activity"">+          {this.state.applications.map((application: Application, appIndex: number) => {+            return (+              <DataListItem key={'application-' + appIndex} aria-labelledby=""simple-item2"" isExpanded={this.state.isRowOpen[appIndex]}>+                <DataListItemRow>+                  <DataListToggle+                    onClick={() => this.onToggle(appIndex)}+                    isExpanded={this.state.isRowOpen[appIndex]}+                    id={'applicationToggle' + appIndex}+                    aria-controls=""ex-expand1""+                  />+                  <DataListItemCells+                    dataListCells={[+                      <DataListCell key={'app-' + appIndex}>+                        <span id=""check-action-item1"">+                          <BuilderImageIcon/> {application.clientId}+                          </span>+                        </DataListCell>,+                        <DataListCell key={'internal-' + appIndex}>+                          <span>{application.internal ? 'Internal' : 'Third-party'}</span>+                        </DataListCell>,+                        <DataListCell key={'status-' + appIndex}>+                          <span>{application.inUse ? 'In-use' : 'NaN'}</span>+                        </DataListCell>,+                        <DataListCell key={'url-' + appIndex}>+                          <a href={application.url}> <LinkIcon/> {application.url}</a>+                        </DataListCell>+                    ]}+                  />+                </DataListItemRow>+                <DataListContent +                  noPadding={false}+                  aria-label=""Application Details""+                  id=""ex-expand1""+                  isHidden={!this.state.isRowOpen[appIndex]}+                >+                  <div className=""pf-c-content"">+                    <h3>Client</h3>+                    <hr/>+                    <h3>Description</h3>+                    <h3>URL</h3>+                    <h3>Has access to</h3>+                    <h3>Access granted on</h3>+                    <hr/>+                    <React.Fragment>+                      <ContinueCancelModal +                        buttonTitle='Remove' // required+                        buttonVariant='secondary' // defaults to 'primary'+                        modalTitle='Remove Access' // required+                        modalMessage='This will remove the currently granted access permission for AdminCLI. You will need to grant access again if you want ot user this app.'+                        modalContinueButtonLabel='Confirm' // defaults to 'Continue'+                        modalCancelButtonLabel='Cancel' // defaults to 'Cancel'+                        onContinue={this.doSomething} // required+                      />+                    </React.Fragment>+                    <InfoAltIcon/> +                    <span>+                      By clicking Remove Access, you will remove granted permissions of this app. This app will no longer use your information.+                    </span>+                  </div>+                </DataListContent>+              </DataListItem>+            )+          })}+        </DataList>+      </ContentPage>+    );+  }+};++interface DropdownWrapperProps {+  dropdownWrapperItems: any[];",@ssilvert I got the inspiration from https://github.com/patternfly/patternfly-react/blob/9335f73f55ac774b4d65eb353e149cf973164293/packages/patternfly-4/react-core/src/components/Dropdown/Dropdown.tsx#L12. Should we really change it? Assuming that the component does the same?,
17771943,sassko,https://api.github.com/repos/keycloak/keycloak/pulls/6279,330399018,2019-10-02T07:12:00Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -15,9 +15,43 @@  * limitations under the License.  */ -(function( window, undefined ) {--    var Keycloak = function (config) {+(function(root, factory) {+    if ( typeof exports === 'object' ) {+        if ( typeof module === 'object' ) {+            module.exports = factory( require(""js-sha256""), require(""base64-js"") );    +        } else {+            exports[""keycloak""] = factory( require(""js-sha256""), require(""base64-js"") );    +        }+    } else {+        /**","Hi,it seems that these comments that are committed within this PR into the keycloak.jsleads to some issues with the minified version:> Source map error: SyntaxError: JSON.parse: unexpected character at line 2 column 1 of the JSON dataResource URL: https://DOMAIN/auth/js/keycloak.min.jsSource Map URL: keycloak.min.js.mapI don't know it is worth to create an issue, just want to mention it.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6044,332108006,2019-10-07T16:10:37Z,services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java,"@@ -291,6 +292,11 @@ protected Response logoutRequest(LogoutRequestType request, String relayState) {                     if (userSession.getState() == UserSessionModel.State.LOGGING_OUT || userSession.getState() == UserSessionModel.State.LOGGED_OUT) {                         continue;                     }++                    SamlAuthenticationPreprocessor.forEach(session, (p) -> {","While this is a neat construct syntactically and I generally prefer functional style, here I'd rather suggest using plain iteration and using similar trick that is used in e.g. `IdentityProviderMapper` for `SamlAuthenticationPreprocessor` to implement both `ProviderFactory` and `Provider`. The current construct impacts some of the JVMs by introducing lots of short-lived objects, overhead of which the iteration has not.Declare the following method in e.g. `SamlSessionUtils` class:```java    public static Iterator<SamlAuthenticationPreprocessor> getSamlAuthenticationPreprocessorIterator(KeycloakSession session) {        return session.getKeycloakSessionFactory().getProviderFactories(SamlAuthenticationPreprocessor.class).stream()          .filter(Objects::nonNull)          .map(SamlAuthenticationPreprocessor.class::cast)          .iterator();    }```Then use it in the following way:```javafor (Iterator<SamlAuthenticationPreprocessor> it = SamlSessionUtils.getSamlAuthenticationPreprocessorIterator(); it.hasNext(); ) {    request = it.next().preprocess(request, userSession);}```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6044,332113186,2019-10-07T16:21:41Z,services/src/main/java/org/keycloak/protocol/saml/preprocessor/SamlAuthenticationPreprocessor.java,"@@ -0,0 +1,53 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.saml.preprocessor;++import java.util.function.Consumer;++import org.keycloak.broker.provider.AuthenticationRequest;+import org.keycloak.dom.saml.v2.SAML2Object;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserSessionModel;+import org.keycloak.provider.Provider;+import org.keycloak.provider.ProviderFactory;+import org.keycloak.sessions.AuthenticationSessionModel;++/**+ * Provider interface for SAML authentication preprocessing.+ * + * @author <a href=""mailto:gideon.caranzo@thalesgroup.com"">Gideon Caranzo</a>+ *+ */+public interface SamlAuthenticationPreprocessor extends Provider {++    void preprocess(AuthenticationSessionModel authSession, SAML2Object samlObj);","Split into methods before processing the received response:```suggestion    default AuthnRequestType beforeProcessingLoginRequest(AuthnRequestType authnRequest, AuthenticationSessionModel authSession) { return authnRequest; }    default LogoutRequestType beforeProcessingLogoutRequest(LogoutRequestType logoutRequest, UserSessionModel authSession, AuthenticatedClientSessionModel clientSession) { return logoutRequest; }    default SAML2LogoutRequestBuilder beforeSendingLogoutRequest(SAML2LogoutRequestBuilder logoutBuilder, UserSessionModel authSession, AuthenticatedClientSessionModel clientSession) {return logoutBuilder;}    default StatusResponseType beforeSendingResponse(StatusResponseType statusResponse, ClientSessionModel clientSession) { return statusResponse; }````beforeProcessingLoginRequest` should be called from `SamlService.loginRequest`, `IdentityBrokerService.authenticated` like it is now.`beforeProcessingLogoutRequest` should be called from `SamlService.logoutRequest` and `SAMLEndpoint.Binding.logoutRequest()``beforeSendingLogoutRequest` should be called from `SAMLIdentityProvider.buildLogoutRequest()` and `SamlProtocol.createLogoutRequest`. Note that `clientSession` parameter would be `null` for identity provider service and filled for clients.`beforeSendingResponse` should be called from `IdentityBrokerService.authenticated()` and `SamlProtocol.transformLoginResponse`",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6362,332432667,2019-10-08T10:06:25Z,services/src/main/java/org/keycloak/common/util/Resteasy.java,"@@ -0,0 +1,156 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.common.util;++import org.jboss.resteasy.core.Dispatcher;+import org.jboss.resteasy.core.ResteasyContext;+import org.jboss.resteasy.spi.ResteasyProviderFactory;++/**+ * <p>Provides a layer of indirection to abstract invocations to Resteasy internal APIs. Making also possible to use different+ * versions of Resteasy (e.g.: v3 and v4) depending on the stack that the server is running.+ *+ * <p>The methods herein provided are basically related with accessing context data from Resteasy, which changed in latest versions of Resteasy.+ *+ * <p>It is important to use this class when access to context data is necessary in order to avoid incompatibilities with future+ * versions of Resteasy.+ *+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public final class Resteasy {++    private static final BiConsumer<Class, Object> PUSH_CONTEXT;+    private static final BiConsumer<Class, Object> PUSH_DEFAULT_OBJECT;+    private static final Function<Class, Object> PULL_CONTEXT;+    private static final Runnable CLEAR_CONTEXT;++    static {+        if (isRestEasy4()) {+            PUSH_CONTEXT = new BiConsumer<Class, Object>() {+                @Override+                public void accep(Class p1, Object p2) {+                    ResteasyContext.pushContext(p1, p2);+                }+            };+            PUSH_DEFAULT_OBJECT = new BiConsumer<Class, Object>() {+                @Override+                public void accep(Class p1, Object p2) {+                    ResteasyContext.getContextData(org.jboss.resteasy.spi.Dispatcher.class).getDefaultContextObjects()+                            .put(p1, p2);+                }+            };+            PULL_CONTEXT = new Function<Class, Object>() {+                @Override+                public Object apply(Class p1) {+                    return ResteasyContext.getContextData(p1);+                }+            };+            CLEAR_CONTEXT = new Runnable() {+                @Override+                public void run() {+                    ResteasyContext.clearContextData();+                }+            };+        } else {+            PUSH_CONTEXT = new BiConsumer<Class, Object>() {+                @Override+                public void accep(Class p1, Object p2) {+                    ResteasyProviderFactory.getInstance().pushContext(p1, p2);+                }+            };+            PUSH_DEFAULT_OBJECT = new BiConsumer<Class, Object>() {+                @Override+                public void accep(Class p1, Object p2) {+                    ResteasyProviderFactory.getInstance().getContextData(Dispatcher.class).getDefaultContextObjects()+                            .put(p1, p2);+                }+            };+            PULL_CONTEXT = new Function<Class, Object>() {+                @Override+                public Object apply(Class p1) {+                    return ResteasyProviderFactory.getInstance().getContextData(p1);+                }+            };+            CLEAR_CONTEXT = new Runnable() {+                @Override+                public void run() {+                    ResteasyProviderFactory.getInstance().clearContextData();+                }+            };+        }+    }++    /**+     * Push the given {@code instance} with type/key {@code type} to the Resteasy context associated with the current thread.+     * +     * @param type the type/key to associate the {@code instance} with +     * @param instance the instance+     */+    public static void pushContext(Class type, Object instance) {+        PUSH_CONTEXT.accep(type, instance);+    }++    /**+     * Lookup the instance associated with the given type/key {@code type} from the Resteasy context associated with the current thread.+     *+     * @param type the type/key to lookup +     * @return the instance associated with the given {@code type} or null if non-existent.                +     */+    public static <R> R getContextData(Class<R> type) {+        return (R) PULL_CONTEXT.apply(type);+    }++    /**+     * Clear the Resteasy context associated with the current thread.+     */+    public static void clearContextData() {+        CLEAR_CONTEXT.run();+    }++    /**+     * Push the given {@code instance} with type/key {@code type} to the Resteasy global context.+     *+     * @param type the type/key to associate the {@code instance} with+     * @param instance the instance+     */+    public static void pushDefaultContextObject(Class type, Object instance) {+        PUSH_DEFAULT_OBJECT.accep(type, instance);+    }++    private static boolean isRestEasy4() {+        try {+            return Class.forName(""org.jboss.resteasy.core.ResteasyContext"") != null;+        } catch (ClassNotFoundException ignore) {+            return false;+        }+    }++    /**+     * Only necessary because keycloak-common is constrained to JDK 1.7.+     */+    private interface BiConsumer<T, S> {+        void accep(T p1, S p2);","Typo in the method name. Probably doesn't worth to block a PR for longer time, but if it's easily possible to fix, it can be nice :)",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6320,334745141,2019-10-15T04:09:48Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmAdapter.java,"@@ -680,8 +680,7 @@ public void removeDefaultRoles(String... defaultRoles) {      @Override     public List<ClientModel> getClients() {-        return cacheSession.getClients(this);-+        return cacheSession.getClients(this, 0, cacheSession.getClientsCount(this).intValue());","Realm should have an overloaded method getClients(this), that just calls getClients(this, null, null). This approach will result in extra query to get the client counts first, to then list all clients.",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6320,334745375,2019-10-15T04:11:19Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -537,40 +537,8 @@ static String getRoleByNameCacheKey(String container, String name) {     }","Just checking here - we are removing any caching of client lists, and only having caching of individual clients?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6320,334746027,2019-10-15T04:15:20Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -582,6 +581,22 @@ public ClientModel getClientByClientId(String clientId, RealmModel realm) {         return session.realms().getClientById(id, realm);     } +    @Override+    public List<ClientModel> searchClientsByClientId(String clientId, Integer firstResult, Integer maxResults, RealmModel realm) {+        TypedQuery<String> query = em.createNamedQuery(""searchClientsByClientId"", String.class);+        if (firstResult != null && firstResult > 0) {+            query.setFirstResult(firstResult);+        }+        if (maxResults != null && maxResults > 0) {+            query.setMaxResults(maxResults);+        }+        query.setParameter(""clientId"", clientId);+        query.setParameter(""realm"", realm.getId());+        List<String> results = query.getResultList();+        if (results.isEmpty()) return null;",This should return empty list rather than null,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6320,334746475,2019-10-15T04:18:34Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java,"@@ -104,6 +104,7 @@ public Response logout(@QueryParam(OIDCLoginProtocol.REDIRECT_URI_PARAM) String                            @QueryParam(""initiating_idp"") String initiatingIdp) {         String redirect = postLogoutRedirectUri != null ? postLogoutRedirectUri : redirectUri; +        // TODO evaluate importance of removing this: major performance boost observed","Remove this TODO as it could result in someone removing this by mistake, and doing so would be a breaking change. We are planning on introducing support for RP Initiated logout (https://issues.jboss.org/browse/KEYCLOAK-11603) which won't suffer from the design issue that this logout endpoint does. We will deprecate and eventually remove the legacy KC endpoint.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6320,334750659,2019-10-15T04:45:23Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties,"@@ -1214,10 +1215,12 @@ group-membership.tooltip=Groups user is a member of. Select a listed group and c membership.available-groups.tooltip=Groups a user can join. Select a group and click the join button. table-of-realm-users=Table of Realm Users view-all-users=View all users+view-all-clients=View all clients","The clients page should just display the first list of clients, not requiring clicking view all clients.",
39477523,mingjliu9,https://api.github.com/repos/keycloak/keycloak/pulls/6338,334860701,2019-10-15T10:02:23Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/RolesResource.java,"@@ -37,6 +39,78 @@     @GET     @Produces(MediaType.APPLICATION_JSON)     List<RoleRepresentation> list();+    +    /**+     * @param fullRepresentation if true, return roles with their attributes+     * @return A list containing all roles.+     */+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    List<RoleRepresentation> list(@QueryParam(""full"") @DefaultValue(""false"") boolean fullRepresentation);+    +    /**+     * Get roles by pagination params.+     * @param search max number of occurrences+     * @param first index of the first element+     * @param max max number of occurrences+     * @return A list containing the slice of all roles.+     */+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    List<RoleRepresentation> list(@QueryParam(""first"") Integer firstResult,+                                  @QueryParam(""max"") Integer maxResults);",Would primitive type and larger scope one `long` type fit better for this kind of cases?,
12050544,Cracky5457,https://api.github.com/repos/keycloak/keycloak/pulls/6338,334894125,2019-10-15T11:25:15Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/RolesResource.java,"@@ -37,6 +39,78 @@     @GET     @Produces(MediaType.APPLICATION_JSON)     List<RoleRepresentation> list();+    +    /**+     * @param fullRepresentation if true, return roles with their attributes+     * @return A list containing all roles.+     */+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    List<RoleRepresentation> list(@QueryParam(""full"") @DefaultValue(""false"") boolean fullRepresentation);+    +    /**+     * Get roles by pagination params.+     * @param search max number of occurrences+     * @param first index of the first element+     * @param max max number of occurrences+     * @return A list containing the slice of all roles.+     */+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    List<RoleRepresentation> list(@QueryParam(""first"") Integer firstResult,+                                  @QueryParam(""max"") Integer maxResults);","Mmmh, actually all the other API with pagination use Integer for firstResult and maxResult so we have to be coherent. Otherwise, long is probable a lot too much for a pagination, also theses fields are not required and could be null that's why we use Integer instead of int.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6119,335961288,2019-10-17T11:57:24Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/CustomAuthFlowOTPTest.java,"@@ -348,6 +370,22 @@ private RoleRepresentation getOrCreateOTPRole() {         }     } +    private GroupRepresentation getOrCreateOTPRoleInGroup() {",This should just create the group directly rather than trying to lookup and catching exceptions,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6406,337351257,2019-10-22T06:53:06Z,distribution/server-quarkus/pom.xml,"@@ -0,0 +1,176 @@+<!--+  ~ Copyright 2016 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">+    <modelVersion>4.0.0</modelVersion>+    <parent>+        <artifactId>keycloak-distribution-parent</artifactId>+        <groupId>org.keycloak</groupId>+        <version>8.0.0-SNAPSHOT</version>+    </parent>++    <artifactId>keycloak-server-quarkus</artifactId>+    <packaging>pom</packaging>+    <name>Keycloak Quarkus Server Distribution</name>+    <description/>++    <dependencies>+        <dependency>","Should not depend on keycloak-server-feature-pack (as that will eventually be removed, granted it is a long time from now). Rather add licenses in the same that it does.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6395,337355907,2019-10-22T07:11:13Z,themes/src/main/resources/theme/base/admin/resources/js/app.js,"@@ -3158,9 +3158,56 @@ module.directive('kcPassword', function ($compile, Notifications) {     return {         restrict: 'A',         link: function ($scope, elem, attr, ctrl) {+            function toggleMask(evt) {+                if(elem.hasClass('password-conceal')) {+                    view();+                } else {+                    conceal();+                }+            }++            function view() {+                elem.removeClass('password-conceal');++                var t = elem.next().children().first();+                t.addClass('fa-eye-slash');+                t.removeClass('fa-eye');+            }++            function conceal() {+                elem.addClass('password-conceal');++                var t = elem.next().children().first();+                t.removeClass('fa-eye-slash');+                t.addClass('fa-eye');+            }+             elem.addClass(""password-conceal"");             elem.attr(""type"",""text"");             elem.attr(""autocomplete"", ""off"");++            var p = elem.parent();++            var inputGroup = $('<div class=""input-group""></div>');+            var eye = $('<span class=""input-group-addon btn btn-default""><span class=""fa fa-eye""></span></span>')+                        .on('click', toggleMask);++            console.info(attr.ngModel);++            $scope.$watch(attr.ngModel, function(v) {+                if (v && v == '**********') {+                    elem.next().addClass('disabled')+                } else if (v && v.startsWith('${')) {","Changed it to ""${v"". Happy middle ground?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6410,337413582,2019-10-22T09:29:51Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/theme/ExtendingThemeTest.java,"@@ -66,4 +84,43 @@ public void environmentVariablesSubstitutionInThemeProperties() {             }         });     }++    // KEYCLOAK-11729+    // If 'shouldBeInContainer' is true, then extending theme will be copied to JBoss-based container.+    // Otherwise, the theme will be deleted from JBoss-based container (clean-up).+    private void themeToContainer(boolean shouldBeInContainer) {","Is it rather possible to copy the theme at the time when auth-server-wildfly (or auth-server-eap) is prepared? Possibly here https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/servers/auth-server/jboss/pom.xml#L155 ? That could be compliant with existing tests, which use some similar functionality and require to have some files available on auth server side.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6388,337895102,2019-10-23T07:50:16Z,server-spi/src/main/java/org/keycloak/models/KeycloakUriInfo.java,"@@ -81,7 +82,7 @@ public UriBuilder getAbsolutePathBuilder() {     @Override     public URI getBaseUri() {         if (baseURI == null) {-            baseURI = delegate.getBaseUriBuilder().scheme(scheme).host(hostname).port(port).build();+            baseURI = delegate.getBaseUriBuilder().scheme(scheme).host(hostname).port(port).replacePath(contextPath).build();","Should this change be applied  to other methods of this class as well (`getAbsolutePath`, `getRequestUri`)?",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6320,338421614,2019-10-24T07:35:52Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -537,40 +537,8 @@ static String getRoleByNameCacheKey(String container, String name) {     }","I was mostly just checking as we shouldn't cache clients at all. Client lists are only used in admin console, and while being used in admin console often changed. So it doesn't make any sense to cache client lists.",
396448,rainerfrey,https://api.github.com/repos/keycloak/keycloak/pulls/4283,338950775,2019-10-25T08:54:28Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/authentication/KeycloakAuthenticationEntryPoint.java,"@@ -94,7 +94,17 @@ public void commence(HttpServletRequest request, HttpServletResponse response, A         }     } +    /**+     * Redirects to the login page. If HTTP sessions are disabled, the redirect URL is saved in a+     * cookie now, to be retrieved by the {@link KeycloakAuthenticationSuccessHandler} or the+     * {@link KeycloakAuthenticationFailureHandler} when the login sequence completes.+     */     protected void commenceLoginRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {+        if (request.getSession(false) == null && KeycloakCookieBasedRedirect.getRedirectUrlFromCookie(request) == null) {+            // If no session exists yet at this point, then apparently the redirect URL is not+            // stored in a session. We'll store it in a cookie instead.+            response.addCookie(KeycloakCookieBasedRedirect.createCookieFromRedirectUrl(request.getRequestURI()));",This does not preserve query parameters of the original request. Is this intentional? Is there any (e.g. security related) reason to not include the query?,
1345317,scranen,https://api.github.com/repos/keycloak/keycloak/pulls/4283,338962840,2019-10-25T09:24:21Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/authentication/KeycloakAuthenticationEntryPoint.java,"@@ -94,7 +94,17 @@ public void commence(HttpServletRequest request, HttpServletResponse response, A         }     } +    /**+     * Redirects to the login page. If HTTP sessions are disabled, the redirect URL is saved in a+     * cookie now, to be retrieved by the {@link KeycloakAuthenticationSuccessHandler} or the+     * {@link KeycloakAuthenticationFailureHandler} when the login sequence completes.+     */     protected void commenceLoginRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {+        if (request.getSession(false) == null && KeycloakCookieBasedRedirect.getRedirectUrlFromCookie(request) == null) {+            // If no session exists yet at this point, then apparently the redirect URL is not+            // stored in a session. We'll store it in a cookie instead.+            response.addCookie(KeycloakCookieBasedRedirect.createCookieFromRedirectUrl(request.getRequestURI()));","Not intenional, this is an oversight on my part. I think it would make perfect sense to include the query parameters.",
1345317,scranen,https://api.github.com/repos/keycloak/keycloak/pulls/4283,338964889,2019-10-25T09:29:20Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/authentication/KeycloakAuthenticationEntryPoint.java,"@@ -94,7 +94,17 @@ public void commence(HttpServletRequest request, HttpServletResponse response, A         }     } +    /**+     * Redirects to the login page. If HTTP sessions are disabled, the redirect URL is saved in a+     * cookie now, to be retrieved by the {@link KeycloakAuthenticationSuccessHandler} or the+     * {@link KeycloakAuthenticationFailureHandler} when the login sequence completes.+     */     protected void commenceLoginRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {+        if (request.getSession(false) == null && KeycloakCookieBasedRedirect.getRedirectUrlFromCookie(request) == null) {+            // If no session exists yet at this point, then apparently the redirect URL is not+            // stored in a session. We'll store it in a cookie instead.+            response.addCookie(KeycloakCookieBasedRedirect.createCookieFromRedirectUrl(request.getRequestURI()));","I do wonder in hindsight if there is not a way to avoid this cookie. Since OAuth2 / Keycloak accepts a redirect URI, that redirect URI could be to an endpoint that itself has a query parameter that is an urlencoded redirect URI. If the current Keycloak adapter already has an endpoint that finalises the authentication flow which accepts a redirect URI parameter, then maybe we could reuse that and avoid the extra cookie (which is a burden because of the HTTP headers growing rather large).",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6417,338965686,2019-10-25T09:31:17Z,services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java,"@@ -0,0 +1,200 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.services.resources.account;++import java.net.URI;+import java.nio.charset.StandardCharsets;+import java.security.MessageDigest;+import java.util.UUID;+import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;+import javax.ws.rs.core.UriBuilder;+import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.common.util.Base64Url;+import org.keycloak.credential.CredentialModel;+import org.keycloak.events.Details;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.FederatedIdentityModel;+import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.representations.account.AccountLinkUriRepresentation;+import org.keycloak.representations.account.LinkedAccountsRepresentation;+import org.keycloak.services.ErrorResponse;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.Auth;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.validation.Validation;++/**+ * API for linking/unlinking social login accounts+ *+ * @author Stan Silvert+ */+public class LinkedAccountsResource {+    private static final Logger logger = Logger.getLogger(LinkedAccountsResource.class);+    +    private final KeycloakSession session;+    private final HttpRequest request;+    private final ClientModel client;+    private final EventBuilder event;+    private final UserModel user;+    private final RealmModel realm;+    private final Auth auth;++    public LinkedAccountsResource(KeycloakSession session, +                                  HttpRequest request, +                                  ClientModel client,+                                  Auth auth, +                                  EventBuilder event, +                                  UserModel user) {+        this.session = session;+        this.request = request;+        this.client = client;+        this.auth = auth;+        this.event = event;+        this.user = user;+        realm = session.getContext().getRealm();+    }+    +    @GET+    @Path(""/"")+    @Produces(MediaType.APPLICATION_JSON)+    public Response linkedAccounts() {+        LinkedAccountsBean linkedAccounts = new LinkedAccountsBean(this.session, this.realm, this.user);+        LinkedAccountsRepresentation rep = new LinkedAccountsRepresentation();+        rep.setHasAlternativeAuthentication(linkedAccounts.getHasAlternativeAuthentication());+        rep.setLinkedAccounts(linkedAccounts.getLinkedAccounts());+        return Cors.add(request, Response.ok(rep)).auth().allowedOrigins(auth.getToken()).build();+    }+    +    @GET+    @Path(""/{providerId}"")+    @Produces(MediaType.APPLICATION_JSON)+    public Response buildLinkedAccountURI(@PathParam(""providerId"") String providerId, +                                     @QueryParam(""redirectUri"") String redirectUri) {+        if (redirectUri == null) {+            ErrorResponse.error(Messages.INVALID_REDIRECT_URI, Response.Status.BAD_REQUEST);+        }+        +        String errorMessage = checkCommonPreconditions(providerId);+        if (errorMessage != null) {+            return ErrorResponse.error(errorMessage, Response.Status.BAD_REQUEST);+        }+        +        try {+            String nonce = UUID.randomUUID().toString();+            MessageDigest md = MessageDigest.getInstance(""SHA-256"");+            String input = nonce + auth.getSession().getId() +  client.getClientId() + providerId;+            byte[] check = md.digest(input.getBytes(StandardCharsets.UTF_8));+            String hash = Base64Url.encode(check);+            URI linkUri = Urls.identityProviderLinkRequest(this.session.getContext().getUri().getBaseUri(), providerId, realm.getName());+            linkUri = UriBuilder.fromUri(linkUri)+                    .queryParam(""nonce"", nonce)+                    .queryParam(""hash"", hash)+                    .queryParam(""client_id"", client.getClientId())+                    .queryParam(""redirect_uri"", redirectUri)+                    .build();+            +            AccountLinkUriRepresentation rep = new AccountLinkUriRepresentation();+            rep.setAccountLinkUri(linkUri);+            rep.setHash(hash);+            rep.setNonce(nonce);+            +            return Cors.add(request, Response.ok(rep)).auth().allowedOrigins(auth.getToken()).build();+        } catch (Exception spe) {+            spe.printStackTrace();+            return ErrorResponse.error(Messages.FAILED_TO_PROCESS_RESPONSE, Response.Status.INTERNAL_SERVER_ERROR);+        }+    }+    +    @DELETE+    @Path(""/{providerId}"")+    @Produces(MediaType.APPLICATION_JSON)+    public Response removeLinkedAccount(@PathParam(""providerId"") String providerId) {+        String errorMessage = checkCommonPreconditions(providerId);+        if (errorMessage != null) {+            return ErrorResponse.error(errorMessage, Response.Status.BAD_REQUEST);+        }+        +        FederatedIdentityModel link = session.users().getFederatedIdentity(user, providerId, realm);+        if (link == null) {+            return ErrorResponse.error(Messages.FEDERATED_IDENTITY_NOT_ACTIVE, Response.Status.BAD_REQUEST);+        }++        // Removing last social provider is not possible if you don't have other possibility to authenticate+        if (!(session.users().getFederatedIdentities(user, realm).size() > 1 || user.getFederationLink() != null || isPasswordSet())) {+            return ErrorResponse.error(Messages.FEDERATED_IDENTITY_REMOVING_LAST_PROVIDER, Response.Status.BAD_REQUEST);+        }+        +        session.users().removeFederatedIdentity(realm, user, providerId);++        logger.debugv(""Social provider {0} removed successfully from user {1}"", providerId, user.getUsername());++        event.event(EventType.REMOVE_FEDERATED_IDENTITY).client(auth.getClient()).user(auth.getUser())+                .detail(Details.USERNAME, auth.getUser().getUsername())+                .detail(Details.IDENTITY_PROVIDER, link.getIdentityProvider())+                .detail(Details.IDENTITY_PROVIDER_USERNAME, link.getUserName())+                .success();++        return Cors.add(request, Response.ok()).auth().allowedOrigins(auth.getToken()).build();+    }+    +    private String checkCommonPreconditions(String providerId) {+        auth.require(AccountRoles.MANAGE_ACCOUNT);+        +        if (Validation.isEmpty(providerId)) {+            return Messages.MISSING_IDENTITY_PROVIDER;+        }+        +        if (!isValidProvider(providerId)) {+            return Messages.IDENTITY_PROVIDER_NOT_FOUND;+        }+        +        if (!user.isEnabled()) {+            return Messages.ACCOUNT_DISABLED;+        }+        +        return null;+    }+    +    private boolean isPasswordSet() {","See earlier comment. This belongs to the /credentials endpoint, not here.",X
396448,rainerfrey,https://api.github.com/repos/keycloak/keycloak/pulls/4283,339083725,2019-10-25T14:32:56Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/authentication/KeycloakAuthenticationEntryPoint.java,"@@ -94,7 +94,17 @@ public void commence(HttpServletRequest request, HttpServletResponse response, A         }     } +    /**+     * Redirects to the login page. If HTTP sessions are disabled, the redirect URL is saved in a+     * cookie now, to be retrieved by the {@link KeycloakAuthenticationSuccessHandler} or the+     * {@link KeycloakAuthenticationFailureHandler} when the login sequence completes.+     */     protected void commenceLoginRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {+        if (request.getSession(false) == null && KeycloakCookieBasedRedirect.getRedirectUrlFromCookie(request) == null) {+            // If no session exists yet at this point, then apparently the redirect URL is not+            // stored in a session. We'll store it in a cookie instead.+            response.addCookie(KeycloakCookieBasedRedirect.createCookieFromRedirectUrl(request.getRequestURI()));","> If the current Keycloak adapter already has an endpoint that finalises the authentication flow which accepts a redirect URI parameter, then maybe we could reuse that and avoid the extra cookie (which is a burden because of the HTTP headers growing rather large)Sounds good in principle, but I am not sure if that is the case. I wouldn't worry too much about it though, because this additional cookie is so much smaller than the ADAPTER_STATE cookie. If header size is a concern, this entire approach isn't ideal.",X
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6382,339172362,2019-10-25T17:59:04Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -464,6 +445,66 @@ private UserConsentModel createConsent(ClientModel client, ConsentRepresentation         return consent;     } +    @Path(""/applications"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response applications() {+        checkAccountApiEnabled();+        auth.requireOneOf(AccountRoles.VIEW_APPLICATIONS, AccountRoles.MANAGE_APPLICATIONS);","@douglaspalmer I believe `MANAGE_APPLICATIONS` should be used only in the removal endpoint, but for listing `VIEW_APPLICATIONS` should be enough. Does it make sense?Maybe worth to ask on the dev mailing list and engage with others to see what they think.",X
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6417,339221430,2019-10-25T20:13:31Z,core/src/main/java/org/keycloak/representations/account/LinkedAccountsRepresentation.java,"@@ -0,0 +1,45 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.representations.account;++import java.util.Set;++/**+ *+ * @author Stan Silvert+ */+public class LinkedAccountsRepresentation {+    private Set<LinkedAccountRepresentation> linkedAccounts;+    private boolean hasAlternativeAuthentication;","That means making two REST calls instead of one, but I'm fine with it.  Agree that hasAlternativeAutentication doesn't really seem like it belongs in this class.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6417,339227934,2019-10-25T20:31:52Z,services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java,"@@ -0,0 +1,200 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.services.resources.account;++import java.net.URI;+import java.nio.charset.StandardCharsets;+import java.security.MessageDigest;+import java.util.UUID;+import javax.ws.rs.DELETE;+import javax.ws.rs.GET;+import javax.ws.rs.Path;+import javax.ws.rs.PathParam;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;+import javax.ws.rs.core.UriBuilder;+import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.common.util.Base64Url;+import org.keycloak.credential.CredentialModel;+import org.keycloak.events.Details;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.FederatedIdentityModel;+import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.representations.account.AccountLinkUriRepresentation;+import org.keycloak.representations.account.LinkedAccountsRepresentation;+import org.keycloak.services.ErrorResponse;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.Auth;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.validation.Validation;++/**+ * API for linking/unlinking social login accounts+ *+ * @author Stan Silvert+ */+public class LinkedAccountsResource {+    private static final Logger logger = Logger.getLogger(LinkedAccountsResource.class);+    +    private final KeycloakSession session;+    private final HttpRequest request;+    private final ClientModel client;+    private final EventBuilder event;+    private final UserModel user;+    private final RealmModel realm;+    private final Auth auth;++    public LinkedAccountsResource(KeycloakSession session, +                                  HttpRequest request, +                                  ClientModel client,+                                  Auth auth, +                                  EventBuilder event, +                                  UserModel user) {+        this.session = session;+        this.request = request;+        this.client = client;+        this.auth = auth;+        this.event = event;+        this.user = user;+        realm = session.getContext().getRealm();+    }+    +    @GET+    @Path(""/"")+    @Produces(MediaType.APPLICATION_JSON)+    public Response linkedAccounts() {+        LinkedAccountsBean linkedAccounts = new LinkedAccountsBean(this.session, this.realm, this.user);+        LinkedAccountsRepresentation rep = new LinkedAccountsRepresentation();+        rep.setHasAlternativeAuthentication(linkedAccounts.getHasAlternativeAuthentication());+        rep.setLinkedAccounts(linkedAccounts.getLinkedAccounts());+        return Cors.add(request, Response.ok(rep)).auth().allowedOrigins(auth.getToken()).build();+    }+    +    @GET+    @Path(""/{providerId}"")+    @Produces(MediaType.APPLICATION_JSON)+    public Response buildLinkedAccountURI(@PathParam(""providerId"") String providerId, +                                     @QueryParam(""redirectUri"") String redirectUri) {+        if (redirectUri == null) {","We discovered that the client isn't able to check the nonce on redirect.   I think we considered that to be a weakness in the process today.This endpoint is just for convenience and simplicity.  If we require the client to create the URI, then every client in every language has to write code for it, and it's not easy code to write.  See https://issues.jboss.org/browse/KEYCLOAK-7752 where a customer had problems doing this correctly.The result is exactly the same whether the URI is generated on server or client.  This endpoint just makes it easier for everyone.That being said, if we are definitely changing this stuff to AIA then we won't need the convenience endpoint going forward.As you see from the JIRA, I have TypeScript code to take care of it, so if you still want me to get rid of the endpoint it won't cost me much extra development time.  But it does mean that the account console needs to download a crypto library that it wouldn't otherwise need.",
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/6427,339529402,2019-10-28T12:10:40Z,GOVERNANCE.md,"@@ -0,0 +1,111 @@+# Keycloak Governance++* [Vision](#vision) +* [Maintainers](#maintainers) +* [Contributing](#contributing)++## Vision++Keycloak aims to be easy to use and lightweight. The project was founded to make it easy for application developers +to secure modern applications and services.++The 80/20 rule is a core part of the vision behind Keycloak. Stating that 80% of requirements come from roughtly 20%+of the use-cases. We strongly believe if Keycloak would support all use-cases out of the box it would become bloated ","use-cases is two words: use casesout of the box is jargon, generally technical communications use the phrase:  ""by default"" ",
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/6427,339531621,2019-10-28T12:16:44Z,GOVERNANCE.md,"@@ -0,0 +1,111 @@+# Keycloak Governance++* [Vision](#vision) +* [Maintainers](#maintainers) +* [Contributing](#contributing)++## Vision++Keycloak aims to be easy to use and lightweight. The project was founded to make it easy for application developers +to secure modern applications and services.++The 80/20 rule is a core part of the vision behind Keycloak. Stating that 80% of requirements come from roughtly 20%+of the use-cases. We strongly believe if Keycloak would support all use-cases out of the box it would become bloated +and hard to use.++As such Keycloak aims to be opinionated and make it as easy as possible to achieve the common use-cases, while still+enabling the less common use-cases through custom extensions.+++## Projects++Keycloak consists of several projects:++* [Keycloak](https://github.com/keycloak/keycloak) - Keycloak Server and Java adapters+* [Keycloak Documentation](https://github.com/keycloak/keycloak-documentation) - Documentation for Keycloak+* [Keycloak QuickStarts](https://github.com/keycloak/keycloak-quickstarts) - QuickStarts for getting started with Keycloak+* [Keycloak Containers](https://github.com/keycloak/keycloak-containers) - Container images for Keycloak+* [Keycloak Gatekeeper](https://github.com/keycloak/keycloak-gatekeeper) - Proxy service to secure apps and services with Keycloak+* [Keycloak Node.js Connect](https://github.com/keycloak/keycloak-nodejs-connect) - Node.js adapter for Keycloak+* [Keycloak Node.js Admin Client](https://github.com/keycloak/keycloak-nodejs-admin-client) - Node.js library for Keycloak Admin REST API++The same governance model applies to all projects. However, the list of maintainers may vary per project. +++## Maintainers++The list of maintainers can be found in the [MAINTAINERS.md](MAINTAINERS.md) file in the repository for the individual +projects listed in the [Projects](#projects) section.++### Maintainer Responsibilities++A maintainer is someone that has shown deep knowledge of vision, features and codebase. It is their +responsibility to drive the project forward, encourage collaboration and contributions, and generally help the +community.++Responsibilities of a maintainer includes, but are not limited to:++* Engage in design discussions+* Actively monitor mailing lists, user forum and chat+* Contribute high quality code+* Maintain deep knowledge of vision, features and codebase+* Review pull requests either themselves or delegate to experts in the relevant area+* Helping the community++### Becoming a Maintainer++To become a maintainer you need to demonstrate the following:++* Good understanding of vision, features and codebase+* Contribution of larger features+* Contribution of bug fixes+* Participation in design discussions+* Participation in pull request reviews+* Ability to collaborate with the team+* Helping the community++A new maintainer must be proposed by sending an email to the [developer mailing list](https://lists.jboss.org/mailman/listinfo/keycloak-dev).+The email should include evidence of the above list.++The existing maintainers will then discuss the proposal. If anyone objects, or wants more information, the maintainers +will reach out to the nominee directly for further discussion. After a review of the nomination existing maintainers+will vote. The nominee will be accepted as a new maintainer by a 2/3 majority vote.+++### Changes in Maintainership++Maintainers can be removed by a 2/3 majority vote by maintainers.+++## Contributing Changes++The process of reviewing proposed changes differs depending of the size and impact of the change.++### Minor Changes++A minor change is a bug fix, a smaller enhancement or a smaller addition to existing features.++To propose a minor change simply create an issue in our [issue tracker](https://issues.jboss.org/browse/KEYCLOAK) and+send a pull request.++A maintainer will be responsible for ultimately approving the pull request. The maintainer may do a deep review of the+pull request themselves or delegate to an expert in the corresponding area.++If the maintainer believes the change has a bigger impact it has to follow the process for larger changes.","I would suggest ""... bigger impact, follow the process for larger changes.""  ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6417,339999778,2019-10-29T10:36:50Z,core/src/main/java/org/keycloak/representations/account/LinkedAccountRepresentation.java,"@@ -0,0 +1,87 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.representations.account;++/**+ *+ * @author Stan Silvert+ */+public class LinkedAccountRepresentation {+    private boolean connected;+    private String providerId;+    private String providerName;+    private String guiOrder;",Would it be better to just sort the returned list on the server side? That way the client doesn't have to sort it. Client-side sorting is tricky if we ever would want to add pagination.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6417,340005478,2019-10-29T10:50:11Z,core/src/main/java/org/keycloak/representations/account/LinkedAccountRepresentation.java,"@@ -0,0 +1,87 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.representations.account;++/**+ *+ * @author Stan Silvert+ */+public class LinkedAccountRepresentation {+    private boolean connected;+    private String providerId;+    private String providerName;","Not sure if it should be providerId, or providerAlias. It is actually the alias, not the internal id, that is used. So might be confusing.BTW one big issue with the admin endpoints today is the requirement to use internal-ids to lookup things. It makes it really hard for folks to use the APIs, so I don't want account endpoint (and console) to expose internal-ids when possible.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6382,340206342,2019-10-29T17:01:33Z,core/src/main/java/org/keycloak/representations/account/ClientRepresentation.java,"@@ -22,4 +26,36 @@ public String getClientName() {     public void setClientName(String clientName) {         this.clientName = clientName;     }++    public String getDescription() {+        return description;+    }++    public void setDescription(String description) {+        this.description = description;+    }++    public boolean isInternal() {+        return internal;+    }++    public void setInternal(boolean internal) {+        this.internal = internal;+    }++    public boolean isInUse() {+        return inUse;+    }++    public void setInUse(boolean inUse) {+        this.inUse = inUse;+    }++    public String getUrl() {+        return url;+    }++    public void setUrl(String url) {+        this.url = url;+    }","@douglaspalmer we're missing created date and last access date. Marek commented on that thread about filtering on the mailing list. Let me quote him:```List<UserConsentModel> consents = session.users().getConsents(realmModel, userId);Each UserConsentModel contains info about client, consent created date and last access date.```I noticed that you already have the code to retrieve Consents, maybe, it's just the matter of update.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6382,340209711,2019-10-29T17:07:25Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountRestServiceTest.java,"@@ -304,6 +306,35 @@ public void listApplications() throws IOException {                 .asJson(new TypeReference<List<ClientRepresentation>>() {                 });         assertFalse(applications.isEmpty());","@douglaspalmer I'd suggest a separate test case for testing this scenario and also add the removal of applications.Also, I'd suggest that we go through each comment made on the mailing list for that Filtering thread and make sure that we have all the requirements reflected here. For example, the comment below was made by Stian:> To advertise applications on the account console we'd add an option to the client in admin console ""Always view in account console"" (not visible on bearer-only clients).>> Now the list of clients to include in this page would be:> > * All applications from current open sessions, including offline sessions> * All applications with granted consents to the user (a third-party app can have a persisted consent, but not currently be in use, so this needs to be displayed)> * All applications that have the ""Always view in account console"" option enabled> > It seems to me that we don't part of these requirements implemented yet.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6324,340360027,2019-10-29T22:41:39Z,model/jpa/src/main/java/org/keycloak/migration/jpa/LazyCreateIndexCustomChange.java,"@@ -0,0 +1,163 @@+package org.keycloak.migration.jpa;++import liquibase.change.AddColumnConfig;+import liquibase.change.custom.CustomSqlChange;+import liquibase.database.Database;+import liquibase.database.core.MSSQLDatabase;+import liquibase.database.core.MySQLDatabase;+import liquibase.database.core.OracleDatabase;+import liquibase.database.core.PostgresDatabase;+import liquibase.exception.SetupException;+import liquibase.exception.ValidationErrors;+import liquibase.resource.ResourceAccessor;+import liquibase.statement.SqlStatement;+import liquibase.statement.core.CreateIndexStatement;+import liquibase.statement.core.RawSqlStatement;+import liquibase.structure.core.Column;+import liquibase.util.StringUtils;++import java.util.ArrayList;+import java.util.Collections;+import java.util.List;+import java.util.StringJoiner;++public class LazyCreateIndexCustomChange implements CustomSqlChange {++    private String catalogName;+    private String schemaName;+    private String tableName;+    private String indexName;+    private List<AddColumnConfig> columns = Collections.emptyList();++    public String getIndexName() {+        return indexName;+    }++    public void setIndexName(String indexName) {+        this.indexName = indexName;+    }++    public String getSchemaName() {+        return schemaName;+    }++    public void setSchemaName(String schemaName) {+        this.schemaName = schemaName;+    }++    public String getTableName() {+        return tableName;+    }++    public void setTableName(String tableName) {+        this.tableName = tableName;+    }++    @Override+    public SqlStatement[] generateStatements(Database database) {+        final String escapedTableName = database.escapeTableName(getCatalogName(), getSchemaName(), getTableName());+        final String escapedIndexName = database.escapeIndexName(getCatalogName(), getSchemaName(), getIndexName());+        final String escapedColumnNames = joinEscapedColumnNames(database);++        final String rawQuery;+        if (database instanceof PostgresDatabase) {+            rawQuery = ""CREATE INDEX "" + escapedIndexName ++                    "" ON "" + escapedTableName ++                    "" ("" + escapedColumnNames + "") CONCURRENTLY"";+        } else if (database instanceof OracleDatabase) {+            rawQuery = ""CREATE INDEX "" + escapedIndexName ++                    "" ON "" + escapedTableName ++                    "" ("" + escapedColumnNames + "") ONLINE"";+        } else if (database instanceof MySQLDatabase) {+            rawQuery = ""ALTER TABLE "" + escapedTableName ++                    "" ADD INDEX "" + escapedIndexName ++                    "" ("" + escapedColumnNames + "")"" ++                    "", LOCK=NONE;"";+        } else if (database instanceof MSSQLDatabase) {+            rawQuery = ""CREATE NONCLUSTERED INDEX "" + escapedIndexName ++                    "" ON "" + escapedTableName + "" ("" + escapedColumnNames + "")"" ++                    "" REBUILD WITH (ONLINE = ON)"";","I agree that the missing indices are painful. This issue is not being ignored, however there are deployments that could have been disrupted by forced creation of the indices.Clearly there is no simple automated way to create the indices due to differences among the databases. Perhaps we can do the following liquibase extension similar to what you have implemented:* An index can just be created in the foreground if the affected table rows count is smaller than a given configurable number with a reasonable default value (let say 500.000 rows)* Otherwise a warning with the SQL message is logged that contains a SQL command recommended to be applied manually by the DB admin.Would that work for you, @thielef, @knutz3n, @gtudan ?",
159774,knutz3n,https://api.github.com/repos/keycloak/keycloak/pulls/6324,340494220,2019-10-30T09:04:01Z,model/jpa/src/main/java/org/keycloak/migration/jpa/LazyCreateIndexCustomChange.java,"@@ -0,0 +1,163 @@+package org.keycloak.migration.jpa;++import liquibase.change.AddColumnConfig;+import liquibase.change.custom.CustomSqlChange;+import liquibase.database.Database;+import liquibase.database.core.MSSQLDatabase;+import liquibase.database.core.MySQLDatabase;+import liquibase.database.core.OracleDatabase;+import liquibase.database.core.PostgresDatabase;+import liquibase.exception.SetupException;+import liquibase.exception.ValidationErrors;+import liquibase.resource.ResourceAccessor;+import liquibase.statement.SqlStatement;+import liquibase.statement.core.CreateIndexStatement;+import liquibase.statement.core.RawSqlStatement;+import liquibase.structure.core.Column;+import liquibase.util.StringUtils;++import java.util.ArrayList;+import java.util.Collections;+import java.util.List;+import java.util.StringJoiner;++public class LazyCreateIndexCustomChange implements CustomSqlChange {++    private String catalogName;+    private String schemaName;+    private String tableName;+    private String indexName;+    private List<AddColumnConfig> columns = Collections.emptyList();++    public String getIndexName() {+        return indexName;+    }++    public void setIndexName(String indexName) {+        this.indexName = indexName;+    }++    public String getSchemaName() {+        return schemaName;+    }++    public void setSchemaName(String schemaName) {+        this.schemaName = schemaName;+    }++    public String getTableName() {+        return tableName;+    }++    public void setTableName(String tableName) {+        this.tableName = tableName;+    }++    @Override+    public SqlStatement[] generateStatements(Database database) {+        final String escapedTableName = database.escapeTableName(getCatalogName(), getSchemaName(), getTableName());+        final String escapedIndexName = database.escapeIndexName(getCatalogName(), getSchemaName(), getIndexName());+        final String escapedColumnNames = joinEscapedColumnNames(database);++        final String rawQuery;+        if (database instanceof PostgresDatabase) {+            rawQuery = ""CREATE INDEX "" + escapedIndexName ++                    "" ON "" + escapedTableName ++                    "" ("" + escapedColumnNames + "") CONCURRENTLY"";+        } else if (database instanceof OracleDatabase) {+            rawQuery = ""CREATE INDEX "" + escapedIndexName ++                    "" ON "" + escapedTableName ++                    "" ("" + escapedColumnNames + "") ONLINE"";+        } else if (database instanceof MySQLDatabase) {+            rawQuery = ""ALTER TABLE "" + escapedTableName ++                    "" ADD INDEX "" + escapedIndexName ++                    "" ("" + escapedColumnNames + "")"" ++                    "", LOCK=NONE;"";+        } else if (database instanceof MSSQLDatabase) {+            rawQuery = ""CREATE NONCLUSTERED INDEX "" + escapedIndexName ++                    "" ON "" + escapedTableName + "" ("" + escapedColumnNames + "")"" ++                    "" REBUILD WITH (ONLINE = ON)"";","Yes, I think that is a fair compromise. I have a couple of questions, though.1. Where should the configurable number be be configured? Standalone.xml?2. Will Liquibase have knowledge of the index after it is applied manually? Does it need to?3. Would it be an option to require the DB admin to add the index before upgrading? So Liquibase can just ensure that the index exists and if not, and there are less than x rows, it will apply the index?Also, regarding Postgres which has support to add indexes in the background, it would be nice to get it to work with adding indexes concurrently. However, Postgres requires this to be done outside an transaction. When I tested it in Keycloak I got a deadlock even when the index was complete. Is this something we could look into? I will be happy to demonstrate it to you in a video meeting or something.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6320,340735071,2019-10-30T16:47:17Z,themes/src/main/resources/theme/base/admin/resources/partials/realm-default-roles.html,"@@ -44,15 +44,13 @@ <h1>{{:: 'roles' | translate}}</h1>         </div>          <div class=""form-group"">-            <label class=""col-md-2 control-label"" class=""control-label"">-                <span>{{:: 'client-roles' | translate}}</span>-                <select class=""form-control"" id=""clients"" name=""clients"" ng-change=""changeClient()"" ng-model=""client"" ng-options=""a.clientId for a in clients | orderBy:'clientId'"" ng-disabled=""false""></select>-            </label>-            <div class=""col-md-10"" data-ng-show=""client"">-                <div class=""row"" data-ng-hide=""client"">-                    <div class=""col-md-4""><span class=""text-muted"">{{:: 'select-client-to-view-roles' | translate}}</span></div>+           <label class=""col-md-2 control-label"" for=""clients"">{{:: 'client-roles' | translate}}</label>+                <div class=""col-md-6"">+                    <input type=""hidden"" ui-select2=""clientsUiSelect"" id=""clients"" data-ng-model=""selectedClient"" data-ng-change=""changeClient(selectedClient);"" data-placeholder=""{{:: 'authz-select-client' | translate}}..."">","The selector for the default roles is broken.**Steps to reproduce**1. Navigate to default realm roles.1. In ""Client Roles"", select a Client that has some roles.1. Select a role in ""Available Roles"" list and click ""Add selected"".*Expected:* The role appears in the ""Client Default Roles"" list.*Actual:* The role ""disappears"" making it impossible to see it in the ""Client Default Roles"" list.@stianst BTW, sad thing about this is it was not caught by tests. :( We truly have some coverage issues.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6320,340752757,2019-10-30T17:19:24Z,testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/clients/mappers/CreateClientMappersForm.java,"@@ -117,14 +118,21 @@ public void selectRealmRole(String roleName) {         }                  public void selectClientRole(String clientName, String roleName) {+            WaitUtils.pause(100);             if (roleName != null || clientName != null) {-                clientSelect.selectByVisibleText(clientName);                 clientAvailable.selectByVisibleText(roleName);             }             WaitUtils.pause(1000);             selectClientRoleButton.click();             WaitUtils.waitForModalFadeOut();         }++        public void selectClient(String clientName) {+            driver.findElement(By.cssSelector(""#s2id_clients .select2-choice"")).click();+            String subContainerClass = ""#select2-drop:not([style*='display: none'])"";+            driver.findElement(By.cssSelector( subContainerClass + "" .select2-input"")).sendKeys(clientName);+            driver.findElements(By.cssSelector(subContainerClass + "" .select2-results li.select2-result-selectable"")).get(0).click();",Could you perhaps try to use similar approach to [this](https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/clients/authorization/policy/ClientPolicyForm.java#L89)? The point is not to copy-paste code between Page Objects and also not to put so many ugly selectors directly into the methods.,X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6320,340752963,2019-10-30T17:19:47Z,testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/clients/clientscopes/ClientScopesEvaluateForm.java,"@@ -103,8 +103,9 @@ public void setAssignedClientScopes(Collection<String> scopes) {     public void selectUser(String username) {         // TODO: Should be probably better way how to work with the ""ui-select2"" component         driver.findElement(By.id(""select2-chosen-1"")).click();-        driver.findElement(By.className(""select2-input"")).sendKeys(username);-        driver.findElement(By.className(""select2-result-label"")).click();+        String subContainerClass = ""#select2-drop:not([style*='display: none'])"";+        driver.findElement(By.cssSelector( subContainerClass + "" .select2-input"")).sendKeys(username);+        driver.findElements(By.cssSelector(subContainerClass + "" .select2-results li.select2-result-selectable"")).get(0).click();",Could you perhaps try to use similar approach to [this](https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/clients/authorization/policy/ClientPolicyForm.java#L89)? The point is not to copy-paste code between Page Objects and also not to put so many ugly selectors directly into the methods.,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6417,341113283,2019-10-31T12:40:30Z,core/src/main/java/org/keycloak/representations/account/LinkedAccountRepresentation.java,"@@ -0,0 +1,87 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.representations.account;++/**+ *+ * @author Stan Silvert+ */+public class LinkedAccountRepresentation {+    private boolean connected;+    private String providerId;+    private String providerName;+    private String guiOrder;","My point is that sorting should be done on the server side, not on the client side. By just sorting the returned list on the server side there is no need for the guiOrder field.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6382,341637367,2019-11-01T15:57:17Z,core/src/main/java/org/keycloak/representations/account/ClientRepresentation.java,"@@ -6,6 +6,11 @@ public class ClientRepresentation {     private String clientId;     private String clientName;+    private String description;+    private boolean internal;+    private boolean inUse;+    private String url;+    private ConsentRepresentation consent;","@douglaspalmer I believe we should try to simplify this to something like:```private List<String> scopes;private Date createdDate;```Even though is technically possible to get these values on the UI side there are 2 reasons for this:1. Avoid exposing more than we need2. Avoid including too much logic into the UI if possible. For example, to retrieve the consent names we need a chain of Promises inside the UI, something that the endpoint could easily return.",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6417,342491763,2019-11-05T10:39:59Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/linked-accounts-page/linked-accounts-page.component.html,"@@ -1,5 +1,23 @@ <div class=""page-header"">-  <h1 id=""pageTitle"">{{'linkedAccountsHtmlTitle' | translate}}</h1>+  <h1>{{'linkedAccountsHtmlTitle' | translate}}</h1>+  <hr/>+  <h2>Buttons for manual testing.  See JS Console for output.</h2>+  <div class=""card-pf-body row"">+      <button class=""label label-primary"" (click)=""doGet()"">List All</button>+  </div>+  <div class=""card-pf-body row"">","I assume the harcoding of providers here is temporary, and it will be changed to using the rest endpoint as part of a separate issue?",X
8788869,saibot94,https://api.github.com/repos/keycloak/keycloak/pulls/6320,342585209,2019-11-05T14:15:53Z,services/src/main/java/org/keycloak/storage/openshift/OpenshiftClientStorageProvider.java,"@@ -73,6 +75,12 @@ public ClientModel getClientByClientId(String clientId, RealmModel realm) {         return new OpenshiftSAClientAdapter(clientId, resource, client, session, realm, providerModel);     } +    @Override+    public List<ClientModel> searchClientsByClientId(String clientId, Integer firstResult, Integer maxResults, RealmModel realm) {+        // TODO not sure about this, but I don't see this implementation using the search now+        return Collections.singletonList(getClientByClientId(clientId, realm));","@vmuzikar what do you think about this? I don't really know where these Openshift storage classes are used, but maybe we don't even need to implement this method. What do you think?",
8788869,saibot94,https://api.github.com/repos/keycloak/keycloak/pulls/6320,342648361,2019-11-05T16:06:20Z,testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/clients/clientscopes/ClientScopesEvaluateForm.java,"@@ -103,8 +103,9 @@ public void setAssignedClientScopes(Collection<String> scopes) {     public void selectUser(String username) {         // TODO: Should be probably better way how to work with the ""ui-select2"" component         driver.findElement(By.id(""select2-chosen-1"")).click();-        driver.findElement(By.className(""select2-input"")).sendKeys(username);-        driver.findElement(By.className(""select2-result-label"")).click();+        String subContainerClass = ""#select2-drop:not([style*='display: none'])"";+        driver.findElement(By.cssSelector( subContainerClass + "" .select2-input"")).sendKeys(username);+        driver.findElements(By.cssSelector(subContainerClass + "" .select2-results li.select2-result-selectable"")).get(0).click();","Hey, you can check out the `ClientSelectModal` class I've added. It hides away the ugly CSS selectors in `ClientScopesEvaluateForm` and `CreateClientMappersForm`.I think you wanted something like this, the tests run just fine.",
8788869,saibot94,https://api.github.com/repos/keycloak/keycloak/pulls/6320,342648421,2019-11-05T16:06:26Z,testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/clients/mappers/CreateClientMappersForm.java,"@@ -117,14 +118,21 @@ public void selectRealmRole(String roleName) {         }                  public void selectClientRole(String clientName, String roleName) {+            WaitUtils.pause(100);             if (roleName != null || clientName != null) {-                clientSelect.selectByVisibleText(clientName);                 clientAvailable.selectByVisibleText(roleName);             }             WaitUtils.pause(1000);             selectClientRoleButton.click();             WaitUtils.waitForModalFadeOut();         }++        public void selectClient(String clientName) {+            driver.findElement(By.cssSelector(""#s2id_clients .select2-choice"")).click();+            String subContainerClass = ""#select2-drop:not([style*='display: none'])"";+            driver.findElement(By.cssSelector( subContainerClass + "" .select2-input"")).sendKeys(clientName);+            driver.findElements(By.cssSelector(subContainerClass + "" .select2-results li.select2-result-selectable"")).get(0).click();","Hey, you can check out the `ClientSelectModal` class I've added. It hides away the ugly CSS selectors in `ClientScopesEvaluateForm` and `CreateClientMappersForm`.I think you wanted something like this, the tests run just fine.",
1562861,k-tamura,https://api.github.com/repos/keycloak/keycloak/pulls/6111,342914277,2019-11-06T04:39:20Z,services/src/main/java/org/keycloak/connections/httpclient/ProxyMappings.java,"@@ -181,6 +209,25 @@ private static HttpHost toProxyHost(String proxyUriString) {       return new HttpHost(uri.getHost(), uri.getPort(), uri.getScheme());     } +    private static String[] toProxyCredentials(String proxyUriString) {++      if (NO_PROXY.equals(proxyUriString)) {+        return null;+      }++      URI uri = URI.create(proxyUriString);+      String userInfo = uri.getUserInfo();+      String[] proxyCredentials = null;+      if (userInfo != null) {+        if(userInfo.indexOf("":"") > 0){+          proxyCredentials = userInfo.split("":"");",Thank you. I will add the `limit` parameter.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6400,343493670,2019-11-07T06:31:31Z,adapters/oidc/js/src/main/resources/keycloak.d.ts,"@@ -37,6 +37,33 @@ declare namespace Keycloak { 	type KeycloakPromiseType = 'legacy' | 'native'; 	type KeycloakPkceMethod = 'S256'; +	interface KeycloakCredentials {+		/**+		 * Secret or Signed JWT.+		 */+		secret: string;+	}++	interface KeycloakConfig {+		/**+		 * URL to the Keycloak server, for example: http://keycloak-server/auth+		 */+		url?: string;+		/**+		 * Name of the realm, for example: 'myrealm'+		 */+		realm: string;+		/**+		 * Client identifier, example: 'myapp'+		 */+		clientId: string;+		/**+		 * The credentials object contains the secret property that should be used+		 * depending on which flow and access type was chosen.+		 */+		credentials?: KeycloakCredentials;","@jonkoops this discussion is probably out of scope for this PR, but it seems useless to me. I will start a thread in dev ML.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6427,343648473,2019-11-07T13:28:34Z,GOVERNANCE.md,"@@ -0,0 +1,110 @@+# Keycloak Governance++* [Vision](#vision) +* [Maintainers](#maintainers) +* [Contributing](#contributing)++## Vision++Keycloak aims to be easy to use and lightweight. The project was founded to make it easy for application developers +to secure modern applications and services.++The 80/20 rule, that states 80% of requirements come from around 20% of use cases, is a core part of the vision behind +Keycloak. We strongly believe if Keycloak would support all use cases by default it would become bloated and hard to use.++Keycloak aims to be opinionated and make it as easy as possible to achieve the common use cases, while still+enabling the less common use cases through custom extensions.+++## Projects++Keycloak consists of several projects:++* [Keycloak](https://github.com/keycloak/keycloak) - Keycloak Server and Java adapters+* [Keycloak Documentation](https://github.com/keycloak/keycloak-documentation) - Documentation for Keycloak+* [Keycloak QuickStarts](https://github.com/keycloak/keycloak-quickstarts) - QuickStarts for getting started with Keycloak+* [Keycloak Containers](https://github.com/keycloak/keycloak-containers) - Container images for Keycloak+* [Keycloak Gatekeeper](https://github.com/keycloak/keycloak-gatekeeper) - Proxy service to secure apps and services with Keycloak+* [Keycloak Node.js Connect](https://github.com/keycloak/keycloak-nodejs-connect) - Node.js adapter for Keycloak+* [Keycloak Node.js Admin Client](https://github.com/keycloak/keycloak-nodejs-admin-client) - Node.js library for Keycloak Admin REST API++The same governance model applies to all projects. However, the list of maintainers may vary per project. +++## Maintainers++The list of maintainers can be found in the [MAINTAINERS.md](MAINTAINERS.md) file in the repository for the individual +projects listed in the [Projects](#projects) section.++### Maintainer Responsibilities++A maintainer is someone who has shown deep knowledge of vision, features and codebase. It is their +responsibility to drive the project forward, encourage collaboration and contributions, and generally help the +community.++Responsibilities of a maintainer include, but are not limited to:++* Engage in design discussions+* Actively monitor mailing lists, user forum and chat+* Contribute high quality code+* Maintain deep knowledge of vision, features and codebase+* Review pull requests either personally or delegate to experts in the relevant area+* Helping the community++### Becoming a Maintainer++To become a maintainer, you need to demonstrate the following:++* Good understanding of vision, features and codebase+* Contribution of larger features+* Contribution of bug fixes+* Participation in design discussions+* Participation in pull request reviews+* Ability to collaborate with the team+* Helping the community++A new maintainer must be proposed by sending an email to the [developer mailing list](https://lists.jboss.org/mailman/listinfo/keycloak-dev).+The email should include evidence of the above list.++The existing maintainers will then discuss the proposal. If anyone objects or wants more information, the maintainers +will reach out to the nominee directly for further discussion. ++For the nominee to be accepted as a maintainer at least 2/3 of existing maintainers have to approve the nominee.+++### Changes in Maintainership","@stianst thinking for a bit, maybe would be nice to add some criteria to these changes? We know what's required to do to become a maintainer, but not the criteria to be removed.So, for example, something like:```Maintainers can be removed if at least 2/3 of existing maintainers agree. Based on the following criteria:* Lack of activity on after X months after a warning from one of the maintainers: PR reviews, design discussions or mailing list* Lack of interactivity with the community* Not following the code of conduct (if we have some)The person requesting the removal of the maintainer should present evidence and arguments on why that person should be removed privately.```The items below are just examples and ideas to align the expectations around this.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6446,343808124,2019-11-07T18:35:31Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/AppInitiatedActionRoleTest.java,"@@ -1,62 +0,0 @@-/*- * Copyright 2019 Red Hat, Inc. and/or its affiliates- * and other contributors as indicated by the @author tags.- *- * Licensed under the Apache License, Version 2.0 (the ""License"");- * you may not use this file except in compliance with the License.- * You may obtain a copy of the License at- *- * http://www.apache.org/licenses/LICENSE-2.0- *- * Unless required by applicable law or agreed to in writing, software- * distributed under the License is distributed on an ""AS IS"" BASIS,- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.- * See the License for the specific language governing permissions and- * limitations under the License.- */-package org.keycloak.testsuite.actions;--import java.util.List;-import org.jboss.arquillian.graphene.page.Page;-import org.junit.Test;-import org.keycloak.models.AccountRoles;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RoleRepresentation;-import org.keycloak.testsuite.pages.ErrorPage;--/**- *- * @author Stan Silvert- */-public class AppInitiatedActionRoleTest extends AbstractAppInitiatedActionTest {-    -    @Page-    protected ErrorPage errorPage;-    -    public AppInitiatedActionRoleTest() {-        super(""update_profile"");-    }-    -    @Override-    public void configureTestRealm(RealmRepresentation testRealm) {-        List<RoleRepresentation> roleList = testRealm.getRoles().getClient().get(""test-app"");-        -        RoleRepresentation manageAccountRole = null;-        for (RoleRepresentation role : roleList) {-            if (role.getName().equals(AccountRoles.MANAGE_ACCOUNT)) {-                manageAccountRole = role;-                break;-            }-        }-        -        roleList.remove(manageAccountRole);-    }-    -    @Test-    public void roleNotSetTest() {",Not sure why this was removed.  Is it no longer a valid test?,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6427,344008807,2019-11-08T06:52:14Z,GOVERNANCE.md,"@@ -0,0 +1,110 @@+# Keycloak Governance++* [Vision](#vision) +* [Maintainers](#maintainers) +* [Contributing](#contributing)++## Vision++Keycloak aims to be easy to use and lightweight. The project was founded to make it easy for application developers +to secure modern applications and services.++The 80/20 rule, that states 80% of requirements come from around 20% of use cases, is a core part of the vision behind +Keycloak. We strongly believe if Keycloak would support all use cases by default it would become bloated and hard to use.++Keycloak aims to be opinionated and make it as easy as possible to achieve the common use cases, while still+enabling the less common use cases through custom extensions.+++## Projects++Keycloak consists of several projects:++* [Keycloak](https://github.com/keycloak/keycloak) - Keycloak Server and Java adapters+* [Keycloak Documentation](https://github.com/keycloak/keycloak-documentation) - Documentation for Keycloak+* [Keycloak QuickStarts](https://github.com/keycloak/keycloak-quickstarts) - QuickStarts for getting started with Keycloak+* [Keycloak Containers](https://github.com/keycloak/keycloak-containers) - Container images for Keycloak+* [Keycloak Gatekeeper](https://github.com/keycloak/keycloak-gatekeeper) - Proxy service to secure apps and services with Keycloak+* [Keycloak Node.js Connect](https://github.com/keycloak/keycloak-nodejs-connect) - Node.js adapter for Keycloak+* [Keycloak Node.js Admin Client](https://github.com/keycloak/keycloak-nodejs-admin-client) - Node.js library for Keycloak Admin REST API++The same governance model applies to all projects. However, the list of maintainers may vary per project. +++## Maintainers++The list of maintainers can be found in the [MAINTAINERS.md](MAINTAINERS.md) file in the repository for the individual +projects listed in the [Projects](#projects) section.++### Maintainer Responsibilities++A maintainer is someone who has shown deep knowledge of vision, features and codebase. It is their +responsibility to drive the project forward, encourage collaboration and contributions, and generally help the +community.++Responsibilities of a maintainer include, but are not limited to:++* Engage in design discussions+* Actively monitor mailing lists, user forum and chat+* Contribute high quality code+* Maintain deep knowledge of vision, features and codebase+* Review pull requests either personally or delegate to experts in the relevant area+* Helping the community++### Becoming a Maintainer++To become a maintainer, you need to demonstrate the following:++* Good understanding of vision, features and codebase+* Contribution of larger features+* Contribution of bug fixes+* Participation in design discussions+* Participation in pull request reviews+* Ability to collaborate with the team+* Helping the community++A new maintainer must be proposed by sending an email to the [developer mailing list](https://lists.jboss.org/mailman/listinfo/keycloak-dev).+The email should include evidence of the above list.++The existing maintainers will then discuss the proposal. If anyone objects or wants more information, the maintainers +will reach out to the nominee directly for further discussion. ++For the nominee to be accepted as a maintainer at least 2/3 of existing maintainers have to approve the nominee.+++### Changes in Maintainership","I'd rather just leave it at the discretion of the maintainers on what conditions a maintainer would be removed for. Could potentially add something along the lines of ""If there are any concerns about a maintainer contact the project lead. The project lead will then discuss the matter with the maintainer. If any issues can not be resolved the maintainer would be removed if at least 2/3 of existing maintainers agree.""",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6382,344650340,2019-11-11T10:38:08Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -464,6 +450,66 @@ private UserConsentModel createConsent(ClientModel client, ConsentRepresentation         return consent;     } +    @Path(""/applications"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response applications() {+        checkAccountApiEnabled();+        auth.require(AccountRoles.VIEW_APPLICATIONS);++        List<String> activeClients = new LinkedList<String>();+        List<UserSessionModel> sessions = session.sessions().getUserSessions(realm, user);+        for (UserSessionModel s : sessions) {+            activeClients.addAll(s.getAuthenticatedClientSessions().keySet());+        }++        List<ClientRepresentation> apps = new LinkedList<>();+        for (ClientModel client : realm.getClients()) {","I'm concerned with performance of realm.getClients if there are thousands of clients. We have an open PR for pagination of clients in admin console for this reason.Ideal would be to add a query to obtain clients that should be advertised to a users in account console. The applications should be clients that:* Are not bearer-only* Have baseUrl set* Have the option ""always show in account console"" enabled. This was discussed on the ML as the simplest way to have an option for admins to decide if a client should be advertised or not in the account console. Alternative of displaying only clients where a user has at least one client role would be too expensive and complex, so we should just do a simple option instead to explicitly advertise clients not current in-use",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6459,345191999,2019-11-12T13:03:35Z,model/jpa/src/main/resources/META-INF/jpa-changelog-8.0.0.xml,"@@ -0,0 +1,205 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2018 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->+<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">+",Please verify this changeset works well with a different database schema,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6452,345319354,2019-11-12T16:45:32Z,services/src/main/java/org/keycloak/crypto/ServerECDSASignatureSignerContext.java,"@@ -0,0 +1,66 @@+package org.keycloak.crypto;++import org.bouncycastle.asn1.ASN1InputStream;+import org.bouncycastle.asn1.ASN1Integer;+import org.bouncycastle.asn1.ASN1Primitive;+import org.bouncycastle.asn1.ASN1Sequence;+import org.bouncycastle.asn1.x9.X9IntegerConverter;+import org.keycloak.models.KeycloakSession;++import java.io.IOException;+import java.security.PrivateKey;+import java.security.Signature;++public class ServerECDSASignatureSignerContext extends AsymmetricSignatureSignerContext {++    public ServerECDSASignatureSignerContext(KeycloakSession session, String algorithm) throws SignatureException {+        super(getKey(session, algorithm));+    }++    public ServerECDSASignatureSignerContext(KeyWrapper key) {+        super(key);+    }++    private static KeyWrapper getKey(KeycloakSession session, String algorithm) {+        KeyWrapper key = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.SIG, algorithm);+        if (key == null) {+            throw new SignatureException(""Active key for "" + algorithm + "" not found"");+        }+        return key;+    }++    @Override+    public byte[] sign(byte[] data) throws SignatureException {+        try {","Could the method body be replaced with ```javaint size = ECDSASignatureProvider.ECDSA.valueOf(getAlgorithm()).getSignatureLength();return asn1DERToConcatenatedRS(super.sign(data), size);```?",
28739,wadahiro,https://api.github.com/repos/keycloak/keycloak/pulls/6478,345587595,2019-11-13T06:28:08Z,themes/src/main/resources-community/theme/base/account/messages/messages_ja.properties,"@@ -255,3 +263,99 @@ allApps= internalApps= thirdpartyApps= appResults=++# Linked account+authorizedProvider=+authorizedProviderMessage=+identityProvider=+identityProviderMessage=+socialLogin=+userDefined=+removeAccess=+removeAccessMessage=++#Authenticator+authenticatorStatusMessage=2+authenticatorFinishSetUpTitle=2+authenticatorFinishSetUpMessage=Keycloak2+authenticatorSubTitle=2+authenticatorSubMessage=21+authenticatorMobileTitle=+authenticatorMobileMessage=2+authenticatorMobileFinishSetUpMessage=+authenticatorActionSetup=+authenticatorSMSTitle=SMS+authenticatorSMSMessage=Keycloak2+authenticatorSMSFinishSetUpMessage=+authenticatorDefaultStatus=+authenticatorChangePhone=+authenticatorBackupCodesTitle=+authenticatorBackupCodesMessage=8+authenticatorBackupCodesFinishSetUpMessage=12++#Authenticator - Mobile Authenticator setup+authenticatorMobileSetupTitle=+smscodeIntroMessage=+mobileSetupStep1=+mobileSetupStep2=+mobileSetupStep3=+scanBarCode=+enterBarCode=+doCopy=+doFinish=++#Authenticator - SMS Code setup+authenticatorSMSCodeSetupTitle=SMS+smscodeIntroMessage=",@k-tamura This is duplicate message. The message was removed from English resource.https://github.com/keycloak/keycloak/commit/f35d3a8ec9a0c404d6e92c19babc520843ead368#diff-212b66440fb033927a3a24caf41983c9L308,X
28739,wadahiro,https://api.github.com/repos/keycloak/keycloak/pulls/6478,345589365,2019-11-13T06:35:54Z,themes/src/main/resources-community/theme/base/account/messages/messages_ja.properties,"@@ -255,3 +263,99 @@ allApps= internalApps= thirdpartyApps= appResults=++# Linked account+authorizedProvider=+authorizedProviderMessage=+identityProvider=+identityProviderMessage=+socialLogin=+userDefined=+removeAccess=+removeAccessMessage=++#Authenticator+authenticatorStatusMessage=2+authenticatorFinishSetUpTitle=2+authenticatorFinishSetUpMessage=Keycloak2+authenticatorSubTitle=2+authenticatorSubMessage=21+authenticatorMobileTitle=+authenticatorMobileMessage=2+authenticatorMobileFinishSetUpMessage=+authenticatorActionSetup=+authenticatorSMSTitle=SMS+authenticatorSMSMessage=Keycloak2+authenticatorSMSFinishSetUpMessage=+authenticatorDefaultStatus=+authenticatorChangePhone=+authenticatorBackupCodesTitle=+authenticatorBackupCodesMessage=8+authenticatorBackupCodesFinishSetUpMessage=12++#Authenticator - Mobile Authenticator setup+authenticatorMobileSetupTitle=+smscodeIntroMessage=+mobileSetupStep1=+mobileSetupStep2=+mobileSetupStep3=+scanBarCode=+enterBarCode=+doCopy=+doFinish=++#Authenticator - SMS Code setup+authenticatorSMSCodeSetupTitle=SMS+smscodeIntroMessage=+chooseYourCountry=+enterYourPhoneNumber=+sendVerficationCode=+enterYourVerficationCode=++#Authenticator - backup Code setup+authenticatorBackupCodesSetupTitle=+backupcodesIntroMessage=+realmName=+doDownload=+doPrint=+doCopy=+backupCodesTips-1=1+backupCodesTips-2=+generateNewBackupCodes=+backupCodesTips-3=+backtoAuthenticatorPage=+++#Resources+resources=+myResources=",@k-tamura This is duplicate message. The message was removed from English resource.https://github.com/keycloak/keycloak/commit/f35d3a8ec9a0c404d6e92c19babc520843ead368#diff-212b66440fb033927a3a24caf41983c9L330,X
28739,wadahiro,https://api.github.com/repos/keycloak/keycloak/pulls/6478,345590028,2019-11-13T06:38:51Z,themes/src/main/resources-community/theme/base/account/messages/messages_ja.properties,"@@ -255,3 +263,99 @@ allApps= internalApps= thirdpartyApps= appResults=++# Linked account+authorizedProvider=+authorizedProviderMessage=+identityProvider=+identityProviderMessage=+socialLogin=+userDefined=+removeAccess=+removeAccessMessage=++#Authenticator+authenticatorStatusMessage=2+authenticatorFinishSetUpTitle=2+authenticatorFinishSetUpMessage=Keycloak2+authenticatorSubTitle=2+authenticatorSubMessage=21+authenticatorMobileTitle=+authenticatorMobileMessage=2+authenticatorMobileFinishSetUpMessage=+authenticatorActionSetup=+authenticatorSMSTitle=SMS+authenticatorSMSMessage=Keycloak2+authenticatorSMSFinishSetUpMessage=+authenticatorDefaultStatus=+authenticatorChangePhone=+authenticatorBackupCodesTitle=+authenticatorBackupCodesMessage=8+authenticatorBackupCodesFinishSetUpMessage=12++#Authenticator - Mobile Authenticator setup+authenticatorMobileSetupTitle=+smscodeIntroMessage=+mobileSetupStep1=+mobileSetupStep2=+mobileSetupStep3=+scanBarCode=+enterBarCode=+doCopy=+doFinish=++#Authenticator - SMS Code setup+authenticatorSMSCodeSetupTitle=SMS+smscodeIntroMessage=+chooseYourCountry=+enterYourPhoneNumber=+sendVerficationCode=+enterYourVerficationCode=++#Authenticator - backup Code setup+authenticatorBackupCodesSetupTitle=+backupcodesIntroMessage=+realmName=+doDownload=+doPrint=+doCopy=+backupCodesTips-1=1+backupCodesTips-2=+generateNewBackupCodes=+backupCodesTips-3=+backtoAuthenticatorPage=+++#Resources+resources=+myResources=+sharedwithMe=+share=+resource=+application=+date=",@k-tamura This is duplicate message. The message was removed from English resource.https://github.com/keycloak/keycloak/commit/f35d3a8ec9a0c404d6e92c19babc520843ead368#diff-212b66440fb033927a3a24caf41983c9L333-L335,X
28739,wadahiro,https://api.github.com/repos/keycloak/keycloak/pulls/6478,345590101,2019-11-13T06:39:11Z,themes/src/main/resources-community/theme/base/account/messages/messages_ja.properties,"@@ -255,3 +263,99 @@ allApps= internalApps= thirdpartyApps= appResults=++# Linked account+authorizedProvider=+authorizedProviderMessage=+identityProvider=+identityProviderMessage=+socialLogin=+userDefined=+removeAccess=+removeAccessMessage=++#Authenticator+authenticatorStatusMessage=2+authenticatorFinishSetUpTitle=2+authenticatorFinishSetUpMessage=Keycloak2+authenticatorSubTitle=2+authenticatorSubMessage=21+authenticatorMobileTitle=+authenticatorMobileMessage=2+authenticatorMobileFinishSetUpMessage=+authenticatorActionSetup=+authenticatorSMSTitle=SMS+authenticatorSMSMessage=Keycloak2+authenticatorSMSFinishSetUpMessage=+authenticatorDefaultStatus=+authenticatorChangePhone=+authenticatorBackupCodesTitle=+authenticatorBackupCodesMessage=8+authenticatorBackupCodesFinishSetUpMessage=12++#Authenticator - Mobile Authenticator setup+authenticatorMobileSetupTitle=+smscodeIntroMessage=+mobileSetupStep1=+mobileSetupStep2=+mobileSetupStep3=+scanBarCode=+enterBarCode=+doCopy=+doFinish=++#Authenticator - SMS Code setup+authenticatorSMSCodeSetupTitle=SMS+smscodeIntroMessage=+chooseYourCountry=+enterYourPhoneNumber=+sendVerficationCode=+enterYourVerficationCode=++#Authenticator - backup Code setup+authenticatorBackupCodesSetupTitle=+backupcodesIntroMessage=+realmName=+doDownload=+doPrint=+doCopy=+backupCodesTips-1=1+backupCodesTips-2=+generateNewBackupCodes=+backupCodesTips-3=+backtoAuthenticatorPage=+++#Resources+resources=+myResources=+sharedwithMe=+share=+resource=+application=+date=+sharedwith=+owner=",@k-tamura This is duplicate message. The message was removed from English resource.https://github.com/keycloak/keycloak/commit/f35d3a8ec9a0c404d6e92c19babc520843ead368#diff-212b66440fb033927a3a24caf41983c9L337,X
28739,wadahiro,https://api.github.com/repos/keycloak/keycloak/pulls/6478,345590301,2019-11-13T06:40:09Z,themes/src/main/resources-community/theme/base/account/messages/messages_ja.properties,"@@ -255,3 +263,99 @@ allApps= internalApps= thirdpartyApps= appResults=++# Linked account+authorizedProvider=+authorizedProviderMessage=+identityProvider=+identityProviderMessage=+socialLogin=+userDefined=+removeAccess=+removeAccessMessage=++#Authenticator+authenticatorStatusMessage=2+authenticatorFinishSetUpTitle=2+authenticatorFinishSetUpMessage=Keycloak2+authenticatorSubTitle=2+authenticatorSubMessage=21+authenticatorMobileTitle=+authenticatorMobileMessage=2+authenticatorMobileFinishSetUpMessage=+authenticatorActionSetup=+authenticatorSMSTitle=SMS+authenticatorSMSMessage=Keycloak2+authenticatorSMSFinishSetUpMessage=+authenticatorDefaultStatus=+authenticatorChangePhone=+authenticatorBackupCodesTitle=+authenticatorBackupCodesMessage=8+authenticatorBackupCodesFinishSetUpMessage=12++#Authenticator - Mobile Authenticator setup+authenticatorMobileSetupTitle=+smscodeIntroMessage=+mobileSetupStep1=+mobileSetupStep2=+mobileSetupStep3=+scanBarCode=+enterBarCode=+doCopy=+doFinish=++#Authenticator - SMS Code setup+authenticatorSMSCodeSetupTitle=SMS+smscodeIntroMessage=+chooseYourCountry=+enterYourPhoneNumber=+sendVerficationCode=+enterYourVerficationCode=++#Authenticator - backup Code setup+authenticatorBackupCodesSetupTitle=+backupcodesIntroMessage=+realmName=+doDownload=+doPrint=+doCopy=+backupCodesTips-1=1+backupCodesTips-2=+generateNewBackupCodes=+backupCodesTips-3=+backtoAuthenticatorPage=+++#Resources+resources=+myResources=+sharedwithMe=+share=+resource=+application=+date=+sharedwith=+owner=+accessPermissions=+permissionRequests=+approve=+approveAll=+sharedwith=",@k-tamura This is duplicate message. The message was removed from English resource.https://github.com/keycloak/keycloak/commit/f35d3a8ec9a0c404d6e92c19babc520843ead368#diff-212b66440fb033927a3a24caf41983c9L342,X
28739,wadahiro,https://api.github.com/repos/keycloak/keycloak/pulls/6478,345599536,2019-11-13T07:17:16Z,themes/src/main/resources-community/theme/base/admin/messages/admin-messages_ja.properties,"@@ -310,6 +337,14 @@ web-origins=Web  web-origins.tooltip= CORS  URI  +  *  fine-oidc-endpoint-conf=OpenID Connect  fine-oidc-endpoint-conf.tooltip=OpenID Connect +access-token-signed-response-alg=+access-token-signed-response-alg.tooltip=JWA+id-token-signed-response-alg=ID+id-token-signed-response-alg.tooltip=IDJWA+id-token-encrypted-response-alg=ID+id-token-encrypted-response-alg.tooltip=IDJWAIDID+id-token-encrypted-response-enc=ID+id-token-encrypted-response-enc.tooltip=id-token-encrypted-response-enc.tooltip=IDJWAIDID",@k-tamura Remove `id-token-encrypted-response-enc.tooltip=` ? It looks like original English message has same issue.https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties#L349,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6468,345628126,2019-11-13T08:41:40Z,server-spi-private/src/main/java/org/keycloak/broker/provider/util/SimpleHttp.java,"@@ -273,6 +274,8 @@ private void readResponse() throws IOException {                 HttpEntity entity = response.getEntity();                 if (entity != null) {                     is = entity.getContent();+                    MediaType mediaType = MediaType.valueOf(entity.getContentType().getValue());","Since this class doesn't rely on JAX-RS I'd prefer it to use httpclient approach. See here https://stackoverflow.com/questions/9112259/obtaining-response-charset-of-response-to-get-or-post-request/34281952#34281952.We also need to add some test to make sure this actually fixes the issue and that there is no regression in the future. It'd be hard to write a proper integration test around this, so a unit test for SimpleHttp would be sufficient.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6459,345698731,2019-11-13T11:07:59Z,model/jpa/src/main/resources/META-INF/jpa-changelog-8.0.0.xml,"@@ -0,0 +1,205 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2018 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->+<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">+","Verified. It is fine and migration from 1.9.8.Final still works (however I needed to comment some failing migration test, which is failing independently of this issue - https://issues.jboss.org/browse/KEYCLOAK-11635 )",
577872,Pastor,https://api.github.com/repos/keycloak/keycloak/pulls/6468,345920837,2019-11-13T18:18:49Z,server-spi-private/src/main/java/org/keycloak/broker/provider/util/SimpleHttp.java,"@@ -273,6 +274,8 @@ private void readResponse() throws IOException {                 HttpEntity entity = response.getEntity();                 if (entity != null) {                     is = entity.getContent();+                    MediaType mediaType = MediaType.valueOf(entity.getContentType().getValue());","> Since this class doesn't rely on JAX-RS I'd prefer it to use httpclient approach. See here https://stackoverflow.com/questions/9112259/obtaining-response-charset-of-response-to-get-or-post-request/34281952#34281952.Thank. Looks pretty.> We also need to add some test to make sure this actually fixes the issue and that there is no regression in the future. It'd be hard to write a proper integration test around this, so a unit test for SimpleHttp would be sufficient.Done.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6499,347769886,2019-11-19T07:45:57Z,wildfly/extensions/src/main/java/org/keycloak/provider/wildfly/JsonConfigProviderFactory.java,"@@ -0,0 +1,30 @@+/*",Remove this. We haven't supported keycloak-server.json in the WF distribution for a very long time.,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6499,347769965,2019-11-19T07:46:10Z,wildfly/extensions/src/main/resources/META-INF/services/org.keycloak.config.ConfigProviderFactory,"@@ -0,0 +1,19 @@+#+# Copyright 2019 Red Hat, Inc. and/or its affiliates+# and other contributors as indicated by the @author tags.+#+# Licensed under the Apache License, Version 2.0 (the ""License"");+# you may not use this file except in compliance with the License.+# You may obtain a copy of the License at+#+# http://www.apache.org/licenses/LICENSE-2.0+#+# Unless required by applicable law or agreed to in writing, software+# distributed under the License is distributed on an ""AS IS"" BASIS,+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+# See the License for the specific language governing permissions and+# limitations under the License.+#++org.keycloak.provider.wildfly.JsonConfigProviderFactory",Remove JsonConfigProviderFactory we haven't supported keycloak-server.json in WildFly for a very very long time,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6501,347928347,2019-11-19T13:42:45Z,themes/src/main/resources/theme/keycloak-preview/account/index.ftl,"@@ -86,7 +86,11 @@     <body>          <script>-            var keycloak = Keycloak('${authUrl}/realms/${realm.name}/account/keycloak.json');+            var keycloak = Keycloak({","A question here.  Long ago we decided to download keycloak.json.  Here, the config is hard-coded.  Is this what we want long term?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6382,348401156,2019-11-20T10:25:22Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -469,6 +456,65 @@ public LinkedAccountsResource linkedAccounts() {         return new LinkedAccountsResource(session, request, client, auth, event, user);     } +    @Path(""/applications"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response applications() {+        checkAccountApiEnabled();+        auth.requireOneOf(AccountRoles.VIEW_APPLICATIONS, AccountRoles.VIEW_PROFILE);++        List<String> inUseClients = getInUseClients();++        List<ClientRepresentation> apps = new LinkedList<>();+        for (ClientModel client : realm.getClients()) {+            if (client.isBearerOnly() || client.getBaseUrl() == null) {+                continue;+            }+            apps.add(modelToRepresentation(client, false, false, inUseClients));+        }++        for (ClientModel client : new UserSessionManager(session).findClientsWithOfflineToken(realm, user)) {+            apps.add(modelToRepresentation(client, false, true, inUseClients));+        }++        for (UserConsentModel consent : session.users().getConsents(realm, user.getId())) {+            ClientModel client = consent.getClient();++            if (!new StorageId(client.getId()).isLocal()) {+                apps.add(modelToRepresentation(client, true, false, inUseClients));+            }+        }","I believe the current approach is not correct (but maybe I'm wrong ;)).1. `realm.getClients()` returns all clients in a realm, so we cannot do this:https://github.com/keycloak/keycloak/blob/00f7faf2151eb64b5e158c35922a707203875832/services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java#L474We're basically setting `userConsentRequired` and `offlineAccess` to false for all clients.1. We're adding some of the clients to the list again here:https://github.com/keycloak/keycloak/blob/00f7faf2151eb64b5e158c35922a707203875832/services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java#L478and here:https://github.com/keycloak/keycloak/blob/00f7faf2151eb64b5e158c35922a707203875832/services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java#L485If I'm correct, this means some of the clients will be returned twice or even three times.1. What about the clients that have both `userConsentRequired` and `offlineAccess`? I believe we don't cover this scenario?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6511,348663106,2019-11-20T18:06:28Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/LoginTotpPage.java,"@@ -34,7 +34,7 @@     @FindBy(css = ""input[type=\""submit\""]"")     private WebElement submitButton; -    @FindBy(id = ""kc-cancel"")+    @FindBy(id = ""kc-back"")","There is already button ""back"" defined on some superclass of LoginTotpPage. So insdtead of rename to ""kc-back"", it will be good to remove this element from the page entirely, also remove the method ""cancel"" from the LoginTotpPage class and update (or eventually remove) the tests, which depends on the cancel button.",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6382,349468448,2019-11-22T07:57:34Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -469,6 +447,41 @@ public LinkedAccountsResource linkedAccounts() {         return new LinkedAccountsResource(session, request, client, auth, event, user);     } +    @Path(""/applications"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response applications() {+        checkAccountApiEnabled();+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE, AccountRoles.VIEW_APPLICATIONS);++        List<ClientRepresentation> apps = new LinkedList<>();+        for (ClientModel client : realm.getClients()) {+            if (client.isBearerOnly() || client.getBaseUrl() == null) {+                continue;+            }+            apps.add(modelToRepresentation(client));+        }++        return Cors.add(request, Response.ok(apps)).auth().allowedOrigins(auth.getToken()).build();+    }++    private ClientRepresentation modelToRepresentation(ClientModel client) {+        ClientRepresentation clientRep = new ClientRepresentation();",This will be very inefficient. Sessions lists are not cached and here you're fetching all sessions for the users for each client.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6382,349469798,2019-11-22T08:02:13Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -464,6 +450,66 @@ private UserConsentModel createConsent(ClientModel client, ConsentRepresentation         return consent;     } +    @Path(""/applications"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response applications() {+        checkAccountApiEnabled();+        auth.require(AccountRoles.VIEW_APPLICATIONS);++        List<String> activeClients = new LinkedList<String>();+        List<UserSessionModel> sessions = session.sessions().getUserSessions(realm, user);+        for (UserSessionModel s : sessions) {+            activeClients.addAll(s.getAuthenticatedClientSessions().keySet());+        }++        List<ClientRepresentation> apps = new LinkedList<>();+        for (ClientModel client : realm.getClients()) {","This needs to be changed as it won't scale and also will display many clients we don't want to display.The logic should probably be something like:* Fetch sessions - build a list of clients from sessions* Fetch persisted user consents - build a list of clients from persisted consents combining with above* Fetch clients with ""always show in account console"" - combine with above",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6330,349473838,2019-11-22T08:16:17Z,services/src/main/java/org/keycloak/authentication/authenticators/x509/CertificateValidator.java,"@@ -468,6 +469,22 @@ public CertificateValidator validateExtendedKeyUsage() throws GeneralSecurityExc         return this;     } +    public CertificateValidator validateTimestamps(boolean isValidationEnabled) throws GeneralSecurityException {",Should we not validate the not-before and not-after on all certs in the chain rather than just the last one?,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6344,349477864,2019-11-22T08:27:19Z,services/pom.xml,"@@ -32,6 +32,8 @@      <properties>         <version.swagger.doclet>1.1.2</version.swagger.doclet>+        <mockito.version>1.9.5</mockito.version>",Please don't introduce new testing tools and rather write tests consistently with existing tests. See https://github.com/keycloak/keycloak/blob/master/CONTRIBUTING.md#testing.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6320,349574152,2019-11-22T12:32:15Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmAdapter.java,"@@ -722,6 +721,21 @@ public ClientModel getClientByClientId(String clientId) {         return cacheSession.getClientByClientId(clientId, this);     } +    @Override+    public List<ClientModel> searchClientByClientId(String clientId, Integer firstResult, Integer maxResults) {",+1 to renaming to searchClientsByClientId,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6396,349643485,2019-11-22T15:10:34Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/HardcodedAttributeMapper.java,"@@ -0,0 +1,228 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++ package org.keycloak.storage.ldap.mappers;++import java.lang.reflect.Method;+import java.util.Arrays;+import java.util.HashMap;+import java.util.List;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.ModelException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.UserModelDelegate;+import org.keycloak.models.utils.reflection.Property;+import org.keycloak.models.utils.reflection.PropertyCriteria;+import org.keycloak.models.utils.reflection.PropertyQueries;+import org.keycloak.storage.ldap.LDAPStorageProvider;+import org.keycloak.storage.ldap.idm.model.LDAPObject;+import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;+++public class HardcodedAttributeMapper extends AbstractLDAPStorageMapper {++    private static final Logger logger = Logger.getLogger(HardcodedAttributeMapper.class);++    public HardcodedAttributeMapper(ComponentModel mapperModel, LDAPStorageProvider ldapProvider) {+        super(mapperModel, ldapProvider);+    }++    private static final Map<String, Property<Object>> userModelProperties;++    static {+        Map<String, Property<Object>> userModelProps = PropertyQueries.createQuery(UserModel.class)+                .addCriteria(new PropertyCriteria() {++                    @Override+                    public boolean methodMatches(Method m) {+                        if ((m.getName().startsWith(""get"") || m.getName().startsWith(""is""))+                                && m.getParameterTypes().length > 0) {+                            return false;+                        }++                        return true;+                    }++                }).getResultList();++        // Convert to be keyed by lower-cased attribute names+        userModelProperties = new HashMap<>();+        for (Map.Entry<String, Property<Object>> entry : userModelProps.entrySet()) {+            userModelProperties.put(entry.getKey().toLowerCase(), entry.getValue());+        }+    }++    public static final String USER_MODEL_ATTRIBUTE = ""user.model.attribute"";+    public static final String LDAP_ATTRIBUTE = ""ldap.attribute"";+    public static final String ATTRIBUTE_VALUE = ""attribute.value"";+    public static final String READ_ONLY = ""read.only"";",It seems many of those constants are not used in the mapper. Could you please remove unused constants?,X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6396,349645529,2019-11-22T15:14:16Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/HardcodedAttributeMapper.java,"@@ -0,0 +1,228 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++ package org.keycloak.storage.ldap.mappers;++import java.lang.reflect.Method;+import java.util.Arrays;+import java.util.HashMap;+import java.util.List;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.ModelException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.UserModelDelegate;+import org.keycloak.models.utils.reflection.Property;+import org.keycloak.models.utils.reflection.PropertyCriteria;+import org.keycloak.models.utils.reflection.PropertyQueries;+import org.keycloak.storage.ldap.LDAPStorageProvider;+import org.keycloak.storage.ldap.idm.model.LDAPObject;+import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;+++public class HardcodedAttributeMapper extends AbstractLDAPStorageMapper {++    private static final Logger logger = Logger.getLogger(HardcodedAttributeMapper.class);++    public HardcodedAttributeMapper(ComponentModel mapperModel, LDAPStorageProvider ldapProvider) {+        super(mapperModel, ldapProvider);+    }++    private static final Map<String, Property<Object>> userModelProperties;++    static {+        Map<String, Property<Object>> userModelProps = PropertyQueries.createQuery(UserModel.class)","NOTE: It seems that same userModelProps stuff is used in some other mappers (EG. UserAttributeLdapMapper). In that case I suggest to make the field ""userModelProperties"" on UserAttributeLDAPMapper public and reference it from this class to avoid the same static code block duplicated in both classes. Even better could be to move this block to some util class and make both mappers to reference to it, but up to you :)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6396,349646909,2019-11-22T15:17:00Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/HardcodedAttributeMapper.java,"@@ -0,0 +1,228 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++ package org.keycloak.storage.ldap.mappers;++import java.lang.reflect.Method;+import java.util.Arrays;+import java.util.HashMap;+import java.util.List;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.ModelException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.UserModelDelegate;+import org.keycloak.models.utils.reflection.Property;+import org.keycloak.models.utils.reflection.PropertyCriteria;+import org.keycloak.models.utils.reflection.PropertyQueries;+import org.keycloak.storage.ldap.LDAPStorageProvider;+import org.keycloak.storage.ldap.idm.model.LDAPObject;+import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;+++public class HardcodedAttributeMapper extends AbstractLDAPStorageMapper {++    private static final Logger logger = Logger.getLogger(HardcodedAttributeMapper.class);++    public HardcodedAttributeMapper(ComponentModel mapperModel, LDAPStorageProvider ldapProvider) {+        super(mapperModel, ldapProvider);+    }++    private static final Map<String, Property<Object>> userModelProperties;++    static {+        Map<String, Property<Object>> userModelProps = PropertyQueries.createQuery(UserModel.class)+                .addCriteria(new PropertyCriteria() {++                    @Override+                    public boolean methodMatches(Method m) {+                        if ((m.getName().startsWith(""get"") || m.getName().startsWith(""is""))+                                && m.getParameterTypes().length > 0) {+                            return false;+                        }++                        return true;+                    }++                }).getResultList();++        // Convert to be keyed by lower-cased attribute names+        userModelProperties = new HashMap<>();+        for (Map.Entry<String, Property<Object>> entry : userModelProps.entrySet()) {+            userModelProperties.put(entry.getKey().toLowerCase(), entry.getValue());+        }+    }++    public static final String USER_MODEL_ATTRIBUTE = ""user.model.attribute"";+    public static final String LDAP_ATTRIBUTE = ""ldap.attribute"";+    public static final String ATTRIBUTE_VALUE = ""attribute.value"";+    public static final String READ_ONLY = ""read.only"";+    public static final String ALWAYS_READ_VALUE_FROM_LDAP = ""always.read.value.from.ldap"";+    public static final String IS_MANDATORY_IN_LDAP = ""is.mandatory.in.ldap"";+    public static final String IS_BINARY_ATTRIBUTE = ""is.binary.attribute"";++    @Override+    public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) {+        String userModelAttrName = getUserModelAttribute();++        String attributeValue = getAttributeValue();+        Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase());++        if (userModelProperty != null) {+            checkDuplicateEmail(userModelAttrName, attributeValue, realm, ldapProvider.getSession(), user);+            setPropertyOnUserModel(userModelProperty, user, attributeValue);+        } else {+            user.setAttribute(userModelAttrName, Arrays.asList(attributeValue));+        }+    }++    @Override+    public void onRegisterUserToLDAP(LDAPObject ldapUser, UserModel localUser, RealmModel realm) {++    }++    // throw ModelDuplicateException if there is different user in model with same+    // email+    protected void checkDuplicateEmail(String userModelAttrName, String email, RealmModel realm,+            KeycloakSession session, UserModel user) {+        if (email == null || realm.isDuplicateEmailsAllowed())+            return;+        if (UserModel.EMAIL.equalsIgnoreCase(userModelAttrName)) {+            // lowercase before search+            email = KeycloakModelUtils.toLowerCaseSafe(email);++            UserModel that = session.userLocalStorage().getUserByEmail(email, realm);+            if (that != null && !that.getId().equals(user.getId())) {+                session.getTransactionManager().setRollbackOnly();+                String exceptionMessage = String.format(+                        ""Can't import user '%s' from LDAP because email '%s' already exists in Keycloak. Existing user with this email is '%s'"",+                        user.getUsername(), email, that.getUsername());+                throw new ModelDuplicateException(exceptionMessage, UserModel.EMAIL);+            }+        }+    }++    protected void checkDuplicateUsername(String userModelAttrName, String username, RealmModel realm,+            KeycloakSession session, UserModel user) {+        // only if working in USERNAME attribute+        if (UserModel.USERNAME.equalsIgnoreCase(userModelAttrName)) {+            if (username == null || username.isEmpty()) {+                throw new ModelException(""Cannot set an empty username"");+            }++            boolean usernameChanged = !username.equals(user.getUsername());+            if (realm.isEditUsernameAllowed() && usernameChanged) {+                UserModel that = session.users().getUserByUsername(username, realm);+                if (that != null && !that.getId().equals(user.getId())) {+                    throw new ModelDuplicateException(String.format(+                            ""Cannot change the username to '%s' because the username already exists in keycloak"",+                            username), UserModel.USERNAME);+                }+            } else if (usernameChanged) {+                throw new ModelException(+                        ""Cannot change username if the realm is not configured to allow edit the usernames"");+            }+        }+    }++    @Override+    public UserModel proxy(final LDAPObject ldapUser, UserModel delegate, RealmModel realm) {+        String userModelAttrName = getUserModelAttribute();++        String attributeValue = getAttributeValue();+        Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase());++        delegate = new UserModelDelegate(delegate) {++            @Override+            public List<String> getAttribute(String name) {+                if(userModelAttrName.equals(name)){+                    return Arrays.asList(attributeValue);+                }+                return super.getAttribute(name);+            }++            @Override+            public boolean isEmailVerified() {+                if(userModelAttrName.equals(""emailVerified"")){+                    return Boolean.valueOf(attributeValue);+                }+                return super.isEmailVerified();+            }++            @Override+            public boolean isEnabled() {+                if(userModelAttrName.equals(""enabled"")){+                    return Boolean.valueOf(attributeValue);+                }+                return super.isEnabled();+            }+           +       };+       return delegate;+   }++   @Override+   public void beforeLDAPQuery(LDAPQuery query) {+       +   }++   private String getUserModelAttribute() {+       return mapperModel.getConfig().getFirst(USER_MODEL_ATTRIBUTE);+   }++   String getLdapAttributeName() {+       return mapperModel.getConfig().getFirst(LDAP_ATTRIBUTE);+   }++   String getAttributeValue() {+      return mapperModel.getConfig().getFirst(ATTRIBUTE_VALUE);+   }++   private boolean isBinaryAttribute() {","Same apply for those private methods, which are not used anymore. I understand you copied the implementation from some other class, but please cleanup unused stuff.",X
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6396,349649617,2019-11-22T15:22:23Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/HardcodedAttributeMapper.java,"@@ -0,0 +1,228 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++ package org.keycloak.storage.ldap.mappers;++import java.lang.reflect.Method;+import java.util.Arrays;+import java.util.HashMap;+import java.util.List;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.ModelException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.UserModelDelegate;+import org.keycloak.models.utils.reflection.Property;+import org.keycloak.models.utils.reflection.PropertyCriteria;+import org.keycloak.models.utils.reflection.PropertyQueries;+import org.keycloak.storage.ldap.LDAPStorageProvider;+import org.keycloak.storage.ldap.idm.model.LDAPObject;+import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;+++public class HardcodedAttributeMapper extends AbstractLDAPStorageMapper {++    private static final Logger logger = Logger.getLogger(HardcodedAttributeMapper.class);++    public HardcodedAttributeMapper(ComponentModel mapperModel, LDAPStorageProvider ldapProvider) {+        super(mapperModel, ldapProvider);+    }++    private static final Map<String, Property<Object>> userModelProperties;++    static {+        Map<String, Property<Object>> userModelProps = PropertyQueries.createQuery(UserModel.class)+                .addCriteria(new PropertyCriteria() {++                    @Override+                    public boolean methodMatches(Method m) {+                        if ((m.getName().startsWith(""get"") || m.getName().startsWith(""is""))+                                && m.getParameterTypes().length > 0) {+                            return false;+                        }++                        return true;+                    }++                }).getResultList();++        // Convert to be keyed by lower-cased attribute names+        userModelProperties = new HashMap<>();+        for (Map.Entry<String, Property<Object>> entry : userModelProps.entrySet()) {+            userModelProperties.put(entry.getKey().toLowerCase(), entry.getValue());+        }+    }++    public static final String USER_MODEL_ATTRIBUTE = ""user.model.attribute"";+    public static final String LDAP_ATTRIBUTE = ""ldap.attribute"";+    public static final String ATTRIBUTE_VALUE = ""attribute.value"";+    public static final String READ_ONLY = ""read.only"";+    public static final String ALWAYS_READ_VALUE_FROM_LDAP = ""always.read.value.from.ldap"";+    public static final String IS_MANDATORY_IN_LDAP = ""is.mandatory.in.ldap"";+    public static final String IS_BINARY_ATTRIBUTE = ""is.binary.attribute"";++    @Override+    public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) {+        String userModelAttrName = getUserModelAttribute();++        String attributeValue = getAttributeValue();+        Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase());++        if (userModelProperty != null) {+            checkDuplicateEmail(userModelAttrName, attributeValue, realm, ldapProvider.getSession(), user);","Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods ""checkDuplicateEmail"" and ""checkDuplicateUsername"" . And you can instead implement method on the HardcodedAttributeMapperFactory ""validateConfiguration"" and throw an error in case that ""username"" or ""email"" was configured as user model attribute.",X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6513,349990666,2019-11-25T04:56:27Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderTest.java,"@@ -754,18 +754,21 @@ private static AuthenticatedClientSessionModel createClientSession(KeycloakSessi     private static UserSessionModel[] createSessions(KeycloakSession session) {","I think that this class's test method seem to check two types of entities (user session, client session) : * that are still on transactions (InfinispanChangelogBasedTransaction) * that have already committed on the cache (sessionCache, clientSessionCache).You've modified createSessions() such that created sessions are committed on the cache. I'm afraid that it can affect other tests that try to check some entities that are still on transactions.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/6513,349991747,2019-11-25T05:04:05Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderTest.java,"@@ -754,18 +754,21 @@ private static AuthenticatedClientSessionModel createClientSession(KeycloakSessi     private static UserSessionModel[] createSessions(KeycloakSession session) {","Please note that there are two types of method in InfinispanUserSessionProvider.* check entities on transactions at first, if not found, next check on the cache (ex. getUserSession).* check entities only on the cache (ex. getUserSessions)To clarify whether each test method of this class try to check entities on only the cache or not, I think it needs to consider the point above.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6516,350219490,2019-11-25T14:36:40Z,services/src/main/java/org/keycloak/services/resources/account/AccountConsole.java,"@@ -114,6 +114,12 @@ public Response getMainPage() throws IOException, FreeMarkerException {             EventStoreProvider eventStore = session.getProvider(EventStoreProvider.class);             map.put(""isEventsEnabled"", eventStore != null && realm.isEventsEnabled());             map.put(""isAuthorizationEnabled"", true);+            +            boolean isTotpConfigured = false;+            if (user != null) {+                isTotpConfigured = session.userCredentialManager().isConfiguredFor(realm, user, realm.getOTPPolicy().getType());+            }+            map.put(""isTotpConfigured"", isTotpConfigured);","I know this is probably just a temporary workaround but just to be sure... What about other credential types? This is not really scalable...Or is OTP a ""special case"", not a regular credential type?",X
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6382,350254687,2019-11-25T15:32:31Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -324,7 +302,7 @@ private String getTranslationOrDefault(String key) {     @Produces(MediaType.APPLICATION_JSON)     public Response getConsent(final @PathParam(""clientId"") String clientId) {         checkAccountApiEnabled();-        auth.requireOneOf(AccountRoles.VIEW_CONSENT, AccountRoles.MANAGE_CONSENT);+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE, AccountRoles.VIEW_CONSENT, AccountRoles.MANAGE_CONSENT);","@douglaspalmer maybe there was a little confusion about this, but my request was about revoking consents. Please see: https://lists.jboss.org/pipermail/keycloak-dev/2019-November/012827.html",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6516,350324198,2019-11-25T17:33:16Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/signingin-page/SigningInPage.tsx,"@@ -0,0 +1,183 @@+/* + * Copyright 2018 Red Hat, Inc. and/or its affiliates.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++import * as React from 'react';+import * as moment from 'moment';+import {AxiosResponse} from 'axios';++import {withRouter, RouteComponentProps} from 'react-router-dom';+import {+        Button,+        DataList, +        DataListAction,+        DataListItemCells, +        DataListCell,+        DataListItemRow, +        Stack,+        StackItem,+        Switch,+        Title, +        TitleLevel+    } from '@patternfly/react-core';++import {AIACommand} from '../../util/AIACommand';+import {AccountServiceClient} from '../../account-service/account.service';+import {ContinueCancelModal} from '../../widgets/ContinueCancelModal';+import {Features} from '../../widgets/features';+import {Msg} from '../../widgets/Msg';+import {ContentPage} from '../ContentPage';+import {ContentAlert} from '../ContentAlert';++declare const features: Features;++interface PasswordDetails {+    registered: boolean;+    lastUpdate: number;+}+ +interface SigningInPageProps extends RouteComponentProps {+}++interface SigningInPageState {+    twoFactorEnabled: boolean;+    twoFactorEnabledText: string;+    isTotpConfigured: boolean;+    lastPasswordUpdate?: number;+}++/**+ * @author Stan Silvert ssilvert@redhat.com (C) 2018 Red Hat Inc.+ */+class SigningInPage extends React.Component<SigningInPageProps, SigningInPageState> {+    private readonly updatePassword: AIACommand = new AIACommand('UPDATE_PASSWORD', this.props.location.pathname);+    private readonly setUpTOTP: AIACommand = new AIACommand('CONFIGURE_TOTP', this.props.location.pathname);+    +    public constructor(props: SigningInPageProps) {+        super(props);+        this.state = {+            twoFactorEnabled: true,+            twoFactorEnabledText: Msg.localize('twoFactorEnabled'),+            isTotpConfigured: features.isTotpConfigured,+        }+        this.setLastPwdUpdate();+    }++    private setLastPwdUpdate(): void {+        AccountServiceClient.Instance.doGet(""/credentials/password"")+            .then((response: AxiosResponse<PasswordDetails>) => {+                if (response.data.lastUpdate) {+                    const lastUpdate: number = response.data.lastUpdate;+                    this.setState({lastPasswordUpdate: lastUpdate});+                }+            });+    }+    +    private handleTwoFactorSwitch = () => {+        if (this.state.twoFactorEnabled) {+            this.setState({twoFactorEnabled: false, twoFactorEnabledText: Msg.localize('twoFactorDisabled')})+        } else {+            this.setState({twoFactorEnabled: true, twoFactorEnabledText:  Msg.localize('twoFactorEnabled')})+        }+    }++    private handleRemoveTOTP = () => {+      AccountServiceClient.Instance.doDelete(""/totp/remove"")+        .then(() => {+            this.setState({isTotpConfigured: false});+            ContentAlert.success('successTotpRemovedMessage');+        });+    }++    public render(): React.ReactNode {+        let lastPwdUpdate: string = Msg.localize('unknown');+        if (this.state.lastPasswordUpdate) {+            lastPwdUpdate = moment(this.state.lastPasswordUpdate).format('LLL');+        }++        return (+            <ContentPage title=""signingIn"" +                     introMessage=""signingInSubMessage"">+                <Stack gutter='md'>+                    <StackItem isFilled>+                        <Title headingLevel={TitleLevel.h2} size='2xl'>+                        <strong><Msg msgKey='password'/></strong>+                        </Title>+                        <DataList aria-label='foo'>+                            <DataListItemRow>+                                <DataListItemCells+                                    dataListCells={[+                                        <DataListCell key='password'><Msg msgKey='password'/></DataListCell>,+                                        <DataListCell key='lastPwdUpdate'><strong><Msg msgKey='lastUpdate'/>: </strong>{lastPwdUpdate}</DataListCell>,+                                        <DataListCell key='spacer'/>+                                    ]}/>+                                <DataListAction aria-labelledby='foo' aria-label='foo action' id='setPasswordAction'>+                                    <Button variant='primary'onClick={()=> this.updatePassword.execute()}><Msg msgKey='update'/></Button>+                                </DataListAction>+                            </DataListItemRow>","In the case where passwords are not being used, we should not display the Password section at all.If password is optional and has never been set, then I agree it would be better to indicate that.I'll leave it up to Bruno whether he wants to try to implement something along those lines or write a JIRA to take care of it after tech preview.  I'd prefer not to spend lots of time figuring out what to do before tech preview.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6516,350326697,2019-11-25T17:38:36Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/signingin-page/SigningInPage.tsx,"@@ -0,0 +1,183 @@+/* + * Copyright 2018 Red Hat, Inc. and/or its affiliates.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++import * as React from 'react';+import * as moment from 'moment';+import {AxiosResponse} from 'axios';++import {withRouter, RouteComponentProps} from 'react-router-dom';+import {+        Button,+        DataList, +        DataListAction,+        DataListItemCells, +        DataListCell,+        DataListItemRow, +        Stack,+        StackItem,+        Switch,+        Title, +        TitleLevel+    } from '@patternfly/react-core';++import {AIACommand} from '../../util/AIACommand';+import {AccountServiceClient} from '../../account-service/account.service';+import {ContinueCancelModal} from '../../widgets/ContinueCancelModal';+import {Features} from '../../widgets/features';+import {Msg} from '../../widgets/Msg';+import {ContentPage} from '../ContentPage';+import {ContentAlert} from '../ContentAlert';++declare const features: Features;++interface PasswordDetails {+    registered: boolean;+    lastUpdate: number;+}+ +interface SigningInPageProps extends RouteComponentProps {+}++interface SigningInPageState {+    twoFactorEnabled: boolean;+    twoFactorEnabledText: string;+    isTotpConfigured: boolean;+    lastPasswordUpdate?: number;+}++/**+ * @author Stan Silvert ssilvert@redhat.com (C) 2018 Red Hat Inc.+ */+class SigningInPage extends React.Component<SigningInPageProps, SigningInPageState> {+    private readonly updatePassword: AIACommand = new AIACommand('UPDATE_PASSWORD', this.props.location.pathname);+    private readonly setUpTOTP: AIACommand = new AIACommand('CONFIGURE_TOTP', this.props.location.pathname);+    +    public constructor(props: SigningInPageProps) {+        super(props);+        this.state = {+            twoFactorEnabled: true,+            twoFactorEnabledText: Msg.localize('twoFactorEnabled'),+            isTotpConfigured: features.isTotpConfigured,+        }+        this.setLastPwdUpdate();+    }++    private setLastPwdUpdate(): void {+        AccountServiceClient.Instance.doGet(""/credentials/password"")+            .then((response: AxiosResponse<PasswordDetails>) => {+                if (response.data.lastUpdate) {+                    const lastUpdate: number = response.data.lastUpdate;+                    this.setState({lastPasswordUpdate: lastUpdate});+                }+            });+    }+    +    private handleTwoFactorSwitch = () => {+        if (this.state.twoFactorEnabled) {+            this.setState({twoFactorEnabled: false, twoFactorEnabledText: Msg.localize('twoFactorDisabled')})+        } else {+            this.setState({twoFactorEnabled: true, twoFactorEnabledText:  Msg.localize('twoFactorEnabled')})+        }+    }++    private handleRemoveTOTP = () => {+      AccountServiceClient.Instance.doDelete(""/totp/remove"")+        .then(() => {+            this.setState({isTotpConfigured: false});+            ContentAlert.success('successTotpRemovedMessage');+        });+    }++    public render(): React.ReactNode {+        let lastPwdUpdate: string = Msg.localize('unknown');+        if (this.state.lastPasswordUpdate) {+            lastPwdUpdate = moment(this.state.lastPasswordUpdate).format('LLL');+        }++        return (+            <ContentPage title=""signingIn"" +                     introMessage=""signingInSubMessage"">+                <Stack gutter='md'>+                    <StackItem isFilled>+                        <Title headingLevel={TitleLevel.h2} size='2xl'>+                        <strong><Msg msgKey='password'/></strong>+                        </Title>+                        <DataList aria-label='foo'>+                            <DataListItemRow>+                                <DataListItemCells+                                    dataListCells={[+                                        <DataListCell key='password'><Msg msgKey='password'/></DataListCell>,+                                        <DataListCell key='lastPwdUpdate'><strong><Msg msgKey='lastUpdate'/>: </strong>{lastPwdUpdate}</DataListCell>,+                                        <DataListCell key='spacer'/>+                                    ]}/>+                                <DataListAction aria-labelledby='foo' aria-label='foo action' id='setPasswordAction'>+                                    <Button variant='primary'onClick={()=> this.updatePassword.execute()}><Msg msgKey='update'/></Button>+                                </DataListAction>+                            </DataListItemRow>+                        </DataList>+                    </StackItem>+                    <StackItem isFilled>+                        <Title headingLevel={TitleLevel.h2} size='2xl'>+                        <strong><Msg msgKey='twoFactorAuth'/></strong>",That's a question for the keycloak-dev list.  This comes from Stian's mockup here: https://docs.google.com/document/d/1Cmon4ODQyd-wvcEbHNJrnZAC3VAxDLM1DB6mjOcjdWk/edit,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6514,350704818,2019-11-26T12:13:46Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/TestClassProvider.java,"@@ -0,0 +1,82 @@+package org.keycloak.testsuite.arquillian;++import com.sun.net.httpserver.HttpContext;",Will this work on IBM JDK? Maybe embedded undertow is a bit safer option regarding this? See for example class OcspHandler from our testsuite for some details.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6504,350714278,2019-11-26T12:35:39Z,quarkus/server/src/main/resources/default-local-cache.xml,"@@ -0,0 +1,63 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+  ~ Copyright 2019 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<infinispan+        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+        xsi:schemaLocation=""urn:infinispan:config:9.4 http://www.infinispan.org/schemas/infinispan-config-9.4.xsd""+        xmlns=""urn:infinispan:config:9.4"">++    <cache-container name=""keycloak"">+        <local-cache name=""default"">+            <transaction transaction-manager-lookup=""org.infinispan.transaction.lookup.JBossStandaloneJTAManagerLookup""/>+        </local-cache>+        <local-cache name=""realms"">+            <memory>+                <object size=""10000""/>+            </memory>+        </local-cache>+        <local-cache name=""users"">+            <memory>+                <object size=""10000""/>+            </memory>+        </local-cache>+        <local-cache name=""sessions""/>","If there is a way to avoid 3 additional files in the workspace with those configurations duplicated, it could be nice. We already have it in few more places, which means that adding/removing/updating any infinispan cache is more and more complicated with more and more possibilities that some place in the workspace will be forgotten.I guess it would be a non-trivial effort to do it, so I am fine with accepting this PR even with this change. But it will be a nice ""bonus"" if it is possible to avoid it :)",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6504,350865487,2019-11-26T16:55:21Z,quarkus/server/src/main/resources/default-local-cache.xml,"@@ -0,0 +1,63 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+  ~ Copyright 2019 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<infinispan+        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+        xsi:schemaLocation=""urn:infinispan:config:9.4 http://www.infinispan.org/schemas/infinispan-config-9.4.xsd""+        xmlns=""urn:infinispan:config:9.4"">++    <cache-container name=""keycloak"">+        <local-cache name=""default"">+            <transaction transaction-manager-lookup=""org.infinispan.transaction.lookup.JBossStandaloneJTAManagerLookup""/>+        </local-cache>+        <local-cache name=""realms"">+            <memory>+                <object size=""10000""/>+            </memory>+        </local-cache>+        <local-cache name=""users"">+            <memory>+                <object size=""10000""/>+            </memory>+        </local-cache>+        <local-cache name=""sessions""/>",The config stuff here is a bit temporary and will change once we drive config through Keycloak config file. I agree we shouldn't have duplicated/multiple versions of this file in the repo.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6504,350865788,2019-11-26T16:55:49Z,quarkus/server/src/main/resources/default-local-cache.xml,"@@ -0,0 +1,63 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+  ~ Copyright 2019 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<infinispan+        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+        xsi:schemaLocation=""urn:infinispan:config:9.4 http://www.infinispan.org/schemas/infinispan-config-9.4.xsd""+        xmlns=""urn:infinispan:config:9.4"">++    <cache-container name=""keycloak"">+        <local-cache name=""default"">+            <transaction transaction-manager-lookup=""org.infinispan.transaction.lookup.JBossStandaloneJTAManagerLookup""/>+        </local-cache>+        <local-cache name=""realms"">+            <memory>+                <object size=""10000""/>+            </memory>+        </local-cache>+        <local-cache name=""users"">+            <memory>+                <object size=""10000""/>+            </memory>+        </local-cache>+        <local-cache name=""sessions""/>",I see your point. This specific config (and the other default one) is meant for running the executable JAR directly or when running in dev mode.I'm not sure too how to avoid this duplication.,X
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/6544,350869431,2019-11-26T17:02:24Z,common/src/main/java/org/keycloak/common/util/MultivaluedHashMap.java,"@@ -101,11 +101,11 @@ public V getFirst(K key)    {       List<V> list = get(key);       if (list == null)-         put(key, list = new ArrayList<V>());+         put(key, list = new ArrayList<>());       return list;    } -   public void addAll(MultivaluedHashMap<K, V> other)+   public final void addAll(MultivaluedHashMap<K, V> other)",Alternatively the whole class can be made `final`. I don't see any extending classes in the project.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6476,351490786,2019-11-27T20:44:58Z,services/src/main/java/org/keycloak/vault/ElytronCSKeyStoreProviderFactory.java,"@@ -0,0 +1,198 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.io.IOException;+import java.lang.invoke.MethodHandles;+import java.nio.file.Files;+import java.nio.file.Paths;+import java.security.GeneralSecurityException;+import java.security.NoSuchAlgorithmException;+import java.security.Security;+import java.security.spec.AlgorithmParameterSpec;+import java.util.HashMap;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.wildfly.security.auth.SupportLevel;+import org.wildfly.security.auth.server.IdentityCredentials;+import org.wildfly.security.credential.Credential;+import org.wildfly.security.credential.PasswordCredential;+import org.wildfly.security.credential.source.CredentialSource;+import org.wildfly.security.credential.store.CredentialStore;+import org.wildfly.security.credential.store.CredentialStoreException;+import org.wildfly.security.credential.store.WildFlyElytronCredentialStoreProvider;+import org.wildfly.security.credential.store.impl.KeyStoreCredentialStore;+import org.wildfly.security.password.interfaces.ClearPassword;+import org.wildfly.security.util.PasswordBasedEncryptionUtil;++/**+ * A {@link VaultProviderFactory} implementation that creates and configures {@link ElytronCSKeyStoreProvider}s. The following+ * configuration attributes are available for the {@code ElytronCSKeyStoreProviderFactory}:+ * <ul>+ *     <li>location (required): the path to he keystore file that contains the secrets. This file is created and managed by Elytron+ *     using either the {@code elytron} subsystem in WildFly/EAP or the {@code elytron-tool.sh} script</li>+ *     <li>secret (required): the keystore master secret. Can be specified in clear text form or in masked form. The masked form+ *     can be generated using the {@code elytron-tool.sh} script. For further details, check the Elytron tool documentation.</li>+ *     <li>type (optional): the keystore type. Defaults to {@code JCEKS}.</li>+ * </ul>+ * <p/>+ * If any of the required configuration attributes is missing, the factory logs a WARN message indicating that it has not+ * been properly configured and will return {@code null} when {@link #create(KeycloakSession)} is called.+ * <p/>+ * If the factory has been properly configured but the {@code location} attribute points to a keystore that does not exist,+ * a {@link VaultNotFoundException} is raised.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class ElytronCSKeyStoreProviderFactory implements VaultProviderFactory {++    private static final Logger logger = Logger.getLogger(MethodHandles.lookup().lookupClass());++    public static final String PROVIDER_ID = ""elytron-cs-keystore"";++    private static final String CS_LOCATION = ""location"";+    private static final String CS_TYPE = ""type"";+    private static final String CS_SECRET = ""secret"";++    private String credentialStoreLocation;+    private String credentialStoreType;+    private String credentialStoreSecret;++    @Override+    public VaultProvider create(KeycloakSession session) {+        if (this.credentialStoreLocation == null || this.credentialStoreSecret == null) {+            logger.debug(""Can not create an elytron-based vault provider since it's disabled or not initialized correctly"");+            return null;+        }+        Map<String, String> attributes = new HashMap<>();+        attributes.put(CS_LOCATION, this.credentialStoreLocation);+        attributes.put(""keyStoreType"", this.credentialStoreType);++        CredentialStore credentialStore = null;+        try {+            credentialStore = CredentialStore.getInstance(KeyStoreCredentialStore.KEY_STORE_CREDENTIAL_STORE);+            credentialStore.initialize(attributes, new CredentialStore.CredentialSourceProtectionParameter(+                    this.getCredentialSource(this.credentialStoreSecret)));+        } catch (NoSuchAlgorithmException | CredentialStoreException e) {+            logger.warn(""Error instantiating credential store"", e);+            return null;+        }++        return new ElytronCSKeyStoreProvider(credentialStore, getRealmName(session));+    }++    @Override+    public void init(Config.Scope config) {+        this.credentialStoreLocation = config.get(CS_LOCATION);+        if (this.credentialStoreLocation == null) {+            logger.warn(""ElytronCSKeyStoreProviderFactory not properly configured - missing store location"");+            return;+        }+        if (!Files.exists(Paths.get(this.credentialStoreLocation))) {+            throw new VaultNotFoundException(""The "" + this.credentialStoreLocation + "" file doesn't exist"");+        }++        this.credentialStoreSecret = config.get(CS_SECRET);+        if (this.credentialStoreSecret == null) {+            logger.warn(""ElytronCSKeyStoreProviderFactory not properly configured - missing store secret"");+            return;+        }+        this.credentialStoreType = config.get(CS_TYPE, ""JCEKS"");++        // install the elytron credential store provider.+        Security.addProvider(WildFlyElytronCredentialStoreProvider.getInstance());+    }++    @Override+    public void postInit(KeycloakSessionFactory factory) {+    }++    @Override+    public void close() {+        // remove the elytron credential store provider.+        Security.removeProvider(WildFlyElytronCredentialStoreProvider.getInstance().getName());+    }++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    /**+     * Obtains the name of realm from the {@link KeycloakSession}.+     *+     * @param session a reference to the {@link KeycloakSession}.+     * @return the name of the realm.+     */+    protected String getRealmName(KeycloakSession session) {+        return session.getContext().getRealm().getName();+    }++    /**+     * Obtains the {@code CredentialSource} to be used as a protection parameter when initializing the Elytron credential+     * store. The source is essentially a wrapper for the credential store secret. The credential store secret can be specified+     * in clear text form or in masked form. Check the Elytron tool documentation for instruction on how to mask the credential+     * store secret.+     *+     * @param secret the secret obtained from the {@link ElytronCSKeyStoreProviderFactory} configuration.+     * @return the constructed {@code CredentialSource}.+     */+    protected CredentialSource getCredentialSource(final String secret) {+        if (secret != null && secret.startsWith(""MASK-"")) {+            return new CredentialSource() {+                @Override+                public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName, AlgorithmParameterSpec parameterSpec) throws IOException {+                    return credentialType == PasswordCredential.class ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;+                }++                @Override+                public <C extends Credential> C getCredential(Class<C> credentialType, String algorithmName, AlgorithmParameterSpec parameterSpec) throws IOException {","Yeah, but Elytron doesn't provide this out of the box. A similar function exists in the elytron subsystem in WildFly to read the secret strings for the credential stores. I agree it would be better to delegate this instead of doing it ourselves but that's just the way it is right now.I'll ping Darran and ask if this could be provided by Elytron somehow. If they do it in the future we could replace this code for something that simply delegates to Elytron.",
50862958,benjamin37,https://api.github.com/repos/keycloak/keycloak/pulls/6344,351793527,2019-11-28T13:58:51Z,services/src/test/java/org/keycloak/broker/oidc/mappers/AdvancedClaimToRoleMapperTest.java,"@@ -0,0 +1,268 @@+/*","Okay, I'll convert the test, thanks for the hint to a similar test.",X
50862958,benjamin37,https://api.github.com/repos/keycloak/keycloak/pulls/6344,351998137,2019-11-29T06:47:16Z,server-spi/src/main/java/org/keycloak/provider/ProviderConfigProperty.java,"@@ -57,6 +57,11 @@      */     public static final String TEXT_TYPE=""Text""; +    /**+     * Define multiple claims as a Map of (claim, value) pairs+     */+    public static final String CLAIMS_TYPE=""Claims"";",Yes right now this can be a general map. However if we want to build more complex boolean expressions with multiple claims (see our discussion in the mailing list https://lists.jboss.org/pipermail/keycloak-dev/2019-September/012446.html) we need to change that type again or introduce a new one. For now I guess it's a good idea to have a map type that can be reused. I'll change that.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6382,352145954,2019-11-29T14:04:26Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -481,6 +474,60 @@ public LinkedAccountsResource linkedAccounts() {         return new LinkedAccountsResource(session, request, client, auth, event, user);     } +    @Path(""/applications"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response applications() {+        checkAccountApiEnabled();+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_APPLICATIONS);++        List<ClientModel> clients = new LinkedList<>();+        List<String> inUseClients = new LinkedList<String>();+        List<UserSessionModel> sessions = session.sessions().getUserSessions(realm, user);+        for(UserSessionModel s : sessions) {+            for (AuthenticatedClientSessionModel a : s.getAuthenticatedClientSessions().values()) {+                ClientModel client = a.getClient();+                if(!client.isBearerOnly() && client.getBaseUrl() != null) {",Just a suggestion for a possible code clarity enhancement (I don't see it as an issue and I'll approve regardless). I think we could remove this condition because it's present here already:https://github.com/keycloak/keycloak/blob/38f314a2634b829b7edaad6720b014d3dbd395f0/services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java#L522-L524,X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6382,352146092,2019-11-29T14:04:48Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -481,6 +474,60 @@ public LinkedAccountsResource linkedAccounts() {         return new LinkedAccountsResource(session, request, client, auth, event, user);     } +    @Path(""/applications"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response applications() {+        checkAccountApiEnabled();+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_APPLICATIONS);++        List<ClientModel> clients = new LinkedList<>();+        List<String> inUseClients = new LinkedList<String>();+        List<UserSessionModel> sessions = session.sessions().getUserSessions(realm, user);+        for(UserSessionModel s : sessions) {+            for (AuthenticatedClientSessionModel a : s.getAuthenticatedClientSessions().values()) {+                ClientModel client = a.getClient();+                if(!client.isBearerOnly() && client.getBaseUrl() != null) {+                    clients.add(client);+                    inUseClients.add(client.getClientId());+                }+            }+        }++        List<String> offlineClients = new LinkedList<String>();+        List<UserSessionModel> offlineSessions = session.sessions().getOfflineUserSessions(realm, user);+        for(UserSessionModel s : offlineSessions) {+            for(AuthenticatedClientSessionModel a : s.getAuthenticatedClientSessions().values()) {+                ClientModel client = a.getClient();+                if(!client.isBearerOnly() && client.getBaseUrl() != null) {",Just a suggestion for a possible code clarity enhancement (I don't see it as an issue and I'll approve regardless). I think we could remove this condition because it's present here already:https://github.com/keycloak/keycloak/blob/38f314a2634b829b7edaad6720b014d3dbd395f0/services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java#L522-L524,X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6382,352147716,2019-11-29T14:08:51Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -481,6 +474,60 @@ public LinkedAccountsResource linkedAccounts() {         return new LinkedAccountsResource(session, request, client, auth, event, user);     } +    @Path(""/applications"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)+    @NoCache+    public Response applications() {+        checkAccountApiEnabled();+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_APPLICATIONS);++        List<ClientModel> clients = new LinkedList<>();","Just a suggestion for a possible code clarity enhancement (I don't see it as an issue and I'll approve regardless). Maybe I'm wrong, but couldn't we use a `Set` (or `SortedSet ` to retain order) here instead of `List` to get rid of many conditions like `if(!clients.contains(client))`? It might make the code cleaner.",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6353,352176829,2019-11-29T15:26:52Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,196 @@  */  import * as React from 'react';- +import { AxiosResponse } from 'axios';++import {+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Text,+  TextVariants,+  Grid,+  GridItem,+} from '@patternfly/react-core';++import { InfoAltIcon, CheckIcon, LinkIcon, BuilderImageIcon } from '@patternfly/react-icons';+import { ContentPage } from '../ContentPage';+import { ContinueCancelModal } from '../../widgets/ContinueCancelModal';+import { AccountServiceClient } from '../../account-service/account.service';+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++export interface GrantedScope {+  displayTest: string;+  id: string;+  name: string;+}++export interface Consent {+  createDate: number;+  grantedScopes: GrantedScope[];+  lastUpdatedDate: number;+}++interface Application {+  baseUrl: string;+  clientId: string;+  clientName: string;+  consent: Consent;+  description: string;+  inUse: boolean;+  offlineAccess: boolean;+  userConsentRequired: boolean;+  scope: string[];+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private removeConsent = (clientId: string) => {+    AccountServiceClient.Instance.doDelete(""/applications/"" + clientId + ""/consent"")+      .then(() => {+        this.fetchApplications();+      });+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({ isRowOpen: newIsRowOpen });+  };++  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+      .then((response: AxiosResponse<Object>) => {+        const applications = response.data as Application[];+        this.setState({+          isRowOpen: this.collapseRows(applications),+          applications: applications+        });+      });+  }++  private collapseRows(applications: Application[]): boolean[] {+    const openRows: boolean[] = new Array<boolean>().fill(true);+    applications.forEach((application: Application, appIndex: number) => {+      openRows[appIndex] = false;+    });+    return openRows;+  }++  public render(): React.ReactNode {+    return (+      <ContentPage title=""applications"">+        <DataList id=""applications-list"" aria-label=""Applications"">+          {this.state.applications.map((application: Application, appIndex: number) => {+            return (+              <DataListItem key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>+                <DataListItemRow>+                  <DataListToggle+                    onClick={() => this.onToggle(appIndex)}+                    isExpanded={this.state.isRowOpen[appIndex]}+                    id={'applicationToggle' + appIndex}+                    aria-controls=""expandable""+                  />+                  <DataListItemCells+                    dataListCells={[+                      <DataListCell width={2} key={'app-' + appIndex}>+                        <BuilderImageIcon /> <Text component={TextVariants.small}>{application.clientId}</Text>+                      </DataListCell>,+                      <DataListCell width={2} key={'internal-' + appIndex}>+                        <span>{application.inUse && !application.userConsentRequired ? 'Internal' : 'Third-party'}+                          {application.offlineAccess ? ', Offline Access' : ''}+                        </span>+                      </DataListCell>,+                      <DataListCell width={2} key={'status-' + appIndex}>+                        <span>{application.inUse ? 'In use' : 'Not in use'}</span>+                      </DataListCell>,+                      <DataListCell width={4} key={'baseUrl-' + appIndex}>+                        <a href={application.baseUrl}><LinkIcon /> {application.baseUrl}</a>","Just a suggestion. Should the link be open in a new tab (`target=""_blank""`) similarly to Admin Console. It's really convenient. :)",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6353,352179664,2019-11-29T15:34:09Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,196 @@  */  import * as React from 'react';- +import { AxiosResponse } from 'axios';++import {+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Text,+  TextVariants,+  Grid,+  GridItem,+} from '@patternfly/react-core';++import { InfoAltIcon, CheckIcon, LinkIcon, BuilderImageIcon } from '@patternfly/react-icons';+import { ContentPage } from '../ContentPage';+import { ContinueCancelModal } from '../../widgets/ContinueCancelModal';+import { AccountServiceClient } from '../../account-service/account.service';+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++export interface GrantedScope {+  displayTest: string;+  id: string;+  name: string;+}++export interface Consent {+  createDate: number;+  grantedScopes: GrantedScope[];+  lastUpdatedDate: number;+}++interface Application {+  baseUrl: string;+  clientId: string;+  clientName: string;+  consent: Consent;+  description: string;+  inUse: boolean;+  offlineAccess: boolean;+  userConsentRequired: boolean;+  scope: string[];+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private removeConsent = (clientId: string) => {+    AccountServiceClient.Instance.doDelete(""/applications/"" + clientId + ""/consent"")+      .then(() => {+        this.fetchApplications();+      });+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({ isRowOpen: newIsRowOpen });+  };++  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+      .then((response: AxiosResponse<Object>) => {+        const applications = response.data as Application[];+        this.setState({+          isRowOpen: this.collapseRows(applications),+          applications: applications+        });+      });+  }++  private collapseRows(applications: Application[]): boolean[] {+    const openRows: boolean[] = new Array<boolean>().fill(true);+    applications.forEach((application: Application, appIndex: number) => {+      openRows[appIndex] = false;+    });+    return openRows;+  }++  public render(): React.ReactNode {+    return (+      <ContentPage title=""applications"">+        <DataList id=""applications-list"" aria-label=""Applications"">+          {this.state.applications.map((application: Application, appIndex: number) => {+            return (+              <DataListItem key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>+                <DataListItemRow>+                  <DataListToggle+                    onClick={() => this.onToggle(appIndex)}+                    isExpanded={this.state.isRowOpen[appIndex]}+                    id={'applicationToggle' + appIndex}+                    aria-controls=""expandable""+                  />+                  <DataListItemCells+                    dataListCells={[+                      <DataListCell width={2} key={'app-' + appIndex}>+                        <BuilderImageIcon /> <Text component={TextVariants.small}>{application.clientId}</Text>+                      </DataListCell>,+                      <DataListCell width={2} key={'internal-' + appIndex}>+                        <span>{application.inUse && !application.userConsentRequired ? 'Internal' : 'Third-party'}+                          {application.offlineAccess ? ', Offline Access' : ''}+                        </span>+                      </DataListCell>,+                      <DataListCell width={2} key={'status-' + appIndex}>+                        <span>{application.inUse ? 'In use' : 'Not in use'}</span>+                      </DataListCell>,+                      <DataListCell width={4} key={'baseUrl-' + appIndex}>+                        <a href={application.baseUrl}><LinkIcon /> {application.baseUrl}</a>+                      </DataListCell>,+                    ]}+                  />+                </DataListItemRow>+                <DataListContent+                  noPadding={false}+                  aria-label=""Application Details""+                  id=""expandable""+                  isHidden={!this.state.isRowOpen[appIndex]}+                >+                  <Grid sm={12} md={12} lg={12}>+                    <GridItem><b>{'Client: '}</b> {application.clientId}</GridItem>+                    {application.description &&+                      <GridItem><b>{'Description: '}</b> {application.description}</GridItem>+                    }+                    <GridItem><b>{'URL: '}</b> {application.baseUrl}</GridItem>+                    {application.consent &&+                      <React.Fragment>+                        <GridItem span={12}>+                          <b>Has access to:</b>+                        </GridItem>+                        {application.consent.grantedScopes.map((scope: GrantedScope, scopeIndex: number) => {+                          return (+                            <React.Fragment key={'scope-' + scopeIndex} >+                              <GridItem offset={1}><CheckIcon /> {scope.name}</GridItem>+                            </React.Fragment>+                          )+                        })}+                        <GridItem><b>{'Access granted on: '}</b>+                          {new Intl.DateTimeFormat('en-US', {+                            year: 'numeric',+                            month: 'long',+                            day: 'numeric',+                            hour: 'numeric',+                            minute: 'numeric',+                            second: 'numeric'+                          }).format(application.consent.createDate)}",This should be localized based on current user locale (incl. 12h/24h clock). But this is probably a bigger task (the same issue is at many different places in the Account Console) so it's probably out of scope of this PR.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6353,352182499,2019-11-29T15:41:40Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,196 @@  */  import * as React from 'react';- +import { AxiosResponse } from 'axios';++import {+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Text,+  TextVariants,+  Grid,+  GridItem,+} from '@patternfly/react-core';++import { InfoAltIcon, CheckIcon, LinkIcon, BuilderImageIcon } from '@patternfly/react-icons';+import { ContentPage } from '../ContentPage';+import { ContinueCancelModal } from '../../widgets/ContinueCancelModal';+import { AccountServiceClient } from '../../account-service/account.service';+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++export interface GrantedScope {+  displayTest: string;+  id: string;+  name: string;+}++export interface Consent {+  createDate: number;+  grantedScopes: GrantedScope[];+  lastUpdatedDate: number;+}++interface Application {+  baseUrl: string;+  clientId: string;+  clientName: string;+  consent: Consent;+  description: string;+  inUse: boolean;+  offlineAccess: boolean;+  userConsentRequired: boolean;+  scope: string[];+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private removeConsent = (clientId: string) => {+    AccountServiceClient.Instance.doDelete(""/applications/"" + clientId + ""/consent"")+      .then(() => {+        this.fetchApplications();+      });+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({ isRowOpen: newIsRowOpen });+  };++  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+      .then((response: AxiosResponse<Object>) => {+        const applications = response.data as Application[];+        this.setState({+          isRowOpen: this.collapseRows(applications),+          applications: applications+        });+      });+  }++  private collapseRows(applications: Application[]): boolean[] {+    const openRows: boolean[] = new Array<boolean>().fill(true);+    applications.forEach((application: Application, appIndex: number) => {+      openRows[appIndex] = false;+    });+    return openRows;+  }++  public render(): React.ReactNode {+    return (+      <ContentPage title=""applications"">+        <DataList id=""applications-list"" aria-label=""Applications"">+          {this.state.applications.map((application: Application, appIndex: number) => {+            return (+              <DataListItem key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>+                <DataListItemRow>+                  <DataListToggle+                    onClick={() => this.onToggle(appIndex)}+                    isExpanded={this.state.isRowOpen[appIndex]}+                    id={'applicationToggle' + appIndex}+                    aria-controls=""expandable""+                  />+                  <DataListItemCells+                    dataListCells={[+                      <DataListCell width={2} key={'app-' + appIndex}>+                        <BuilderImageIcon /> <Text component={TextVariants.small}>{application.clientId}</Text>+                      </DataListCell>,+                      <DataListCell width={2} key={'internal-' + appIndex}>+                        <span>{application.inUse && !application.userConsentRequired ? 'Internal' : 'Third-party'}+                          {application.offlineAccess ? ', Offline Access' : ''}+                        </span>+                      </DataListCell>,+                      <DataListCell width={2} key={'status-' + appIndex}>+                        <span>{application.inUse ? 'In use' : 'Not in use'}</span>+                      </DataListCell>,+                      <DataListCell width={4} key={'baseUrl-' + appIndex}>+                        <a href={application.baseUrl}><LinkIcon /> {application.baseUrl}</a>+                      </DataListCell>,+                    ]}+                  />+                </DataListItemRow>+                <DataListContent+                  noPadding={false}+                  aria-label=""Application Details""+                  id=""expandable""+                  isHidden={!this.state.isRowOpen[appIndex]}+                >+                  <Grid sm={12} md={12} lg={12}>+                    <GridItem><b>{'Client: '}</b> {application.clientId}</GridItem>+                    {application.description &&+                      <GridItem><b>{'Description: '}</b> {application.description}</GridItem>+                    }+                    <GridItem><b>{'URL: '}</b> {application.baseUrl}</GridItem>+                    {application.consent &&+                      <React.Fragment>+                        <GridItem span={12}>+                          <b>Has access to:</b>+                        </GridItem>+                        {application.consent.grantedScopes.map((scope: GrantedScope, scopeIndex: number) => {+                          return (+                            <React.Fragment key={'scope-' + scopeIndex} >+                              <GridItem offset={1}><CheckIcon /> {scope.name}</GridItem>+                            </React.Fragment>+                          )+                        })}","I'm not sure what but IMHO it's missing something. :) (I'm definitely no UX expert but my common sense tells me it could _somehow_ look better. :)). Perhaps the list has too big left margin(?) I don't know ;)Maybe a simple one-line list (""Has access to: email, profile, roles"") would look better?![Screenshot 2019-11-29 at 16 36 44](https://user-images.githubusercontent.com/13906855/69878944-7e4cac00-12c6-11ea-89fb-f46b3af42474.png)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6514,352244355,2019-11-29T21:07:15Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/TestClassProvider.java,"@@ -0,0 +1,82 @@+package org.keycloak.testsuite.arquillian;++import com.sun.net.httpserver.HttpContext;+import com.sun.net.httpserver.HttpExchange;+import com.sun.net.httpserver.HttpServer;+import org.apache.commons.io.IOUtils;+import org.jboss.logging.Logger;++import java.io.IOException;+import java.io.InputStream;+import java.io.OutputStream;+import java.net.InetSocketAddress;++public class TestClassProvider {++    private static final Logger LOGGER = Logger.getLogger(TestClassProvider.class);++    public static final String[] PERMITTED_PACKAGES = new String[] {+            ""/org/keycloak/testsuite"",+            ""/org/junit"",+            ""/org/hamcrest"",+            ""/org/keycloak/admin/client"",+            ""/org/jboss/resteasy/client"",+            ""/org/jboss/arquillian"",+            ""/org/jboss/shrinkwrap"",+            ""/org/openqa/selenium""+    };++    private static TestClassProvider instance;+    private final HttpServer server;++    public static TestClassProvider getInstance() throws IOException {+        if (instance == null) {+            instance = new TestClassProvider();+        }+        return instance;+    }++    private TestClassProvider() throws IOException {+        InetSocketAddress address = new InetSocketAddress(8500);+        server = HttpServer.create(address, 0);+        HttpContext context = server.createContext(""/"");+        context.setHandler(TestClassProvider::handleRequest);+        server.start();++        LOGGER.infov(""Started test class provider {0}"", address.toString());+    }++    public void stop() {+        server.stop(0);+    }++    private static void handleRequest(HttpExchange exchange) throws IOException {+        String className = exchange.getRequestURI().toString();++        LOGGER.infov(""Request: {0}"", className);++        InputStream is = TestClassProvider.class.getResourceAsStream(className);",```suggestion        try (InputStream is = TestClassProvider.class.getResourceAsStream(className)) {            ...        }```,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6520,352252633,2019-11-29T22:37:50Z,services/src/main/java/org/keycloak/protocol/saml/mappers/SAMLAudienceProtocolMapper.java,"@@ -0,0 +1,136 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.saml.mappers;++import java.net.URI;+import java.util.ArrayList;+import java.util.List;+import org.jboss.logging.Logger;+import org.keycloak.dom.saml.v2.assertion.AudienceRestrictionType;+import org.keycloak.dom.saml.v2.protocol.ResponseType;+import org.keycloak.models.ClientSessionContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ProtocolMapperModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.provider.ProviderConfigProperty;++/**+ * SAML mapper to add a audience restriction into the assertion, to another+ * client (clientId) or to a custom URI. Only one URI is added, clientId+ * has preference over the custom value (the class maps OIDC behavior).+ *+ * @author rmartinc+ */+public class SAMLAudienceProtocolMapper extends AbstractSAMLProtocolMapper implements SAMLLoginResponseMapper {++    protected static final Logger logger = Logger.getLogger(SAMLAudienceProtocolMapper.class);++    public static final String PROVIDER_ID = ""saml-audience-mapper"";++    public static final String AUDIENCE_CATEGORY = ""Audience mapper"";++    private static final List<ProviderConfigProperty> configProperties = new ArrayList<ProviderConfigProperty>();++    public static final String INCLUDED_CLIENT_AUDIENCE = ""included.client.audience"";+    private static final String INCLUDED_CLIENT_AUDIENCE_LABEL = ""included.client.audience.label"";+    private static final String INCLUDED_CLIENT_AUDIENCE_HELP_TEXT = ""included.client.audience.tooltip"";++    public static final String INCLUDED_CUSTOM_AUDIENCE = ""included.custom.audience"";+    private static final String INCLUDED_CUSTOM_AUDIENCE_LABEL = ""included.custom.audience.label"";+    private static final String INCLUDED_CUSTOM_AUDIENCE_HELP_TEXT = ""included.custom.audience.tooltip"";++    static {+        ProviderConfigProperty property;+        property = new ProviderConfigProperty();+        property.setName(INCLUDED_CLIENT_AUDIENCE);+        property.setLabel(INCLUDED_CLIENT_AUDIENCE_LABEL);+        property.setHelpText(INCLUDED_CLIENT_AUDIENCE_HELP_TEXT);+        property.setType(ProviderConfigProperty.CLIENT_LIST_TYPE);+        configProperties.add(property);++        property = new ProviderConfigProperty();+        property.setName(INCLUDED_CUSTOM_AUDIENCE);+        property.setLabel(INCLUDED_CUSTOM_AUDIENCE_LABEL);+        property.setHelpText(INCLUDED_CUSTOM_AUDIENCE_HELP_TEXT);+        property.setType(ProviderConfigProperty.STRING_TYPE);+        configProperties.add(property);+    }++    @Override+    public List<ProviderConfigProperty> getConfigProperties() {+        return configProperties;+    }++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    @Override+    public String getDisplayType() {+        return ""Audience"";+    }++    @Override+    public String getDisplayCategory() {+        return AUDIENCE_CATEGORY;+    }++    @Override+    public String getHelpText() {+        return ""Add specified audience to the audience conditions in the assertion."";+    }++    protected static AudienceRestrictionType locateAudienceRestriction(ResponseType response) {+        try {+            return response.getAssertions().get(0).getAssertion().getConditions().getConditions()+                    .stream()+                    .filter(c -> c instanceof AudienceRestrictionType)",```suggestion                    .filter(AudienceRestrictionType.class::isInstance)                    .map(AudienceRestrictionType.class::cast)```,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6382,352513964,2019-12-02T10:14:32Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -275,42 +257,53 @@ public Response getApplications() {     @Produces(MediaType.APPLICATION_JSON)     public Response getApplication(final @PathParam(""clientId"") String clientId) {         checkAccountApiEnabled();-        auth.require(AccountRoles.VIEW_APPLICATIONS);+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_APPLICATIONS);         ClientModel client = realm.getClientByClientId(clientId);         if (client == null) {             return Cors.add(request, Response.status(Response.Status.NOT_FOUND).entity(""No client with clientId: "" + clientId + "" found."")).build();         } -        return Cors.add(request, Response.ok(modelToRepresentation(client))).build();+        List<String> inUseClients = new LinkedList<>();+        if(!session.sessions().getUserSessions(realm, client).isEmpty()) {+            inUseClients.add(clientId);+        }++        List<String> offlineClients = new LinkedList<>();+        if(session.sessions().getOfflineSessionsCount(realm, client) > 0) {+            offlineClients.add(clientId);+        }++        return Cors.add(request, Response.ok(modelToRepresentation(client, inUseClients, offlineClients))).build();","@douglaspalmer Thanks!Should we also hide Clients that are not in active session?In other words, should we have some unified mechanism for filtering clients out that would ensure the results from `/applications` and `/applications/{client_id}` are consistent? `/applications/{client_id}` IMHO should return only the clients that are accessible through `/applications`. But maybe this is out of scope of this PR? WDYT @stianst @abstractj ?",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/6564,352551784,2019-12-02T11:43:18Z,services/src/main/java/org/keycloak/keys/AbstractEcdsaKeyProviderFactory.java,"@@ -43,7 +43,7 @@             String.valueOf(GeneratedEcdsaKeyProviderFactory.DEFAULT_ECDSA_ELLIPTIC_CURVE),             ""P-256"", ""P-384"", ""P-521"");  -    public final static ProviderConfigurationBuilder configurationBuilder() {+    public static ProviderConfigurationBuilder configurationBuilder() {",I think the final modifier might be here on purpose. It will prevent from hiding the method from subclass.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6552,352652936,2019-12-02T15:18:07Z,distribution/feature-packs/server-feature-pack/src/main/resources/modules/system/layers/keycloak/org/keycloak/keycloak-server-subsystem/dependencies/main/module.xml,"@@ -23,6 +23,7 @@      <dependencies>         <module name=""org.keycloak.keycloak-services"" export=""true""/>+        <module name=""org.keycloak.keycloak-wildfly-extensions"" export=""true""/>","This shouldn't be needed as platform provider is used within services only, which has a dependency on keycloak-wildfly-extensions",X
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6353,352794457,2019-12-02T19:49:32Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,196 @@  */  import * as React from 'react';- +import { AxiosResponse } from 'axios';++import {+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Text,+  TextVariants,+  Grid,+  GridItem,+} from '@patternfly/react-core';++import { InfoAltIcon, CheckIcon, LinkIcon, BuilderImageIcon } from '@patternfly/react-icons';+import { ContentPage } from '../ContentPage';+import { ContinueCancelModal } from '../../widgets/ContinueCancelModal';+import { AccountServiceClient } from '../../account-service/account.service';+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++export interface GrantedScope {+  displayTest: string;+  id: string;+  name: string;+}++export interface Consent {+  createDate: number;+  grantedScopes: GrantedScope[];+  lastUpdatedDate: number;+}++interface Application {+  baseUrl: string;+  clientId: string;+  clientName: string;+  consent: Consent;+  description: string;+  inUse: boolean;+  offlineAccess: boolean;+  userConsentRequired: boolean;+  scope: string[];+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private removeConsent = (clientId: string) => {+    AccountServiceClient.Instance.doDelete(""/applications/"" + clientId + ""/consent"")+      .then(() => {+        this.fetchApplications();+      });+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({ isRowOpen: newIsRowOpen });+  };++  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+      .then((response: AxiosResponse<Object>) => {+        const applications = response.data as Application[];+        this.setState({+          isRowOpen: this.collapseRows(applications),+          applications: applications+        });+      });+  }++  private collapseRows(applications: Application[]): boolean[] {+    const openRows: boolean[] = new Array<boolean>().fill(true);+    applications.forEach((application: Application, appIndex: number) => {+      openRows[appIndex] = false;+    });+    return openRows;+  }++  public render(): React.ReactNode {+    return (+      <ContentPage title=""applications"">+        <DataList id=""applications-list"" aria-label=""Applications"">+          {this.state.applications.map((application: Application, appIndex: number) => {+            return (+              <DataListItem key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>+                <DataListItemRow>+                  <DataListToggle+                    onClick={() => this.onToggle(appIndex)}+                    isExpanded={this.state.isRowOpen[appIndex]}+                    id={'applicationToggle' + appIndex}+                    aria-controls=""expandable""+                  />+                  <DataListItemCells+                    dataListCells={[+                      <DataListCell width={2} key={'app-' + appIndex}>+                        <BuilderImageIcon /> <Text component={TextVariants.small}>{application.clientId}</Text>","@vmuzikar changed to name with clientId as fallback. Stian suggested this some time ago: https://lists.jboss.org/pipermail/keycloak-dev/2019-October/012698.html@vmuzikar regards the font-size, no specific reason. Could you please tell me which one you think would be better: https://patternfly-react.surge.sh/patternfly-4/documentation/react/components/text ?",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6353,352809150,2019-12-02T20:21:34Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,196 @@  */  import * as React from 'react';- +import { AxiosResponse } from 'axios';++import {+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Text,+  TextVariants,+  Grid,+  GridItem,+} from '@patternfly/react-core';++import { InfoAltIcon, CheckIcon, LinkIcon, BuilderImageIcon } from '@patternfly/react-icons';+import { ContentPage } from '../ContentPage';+import { ContinueCancelModal } from '../../widgets/ContinueCancelModal';+import { AccountServiceClient } from '../../account-service/account.service';+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++export interface GrantedScope {+  displayTest: string;+  id: string;+  name: string;+}++export interface Consent {+  createDate: number;+  grantedScopes: GrantedScope[];+  lastUpdatedDate: number;+}++interface Application {+  baseUrl: string;+  clientId: string;+  clientName: string;+  consent: Consent;+  description: string;+  inUse: boolean;+  offlineAccess: boolean;+  userConsentRequired: boolean;+  scope: string[];+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private removeConsent = (clientId: string) => {+    AccountServiceClient.Instance.doDelete(""/applications/"" + clientId + ""/consent"")+      .then(() => {+        this.fetchApplications();+      });+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({ isRowOpen: newIsRowOpen });+  };++  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+      .then((response: AxiosResponse<Object>) => {+        const applications = response.data as Application[];",Linter might not like using Object here.  Simpler way to code this:.then((response: AxiosResponse<Application[]>) => {    const applications: Application[] = response.data;  // don't need this line - now response.data has correct type,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6353,353022309,2019-12-03T07:42:17Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,196 @@  */  import * as React from 'react';- +import { AxiosResponse } from 'axios';++import {+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Text,+  TextVariants,+  Grid,+  GridItem,+} from '@patternfly/react-core';++import { InfoAltIcon, CheckIcon, LinkIcon, BuilderImageIcon } from '@patternfly/react-icons';+import { ContentPage } from '../ContentPage';+import { ContinueCancelModal } from '../../widgets/ContinueCancelModal';+import { AccountServiceClient } from '../../account-service/account.service';+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++export interface GrantedScope {+  displayTest: string;+  id: string;+  name: string;+}++export interface Consent {+  createDate: number;+  grantedScopes: GrantedScope[];+  lastUpdatedDate: number;+}++interface Application {+  baseUrl: string;+  clientId: string;+  clientName: string;+  consent: Consent;+  description: string;+  inUse: boolean;+  offlineAccess: boolean;+  userConsentRequired: boolean;+  scope: string[];+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private removeConsent = (clientId: string) => {+    AccountServiceClient.Instance.doDelete(""/applications/"" + clientId + ""/consent"")+      .then(() => {+        this.fetchApplications();+      });+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({ isRowOpen: newIsRowOpen });+  };++  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+      .then((response: AxiosResponse<Object>) => {+        const applications = response.data as Application[];+        this.setState({+          isRowOpen: this.collapseRows(applications),+          applications: applications+        });+      });+  }++  private collapseRows(applications: Application[]): boolean[] {+    const openRows: boolean[] = new Array<boolean>().fill(true);+    applications.forEach((application: Application, appIndex: number) => {+      openRows[appIndex] = false;+    });+    return openRows;+  }++  public render(): React.ReactNode {+    return (+      <ContentPage title=""applications"">+        <DataList id=""applications-list"" aria-label=""Applications"">+          {this.state.applications.map((application: Application, appIndex: number) => {+            return (+              <DataListItem key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>+                <DataListItemRow>+                  <DataListToggle+                    onClick={() => this.onToggle(appIndex)}+                    isExpanded={this.state.isRowOpen[appIndex]}+                    id={'applicationToggle' + appIndex}+                    aria-controls=""expandable""+                  />+                  <DataListItemCells+                    dataListCells={[+                      <DataListCell width={2} key={'app-' + appIndex}>+                        <BuilderImageIcon /> <Text component={TextVariants.small}>{application.clientId}</Text>","@abstractj Let me answer you with a question. :) Do we need to put client name/ID in `<Text>` component at all? We don't put e.g. ""Internal"" to this component and it looks good without it.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6382,354139399,2019-12-05T07:12:10Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -275,42 +259,53 @@ public Response getApplications() {     @Produces(MediaType.APPLICATION_JSON)     public Response getApplication(final @PathParam(""clientId"") String clientId) {         checkAccountApiEnabled();-        auth.require(AccountRoles.VIEW_APPLICATIONS);+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_APPLICATIONS);         ClientModel client = realm.getClientByClientId(clientId);-        if (client == null) {+        if (client == null || client.isBearerOnly() || client.getBaseUrl() == null) {             return Cors.add(request, Response.status(Response.Status.NOT_FOUND).entity(""No client with clientId: "" + clientId + "" found."")).build();         } -        return Cors.add(request, Response.ok(modelToRepresentation(client))).build();+        List<String> inUseClients = new LinkedList<>();+        if(!session.sessions().getUserSessions(realm, client).isEmpty()) {+            inUseClients.add(clientId);+        }++        List<String> offlineClients = new LinkedList<>();+        if(session.sessions().getOfflineSessionsCount(realm, client) > 0) {+            offlineClients.add(clientId);+        }++        return Cors.add(request, Response.ok(modelToRepresentation(client, inUseClients, offlineClients))).build();     } -    private ClientRepresentation modelToRepresentation(ClientModel model) {+    private ClientRepresentation modelToRepresentation(ClientModel model, List<String> inUseClients, List<String> offlineClients) {         ClientRepresentation representation = new ClientRepresentation();         representation.setClientId(model.getClientId());-        representation.setClientName(getTranslationOrDefault(model.getName()));+        representation.setClientName(StringPropertyReplacer.replaceProperties(model.getName(), getProperties()));+        representation.setDescription(model.getDescription());+        representation.setUserConsentRequired(model.isConsentRequired());+        representation.setInUse(inUseClients.contains(model.getClientId()));+        representation.setOfflineAccess(offlineClients.contains(model.getClientId()));+        representation.setBaseUrl(model.getBaseUrl());+        UserConsentModel consentModel = session.users().getConsentByClient(realm, user.getId(), model.getId());","When you are fetching a list of clients you are already fetching the consent-model, which is being fetched again here. Would be better to not do that.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6573,354151714,2019-12-05T07:53:09Z,quarkus/extensions/src/main/java/org/keycloak/provider/quarkus/QuarkusStartupObserver.java,"@@ -34,6 +53,55 @@ private void startupEvent(@Observes StartupEvent event) {         if (command != null) {             command.run();         }++        createAdminUser();+    }++    private void createAdminUser() {+        String adminUserName;+        String adminPassword;++        if ((adminUserName = System.getenv(KEYCLOAK_ADMIN_ENV_VAR)) == null+                || (adminPassword = System.getenv(KEYCLOAK_ADMIN_PASSWORD_ENV_VAR)) == null) {+            return;+        }++        KeycloakSessionFactory sessionFactory = (KeycloakSessionFactory) servletContext+                .getAttribute(KeycloakSessionFactory.class.getName());+        KeycloakSession session = sessionFactory.create();+        KeycloakTransactionManager transaction = session.getTransactionManager();++        try {+            transaction.begin();++            RealmModel realm = session.realms().getRealmByName(DEFAULT_REALM);+            UserProvider users = session.users();++            if (users.getUserByUsername(adminUserName, realm) != null) {+                ServicesLogger.LOGGER.notCreatingExistingUser(adminUserName);+            } else {+                UserModel user = users.addUser(realm, adminUserName);",You can use https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/services/managers/ApplianceBootstrap.java#L95 for this,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6564,354396484,2019-12-05T15:56:07Z,services/src/main/java/org/keycloak/keys/AbstractEcdsaKeyProviderFactory.java,"@@ -43,7 +43,7 @@             String.valueOf(GeneratedEcdsaKeyProviderFactory.DEFAULT_ECDSA_ELLIPTIC_CURVE),             ""P-256"", ""P-384"", ""P-521"");  -    public final static ProviderConfigurationBuilder configurationBuilder() {+    public static ProviderConfigurationBuilder configurationBuilder() {","If ""final"" is removed it would make it possible to override from subclass, so this change should be reverted",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6548,354439995,2019-12-05T17:11:59Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/AbstractUsernameFormAuthenticator.java,"@@ -48,6 +49,7 @@      public static final String REGISTRATION_FORM_ACTION = ""registration_form"";     public static final String ATTEMPTED_USERNAME = ""ATTEMPTED_USERNAME"";+    private boolean isUserPasswordForm = false;","I vote for removing this private variable entirely from this class. Instead of it, there could be possibly some method defined on AbstractUsernameFormAuthenticator like for example:```/** * @return Error message displayed to the user when he enters invalid data (EG. ""Invalid username or password"" or ""Invalid username"" */protected String getDefaultChallengeMessage() {    return Messages.INVALID_USER;}```This method then can be overriden on classes like UsernameForm and PasswordForm.The various calls to ""challenge"" can look like this: ```challengeResponse = challenge(context, getDefaultChallengeMessage());```I believe this will simplify the PR and there won't be so much changes needed to the method ""validateUserAndPassword"" . Ideally no changes will be needed in this method :)",X
4740207,Captain1653,https://api.github.com/repos/keycloak/keycloak/pulls/6561,354485865,2019-12-05T18:49:19Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCWellKnownProvider.java,"@@ -140,11 +142,7 @@ public void close() {     }      private static List<String> list(String... values) {-        List<String> s = new LinkedList<>();-        for (String v : values) {-            s.add(v);-        }-        return s;+        return new LinkedList<>(Arrays.asList(values));","Original code returned LinkedList. I have tried to save semantic. Of cource I can change it, but I'm not sure about the meaning.  As you wish :)",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6573,354997249,2019-12-06T19:35:51Z,quarkus/extensions/pom.xml,"@@ -34,15 +34,15 @@         </dependency>         <dependency>             <groupId>org.keycloak</groupId>-            <artifactId>keycloak-server-spi-private</artifactId>+            <artifactId>keycloak-services</artifactId>",`server-spi-private`is duplicated.,X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6573,355008645,2019-12-06T20:04:35Z,quarkus/server/src/main/resources/META-INF/keycloak-server.json,"@@ -1,12 +1,19 @@ {","In fact, that file has also config that is deprecated, like the request hostname provider. I didn't change that because of the config work. But for now, it helps to check current behavior and how it will look like once we have the config system in.",
55751016,thielef,https://api.github.com/repos/keycloak/keycloak/pulls/6556,355316603,2019-12-09T08:36:45Z,server-spi-private/src/main/java/org/keycloak/migration/migrators/MigrateTo9_0_0.java,"@@ -83,4 +89,71 @@ protected void addAccountConsoleClient(RealmModel realm) {             client.addProtocolMapper(audienceMapper);         }     }+++    protected void migrateAuthenticationFlowsWithAlternativeRequirements(RealmModel realm) {+        for (AuthenticationFlowModel flow : realm.getAuthenticationFlows()) {++            // Suffix used just to avoid name conflicts+            int suffix = 0;+            boolean requiredFound = false;+            LinkedList<AuthenticationExecutionModel> alternativesAfterRequired = new LinkedList<>();+            for (AuthenticationExecutionModel execution : realm.getAuthenticationExecutions(flow.getId())) {+                if (AuthenticationExecutionModel.Requirement.REQUIRED.equals(execution.getRequirement())) {","For a flow like...- 1) ExecutionA, conditional- 2) ExecutionB, alternative- 3) ExecutionC, alternative...there would be no migration. But effectively, this flow is now ignoring step 2 and 3 as no migration is applied (due to org.keycloak.authentication.DefaultAuthenticationFlow.processFlow():`            else if (execution.isRequired() || execution.isConditional()) {                requiredList.add(execution);            }`",
55751016,thielef,https://api.github.com/repos/keycloak/keycloak/pulls/6556,355317607,2019-12-09T08:39:23Z,server-spi-private/src/main/java/org/keycloak/migration/migrators/MigrateTo9_0_0.java,"@@ -83,4 +89,71 @@ protected void addAccountConsoleClient(RealmModel realm) {             client.addProtocolMapper(audienceMapper);         }     }+++    protected void migrateAuthenticationFlowsWithAlternativeRequirements(RealmModel realm) {+        for (AuthenticationFlowModel flow : realm.getAuthenticationFlows()) {++            // Suffix used just to avoid name conflicts+            int suffix = 0;+            boolean requiredFound = false;+            LinkedList<AuthenticationExecutionModel> alternativesAfterRequired = new LinkedList<>();+            for (AuthenticationExecutionModel execution : realm.getAuthenticationExecutions(flow.getId())) {+                if (AuthenticationExecutionModel.Requirement.REQUIRED.equals(execution.getRequirement())) {+                    requiredFound = true;+                }++                // If we have some REQUIRED then ALTERNATIVE and then REQUIRED/CONDITIONAL, we migrate the alternatives to the new subflow.+                if (AuthenticationExecutionModel.Requirement.REQUIRED.equals(execution.getRequirement()) ||+                        AuthenticationExecutionModel.Requirement.CONDITIONAL.equals(execution.getRequirement())) {+                    if (!alternativesAfterRequired.isEmpty()) {+                        migrateAlternatives(realm, flow, alternativesAfterRequired, suffix);+                        suffix += 1;+                        alternativesAfterRequired.clear();+                    }+                }++                // ALTERNATIVE executions found after REQUIRED. We may migrate them+                if (AuthenticationExecutionModel.Requirement.ALTERNATIVE.equals(execution.getRequirement()) && requiredFound) {","For a flow like...- ExecutionA, alternative- ExecutionB, alternative- ExecutionC, required...there would be no migration either. But effectively, this flow is now ignoring step 1 and 2 as no migration is applied (see mail thread on dev mailing list -- our custom SPI use case).",
3079540,Captain-P-Goldfish,https://api.github.com/repos/keycloak/keycloak/pulls/6330,355415064,2019-12-09T12:12:11Z,services/src/test/java/org/keycloak/authentication/authenticators/x509/CertificateValidatorTest.java,"@@ -0,0 +1,157 @@+package org.keycloak.authentication.authenticators.x509;",was not able to get the test running and I am not getting any answers in the mailing list...https://groups.google.com/forum/#!topic/keycloak-dev/MI20c_zKI1Q,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/6548,356020982,2019-12-10T12:57:51Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/AbstractUsernameFormAuthenticator.java,"@@ -228,4 +224,19 @@ protected boolean isTemporarilyDisabledByBruteForce(AuthenticationFlowContext co         }         return false;     }++    private void setInvalidUser(AuthenticationFlowContext context) {+        context.getEvent().error(Errors.USER_NOT_FOUND);+        Response challengeResponse;+        if (getDefaultChallengeMessage().equals(Messages.INVALID_USERNAME) && context.getRealm().isLoginWithEmailAllowed()) {","Yes, I've considered this possibility, but the `getDefaultChallengeMessage` with parameter `context` would be used only with `UsernameForm`. So I thought, this way would be cleaner. But, if you think, it'll be better with parameter, I'll remake it :) ",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/6353,356597888,2019-12-11T13:29:39Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,196 @@  */  import * as React from 'react';- +import { AxiosResponse } from 'axios';++import {+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Text,+  TextVariants,+  Grid,+  GridItem,+} from '@patternfly/react-core';++import { InfoAltIcon, CheckIcon, LinkIcon, BuilderImageIcon } from '@patternfly/react-icons';+import { ContentPage } from '../ContentPage';+import { ContinueCancelModal } from '../../widgets/ContinueCancelModal';+import { AccountServiceClient } from '../../account-service/account.service';+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++export interface GrantedScope {+  displayTest: string;+  id: string;+  name: string;+}++export interface Consent {+  createDate: number;+  grantedScopes: GrantedScope[];+  lastUpdatedDate: number;+}++interface Application {+  baseUrl: string;+  clientId: string;+  clientName: string;+  consent: Consent;+  description: string;+  inUse: boolean;+  offlineAccess: boolean;+  userConsentRequired: boolean;+  scope: string[];+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private removeConsent = (clientId: string) => {+    AccountServiceClient.Instance.doDelete(""/applications/"" + clientId + ""/consent"")+      .then(() => {+        this.fetchApplications();+      });+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({ isRowOpen: newIsRowOpen });+  };++  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+      .then((response: AxiosResponse<Object>) => {+        const applications = response.data as Application[];+        this.setState({+          isRowOpen: this.collapseRows(applications),+          applications: applications+        });+      });+  }++  private collapseRows(applications: Application[]): boolean[] {+    const openRows: boolean[] = new Array<boolean>().fill(true);+    applications.forEach((application: Application, appIndex: number) => {+      openRows[appIndex] = false;+    });+    return openRows;+  }++  public render(): React.ReactNode {+    return (+      <ContentPage title=""applications"">+        <DataList id=""applications-list"" aria-label=""Applications"">+          {this.state.applications.map((application: Application, appIndex: number) => {+            return (+              <DataListItem key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>+                <DataListItemRow>+                  <DataListToggle+                    onClick={() => this.onToggle(appIndex)}+                    isExpanded={this.state.isRowOpen[appIndex]}+                    id={'applicationToggle' + appIndex}+                    aria-controls=""expandable""+                  />+                  <DataListItemCells+                    dataListCells={[+                      <DataListCell width={2} key={'app-' + appIndex}>+                        <BuilderImageIcon /> <Text component={TextVariants.small}>{application.clientId}</Text>+                      </DataListCell>,+                      <DataListCell width={2} key={'internal-' + appIndex}>+                        <span>{application.inUse && !application.userConsentRequired ? 'Internal' : 'Third-party'}+                          {application.offlineAccess ? ', Offline Access' : ''}+                        </span>+                      </DataListCell>,+                      <DataListCell width={2} key={'status-' + appIndex}>+                        <span>{application.inUse ? 'In use' : 'Not in use'}</span>+                      </DataListCell>,+                      <DataListCell width={4} key={'baseUrl-' + appIndex}>+                        <a href={application.baseUrl}><LinkIcon /> {application.baseUrl}</a>+                      </DataListCell>,+                    ]}+                  />+                </DataListItemRow>+                <DataListContent+                  noPadding={false}+                  aria-label=""Application Details""+                  id=""expandable""+                  isHidden={!this.state.isRowOpen[appIndex]}+                >+                  <Grid sm={12} md={12} lg={12}>+                    <GridItem><b>{'Client: '}</b> {application.clientId}</GridItem>+                    {application.description &&+                      <GridItem><b>{'Description: '}</b> {application.description}</GridItem>+                    }+                    <GridItem><b>{'URL: '}</b> {application.baseUrl}</GridItem>+                    {application.consent &&+                      <React.Fragment>+                        <GridItem span={12}>+                          <b>Has access to:</b>+                        </GridItem>+                        {application.consent.grantedScopes.map((scope: GrantedScope, scopeIndex: number) => {+                          return (+                            <React.Fragment key={'scope-' + scopeIndex} >+                              <GridItem offset={1}><CheckIcon /> {scope.name}</GridItem>+                            </React.Fragment>+                          )+                        })}","@vmuzikar based on the discussion from the mailing list, I will mark this as resolved. Let's stick with the wireframes and for future improvements we can discuss with UXD team.I will revisit all the details from the wireframe and update this PR.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6593,357515760,2019-12-13T07:34:20Z,testsuite/integration-arquillian/tests/pom.xml,"@@ -225,6 +225,25 @@                                 <skip>${auth.server.jboss.skip.unpack}</skip>                             </configuration>                         </execution>+                        <execution>+                            <id>unpack-undertow-server</id>",Just to clarify. I've moved this task from base testsuite one level higher (to a parent POM) so that all test modules have access to some required files. This is specifically needed for using [`OAuthClient`](https://github.com/keycloak/keycloak/blob/3eedcdb1542e254a5de74701c6d71fad380fde2a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java#L119) in tests (and apparently it was used only in the base testsuite until now).,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6566,357565609,2019-12-13T09:58:02Z,model/jpa/src/main/resources/META-INF/jpa-changelog-9.0.0.xml,"@@ -0,0 +1,28 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2018 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->+<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++    <changeSet author=""keycloak"" id=""9.0.0-always-display-client"">","Should we perhaps extend the [MigrationTest](https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/migration/MigrationTest.java)? On the other hand this is a quite small change... But still, just to be sure...",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6566,357593941,2019-12-13T11:04:35Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -546,6 +546,42 @@ static String getRoleByNameCacheKey(String container, String name) {         return getClientDelegate().getClients(realm);     } +    @Override+    public List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm) {","I don't yet have enough expertise in this area (caching etc.) to properly review this, so I've got a few stupid questions. :)Why not to directly call `getClientDelegate().getAlwaysDisplayInConsoleClients(realm)` like here?https://github.com/keycloak/keycloak/blob/45ea5bd34828cefcd7301d168e40b854ff52234f/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java#L544-L547",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6576,357610565,2019-12-13T11:50:15Z,model/jpa/src/main/java/org/keycloak/events/jpa/JpaEventStoreProvider.java,"@@ -116,13 +119,30 @@ static EventEntity convertEvent(Event event) {         eventEntity.setIpAddress(event.getIpAddress());         eventEntity.setError(event.getError());         try {-            eventEntity.setDetailsJson(mapper.writeValueAsString(event.getDetails()));+            if (maxDetailLength > 0 && event.getDetails() != null) {+                Map<String, String> result = new HashMap<>(event.getDetails());+                result.entrySet().forEach(t -> t.setValue(trimToMaxLength(t.getValue())));++                eventEntity.setDetailsJson(mapper.writeValueAsString(result));+            } else {+                eventEntity.setDetailsJson(mapper.writeValueAsString(event.getDetails()));+            }         } catch (IOException ex) {             logger.error(""Failed to write log details"", ex);         }         return eventEntity;     } +    private String trimToMaxLength(String detail) {+        if (detail != null && detail.length() > maxDetailLength) {+            String result = detail.substring(0, maxDetailLength).concat(""..."");","It should take `...` into account in the max-length, so the string with `...` should be max maxDetailLength long",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6476,358090477,2019-12-16T07:56:36Z,services/src/main/java/org/keycloak/vault/AbstractVaultProviderFactory.java,"@@ -0,0 +1,174 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.vault;++import java.io.File;+import java.lang.invoke.MethodHandles;+import java.util.ArrayList;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;++/**+ * Abstract class that is meant to be extended by implementations of {@link VaultProviderFactory} that want to offer support+ * for the configuration of key resolvers.+ * <p/>+ * It implements the {@link #init(Config.Scope)} method, where is looks for the {@code keyResolvers} property. The value is+ * a comma-separated list of key resolver names. It then verifies if the resolver names match one of the available key resolver+ * implementations and then creates a list of {@link VaultKeyResolver} instances that subclasses can pass to {@link VaultProvider}+ * instances on {@link #create(KeycloakSession)}.+ * <p/>+ * The list of currently available resolvers follows:+ * <ul>+ *     <li>{@code KEY_ONLY}: only the key name is used as is, realm is ignored;</li>+ *     <li>{@code REALM_UNDERSCORE_KEY}: realm and key are combined using an underscore ({@code '_'}) character. Any occurrences of+ *     underscore in both the realm and key are escaped by an additional underscore character;</li>+ *     <li>{@code REALM_FILESEPARATOR_KEY}: realm and key are combined using the platform file separator character. It might not be+ *     suitable for every vault provider but it enables the grouping of secrets using a directory structure;</li>+ *     <li>{@code FACTORY_PROVIDED}: the format of the constructed key is determined by the factory's {@link #getFactoryResolver()}+ *     implementation. it allows for the customization of the final key format by extending the factory and overriding the+ *     {@link #getFactoryResolver()} method.</li>+ * </ul>+ * <p/>+ * <b><i>Note</i></b>: When extending the standard factories to use the {@code FACTORY_PROVIDED} resolver, it is important to also+ * override the {@link #getId()} method so that the custom factory has its own id and as such can be configured in the keycloak+ * server.+ * <p/>+ * If no resolver is explicitly configured for the factory, it defaults to using the {@code REALM_UNDERSCORE_KEY} resolver.+ * When one or more resolvers are explicitly configured, this factory iterates through them in order and for each one attempts+ * to obtain the respective {@link VaultKeyResolver} implementation. If it fails (for example, the name doesn't match one of+ * the existing resolvers), it logs a message and ignores the resolver. If it fails to load all configured resolvers, it+ * throws a {@link VaultConfigurationException}.+ * <p/>+ * Concrete implementations must also make sure to call the {@code super.init(config)} in their own {@link #init(Config.Scope)}+ * implementations so tha the processing of the key resolvers is performed correctly.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public abstract class AbstractVaultProviderFactory implements VaultProviderFactory {++    private static final Logger logger = Logger.getLogger(MethodHandles.lookup().lookupClass());++    protected static final String KEY_RESOLVERS = ""keyResolvers"";++    protected List<VaultKeyResolver> keyResolvers = new ArrayList<>();","Since this list is only used for adding and full iteration (no indexed access), `LinkedList` is best option.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6600,358388403,2019-12-16T18:18:14Z,quarkus/extensions/src/main/java/org/keycloak/provider/quarkus/QuarkusFilter.java,"@@ -0,0 +1,159 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.provider.quarkus;++import io.vertx.core.http.HttpServerRequest;+import org.jboss.resteasy.core.interception.jaxrs.ContainerResponseContextImpl;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Resteasy;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.KeycloakTransaction;+import org.keycloak.services.resources.KeycloakApplication;+import org.slf4j.Logger;+import org.slf4j.LoggerFactory;++import javax.annotation.Priority;+import javax.inject.Inject;+import javax.ws.rs.container.ContainerRequestContext;+import javax.ws.rs.container.ContainerResponseContext;+import javax.ws.rs.container.PreMatching;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.NewCookie;+import javax.ws.rs.ext.Provider;+import java.io.IOException;+import java.util.ArrayList;+++@PreMatching+@Provider+@Priority(1)+public class QuarkusFilter implements javax.ws.rs.container.ContainerRequestFilter,+        javax.ws.rs.container.ContainerResponseFilter  {++    private static final Logger LOGGER = LoggerFactory.getLogger(""QuarkusFilter"");",Maybe just use QuarkusFilter.class.getName() here ?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6600,358392132,2019-12-16T18:26:20Z,quarkus/extensions/src/main/java/org/keycloak/provider/quarkus/QuarkusFilter.java,"@@ -0,0 +1,159 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.provider.quarkus;++import io.vertx.core.http.HttpServerRequest;+import org.jboss.resteasy.core.interception.jaxrs.ContainerResponseContextImpl;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Resteasy;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.KeycloakTransaction;+import org.keycloak.services.resources.KeycloakApplication;+import org.slf4j.Logger;+import org.slf4j.LoggerFactory;++import javax.annotation.Priority;+import javax.inject.Inject;+import javax.ws.rs.container.ContainerRequestContext;+import javax.ws.rs.container.ContainerResponseContext;+import javax.ws.rs.container.PreMatching;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.NewCookie;+import javax.ws.rs.ext.Provider;+import java.io.IOException;+import java.util.ArrayList;+++@PreMatching+@Provider+@Priority(1)+public class QuarkusFilter implements javax.ws.rs.container.ContainerRequestFilter,+        javax.ws.rs.container.ContainerResponseFilter  {","I'm not sure whether or not a `ContainerResponseFilter` is invoked if an exception is thrown by applications. If not, we won't be able to perform the `ending` aspects of this filter such as cleaning up sessions, transactions, etc.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6353,358876730,2019-12-17T16:00:11Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -15,21 +15,187 @@  */  import * as React from 'react';- +import { AxiosResponse } from 'axios';++import {+  DataList,+  DataListItem,+  DataListItemRow,+  DataListCell,+  DataListToggle,+  DataListContent,+  DataListItemCells,+  Grid,+  GridItem,+} from '@patternfly/react-core';++import { InfoAltIcon, CheckIcon, LinkIcon, BuilderImageIcon } from '@patternfly/react-icons';+import { ContentPage } from '../ContentPage';+import { ContinueCancelModal } from '../../widgets/ContinueCancelModal';+import { AccountServiceClient } from '../../account-service/account.service';+import {Msg} from '../../widgets/Msg';+ export interface ApplicationsPageProps { }- -export class ApplicationsPage extends React.Component<ApplicationsPageProps> {-    -    public constructor(props: ApplicationsPageProps) {-        super(props);-    }--    public render(): React.ReactNode {-        return (-            <div>-              <h2>Hello Applications Page</h2>-            </div>-        );-    }-};\ No newline at end of file++export interface ApplicationsPageState {+  isRowOpen: boolean[];+  applications: Application[];+}++export interface GrantedScope {+  displayTest: string;+  id: string;+  name: string;+}++export interface Consent {+  createDate: number;+  grantedScopes: GrantedScope[];+  lastUpdatedDate: number;+}++interface Application {+  baseUrl: string;+  clientId: string;+  clientName: string;+  consent: Consent;+  description: string;+  inUse: boolean;+  offlineAccess: boolean;+  userConsentRequired: boolean;+  scope: string[];+}++export class ApplicationsPage extends React.Component<ApplicationsPageProps, ApplicationsPageState> {++  public constructor(props: ApplicationsPageProps) {+    super(props);+    this.state = {+      isRowOpen: [],+      applications: []+    };++    this.fetchApplications();+  }++  private removeConsent = (clientId: string) => {+    AccountServiceClient.Instance.doDelete(""/applications/"" + clientId + ""/consent"")+      .then(() => {+        this.fetchApplications();+      });+  }++  private onToggle = (row: number): void => {+    const newIsRowOpen: boolean[] = this.state.isRowOpen;+    newIsRowOpen[row] = !newIsRowOpen[row];+    this.setState({ isRowOpen: newIsRowOpen });+  };++  private fetchApplications(): void {+    AccountServiceClient.Instance.doGet(""/applications"")+      .then((response: AxiosResponse<Application[]>) => {+        const applications = response.data;+        this.setState({+          isRowOpen: new Array(applications.length).fill(false),+          applications: applications+        });+      });+  }++  public render(): React.ReactNode {+    return (+      <ContentPage title={Msg.localize('applicationsPageTitle')}>+        <DataList id=""applications-list"" aria-label={Msg.localize('applicationsPageTitle')}>+          {this.state.applications.map((application: Application, appIndex: number) => {+            return (+              <DataListItem key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>+                <DataListItemRow>+                  <DataListToggle+                    onClick={() => this.onToggle(appIndex)}+                    isExpanded={this.state.isRowOpen[appIndex]}+                    id={'applicationToggle' + appIndex}+                    aria-controls=""expandable""+                  />+                  <DataListItemCells+                    dataListCells={[+                      <DataListCell width={2} key={'app-' + appIndex}>+                        <span><BuilderImageIcon size='sm'/> {application.clientName ? application.clientName : application.clientId}</span>+                      </DataListCell>,+                      <DataListCell width={2} key={'internal-' + appIndex}>+                        <span>{application.userConsentRequired ? Msg.localize('thirdPartyApp') : Msg.localize('internalApp')}+                          {application.offlineAccess ? ', ' + Msg.localize('offlineAccess') : ''}+                        </span>+                      </DataListCell>,+                      <DataListCell width={2} key={'status-' + appIndex}>+                        <span>{application.inUse ? Msg.localize('inUse') : Msg.localize('notInUse')}</span>+                      </DataListCell>,+                      <DataListCell width={4} key={'baseUrl-' + appIndex}>+                        <a href={application.userConsentRequired ? application.baseUrl : '/auth' + application.baseUrl} target=""_blank""><LinkIcon /> {application.baseUrl}</a>+                      </DataListCell>,+                    ]}+                  />+                </DataListItemRow>+                <DataListContent+                  noPadding={false}+                  aria-label={Msg.localize('applicationDetails')}+                  id=""expandable""+                  isHidden={!this.state.isRowOpen[appIndex]}+                >+                  <Grid sm={12} md={12} lg={12}>+                    <GridItem><b>{Msg.localize('client') + ': '}</b> {application.clientId}</GridItem>","We need to use `<strong>` here instead of `<b>`.  `<b>` is not understood by pf-c-content.Also, any ordinary HTML blocks need to be surrounded with `<div className='pf-c-content'></div>`.  This allows global styling of the text by overriding PatternFly CSS variables.I just realized that we've been doing this wrong throughout our code.See https://pf4.patternfly.org/documentation/core/components/content",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6561,359313417,2019-12-18T12:18:51Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCWellKnownProvider.java,"@@ -140,11 +142,7 @@ public void close() {     }      private static List<String> list(String... values) {-        List<String> s = new LinkedList<>();-        for (String v : values) {-            s.add(v);-        }-        return s;+        return new LinkedList<>(Arrays.asList(values));","the method returns a List, so the expectation is that it returns a list and doesn't have to be a LinkedList.",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/6520,359457810,2019-12-18T16:55:26Z,services/src/main/java/org/keycloak/protocol/saml/mappers/SAMLLoginResponseMapper.java,"@@ -29,6 +29,7 @@  */ public interface SAMLLoginResponseMapper { +     ResponseType transformLoginResponse(ResponseType response, ProtocolMapperModel mappingModel, KeycloakSession session,-                                        UserSessionModel userSession, AuthenticatedClientSessionModel clientSession);+                                        UserSessionModel userSession, ClientSessionContext clientSessionCtx);","This change is because the audience resolve mapper needs to compute the groups of the user in each client (the resolve mapper duplicates the OIDC behavior, and the clientId is added in the audience if the user has at least one group in that client). So for that I re-used the [clientSessionCtx.getRoles()](https://github.com/keycloak/keycloak/pull/6520/files#diff-ec80ecf52bea4386f9a2e6e04c51d6b1R85) method. This class is also passed to the [SAMLRoleListMapper](https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/saml/mappers/SAMLRoleListMapper.java#L32). If I hadn't passed it I would have needed to calculate groups again (repeating code and calculation), as I saw no mapper used this interface I decided to modify it (the previous AuthenticatedClientSessionModel can also be accessed through the ClientSessionContext).",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6606,359855916,2019-12-19T13:22:41Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/filter/KeycloakPreAuthActionsFilter.java,"@@ -78,7 +79,16 @@ public void doFilter(ServletRequest request, ServletResponse response, FilterCha             throws IOException, ServletException {          HttpFacade facade = new SimpleHttpFacade((HttpServletRequest)request, (HttpServletResponse)response);-        nodesRegistrationManagement.tryRegister(deploymentContext.resolveDeployment(facade));+        KeycloakDeployment deployment = deploymentContext.resolveDeployment(facade);+        +        if (deployment == null) {+            return;+        }++        if (deployment.isConfigured()) {","This will stop other things from being executed won't it? So shouldn't it just be ""if (deployment != null && deployment.isConfigured()"" instead of the check above that returns without continuing the chain.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6606,359976715,2019-12-19T17:24:05Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/filter/KeycloakPreAuthActionsFilter.java,"@@ -78,7 +79,16 @@ public void doFilter(ServletRequest request, ServletResponse response, FilterCha             throws IOException, ServletException {          HttpFacade facade = new SimpleHttpFacade((HttpServletRequest)request, (HttpServletResponse)response);-        nodesRegistrationManagement.tryRegister(deploymentContext.resolveDeployment(facade));+        KeycloakDeployment deployment = deploymentContext.resolveDeployment(facade);+        +        if (deployment == null) {+            return;+        }++        if (deployment.isConfigured()) {","Other filters in the chain always expect a deployment instance. The chain continues as long as you have a deployment 9configured or not), which is the expected behavior. ",
1739159,dometec,https://api.github.com/repos/keycloak/keycloak/pulls/6616,360337821,2019-12-20T11:39:43Z,services/src/main/java/org/keycloak/email/freemarker/FreeMarkerEmailTemplateProvider.java,"@@ -217,13 +219,19 @@ protected EmailTemplate processTemplate(String subjectKey, List<Object> subjectA                 textBody = freeMarker.processTemplate(attributes, textTemplate, theme);             } catch (final FreeMarkerException e) {                 textBody = null;+                logger.warn(""Failed to template plain text email."", e);             }             String htmlTemplate = String.format(""html/%s"", template);             String htmlBody;             try {                 htmlBody = freeMarker.processTemplate(attributes, htmlTemplate, theme);             } catch (final FreeMarkerException e) {                 htmlBody = null;+                logger.warn(""Failed to template html email."", e);","The same above, but vice-versa, I prefer to receive an email in plain text if html is broken.The exception is raised only if both fail.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6616,360354571,2019-12-20T12:35:27Z,services/src/main/java/org/keycloak/email/freemarker/FreeMarkerEmailTemplateProvider.java,"@@ -217,13 +219,19 @@ protected EmailTemplate processTemplate(String subjectKey, List<Object> subjectA                 textBody = freeMarker.processTemplate(attributes, textTemplate, theme);             } catch (final FreeMarkerException e) {                 textBody = null;+                logger.warn(""Failed to template plain text email."", e);","Keycloak expects to send both text/html emails, so if it can't process both templates that is still an error and should be handled as such. Not throwing the exception can lead to situations where people believe the templates are working, but they are not.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6601,360512250,2019-12-20T18:31:46Z,services/src/main/java/org/keycloak/authorization/admin/PolicyService.java,"@@ -176,6 +176,7 @@ public Response findAll(@QueryParam(""policyId"") String id,                             @QueryParam(""scope"") String scope,                             @QueryParam(""permission"") Boolean permission,                             @QueryParam(""owner"") String owner,+                            @QueryParam(""fields"") String fields,","For now yes, but we may in the future use this parameter to let clients choose the fields they want back in the response.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6618,360514787,2019-12-20T18:39:27Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/UserInfoEndpoint.java,"@@ -140,6 +141,8 @@ private Response issueUserInfo(String tokenString) {             token = verifier.verify().getToken();         } catch (VerificationException e) {             event.error(Errors.INVALID_TOKEN);+            // See: https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError+            response.getOutputHeaders().put(HttpHeaders.WWW_AUTHENTICATE, Collections.singletonList(String.format(""Bearer realm=\""%s\"", error=\""%s\"", error_description=\""%s\"""", realm.getName(), OAuthErrorException.INVALID_TOKEN, e.getMessage())));","I'm not sure about pushing `e.getMessage` into `error_description`. Although I think the exception thrown by the verifier does not expose details about the runtime, it may happen.Maybe just description `Token verification failed` is enough.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6595,361731039,2019-12-27T19:28:43Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/authz/EntitlementAPITest.java,"@@ -233,6 +233,7 @@ public void testInvalidRequestWithClaimsFromPublicClient() throws IOException {          try {             getAuthzClient(AUTHZ_CLIENT_CONFIG).authorization(response.getAccessToken()).authorize(request);+            fail(""Should fail, public clients not allowed"");",We've been trying to avoid these constructs when testing expected exceptions and instead use the JUnit ExpectedException rule. See https://github.com/keycloak/keycloak/blob/master/wildfly/extensions/src/test/java/org/keycloak/vault/ElytronCSKeyStoreProviderTest.java as an example.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6595,361731101,2019-12-27T19:28:56Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/authz/EntitlementAPITest.java,"@@ -1922,6 +1923,64 @@ public void testUsingExpiredToken() throws Exception {         }     } +    @Test+    public void testDenyScopeNotManagedByScopePolicy() throws Exception {+        ClientResource client = getClient(getRealm(), RESOURCE_SERVER_TEST);+        AuthorizationResource authorization = client.authorization();++        JSPolicyRepresentation policy = new JSPolicyRepresentation();++        policy.setName(KeycloakModelUtils.generateId());+        policy.setCode(""$evaluation.grant();"");++        authorization.policies().js().create(policy).close();++        ResourceRepresentation resource = new ResourceRepresentation();++        resource.setName(KeycloakModelUtils.generateId());+        resource.addScope(""sensors:view"", ""sensors:update"", ""sensors:delete"");++        try (Response response = authorization.resources().create(resource)) {+            resource = response.readEntity(ResourceRepresentation.class);+        }++        ScopePermissionRepresentation permission = new ScopePermissionRepresentation();++        permission.setName(KeycloakModelUtils.generateId());+        permission.addResource(resource.getId());+        permission.addScope(""sensors:view"");+        permission.addPolicy(policy.getName());++        authorization.permissions().scope().create(permission).close();++        String accessToken = new OAuthClient().realm(""authz-test"").clientId(RESOURCE_SERVER_TEST).doGrantAccessTokenRequest(""secret"", ""kolo"", ""password"").getAccessToken();+        AuthzClient authzClient = getAuthzClient(AUTHZ_CLIENT_CONFIG);+        AuthorizationRequest request = new AuthorizationRequest();++        request.addPermission(resource.getId(), ""sensors:view"");++        AuthorizationResponse response = authzClient.authorization(accessToken).authorize(request);+        assertNotNull(response.getToken());+        Collection<Permission> permissions = toAccessToken(response.getToken()).getAuthorization().getPermissions();+        assertEquals(1, permissions.size());++        for (Permission grantedPermission : permissions) {+            assertEquals(resource.getId(), grantedPermission.getResourceId());+            assertEquals(1, grantedPermission.getScopes().size());+            assertThat(grantedPermission.getScopes(), hasItem(""sensors:view""));+        }++        request = new AuthorizationRequest();+        request.addPermission(resource.getId(), ""sensors:update"");++        try {+            authzClient.authorization().authorize(request);+            fail(""should fail, session invalidated"");",Same as above re. exceptions.,
46450505,maxbes,https://api.github.com/repos/keycloak/keycloak/pulls/6628,361988904,2019-12-30T13:42:55Z,services/src/main/java/org/keycloak/services/resources/admin/permissions/UserPermissions.java,"@@ -398,7 +398,26 @@ public boolean canImpersonate() {             return false;         } -        return canImpersonate(new DefaultEvaluationContext(identity, session));++        EvaluationContext context;++        ClientModel client = root.adminAuth().getClient();++        if (client!=null) {+        context = new DefaultEvaluationContext(identity, session) {+            @Override+            public Map<String, Collection<String>> getBaseAttributes() {+                Map<String, Collection<String>> attributes = super.getBaseAttributes();+                attributes.put(""kc.client.id"", Arrays.asList(client.getClientId()));","I'm not sure I understand what you're suggesting, in the current state of the code, kc.client.id already mean different things depending on the context the policy engine is being used in. It already corresponds to the calling client ID in the context of other token exchanges:https://github.com/keycloak/keycloak/blob/160f2dab06ddb8743992c37f1a4afae7a8e6cece/services/src/main/java/org/keycloak/services/resources/admin/permissions/UserPermissions.java#L344https://github.com/keycloak/keycloak/blob/160f2dab06ddb8743992c37f1a4afae7a8e6cece/services/src/main/java/org/keycloak/services/resources/admin/permissions/IdentityProviderPermissions.java#L187https://github.com/keycloak/keycloak/blob/160f2dab06ddb8743992c37f1a4afae7a8e6cece/services/src/main/java/org/keycloak/services/resources/admin/permissions/ClientPermissions.java#L345and to the holder in other context (through DefaultEvaluationContext)So if I add a new field, say, `kc.exchanging-client.id`, I would have to create a new policy type, say, ""Exchanging Client Policy"" in the UI, but it means that for some token exchange types (internal-to-internal, naked impersonation), users would have to use the old ""Client Policy"" to filter on calling client ID, and for non-naked impersonation, they would have to use a new ""Exchanging Client Policy"".",
55751016,thielef,https://api.github.com/repos/keycloak/keycloak/pulls/6575,362459862,2020-01-02T12:39:06Z,themes/src/main/resources-product/theme/rh-sso/admin/theme.properties,"@@ -1,3 +1,4 @@ parent=keycloak import=common/rh-sso-styles=node_modules/rcue/dist/css/rcue.min.css node_modules/rcue/dist/css/rcue-additions.min.css node_modules/select2/select2.css css/styles.css lib/angular/treeview/css/angular.treeview.css node_modules/text-security/dist/text-security.css+styles=node_modules/rcue/dist/css/rcue.min.css node_modules/rcue/dist/css/rcue-additions.min.css node_modules/ui-select/dist/select.css node_modules/select2/dist/css/select2.css css/styles.css lib/angular/treeview/css/angular.treeview.css node_modules/text-security/dist/text-security.css","> I'm not sure with this one, but do we really need to specify the select2 styles here again? Isn't it inherited from Keycloak theme?Hi, @vmuzikar, You might be right. But for whatever reason this has never been cleaned up, not even with the last patternfly changes of @stianst .",X
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6609,363308215,2020-01-06T14:09:54Z,themes/src/main/resources/theme/base/admin/resources/partials/client-detail.html,"@@ -37,6 +37,13 @@                 </div>                 <kc-tooltip>{{:: 'client.enabled.tooltip' | translate}}</kc-tooltip>             </div>+            <div class=""form-group clearfix block"" data-ng-show=""serverInfo.featureEnabled('ACCOUNT2')"">","@douglaspalmer @abstractj Yes, bearer only clients need to be handled properly in the UI.  I think it will need a trigger so that it sets alwaysDisplayInConsole to false and hides the selection whenever bearer-only is set.I'm not sure about the ""no base url"" thing.  Are we unable to show in account console if there is no base url?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6638,363798090,2020-01-07T15:19:09Z,model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java,"@@ -147,8 +152,9 @@ public void setAttribute(String name, List<String> values) {         // Remove all existing         removeAttribute(name); -        // Put all new-        for (String value : values) {+        List<String> nonNullValues = values.stream().filter(Objects::nonNull).collect(Collectors.toList());",No need to realize this list into memory via `.collect`. you can either obtain a stream `iterator()` or use `Stream.forEach()`.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6432,364325618,2020-01-08T16:33:09Z,themes/pom.xml,"@@ -11,6 +11,115 @@     <artifactId>keycloak-themes</artifactId>     <name>Keycloak Themes</name>     <description/>+    <packaging>jar</packaging>++    <properties>+        <dir.common>src/main/resources/theme/keycloak/common/resources</dir.common>+        <dir.account2>src/main/resources/theme/keycloak-preview/account/resources</dir.account2>+        <args.npm.install>install -P -E --no-optional --ignore-scripts --no-shrinkwrap</args.npm.install>+    </properties>++    <build>+        <plugins>+            <plugin>+                <groupId>com.github.eirslett</groupId>+                <artifactId>frontend-maven-plugin</artifactId>+                <version>1.8.0</version>+                <executions>+                    <!-- Download NPM tools -->+                    <execution>+                        <id>setup-node</id>+                        <goals>+                            <goal>install-node-and-npm</goal>+                        </goals>+                        <phase>initialize</phase>+                    </execution>+                    <!-- Compile stuff -->+                    <execution>+                        <id>compile-account2</id>+                        <goals>+                            <goal>npm</goal>+                        </goals>+                        <phase>generate-resources</phase>+                        <configuration>+                            <workingDirectory>${dir.account2}</workingDirectory>+                            <arguments>run build --scripts-prepend-node-path</arguments>+                        </configuration>+                    </execution>+                    <!-- Download NPM packages -->+                    <execution>+                        <id>npm-install-account2</id>+                        <phase>initialize</phase>+                        <goals>+                            <goal>npm</goal>+                        </goals>+                        <configuration>+                            <workingDirectory>${dir.account2}</workingDirectory>+                            <arguments>${args.npm.install}</arguments>+                        </configuration>+                    </execution>+                </executions>+                <configuration>+                    <nodeVersion>v12.13.0</nodeVersion>+                    <npmVersion>6.9.0</npmVersion>+                    <installDirectory>node</installDirectory>+                </configuration>+            </plugin>+        </plugins>++        <resources>+            <resource>+                <directory>src/main/resources</directory>+                <excludes>+                    <exclude>**/node_modules/**/node_modules/**</exclude>+                    <exclude>**/minimist/**</exclude>+                    <exclude>**/mkdirp/**</exclude>+                    <exclude>**/package.json</exclude>+                    <exclude>**/bower.json</exclude>+                    <exclude>**/component.json</exclude>+                    <exclude>**/composer.json</exclude>+                    <exclude>**/npm-shrinkwrap.json</exclude>+                    <exclude>**/select2.jquery.json</exclude>+                    <exclude>**/*.markdown</exclude>+                    <exclude>**/*.swf</exclude>+                    <exclude>**/*.sh</exclude>+                    <exclude>**/.bin/**</exclude>+                    <exclude>**/bin/**</exclude>+                    <exclude>**/build/**</exclude>+                    <exclude>**/docs/**</exclude>+                    <exclude>**/demo/**</exclude>+                    <exclude>**/devtools/**</exclude>+                    <exclude>**/example/**</exclude>+                    <exclude>**/examples/**</exclude>+                    <exclude>**/grunt/**</exclude>+                    <exclude>**/less/**</exclude>+                    <exclude>**/sass/**</exclude>+                    <exclude>**/scss/**</exclude>+                    <exclude>**/jquery/src/**</exclude>+                    <exclude>**/angular-treeview/src/**</exclude>+                    <exclude>**/test/**</exclude>+                    <exclude>**/tests/**</exclude>+                    <exclude>**/_config.yml</exclude>+                    <exclude>**/api.md</exclude>+                    <exclude>**/AUTHORS.txt</exclude>+                    <exclude>**/CHANGELOG.md</exclude>+                    <exclude>**/CONTRIBUTING.md</exclude>+                    <exclude>**/HELP-US-OUT.txt</exclude>+                    <exclude>**/README.md</exclude>+                    <exclude>**/Gruntfile.js</exclude>+                    <exclude>**/Gemfile*</exclude>+                    <exclude>**/index.js</exclude>",I'd remove this if possible. It seems more dependencies (not just patternfly/react) rely on an `index.js` (e.g. exenv) and without it the Account Console doesn't work.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6609,364639662,2020-01-09T09:39:02Z,themes/src/main/resources/theme/base/admin/resources/partials/client-detail.html,"@@ -37,6 +37,13 @@                 </div>                 <kc-tooltip>{{:: 'client.enabled.tooltip' | translate}}</kc-tooltip>             </div>+            <div class=""form-group clearfix block"" data-ng-show=""serverInfo.featureEnabled('ACCOUNT2') && accessType !== 'bearer-only'"">","Found one corner case issue.1. Let's have a bearer-only OIDC client.1. Switch that Client to SAML.  The ""always display in account console"" switch is not visible because the bearer-only flag is technically still present (even though it's not effective for SAML clients).A possible solution could probably be something like:```javascript(accessType !== 'bearer-only' || protocol == 'saml')```",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6432,364768805,2020-01-09T14:31:37Z,themes/pom.xml,"@@ -11,6 +11,115 @@     <artifactId>keycloak-themes</artifactId>     <name>Keycloak Themes</name>     <description/>+    <packaging>jar</packaging>++    <properties>+        <dir.common>src/main/resources/theme/keycloak/common/resources</dir.common>+        <dir.account2>src/main/resources/theme/keycloak-preview/account/resources</dir.account2>+        <args.npm.install>install -P -E --no-optional --ignore-scripts --no-shrinkwrap</args.npm.install>+    </properties>++    <build>+        <plugins>+            <plugin>+                <groupId>com.github.eirslett</groupId>+                <artifactId>frontend-maven-plugin</artifactId>+                <version>1.8.0</version>+                <executions>+                    <!-- Download NPM tools -->+                    <execution>+                        <id>setup-node</id>+                        <goals>+                            <goal>install-node-and-npm</goal>+                        </goals>+                        <phase>initialize</phase>+                    </execution>+                    <!-- Compile stuff -->+                    <execution>+                        <id>compile-account2</id>+                        <goals>+                            <goal>npm</goal>+                        </goals>+                        <phase>generate-resources</phase>+                        <configuration>+                            <workingDirectory>${dir.account2}</workingDirectory>+                            <arguments>run build --scripts-prepend-node-path</arguments>+                        </configuration>+                    </execution>+                    <!-- Download NPM packages -->+                    <execution>+                        <id>npm-install-account2</id>+                        <phase>initialize</phase>+                        <goals>+                            <goal>npm</goal>+                        </goals>+                        <configuration>+                            <workingDirectory>${dir.account2}</workingDirectory>+                            <arguments>${args.npm.install}</arguments>+                        </configuration>+                    </execution>+                </executions>+                <configuration>+                    <nodeVersion>v12.13.0</nodeVersion>+                    <npmVersion>6.9.0</npmVersion>+                    <installDirectory>node</installDirectory>+                </configuration>+            </plugin>+        </plugins>++        <resources>+            <resource>+                <directory>src/main/resources</directory>+                <excludes>+                    <exclude>**/node_modules/**/node_modules/**</exclude>+                    <exclude>**/minimist/**</exclude>+                    <exclude>**/mkdirp/**</exclude>+                    <exclude>**/package.json</exclude>+                    <exclude>**/bower.json</exclude>+                    <exclude>**/component.json</exclude>+                    <exclude>**/composer.json</exclude>+                    <exclude>**/npm-shrinkwrap.json</exclude>+                    <exclude>**/select2.jquery.json</exclude>+                    <exclude>**/*.markdown</exclude>+                    <exclude>**/*.swf</exclude>+                    <exclude>**/*.sh</exclude>+                    <exclude>**/.bin/**</exclude>+                    <exclude>**/bin/**</exclude>+                    <exclude>**/build/**</exclude>+                    <exclude>**/docs/**</exclude>+                    <exclude>**/demo/**</exclude>+                    <exclude>**/devtools/**</exclude>+                    <exclude>**/example/**</exclude>+                    <exclude>**/examples/**</exclude>+                    <exclude>**/grunt/**</exclude>+                    <exclude>**/less/**</exclude>+                    <exclude>**/sass/**</exclude>+                    <exclude>**/scss/**</exclude>+                    <exclude>**/jquery/src/**</exclude>+                    <exclude>**/angular-treeview/src/**</exclude>+                    <exclude>**/test/**</exclude>+                    <exclude>**/tests/**</exclude>+                    <exclude>**/_config.yml</exclude>+                    <exclude>**/api.md</exclude>+                    <exclude>**/AUTHORS.txt</exclude>+                    <exclude>**/CHANGELOG.md</exclude>+                    <exclude>**/CONTRIBUTING.md</exclude>+                    <exclude>**/HELP-US-OUT.txt</exclude>+                    <exclude>**/README.md</exclude>+                    <exclude>**/Gruntfile.js</exclude>+                    <exclude>**/Gemfile*</exclude>+                    <exclude>**/index.js</exclude>","Yes, but this way we'll need to manually pick those index.js files that are really required by some of our (transitive) dependencies. And that is IMHO quite a big hassle, mainly when e.g. updating dependencies or introducing new ones. Every time we'll need to manually investigate whether this or that index.js is really required.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6432,364786566,2020-01-09T15:02:19Z,themes/pom.xml,"@@ -11,6 +11,115 @@     <artifactId>keycloak-themes</artifactId>     <name>Keycloak Themes</name>     <description/>+    <packaging>jar</packaging>++    <properties>+        <dir.common>src/main/resources/theme/keycloak/common/resources</dir.common>+        <dir.account2>src/main/resources/theme/keycloak-preview/account/resources</dir.account2>+        <args.npm.install>install -P -E --no-optional --ignore-scripts --no-shrinkwrap</args.npm.install>+    </properties>++    <build>+        <plugins>+            <plugin>+                <groupId>com.github.eirslett</groupId>+                <artifactId>frontend-maven-plugin</artifactId>+                <version>1.8.0</version>+                <executions>+                    <!-- Download NPM tools -->+                    <execution>+                        <id>setup-node</id>+                        <goals>+                            <goal>install-node-and-npm</goal>+                        </goals>+                        <phase>initialize</phase>+                    </execution>+                    <!-- Compile stuff -->+                    <execution>+                        <id>compile-account2</id>+                        <goals>+                            <goal>npm</goal>+                        </goals>+                        <phase>generate-resources</phase>+                        <configuration>+                            <workingDirectory>${dir.account2}</workingDirectory>+                            <arguments>run build --scripts-prepend-node-path</arguments>+                        </configuration>+                    </execution>+                    <!-- Download NPM packages -->+                    <execution>+                        <id>npm-install-account2</id>+                        <phase>initialize</phase>+                        <goals>+                            <goal>npm</goal>+                        </goals>+                        <configuration>+                            <workingDirectory>${dir.account2}</workingDirectory>+                            <arguments>${args.npm.install}</arguments>+                        </configuration>+                    </execution>+                </executions>+                <configuration>+                    <nodeVersion>v12.13.0</nodeVersion>+                    <npmVersion>6.9.0</npmVersion>+                    <installDirectory>node</installDirectory>+                </configuration>+            </plugin>+        </plugins>++        <resources>+            <resource>+                <directory>src/main/resources</directory>+                <excludes>+                    <exclude>**/node_modules/**/node_modules/**</exclude>+                    <exclude>**/minimist/**</exclude>+                    <exclude>**/mkdirp/**</exclude>+                    <exclude>**/package.json</exclude>+                    <exclude>**/bower.json</exclude>+                    <exclude>**/component.json</exclude>+                    <exclude>**/composer.json</exclude>+                    <exclude>**/npm-shrinkwrap.json</exclude>+                    <exclude>**/select2.jquery.json</exclude>+                    <exclude>**/*.markdown</exclude>+                    <exclude>**/*.swf</exclude>+                    <exclude>**/*.sh</exclude>+                    <exclude>**/.bin/**</exclude>+                    <exclude>**/bin/**</exclude>+                    <exclude>**/build/**</exclude>+                    <exclude>**/docs/**</exclude>+                    <exclude>**/demo/**</exclude>+                    <exclude>**/devtools/**</exclude>+                    <exclude>**/example/**</exclude>+                    <exclude>**/examples/**</exclude>+                    <exclude>**/grunt/**</exclude>+                    <exclude>**/less/**</exclude>+                    <exclude>**/sass/**</exclude>+                    <exclude>**/scss/**</exclude>+                    <exclude>**/jquery/src/**</exclude>+                    <exclude>**/angular-treeview/src/**</exclude>+                    <exclude>**/test/**</exclude>+                    <exclude>**/tests/**</exclude>+                    <exclude>**/_config.yml</exclude>+                    <exclude>**/api.md</exclude>+                    <exclude>**/AUTHORS.txt</exclude>+                    <exclude>**/CHANGELOG.md</exclude>+                    <exclude>**/CONTRIBUTING.md</exclude>+                    <exclude>**/HELP-US-OUT.txt</exclude>+                    <exclude>**/README.md</exclude>+                    <exclude>**/Gruntfile.js</exclude>+                    <exclude>**/Gemfile*</exclude>+                    <exclude>**/index.js</exclude>","Thinking about this more. Maybe this is more of a generic question what to really include in the distribution. Couldn't this be somehow derived from [systemjs.config.js](https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/keycloak-preview/account/resources/systemjs.config.js)? @ssilvert?npm surely downloads lots of ""garbage"" and we need only a few files.On the other hand this is basically an optimization task. Couldn't this be perhaps done after the tech preview?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6339,365166036,2020-01-10T10:22:54Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -131,12 +136,17 @@ public Response createUser(final UserRepresentation rep) {                 session.getTransactionManager().setRollbackOnly();             }             return ErrorResponse.exists(""User exists with same username or email"");+        } catch (PasswordPolicyNotMetException e) {+            if (session.getTransactionManager().isActive()) {+                session.getTransactionManager().setRollbackOnly();+            }+            return ErrorResponse.error(""Password policy not met for user "" + username, Response.Status.BAD_REQUEST);         } catch (ModelException me){             if (session.getTransactionManager().isActive()) {                 session.getTransactionManager().setRollbackOnly();             }             logger.warn(""Could not create user"", me);-            return ErrorResponse.exists(""Could not create user"");+            return ErrorResponse.error(me.getMessage(), Response.Status.BAD_REQUEST);","It will be good to display some generic error message, but not add exception message to the response. In case that exception message would contain some user-provided data and the error response is later shown on the HTML page, various kind of attacks (eg XSS) can happen",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6432,365221269,2020-01-10T12:56:46Z,themes/pom.xml,"@@ -40,129 +139,35 @@             </activation>             <build>                 <resources>-                    <resource>-                        <directory>src/main/resources</directory>-                    </resource>                     <resource>                         <directory>src/main/resources-product</directory>                     </resource>                 </resources>-                <plugins>-                    <plugin>-                        <artifactId>maven-jar-plugin</artifactId>-                        <configuration>-                            <excludes>-                                <exclude>**/keycloak-preview/**</exclude>-                            </excludes>-                        </configuration>-                    </plugin>-                </plugins>-            </build>-        </profile>-        -        <profile>-            <id>account2</id>-            <build>-                <plugins>-                    <plugin>-                        <groupId>com.github.eirslett</groupId>-                        <artifactId>frontend-maven-plugin</artifactId>-                        <executions>-                            <execution>-                                <id>install node and npm</id>-                                <goals>-                                    <goal>install-node-and-npm</goal>-                                </goals>-                                <phase>generate-resources</phase>-                                <configuration>-                                    <nodeVersion>v8.9.4</nodeVersion>-                                </configuration>-                            </execution>-                            <execution>-                                <id>npm install</id>-                                <goals>-                                    <goal>npm</goal>-                                </goals>-                                <phase>generate-resources</phase>-                                <configuration>-                                    <arguments>install</arguments>-                                </configuration>-                            </execution>-                            <execution>-                                <id>compile typescript</id>-                                <goals>-                                    <goal>npm</goal>-                                </goals>-                                <phase>compile</phase>-                                <configuration>-                                    <arguments>run build</arguments>-                                </configuration>-                            </execution>-                            <execution>-                                <id>npm remove dev dependencies production=true</id>-                                <goals>-                                    <goal>npm</goal>-                                </goals>-                                <phase>process-classes</phase>-                                <configuration>-                                    <arguments>install --production=true --no-package-lock</arguments>-                                </configuration>-                            </execution>-                        </executions>-                        <configuration>-                            <workingDirectory>src/main/resources/theme/keycloak-preview/account/resources</workingDirectory>-                        </configuration>-                    </plugin>-                    <plugin>-                        <artifactId>maven-clean-plugin</artifactId>-                        <configuration>-                            <filesets>-                                <fileset>-                                    <directory>src/main/resources/theme/keycloak-preview/account/resources/node_modules</directory>-                                </fileset>-                                <fileset>-                                    <directory>src/main/resources/theme/keycloak-preview/account/resources/node</directory>-                                </fileset>-                            </filesets>-                        </configuration>-                    </plugin>-                </plugins>             </build>         </profile>          <profile>             <id>npm-update</id>             <build>                 <plugins>-                    <!-- Install NPM and download packages -->+                    <!-- Download packages -->                     <plugin>                         <groupId>com.github.eirslett</groupId>                         <artifactId>frontend-maven-plugin</artifactId>                         <version>1.8.0</version>                         <executions>-                            <execution>-                                <id>install-node-and-npm</id>-                                <phase>generate-resources</phase>-                                <goals>-                                    <goal>install-node-and-npm</goal>-                                </goals>-                            </execution>                             <execution>                                 <id>npm-install</id>                                 <phase>generate-resources</phase>                                 <goals>                                     <goal>npm</goal>                                 </goals>                                 <configuration>-                                    <arguments>install -P -E --no-optional --ignore-scripts --no-bin-links --no-shrinkwrap --no-package-lock</arguments>+                                    <workingDirectory>${dir.common}</workingDirectory>+                                    <arguments>${args.npm.install} --no-bin-links</arguments>","I believe we should install the common dependencies with the original arguments `install -P -E --no-optional --ignore-scripts --no-bin-links --no-shrinkwrap --no-package-lock`. Switching to `npm ci` apparently resulted in adding many more useless dependencies to the common folder. This really concerns only the common deps, new account console works fine with `npm ci`.We should touch the common dependencies as little as possible in this PR. Ideally, we shouldn't touch them at all but I understand the reason to somewhat unify the npm stuff with the new account console. (Maybe we can unify it completely in the future.)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6646,365764345,2020-01-13T11:51:26Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UserResource.java,"@@ -67,6 +68,19 @@     List<GroupRepresentation> groups(@QueryParam(""search"") String search,                                      @QueryParam(""first"") Integer firstResult,                                      @QueryParam(""max"") Integer maxResults);+    +    @Path(""groups"")+    @GET+    List<GroupRepresentation> groups(@QueryParam(""first"") Integer firstResult,+                                     @QueryParam(""max"") Integer maxResults,+                                     @QueryParam(""full"") @DefaultValue(""false"") boolean fullRepresentation);",Please use parameter name `briefRepresentation` to keep consistent with the rest of API,
12050544,Cracky5457,https://api.github.com/repos/keycloak/keycloak/pulls/6646,366327940,2020-01-14T13:10:03Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UserResource.java,"@@ -67,6 +68,19 @@     List<GroupRepresentation> groups(@QueryParam(""search"") String search,                                      @QueryParam(""first"") Integer firstResult,                                      @QueryParam(""max"") Integer maxResults);+    +    @Path(""groups"")+    @GET+    List<GroupRepresentation> groups(@QueryParam(""first"") Integer firstResult,+                                     @QueryParam(""max"") Integer maxResults,+                                     @QueryParam(""full"") @DefaultValue(""false"") boolean fullRepresentation);",Fixed. Should we fixe all the full parameters in this issue ? because it had common change with other endpoint for the method toRepresentation,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6646,366347740,2020-01-14T13:50:56Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java,"@@ -1668,4 +1675,35 @@ public void testDeleteCredentials() {         user.resetPassword(credPasswd);         Assert.assertEquals(1, user.credentials().size());     }+    +    @Test+    public void testGetGroupsForUserFullRepresentation() {+       +        RealmResource realm = adminClient.realms().realm(""test"");+        GroupsResource groups = realm.groups();+        +        String userName = ""brief-grouptest-user"";+        String groupName = ""groupWithAttribute"";+        Map<String, List<String>> attributes = new HashMap<String, List<String>>();+        attributes.put(""attribute1"", Arrays.asList(""attribute1"",""attribute2""));+        +        try (Response response = groups.add(GroupBuilder.create().name(groupName).attributes(attributes).build())) {+            String groupId = ApiUtil.getCreatedId(response);+            +            UsersResource users = realm.users();++            UserRepresentation userRepresentation = UserBuilder.create()","It seems this user is never removed. You can use Creator.create(RealmResource, UserRepresentation) that handles cleanup automatically, see e.g. https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/SAMLServletAdapterTest.java#L924. Feel free to use Creator.create(RealmResource, GroupRepresentation) for group similarly.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6649,366580646,2020-01-14T21:26:40Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/WebAuthnPasswordlessAuthenticator.java,"@@ -0,0 +1,75 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.authentication.authenticators.browser;++import java.util.Collections;+import java.util.List;++import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.RequiredActionFactory;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.authentication.requiredactions.WebAuthnPasswordlessRegisterFactory;+import org.keycloak.credential.CredentialProvider;+import org.keycloak.credential.WebAuthnPasswordlessCredentialProvider;+import org.keycloak.credential.WebAuthnPasswordlessCredentialProviderFactory;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.WebAuthnPolicy;+import org.keycloak.models.credential.WebAuthnCredentialModel;++/**+ * Authenticator for WebAuthn authentication with passwordless credential. This class is temporary and will be likely+ * removed in the future during future improvements in authentication SPI+ */+public class WebAuthnPasswordlessAuthenticator extends WebAuthnAuthenticator {++    public WebAuthnPasswordlessAuthenticator(KeycloakSession session) {+        super(session);+    }++    @Override+    protected WebAuthnPolicy getWebAuthnPolicy(AuthenticationFlowContext context) {+        return context.getRealm().getWebAuthnPolicyPasswordless();+    }++    @Override+    protected String getCredentialType() {+        return WebAuthnCredentialModel.TYPE_PASSWORDLESS;+    }++    @Override+    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {+        // ask the user to do required action to register webauthn authenticator+        if (!user.getRequiredActions().contains(WebAuthnPasswordlessRegisterFactory.PROVIDER_ID)) {+            user.addRequiredAction(WebAuthnPasswordlessRegisterFactory.PROVIDER_ID);+        }+    }++    @Override+    public List<RequiredActionFactory> getRequiredActions(KeycloakSession session) {+        return Collections.singletonList((WebAuthnPasswordlessRegisterFactory)session.getKeycloakSessionFactory().getProviderFactory(RequiredActionProvider.class, WebAuthnPasswordlessRegisterFactory.PROVIDER_ID));+    }+++    public WebAuthnPasswordlessCredentialProvider getCredentialProvider(KeycloakSession session) {","Thanks, the only reason why I kept this method was, that I originally worked on this on top of the other branch for introduce ""Try another way"" link. That task changed some stuff in WebAuthnAuthenticator class (added CredentialValidator as an implementing interface among other things).Now that other PR is merged in Keycloak master, which means that the method ""getCredentialProvider"" became to be used :) I needed to do few more very small changes in the WebAuthnAuthenticator and WebAuthnPasswordlessAuthenticator class. Do you have a chance to re-review?",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/6658,367428466,2020-01-16T13:54:01Z,adapters/oidc/js/src/main/resources/login-status-iframe.html,"@@ -81,7 +81,16 @@      function getCookie()     {-        var name = 'KEYCLOAK_SESSION=';+        var cookie = getCookieByName('KEYCLOAK_SESSION');+        if (cookie === null) {+            cookie = getCookieByName('KEYCLOAK_SESSION_LEGACY');+        }+        return cookie;+    }++    function getCookieByName(name)+    {+        name = name + '=';",Where does this value end up being used? Are we sure this separator doesn't accidentally break other code that depends on the structure of the value somewhere else?,X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6658,367455050,2020-01-16T14:42:20Z,adapters/oidc/js/src/main/resources/login-status-iframe.html,"@@ -81,7 +81,16 @@      function getCookie()     {-        var name = 'KEYCLOAK_SESSION=';+        var cookie = getCookieByName('KEYCLOAK_SESSION');+        if (cookie === null) {+            cookie = getCookieByName('KEYCLOAK_SESSION_LEGACY');+        }+        return cookie;+    }++    function getCookieByName(name)+    {+        name = name + '=';","If you mean the separator `=`, we used that before so I didn't want to change that.https://github.com/keycloak/keycloak/blob/05c428f6e74de7a544587537cebeee35aae70eb4/adapters/oidc/js/src/main/resources/login-status-iframe.html#L84",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6658,367458111,2020-01-16T14:47:24Z,adapters/oidc/js/src/main/resources/login-status-iframe.html,"@@ -81,7 +81,16 @@      function getCookie()     {-        var name = 'KEYCLOAK_SESSION=';+        var cookie = getCookieByName('KEYCLOAK_SESSION');+        if (cookie === null) {+            cookie = getCookieByName('KEYCLOAK_SESSION_LEGACY');","@jonkoops I'm sorry, I got it wrong the first time. You're correct, technically there's no need to re-assign the variable. But to me it seems more clear to have only one `return` but I don't really insist on it. Do you think this impacts performance?",X
2424580,ASzc,https://api.github.com/repos/keycloak/keycloak/pulls/6432,367954256,2020-01-17T14:12:52Z,themes/pom.xml,"@@ -11,6 +11,109 @@     <artifactId>keycloak-themes</artifactId>     <name>Keycloak Themes</name>     <description/>+    <packaging>jar</packaging>++    <properties>+        <dir.common>src/main/resources/theme/keycloak/common/resources</dir.common>+        <dir.account2>src/main/resources/theme/keycloak-preview/account/resources</dir.account2>+        <args.npm.install>ci --no-optional --ignore-scripts</args.npm.install>+    </properties>++    <build>+        <plugins>+            <plugin>+                <groupId>com.github.eirslett</groupId>+                <artifactId>frontend-maven-plugin</artifactId>+                <version>1.8.0</version>","Parent POM specifies 1.5, hadn't seen that. I don't know of a specific reason to use later than that version, but since we've been using 1.8.0 [since before my PR](https://github.com/keycloak/keycloak/blob/89fc0e1fcc3df43e4a8e89c817b897f8aa9a5d60/themes/pom.xml#L141), I don't want to change that now. I'll update the parent POM's version, since the plugin isn't used anywhere but themes.The nice thing about building in PNC is it will import the third party artifacts for us, unlike Brew.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369404775,2020-01-22T07:33:53Z,services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java,"@@ -57,6 +57,139 @@ public AccountCredentialResource(KeycloakSession session, EventBuilder event, Us //        models.forEach(c -> c.setSecretData(null)); //        return models.stream().map(ModelToRepresentation::toRepresentation).collect(Collectors.toList()); //    }+    +    private static class CredentialContainer {+        private String category;+        private String type;+        private String tooltip;+        private boolean enabled;+        private String createAction;+        private String updateAction;+        private boolean removeable;+        private List<CredentialModel> userCredentials;+        +        public CredentialContainer(String category, String type, String tooltip, boolean enabled, String createAction, String updateAction, boolean removeable,List<CredentialModel> userCredentials) {+            this.category = category;+            this.type = type;+            this.tooltip = tooltip;+            this.enabled = enabled;+            this.createAction = createAction;+            this.updateAction = updateAction;+            this.removeable = removeable;+            this.userCredentials = userCredentials;+        }++        public String getCategory() {+            return category;+        }+        +        public String getType() {+            return type;+        }++        public String getTooltip() {+            return tooltip;+        }++        public boolean isEnabled() {+            return enabled;+        }++        public String getCreateAction() {+            return createAction;+        }++        public String getUpdateAction() {+            return updateAction;+        }++        public boolean isRemoveable() {+            return removeable;+        }++        public List<CredentialModel> getUserCredentials() {+            return userCredentials;+        }+        +    }+    +    @GET+    @NoCache+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)+    public List<CredentialContainer> dummyCredentialTypes(){+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);+        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);+        +        List<CredentialModel> passwordUserCreds = new java.util.ArrayList<>();+        passwordUserCreds.add(models.get(0));","This will throw an exception in case that user doesn't have password? Also in case he doesn't have password and has 1 OTP credential, it can happen that ""models.get(0)"" won't return the password.I know we're going to rewrite this stuff and it is just ""dummy"" endpoint for now. So leaving to you whether to change this or not. I am fine with accept PR even without fixing it we all agree that some temporary ""bugs"" in this dummy endpoints are ok.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369543183,2020-01-22T12:56:48Z,services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java,"@@ -57,6 +57,139 @@ public AccountCredentialResource(KeycloakSession session, EventBuilder event, Us //        models.forEach(c -> c.setSecretData(null)); //        return models.stream().map(ModelToRepresentation::toRepresentation).collect(Collectors.toList()); //    }+    +    private static class CredentialContainer {+        private String category;+        private String type;+        private String tooltip;+        private boolean enabled;+        private String createAction;+        private String updateAction;+        private boolean removeable;+        private List<CredentialModel> userCredentials;+        +        public CredentialContainer(String category, String type, String tooltip, boolean enabled, String createAction, String updateAction, boolean removeable,List<CredentialModel> userCredentials) {+            this.category = category;+            this.type = type;+            this.tooltip = tooltip;+            this.enabled = enabled;+            this.createAction = createAction;+            this.updateAction = updateAction;+            this.removeable = removeable;+            this.userCredentials = userCredentials;+        }++        public String getCategory() {+            return category;+        }+        +        public String getType() {+            return type;+        }++        public String getTooltip() {+            return tooltip;+        }++        public boolean isEnabled() {+            return enabled;+        }++        public String getCreateAction() {+            return createAction;+        }++        public String getUpdateAction() {+            return updateAction;+        }++        public boolean isRemoveable() {+            return removeable;+        }++        public List<CredentialModel> getUserCredentials() {+            return userCredentials;+        }+        +    }+    +    @GET+    @NoCache+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)+    public List<CredentialContainer> dummyCredentialTypes(){+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);+        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);+        +        List<CredentialModel> passwordUserCreds = new java.util.ArrayList<>();+        passwordUserCreds.add(models.get(0));","@mposolda I am assuming that you will take care of those things when there is live data.  As long as the data you send is in the format I expect, the UI will be able to handle it.I am only assuming that there will be at least one credential sent to me.  It doesn't matter what category or type it is.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369594837,2020-01-22T14:34:24Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -132,7 +134,10 @@ export class ApplicationsPage extends React.Component<ApplicationsPageProps, App                         {application.inUse ? Msg.localize('inUse') : Msg.localize('notInUse')}                       </DataListCell>,                       <DataListCell width={4} key={'baseUrl-' + appIndex}>-                        <a href={application.userConsentRequired ? application.baseUrl : '/auth' + application.baseUrl} target=""_blank""><LinkIcon /> {application.baseUrl}</a>+                        <button className=""pf-c-button pf-m-link"" type=""button"" onClick={() => window.location.href = appUrl}>+                          <span className=""pf-c-button__icon"">+                            <i className=""fas fa-link"" aria-hidden=""true""></i>+                          </span>{application.baseUrl}</button>","Just a question. Why are we making this change? It's not related to the Credentials page, correct? This results in links no longer being opened in new browser tab.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369604798,2020-01-22T14:50:58Z,services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java,"@@ -57,6 +57,139 @@ public AccountCredentialResource(KeycloakSession session, EventBuilder event, Us //        models.forEach(c -> c.setSecretData(null)); //        return models.stream().map(ModelToRepresentation::toRepresentation).collect(Collectors.toList()); //    }+    +    private static class CredentialContainer {+        private String category;+        private String type;+        private String tooltip;+        private boolean enabled;+        private String createAction;+        private String updateAction;+        private boolean removeable;+        private List<CredentialModel> userCredentials;+        +        public CredentialContainer(String category, String type, String tooltip, boolean enabled, String createAction, String updateAction, boolean removeable,List<CredentialModel> userCredentials) {+            this.category = category;+            this.type = type;+            this.tooltip = tooltip;+            this.enabled = enabled;+            this.createAction = createAction;+            this.updateAction = updateAction;+            this.removeable = removeable;+            this.userCredentials = userCredentials;+        }++        public String getCategory() {+            return category;+        }+        +        public String getType() {+            return type;+        }++        public String getTooltip() {+            return tooltip;+        }++        public boolean isEnabled() {+            return enabled;+        }++        public String getCreateAction() {+            return createAction;+        }++        public String getUpdateAction() {+            return updateAction;+        }++        public boolean isRemoveable() {+            return removeable;+        }++        public List<CredentialModel> getUserCredentials() {+            return userCredentials;+        }+        +    }+    +    @GET+    @NoCache+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)+    public List<CredentialContainer> dummyCredentialTypes(){+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);+        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);+        +        List<CredentialModel> passwordUserCreds = new java.util.ArrayList<>();+        passwordUserCreds.add(models.get(0));","> > I just realized the tooltips are missing.> > Actually need to discuss this a bit. Right now, tooltips are sent for each credential type. Should they also appear for each credential category?@mposolda @abstractj I think I will rename ""tooltip"" to ""helptext"".  It will be shown as plain text after the type name instead of as a tooltip.Concerning help text at the category level, with the current structure we can not have help text that belongs to the category.  This is because you can have more than one type for each category and they are sent as a category/type combo.  We would need another level of abstraction to send an attribute that belongs specifically to the category.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369686660,2020-01-22T17:04:33Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/signingin-page/SigningInPage.tsx,"@@ -68,116 +92,202 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta     public constructor(props: SigningInPageProps) {         super(props);         this.state = {-            twoFactorEnabled: true,-            twoFactorEnabledText: Msg.localize('twoFactorEnabled'),-            isTotpConfigured: features.isTotpConfigured,+            credentialContainers: new Map()         }-        this.setLastPwdUpdate();++        this.getCredentialContainers();     } -    private setLastPwdUpdate(): void {-        AccountServiceClient.Instance.doGet(""/credentials/password"")-            .then((response: AxiosResponse<PasswordDetails>) => {-                if (response.data.lastUpdate) {-                    const lastUpdate: number = response.data.lastUpdate;-                    this.setState({lastPasswordUpdate: lastUpdate});-                }+    private getCredentialContainers(): void {+        AccountServiceClient.Instance.doGet(""/credentials"")+            .then((response: AxiosResponse<CredentialContainer[]>) => {++                const allContainers: CredContainerMap = new Map();+                response.data.forEach(container => {+                    let categoryMap = allContainers.get(container.category);+                    if (!categoryMap) {+                        categoryMap = new Map();+                        allContainers.set(container.category, categoryMap);+                    }+                    categoryMap.set(container.type, container);+                });++                this.setState({credentialContainers: allContainers});             });     }     -    private handleTwoFactorSwitch = () => {-        if (this.state.twoFactorEnabled) {-            this.setState({twoFactorEnabled: false, twoFactorEnabledText: Msg.localize('twoFactorDisabled')})-        } else {-            this.setState({twoFactorEnabled: true, twoFactorEnabledText:  Msg.localize('twoFactorEnabled')})-        }-    }--    private handleRemoveTOTP = () => {-      AccountServiceClient.Instance.doDelete(""/totp/remove"")+    private handleRemove = (credentialId: string, userLabel: string) => {+      AccountServiceClient.Instance.doDelete(""/credentials/"" + credentialId)         .then(() => {-            this.setState({isTotpConfigured: false});-            ContentAlert.success('successTotpRemovedMessage');+            this.getCredentialContainers();+            ContentAlert.success('successRemovedMessage', [userLabel]);         });     }      public render(): React.ReactNode {","Just a suggestion. The two-factor authentication looks like it's an independent credential type. If I understand it correctly, it works only with password. Couldn't we somehow visually hint the user that it's not independent? E.g. somehow place it in the same box as password?Of course, for the tech preview it's ok as it is.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369690274,2020-01-22T17:11:21Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/signingin-page/SigningInPage.tsx,"@@ -68,116 +92,202 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta     public constructor(props: SigningInPageProps) {         super(props);         this.state = {-            twoFactorEnabled: true,-            twoFactorEnabledText: Msg.localize('twoFactorEnabled'),-            isTotpConfigured: features.isTotpConfigured,+            credentialContainers: new Map()         }-        this.setLastPwdUpdate();++        this.getCredentialContainers();     } -    private setLastPwdUpdate(): void {-        AccountServiceClient.Instance.doGet(""/credentials/password"")-            .then((response: AxiosResponse<PasswordDetails>) => {-                if (response.data.lastUpdate) {-                    const lastUpdate: number = response.data.lastUpdate;-                    this.setState({lastPasswordUpdate: lastUpdate});-                }+    private getCredentialContainers(): void {+        AccountServiceClient.Instance.doGet(""/credentials"")+            .then((response: AxiosResponse<CredentialContainer[]>) => {++                const allContainers: CredContainerMap = new Map();+                response.data.forEach(container => {+                    let categoryMap = allContainers.get(container.category);+                    if (!categoryMap) {+                        categoryMap = new Map();+                        allContainers.set(container.category, categoryMap);+                    }+                    categoryMap.set(container.type, container);+                });++                this.setState({credentialContainers: allContainers});             });     }     -    private handleTwoFactorSwitch = () => {-        if (this.state.twoFactorEnabled) {-            this.setState({twoFactorEnabled: false, twoFactorEnabledText: Msg.localize('twoFactorDisabled')})-        } else {-            this.setState({twoFactorEnabled: true, twoFactorEnabledText:  Msg.localize('twoFactorEnabled')})-        }-    }--    private handleRemoveTOTP = () => {-      AccountServiceClient.Instance.doDelete(""/totp/remove"")+    private handleRemove = (credentialId: string, userLabel: string) => {+      AccountServiceClient.Instance.doDelete(""/credentials/"" + credentialId)         .then(() => {-            this.setState({isTotpConfigured: false});-            ContentAlert.success('successTotpRemovedMessage');+            this.getCredentialContainers();+            ContentAlert.success('successRemovedMessage', [userLabel]);         });     }      public render(): React.ReactNode {","It looks a bit weird, or maybe too technical, that there are two ""passwords"" on top of each other. Again, IMHO ok for tech preview.![Screenshot 2020-01-22 at 18 11 47](https://user-images.githubusercontent.com/13906855/72916644-ae528180-3d42-11ea-9b92-2e77eea5a55a.png)",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369713683,2020-01-22T17:57:27Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/signingin-page/SigningInPage.tsx,"@@ -68,116 +92,202 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta     public constructor(props: SigningInPageProps) {         super(props);         this.state = {-            twoFactorEnabled: true,-            twoFactorEnabledText: Msg.localize('twoFactorEnabled'),-            isTotpConfigured: features.isTotpConfigured,+            credentialContainers: new Map()         }-        this.setLastPwdUpdate();++        this.getCredentialContainers();     } -    private setLastPwdUpdate(): void {-        AccountServiceClient.Instance.doGet(""/credentials/password"")-            .then((response: AxiosResponse<PasswordDetails>) => {-                if (response.data.lastUpdate) {-                    const lastUpdate: number = response.data.lastUpdate;-                    this.setState({lastPasswordUpdate: lastUpdate});-                }+    private getCredentialContainers(): void {+        AccountServiceClient.Instance.doGet(""/credentials"")+            .then((response: AxiosResponse<CredentialContainer[]>) => {++                const allContainers: CredContainerMap = new Map();+                response.data.forEach(container => {+                    let categoryMap = allContainers.get(container.category);+                    if (!categoryMap) {+                        categoryMap = new Map();+                        allContainers.set(container.category, categoryMap);+                    }+                    categoryMap.set(container.type, container);+                });++                this.setState({credentialContainers: allContainers});             });     }     -    private handleTwoFactorSwitch = () => {-        if (this.state.twoFactorEnabled) {-            this.setState({twoFactorEnabled: false, twoFactorEnabledText: Msg.localize('twoFactorDisabled')})-        } else {-            this.setState({twoFactorEnabled: true, twoFactorEnabledText:  Msg.localize('twoFactorEnabled')})-        }-    }--    private handleRemoveTOTP = () => {-      AccountServiceClient.Instance.doDelete(""/totp/remove"")+    private handleRemove = (credentialId: string, userLabel: string) => {+      AccountServiceClient.Instance.doDelete(""/credentials/"" + credentialId)         .then(() => {-            this.setState({isTotpConfigured: false});-            ContentAlert.success('successTotpRemovedMessage');+            this.getCredentialContainers();+            ContentAlert.success('successRemovedMessage', [userLabel]);         });     }      public render(): React.ReactNode {","> Just a suggestion. The two-factor authentication looks like it's an independent credential type. If I understand it correctly, it works only with password. Couldn't we somehow visually hint the user that it's not independent? E.g. somehow place it in the same box as password?> > Of course, for the tech preview it's ok as it is.@mposolda Do you have any feedback on this?",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369716598,2020-01-22T18:03:53Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/signingin-page/SigningInPage.tsx,"@@ -68,116 +92,202 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta     public constructor(props: SigningInPageProps) {         super(props);         this.state = {-            twoFactorEnabled: true,-            twoFactorEnabledText: Msg.localize('twoFactorEnabled'),-            isTotpConfigured: features.isTotpConfigured,+            credentialContainers: new Map()         }-        this.setLastPwdUpdate();++        this.getCredentialContainers();     } -    private setLastPwdUpdate(): void {-        AccountServiceClient.Instance.doGet(""/credentials/password"")-            .then((response: AxiosResponse<PasswordDetails>) => {-                if (response.data.lastUpdate) {-                    const lastUpdate: number = response.data.lastUpdate;-                    this.setState({lastPasswordUpdate: lastUpdate});-                }+    private getCredentialContainers(): void {+        AccountServiceClient.Instance.doGet(""/credentials"")+            .then((response: AxiosResponse<CredentialContainer[]>) => {++                const allContainers: CredContainerMap = new Map();+                response.data.forEach(container => {+                    let categoryMap = allContainers.get(container.category);+                    if (!categoryMap) {+                        categoryMap = new Map();+                        allContainers.set(container.category, categoryMap);+                    }+                    categoryMap.set(container.type, container);+                });++                this.setState({credentialContainers: allContainers});             });     }     -    private handleTwoFactorSwitch = () => {-        if (this.state.twoFactorEnabled) {-            this.setState({twoFactorEnabled: false, twoFactorEnabledText: Msg.localize('twoFactorDisabled')})-        } else {-            this.setState({twoFactorEnabled: true, twoFactorEnabledText:  Msg.localize('twoFactorEnabled')})-        }-    }--    private handleRemoveTOTP = () => {-      AccountServiceClient.Instance.doDelete(""/totp/remove"")+    private handleRemove = (credentialId: string, userLabel: string) => {+      AccountServiceClient.Instance.doDelete(""/credentials/"" + credentialId)         .then(() => {-            this.setState({isTotpConfigured: false});-            ContentAlert.success('successTotpRemovedMessage');+            this.getCredentialContainers();+            ContentAlert.success('successRemovedMessage', [userLabel]);         });     }      public render(): React.ReactNode {","I'm not sure that it needs to be aligned.  It is centered instead, which is standard for Empty State.I considered using the EmptyState component for this, which makes it a little fancier.  With that, it becomes much more obvious that it needs to be centered.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6686,369974020,2020-01-23T08:02:33Z,services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java,"@@ -57,6 +57,139 @@ public AccountCredentialResource(KeycloakSession session, EventBuilder event, Us //        models.forEach(c -> c.setSecretData(null)); //        return models.stream().map(ModelToRepresentation::toRepresentation).collect(Collectors.toList()); //    }+    +    private static class CredentialContainer {+        private String category;+        private String type;+        private String tooltip;+        private boolean enabled;+        private String createAction;+        private String updateAction;+        private boolean removeable;+        private List<CredentialModel> userCredentials;+        +        public CredentialContainer(String category, String type, String tooltip, boolean enabled, String createAction, String updateAction, boolean removeable,List<CredentialModel> userCredentials) {+            this.category = category;+            this.type = type;+            this.tooltip = tooltip;+            this.enabled = enabled;+            this.createAction = createAction;+            this.updateAction = updateAction;+            this.removeable = removeable;+            this.userCredentials = userCredentials;+        }++        public String getCategory() {+            return category;+        }+        +        public String getType() {+            return type;+        }++        public String getTooltip() {+            return tooltip;+        }++        public boolean isEnabled() {+            return enabled;+        }++        public String getCreateAction() {+            return createAction;+        }++        public String getUpdateAction() {+            return updateAction;+        }++        public boolean isRemoveable() {+            return removeable;+        }++        public List<CredentialModel> getUserCredentials() {+            return userCredentials;+        }+        +    }+    +    @GET+    @NoCache+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)+    public List<CredentialContainer> dummyCredentialTypes(){+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);+        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);+        +        List<CredentialModel> passwordUserCreds = new java.util.ArrayList<>();+        passwordUserCreds.add(models.get(0));","@ssilvert The UI with added helpText for each credentialType looks nice to me. Thanks for adding it!Regarding the helpText for the category, I think it will makes sense to have helpText which will be specific to each category. I just don't know where exactly to show it in the UI, so that it looks nice and user-friendly...Regarding your question for helpText on categories, there will be always just 3 categories. Those 3 categories are ""hardcoded"" (with the exception that they should be localized, but otherwise it is pretty much hardcoded text) and their helpTexts can be hardcoded as well. There is no need to return anything from the REST API regarding helpText for the categories (which I am not sure if it is something you meant in your last paragraph).",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6686,370038163,2020-01-23T10:26:34Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/signingin-page/SigningInPage.tsx,"@@ -68,116 +92,202 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta     public constructor(props: SigningInPageProps) {         super(props);         this.state = {-            twoFactorEnabled: true,-            twoFactorEnabledText: Msg.localize('twoFactorEnabled'),-            isTotpConfigured: features.isTotpConfigured,+            credentialContainers: new Map()         }-        this.setLastPwdUpdate();++        this.getCredentialContainers();     } -    private setLastPwdUpdate(): void {-        AccountServiceClient.Instance.doGet(""/credentials/password"")-            .then((response: AxiosResponse<PasswordDetails>) => {-                if (response.data.lastUpdate) {-                    const lastUpdate: number = response.data.lastUpdate;-                    this.setState({lastPasswordUpdate: lastUpdate});-                }+    private getCredentialContainers(): void {+        AccountServiceClient.Instance.doGet(""/credentials"")+            .then((response: AxiosResponse<CredentialContainer[]>) => {++                const allContainers: CredContainerMap = new Map();+                response.data.forEach(container => {+                    let categoryMap = allContainers.get(container.category);+                    if (!categoryMap) {+                        categoryMap = new Map();+                        allContainers.set(container.category, categoryMap);+                    }+                    categoryMap.set(container.type, container);+                });++                this.setState({credentialContainers: allContainers});             });     }     -    private handleTwoFactorSwitch = () => {-        if (this.state.twoFactorEnabled) {-            this.setState({twoFactorEnabled: false, twoFactorEnabledText: Msg.localize('twoFactorDisabled')})-        } else {-            this.setState({twoFactorEnabled: true, twoFactorEnabledText:  Msg.localize('twoFactorEnabled')})-        }-    }--    private handleRemoveTOTP = () => {-      AccountServiceClient.Instance.doDelete(""/totp/remove"")+    private handleRemove = (credentialId: string, userLabel: string) => {+      AccountServiceClient.Instance.doDelete(""/credentials/"" + credentialId)         .then(() => {-            this.setState({isTotpConfigured: false});-            ContentAlert.success('successTotpRemovedMessage');+            this.getCredentialContainers();+            ContentAlert.success('successRemovedMessage', [userLabel]);         });     }      public render(): React.ReactNode {","> I suggest to keep it like this and possibly revisit later based on the feedback from users...I'm not sure we can expect this kind of feedback (""Hey, it looks weird!""). :) IMHO it is about the ""look and feel"", about the impression from the admin console and most importantly how easy-to-use and intuitive it is for an end user that doesn't have any technical background. And I don't think those kind of users will file a JIRA. :) But I'm no UX expert, so it's just how I feel it. ;)> For the future, I wonder if we may have 2 categories instead of 3. Instead of ""Password, ""Two-Factor Authentication"" and ""Passwordless"", we may have just something like ""1st factor authentication"" and ""Two-factor authentication"" . From the built-in credentials, the ""Password"" and ""WebAuthn Passwordless"" will be 1st-factor Category. And ""OTP"" and ""WebAuthn"" will be two-factor category. We may probably wait for the feedback from users and customers whether to do something like this...This would even more strongly imply that 2FA is an independent credential type which it isn't.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6686,370074402,2020-01-23T11:51:49Z,services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java,"@@ -57,6 +57,139 @@ public AccountCredentialResource(KeycloakSession session, EventBuilder event, Us //        models.forEach(c -> c.setSecretData(null)); //        return models.stream().map(ModelToRepresentation::toRepresentation).collect(Collectors.toList()); //    }+    +    private static class CredentialContainer {+        private String category;+        private String type;+        private String tooltip;+        private boolean enabled;+        private String createAction;+        private String updateAction;+        private boolean removeable;+        private List<CredentialModel> userCredentials;+        +        public CredentialContainer(String category, String type, String tooltip, boolean enabled, String createAction, String updateAction, boolean removeable,List<CredentialModel> userCredentials) {+            this.category = category;+            this.type = type;+            this.tooltip = tooltip;+            this.enabled = enabled;+            this.createAction = createAction;+            this.updateAction = updateAction;+            this.removeable = removeable;+            this.userCredentials = userCredentials;+        }++        public String getCategory() {+            return category;+        }+        +        public String getType() {+            return type;+        }++        public String getTooltip() {+            return tooltip;+        }++        public boolean isEnabled() {+            return enabled;+        }++        public String getCreateAction() {+            return createAction;+        }++        public String getUpdateAction() {+            return updateAction;+        }++        public boolean isRemoveable() {+            return removeable;+        }++        public List<CredentialModel> getUserCredentials() {+            return userCredentials;+        }+        +    }+    +    @GET+    @NoCache+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)+    public List<CredentialContainer> dummyCredentialTypes(){+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);+        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);+        +        List<CredentialModel> passwordUserCreds = new java.util.ArrayList<>();+        passwordUserCreds.add(models.get(0));",@mposolda OK.  I'll hard-code some text then.  I think I'll post to the dev list to get feedback on all the help text.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6647,370085398,2020-01-23T12:18:52Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/SniSSLSocketFactory.java,"@@ -115,18 +120,34 @@ public Socket createLayeredSocket(Socket socket, String target, int port, HttpCo     }      private Socket applySNI(final Socket socket, String hostname) {+        if (skipSNIApplication.get()) {+            LOG.log(Level.FINE, ""Skipping application of SNI because IBM JDK is missing setHost() method."");+            return socket;+        }+         if (socket instanceof SSLSocket) {             try {                 Method setHostMethod = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {+                    @Override                     public Method run() throws NoSuchMethodException {                         return socket.getClass().getMethod(""setHost"", String.class);                     }                 });                  setHostMethod.invoke(socket, hostname);-                log.finest(""Applied SNI to socket for: "" + hostname);-            } catch (Exception e) {-                log.log(Level.WARNING, ""Failed to apply SNI to SSLSocket"", e);+                LOG.log(Level.FINEST, ""Applied SNI to socket for host {0}"", hostname);+            } catch (PrivilegedActionException e) {+                if (e.getCause() instanceof NoSuchMethodException && Environment.IS_IBM_JAVA) {","@hmlnarik I am not sure we want this. I agree we should set `skipSNIApplication` to `true` for all JDKs in case the exception is `NoSuchMethod`, but we don't want to set log level to FINE for each JDK as for now we know only for IBM JDK that it is ok to skip SNI application. Does it make sense? ",
12050544,Cracky5457,https://api.github.com/repos/keycloak/keycloak/pulls/6338,370163008,2020-01-23T14:51:45Z,themes/src/main/resources/theme/base/admin/resources/partials/role-list.html,"@@ -6,20 +6,20 @@ <h1>Roles</h1>         <li><a href=""#/realms/{{realm.realm}}/default-roles"">{{:: 'default-roles' | translate}}</a></li>     </ul> -    <table class=""datatable table table-striped table-bordered dataTable no-footer"">+    <table class=""table table-striped table-bordered"">         <thead>             <tr>                 <th class=""kc-table-actions"" colspan=""5"">                     <div class=""form-inline"">                         <div class=""form-group"">                             <div class=""input-group"">-                                <input type=""text"" placeholder=""{{:: 'search.placeholder' | translate}}"" data-ng-model=""searchQuery"" class=""form-control search"" onkeyup=""if (event.keyCode === 13){$(this).next('I').click(); }"">+                                <input type=""text"" placeholder=""{{:: 'search.placeholder' | translate}}"" data-ng-model=""query.search"" ng-model-options=""{debounce: 500}"" class=""form-control search"">","It's related to the automatic search idea, automatic search is perform only if at least 3 characters are pressed ( to avoid useless request ) and the debounce is a delay of 500 ms, to avoid unwanted search as the user is typing. But if I rollback the automatic search I will remove the debounce too because it become useless without the automatic search",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6691,370200199,2020-01-23T15:50:46Z,themes/src/main/resources-product/theme/rh-sso-preview/account/theme.properties,"@@ -0,0 +1,2 @@+parent=keycloak-preview+import=common/rh-sso","RH-SSO (not Keycloak) is failing with the following exception when it tries to load any theme. The (most probable) cause is that the `common/rh-sso` dir is in the `rh-sso` theme and not in `rh-sso-preview`.```16:38:53,350 ERROR [org.keycloak.services.error.KeycloakErrorHandler] (default task-5) Uncaught server error: java.lang.NullPointerException	at org.keycloak.theme.ExtendingThemeManager.loadTheme(ExtendingThemeManager.java:129)	at org.keycloak.theme.ExtendingThemeManager.getTheme(ExtendingThemeManager.java:97)	at org.keycloak.theme.DefaultThemeManager.getTheme(DefaultThemeManager.java:26)	at org.keycloak.services.resources.admin.info.ServerInfoAdminResource.setThemes(ServerInfoAdminResource.java:183)	at org.keycloak.services.resources.admin.info.ServerInfoAdminResource.getInfo(ServerInfoAdminResource.java:100)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:138)	at org.jboss.resteasy.core.ResourceMethodInvoker.internalInvokeOnTarget(ResourceMethodInvoker.java:517)	at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTargetAfterFilter(ResourceMethodInvoker.java:406)	at org.jboss.resteasy.core.ResourceMethodInvoker.lambda$invokeOnTarget$0(ResourceMethodInvoker.java:370)	at org.jboss.resteasy.core.interception.PreMatchContainerRequestContext.filter(PreMatchContainerRequestContext.java:356)	at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(ResourceMethodInvoker.java:372)	at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:344)	at org.jboss.resteasy.core.ResourceLocatorInvoker.invokeOnTargetObject(ResourceLocatorInvoker.java:137)	at org.jboss.resteasy.core.ResourceLocatorInvoker.invoke(ResourceLocatorInvoker.java:100)	at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:440)	at org.jboss.resteasy.core.SynchronousDispatcher.lambda$invoke$4(SynchronousDispatcher.java:229)	at org.jboss.resteasy.core.SynchronousDispatcher.lambda$preprocess$0(SynchronousDispatcher.java:135)	at org.jboss.resteasy.core.interception.PreMatchContainerRequestContext.filter(PreMatchContainerRequestContext.java:356)	at org.jboss.resteasy.core.SynchronousDispatcher.preprocess(SynchronousDispatcher.java:138)	at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:215)	at org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:227)	at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:56)	at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:51)	at javax.servlet.http.HttpServlet.service(HttpServlet.java:590)	at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74)	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129)	at org.keycloak.services.filters.KeycloakSessionServletFilter.doFilter(KeycloakSessionServletFilter.java:91)	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)	at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84)	at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)	at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:68)	at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)	at org.wildfly.extension.undertow.security.SecurityContextAssociationHandler.handleRequest(SecurityContextAssociationHandler.java:78)	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)	at io.undertow.servlet.handlers.RedirectDirHandler.handleRequest(RedirectDirHandler.java:68)	at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:132)	at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57)	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)	at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)	at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64)	at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60)	at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77)	at io.undertow.security.handlers.NotificationReceiverHandler.handleRequest(NotificationReceiverHandler.java:50)	at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43)	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)	at org.wildfly.extension.undertow.security.jacc.JACCContextIdHandler.handleRequest(JACCContextIdHandler.java:61)	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)	at org.wildfly.extension.undertow.deployment.GlobalRequestControllerHandler.handleRequest(GlobalRequestControllerHandler.java:68)	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)	at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:269)	at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:78)	at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:133)	at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:130)	at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48)	at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)	at org.wildfly.extension.undertow.security.SecurityContextThreadSetupAction.lambda$create$0(SecurityContextThreadSetupAction.java:105)	at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504)	at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504)	at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504)	at org.wildfly.extension.undertow.deployment.UndertowDeploymentInfoService$UndertowThreadSetupAction.lambda$create$0(UndertowDeploymentInfoService.java:1504)	at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:249)	at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:78)	at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:99)	at io.undertow.server.Connectors.executeRootHandler(Connectors.java:376)	at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830)	at org.jboss.threads.ContextClassLoaderSavingRunnable.run(ContextClassLoaderSavingRunnable.java:35)	at org.jboss.threads.EnhancedQueueExecutor.safeRun(EnhancedQueueExecutor.java:1982)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.doRunTask(EnhancedQueueExecutor.java:1486)	at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1377)	at java.lang.Thread.run(Thread.java:748)```",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6575,370712682,2020-01-24T16:06:38Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/clients/ClientScopeTest.java,"@@ -62,7 +62,6 @@ public void before() {     }          @Test-    @Ignore //phantomjs sometimes doens't enable ""Add Selected >>"" button when role is selected","This is failing with Chrome. Luckily, there's an easy fix.https://github.com/keycloak/keycloak/blob/14efa819bd2da1e5ffa55522b95a134f9e168815/testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/roles/RoleCompositeRoles.java#L122Change it to:```javaroles.add(getTextFromElement(option).trim());```",
55751016,thielef,https://api.github.com/repos/keycloak/keycloak/pulls/6575,371103686,2020-01-27T08:12:34Z,themes/src/main/resources/theme/base/admin/resources/templates/kc-provider-config.html,"@@ -27,8 +27,18 @@             </div>         </div>         <div class=""col-md-4"" data-ng-if=""option.type == 'ClientList'"">-            <input type=""hidden"" ui-select2=""clientsUiSelect"" id=""clients"" data-ng-init=""initSelectedClient(option.name, config)"" data-ng-model=""selectedClient"" data-ng-change=""changeClient(option.name, config, selectedClient);"" data-placeholder=""{{:: 'selectOne' | translate}}..."">-            </input>+            <ui-select data-ng-init=""initSelectedClient(option.name, config)"" data-ng-model=""clientUiSelection.selected.newClient""+                    data-ng-change=""changeClient(option.name, config, clientUiSelection.selected.newClient);""+                    id=""clients"" theme=""bootstrap"" style=""margin-bottom: 10px;"">+                <ui-select-match placeholder=""{{:: 'authz-select-client' | translate}}..."" allow-clear=""true"">{{$select.selected.clientId}}</ui-select-match>+                <ui-select-choices minimum-input-length=""1"" refresh=""clientsUiSelect($select.search)"" refresh-delay=""500""+                        repeat=""client as client in clientUiSelection.available.clients"">+                    <div ng-bind-html=""client.clientId | highlight: $select.search""/>+                </ui-select-choices>+                <ui-select-no-choice>+                    {{:: 'authz-select-min-character-hint' | translate}}+                </ui-select-no-choice>+            </ui-select>","There are 2 type of users for the JS field type. User federation mappers like the RoleLdap one and client mappers like the Audience one. The RoleLdap mapper uses the JS field to express an array field, the Audience one uses the JS field to model a single String field. This must break and it does. Simply try to create a user federation mapper that uses the client id field. This will result in a failure when saving (example here is from console log):```09:04:09,835 ERROR [org.keycloak.services.error.KeycloakErrorHandler] (default task-2) Uncaught server error: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of `java.util.ArrayList` out of VALUE_STRING token at [Source: (io.undertow.servlet.spec.ServletInputStreamImpl); line: 1, column: 402] (through reference chain: org.keycloak.representations.idm.ComponentRepresentation[""config""]->org.keycloak.common.util.MultivaluedHashMap[""client.id""])	at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63)...	at org.keycloak.services.filters.KeycloakSessionServletFilter.doFilter(KeycloakSessionServletFilter.java:91)```I think it makes sense to fix this by making this field a simple string in all use cases (i.e. adapting the user federation mappers).",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6607,371212002,2020-01-27T12:25:50Z,themes/src/main/resources/theme/base/admin/resources/js/authz/authz-controller.js,"@@ -1821,6 +1821,10 @@ module.controller('ResourceServerPolicyGroupDetailCtrl', function($scope, $route                         return                     }                 }+                if (group.id == ""realm"") {",@mhajas I'm not sure if that will be possible. The `realm` value should only be set by the UI when preparing the list of groups. See https://github.com/keycloak/keycloak/blob/5c7ce775cff43becdbaef98e53e482babc52dbcd/themes/src/main/resources/theme/base/admin/resources/js/controllers/groups.js#L3.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6698,371772211,2020-01-28T12:27:31Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcSamlBrokerTest.java,"@@ -256,6 +262,75 @@ public void loginClientWithDotsInName() throws Exception {         Assert.assertThat(samlResponse.getSamlObject(), isSamlResponse(JBossSAMLURIConstants.STATUS_SUCCESS));     } +    @Test+    public void loginClientExpiredResponseFromIdP() throws Exception {+        // set the provider realm lifespans to 1 sec, this way the SAML response will be expired+        try (AutoCloseable c = new RealmAttributeUpdater(adminClient.realm(bc.providerRealmName()))+                .setAccessTokenLifespan(1)+                .setAccessCodeLifespan(1)+                .update()) {++            AuthnRequestType loginRep = SamlClient.createLoginRequestDocument(AbstractSamlTest.SAML_CLIENT_ID_SALES_POST + "".dot/ted"", getAuthServerContextRoot() + ""/sales-post/saml"", null);++            Document doc = SAML2Request.convert(loginRep);++            new SamlClientBuilder()+              .authnRequest(getAuthServerSamlEndpoint(bc.consumerRealmName()), doc, Binding.POST).build()   // Request to consumer IdP+              .login().idp(bc.getIDPAlias()).build()++              .processSamlResponse(Binding.POST)    // AuthnRequest to producer IdP+                .targetAttributeSamlRequest()+                .build()++              .login().user(bc.getUserLogin(), bc.getUserPassword()).build()++              .sleep(1500)    // sleep 1.5 seconds to expire the document","We are not using static waits in testsuite, we have a possibility to ""move"" in time. You can just use this method: https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java#L581 You can look for usages of the method to see how it works. It basically changes the time in Keycloak server, so you don't need to wait.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6698,371777112,2020-01-28T12:38:57Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcSamlBrokerTest.java,"@@ -256,6 +262,75 @@ public void loginClientWithDotsInName() throws Exception {         Assert.assertThat(samlResponse.getSamlObject(), isSamlResponse(JBossSAMLURIConstants.STATUS_SUCCESS));     } +    @Test+    public void loginClientExpiredResponseFromIdP() throws Exception {",I would prefer to create a new test class for these two tests and remove it from general KcSamlBrokerTest. You can have a look at https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcSamlBrokerSessionNotOnOrAfterTest.java to see what is needed for a new class.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6698,371791878,2020-01-28T13:10:51Z,themes/src/main/resources/theme/base/admin/resources/js/app.js,"@@ -3270,6 +3270,21 @@ module.directive('kcValidPage', function() {    } }); +// Directive to parse/format strings into numbers+module.directive('stringToNumber', function() {","If I understand it correctly, this is here so that `identityProvider.config.allowedClockSkew` is stored as a number not as a String. However, when I try to save a provider with clockskew it is a String in the request. Also in the database it is stored as a String, so we can't avoid parsing the value in Java code. I looked at other places we are having numbers in forms and it is not needed, for example see: https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/base/admin/resources/partials/realm-tokens.html#L34 @rmartinc is there something I am missing?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6701,372534904,2020-01-29T17:48:36Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/ApplicationsPage.java,"@@ -17,14 +17,46 @@  package org.keycloak.testsuite.ui.account2.page; +import org.keycloak.representations.account.ClientRepresentation;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import java.util.ArrayList;+import java.util.List;+ /**  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */ public class ApplicationsPage extends AbstractLoggedInPage {+    @FindBy(xpath = ""//ul[@id='applications-list']/li/div/div[@class='pf-c-data-list__item-content']"")","I'm not sure we should use selectors like that. This will be very error prone in the future when slightly changing the layout or even updating PF/React. Please add IDs where missing. (To keep all IDs unique, you can make a part of the ID dynamic like e.g. [here](https://github.com/keycloak/keycloak/blob/210fd92d2328b3d8173d7c07e2708e6d9544a396/themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/device-activity-page/DeviceActivityPage.tsx#L283)).",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6701,372538049,2020-01-29T17:54:40Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/ApplicationsPage.java,"@@ -17,14 +17,46 @@  package org.keycloak.testsuite.ui.account2.page; +import org.keycloak.representations.account.ClientRepresentation;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import java.util.ArrayList;+import java.util.List;+ /**  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */ public class ApplicationsPage extends AbstractLoggedInPage {+    @FindBy(xpath = ""//ul[@id='applications-list']/li/div/div[@class='pf-c-data-list__item-content']"")+    private List<WebElement> applications;+     @Override     public String getPageId() {         return ""applications"";     } +    public List<ClientRepresentation> getApplications() {+        ArrayList<ClientRepresentation> apps = new ArrayList<>();+        for(WebElement app : applications) {+            apps.add(toRepresentation(app));+        }+        return apps;+    }++    private ClientRepresentation toRepresentation(WebElement app) {+        ClientRepresentation client = new ClientRepresentation();+        String clientName = app.findElement(By.xpath(""(div)[1]"")).getText();+        client.setClientName(clientName);+        boolean userConsentRequired = !app.findElement(By.xpath(""(div)[2]"")).getText().equals(""Internal"");",Please use [`getTextFromElement`](https://github.com/keycloak/keycloak/blob/f426643225337f17f640d43e0f5b236f09d70e9d/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/UIUtils.java#L159) to avoid any browser-related problems in the future.,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/6681,373097068,2020-01-30T17:46:00Z,saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/assertion/SAMLAttributeParser.java,"@@ -47,14 +66,39 @@ protected AttributeType instantiateElement(XMLEventReader xmlEventReader, StartE         attribute.setFriendlyName(StaxParserUtil.getAttributeValue(element, SAMLAssertionQNames.ATTR_FRIENDLY_NAME));         attribute.setNameFormat(StaxParserUtil.getAttributeValue(element, SAMLAssertionQNames.ATTR_NAME_FORMAT)); -        final String x500Encoding = StaxParserUtil.getAttributeValue(element, SAMLAssertionQNames.ATTR_X500_ENCODING);-        if (x500Encoding != null) {-            attribute.getOtherAttributes().put(SAMLAssertionQNames.ATTR_X500_ENCODING.getQName(), x500Encoding);-        }+        // add non standard elements like SAMLAssertionQNames.ATTR_X500_ENCODING to other attributes+        attribute.getOtherAttributes().putAll(collectUnknownAttributesFrom(element));          return attribute;     } +    /**+     * Returns a {@link Map} with the found non-standard attribute values for the given {@link StartElement}.+     * An attribute is considered as non-standard, if it is not contained in DEFAULT_KNOWN_LOCAL_ATTRIBUTE_NAMES.+     *+     * @return Map+     */+    private Map<QName, String> collectUnknownAttributesFrom(StartElement element) {++        Map<QName, String> otherAttributes = new HashMap<>();++        Iterator<?> attributes = element.getAttributes();+        while (attributes.hasNext()) {+            Attribute currentAttribute = (Attribute) attributes.next();+            QName attributeQName = currentAttribute.getName();+            if (attributeQName == null || DEFAULT_KNOWN_LOCAL_ATTRIBUTE_NAMES.contains(attributeQName.getLocalPart())) {+                continue;+            }+            String attributeValue = currentAttribute.getValue();+            otherAttributes.put(attributeQName, attributeValue);+            if (LOGGER.isTraceEnabled()) {","That's what I wanted to do in the first place, but there is no classic JBoss-Logging ""logger"" field available for this class, just the PicketLinkLogger LOGGER, which doesn't provide a tracef(...) method. That's why I added the guard to spare the string concat.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6690,373234315,2020-01-30T22:44:28Z,server-spi/src/main/java/org/keycloak/credential/CredentialTypeMetadata.java,"@@ -0,0 +1,282 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.credential;++import org.jboss.logging.Logger;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RequiredActionProviderModel;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class CredentialTypeMetadata implements Comparable<CredentialTypeMetadata> {++    private static final Logger logger = Logger.getLogger(CredentialTypeMetadata.class);++    public static final String DEFAULT_ICON_CSS_CLASS = ""kcAuthenticatorDefaultClass"";++    private String type;++    private String displayName;++    private String helpText;++    private String iconCssClass = DEFAULT_ICON_CSS_CLASS;++    private String createAction;++    private String updateAction;++    private Boolean removeable;++    private Category category;+++    public enum Category {+        PASSWORD(""password"", 1),+        TWO_FACTOR(""two-factor"", 2),+        PASSWORDLESS(""passwordless"", 3);++        private String categoryName;+        private int order;++        Category(String categoryName, int order) {+            this.categoryName = categoryName;+            this.order = order;+        }++        @Override+        public String toString() {+            return categoryName;+        }++        public int compareWith(Category that) {+            return order - that.order;+        }++    }+++    private CredentialTypeMetadata() {+    }+++    // GETTERS++    /**+     * @return credential type like for example ""password"", ""otp"" or ""webauthn""+     */+    public String getType() {+        return type;+    }++   /**+     * @return the label, which will be shown to the end user on various screens, like login screen with available authentication mechanisms.+     * This label will reference this particular authenticator type.+     * It should be clear to end users. For example, implementations can return ""Authenticator Application"" for OTP or ""Security Key"" for WebAuthn.+     *+     * Alternatively, this method can return a message key, so that it is possible to localize it for various languages.+     */+    public String getDisplayName() {+        return displayName;+    }++    /**+     * @return the text, which will be shown to the user on various screens, like login screen with available authentication mechanisms.+     * This text will reference this particular authenticator type.+     * For example for OTP, the returned text could be ""Enter a verification code from authenticator application"" .+     *+     * Alternatively, this method can return a message key, so that it is possible to localize it for various languages.+     */+    public String getHelpText() {+        return helpText;+    }++    /**+     * Return the icon CSS, which can be used to display icon, which represents this particular authenticator.+     *+     * The icon will be displayed on various places. For example the ""Select authenticator"" screen during login, where user can select from+     * various authentication mechanisms for two-factor or passwordless authentication.+     *+     * The returned value can be either:+     * - Key of the property, which will reference the actual CSS in the themes.properties file. For example if you return ""kcAuthenticatorWebAuthnClass""+     *   from this method, then your themes.properties should have the property like for example ""kcAuthenticatorWebAuthnClass=fa fa-key list-view-pf-icon-lg"" .+     *   This would mean that ""fa fa-key list-view-pf-icon-lg"" will be the actual CSS used.+     * - the icon CSS class directly. For example you can return ""fa fa-key list-view-pf-icon-lg"" directly for the above example with WebAuthn.+     *   This alternative is fine just if your authenticator can use same CSS class for all the themes.+     *+     * If you don't expect your authenticator to need icon (for example it will never be shown in the ""select authenticator"" screen), then+     * it is fine to keep the default value.+     */+    public String getIconCssClass() {+        return iconCssClass;+    }++    /**+     * @return the providerID of the required action, which can be used by the user to create new credential of our type. Null if there is no","Yes, ""CONFIGURE_TOTP"" is the providerID of the required action provider. When requiredAction/AIA is triggered, Keycloak uses the providerID like ""CONFIGURE_TOTP"" to lookup required action provider - in this case class UpdateTotp. In case of WebAuthn, the name of the action is ""webauthn-register"" , which is provider id of WebAuthnRegisterFactory.By default, the alias and providerId of RequiredActionProviderModels attached to the realm is the same, but it may not be necessarily true. Keycloak uses providerId to lookup the requiredAction, not the alias or name of requiredAction.However if you have any better idea to this javadoc, we can discuss it.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6690,373234742,2020-01-30T22:45:43Z,server-spi/src/main/java/org/keycloak/credential/CredentialTypeMetadata.java,"@@ -0,0 +1,282 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.credential;++import org.jboss.logging.Logger;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RequiredActionProviderModel;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class CredentialTypeMetadata implements Comparable<CredentialTypeMetadata> {++    private static final Logger logger = Logger.getLogger(CredentialTypeMetadata.class);++    public static final String DEFAULT_ICON_CSS_CLASS = ""kcAuthenticatorDefaultClass"";++    private String type;++    private String displayName;++    private String helpText;++    private String iconCssClass = DEFAULT_ICON_CSS_CLASS;++    private String createAction;++    private String updateAction;++    private Boolean removeable;++    private Category category;+++    public enum Category {+        PASSWORD(""password"", 1),+        TWO_FACTOR(""two-factor"", 2),+        PASSWORDLESS(""passwordless"", 3);++        private String categoryName;+        private int order;++        Category(String categoryName, int order) {+            this.categoryName = categoryName;+            this.order = order;+        }++        @Override+        public String toString() {+            return categoryName;+        }++        public int compareWith(Category that) {+            return order - that.order;+        }++    }+++    private CredentialTypeMetadata() {+    }+++    // GETTERS++    /**+     * @return credential type like for example ""password"", ""otp"" or ""webauthn""+     */+    public String getType() {+        return type;+    }++   /**+     * @return the label, which will be shown to the end user on various screens, like login screen with available authentication mechanisms.+     * This label will reference this particular authenticator type.+     * It should be clear to end users. For example, implementations can return ""Authenticator Application"" for OTP or ""Security Key"" for WebAuthn.+     *+     * Alternatively, this method can return a message key, so that it is possible to localize it for various languages.+     */+    public String getDisplayName() {+        return displayName;+    }++    /**+     * @return the text, which will be shown to the user on various screens, like login screen with available authentication mechanisms.+     * This text will reference this particular authenticator type.+     * For example for OTP, the returned text could be ""Enter a verification code from authenticator application"" .+     *+     * Alternatively, this method can return a message key, so that it is possible to localize it for various languages.+     */+    public String getHelpText() {+        return helpText;+    }++    /**+     * Return the icon CSS, which can be used to display icon, which represents this particular authenticator.+     *+     * The icon will be displayed on various places. For example the ""Select authenticator"" screen during login, where user can select from+     * various authentication mechanisms for two-factor or passwordless authentication.+     *+     * The returned value can be either:+     * - Key of the property, which will reference the actual CSS in the themes.properties file. For example if you return ""kcAuthenticatorWebAuthnClass""+     *   from this method, then your themes.properties should have the property like for example ""kcAuthenticatorWebAuthnClass=fa fa-key list-view-pf-icon-lg"" .+     *   This would mean that ""fa fa-key list-view-pf-icon-lg"" will be the actual CSS used.+     * - the icon CSS class directly. For example you can return ""fa fa-key list-view-pf-icon-lg"" directly for the above example with WebAuthn.+     *   This alternative is fine just if your authenticator can use same CSS class for all the themes.+     *+     * If you don't expect your authenticator to need icon (for example it will never be shown in the ""select authenticator"" screen), then+     * it is fine to keep the default value.+     */+    public String getIconCssClass() {+        return iconCssClass;+    }++    /**+     * @return the providerID of the required action, which can be used by the user to create new credential of our type. Null if there is no+     * action for creating credential. For example we're creating credential in case of ""otp"" type, but we're updating credential+     * in case of type ""password""+     */+    public String getCreateAction() {+        return createAction;+    }++    /**+     * @return the providerID of the required action, which can be used by the user to update credential of our type. Null if there is no","Yes, the ""UPDATE_PASSWORD"" is the providerId of requiredAction for update password - it's java class is UpdatePassword. Same case like for ""createAction"".However if you have any better idea to this javadoc, we can discuss it. Any suggestion?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6668,373380775,2020-01-31T09:16:41Z,services/src/main/java/org/keycloak/services/resources/admin/UserResource.java,"@@ -620,13 +617,29 @@ public void resetPassword(CredentialRepresentation cred) {     @NoCache     @Produces(MediaType.APPLICATION_JSON)     public List<CredentialRepresentation> credentials(){-        auth.users().requireManage(user);+        auth.users().requireView(user);","Yes, but just the public metadata of the credentials, not the secret data. So for example he will be able to see that user has password and algorithm ""pbkdf2"" was used to hash the password and there are 20.000 hashing iterations. He won't be able to see secret data (salt and password hash in case of password).",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6668,373382740,2020-01-31T09:21:33Z,services/src/main/java/org/keycloak/services/resources/admin/UserResource.java,"@@ -620,13 +617,29 @@ public void resetPassword(CredentialRepresentation cred) {     @NoCache     @Produces(MediaType.APPLICATION_JSON)     public List<CredentialRepresentation> credentials(){-        auth.users().requireManage(user);+        auth.users().requireView(user);","I suggest then leaving this information only available for those managing this user since the metadata can increase the attack surface (like ""as an attacker I don't need to try password-breaking since the user has enrolled no password"").",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6701,373537976,2020-01-31T15:29:23Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx,"@@ -113,27 +117,27 @@ export class ApplicationsPage extends React.Component<ApplicationsPageProps, App             const appUrl: string = application.userConsentRequired ? application.baseUrl : '/auth' + application.baseUrl;              return (-              <DataListItem key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>+              <DataListItem id={this.elementId(""client-id"", application)} key={'application-' + appIndex} aria-labelledby=""applications-list"" isExpanded={this.state.isRowOpen[appIndex]}>                 <DataListItemRow>                   <DataListToggle                     onClick={() => this.onToggle(appIndex)}                     isExpanded={this.state.isRowOpen[appIndex]}-                    id={'applicationToggle' + appIndex}+                    id={this.elementId('toggle', application)}                     aria-controls=""expandable""","One last thing. This (`aria-controls`) should have the same value as this:https://github.com/keycloak/keycloak/blob/ab862c045231dffaba342b400cf301d409aedc47/themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/applications-page/ApplicationsPage.tsx#L152I think this has something to do with accessibility. Even though we'll address accessibility in general later, let's not add more issues. ;)```suggestion                    aria-controls={this.elementId(""expandable"", application)}```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6702,374155066,2020-02-03T15:08:11Z,services/src/main/java/org/keycloak/broker/oidc/OIDCIdentityProvider.java,"@@ -715,4 +721,32 @@ protected BrokeredIdentityContext exchangeExternalImpl(EventBuilder event, Multi             throw new ErrorResponseException(OAuthErrorException.INVALID_TOKEN, ""invalid token type"", Response.Status.BAD_REQUEST);         }     }++    @Override+    protected UriBuilder createAuthorizationUrl(AuthenticationRequest request) {+        UriBuilder uriBuilder = super.createAuthorizationUrl(request);+        String nonce = UUID.randomUUID().toString();",Should we use https://github.com/keycloak/keycloak/blob/master/server-spi-private/src/main/java/org/keycloak/models/utils/KeycloakModelUtils.java#L81 instead of UUID? SecureRandom seems more appropriate for a nonce than an UUID,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6717,374329439,2020-02-03T20:41:55Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/account-service/account.service.ts,"@@ -100,7 +100,12 @@ export class AccountServiceClient {             this.kcSvc.login();         }         console.log(error);-        ContentAlert.danger(error.name + ': ' + error.message);++        if (error != null && error.response != null && error.response.data != null && error.response.data.errorMessage) {",Better way to say this:`if (error?.response?.data?.errorMessage) {`See https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6717,374335150,2020-02-03T20:54:20Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/account-service/account.service.ts,"@@ -100,7 +100,12 @@ export class AccountServiceClient {             this.kcSvc.login();         }         console.log(error);-        ContentAlert.danger(error.name + ': ' + error.message);++        if (error != null && error.response != null && error.response.data != null && error.response.data.errorMessage) {",Hmm.  Looks like optional chaining is not available until TypeScript 3.7 and we are still on 3.3.  Maybe not such a good idea to upgrade this close to the release.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6729,375257996,2020-02-05T13:37:22Z,adapters/saml/as7-eap6/subsystem/src/main/resources/org/keycloak/subsystem/saml/as7/LocalDescriptions.properties,"@@ -68,6 +69,7 @@ keycloak-saml.IDP.remove=Remove an identity provider keycloak-saml.IDP.signaturesRequired=Require signatures for SingleSignOnService and SingleLogoutService keycloak-saml.IDP.signatureAlgorithm=Signature algorithm keycloak-saml.IDP.signatureCanonicalizationMethod=Signature canonicalization method+keycloak-saml.IDP.metadataUrl=he URL used to retrieve the IDP metadata from",```suggestionkeycloak-saml.IDP.metadataUrl=The URL used to retrieve the IDP metadata from```,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6726,375837411,2020-02-06T13:38:52Z,services/src/main/java/org/keycloak/protocol/oidc/installation/KeycloakOIDCJbossSubsystemClientCliInstallation.java,"@@ -0,0 +1,126 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.installation;++import org.keycloak.Config;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.ClientInstallationProvider;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;++import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;+import java.net.URI;+import java.util.Map;++public class KeycloakOIDCJbossSubsystemClientCliInstallation implements ClientInstallationProvider {++    @Override+    public Response generateInstallation(KeycloakSession session, RealmModel realm, ClientModel client, URI baseUri) {+        String deploymentName = ""WAR MODULE NAME.war"";+        StringBuilder builder = new StringBuilder();+        +        builder+                .append(""/subsystem=keycloak/secure-deployment=\"""").append(deploymentName).append(""\""/:add( \\\n"")","introduce a method for escaping the quotes in any user-entered data: https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.1/html-single/management_cli_guide/index#quotation_marks```suggestion                .append(""/subsystem=keycloak/secure-deployment=\"""").append(quote(deploymentName)).append(""\""/:add( \\\n"")```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6791,380049355,2020-02-17T08:51:56Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -517,6 +517,19 @@ public Response execute(String samlRequest, String samlResponse, String relaySta             else                 return handleSamlResponse(samlResponse, relayState);         }++        /**+         * KEYCLOAK-12616, KEYCLOAK-12944: construct the expected destination URI in the same way that {@link KeycloakUriInfo#getAbsolutePath()}+         * used to do prior to the changes introduced by the addition of the default hostname provider.+         *+         * @param session a reference to the {@link KeycloakSession}.+         * @return the constructed {@link URI}.+         */+        protected URI getExpectedDestinationUri(final KeycloakSession session) {+            KeycloakUriInfo info = session.getContext().getUri();+            URI baseUri = info.getBaseUri();+            return info.getAbsolutePathBuilder().scheme(baseUri.getScheme()).host(baseUri.getHost()).port(baseUri.getPort()).build();","This is not going to work as Keycloak may be exposed on a different context-path on the reverse proxy. I.e. frontendUrl could be ""https://mykeycloak.org/"" while Keycloak is listening on ""https://10.9.10.10:8443/auth"".",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/6791,380151116,2020-02-17T12:21:49Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -517,6 +517,19 @@ public Response execute(String samlRequest, String samlResponse, String relaySta             else                 return handleSamlResponse(samlResponse, relayState);         }++        /**+         * KEYCLOAK-12616, KEYCLOAK-12944: construct the expected destination URI in the same way that {@link KeycloakUriInfo#getAbsolutePath()}+         * used to do prior to the changes introduced by the addition of the default hostname provider.+         *+         * @param session a reference to the {@link KeycloakSession}.+         * @return the constructed {@link URI}.+         */+        protected URI getExpectedDestinationUri(final KeycloakSession session) {+            KeycloakUriInfo info = session.getContext().getUri();+            URI baseUri = info.getBaseUri();+            return info.getAbsolutePathBuilder().scheme(baseUri.getScheme()).host(baseUri.getHost()).port(baseUri.getPort()).build();","> This is not going to work as Keycloak may be exposed on a different context-path on the reverse proxy. I.e. frontendUrl could be ""https://mykeycloak.org/"" while Keycloak is listening on ""https://10.9.10.10:8443/auth"".It does work as this is just the URL used for validating the destination. The redirection uses the baseUri so it properly redirects back to the proxy. I assumed users were setting the destination with the /auth/ path because of the way we used to buld the validation URL. I agree the destination should be set using solely the proxy path, so I will change that.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6786,380505467,2020-02-18T07:53:34Z,themes/src/main/resources-product/theme/rh-sso/admin/resources/css/styles.css,"@@ -406,6 +406,5 @@ table.kc-authz-table-expanded { }  .password-conceal {-  font-family: 'text-security-disc';",Since we're not using text-security-disc here the dependency should be removed,
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/6786,380512726,2020-02-18T08:12:33Z,themes/src/main/resources/theme/base/admin/resources/partials/user-credentials.html,"@@ -97,7 +97,7 @@                 <div class=""form-group"">                     <label class=""col-md-2 control-label"" for=""confirmPas"">{{:: 'password-confirmation' | translate}} <span class=""required"" data-ng-show=""create"">*</span></label>                     <div class=""col-md-6"">-                        <input class=""form-control"" kc-password id=""confirmPas"" name=""confirmPas"" data-ng-model=""confirmPassword"" required>+                        <input class=""form-control"" kc-password type=""text"" id=""confirmPas"" name=""confirmPas"" data-ng-model=""confirmPassword"" required>","This change was accidental, it's not needed. The directive is sometimes used with `type=""text""` and sometimes it's omitted.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6789,380570154,2020-02-18T10:01:54Z,quarkus/pom.xml,"@@ -31,8 +31,10 @@     <packaging>pom</packaging>      <properties>-        <quarkus.version>1.0.1.Final</quarkus.version>-        <resteasy.version>4.3.1.Final</resteasy.version>+        <quarkus.version>1.2.0.Final</quarkus.version>+        <resteasy.version>4.4.2.Final</resteasy.version>+        <jackson.version>2.10.0</jackson.version>",Quarkus 1.2.0 uses 2.10.2 (https://github.com/quarkusio/quarkus/blob/1.2.0.Final/bom/runtime/pom.xml#L79),
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6780,383144909,2020-02-24T09:09:25Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java,"@@ -62,6 +64,9 @@ /**  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */+@EnableFeature(value = Profile.Feature.ACCOUNT2, skipRestart = true)+@EnableFeature(value = Profile.Feature.ACCOUNT_API, skipRestart = true)+@EnableFeature(value = Profile.Feature.WEB_AUTHN, skipRestart = true)","I believe we don't need to enable WebAuthn for the whole test class. This affects only:https://github.com/keycloak/keycloak/blob/26a78a1eb61b4e2b293bcf98d06fe78713492b70/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java#L246-L254If I understand it correctly, the annotation should work for test methods as well, shouldn't it?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6780,383145533,2020-02-24T09:10:45Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java,"@@ -62,6 +64,9 @@ /**  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */+@EnableFeature(value = Profile.Feature.ACCOUNT2, skipRestart = true)+@EnableFeature(value = Profile.Feature.ACCOUNT_API, skipRestart = true)","Is there any reason why to put here the account profile features? Seems a bit redundant, there are already present in the parent class.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6780,383160290,2020-02-24T09:42:06Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java,"@@ -62,6 +64,9 @@ /**  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */+@EnableFeature(value = Profile.Feature.ACCOUNT2, skipRestart = true)+@EnableFeature(value = Profile.Feature.ACCOUNT_API, skipRestart = true)+@EnableFeature(value = Profile.Feature.WEB_AUTHN, skipRestart = true)",Scratch that! I completely forgot we configure WebAuthn before running the whole test class. This approach is therefore correct.,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/6780,383170853,2020-02-24T10:02:05Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java,"@@ -62,6 +64,9 @@ /**  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */+@EnableFeature(value = Profile.Feature.ACCOUNT2, skipRestart = true)+@EnableFeature(value = Profile.Feature.ACCOUNT_API, skipRestart = true)+@EnableFeature(value = Profile.Feature.WEB_AUTHN, skipRestart = true)","There are more tests, which depend on the WebAuthn feature. So, I think, it would be better to keep that for whole class.f.e. `categoriesTest`,`setUpLinksTest`,...",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/6780,383176784,2020-02-24T10:13:37Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java,"@@ -62,6 +64,9 @@ /**  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */+@EnableFeature(value = Profile.Feature.ACCOUNT2, skipRestart = true)+@EnableFeature(value = Profile.Feature.ACCOUNT_API, skipRestart = true)","AFAIK, the problem is with `KeycloakContainerFeaturesController`, which manage and prepare all environments to enabling/disabling feature. The controller enable a feature only for specific class, therefore, it doesn't allow inheritance of the enabling/disabling feature from parent. So, the `account` features should be again explicitly specified.I don't know, if it's a good approach, but it's not ""target"" of this PR :) ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6780,383511237,2020-02-24T21:00:21Z,common/src/main/java/org/keycloak/common/Profile.java,"@@ -95,6 +119,8 @@ private Profile() {          for (Feature f : Feature.values()) {             Boolean enabled = config.getConfig(f);+            Type type = product.equals(ProductValue.RHSSO) ? f.getTypeProduct() : f.getTypeProject();","Is it possible to remove field ""defaultType"" and methods ""setDefaultType"" and ""getType"" from the Feature enum? AFAIK the mutable enums is the antipattern - see for example https://rules.sonarsource.com/java/RSPEC-3066 . Hopefully all occurences of ""f.getType()"" in the further code can be replaced simply with the ""type"", which was retrieved on line 122? For exampe:```switch (type) {```instead of:```switch (f.getType()) {```etc",
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/6810,383854552,2020-02-25T12:42:33Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/javascript/JavascriptAdapterTest.java,"@@ -474,6 +474,23 @@ public void testLocationHeaderInResponse() {                         });     } +    @Test+    public void equalsSignInRedirectUrl() {++        testAppUrl = authServerContextRootPage.toString().replace(""localhost"", NIP_IO_URL) + JAVASCRIPT_URL + ""/index.html?test=bla=bla&super=man"";",It's done [here](https://github.com/keycloak/keycloak/blob/303514c73fd5b8fafcb9602c73f4b6fdafc6774a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/javascript/JavascriptAdapterTest.java#L508) as well. How do I set the `testAppUrl` by using `AuthServerTestEnricher.getAuthServerContextRoot` method?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6810,383889249,2020-02-25T13:50:20Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/javascript/JavascriptAdapterTest.java,"@@ -474,6 +474,23 @@ public void testLocationHeaderInResponse() {                         });     } +    @Test+    public void equalsSignInRedirectUrl() {++        testAppUrl = authServerContextRootPage.toString().replace(""localhost"", NIP_IO_URL) + JAVASCRIPT_URL + ""/index.html?test=bla=bla&super=man"";","I see. It is working because testAppUrl is assigned in `@Before` method, so it is same for each test. However it is useless to reassign it before each method since for majority of methods it is same. We can have something like this```private static final String TEST_APP_URL = AuthServerTestEnricher.getAuthServerContextRoot().replace(""localhost"", NIP_IO_URL) + JAVASCRIPT_URL + ""/index.html"";```instead of```private String testAppUrl;```and then create a new variable based on TEST_APP_URL everywhere we need to change it. However this is little bit out of this issue and the test will be working even without it, so I won't insist on changing it :-). Feel free to ignore this comment.",
13949566,alvarogimenez,https://api.github.com/repos/keycloak/keycloak/pulls/6819,383970291,2020-02-25T15:55:46Z,authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/permission/ScopePolicyProviderFactory.java,"@@ -62,6 +66,33 @@ public ScopePermissionRepresentation toRepresentation(Policy policy, Authorizati         return new ScopePermissionRepresentation();     } +    @Override+    public void onCreate(Policy policy, ScopePermissionRepresentation representation, AuthorizationProvider authorization) {+        updateResourceType(policy, representation);+    }++    @Override+    public void onUpdate(Policy policy, ScopePermissionRepresentation representation, AuthorizationProvider authorization) {+        updateResourceType(policy, representation);+    }++    private void updateResourceType(Policy policy, ScopePermissionRepresentation representation) {+        if (representation != null) {+            //TODO: remove this check once we migrate to new API+            if (ScopePermissionRepresentation.class.equals(representation.getClass())) {",We duplicated this `if` from:https://github.com/keycloak/keycloak/blob/8436a880755a7166741d572b7a803e0417fdb909/authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/permission/ResourcePolicyProviderFactory.java#L83Since the API now specifies the representation type (`ResourcePermissionRepresentation` and  `ScopePermissionRepresentation`) maybe we could remove the `if` and the `class.cast` from both `ResourcePolicyProviderFactory` and `ScopePolicyProviderFactory`. Do you agree with this change?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6831,384341284,2020-02-26T08:41:09Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/SAMLServletAdapterTest.java,"@@ -1161,17 +1163,14 @@ public void testRelayStateEncoding() throws Exception {     }      private static List<String> parseCommaSeparatedAttributes(String body, String attribute) {-        int start = body.indexOf(attribute) + attribute.length();-        if (start == -1) {-            return Collections.emptyList();-        }-        int end = body.indexOf(System.getProperty(""line.separator""), start);-        if (end == -1) {-            end = body.length();+        Pattern pattern = Pattern.compile(attribute + ""(.*)"");","```suggestion        Pattern pattern = Pattern.compile(Pattern.quote(attribute) + ""\\s*(.*)"");```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6819,384482845,2020-02-26T13:13:37Z,model/jpa/src/main/java/org/keycloak/authorization/jpa/entities/PolicyEntity.java,"@@ -59,7 +56,7 @@                 @NamedQuery(name=""findPolicyIdByResource"", query=""select p from PolicyEntity p inner join fetch p.resources r left join fetch p.scopes s inner join fetch p.associatedPolicies a where p.resourceServer.id = :serverId and (r.resourceServer.id = :serverId and r.id = :resourceId)""),                 @NamedQuery(name=""findPolicyIdByScope"", query=""select pe from PolicyEntity pe left join fetch pe.resources r inner join fetch pe.scopes s inner join fetch pe.associatedPolicies a where pe.resourceServer.id = :serverId and exists (select p.id from ScopeEntity s inner join s.policies p where s.resourceServer.id = :serverId and (p.resourceServer.id = :serverId and p.type = 'scope' and s.id in (:scopeIds) and p.id = pe.id))""),                 @NamedQuery(name=""findPolicyIdByResourceScope"", query=""select pe from PolicyEntity pe inner join fetch pe.resources r inner join fetch pe.scopes s inner join fetch pe.associatedPolicies a where pe.resourceServer.id = :serverId and exists (select p.id from ScopeEntity s inner join s.policies p where s.resourceServer.id = :serverId and (p.resourceServer.id = :serverId and p.type = 'scope' and s.id in (:scopeIds) and p.id = pe.id)) and exists (select p.id from ResourceEntity r inner join r.policies p where r.resourceServer.id = :serverId and (p.resourceServer.id = :serverId and p.id = pe.id and p.type = 'scope' and r.id in (:resourceId)))""),-                @NamedQuery(name=""findPolicyIdByNullResourceScope"", query=""select pe from PolicyEntity pe left join fetch pe.resources r inner join fetch pe.scopes s inner join fetch pe.associatedPolicies a where pe.resourceServer.id = :serverId and exists (select p.id from ScopeEntity s inner join s.policies p where s.resourceServer.id = :serverId and (p.resourceServer.id = :serverId and p.id = pe.id and p.type = 'scope' and s.id in (:scopeIds))) and pe.resources is empty""),+                @NamedQuery(name=""findPolicyIdByNullResourceScope"", query=""select pe from PolicyEntity pe left join fetch pe.resources r left join fetch pe.configKeys ck inner join fetch pe.scopes s inner join fetch pe.associatedPolicies a where pe.resourceServer.id = :serverId and exists (select p.id from ScopeEntity s inner join s.policies p where s.resourceServer.id = :serverId and (p.resourceServer.id = :serverId and p.id = pe.id and p.type = 'scope' and s.id in (:scopeIds))) and pe.resources is empty and 'defaultResourceType' not member of pe.configKeys""),",I'm a bit concerned about this change. I'm afraid it could impact performance?It is indeed better than filtering the results once they are fetched from the database. Really not sure ...,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/6778,384970814,2020-02-27T08:18:48Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ClientTest.java,"@@ -248,7 +248,8 @@ private void assertPaginatedClients(int start, int end, List<ClientRepresentatio             expected.add(""ccx-"" + (i < 10 ? ""0"" + i : i));         }         List<String> a = actual.stream().map(rep -> rep.getClientId()).collect(Collectors.toList());-        assertThat(a, is(expected));+        assertThat(a, Matchers.hasSize(expected.size()));+        assertThat(a, Matchers.containsInAnyOrder(expected.toArray()));","Thanks, there is no index on client_id column in database, so it has to added. And also it would be good to check all other entities which can be paginated.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6834,385113990,2020-02-27T13:07:45Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -1785,6 +1780,15 @@ public static UserModel createUser(KeycloakSession session, RealmModel newRealm,         return user;     } +    public static void createFederatedIdentities(UserRepresentation userRep, KeycloakSession session, RealmModel realm, UserModel user) {",Can you revert the change to extract this into a separate method? We don't need a public method like this when it's only used within a single place in the same class,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6835,385899445,2020-02-28T20:08:34Z,themes/src/main/resources-community/theme/base/login/messages/messages_pt_BR.properties,"@@ -2,42 +2,51 @@ doLogIn=Entrar doRegister=Cadastre-se doCancel=Cancelar doSubmit=Ok+doBack=Voltar doYes=Sim doNo=N\u00E3o-doContinue=Continue+doContinue=Continuar+doIgnore=Ignorar doAccept=Aceitar doDecline=Rejeitar-doForgotPassword=Esqueceu sua senha?+doForgotPassword=Esqueceu a senha? doClickHere=Clique aqui doImpersonate=Personificar+doTryAgain=Tente novamente+doTryAnotherWay=Tente Outra Maneira","By following the same pattern to other messages, I think we should have `Tente outra maneira`. Talvez, `Tente outra forma` seja mais correto ?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6835,385904494,2020-02-28T20:20:54Z,themes/src/main/resources-community/theme/base/login/messages/messages_pt_BR.properties,"@@ -65,73 +74,119 @@ region=Estado postal_code=CEP country=Pa\u00EDs emailVerified=E-mail verificado-gssDelegationCredential=gss delega\u00E7\u00E3o credencial+gssDelegationCredential=Delega\u00E7\u00E3o de Credenciais GSS++profileScopeConsentText=Perfil de usu\u00E1rio+emailScopeConsentText=Endere\u00E7o de e-mail+addressScopeConsentText=Endere\u00E7o+phoneScopeConsentText=N\u00FAmero de telefone+offlineAccessScopeConsentText=Acesso Offline+samlRoleListScopeConsentText=Minhas Fun\u00E7\u00F5es+rolesScopeConsentText=Fun\u00E7\u00F5es do usu\u00E1rio",Maybe `Perfis de Acesso do Usurio`. Too big though ...,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6835,385914674,2020-02-28T20:47:21Z,themes/src/main/resources-community/theme/base/login/messages/messages_pt_BR.properties,"@@ -202,13 +264,108 @@ invalidCodeMessage=C\u00F3digo inv\u00E1lido, por favor fa\u00E7a login novament identityProviderUnexpectedErrorMessage=Erro inesperado durante a autentica\u00E7\u00E3o com o provedor de identidade identityProviderNotFoundMessage=N\u00E3o foi poss\u00EDvel encontrar um provedor de identidade com o identificador. identityProviderLinkSuccess=Sua conta foi vinculada com sucesso com {0} conta {1} .-realmSupportsNoCredentialsMessage=O realm n\u00E3o suporta qualquer tipo de credencial.-identityProviderNotUniqueMessage=O realm suporta m\u00FAltiplos provedores de identidade. N\u00E3o foi poss\u00EDvel determinar qual o provedor de identidade deve ser usado para se autenticar.+staleCodeMessage=Esta p\u00E1gina n\u00E3o \u00E9 mais v\u00E1lida. Volte ao seu aplicativo e fa\u00E7a login novamente+realmSupportsNoCredentialsMessage=O dom\u00EDnio n\u00E3o suporta qualquer tipo de credencial.+credentialSetupRequired=N\u00E3o \u00E9 poss\u00EDvel fazer o login, \u00E9 necess\u00E1ria configura\u00E7\u00E3o de credencial.+identityProviderNotUniqueMessage=O dom\u00EDnio suporta m\u00FAltiplos provedores de identidade. N\u00E3o foi poss\u00EDvel determinar qual o provedor de identidade deve ser usado para se autenticar. emailVerifiedMessage=O seu endere\u00E7o de e-mail foi confirmado.+staleEmailVerificationLink=O link em que voc\u00EA clicou \u00E9 um link antigo e n\u00E3o \u00E9 mais v\u00E1lido. Talvez voc\u00EA j\u00E1 tenha verificado seu e-mail.+identityProviderAlreadyLinkedMessage=A identidade federada retornada por {0} j\u00E1 est\u00E1 vinculada a outro usu\u00E1rio.",Too technical? Maybe`A conta retornada do {0} j est vinculada ...` ?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6828,387570146,2020-03-04T10:17:30Z,services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpUsernamePasswordForm.java,"@@ -22,51 +22,76 @@ import org.keycloak.authentication.AuthenticationFlowException; import org.keycloak.authentication.authenticators.broker.util.SerializedBrokeredIdentityContext; import org.keycloak.authentication.authenticators.browser.UsernamePasswordForm;+import org.keycloak.broker.provider.BrokeredIdentityContext; import org.keycloak.forms.login.LoginFormsProvider; import org.keycloak.models.UserModel; import org.keycloak.services.managers.AuthenticationManager; import org.keycloak.services.messages.Messages; +import java.util.Optional;+ import javax.ws.rs.core.MultivaluedMap; import javax.ws.rs.core.Response;  /**- * Same like classic username+password form, but username is ""known"" and user can't change it+ * Same like classic username+password form, but for use in IdP linking.+ *+ * User identity is optionally established by the preceding idp-create-user-if-unique execution.+ * In this case username field will be pre-filled (but still changeable).  *  * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>  */ public class IdpUsernamePasswordForm extends UsernamePasswordForm {      @Override     protected Response challenge(AuthenticationFlowContext context, MultivaluedMap<String, String> formData) {-        UserModel existingUser = AbstractIdpAuthenticator.getExistingUser(context.getSession(), context.getRealm(), context.getAuthenticationSession());--        return setupForm(context, formData, existingUser)+        return setupForm(context, formData, getExistingUser(context))                 .setStatus(Response.Status.OK)                 .createLoginUsernamePassword();     }      @Override     protected boolean validateForm(AuthenticationFlowContext context, MultivaluedMap<String, String> formData) {-        UserModel existingUser = AbstractIdpAuthenticator.getExistingUser(context.getSession(), context.getRealm(), context.getAuthenticationSession());-        context.setUser(existingUser);+        Optional<UserModel> existingUser = getExistingUser(context);+        existingUser.ifPresent(context::setUser);++        boolean result = validateUserAndPassword(context, formData);          // Restore formData for the case of error         setupForm(context, formData, existingUser); -        return validatePassword(context, existingUser, formData);+        return result;     } -    protected LoginFormsProvider setupForm(AuthenticationFlowContext context, MultivaluedMap<String, String> formData, UserModel existingUser) {+    protected LoginFormsProvider setupForm(AuthenticationFlowContext context, MultivaluedMap<String, String> formData, Optional<UserModel> existingUser) {         SerializedBrokeredIdentityContext serializedCtx = SerializedBrokeredIdentityContext.readFromAuthenticationSession(context.getAuthenticationSession(), AbstractIdpAuthenticator.BROKERED_CONTEXT_NOTE);         if (serializedCtx == null) {             throw new AuthenticationFlowException(""Not found serialized context in clientSession"", AuthenticationFlowError.IDENTITY_PROVIDER_ERROR);         } -        formData.putSingle(AuthenticationManager.FORM_USERNAME, existingUser.getUsername());-        return context.form()+        existingUser.ifPresent(u -> formData.putSingle(AuthenticationManager.FORM_USERNAME, u.getUsername()));++        LoginFormsProvider form = context.form()                 .setFormData(formData)-                .setAttribute(LoginFormsProvider.USERNAME_EDIT_DISABLED, true)-                .setInfo(Messages.FEDERATED_IDENTITY_CONFIRM_REAUTHENTICATE_MESSAGE, existingUser.getUsername(), serializedCtx.getIdentityProviderId());+                .setAttribute(LoginFormsProvider.REGISTRATION_DISABLED, true)+                .setInfo(Messages.FEDERATED_IDENTITY_CONFIRM_REAUTHENTICATE_MESSAGE, serializedCtx.getIdentityProviderId());","There is one small issue that changing the message and arguments would mean that message will be a bit broken for other languages despite english. I see you updated english resource bundle in this PR, but assuming you did not updated it, the message will be something like `Authenticate as 'twitter' to link your account with`Some similar out-of-sense message is now likely displayed for other languages.I wonder if you can try to update the message for other languages as well? I understand you don't understand other languages, but maybe at least some best-effort? :)For example, I assume that French message `Identifiez vous en tant que {0} afin de lier votre compte avec {1}`could be probably changed to something like `Identifiez vous en tant afin de lier votre compte avec {0}`(I don't understand french, so really just best-effort from my side :)Another option is to remove the message and create completely new message, which will mean that other languages will see just default english message.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6828,387577167,2020-03-04T10:29:42Z,services/src/main/java/org/keycloak/services/resources/IdentityBrokerService.java,"@@ -796,9 +812,13 @@ private Response afterPostBrokerLoginFlowSuccess(AuthenticationSessionModel auth             if (firstBrokerLoginInProgress) {                 logger.debugf(""Reauthenticated with broker '%s' when linking user '%s' with other broker"", context.getIdpConfig().getAlias(), federatedUser.getUsername()); -                UserModel linkingUser = AbstractIdpAuthenticator.getExistingUser(session, realmModel, authSession);-                if (!linkingUser.getId().equals(federatedUser.getId())) {-                    return redirectToErrorPage(authSession, Response.Status.BAD_REQUEST, Messages.IDENTITY_PROVIDER_DIFFERENT_USER_MESSAGE, federatedUser.getUsername(), linkingUser.getUsername());+                try {+                    UserModel linkingUser = AbstractIdpAuthenticator.getExistingUser(session, realmModel, authSession);","Instead of this change, could we remove the check for `if (!linkingUser.getId().equals(federatedUser.getId()))` entirely? With this PR, there is a way that user authenticated in username/password form could be different than the one in the ""AbstractIdpAuthenticator.getExistingUser"" . So I believe that same logic can be for broker re-authentication. This means that IDENTITY_PROVIDER_DIFFERENT_USER_MESSAGE can be removed entirely from the ""Messages"" class and resource bundles. I think the similar change may now need to be done in the ResetCredentialsActionTokenHandler",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6846,387613166,2020-03-04T11:42:02Z,services/src/main/java/org/keycloak/services/Urls.java,"@@ -273,4 +277,33 @@ private static UriBuilder themeBase(URI baseUri) {     public static URI samlRequestEndpoint(final URI baseUri, final String realmName) {         return realmBase(baseUri).path(RealmsResource.class, ""getProtocol"").build(realmName, SamlProtocol.LOGIN_PROTOCOL);     }++    public static void checkUrl(KeycloakSession session, String url, String name) throws IllegalArgumentException{",What if we move to `org.keycloak.common.util.UriUtils` instead of creating a new class?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6865,388134807,2020-03-05T08:15:35Z,services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java,"@@ -254,6 +254,10 @@ public Response createForm(String form) {         Locale locale = session.getContext().resolveLocale(user);         Properties messagesBundle = handleThemeResources(theme, locale); +        if (authenticationSession != null && authenticationSession.getClientNote(Constants.KC_ACTION_EXECUTING) != null) {","Will it makes sense to move this to method ""createCommonAttributes"" and remove the very same block from ""createResponse"" so that it is not same code duplicated on 2 places?",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/6861,388204092,2020-03-05T10:27:54Z,server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java,"@@ -55,6 +55,49 @@  * @version $Revision: 1 $  */ public class ModelToRepresentation {++    public static Set<String> REALM_EXCLUDED_ATTRIBUTES = new HashSet<>();+    static {+        REALM_EXCLUDED_ATTRIBUTES.add(""displayName"");+        REALM_EXCLUDED_ATTRIBUTES.add(""displayNameHtml"");+        REALM_EXCLUDED_ATTRIBUTES.add(""defaultSignatureAlgorithm"");+        REALM_EXCLUDED_ATTRIBUTES.add(""bruteForceProtected"");+        REALM_EXCLUDED_ATTRIBUTES.add(""permanentLockout"");+        REALM_EXCLUDED_ATTRIBUTES.add(""maxFailureWaitSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""waitIncrementSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""quickLoginCheckMilliSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""minimumQuickLoginWaitSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""maxDeltaTimeSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""failureFactor"");+        REALM_EXCLUDED_ATTRIBUTES.add(""actionTokenGeneratedByAdminLifespan"");+        REALM_EXCLUDED_ATTRIBUTES.add(""actionTokenGeneratedByUserLifespan"");+        REALM_EXCLUDED_ATTRIBUTES.add(""offlineSessionMaxLifespanEnabled"");+        REALM_EXCLUDED_ATTRIBUTES.add(""offlineSessionMaxLifespan"");++        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRpEntityName"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicySignatureAlgorithms"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRpId"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAttestationConveyancePreference"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAuthenticatorAttachment"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRequireResidentKey"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyUserVerificationRequirement"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyCreateTimeout"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAvoidSameAuthenticatorRegister"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAcceptableAaguids"");++        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRpEntityNamePasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicySignatureAlgorithmsPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRpIdPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAttestationConveyancePreferencePasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAuthenticatorAttachmentPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRequireResidentKeyPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyUserVerificationRequirementPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyCreateTimeoutPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAvoidSameAuthenticatorRegisterPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAcceptableAaguidsPasswordless"");","IMO the names of the fields are incorrect. It should contains ""Passwordless"" word in the middle of the name.So, instead `webAuthnPolicyRpEntityNamePasswordless` should be `webAuthnPolicyPasswordlessRpEntityName` like in _RealmRepresentation_ class.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6861,388271853,2020-03-05T12:48:45Z,server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java,"@@ -55,6 +55,49 @@  * @version $Revision: 1 $  */ public class ModelToRepresentation {++    public static Set<String> REALM_EXCLUDED_ATTRIBUTES = new HashSet<>();+    static {+        REALM_EXCLUDED_ATTRIBUTES.add(""displayName"");+        REALM_EXCLUDED_ATTRIBUTES.add(""displayNameHtml"");+        REALM_EXCLUDED_ATTRIBUTES.add(""defaultSignatureAlgorithm"");+        REALM_EXCLUDED_ATTRIBUTES.add(""bruteForceProtected"");+        REALM_EXCLUDED_ATTRIBUTES.add(""permanentLockout"");+        REALM_EXCLUDED_ATTRIBUTES.add(""maxFailureWaitSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""waitIncrementSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""quickLoginCheckMilliSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""minimumQuickLoginWaitSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""maxDeltaTimeSeconds"");+        REALM_EXCLUDED_ATTRIBUTES.add(""failureFactor"");+        REALM_EXCLUDED_ATTRIBUTES.add(""actionTokenGeneratedByAdminLifespan"");+        REALM_EXCLUDED_ATTRIBUTES.add(""actionTokenGeneratedByUserLifespan"");+        REALM_EXCLUDED_ATTRIBUTES.add(""offlineSessionMaxLifespanEnabled"");+        REALM_EXCLUDED_ATTRIBUTES.add(""offlineSessionMaxLifespan"");++        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRpEntityName"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicySignatureAlgorithms"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRpId"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAttestationConveyancePreference"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAuthenticatorAttachment"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRequireResidentKey"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyUserVerificationRequirement"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyCreateTimeout"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAvoidSameAuthenticatorRegister"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAcceptableAaguids"");++        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRpEntityNamePasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicySignatureAlgorithmsPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRpIdPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAttestationConveyancePreferencePasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAuthenticatorAttachmentPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyRequireResidentKeyPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyUserVerificationRequirementPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyCreateTimeoutPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAvoidSameAuthenticatorRegisterPasswordless"");+        REALM_EXCLUDED_ATTRIBUTES.add(""webAuthnPolicyAcceptableAaguidsPasswordless"");","Doesn't matter what the name of the fields are in the representation. What matters key is used by the RealmAdapter. See here:https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java#L984The RealmAdapter uses ""<Key>"" + ""Passwordless"", so will be webAuthnPolicyRpEntityNamePasswordless.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6842,390335810,2020-03-10T14:03:56Z,services/src/main/java/org/keycloak/services/resources/admin/IdentityProvidersResource.java,"@@ -134,6 +135,9 @@ public Response getIdentityProviders(@PathParam(""provider_id"") String providerId         if (!(data.containsKey(""providerId"") && data.containsKey(""fromUrl""))) {             throw new BadRequestException();         }+        +        ReservedCharValidator.validate((String)data.get(""alias""));","Should this be data.get(""alias"").toString()?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6825,390756664,2020-03-11T05:46:11Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/GroupResource.java,"@@ -82,7 +82,7 @@      */     @PUT     @Consumes(MediaType.APPLICATION_JSON)-    void update(GroupRepresentation rep);+    Response update(GroupRepresentation rep);","I am not sure about changing this to ""Response"" . My vote is to keep return type to ""void"" .With the ""void"", it means that exception is thrown for the client if something is bad (duplicate name etc). Which is in general better IMO as client knows that something was wrong. With ""Response"", the client explicitly needs to check if response status was correct, also he may need to close the responses etc. Just my 2 cents.@stianst wdyt about this?BTV. It is fine to change the server method with return type ""Response"" and just the client keep to ""void"" . It should work just fine.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6825,390928220,2020-03-11T12:12:53Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/GroupResource.java,"@@ -82,7 +82,7 @@      */     @PUT     @Consumes(MediaType.APPLICATION_JSON)-    void update(GroupRepresentation rep);+    Response update(GroupRepresentation rep);","@mposolda @stianst We haven't been consistent about this.  I was trying to follow convention of other API's.  Now I see that some use an exception while others stuff an error into a Response.  (I also found that the admin UI handles a Response better than an exception.  In the future we need to handle errors consistently and also localize the error messages.)I would prefer to not change this code just because I would have to go in and rewrite a lot of stuff, especially the tests.  But it's OK if you guys think that's what I should do.  Please let me know.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6825,391033652,2020-03-11T14:58:27Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/GroupResource.java,"@@ -82,7 +82,7 @@      */     @PUT     @Consumes(MediaType.APPLICATION_JSON)-    void update(GroupRepresentation rep);+    Response update(GroupRepresentation rep);","I can see that admin-client returns usually ""void"" on all the places where @PUT method is used. There is no other @PUT method, which returns ""Response"" . Also changing org.keycloak.admin.client.resource.GroupResource.update to return ""Response"" instead of ""void"" can theoretically break backwards compatibility for some clients, who use this (they rely on catching the Exception and now they will need to change to rely on checking Response status).Also I think that admin client is unrelated to the admin UI as admin UI doesn't use admin-client? IMO it's not an issue to keep just org.keycloak.admin.client.resource.GroupResource.update to return ""void"", but return ""Response"" from the server-side org.keycloak.services.resources.admin.GroupResource . Both GroupResource class from admin-client and keycloak-services are unrelated to each other - the only contract between them is REST interface, not tightly coupled java interface or something.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6825,391787912,2020-03-12T17:43:25Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/GroupResource.java,"@@ -82,7 +82,7 @@      */     @PUT     @Consumes(MediaType.APPLICATION_JSON)-    void update(GroupRepresentation rep);+    Response update(GroupRepresentation rep);","Yes, I was talking about the REST API and not the client.  I guess it's not so bad if we only need to leave the client as returning void.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6825,391789136,2020-03-12T17:45:24Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/GroupResource.java,"@@ -82,7 +82,7 @@      */     @PUT     @Consumes(MediaType.APPLICATION_JSON)-    void update(GroupRepresentation rep);+    Response update(GroupRepresentation rep);",I was talking about the REST API.  I guess it's not so bad if we only need to change the client signature.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6893,392323067,2020-03-13T16:06:03Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/SigningInPage.java,"@@ -192,6 +192,15 @@ public String getUserLabel() {             return getTextFromItem(LABEL);         } +        public boolean hasCreatedAt() {+            boolean result = false;+            try {+                result = getItemElement(CREATED_AT) != null;",`getItemElement` can never return null. It will either return the element or throw an exception.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6912,396023501,2020-03-21T19:51:24Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/events/GroupAddedEvent.java,"@@ -69,6 +74,7 @@ public void writeObject(ObjectOutput output, GroupAddedEvent obj) throws IOExcep              MarshallUtil.marshallString(obj.groupId, output);             MarshallUtil.marshallString(obj.realmId, output);+            MarshallUtil.marshallString(obj.parentId, output);","This should be `VERSION_2` serialization, since the structure of the message has changed and it is thus not possible to read version 1 messages anymore without an exception.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6908,397703856,2020-03-25T09:14:13Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -40,6 +40,7 @@      void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink);     boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider);+    void removeFederatedIdentity(RealmModel realm, String socialProvider);","Just minor concern, but from the name of this method, it is not obvious what is is doing... Is it possible to change the method signature to ""preRemove(RealmModel, IdentityProviderModel)"" to be compatible with all the other similar methods on the UserProvider interface (methods which intercepts removing on some realm object) ? WDYT?",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/6928,399124767,2020-03-27T09:11:12Z,pom.xml,"@@ -41,35 +41,35 @@          <product.build-time>${timestamp}</product.build-time> -        <wildfly.version>18.0.1.Final</wildfly.version>-        <wildfly.build-tools.version>1.2.12.Final</wildfly.build-tools.version>+        <wildfly.version>19.0.0.Final</wildfly.version>+        <wildfly.build-tools.version>1.2.13.Final</wildfly.build-tools.version>         <eap.version>7.3.0.GA-redhat-00004</eap.version>-        <wildfly.core.version>10.0.3.Final</wildfly.core.version>+        <wildfly.core.version>11.0.0.Final</wildfly.core.version>          <jboss.as.version>7.2.0.Final</jboss.as.version>         <jboss.as.subsystem.test.version>7.5.22.Final-redhat-1</jboss.as.subsystem.test.version>          <!-- Versions used mostly for Undertow server, aligned with WildFly -->         <jboss.aesh.version>0.66.19</jboss.aesh.version>         <aesh.version>2.4</aesh.version>-        <apache.httpcomponents.version>4.5.4</apache.httpcomponents.version>-        <apache.httpcomponents.httpcore.version>4.4.5</apache.httpcomponents.httpcore.version>+        <apache.httpcomponents.version>4.5.11</apache.httpcomponents.version>+        <apache.httpcomponents.httpcore.version>4.4.13</apache.httpcomponents.httpcore.version>         <apache.mime4j.version>0.6</apache.mime4j.version>         <jboss.dmr.version>1.5.0.Final</jboss.dmr.version>-        <bouncycastle.version>1.60</bouncycastle.version>-        <cxf.version>3.3.4</cxf.version>-        <cxf.jetty.version>3.3.4</cxf.jetty.version>-        <cxf.jaxrs.version>3.3.4</cxf.jaxrs.version>-        <cxf.undertow.version>3.3.4</cxf.undertow.version>+        <bouncycastle.version>1.62</bouncycastle.version>+        <cxf.version>3.3.5</cxf.version>+        <cxf.jetty.version>3.3.5</cxf.jetty.version>+        <cxf.jaxrs.version>3.3.5</cxf.jaxrs.version>+        <cxf.undertow.version>3.3.5</cxf.undertow.version>         <dom4j.version>2.1.1</dom4j.version>-        <github.relaxng.version>2.3.1</github.relaxng.version>-        <h2.version>1.4.193</h2.version>+        <github.relaxng.version>2.3.3-b02</github.relaxng.version>",I just noticed this dependency has a different GAV than in Wildfly. It doesn't even exist in this version. Please remove it completely as it's not used.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6953,402406793,2020-04-02T15:31:30Z,integration/client-cli/admin-cli/src/main/java/org/keycloak/client/admin/cli/util/HttpUtil.java,"@@ -442,7 +442,11 @@ public static String getIdForType(String rootUrl, String realm, String auth, Str     public static String getAttrForType(String rootUrl, String realm, String auth, String resourceEndpoint, String attrName, String attrValue, String returnAttrName) {          String resourceUrl = composeResourceUrl(rootUrl, realm, resourceEndpoint);-        resourceUrl = HttpUtil.addQueryParamsToUri(resourceUrl, attrName, attrValue, ""first"", ""0"", ""max"", ""2"");+        if (""roles"".equals(resourceEndpoint)) {",This really smells of work-around rather than a fix?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6910,402918185,2020-04-03T10:43:57Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/ReferrerTest.java,"@@ -163,8 +163,6 @@ private String getFakeClientUrl() {         // we need to use some page which host exists  Firefox is throwing exceptions like crazy if we try to load         // a page on a non-existing host, like e.g. http://non-existing-server/         // also we need to do this here as getAuthServerRoot is not ready when firing this class' constructor-        return getAuthServerRoot() + ""auth/non-existing-page/?foo=bar"";-        // TODO replace ^^ with the following once KEYCLOAK-12173 and KEYCLOAK-12189 are resolved-        // return getAuthServerRoot() + ""auth/non-existing-page/?foo=bar&bar=foo#anchor"";+         return getAuthServerRoot() + ""auth/non-existing-page/?foo=bar&bar=foo#anchor"";","We currently have no way how to test [KEYCLOAK-12189](https://issues.redhat.com/browse/KEYCLOAK-12189) as i18n support was temporarily removed from the new Account Console and the test related to [KEYCLOAK-12189](https://issues.redhat.com/browse/KEYCLOAK-12189) was [ignored](https://github.com/keycloak/keycloak/blob/e731736d7e37d4e49279746d736c223c15da541c/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/ReferrerTest.java#L130) for now. So even though we cannot confirm [KEYCLOAK-12189](https://issues.redhat.com/browse/KEYCLOAK-12189) was fixed by this PR, it's safe to do this change.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6897,404054605,2020-04-06T12:33:38Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/LoggedInPageHeaderTest.java,"@@ -0,0 +1,44 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.ui.account2;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.ui.account2.page.AbstractLoggedInPage;+import org.keycloak.testsuite.ui.account2.page.LoggedInPageHeaderPage;++import static org.junit.Assert.assertTrue;++public class LoggedInPageHeaderTest extends BaseAccountPageTest {","I don't think we necessarily need to make a separate test for this. It could ""piggyback"" on some other test class, e.g. [PersonalInfoTest](https://github.com/keycloak/keycloak/blob/f2715025b344d37411701efec2df07376836979e/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/PersonalInfoTest.java). (I think you had it like that at some point.)But if you decide it should have its own test class (which is also ok), please don't base it on BaseAccountPageTest as it contains some features specific for a page test (like a navigation test, e.g.). You can use [AbstractAccountTest](https://github.com/keycloak/keycloak/blob/f2715025b344d37411701efec2df07376836979e/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/AbstractAccountTest.java) instead as a much more suitable option.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6897,404056556,2020-04-06T12:37:05Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/LoggedInPageHeaderPage.java,"@@ -0,0 +1,43 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.ui.account2.page;++import org.keycloak.representations.idm.UserRepresentation;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIAssert.assertElementDisabled;+import static org.keycloak.testsuite.util.UIAssert.assertInputElementValid;+import static org.keycloak.testsuite.util.UIUtils.getTextInputValue;+import static org.keycloak.testsuite.util.UIUtils.setTextInputValue;++import static org.junit.Assert.assertEquals;++public class LoggedInPageHeaderPage extends AbstractLoggedInPage {","Please don't make a separate Page Class for this. It's not a page, it's part of a page header. Please move its content to [AbstractHeader](https://github.com/keycloak/keycloak/blob/f2715025b344d37411701efec2df07376836979e/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/fragment/AbstractHeader.java) (if the username will be displayed on Welcome Screen as well) or [LoggedInPageHeader](https://github.com/keycloak/keycloak/blob/f2715025b344d37411701efec2df07376836979e/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/fragment/LoggedInPageHeader.java).",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6897,404637825,2020-04-07T08:41:07Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/LoggedInPageHeaderTest.java,"@@ -0,0 +1,44 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.ui.account2;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.ui.account2.page.AbstractLoggedInPage;+import org.keycloak.testsuite.ui.account2.page.LoggedInPageHeaderPage;++import static org.junit.Assert.assertTrue;++public class LoggedInPageHeaderTest extends BaseAccountPageTest {",@edewit How did I change my mind? :) The citation you're mentioning is specifically about the page object whereas this thread is about the test class. If something's not clear please let me know  we could e.g. schedule a call and talk about it.,
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/6897,404663487,2020-04-07T09:21:34Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/LoggedInPageHeaderTest.java,"@@ -0,0 +1,44 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.ui.account2;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.ui.account2.page.AbstractLoggedInPage;+import org.keycloak.testsuite.ui.account2.page.LoggedInPageHeaderPage;++import static org.junit.Assert.assertTrue;++public class LoggedInPageHeaderTest extends BaseAccountPageTest {","Okay now I'm totally confused, based on you comment I moved all the stuff to separate classes. Then you comment that I shouldn't do that so I revert. I might have misinterpreted that, because you only mend the stuff from `PersonalInfoPage`, but here in this PR you also say that I shouldn't have a `LoggedInPageHeader`",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6897,404675533,2020-04-07T09:40:44Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/LoggedInPageHeaderTest.java,"@@ -0,0 +1,44 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.ui.account2;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.ui.account2.page.AbstractLoggedInPage;+import org.keycloak.testsuite.ui.account2.page.LoggedInPageHeaderPage;++import static org.junit.Assert.assertTrue;++public class LoggedInPageHeaderTest extends BaseAccountPageTest {",Thank you. My whole point was to simply follow the pattern we have in the tests to keep the code consistent and clean.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6897,405434981,2020-04-08T10:52:03Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/PersonalInfoTest.java,"@@ -154,6 +155,11 @@ public void disabledEditUsername() {         personalInfoPage.valuesEqual(testUser2);     } +    @Test+    public void testNameInToolbar() {+        assertEquals(""test user"", personalInfoPage.header().getToolbarLoggedInUser().getText());","Looks good, thanks. Could you please add something similar for welcome screen as well? It doesn't share the implementation with React pages, so it's worth to have a separate test for that too.Also, on welcome screen please test that the user is not displayed at all if not logged in. We have to make sure we don't have gaps in test coverage. :)",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6897,405437402,2020-04-08T10:56:44Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/fragment/LoggedInPageHeader.java,"@@ -73,4 +76,8 @@ protected WebElement getLogoutBtn() {     protected WebElement getReferrerLink() {         return isMobileLayout() ? referrerLinkMobile : referrerLink;     }++    public WebElement getToolbarLoggedInUser() {+        return toolbarLoggedInUser;",Please return `String` from this element using [`getTextFromElement`](https://github.com/keycloak/keycloak/blob/de8ba75399209121f4238aef567795c1c4e7c938/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/UIUtils.java#L154) as it includes some hacks (and more might be added in the future).```suggestion    public String getToolbarLoggedInUser() {        return getTextFromElement(toolbarLoggedInUser);```,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6897,408080827,2020-04-14T12:00:55Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/keycloak-service/keycloak.service.ts,"@@ -84,6 +84,21 @@ export class KeycloakService {         return KeycloakService.keycloakAuth.realm;     } +    public get userName(): string {+        let userName = 'Anonymous';",I don't know enough to say with 100% certainty.  It's not a big deal to localize just in case.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6897,408750682,2020-04-15T10:47:59Z,themes/src/main/resources/theme/keycloak-preview/account/index.ftl,"@@ -160,6 +178,10 @@               <button id=""landingSignOutButton"" tabindex=""0"" style=""display:none"" onclick=""keycloak.logout();"" class=""pf-c-button pf-m-primary"" type=""button"">${msg(""doSignOut"")}</button>             </div> +            <div class=""pf-l-toolbar__group"" style=""margin-left: 10px;"">+                <span id=""loggedInUser""></span>","I've noticed we use the same ID both at Welcome Screen and at React pages. The Welcome Screen is technically always present in the DOM, just hidden when a React page is loaded. I'm no HTML expert, so correct me if I'm wrong, but I think it's not valid to have duplicit IDs in HTML and it could theoretically cause some problems. One thing I can think of is testing it could be a bit nondeterministic as we don't know which of the elements with this ID was selected.At the Welcome Screen we usually use `landing` prefix for IDs to prevent this kind of issues.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6980,409550090,2020-04-16T13:21:00Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java,"@@ -237,16 +233,33 @@ public boolean supportsCredentialAuthenticationFor(String type) {               for (LDAPObject ldapUser : ldapObjects) {                  String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());-                 if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {+                 UserModel localUser = session.userLocalStorage().getUserByUsername(ldapUsername, realm);+                 if (localUser == null) {                      UserModel imported = importUserFromLDAP(session, realm, ldapUser);                      searchResults.add(imported);+                 } else if (shouldUserAttributeBeAlwaysReadFromLdap(realm, attrName)) {+                     searchResults.add(proxy(realm, localUser, ldapUser));","I think it will be good to remove method ""shouldUserAttributeBeAlwaysReadFromLdap"" (and any new things related to that added in this PR) and just always add the proxy to the results.Regarding this, it may be also good to update a bit method UserStorageManager.query and make sure that duplicates are not returned. As currently UserStorageMAnager.query returns stuff from multiple providers, so it can probably return duplicated stuff in some cases (EG. in case that LDAP user was imported and attribute ""foo"" with value ""bar"" is available in both the DB and LDAP)",
12183470,sventorben,https://api.github.com/repos/keycloak/keycloak/pulls/6980,409795229,2020-04-16T19:24:23Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java,"@@ -237,16 +233,33 @@ public boolean supportsCredentialAuthenticationFor(String type) {               for (LDAPObject ldapUser : ldapObjects) {                  String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());-                 if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {+                 UserModel localUser = session.userLocalStorage().getUserByUsername(ldapUsername, realm);+                 if (localUser == null) {                      UserModel imported = importUserFromLDAP(session, realm, ldapUser);                      searchResults.add(imported);+                 } else if (shouldUserAttributeBeAlwaysReadFromLdap(realm, attrName)) {+                     searchResults.add(proxy(realm, localUser, ldapUser));","In which case would we consider two users from different stores to be duplicates?They may be duplicates when user from LDAP has been imported to local store. Then LDAP user and user from local store could be considered duplicates.Should we treat users from (let say) a custom storage provider and the LDAP provider to be duplicates (e.g. when usernames are equal)? And if we have duplicates, which user model should be removed from the result set?Is it always the one from the local store, because the one from LDAP provider will always proxy the local one anyways?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6971,410273802,2020-04-17T14:49:02Z,services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java,"@@ -1015,13 +1014,15 @@ public static ClientSessionContext attachSession(AuthenticationSessionModel auth                 userSession.restartSession(realm, authSession.getAuthenticatedUser(), username, connection.getRemoteAddr(), authSession.getProtocol()                         , remember, brokerSessionId, brokerUserId);             } else {-                // We have existing userSession even if it wasn't attached to authenticator. Could happen if SSO authentication was ignored (eg. prompt=login) and in some other cases.-                // We need to handle case when different user was used-                logger.debugf(""No SSO login, but found existing userSession with ID '%s' after finished authentication."", userSession.getId());                 if (!authSession.getAuthenticatedUser().equals(userSession.getUser())) {-                    event.detail(Details.EXISTING_USER, userSession.getUser().getId());-                    event.error(Errors.DIFFERENT_USER_AUTHENTICATED);-                    throw new ErrorPageException(session, authSession, Response.Status.INTERNAL_SERVER_ERROR, Messages.DIFFERENT_USER_AUTHENTICATED, userSession.getUser().getUsername());+                    AuthenticationManager.backchannelLogout(session, userSession, true);","Well, my hope is, we can always logout original user and create new userSession. This can be for all flows like ""register"", ""reset-credentials"" or ""login"" and will allow to avoid some additional complexity.BTV. There is discussion on keycloak-dev regarding this, so I suggest to continue discussion there.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/6964,411157367,2020-04-20T07:33:38Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -307,7 +307,7 @@ protected Response loginRequest(String relayState, AuthnRequestType requestAbstr                 } else {                     redirect = client.getAttribute(SamlProtocol.SAML_ASSERTION_CONSUMER_URL_REDIRECT_ATTRIBUTE);                 }-                if (redirect == null) {+                if (redirect == null || redirect.isEmpty()) {",Should we use `trim()` here? Similarly to this: https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/saml/SamlService.java#L726If yes it should be fixed also here: https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/saml/installation/SamlSPDescriptorClientInstallation.java#L59BTW: there is also a [copy&paste bug](https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/saml/installation/SamlSPDescriptorClientInstallation.java#L61). Should we fix it here or in separate Jira?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6705,411436701,2020-04-20T14:44:27Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties,"@@ -540,6 +540,14 @@ provider=Provider gui-order=GUI order first-broker-login-flow=First Login Flow post-broker-login-flow=Post Login Flow+sync-mode=Sync Mode+sync-mode.tooltip=Default sync mode for all mappers. The sync mode determines when user data will be synced using the mappers. Possible values are: 'legacy' to keep the behaviour before this option was introduced, 'import' to only import the user once, 'force' to always update the user.",See my note above for the similar tooltip,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6705,411448172,2020-04-20T14:58:42Z,server-spi/src/main/java/org/keycloak/models/IdentityProviderModel.java,"@@ -64,6 +66,8 @@      private String displayName; +    private IdentityProviderSyncMode syncMode;","Is it possible to remove this field entirely and change getter/setter to directly read the value from the ""config"" ? For example something like:```public IdentityProviderSyncMode getSyncMode() {    return getConfig().containsKey(IdentityProviderModel.SYNC_MODE)                ? IdentityProviderSyncMode.valueOf(getConfig().get(IdentityProviderModel.SYNC_MODE))                : IdentityProviderSyncMode.LEGACY);}public void setSyncMode(IdentityProviderSyncMode syncMode) {    getConfig().put(IdentityProviderModel.SYNC_MODE, syncMode);}```See for example classes like OIDCIdentityProviderConfig or OAuth2IdentityProviderConfig, which contains bunch of other similar options.I think this will simplify lots of other things and reduce the amount of changes at the model classes you needed to do in this PR. For example classes like RealmAdapter, ModelToRepresentation, RepresentationToModel etc won't be needed to be changed at all in this PR IMO.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6705,411449930,2020-04-20T15:00:52Z,server-spi/src/main/java/org/keycloak/models/IdentityProviderMapperModel.java,"@@ -41,6 +42,7 @@     protected String name;     protected String identityProviderAlias;     protected String identityProviderMapper;+    protected IdentityProviderMapperSyncMode syncMode;",See my comment for the class IdentityProviderModel.java. I think same can be applied here.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6705,411499328,2020-04-20T16:02:36Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountFormServiceTest.java,"@@ -121,20 +122,24 @@ public void configureTestRealm(RealmRepresentation testRealm) {         testRealm.addIdentityProvider(IdentityProviderBuilder.create()                                               .providerId(""github"")                                               .alias(""github"")+                                              .syncMode(IdentityProviderSyncMode.IMPORT)","I wonder that many of the existing tests possibly won't need to be changed? Assuming that you remove the field like ""syncMode"" directly from the representation and model classes as I proposed in the comments. This will mean it will use the default value ""Legacy"" and the behaviour will be same as before AFAIK?This doesn't apply just for AccountFormServiceTest, but many other tests where you explicitly added "".syncMode(IdentityProviderSyncMode.IMPORT)"" . I won't repeat this comment to all those places.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6705,412200083,2020-04-21T13:48:14Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1287,25 +1291,31 @@ public void addIdentityProvider(IdentityProviderModel identityProvider) {         } else {             entity.setInternalId(identityProvider.getInternalId());         }+        fillEntity(identityProvider, entity);+        entity.setProviderId(identityProvider.getProviderId());++        realm.addIdentityProvider(entity);++        identityProvider.setInternalId(entity.getInternalId());++        em.persist(entity);+        em.flush();+    }++    private void fillEntity(IdentityProviderModel identityProvider, IdentityProviderEntity entity) {","@stianst I think that this PR doesn't need to change anything in the RealmAdapter class at all if some of my other comments are applied - this means using just field from ""config"" map instead of adding additional field into the IdentityProviderModel / IdentityProviderMapperModel classes.",
31658331,Martin-Idel-SI,https://api.github.com/repos/keycloak/keycloak/pulls/6705,412314878,2020-04-21T16:40:44Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountFormServiceTest.java,"@@ -121,20 +122,24 @@ public void configureTestRealm(RealmRepresentation testRealm) {         testRealm.addIdentityProvider(IdentityProviderBuilder.create()                                               .providerId(""github"")                                               .alias(""github"")+                                              .syncMode(IdentityProviderSyncMode.IMPORT)","I removed this line where possible. In fact, this means that now my test changes are limited to the following places:- classes within `org.keycloak.testsuite.broker` package: Most of the tests that don't need the sync mode are left as is, but the broker configurations all need to be adapted due to the nature of the inheritance structure. - classes outside `org.keycloak.testsuite.broker` are only adapted where I added tests (admin console tests and CLI-Test) or improved on existing tests (IdentityProviderTest)Is this enough in your view?",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/6897,414094875,2020-04-23T20:17:04Z,themes/src/main/resources/theme/keycloak-preview/account/index.ftl,"@@ -121,6 +122,23 @@             }).error(function() {                 alert('failed to initialize keycloak');             });++            function loggedInUserName() {+                let userName = '${msg(""unknownUser"")}';+                if (keycloak.tokenParsed) {+                    const givenName = keycloak.tokenParsed.given_name;+                    const familyName = keycloak.tokenParsed.family_name;+                    const preferredUsername = keycloak.tokenParsed.preferred_username;+                    if (givenName && familyName) {+                        userName = [givenName, familyName].reduce((acc, value, index) =>+                            acc.replace('{'+ index + '}', value), '${msg(""fullName"")}'+                        );+                    } else {+                        userName = (givenName || familyName) || preferredUsername || userName;+                    }+                }+                return userName;+            }",@edewit Can you move this function to WelcomePageScripts.js?  index.ftl is too big and hard to manage already.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/6987,414502834,2020-04-24T11:28:29Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/account-page/AccountPage.tsx,"@@ -100,6 +108,9 @@ export class AccountPage extends React.Component<AccountPageProps, AccountPageSt             AccountServiceClient.Instance.doPost(""/"", { data: reqData })                 .then(() => { // to use response, say ((response: AxiosResponse<FormFields>) => {                     ContentAlert.success('accountUpdatedMessage');+                    if (locale !== this.state.formFields.attributes!.locale) {","It seems this condition doesn't work. The whole page is reloaded every time when the form is saved, regardless if the locale changed.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6998,415535967,2020-04-27T06:10:00Z,model/jpa/src/main/java/org/keycloak/models/jpa/entities/RealmEntity.java,"@@ -137,7 +137,7 @@     @Column(name=""EMAIL_THEME"")     protected String emailTheme; -    @OneToMany(cascade ={CascadeType.REMOVE}, orphanRemoval = true, mappedBy = ""realm"")+    @OneToMany(cascade ={CascadeType.REMOVE}, orphanRemoval = true, mappedBy = ""realm"", fetch = FetchType.EAGER)","Yes, as otherwise I get a lazy load error in some tests. Would we ever load realms without attributes? I don't get why this is being lazy loaded in the first place.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6998,415758425,2020-04-27T12:11:10Z,model/jpa/src/main/java/org/keycloak/models/jpa/entities/RealmEntity.java,"@@ -137,7 +137,7 @@     @Column(name=""EMAIL_THEME"")     protected String emailTheme; -    @OneToMany(cascade ={CascadeType.REMOVE}, orphanRemoval = true, mappedBy = ""realm"")+    @OneToMany(cascade ={CascadeType.REMOVE}, orphanRemoval = true, mappedBy = ""realm"", fetch = FetchType.EAGER)","I'm just afraid that this can impact somehow performance when loading realms from the database. If we are sure that attributes are needed when loading a realm, that is OK.But if this is not always true, I'm not sure about the impacts. We already have issues when having a lot of realms, so that could make things even worse?If this was set to EAGER already and you were changing to LAZY, I would have the same considerations.So, if you really think this is not a problem. I'm OK with it.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6704,415853733,2020-04-27T14:20:17Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java,"@@ -0,0 +1,211 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.endpoints;++import java.util.List;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.RefreshToken;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.managers.UserSessionCrossDCManager;+import org.keycloak.services.managers.UserSessionManager;+import org.keycloak.services.resources.Cors;+import org.keycloak.util.TokenUtil;++/**+ * @author <a href=""mailto:yoshiyuki.tabata.jy@hitachi.com"">Yoshiyuki Tabata</a>+ */+public class TokenRevocationEndpoint {+    private static final String PARAM_TOKEN = ""token"";++    @Context+    private KeycloakSession session;++    @Context+    private HttpRequest request;++    @Context+    private HttpHeaders headers;++    @Context+    private ClientConnection clientConnection;++    private MultivaluedMap<String, String> formParams;+    private ClientModel client;+    private RealmModel realm;+    private EventBuilder event;+    private Cors cors;+    private RefreshToken token;+    private UserModel user;++    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {+        this.realm = realm;+        this.event = event;+    }++    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    public Response revoke() {+        event.event(EventType.REVOKE_GRANT);++        cors = Cors.add(request).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);++        checkSsl();+        checkRealm();+        checkClient();++        formParams = request.getDecodedFormParameters();++        checkToken();+        checkIssuedFor();++        checkUser();+        revokeClient();++        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();++        return cors.builder(Response.ok()).build();+    }++    private void checkSsl() {+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(""https"")+            && realm.getSslRequired().isRequired(clientConnection)) {+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, ""HTTPS required"",+                Response.Status.FORBIDDEN);+        }+    }++    private void checkRealm() {+        if (!realm.isEnabled()) {+            throw new CorsErrorResponseException(cors.allowAllOrigins(), ""access_denied"", ""Realm not enabled"",+                Response.Status.FORBIDDEN);+        }+    }++    private void checkClient() {+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);+        client = clientAuth.getClient();++        event.client(client);++        cors.allowedOrigins(session, client);++        if (client.isBearerOnly()) {+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, ""Bearer-only not allowed"",+                Response.Status.BAD_REQUEST);+        }+    }++    private void checkToken() {",It looks like you are missing validations based on the `token_type_hint`. As well as what is the default value we expect if none was provided.I understand this parameter is OPTIONAL and we can infer the token type from the token itself (As we are using JWT as the format). But not validate this parameter can cause confusion given that we are supposed to accept only a specific set of values.,
34849594,y-tabata,https://api.github.com/repos/keycloak/keycloak/pulls/6704,416231002,2020-04-28T00:02:44Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java,"@@ -0,0 +1,211 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.endpoints;++import java.util.List;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.RefreshToken;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.managers.UserSessionCrossDCManager;+import org.keycloak.services.managers.UserSessionManager;+import org.keycloak.services.resources.Cors;+import org.keycloak.util.TokenUtil;++/**+ * @author <a href=""mailto:yoshiyuki.tabata.jy@hitachi.com"">Yoshiyuki Tabata</a>+ */+public class TokenRevocationEndpoint {+    private static final String PARAM_TOKEN = ""token"";++    @Context+    private KeycloakSession session;++    @Context+    private HttpRequest request;++    @Context+    private HttpHeaders headers;++    @Context+    private ClientConnection clientConnection;++    private MultivaluedMap<String, String> formParams;+    private ClientModel client;+    private RealmModel realm;+    private EventBuilder event;+    private Cors cors;+    private RefreshToken token;+    private UserModel user;++    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {+        this.realm = realm;+        this.event = event;+    }++    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    public Response revoke() {+        event.event(EventType.REVOKE_GRANT);++        cors = Cors.add(request).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);++        checkSsl();+        checkRealm();+        checkClient();++        formParams = request.getDecodedFormParameters();++        checkToken();+        checkIssuedFor();++        checkUser();+        revokeClient();++        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();++        return cors.builder(Response.ok()).build();+    }++    private void checkSsl() {+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(""https"")+            && realm.getSslRequired().isRequired(clientConnection)) {+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, ""HTTPS required"",+                Response.Status.FORBIDDEN);+        }+    }++    private void checkRealm() {+        if (!realm.isEnabled()) {+            throw new CorsErrorResponseException(cors.allowAllOrigins(), ""access_denied"", ""Realm not enabled"",+                Response.Status.FORBIDDEN);+        }+    }++    private void checkClient() {+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);+        client = clientAuth.getClient();++        event.client(client);++        cors.allowedOrigins(session, client);++        if (client.isBearerOnly()) {+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, ""Bearer-only not allowed"",+                Response.Status.BAD_REQUEST);+        }+    }++    private void checkToken() {","@pedroigor > But not validate this parameter can cause confusion given that we are supposed to accept only a specific set of values.We are not supposed to accept only a specific set of values. RFC7009 defined two values ""access_token"" and ""refresh_token"", and also says that other values for this parameter can be defined. And RFC 7009 also says like [1], so they can be summarized as follows.- token_type_hint == ""refresh_token"":We will support this and if ""token"" is the refresh token, the server can revoke it. But if ""token"" is not the refresh token, return an error.- token_type_hint == ""access_token"":We will not support this. But if ""token"" is the refresh token, the server can revoke it.- token_type_hint == ""invalid_token_type"":The same as ""access_token"", we will not support this, but if ""token"" is the refresh token, the server can revoke it.- token_type_hint == null:The same as ""access_token"", we will not support this, but if ""token"" is the refresh token, the server can revoke it.According to the above, there is no need to check ""token_type_hint"".[1] If the server is unable to locate the token using the given hint, it MUST extend its search across all of its supported token types. An authorization server MAY ignore this parameter, particularly if it is able to detect the token type automatically. An invalid token type hint value is ignored by the authorization server and does not influence the revocation response.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/6998,416359058,2020-04-28T06:25:15Z,services/src/main/java/org/keycloak/headers/DefaultSecurityHeadersProvider.java,"@@ -0,0 +1,168 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.headers;++import org.jboss.logging.Logger;+import org.keycloak.models.BrowserSecurityHeaders;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;++import javax.ws.rs.InternalServerErrorException;+import javax.ws.rs.container.ContainerRequestContext;+import javax.ws.rs.container.ContainerResponseContext;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import java.util.Map;++public class DefaultSecurityHeadersProvider implements SecurityHeadersProvider {++    private static final Logger LOGGER = Logger.getLogger(DefaultSecurityHeadersProvider.class);++    private final Map<String, String> headerValues;+    private final KeycloakSession session;++    private DefaultSecurityHeadersOptions options;++    public DefaultSecurityHeadersProvider(KeycloakSession session) {+        this.session = session;++        RealmModel realm = session.getContext().getRealm();+        if (realm != null) {+            headerValues = realm.getBrowserSecurityHeaders();+        } else {+            headerValues = BrowserSecurityHeaders.defaultHeaders;+        }+    }++    @Override+    public SecurityHeadersOptions options() {+        if (options == null) {+            options = new DefaultSecurityHeadersOptions();+        }+        return options;+    }++    @Override+    public void addHeaders(ContainerRequestContext requestContext, ContainerResponseContext responseContext) {+        if (options != null && options.isSkipHeaders()) {+            return;+        }++        MediaType requestType = requestContext.getMediaType();+        MediaType responseType = responseContext.getMediaType();+        MultivaluedMap<String, Object> headers = responseContext.getHeaders();++        if (responseType == null && !isEmptyMediaTypeAllowed(requestContext, responseContext)) {+            LOGGER.errorv(""MediaType not set on path {0}, with response status {1}"", session.getContext().getUri().getRequestUri().getPath(), responseContext.getStatus());+            throw new InternalServerErrorException();+        }++        if (isRest(requestType, responseType)) {+            addRestHeaders(headers);+        } else if (isHtml(requestType, responseType)) {+            addHtmlHeaders(headers);+        } else {+            addGenericHeaders(headers);+        }+    }++    private void addGenericHeaders(MultivaluedMap<String, Object> headers) {","Don't like opening up internal classes too much. Someone can also extend be calling the default provider within their extended provider, to then modify the results. It's more likely that folks will want to change one or two headers and not implement all the headers for one ""type"".",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7004,416440916,2020-04-28T08:47:43Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -91,13 +93,15 @@ public Response performLogin(AuthenticationRequest request) {                 protocolBinding = JBossSAMLURIConstants.SAML_HTTP_POST_BINDING.get();             } +            String loginHint = request.getHttpRequest().getUri().getQueryParameters().getFirst(LOGIN_HINT_QUERY_PARAMETER);             SAML2AuthnRequestBuilder authnRequestBuilder = new SAML2AuthnRequestBuilder()",Is there some input validation / escaping required here after reading `loginHint` from the request parameters?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6704,416559000,2020-04-28T12:06:56Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java,"@@ -0,0 +1,211 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.endpoints;++import java.util.List;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.RefreshToken;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.managers.UserSessionCrossDCManager;+import org.keycloak.services.managers.UserSessionManager;+import org.keycloak.services.resources.Cors;+import org.keycloak.util.TokenUtil;++/**+ * @author <a href=""mailto:yoshiyuki.tabata.jy@hitachi.com"">Yoshiyuki Tabata</a>+ */+public class TokenRevocationEndpoint {+    private static final String PARAM_TOKEN = ""token"";++    @Context+    private KeycloakSession session;++    @Context+    private HttpRequest request;++    @Context+    private HttpHeaders headers;++    @Context+    private ClientConnection clientConnection;++    private MultivaluedMap<String, String> formParams;+    private ClientModel client;+    private RealmModel realm;+    private EventBuilder event;+    private Cors cors;+    private RefreshToken token;+    private UserModel user;++    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {+        this.realm = realm;+        this.event = event;+    }++    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    public Response revoke() {+        event.event(EventType.REVOKE_GRANT);++        cors = Cors.add(request).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);++        checkSsl();+        checkRealm();+        checkClient();++        formParams = request.getDecodedFormParameters();++        checkToken();+        checkIssuedFor();++        checkUser();+        revokeClient();++        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();++        return cors.builder(Response.ok()).build();+    }++    private void checkSsl() {+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(""https"")+            && realm.getSslRequired().isRequired(clientConnection)) {+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, ""HTTPS required"",+                Response.Status.FORBIDDEN);+        }+    }++    private void checkRealm() {+        if (!realm.isEnabled()) {+            throw new CorsErrorResponseException(cors.allowAllOrigins(), ""access_denied"", ""Realm not enabled"",+                Response.Status.FORBIDDEN);+        }+    }++    private void checkClient() {+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);+        client = clientAuth.getClient();++        event.client(client);++        cors.allowedOrigins(session, client);++        if (client.isBearerOnly()) {+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, ""Bearer-only not allowed"",+                Response.Status.BAD_REQUEST);+        }+    }++    private void checkToken() {+        String encodedToken = formParams.getFirst(PARAM_TOKEN);++        if (encodedToken == null) {+            event.error(Errors.INVALID_REQUEST);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, ""Token not provided"",+                Response.Status.BAD_REQUEST);+        }++        token = session.tokens().decode(encodedToken, RefreshToken.class);++        if (token == null) {+            event.error(Errors.INVALID_TOKEN);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, ""Invalid token"", Response.Status.OK);+        }++        if (!(TokenUtil.TOKEN_TYPE_REFRESH.equals(token.getType()) || TokenUtil.TOKEN_TYPE_OFFLINE.equals(token.getType()))) {+            event.error(Errors.INVALID_TOKEN_TYPE);+            throw new CorsErrorResponseException(cors, OAuthErrorException.UNSUPPORTED_TOKEN_TYPE, ""Unsupported token type"",+                Response.Status.BAD_REQUEST);+        }+    }++    private void checkIssuedFor() {+        String issuedFor = token.getIssuedFor();+        if (issuedFor == null) {+            event.error(Errors.INVALID_TOKEN);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, ""Invalid token"", Response.Status.OK);+        }++        if (!client.getClientId().equals(issuedFor)) {+            event.error(Errors.INVALID_REQUEST);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, ""Unmatching clients"",+                Response.Status.BAD_REQUEST);+        }+    }++    private void checkUser() {+        UserSessionModel userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm,+            token.getSessionState(), false, client.getId());++        if (userSession == null) {+            userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm, token.getSessionState(), true,+                client.getId());++            if (userSession == null) {+                event.error(Errors.USER_SESSION_NOT_FOUND);+                throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, ""Invalid token"",+                    Response.Status.OK);+            }+        }++        user = userSession.getUser();++        if (user == null) {+            event.error(Errors.USER_NOT_FOUND);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, ""Invalid token"", Response.Status.OK);+        }++        event.user(user);+    }++    private void revokeClient() {+        session.users().revokeConsentForClient(realm, user.getId(), client.getId());","The user does not revoke tokens but clients. Another reason behind my question is that reading the specs it is not clear how consents should be handled when revoking tokens. It does talk about cleaning up data associated with the token (e.g.: session data).IMO, consents span multiple sessions and are not related to a single access token. Users have control over their consent so they can decide whether or not they want to revoke consent for a given client. By revoking consent when revoking tokens you are assuming the end-user also wants to revoke the consent but is that always true?I do see a lot of references where token revocation is more a ""logout""  feature for clients than a revocation mechanism for consents.I know we are talking about OAuth2 and not OIDC. But the specs say:``` From an end-user's perspective, OAuth is often used to **log into** a   certain site or application.  This revocation mechanism allows a   client to invalidate its tokens if the end-user logs out, changes   identity, or uninstalls the respective application.  Notifying the   authorization server that the token is no longer needed allows the   authorization server to clean up data associated with that token   (e.g., **session data**) and the underlying authorization grant.```That is what I mentioned logout. Another reference is https://oauth.net/2/token-revocation/.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6968,419650302,2020-05-04T18:46:39Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/DemoFilterServletAdapterWithIdMapperConfigTest.java,"@@ -0,0 +1,98 @@+/*+ * Copyright 2018 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.adapter.servlet;++import org.junit.Ignore;+import org.junit.Test;+import org.keycloak.adapters.spi.InMemorySessionIdMapper;+import org.keycloak.adapters.spi.SessionIdMapper;+import org.keycloak.testsuite.arquillian.annotation.AppServerContainer;+import org.keycloak.testsuite.utils.annotation.UseServletFilter;+import org.keycloak.testsuite.utils.arquillian.ContainerConstants;++@AppServerContainer(ContainerConstants.APP_SERVER_UNDERTOW)+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY)+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY_DEPRECATED)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP6)+@AppServerContainer(ContainerConstants.APP_SERVER_EAP71)+@UseServletFilter(filterName = ""oidc-filter"", filterClass = ""org.keycloak.adapters.servlet.KeycloakOIDCFilter"",+        filterDependency = ""org.keycloak:keycloak-servlet-filter-adapter"", skipPattern = ""/error.html"", configIdMapperClass = ""org.keycloak.helpers.TestInMemorySessionIdMapper"")+public class DemoFilterServletAdapterWithIdMapperConfigTest extends DemoServletsAdapterTest {","Instead of extending from DemoServletsAdapterTest, it will be better to either:- extend from AbstractServletsAdapterTest and add only single test method- change the existing DemoFilterServletAdapterTest and change the configuration of it to your idMapperAdding completely new class, which extends from DemoServletsAdapterTest adds around 30-50 additional running tests to the testsuite just due this relatively small feature.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6873,420063625,2020-05-05T12:17:17Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/concurrency/ConcurrencyTest.java,"@@ -51,6 +62,38 @@ public void concurrentTest(KeycloakRunnable... tasks) throws Throwable {         System.out.println(""took "" + end + "" ms"");     } +    // KEYCLOAK-8141 Verify that no attribute values are duplicated, and there are no locking exceptions when adding attributes in parallell+    @Test+    @Ignore+    public void createUserAttributes() throws Throwable {+        AtomicInteger c = new AtomicInteger();++        UsersResource users = testRealm().users();++        UserRepresentation u = UserBuilder.create().username(""attributes"").build();+        Response response = users.create(u);","The response is never closed and causes connection leak.`Creator` relieves you from boilerplate code, see e.g. https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java#L2047.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6873,422889413,2020-05-11T08:58:36Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/concurrency/ConcurrencyTest.java,"@@ -51,6 +62,38 @@ public void concurrentTest(KeycloakRunnable... tasks) throws Throwable {         System.out.println(""took "" + end + "" ms"");     } +    // KEYCLOAK-8141 Verify that no attribute values are duplicated, and there are no locking exceptions when adding attributes in parallell+    @Test+    @Ignore+    public void createUserAttributes() throws Throwable {+        AtomicInteger c = new AtomicInteger();++        UsersResource users = testRealm().users();++        UserRepresentation u = UserBuilder.create().username(""attributes"").build();+        Response response = users.create(u);+        String userId = ApiUtil.getCreatedId(response);++        UserResource user = users.get(userId);++        concurrentTest((threadIndex, keycloak, realm) -> {+            UserRepresentation rep = user.toRepresentation();+            rep.singleAttribute(""a-"" + c.getAndIncrement(), ""value"");+            user.update(rep);+        });++        UserRepresentation rep = user.toRepresentation();++        // Number of attributes should be equal to created attributes, or less (concurrent requests may drop attributes added by other threads)+        assertTrue(rep.getAttributes().size() <= c.get());++        // All attributes should have a single value+        for (Map.Entry<String, List<String>> e : rep.getAttributes().entrySet()) {+            assertEquals(1, e.getValue().size());","Not a nitpick.Error reporting with `assertThat` shows the list items which is useful for bug investigation, especially in case of hard-to-reproduce concurrent tests.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6873,422890731,2020-05-11T09:00:42Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/concurrency/ConcurrencyTest.java,"@@ -51,6 +62,38 @@ public void concurrentTest(KeycloakRunnable... tasks) throws Throwable {         System.out.println(""took "" + end + "" ms"");     } +    // KEYCLOAK-8141 Verify that no attribute values are duplicated, and there are no locking exceptions when adding attributes in parallell+    @Test+    @Ignore+    public void createUserAttributes() throws Throwable {+        AtomicInteger c = new AtomicInteger();++        UsersResource users = testRealm().users();++        UserRepresentation u = UserBuilder.create().username(""attributes"").build();+        Response response = users.create(u);+        String userId = ApiUtil.getCreatedId(response);++        UserResource user = users.get(userId);++        concurrentTest((threadIndex, keycloak, realm) -> {+            UserRepresentation rep = user.toRepresentation();+            rep.singleAttribute(""a-"" + c.getAndIncrement(), ""value"");+            user.update(rep);+        });++        UserRepresentation rep = user.toRepresentation();++        // Number of attributes should be equal to created attributes, or less (concurrent requests may drop attributes added by other threads)+        assertTrue(rep.getAttributes().size() <= c.get());","Not a nitpick.Error reporting with `assertThat` shows the list items which is useful for bug investigation, especially in case of hard-to-reproduce concurrent tests.Current variant only fails without any further details",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7049,423521109,2020-05-12T07:32:01Z,util/embedded-ldap/src/main/java/org/keycloak/util/ldap/LDAPEmbeddedServer.java,"@@ -226,19 +251,52 @@ protected LdapServer createLdapServer() {         // Read the transports         Transport ldap = new TcpTransport(this.bindHost, this.bindPort, 3, 50);         ldapServer.addTransports( ldap );-        if (enableSSL) {-            Transport ldaps = new TcpTransport(this.bindHost, this.bindLdapsPort, 3, 50);-            ldaps.setEnableSSL(true);+        if (enableSSL || enableStartTLS) {             ldapServer.setKeystoreFile(keystoreFile);             ldapServer.setCertificatePassword(certPassword);-            ldapServer.addTransports( ldaps );+            if (enableSSL) {+                Transport ldaps = new TcpTransport(this.bindHost, this.bindLdapsPort, 3, 50);+                ldaps.setEnableSSL(true);+                ldapServer.addTransports( ldaps );+                if (ldaps.isSSLEnabled()) {+                    log.info(""Enabled SSL support on the LDAP server."");+                }+            }+            if (enableStartTLS) {+                try {+                    ldapServer.addExtendedOperationHandler(new StartTlsHandler());+                } catch (Exception e) {+                    throw new IllegalStateException(""Cannot add the StartTLS extension handler: "", e);+                }+                for (ExtendedOperationHandler eoh : ldapServer.getExtendedOperationHandlers()) {+                    if (eoh.getOid().equals(StartTlsHandler.EXTENSION_OID)) {+                        log.info(""Enabled StartTLS support on the LDAP server."");+                        break;+                    }+                }+            }         }          // Associate the DS to this LdapServer         ldapServer.setDirectoryService( directoryService ); -        // Propagate the anonymous flag to the DS-        directoryService.setAllowAnonymousAccess(false);+        if (enableAnonymousAccess && !enableAccessControl) {","If I understand correctly, the combination like `enableAnonymousAccess==true && enableAccessControl==true` is invalid. Will it makes sense to throw the exception if the attempt of such configuration is tried?I mean something like:```if (enableAnonymousAccess && enableAccessControl) {    throw new IllegalStateException(""Illegal to enableAnonymousAccess and enableAccessControl at the same time"");}",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6980,423778045,2020-05-12T14:26:35Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java,"@@ -58,10 +57,7 @@ import org.keycloak.storage.ldap.idm.query.internal.LDAPQueryConditionsBuilder; import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore; import org.keycloak.storage.ldap.kerberos.LDAPProviderKerberosConfig;-import org.keycloak.storage.ldap.mappers.LDAPOperationDecorator;-import org.keycloak.storage.ldap.mappers.LDAPStorageMapper;-import org.keycloak.storage.ldap.mappers.LDAPStorageMapperManager;-import org.keycloak.storage.ldap.mappers.PasswordUpdateCallback;+import org.keycloak.storage.ldap.mappers.*;",Please remove star imports and replace with individual classes,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6980,423778189,2020-05-12T14:26:47Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPNoCacheTest.java,"@@ -52,7 +53,12 @@ import org.keycloak.testsuite.util.LDAPTestUtils; import org.keycloak.testsuite.util.MailUtils; +import static org.hamcrest.CoreMatchers.is;+import static org.hamcrest.CoreMatchers.not;+import static org.hamcrest.Matchers.*;",Please remove star imports and replace with individual classes,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7062,424405206,2020-05-13T12:41:47Z,model/jpa/src/main/java/org/keycloak/connections/jpa/EntityManagerFactoryProvider.java,"@@ -0,0 +1,8 @@+package org.keycloak.connections.jpa;++import javax.persistence.EntityManagerFactory;++public interface EntityManagerFactoryProvider {","The changes do improve WF dist too. Test runs seem to be OK.Replicating them is not ideal, but I understand your point about first trying this change in Quarkus, isolated. I'll close this PR and have both JPA and Liquibase providers duplicated.It is kind of easy to check the impact of these changes in WF dist if you want too, just run the server using these changes.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7062,424407090,2020-05-13T12:44:48Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/JpaUpdaterProvider.java,"@@ -49,23 +49,26 @@      * Updates the Keycloak database      * @param connection DB connection      * @param defaultSchema DB connection+     * @param verifyAndRunMasterChangelog if master changelog should be verified and run       */-    void update(Connection connection, String defaultSchema);+    void update(Connection connection, String defaultSchema, boolean verifyAndRunMasterChangelog);","We tell the updater whether or not we should validate/execute the master changelog.Running validation and checking the ""unrun"" changesets during startup is one of the main parts that affect startup, as well as footprint. This is especially true if the database is already initialized. Note that this does not affect custom providers, as their changelogs are still validated/executed regardless. This is only for the master changelog.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7062,424409114,2020-05-13T12:48:02Z,model/jpa/src/main/resources/META-INF/persistence.xml,"@@ -85,8 +85,11 @@                  <exclude-unlisted-classes>true</exclude-unlisted-classes> +        <!-- These properties are overridden when Keycloak is managing the persistence unit by itself -->         <properties>             <property name=""jboss.as.jpa.managed"" value=""false""/>+            <property name=""hibernate.dialect"" value=""org.hibernate.dialect.H2Dialect""/>","This is temporary and does not really matter of WF dist. As you know, we manually create the EMF.The reason for this is that when using a `persistence.xml`, Quarkus does not allow you to define hibernate configuration via properties file. One or another. See their docs for more details.The idea is to also review that once we have a final solution for supporting multiple databases when using Quarkus.",
8414918,iankko,https://api.github.com/repos/keycloak/keycloak/pulls/7049,424508008,2020-05-13T15:00:48Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPUserLoginTest.java,"@@ -0,0 +1,304 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.testsuite.federation.ldap;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.FixMethodOrder;+import org.junit.Rule;+import org.junit.Test;+import org.junit.rules.ExternalResource;+import org.junit.runners.MethodSorters;+import org.keycloak.events.EventType;+import org.keycloak.models.LDAPConstants;+import org.keycloak.models.RealmModel;+import org.keycloak.OAuth2Constants;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.storage.ldap.idm.model.LDAPObject;+import org.keycloak.testsuite.arquillian.annotation.EnableVault;+import org.keycloak.testsuite.Assert;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.pages.AppPage;+import org.keycloak.testsuite.pages.LoginPage;+import org.keycloak.testsuite.util.LDAPRule;+import org.keycloak.testsuite.util.LDAPRule.LDAPConnectionParameters;+import org.keycloak.testsuite.util.LDAPTestUtils;++import java.util.HashMap;+import java.util.Map;+import java.util.List;++import static org.junit.Assert.assertEquals;+import static org.junit.Assert.assertTrue;++/**+ * Test user logins utilizing various LDAP authentication methods and different LDAP connection encryption mechanisms.+ *+ * @author <a href=""mailto:jlieskov@redhat.com"">Jan Lieskovsky</a>+ */+@EnableVault+@FixMethodOrder(MethodSorters.NAME_ASCENDING)+public class LDAPUserLoginTest extends AbstractLDAPTest {++    @Rule+    // Start an embedded LDAP server with configuration derived from test annotations before each test+    public LDAPRule ldapRule = new LDAPRule();","Fixed in 2nd commit (intentionally kept it separate, so the changes done are better visible) Will squash the commits later (since it's likely there will be conflicts with the Tero's one, I might need to up2date this one anyway). Thanks for the example test hint, utilizing that assumeTrue() condition!",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7067,424524730,2020-05-13T15:22:50Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/MyResourcesTest.java,"@@ -173,6 +197,23 @@ public void shouldShowMyResourcesAndShare() {         assertThat(myResourcesPage.getSharedWith(row), endsWith(""and 1 other users.""));     } +    @Test+    public void shouldAllowRequestToShare() {+        final String resourceName = ""Resource 12"";+        myResourcesPage.clickPendingRequest(resourceName);+        waitForModalFadeIn();","`waitForModalFadeIn` and `waitForModalFadeOut` is meant to be used only by Admin Console. I'm sorry it's not apparent at the first sight, the Admin Console testsuite is a mess. It's a coincidence it works here as well but I wouldn't rely on that. Consider using [`testModalDialog`](https://github.com/keycloak/keycloak/blob/0801cfb01f3e56ec4526171ff0d37ca340fc5a61/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/BaseAccountPageTest.java#L52-L61) as we discussed.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7067,424554462,2020-05-13T16:02:21Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/MyResourcesTest.java,"@@ -30,18 +30,20 @@ import java.util.HashMap; import java.util.List; import java.util.Map;+import java.util.stream.Collectors;  import static java.util.Collections.singletonList; import static org.hamcrest.core.StringEndsWith.endsWith; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertThat;+import static org.junit.Assert.assertTrue; import static org.keycloak.representations.idm.CredentialRepresentation.PASSWORD; import static org.keycloak.testsuite.auth.page.AuthRealm.TEST; import static org.keycloak.testsuite.util.WaitUtils.pause; import static org.keycloak.testsuite.util.WaitUtils.waitForModalFadeIn; import static org.keycloak.testsuite.util.WaitUtils.waitForModalFadeOut; -public class MyResourcesTest extends AbstractAccountTest {+public class MyResourcesTest extends BaseAccountPageTest {","Please add some simple notifications checks to all test scenarios, similarly to e.g. [DeviceActivityTest](https://github.com/keycloak/keycloak/blob/de8ba75399209121f4238aef567795c1c4e7c938/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/DeviceActivityTest.java#L158).",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7067,424946716,2020-05-14T08:06:50Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/MyResourcesTest.java,"@@ -173,6 +197,23 @@ public void shouldShowMyResourcesAndShare() {         assertThat(myResourcesPage.getSharedWith(row), endsWith(""and 1 other users.""));     } +    @Test+    public void shouldAllowRequestToShare() {+        final String resourceName = ""Resource 12"";+        myResourcesPage.clickPendingRequest(resourceName);+        waitForModalFadeIn();","Yes, I agree. But we should use a similar approach to test this more complex dialogs. Like try to close them, check that they are (not) displayed, etc.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7058,424977401,2020-05-14T08:55:39Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/clients/ClientSettingsTest.java,"@@ -99,6 +100,9 @@ public void crudOIDCPublic() {     @Test     @EnableFeature(value = Profile.Feature.ACCOUNT2, skipRestart = true)     public void alwaysDisplayInAccountConsole() {+        driver.navigate().refresh();+        waitForPageToLoad();",Just one small nit pick. :) You can use [`refreshPageAndWaitForLoad`](https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/UIUtils.java#L64-L66).```suggestion        refreshPageAndWaitForLoad();```,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7074,426419726,2020-05-18T07:29:00Z,testsuite/utils/src/main/java/org/keycloak/testsuite/KeycloakServer.java,"@@ -400,15 +401,11 @@ public void start() throws Throwable {              di.setDefaultServletConfig(new DefaultServletConfig(true)); -            ServletInfo restEasyDispatcher = Servlets.servlet(""Keycloak REST Interface"", HttpServlet30Dispatcher.class);--            restEasyDispatcher.addInitParam(""resteasy.servlet.mapping.prefix"", ""/"");-            restEasyDispatcher.setAsyncSupported(true);--            di.addServlet(restEasyDispatcher);+            // Note that the ResteasyServlet is configured via server.undertowDeployment(...);",@thomasdarimont Are `asyncSupported` and `resteasy.servlet.mapping.prefix` parameter maintained? Perhaps they need to be added similarly as a property of the `deployment`?,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7074,426432004,2020-05-18T07:52:06Z,testsuite/utils/src/main/java/org/keycloak/testsuite/KeycloakServer.java,"@@ -400,15 +401,11 @@ public void start() throws Throwable {              di.setDefaultServletConfig(new DefaultServletConfig(true)); -            ServletInfo restEasyDispatcher = Servlets.servlet(""Keycloak REST Interface"", HttpServlet30Dispatcher.class);--            restEasyDispatcher.addInitParam(""resteasy.servlet.mapping.prefix"", ""/"");-            restEasyDispatcher.setAsyncSupported(true);--            di.addServlet(restEasyDispatcher);+            // Note that the ResteasyServlet is configured via server.undertowDeployment(...);",IMHO yes: https://github.com/resteasy/Resteasy/blob/master/server-adapters/resteasy-undertow/src/main/java/org/jboss/resteasy/plugins/server/undertow/UndertowJaxrsServer.java#L184,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6962,426831590,2020-05-18T18:57:34Z,services/src/main/java/org/keycloak/services/resources/admin/RealmAdminResource.java,"@@ -966,6 +981,43 @@ public Response testLDAPConnection(TestLdapConnectionRepresentation config) {                 config.getStartTls());     } +    /**+     * Get LDAP supported extensions.+     * @param config LDAP configuration+     * @return+     */+    @POST+    @Path(""ldap-supported-extensions"")+    @NoCache+    @Consumes(MediaType.APPLICATION_JSON)+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)+    public Response getLDAPSupportedExtensions(TestLdapConnectionRepresentation config) {++        auth.realm().requireManageRealm();++        String bindCredential = handleSavedBindCredential(config.getComponentId(), config.getBindCredential());++        // Create Factory Methods for LDAPConfig and LDAPIdentityStore in LDAPConnectionTestManager?+        MultivaluedHashMap<String, String> map = new MultivaluedHashMap<>();","Is it possible to rename existing class LDAPConnectionTestManager to something like LDAPServerCapabilitiesManager and add the logic behind this into that class? This will allow that filling of some common connection properties (CONNECTION_URL, USE_TRUSTSTORE_SPI etc) can be probably some done in the shared code, which will be shared for existing method for testing connection and testing authentication",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6962,426834916,2020-05-18T19:03:58Z,services/src/main/java/org/keycloak/services/resources/admin/RealmAdminResource.java,"@@ -966,6 +981,43 @@ public Response testLDAPConnection(TestLdapConnectionRepresentation config) {                 config.getStartTls());     } +    /**+     * Get LDAP supported extensions.+     * @param config LDAP configuration+     * @return+     */+    @POST+    @Path(""ldap-supported-extensions"")+    @NoCache+    @Consumes(MediaType.APPLICATION_JSON)+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)+    public Response getLDAPSupportedExtensions(TestLdapConnectionRepresentation config) {++        auth.realm().requireManageRealm();++        String bindCredential = handleSavedBindCredential(config.getComponentId(), config.getBindCredential());++        // Create Factory Methods for LDAPConfig and LDAPIdentityStore in LDAPConnectionTestManager?+        MultivaluedHashMap<String, String> map = new MultivaluedHashMap<>();+        map.add(LDAPConstants.CONNECTION_URL, config.getConnectionUrl());+        map.add(LDAPConstants.USE_TRUSTSTORE_SPI, config.getUseTruststoreSpi());+        map.add(LDAPConstants.AUTH_TYPE, LDAPConstants.AUTH_TYPE_SIMPLE);+        map.add(LDAPConstants.BIND_DN, config.getBindDn());+        map.add(LDAPConstants.BIND_CREDENTIAL, bindCredential);+        IdentityStore ldapIdentityStore = new LDAPIdentityStore(session, new LDAPConfig(map));++        Set<LDAPOid> ldapOids = ldapIdentityStore.queryServerCapabilities();","It will be better if response allows to differentiate between supportedControl, supportedExtensions and supportedFeatures. The JSON can possibly look like this:```{     ""supportedExtension"": [ ""1.3.6.1.4.1.1466.20036"" ],    ""supportedFeatures"": [ ""1.3.6.1.1.14"", ""1.3.6.1.4.1.4203.1.5.1"" ],    ""supportedControl"": [ ""1.2.840.113556.1.4.1413"", ""1.2.840.113556.1.4.2239"", ""1.2.840.113556.1.4.319"" ]}````Feel free to create some internal JSON representation class for help with this - for example see TestLdapConnectionRepresentation for the inspiration",
199488,splatch,https://api.github.com/repos/keycloak/keycloak/pulls/6992,427208098,2020-05-19T10:49:50Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/OAuth2DeviceAuthorizationEndpoint.java,"@@ -0,0 +1,345 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.endpoints;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.Time;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.OAuth2DeviceUserCodeProvider;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.SystemClientUtil;+import org.keycloak.protocol.AuthorizationEndpointBase;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequestParserProcessor;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.OAuth2DeviceAuthorizationResponse;+import org.keycloak.saml.common.util.StringUtil;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.ErrorPageException;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.resources.LoginActionsService;+import org.keycloak.services.resources.RealmsResource;+import org.keycloak.services.util.CacheControlUtil;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.util.JsonSerialization;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import static org.keycloak.protocol.oidc.endpoints.AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class OAuth2DeviceAuthorizationEndpoint extends AuthorizationEndpointBase {++    private static final Logger logger = Logger.getLogger(OAuth2DeviceAuthorizationEndpoint.class);++    private enum Action {+        OAUTH2_DEVICE_AUTH, OAUTH2_DEVICE_VERIFY_USER_CODE+    }++    private ClientModel client;+    private AuthenticationSessionModel authenticationSession;+    private Action action;+    private AuthorizationEndpointRequest request;+    private Cors cors;++    public OAuth2DeviceAuthorizationEndpoint(RealmModel realm, EventBuilder event) {+        super(realm, event);+    }++    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    public Response buildPost() {+        logger.trace(""Processing @POST request"");+        cors = Cors.add(httpRequest).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);+        action = Action.OAUTH2_DEVICE_AUTH;+        event.event(EventType.OAUTH2_DEVICE_AUTH);+        return process(httpRequest.getDecodedFormParameters());+    }++    private Response process(MultivaluedMap<String, String> params) {+        checkSsl();+        checkRealm();+        checkClient(null);++        request = AuthorizationEndpointRequestParserProcessor.parseRequest(event, session, client, params);++        if (!TokenUtil.isOIDCRequest(request.getScope())) {+            ServicesLogger.LOGGER.oidcScopeMissing();+        }++        authenticationSession = createAuthenticationSession(client, request.getState());+        updateAuthenticationSession();++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();+        switch (action) {+            case OAUTH2_DEVICE_AUTH:+                return buildDeviceAuthorizationResponse();+        }++        throw new RuntimeException(""Unknown action "" + action);+    }++    public Response buildDeviceAuthorizationResponse() {+        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""Client not allowed for OAuth 2.0 Device Authorization Grant"", Response.Status.BAD_REQUEST);+        }++        int expiresIn = realm.getOAuth2DeviceCodeLifespan();+        int interval = realm.getOAuth2DevicePollingInterval();++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+                Base64Url.encode(KeycloakModelUtils.generateSecret()), request.getScope(), request.getNonce());++        OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+        String secret = userCodeProvider.generate();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm,+                deviceCode.getDeviceCode(),+                secret);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + interval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        store.put(deviceCode, userCode, lifespanSeconds);++        try {+            String deviceUrl = RealmsResource.oauth2DeviceVerificationUrl(session.getContext().getUri()).build(realm.getName()).toString();++            OAuth2DeviceAuthorizationResponse response = new OAuth2DeviceAuthorizationResponse();+            response.setDeviceCode(deviceCode.getDeviceCode());+            response.setUserCode(userCodeProvider.display(secret));+            response.setExpiresIn(expiresIn);+            response.setInterval(interval);+            response.setVerificationUri(deviceUrl);+            response.setVerificationUriComplete(deviceUrl + ""?user_code="" + response.getUserCode());++            return Response.ok(JsonSerialization.writeValueAsBytes(response)).type(MediaType.APPLICATION_JSON_TYPE).build();+        } catch (Exception e) {+            throw new RuntimeException(""Error creating OAuth 2.0 Device Authorization Response."", e);+        }+    }++    private void checkClient(String clientId) {+        // https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15#section-3.1+        // The spec says ""The client authentication requirements of Section 3.2.1 of [RFC6749]+        // apply to requests on this endpoint"".+        if (action == Action.OAUTH2_DEVICE_AUTH) {+            AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);+            client = clientAuth.getClient();+            clientId = client.getClientId();+        }++        if (clientId == null) {+            event.error(Errors.INVALID_REQUEST);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.MISSING_PARAMETER, OIDCLoginProtocol.CLIENT_ID_PARAM);+        }++        event.client(clientId);++        client = realm.getClientByClientId(clientId);+        if (client == null) {+            event.error(Errors.CLIENT_NOT_FOUND);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.CLIENT_NOT_FOUND);+        }++        if (!client.isEnabled()) {+            event.error(Errors.CLIENT_DISABLED);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.CLIENT_DISABLED);+        }++        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.OAUTH2_DEVICE_AUTHORIZATION_GRANT_DISABLED);+        }++        if (client.isBearerOnly()) {+            event.error(Errors.NOT_ALLOWED);+            throw new ErrorPageException(session, authenticationSession, Response.Status.FORBIDDEN, Messages.BEARER_ONLY);+        }++        String protocol = client.getProtocol();+        if (protocol == null) {+            logger.warnf(""Client '%s' doesn't have protocol set. Fallback to openid-connect. Please fix client configuration"", clientId);+            protocol = OIDCLoginProtocol.LOGIN_PROTOCOL;+        }+        if (!protocol.equals(OIDCLoginProtocol.LOGIN_PROTOCOL)) {+            event.error(Errors.INVALID_CLIENT);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, ""Wrong client protocol."");+        }++        session.getContext().setClient(client);+    }++    private void updateAuthenticationSession() {+        authenticationSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);+        authenticationSession.setAction(AuthenticationSessionModel.Action.AUTHENTICATE.name());+        authenticationSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));++        if (request.getNonce() != null) authenticationSession.setClientNote(OIDCLoginProtocol.NONCE_PARAM, request.getNonce());+        if (request.getMaxAge() != null) authenticationSession.setClientNote(OIDCLoginProtocol.MAX_AGE_PARAM, String.valueOf(request.getMaxAge()));+        if (request.getScope() != null) authenticationSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, request.getScope());+        if (request.getLoginHint() != null) authenticationSession.setClientNote(OIDCLoginProtocol.LOGIN_HINT_PARAM, request.getLoginHint());+        if (request.getPrompt() != null) authenticationSession.setClientNote(OIDCLoginProtocol.PROMPT_PARAM, request.getPrompt());+        if (request.getIdpHint() != null) authenticationSession.setClientNote(AdapterConstants.KC_IDP_HINT, request.getIdpHint());+        if (request.getClaims()!= null) authenticationSession.setClientNote(OIDCLoginProtocol.CLAIMS_PARAM, request.getClaims());+        if (request.getAcr() != null) authenticationSession.setClientNote(OIDCLoginProtocol.ACR_PARAM, request.getAcr());+        if (request.getDisplay() != null) authenticationSession.setAuthNote(OAuth2Constants.DISPLAY, request.getDisplay());++        if (request.getAdditionalReqParams() != null) {+            for (String paramName : request.getAdditionalReqParams().keySet()) {+                authenticationSession.setClientNote(LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX + paramName, request.getAdditionalReqParams().get(paramName));","These client notes are useful, however as far I was able to test, it is not possible to make any use of them. The initial session created by device is valid only during the generation of the code. When user opens verification URI he creates completely new session. The URI he launches has no additional request parameters. In current implementation there is no way to correlate session created by device with one which is continued by user who confirms the code.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7081,427372111,2020-05-19T14:59:47Z,quarkus/runtime/src/main/java/org/keycloak/QuarkusKeycloakApplication.java,"@@ -1,10 +1,402 @@ package org.keycloak; +import javax.transaction.SystemException;+import javax.transaction.Transaction; import javax.ws.rs.ApplicationPath; +import java.io.File;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.IOException;+import java.io.InputStream;+import java.util.HashSet;+import java.util.List;+import java.util.NoSuchElementException;+import java.util.ServiceLoader;+import java.util.Set;+import java.util.StringTokenizer;+import java.util.concurrent.atomic.AtomicBoolean;++import com.fasterxml.jackson.core.type.TypeReference;+import org.jboss.logging.Logger;+import org.keycloak.common.util.Resteasy;+import org.keycloak.config.ConfigProviderFactory;+import org.keycloak.exportimport.ExportImportManager;+import org.keycloak.migration.MigrationModelManager;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.KeycloakSessionTask;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserProvider;+import org.keycloak.models.dblock.DBLockManager;+import org.keycloak.models.dblock.DBLockProvider;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.PostMigrationEvent;+import org.keycloak.models.utils.RepresentationToModel;+import org.keycloak.platform.Platform;+import org.keycloak.platform.PlatformProvider;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.services.DefaultKeycloakSessionFactory;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.error.KeycloakErrorHandler;+import org.keycloak.services.filters.KeycloakSecurityHeadersFilter;+import org.keycloak.services.filters.KeycloakTransactionCommitter;+import org.keycloak.services.managers.ApplianceBootstrap;+import org.keycloak.services.managers.RealmManager;+import org.keycloak.services.managers.UserStorageSyncManager;+import org.keycloak.services.resources.JsResource; import org.keycloak.services.resources.KeycloakApplication;+import org.keycloak.services.resources.RealmsResource;+import org.keycloak.services.resources.RobotsResource;+import org.keycloak.services.resources.ThemeResource;+import org.keycloak.services.resources.WelcomeResource;+import org.keycloak.services.resources.admin.AdminRoot;+import org.keycloak.services.scheduled.ClearExpiredClientInitialAccessTokens;+import org.keycloak.services.scheduled.ClearExpiredEvents;+import org.keycloak.services.scheduled.ClearExpiredUserSessions;+import org.keycloak.services.scheduled.ClusterAwareScheduledTaskRunner;+import org.keycloak.services.scheduled.ScheduledTaskRunner;+import org.keycloak.services.util.ObjectMapperResolver;+import org.keycloak.timer.TimerProvider;+import org.keycloak.transaction.JtaTransactionManagerLookup;+import org.keycloak.util.JsonSerialization;  @ApplicationPath(""/"") public class QuarkusKeycloakApplication extends KeycloakApplication { +    private static final Logger logger = Logger.getLogger(KeycloakApplication.class);++    protected final PlatformProvider platform = Platform.getPlatform();++    protected Set<Object> singletons = new HashSet<Object>();+    protected Set<Class<?>> classes = new HashSet<Class<?>>();++    protected KeycloakSessionFactory sessionFactory;++    public QuarkusKeycloakApplication() {++        try {","`Short term, we are planning quite a few other changes that might impact your code.`I'm aware of that :) Sometimes, it's hard to keep up with your speed in my spare-time :DI'm asking, because the initialization within this constructor requires a bunch of infrastructure to be in place already: The required components need to be either statically configured or populated in a JNDI environment.It would be much nicer if the dependencies needed by the KeycloakApplication instance could be passed in as constructor arguments directly, or indirectly via some kind of Context object that's passed in. This would allow for more control about when which required component is created. Another benefit would be to ease subclassing the `KeycloakApplication` with more control about the component bootstrap there. IIRC it is possible to configure the `org.jboss.resteasy.plugins.server.servlet.HttpServlet30Dispatcher` with a predefined `javax.ws.rs.Application` instance instead of just providing it with a FQCN. This could also ease testing of KeycloakApplication components due to easier mocking.For instance, the `HttpServlet30Dispatcher` could be configured and deployed programmatically via a `ServletContextListener` which would then bootstrap the whole environment.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6992,427510783,2020-05-19T18:25:25Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/OAuth2DeviceAuthorizationEndpoint.java,"@@ -0,0 +1,345 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.endpoints;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.Time;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.OAuth2DeviceUserCodeProvider;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.SystemClientUtil;+import org.keycloak.protocol.AuthorizationEndpointBase;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequestParserProcessor;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.OAuth2DeviceAuthorizationResponse;+import org.keycloak.saml.common.util.StringUtil;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.ErrorPageException;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.resources.LoginActionsService;+import org.keycloak.services.resources.RealmsResource;+import org.keycloak.services.util.CacheControlUtil;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.util.JsonSerialization;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import static org.keycloak.protocol.oidc.endpoints.AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class OAuth2DeviceAuthorizationEndpoint extends AuthorizationEndpointBase {++    private static final Logger logger = Logger.getLogger(OAuth2DeviceAuthorizationEndpoint.class);++    private enum Action {+        OAUTH2_DEVICE_AUTH, OAUTH2_DEVICE_VERIFY_USER_CODE+    }++    private ClientModel client;+    private AuthenticationSessionModel authenticationSession;+    private Action action;+    private AuthorizationEndpointRequest request;+    private Cors cors;++    public OAuth2DeviceAuthorizationEndpoint(RealmModel realm, EventBuilder event) {+        super(realm, event);+    }++    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    public Response buildPost() {+        logger.trace(""Processing @POST request"");+        cors = Cors.add(httpRequest).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);+        action = Action.OAUTH2_DEVICE_AUTH;+        event.event(EventType.OAUTH2_DEVICE_AUTH);+        return process(httpRequest.getDecodedFormParameters());+    }++    private Response process(MultivaluedMap<String, String> params) {+        checkSsl();+        checkRealm();+        checkClient(null);++        request = AuthorizationEndpointRequestParserProcessor.parseRequest(event, session, client, params);++        if (!TokenUtil.isOIDCRequest(request.getScope())) {+            ServicesLogger.LOGGER.oidcScopeMissing();+        }++        authenticationSession = createAuthenticationSession(client, request.getState());+        updateAuthenticationSession();++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();+        switch (action) {+            case OAUTH2_DEVICE_AUTH:+                return buildDeviceAuthorizationResponse();+        }++        throw new RuntimeException(""Unknown action "" + action);+    }++    public Response buildDeviceAuthorizationResponse() {+        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""Client not allowed for OAuth 2.0 Device Authorization Grant"", Response.Status.BAD_REQUEST);+        }++        int expiresIn = realm.getOAuth2DeviceCodeLifespan();+        int interval = realm.getOAuth2DevicePollingInterval();++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+                Base64Url.encode(KeycloakModelUtils.generateSecret()), request.getScope(), request.getNonce());++        OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+        String secret = userCodeProvider.generate();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm,+                deviceCode.getDeviceCode(),+                secret);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + interval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        store.put(deviceCode, userCode, lifespanSeconds);++        try {+            String deviceUrl = RealmsResource.oauth2DeviceVerificationUrl(session.getContext().getUri()).build(realm.getName()).toString();++            OAuth2DeviceAuthorizationResponse response = new OAuth2DeviceAuthorizationResponse();+            response.setDeviceCode(deviceCode.getDeviceCode());+            response.setUserCode(userCodeProvider.display(secret));+            response.setExpiresIn(expiresIn);+            response.setInterval(interval);+            response.setVerificationUri(deviceUrl);+            response.setVerificationUriComplete(deviceUrl + ""?user_code="" + response.getUserCode());++            return Response.ok(JsonSerialization.writeValueAsBytes(response)).type(MediaType.APPLICATION_JSON_TYPE).build();+        } catch (Exception e) {+            throw new RuntimeException(""Error creating OAuth 2.0 Device Authorization Response."", e);+        }+    }++    private void checkClient(String clientId) {+        // https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15#section-3.1+        // The spec says ""The client authentication requirements of Section 3.2.1 of [RFC6749]+        // apply to requests on this endpoint"".+        if (action == Action.OAUTH2_DEVICE_AUTH) {+            AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);+            client = clientAuth.getClient();+            clientId = client.getClientId();+        }++        if (clientId == null) {+            event.error(Errors.INVALID_REQUEST);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.MISSING_PARAMETER, OIDCLoginProtocol.CLIENT_ID_PARAM);+        }++        event.client(clientId);++        client = realm.getClientByClientId(clientId);+        if (client == null) {+            event.error(Errors.CLIENT_NOT_FOUND);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.CLIENT_NOT_FOUND);+        }++        if (!client.isEnabled()) {+            event.error(Errors.CLIENT_DISABLED);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.CLIENT_DISABLED);+        }++        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.OAUTH2_DEVICE_AUTHORIZATION_GRANT_DISABLED);+        }++        if (client.isBearerOnly()) {+            event.error(Errors.NOT_ALLOWED);+            throw new ErrorPageException(session, authenticationSession, Response.Status.FORBIDDEN, Messages.BEARER_ONLY);+        }++        String protocol = client.getProtocol();+        if (protocol == null) {+            logger.warnf(""Client '%s' doesn't have protocol set. Fallback to openid-connect. Please fix client configuration"", clientId);+            protocol = OIDCLoginProtocol.LOGIN_PROTOCOL;+        }+        if (!protocol.equals(OIDCLoginProtocol.LOGIN_PROTOCOL)) {+            event.error(Errors.INVALID_CLIENT);+            throw new ErrorPageException(session, authenticationSession, Response.Status.BAD_REQUEST, ""Wrong client protocol."");+        }++        session.getContext().setClient(client);+    }++    private void updateAuthenticationSession() {+        authenticationSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);+        authenticationSession.setAction(AuthenticationSessionModel.Action.AUTHENTICATE.name());+        authenticationSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));++        if (request.getNonce() != null) authenticationSession.setClientNote(OIDCLoginProtocol.NONCE_PARAM, request.getNonce());+        if (request.getMaxAge() != null) authenticationSession.setClientNote(OIDCLoginProtocol.MAX_AGE_PARAM, String.valueOf(request.getMaxAge()));+        if (request.getScope() != null) authenticationSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, request.getScope());+        if (request.getLoginHint() != null) authenticationSession.setClientNote(OIDCLoginProtocol.LOGIN_HINT_PARAM, request.getLoginHint());+        if (request.getPrompt() != null) authenticationSession.setClientNote(OIDCLoginProtocol.PROMPT_PARAM, request.getPrompt());+        if (request.getIdpHint() != null) authenticationSession.setClientNote(AdapterConstants.KC_IDP_HINT, request.getIdpHint());+        if (request.getClaims()!= null) authenticationSession.setClientNote(OIDCLoginProtocol.CLAIMS_PARAM, request.getClaims());+        if (request.getAcr() != null) authenticationSession.setClientNote(OIDCLoginProtocol.ACR_PARAM, request.getAcr());+        if (request.getDisplay() != null) authenticationSession.setAuthNote(OAuth2Constants.DISPLAY, request.getDisplay());++        if (request.getAdditionalReqParams() != null) {+            for (String paramName : request.getAdditionalReqParams().keySet()) {+                authenticationSession.setClientNote(LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX + paramName, request.getAdditionalReqParams().get(paramName));","Spec-wise is it expected the client to send additional parameters?If that is the case, I think we could just have those available through the root session.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7081,427525256,2020-05-19T18:49:36Z,quarkus/runtime/src/main/java/org/keycloak/QuarkusKeycloakApplication.java,"@@ -1,10 +1,402 @@ package org.keycloak; +import javax.transaction.SystemException;+import javax.transaction.Transaction; import javax.ws.rs.ApplicationPath; +import java.io.File;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.IOException;+import java.io.InputStream;+import java.util.HashSet;+import java.util.List;+import java.util.NoSuchElementException;+import java.util.ServiceLoader;+import java.util.Set;+import java.util.StringTokenizer;+import java.util.concurrent.atomic.AtomicBoolean;++import com.fasterxml.jackson.core.type.TypeReference;+import org.jboss.logging.Logger;+import org.keycloak.common.util.Resteasy;+import org.keycloak.config.ConfigProviderFactory;+import org.keycloak.exportimport.ExportImportManager;+import org.keycloak.migration.MigrationModelManager;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.KeycloakSessionTask;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserProvider;+import org.keycloak.models.dblock.DBLockManager;+import org.keycloak.models.dblock.DBLockProvider;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.PostMigrationEvent;+import org.keycloak.models.utils.RepresentationToModel;+import org.keycloak.platform.Platform;+import org.keycloak.platform.PlatformProvider;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.services.DefaultKeycloakSessionFactory;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.error.KeycloakErrorHandler;+import org.keycloak.services.filters.KeycloakSecurityHeadersFilter;+import org.keycloak.services.filters.KeycloakTransactionCommitter;+import org.keycloak.services.managers.ApplianceBootstrap;+import org.keycloak.services.managers.RealmManager;+import org.keycloak.services.managers.UserStorageSyncManager;+import org.keycloak.services.resources.JsResource; import org.keycloak.services.resources.KeycloakApplication;+import org.keycloak.services.resources.RealmsResource;+import org.keycloak.services.resources.RobotsResource;+import org.keycloak.services.resources.ThemeResource;+import org.keycloak.services.resources.WelcomeResource;+import org.keycloak.services.resources.admin.AdminRoot;+import org.keycloak.services.scheduled.ClearExpiredClientInitialAccessTokens;+import org.keycloak.services.scheduled.ClearExpiredEvents;+import org.keycloak.services.scheduled.ClearExpiredUserSessions;+import org.keycloak.services.scheduled.ClusterAwareScheduledTaskRunner;+import org.keycloak.services.scheduled.ScheduledTaskRunner;+import org.keycloak.services.util.ObjectMapperResolver;+import org.keycloak.timer.TimerProvider;+import org.keycloak.transaction.JtaTransactionManagerLookup;+import org.keycloak.util.JsonSerialization;  @ApplicationPath(""/"") public class QuarkusKeycloakApplication extends KeycloakApplication { +    private static final Logger logger = Logger.getLogger(KeycloakApplication.class);++    protected final PlatformProvider platform = Platform.getPlatform();++    protected Set<Object> singletons = new HashSet<Object>();+    protected Set<Class<?>> classes = new HashSet<Class<?>>();++    protected KeycloakSessionFactory sessionFactory;++    public QuarkusKeycloakApplication() {++        try {","The thing is that we are dropping Servlet API for Quarkus. We are now using Vert.x.We are also looking forward to making `KeycloakApplication` really specific to bootstrapping JAX-RS whereas the session factory is basically a singleton that can be initialized from itself.I guess you are doing this for your Keycloak On SB project, right? If we just make the session factory doing all the heavy work you can easily bootstrap the server, from everywhere.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7081,427768532,2020-05-20T06:26:39Z,quarkus/runtime/src/main/java/org/keycloak/QuarkusKeycloakApplication.java,"@@ -1,10 +1,402 @@ package org.keycloak; +import javax.transaction.SystemException;+import javax.transaction.Transaction; import javax.ws.rs.ApplicationPath; +import java.io.File;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.IOException;+import java.io.InputStream;+import java.util.HashSet;+import java.util.List;+import java.util.NoSuchElementException;+import java.util.ServiceLoader;+import java.util.Set;+import java.util.StringTokenizer;+import java.util.concurrent.atomic.AtomicBoolean;++import com.fasterxml.jackson.core.type.TypeReference;+import org.jboss.logging.Logger;+import org.keycloak.common.util.Resteasy;+import org.keycloak.config.ConfigProviderFactory;+import org.keycloak.exportimport.ExportImportManager;+import org.keycloak.migration.MigrationModelManager;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.KeycloakSessionTask;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserProvider;+import org.keycloak.models.dblock.DBLockManager;+import org.keycloak.models.dblock.DBLockProvider;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.PostMigrationEvent;+import org.keycloak.models.utils.RepresentationToModel;+import org.keycloak.platform.Platform;+import org.keycloak.platform.PlatformProvider;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.services.DefaultKeycloakSessionFactory;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.error.KeycloakErrorHandler;+import org.keycloak.services.filters.KeycloakSecurityHeadersFilter;+import org.keycloak.services.filters.KeycloakTransactionCommitter;+import org.keycloak.services.managers.ApplianceBootstrap;+import org.keycloak.services.managers.RealmManager;+import org.keycloak.services.managers.UserStorageSyncManager;+import org.keycloak.services.resources.JsResource; import org.keycloak.services.resources.KeycloakApplication;+import org.keycloak.services.resources.RealmsResource;+import org.keycloak.services.resources.RobotsResource;+import org.keycloak.services.resources.ThemeResource;+import org.keycloak.services.resources.WelcomeResource;+import org.keycloak.services.resources.admin.AdminRoot;+import org.keycloak.services.scheduled.ClearExpiredClientInitialAccessTokens;+import org.keycloak.services.scheduled.ClearExpiredEvents;+import org.keycloak.services.scheduled.ClearExpiredUserSessions;+import org.keycloak.services.scheduled.ClusterAwareScheduledTaskRunner;+import org.keycloak.services.scheduled.ScheduledTaskRunner;+import org.keycloak.services.util.ObjectMapperResolver;+import org.keycloak.timer.TimerProvider;+import org.keycloak.transaction.JtaTransactionManagerLookup;+import org.keycloak.util.JsonSerialization;  @ApplicationPath(""/"") public class QuarkusKeycloakApplication extends KeycloakApplication { +    private static final Logger logger = Logger.getLogger(KeycloakApplication.class);++    protected final PlatformProvider platform = Platform.getPlatform();++    protected Set<Object> singletons = new HashSet<Object>();+    protected Set<Class<?>> classes = new HashSet<Class<?>>();++    protected KeycloakSessionFactory sessionFactory;++    public QuarkusKeycloakApplication() {++        try {",In this PR we're just making a copy of the KeycloakApplication in order to make more drastic changes here without affecting the main distribution.Let's discuss this on the mailing list instead of this PR.,
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/7067,429742407,2020-05-25T05:53:15Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/MyResourcesTest.java,"@@ -131,48 +121,133 @@ public void setup() throws Exception {         }     } +    private ResourceRepresentation createResource(AuthzClient authzClient, AuthorizationResource authorization, int i) {+        ResourceRepresentation resource = new ResourceRepresentation();++        resource.setOwnerManagedAccess(true);++        try {+            final byte[] content = new JWSInput(authzClient.obtainAccessToken(""jdoe"", PASSWORD).getToken()).getContent();+            final AccessToken accessToken = JsonSerialization.readValue(content, AccessToken.class);+            resource.setOwner(accessToken.getSubject());+        }+        catch (Exception e) {+            throw new RuntimeException(e);+        }++        resource.setName(""Resource "" + i);+        resource.setDisplayName(""Display Name "" + i);+        resource.setIconUri(""Icon Uri "" + i);+        resource.addScope(""Scope A"", ""Scope B"", ""Scope C"", ""Scope D"");+        resource.setUri(""http://resourceServer.com/resources/"" + i);++        try (Response response1 = authorization.resources().create(resource)) {+            resource.setId(response1.readEntity(ResourceRepresentation.class).getId());+        }+        return resource;+    }++    @Override+    public void addTestUser() {+        testUser = createUser(""jdoe"");+    }++    @Test+    public void shouldDisplayTheResources() {+        assertEquals(6, myResourcesPage.getResourcesListCount());++        assertEquals(""Resource 0"", myResourcesPage.getCellText(""name"", 0));+        assertEquals(""Resource 1"", myResourcesPage.getCellText(""name"", 1));+        assertEquals(""My Resource Server"", myResourcesPage.getCellText(""client"", 0));",there should always be a link: https://github.com/keycloak/keycloak/blob/0b75961986ccb625fb55a9777fac29dc0315d729/themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/my-resources-page/ResourcesTable.tsx#L130,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7099,430448809,2020-05-26T14:19:14Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oidc/flows/AbstractOIDCResponseTypeTest.java,"@@ -253,6 +253,8 @@ private void oidcFlow(String expectedAccessAlg, String expectedIdTokenAlg) throw         for (IDToken idt : idTokens) {             Assert.assertEquals(""abcdef123456"", idt.getNonce());             Assert.assertEquals(authzResponse.getSessionState(), idt.getSessionState());+            // see KEYCLOAK-9635+            Assert.assertNotNull(""claim at_hash should be present in IDToken for OIDC auth code flow requests"", idt.getAccessTokenHash());","@thomasdarimont It is done for example in testAuthzResponseAndRetrieveIDTokens() of various tests, which already generate ""at_has"" . For example in OIDCImplicitResponseTypeIDTokenTokenTest.testAuthzResponseAndRetrieveIDTokens() .I suggest to explicitly add the verifications to the individual methods to explicitly check OIDCXYTest.testAuthzResponseAndRetrieveIDTokens() to explicitly check if ""at_hash"" is generated always when it makes sense instead of using it here in the subclass where the check is not very explicit. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6970,430471495,2020-05-26T14:49:03Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/membership/group/GroupLDAPStorageMapperFactory.java,"@@ -282,6 +292,12 @@ public void validateConfiguration(KeycloakSession session, RealmModel realm, Com         }          LDAPUtils.validateCustomLdapFilter(config.getConfig().getFirst(GroupMapperConfig.GROUPS_LDAP_FILTER));++        checkMandatoryConfigAttribute(GroupMapperConfig.LDAP_GROUPS_PATH, ""Groups Path"", config);+        String group = config.getConfig().getFirst(GroupMapperConfig.LDAP_GROUPS_PATH).trim();+        if (!""/"".equals(group) && KeycloakModelUtils.findGroupByPath(realm, group) == null) {+            throw new ComponentValidationException(""Groups path group '"" + group + ""' does not exist - please create it first"");","Is it possible to use generic message without adding ""group"" variable into the text? Maybe just something like ""Groups path group does not exist  - please create the group on specified path first"" .The reason is some potential for various injection attacks, which would be possible if the user input (variable ""group"") is shown in the notification in the UI.Bonus point: If you manage to localize the error message, it will be nice as well. The message with specified key will just need to be added to this file and that should be enough: https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/base/admin/messages/messages_en.properties",
2626998,tjuerge,https://api.github.com/repos/keycloak/keycloak/pulls/6970,430478064,2020-05-26T14:57:40Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/membership/group/GroupLDAPStorageMapperFactory.java,"@@ -282,6 +292,12 @@ public void validateConfiguration(KeycloakSession session, RealmModel realm, Com         }          LDAPUtils.validateCustomLdapFilter(config.getConfig().getFirst(GroupMapperConfig.GROUPS_LDAP_FILTER));++        checkMandatoryConfigAttribute(GroupMapperConfig.LDAP_GROUPS_PATH, ""Groups Path"", config);+        String group = config.getConfig().getFirst(GroupMapperConfig.LDAP_GROUPS_PATH).trim();+        if (!""/"".equals(group) && KeycloakModelUtils.findGroupByPath(realm, group) == null) {+            throw new ComponentValidationException(""Groups path group '"" + group + ""' does not exist - please create it first"");",Sure. And now I know why the other exception messages are so generic.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,430885604,2020-05-27T06:31:14Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {","One issue I see here is that it will be relatively expensive to loop through the component model and initialise all policies for all requests. A better option may be to follow something more along the lines of what is done with keys. See https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/keys/DefaultKeyManager.java. It caches the keys with the realm, which means it doesn't have to parse the config and load keys for every request.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,430896439,2020-05-27T06:58:09Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyCondition.java,"@@ -0,0 +1,181 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this condition to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyCondition extends Provider {++    @Override+    default void close() {}++    /**+     * returns true if this condition is evaluated to check+     * whether the client satisfies this condition on the event specified as a parameter.+     * A condition can be implemented to be evaluated on some events while not on others.+     * On the event specified as the parameter, this condition is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this condition is evaluated on the event.+     */+    default boolean isEvaluatedOnEvent(String event) {return true;}++    /**+     * returns true if the client satisfies this condition+     * on Dynamic Registration Endpoint access for creating client.+     *+     * @param context+     * @param authType+     * @return true if the client satisfies this condition.+     */+    default boolean isSatisfiedOnDynamicClientRegister(","Very often a condition is going to have the same code for create/update as well as if it's admin or dynamic. So I would rather see something like:default boolean isSatisfiedOnClientUpdate(ClientUpdateContext context)Where ClientUpdateContext contains information about who is updating it, and if it's a create or update.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7109,431579186,2020-05-28T04:48:05Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/AuthenticationManagementResource.java,"@@ -106,7 +111,7 @@     @Path(""/flows/{flowAlias}/executions"")     @PUT     @Consumes(MediaType.APPLICATION_JSON)-    void updateExecutions(@PathParam(""flowAlias"") String flowAlias, AuthenticationExecutionInfoRepresentation rep);+    Response updateExecutions(@PathParam(""flowAlias"") String flowAlias, AuthenticationExecutionInfoRepresentation rep);","Please don't change return type to ""Response"" .In case that it was ""void"" as in current master and some exception happen on server, then the client will receive the exception as well. Which is usually good thing that client is notified about some failure through the exception. However when you change the return type on the admin-client to ""Response"", then the client call won't receive the exception at all. Instead of receiving exception, client  needs to explicitly check the status of the response etc. This means that client needs to explicitly close the ""Response"" (which is often forgotten) and I think this can be also the reason of broken tests.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7109,431582339,2020-05-28T05:01:28Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/authentication/FlowTest.java,"@@ -275,4 +275,150 @@ public void addExecutionFlow() {         assertAdminEvents.assertEvent(REALM_NAME, OperationType.CREATE, AdminEventPaths.authAddExecutionFlowPath(""parent""), params, ResourceType.AUTH_EXECUTION_FLOW);     } +    @Test+    //KEYCLOAK-12741+    public void editFlowTest() {+        List<AuthenticationFlowRepresentation> flows;++        //copy one first+        HashMap<String, String> params = new HashMap<>();+        params.put(""newName"", ""Copy of browser"");+        Response response = authMgmtResource.copy(""browser"", params);+        assertAdminEvents.assertEvent(REALM_NAME, OperationType.CREATE, AdminEventPaths.authCopyFlowPath(""browser""), params, ResourceType.AUTH_FLOW);+        try {+            Assert.assertEquals(""Copy flow"", 201, response.getStatus());+        } finally {+            response.close();+        }++        //Set a new unique name. Should succeed+        flows = authMgmtResource.getFlows();+        AuthenticationFlowRepresentation testFlow = findFlowByAlias(""Copy of browser"", flows);+        testFlow.setAlias(""Copy of browser2"");+        response = authMgmtResource.updateFlow(testFlow.getId(), testFlow);+        flows = authMgmtResource.getFlows();+        try {+            Assert.assertEquals(""Copy of browser2"", findFlowByAlias(""Copy of browser2"", flows).getAlias());+            assertAdminEvents.assertEvent(REALM_NAME, OperationType.UPDATE, AdminEventPaths.authEditFlowPath(testFlow.getId()), ResourceType.AUTH_FLOW);+        } finally {+            response.close();+        }++        //Create new flow and edit the old one to have the new ones name+        AuthenticationFlowRepresentation newFlow = newFlow(""New Flow"", ""Test description"", ""basic-flow"", true, false);+        createFlow(newFlow);+        // check that new flow is returned in a children list+        flows = authMgmtResource.getFlows();+        AuthenticationFlowRepresentation found = findFlowByAlias(""New Flow"", flows);+        try {+            Assert.assertNotNull(""created flow visible in parent"", found);+            compareFlows(newFlow, found);++            testFlow.setAlias(""New Flow"");+            response = authMgmtResource.updateFlow(testFlow.getId(), testFlow);+            Assert.assertEquals(""updateFlow using the alias of existing flow should fail"", 409, response.getStatus());+            flows = authMgmtResource.getFlows();++            //name should be the same for the old Flow+            Assert.assertEquals(""Copy of browser2"", findFlowByAlias(""Copy of browser2"", flows).getAlias());+        } finally {+            response.close();+        }++        //Only update the description+        found.setDescription(""New description"");+        response = authMgmtResource.updateFlow(found.getId(), found);+        flows = authMgmtResource.getFlows();+        try {+            Assert.assertEquals(""New description"", findFlowByAlias(""New Flow"", flows).getDescription());+            assertAdminEvents.assertEvent(REALM_NAME, OperationType.UPDATE, AdminEventPaths.authEditFlowPath(found.getId()), ResourceType.AUTH_FLOW);+        } finally {+            response.close();+        }++        //Update name and description+        found.setAlias(""New Flow2"");+        found.setDescription(""New description2"");+        response = authMgmtResource.updateFlow(found.getId(), found);+        flows = authMgmtResource.getFlows();+        try {+            Assert.assertEquals(""New Flow2"", findFlowByAlias(""New Flow2"", flows).getAlias());+            Assert.assertEquals(""New description2"", findFlowByAlias(""New Flow2"", flows).getDescription());+            assertAdminEvents.assertEvent(REALM_NAME, OperationType.UPDATE, AdminEventPaths.authEditFlowPath(found.getId()), ResourceType.AUTH_FLOW);+            Assert.assertNull(findFlowByAlias(""New Flow"", flows));+        } finally {+            response.close();+        }+        authMgmtResource.deleteFlow(testFlow.getId());+    }++    @Test+    public void editExecutionFlowTest() {+        HashMap<String, String> params = new HashMap<>();+        List<AuthenticationExecutionInfoRepresentation> executionReps;+        //create new parent flow+        AuthenticationFlowRepresentation newFlow = newFlow(""Parent-Flow"", ""This is a parent flow"", ""basic-flow"", true, false);+        createFlow(newFlow);++        //create a child sub flow+        params.put(""alias"", ""Child-Flow"");+        params.put(""description"", ""This is a child flow"");+        params.put(""provider"", ""registration-page-form"");+        params.put(""type"", ""basic-flow"");++        authMgmtResource.addExecutionFlow(""Parent-Flow"", params);+        assertAdminEvents.assertEvent(REALM_NAME, OperationType.CREATE, AdminEventPaths.authAddExecutionFlowPath(""Parent-Flow""), params, ResourceType.AUTH_EXECUTION_FLOW);++        //create another+        executionReps = authMgmtResource.getExecutions(""Parent-Flow"");++        params = new HashMap<>();+        params.put(""alias"", ""Child-Flow"");+        params.put(""description"", ""This is another child flow"");+        params.put(""provider"", ""registration-page-form"");+        params.put(""type"", ""basic-flow"");++        try {+            authMgmtResource.addExecutionFlow(""Parent-Flow"", params);+            Assert.fail(""addExecutionFlow the alias already exist"");+        } catch (Exception expected) {+            // Expected+        }++        AuthenticationExecutionInfoRepresentation found = executionReps.get(0);+        found.setDisplayName(""Parent-Flow"");++        Response response = authMgmtResource.updateExecutions(""Parent-Flow"", found);+        try {+            Assert.assertEquals(""updateFlow using the alias of existing flow should fail"", 409, response.getStatus());",This will need to catch exception instead of checking the response status. Which is in general better approach.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431608010,2020-05-28T06:27:45Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProvider.java,"@@ -0,0 +1,42 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;++import org.keycloak.provider.Provider;++/**+ * Provides Client Policy which accommodates several Conditions and Executors.+ */+public interface ClientPolicyProvider extends Provider {++    /**+     * returns the list of condition's id which this provider accommodates.+     *+     * @return list of condition's id+     */+    List<String> getConditionIds();","I wonder if it would be better if a ClientPolicyProvider returns lists of ClientPolicyCondition/ClientPolicyExecutor instead of ids. That would allow creating ClientPolicyProviders that don't use ComponentModel, but just hard-codes some conditions/executors instead.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431611166,2020-05-28T06:35:48Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);",Doesn't this mean that if a ClientPolicyCondition throws an exception it is ignored and only a trace level logging is shown? An exception in a ClientPolicyCondition/Executor should result in an error handling the request I'd say.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431613145,2020-05-28T06:41:01Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");",If no conditions are evaluated it should return true right? Otherwise no matches would return in not accepting the request.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431613739,2020-05-28T06:42:30Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");+            return false;+        }++        if (conditions.stream().anyMatch(t -> {+                    try {return !op.run(t);} catch (ClientPolicyException e) {+                        ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);","Doesn't this mean an exception always results in false? That's okay, but there's no feedback to the user other than the request failed.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431615155,2020-05-28T06:45:49Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");+            return false;+        }++        if (conditions.stream().anyMatch(t -> {+                    try {return !op.run(t);} catch (ClientPolicyException e) {+                        ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                        return false;+                    }+            })) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. Not all conditones satisfied."");+            return false;+        }++        ClientPolicyLogger.log(logger, ""POSITIVE :: This policy is applied."");+        return true;+ +    }++    private static void execute(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientExecutorFilter filter,+            ClientExecutorOperation op) throws ClientPolicyException {++        List<String> executorIds = policy.getExecutorIds();++        if (executorIds == null || executorIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This executor is not executed. No executor registered."");+            return;+        }++        List<ClientPolicyExecutor> executors = executorIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Executor ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Executor Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Executor Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyExecutor.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This executor is not executed. "" + e);","This swallows exceptions, with only information in trace level logging. An exception should probably result in an error to handle request (500).",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431615886,2020-05-28T06:47:50Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");+            return false;+        }++        if (conditions.stream().anyMatch(t -> {+                    try {return !op.run(t);} catch (ClientPolicyException e) {+                        ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                        return false;+                    }+            })) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. Not all conditones satisfied."");+            return false;+        }++        ClientPolicyLogger.log(logger, ""POSITIVE :: This policy is applied."");+        return true;+ +    }++    private static void execute(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientExecutorFilter filter,+            ClientExecutorOperation op) throws ClientPolicyException {++        List<String> executorIds = policy.getExecutorIds();++        if (executorIds == null || executorIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This executor is not executed. No executor registered."");+            return;+        }++        List<ClientPolicyExecutor> executors = executorIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Executor ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Executor Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Executor Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyExecutor.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This executor is not executed. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (executors == null || executors.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This executor is not executed. No executor executable."");+            return;+        }++        for (ClientPolicyExecutor executor : executors) op.run(executor);","Using exceptions when the executor is not happy is fine, but in that case it should be an exception that doesn't fill the stack trace, as otherwise you have stack traces being loaded during ""normal behaviour"", which doesn't come for free. ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431618977,2020-05-28T06:54:49Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this executor to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyExecutor extends Provider {++    @Override+    default void close() {+    }++    /**+     * returns true if this executor is executed against the client.+     * A executor can be implemented to be executed on some events while not on others.+     * On the event specified as the parameter, this executor is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this executor is executed on the event.+     */+    default boolean isExecutedOnEvent(String event) {return true;}++    /**+     * execute actions against the client+     * on Dynamic Registration Endpoint access for creating client.+     *+     * @param context+     * @param authType+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions+     */+    default void executeOnDynamicClientRegister(+            ClientRegistrationContext context,+            RegistrationAuth authType)  throws ClientPolicyException {}","Default should just be an empty method, it should not throw an exceptionSame as with ClientPolicyCondition I think it would be better to have a single method for create/update clients for both dynamic and client. As in most cases the code will be the same, and a context object would allow different behaviour for specific cases.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431619176,2020-05-28T06:55:13Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this executor to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyExecutor extends Provider {++    @Override+    default void close() {+    }++    /**+     * returns true if this executor is executed against the client.+     * A executor can be implemented to be executed on some events while not on others.+     * On the event specified as the parameter, this executor is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this executor is executed on the event.+     */+    default boolean isExecutedOnEvent(String event) {return true;}++    /**+     * execute actions against the client+     * on Dynamic Registration Endpoint access for creating client.+     *+     * @param context+     * @param authType+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions+     */+    default void executeOnDynamicClientRegister(+            ClientRegistrationContext context,+            RegistrationAuth authType)  throws ClientPolicyException {}++    /**+     * execute actions against the client+     * on Dynamic Registration Endpoint access for updating client.+     *+     * @param context+     * @param authType+     * @param client - current client's model+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions+     */+    default void executeOnDynamicClientUpdate(+            ClientRegistrationContext context,+            RegistrationAuth authType,+            ClientModel client)  throws ClientPolicyException {}","Default should just be an empty method, it should not throw an exception. Applies to all default methods below.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,431692866,2020-05-28T09:10:39Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {","I see, it is performance matter and it can be resolved by cache conceptually. And I can find out the hint of how to implement it in https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/keys/DefaultKeyManager.java. Let me give some time to study it.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432226525,2020-05-29T02:43:24Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);","I've reviewed `ClientConditionFilter` interface and its implementation classes and found that these do not throw `ClientPolicyException`. Therefore, I'll modify `ClientConditionFilter`  and remove this try-catch sentences. WDYT?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432234948,2020-05-29T03:21:56Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");","I think it returns false. The reason is as follows :* IMO, If it returns false, executors are not executed but the request itself from a client is accepted and processed the same as the current keycloak. Merely executors are not executed. Conditions only detetermines whether executors are executed. * There is the chance that no conditions are evaluated. (e.g. a policy including one condition about cilent role. It is evalutated in the event of Authz Request, Token Request, but not evaluated in the event of Dynamic Client Registration.)WDYT? ",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432242355,2020-05-29T03:56:38Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");+            return false;+        }++        if (conditions.stream().anyMatch(t -> {+                    try {return !op.run(t);} catch (ClientPolicyException e) {+                        ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);","Yes, always results in false. I think that this exception is catched by the source of event (e.g. `AuthrozationEndpoint.process()`) and the contents of this exeception can be propagated to the user as the error response.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432247029,2020-05-29T04:17:37Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");+            return false;+        }++        if (conditions.stream().anyMatch(t -> {+                    try {return !op.run(t);} catch (ClientPolicyException e) {+                        ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                        return false;+                    }+            })) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. Not all conditones satisfied."");+            return false;",My intention is that the evaluation of conditions only detetermines whether executors are executed and the request itself is accepted and processed regardless of the result of the evaluation of conditions.,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432250031,2020-05-29T04:31:41Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");+            return false;+        }++        if (conditions.stream().anyMatch(t -> {+                    try {return !op.run(t);} catch (ClientPolicyException e) {+                        ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                        return false;+                    }+            })) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. Not all conditones satisfied."");+            return false;+        }++        ClientPolicyLogger.log(logger, ""POSITIVE :: This policy is applied."");+        return true;+ +    }++    private static void execute(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientExecutorFilter filter,+            ClientExecutorOperation op) throws ClientPolicyException {++        List<String> executorIds = policy.getExecutorIds();++        if (executorIds == null || executorIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This executor is not executed. No executor registered."");+            return;+        }++        List<ClientPolicyExecutor> executors = executorIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Executor ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Executor Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Executor Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyExecutor.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This executor is not executed. "" + e);","I've reviewed `ClientExecutorFilter` interface and its implementation classes and found that these do not throw `ClientPolicyException`. Therefore, I'll modify `ClientExecutorFilter` and remove this try-catch sentences. WDYT?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432300307,2020-05-29T07:21:18Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProvider.java,"@@ -0,0 +1,42 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;++import org.keycloak.provider.Provider;++/**+ * Provides Client Policy which accommodates several Conditions and Executors.+ */+public interface ClientPolicyProvider extends Provider {++    /**+     * returns the list of condition's id which this provider accommodates.+     *+     * @return list of condition's id+     */+    List<String> getConditionIds();","I see, I'll revise this codes to return the lists of ClientPolicyCondition/ClientPolicyExecutor instead of its ids.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432369212,2020-05-29T09:34:19Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java,"@@ -0,0 +1,303 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;+import java.util.stream.Collectors;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++public class ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);++    // Dynamic Client Registration+    // delegate executions to the existing ClientRegistrationPolicyManager++    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for creating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)+        );+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);+    }++    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Dynamic Registration Endpoint access for updating client"");+        doPolicyOperaion(+                context.getSession(),+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)+        );+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);+    }++    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for creating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)+        );+    }++    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Admin REST API Registration access for updating client"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)+        );+    }++    public static void triggerOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Authorization Endpoint access for authorization request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)+        );+    }++    public static void triggerOnTokenRequest(+            MultivaluedMap<String, String> params,+            OAuth2CodeParser.ParseResult parseResult,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)+        );+    }++    public static void triggerOnTokenRefresh(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Endpoint access for token refresh"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)+        );+    }++    public static void triggerOnTokenRevoke(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Revocation Endpoint access for token revoke"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)+        );+    }++    public static void triggerOnTokenIntrospect(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Token Introspenction Endpoint access for token introspect"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)+        );+    }++    public static void triggerOnUserInfoRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on UserInfo Endpoint access for userinfo request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)+        );+    }++    public static void triggerOnLogoutRequest(+            MultivaluedMap<String, String> params,+            KeycloakSession session) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Client Policy Operation : on Logout Endpoint access for logout request"");+        doPolicyOperaion(+                session,+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)+        );+    }++    private static void doPolicyOperaion(KeycloakSession session, +            ClientConditionFilter conditionFilter, ClientConditionOperation condition,+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+        for (ComponentModel policyModel : policyModels) {+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+            ClientPolicyLogger.log(logger, ""Policy Name = "" + policyModel.getName());+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;+            execute(policy, session, executorFilter, executor);+        }+    }++    private static boolean isSatisfied(+            ClientPolicyProvider policy,+            KeycloakSession session,+            ClientConditionFilter filter,+            ClientConditionOperation op) throws ClientPolicyException {++        List<String> conditionIds = policy.getConditionIds();++        if (conditionIds == null || conditionIds.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition registered."");+            return false;+        }++        List<ClientPolicyCondition> conditions = conditionIds.stream()+                .map(s -> {+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);+                        ClientPolicyLogger.log(logger, ""Condition ID = "" + s);+                        ClientPolicyLogger.log(logger, ""Condition Name = "" + conditionModel.getName());+                        ClientPolicyLogger.log(logger, ""Condition Provider ID = "" + conditionModel.getProviderId());+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);+                    })+                .filter(t -> {+                        try {return filter.run(t);} catch (ClientPolicyException e) {+                            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);+                            return false;+                        }+                }).collect(Collectors.toList());++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition evalutated."");+            return false;+        }++        if (conditions.stream().anyMatch(t -> {+                    try {return !op.run(t);} catch (ClientPolicyException e) {+                        ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. "" + e);","But, the exception is caught/swallowed here and false is returned, so how would AuthrozationEndpoint.process() catch the contents of the exception?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432425349,2020-05-29T11:35:00Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyCondition.java,"@@ -0,0 +1,181 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this condition to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyCondition extends Provider {++    @Override+    default void close() {}++    /**+     * returns true if this condition is evaluated to check+     * whether the client satisfies this condition on the event specified as a parameter.+     * A condition can be implemented to be evaluated on some events while not on others.+     * On the event specified as the parameter, this condition is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this condition is evaluated on the event.+     */+    default boolean isEvaluatedOnEvent(String event) {return true;}","I think you said that `isEvaluatedOnEvent()` and `isSatisfiedOn...()` are integrated into one method. The reason why I split into two method is as follows :* There are several events defined by `ClientPolicyEvent` and a condition is not needed to be evaluated on all events.  (e.g. a policy including one condition about client role. It is evaluated in the event of Authz Request, Token Request, but not evaluated in the event of Dynamic Client Registration.)* Considering the point just above, if we try to evaluate the condition, the following three results are possible1. This condition is not needed to be evaluated.2. This condition is needed to be evaluated. Therefore, keycloak tries to evaluate this condition to check whether the client who sent the request satisfies this condition and it indeed satisfies.3. This condition is needed to be evaluated. Therefore, keycloak tries to evaluate this condition to check whether the client who sent the request satisfies this condition and it does NOT satisfies.which means three values are returned if we  integrate `isEvaluatedOnEvent()` and `isSatisfiedOn...()` onto one method.At first, I had tried to achieve one method but found the point just above. Therefore I've separated two method. At first, checking whether the condition itself is needed to evaluated on its nature, after that, I've tried to actually evaluate this condition to check whether the client satisfies with the condition or not.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432429509,2020-05-29T11:44:44Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyCondition.java,"@@ -0,0 +1,181 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this condition to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyCondition extends Provider {++    @Override+    default void close() {}++    /**+     * returns true if this condition is evaluated to check+     * whether the client satisfies this condition on the event specified as a parameter.+     * A condition can be implemented to be evaluated on some events while not on others.+     * On the event specified as the parameter, this condition is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this condition is evaluated on the event.+     */+    default boolean isEvaluatedOnEvent(String event) {return true;}","And, I think that it is not appropriate to implement `boolean isEvaluatedOnEvent(String event)` with default sentence. IMO, the actual implementation of condition needs to implement this method explicitly on its nature. Therefore, I'd like to remove default keyword from this method.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432791395,2020-05-30T00:31:21Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this executor to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyExecutor extends Provider {++    @Override+    default void close() {+    }++    /**+     * returns true if this executor is executed against the client.+     * A executor can be implemented to be executed on some events while not on others.+     * On the event specified as the parameter, this executor is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this executor is executed on the event.+     */+    default boolean isExecutedOnEvent(String event) {return true;}++    /**+     * execute actions against the client+     * on Dynamic Registration Endpoint access for creating client.+     *+     * @param context+     * @param authType+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions+     */+    default void executeOnDynamicClientRegister(+            ClientRegistrationContext context,+            RegistrationAuth authType)  throws ClientPolicyException {}","My intention for throwing `ClientPolicyException` from `executeOn...()` methods is as follows :* There is a chance that an executor refuses a request from a client. For example, an executor for enforcing PKCE. When a client sends an authorization request without `code_challenge` on Authorization Endpoint, this executor refuses this request* If an executor refuses a request from a client, the executor needs to convey this situation to these methods' caller in order for them to send an appropriate error to the client. For the example above, `AuthorizationEndpoint` returns to the client 400 Bad Request with `error=""invalid_client""`.* To convey such the situation, I've used an exception. ",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432792185,2020-05-30T00:37:11Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this executor to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyExecutor extends Provider {++    @Override+    default void close() {+    }++    /**+     * returns true if this executor is executed against the client.+     * A executor can be implemented to be executed on some events while not on others.+     * On the event specified as the parameter, this executor is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this executor is executed on the event.+     */+    default boolean isExecutedOnEvent(String event) {return true;}++    /**+     * execute actions against the client+     * on Dynamic Registration Endpoint access for creating client.+     *+     * @param context+     * @param authType+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions+     */+    default void executeOnDynamicClientRegister(+            ClientRegistrationContext context,+            RegistrationAuth authType)  throws ClientPolicyException {}"," As the same as condition, I'll implement `default void executeOnClientUpdate(ClientUpdateContext context)`   instead of current several method on each events (Dynamic Client Registration, Dynamic Client Update, Admin REST API Client Registration, Admin REST API Client Update).",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,432801982,2020-05-30T02:27:18Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java,"@@ -0,0 +1,107 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor.impl;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * Executor can override the client settings to enforce some actions.+ * This feature can be activated or deactivated.+ */+public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutor {","> For update events the augment for all executors needs to be done prior to the isSatisfied as it could be that one executor adds something that a different executor requires.One point I'd like to confirm it is that an executor do augment and validation against clients that satisfies all conditions of a policy. Therefore, I intended that no method of an executor is called before `isSatisfied...()` of a condition are called. Is that correct?",
19531958,drichtarik,https://api.github.com/repos/keycloak/keycloak/pulls/7109,433156676,2020-06-01T10:26:30Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/AuthenticationManagementResource.java,"@@ -88,6 +88,11 @@     @Consumes(MediaType.APPLICATION_JSON)     Response copy(@PathParam(""flowAlias"") String flowAlias, Map<String, String> data); +    @Path(""/flows/{id}"")+    @PUT+    @Consumes(MediaType.APPLICATION_JSON)+    Response updateFlow(@PathParam(""id"") String id, AuthenticationFlowRepresentation flow);","I can edit the return type of updateExecutions method which I changed to Response: https://github.com/drichtarik/keycloak/commit/ebc057e55e31c8d16a91bbbd2f708c399030ca56#diff-024264f56f48bd47bd9f783559f2bf85R602, but updateFlows method has already had a return type Response, that's why I created this resource as a Response too. I can edit this to void type but then I'd have to redo this: https://github.com/drichtarik/keycloak/commit/ebc057e55e31c8d16a91bbbd2f708c399030ca56#diff-024264f56f48bd47bd9f783559f2bf85R258 too along with several tests. Do you want me to keep this one or redo the original code too?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7109,433187005,2020-06-01T11:42:51Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/AuthenticationManagementResource.java,"@@ -88,6 +88,11 @@     @Consumes(MediaType.APPLICATION_JSON)     Response copy(@PathParam(""flowAlias"") String flowAlias, Map<String, String> data); +    @Path(""/flows/{id}"")+    @PUT+    @Consumes(MediaType.APPLICATION_JSON)+    Response updateFlow(@PathParam(""id"") String id, AuthenticationFlowRepresentation flow);","@drichtarik The methods on the server (in class org.keycloak.services.resources.admin.AuthenticationManagementResource) and on the admin client (in class org.keycloak.admin.client.resource.AuthenticationManagementResource) don't need to have same signatures. Their only contract is through HTTP/REST, they don't have any contract like Java interface etc.Feel free to use the ""Response"" as return type on the server (in org.keycloak.services.resources.admin.AuthenticationManagementResource), but on the client, it is not good to use ""Response"" at all due the missing automatic error handling, requirement to manually close responses etc. So I suggest to return ""void"" from the org.keycloak.admin.client.resource.AuthenticationManagementResource.updateFlow and org.keycloak.admin.client.resource.AuthenticationManagementResource.updateExecutions and update the tests accordingly.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7138,434819472,2020-06-03T19:58:38Z,adapters/oidc/tomcat/tomcat-core/src/main/java/org/keycloak/adapters/tomcat/CatalinaSessionTokenStore.java,"@@ -163,6 +167,17 @@ public Principal getPrincipal() {         public RefreshableKeycloakSecurityContext getKeycloakSecurityContext() {             return securityContext;         }++        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {+            DelegatingSerializationFilter.builder()+                    .addAllowedClass(CatalinaSessionTokenStore.SerializableKeycloakAccount.class)+                    .addAllowedClass(RefreshableKeycloakSecurityContext.class)+                    .addAllowedClass(KeycloakSecurityContext.class)+                    .addAllowedClass(KeycloakPrincipal.class)+                    .setFilter(in);++            in.defaultReadObject();+        }     }","Just thinking if we shouldn't add a similar method to OIDCFilterSessionStore.SerializableKeycloakAccount, which is an exact copy of this class.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,435132987,2020-06-04T09:54:07Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this executor to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyExecutor extends Provider {++    @Override+    default void close() {+    }++    /**+     * returns true if this executor is executed against the client.+     * A executor can be implemented to be executed on some events while not on others.+     * On the event specified as the parameter, this executor is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this executor is executed on the event.+     */+    default boolean isExecutedOnEvent(String event) {return true;}++    /**+     * execute actions against the client+     * on Dynamic Registration Endpoint access for creating client.+     *+     * @param context+     * @param authType+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions+     */+    default void executeOnDynamicClientRegister(+            ClientRegistrationContext context,+            RegistrationAuth authType)  throws ClientPolicyException {}","Ignore the comment on the default implementation - I completely miss-read the code, somehow I read ""throw new ClientPolicyException()"" as the default implementation, not that the method ""throws ClientPolicyException""Having the single method for an events (instead isExecuted on and executeOn) will be good and I think it will clean up the PR a lot, as well as require less ""boilerplate"" to implement executors and conditions.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7141,435513641,2020-06-04T19:56:21Z,themes/src/main/resources/theme/keycloak-preview/account/resources/app/content/my-resources-page/ResourcesTable.tsx,"@@ -83,6 +87,16 @@ export class ResourcesTable extends AbstractResourcesTable<CollapsibleResourcesT     }      public render(): React.ReactNode {+        if (this.props.resources.data.length === 0) {+            return (+                <EmptyState variant={EmptyStateVariant.full}>+                    <EmptyStateIcon icon={RepositoryIcon}/>+                    <Title headingLevel=""h5"" size=""lg"">+                        <Msg msgKey=""notHaveAnyResource""/>+                    </Title>+                </EmptyState>",Perhaps put this into its own component passing in icon and message.  Then reuse in both tables.,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,437063905,2020-06-08T23:58:12Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java,"@@ -153,6 +155,12 @@ private Response process(MultivaluedMap<String, String> params) {             return errorResponse;         } +        try {+            ClientPolicyManager.triggerOnAuthorizationRequest(parsedResponseType, request, redirectUri, session);","I've tried to add `clientPolicy()` method on `KeycloakSession` and `DefaultKecloakSession` but have a problem. `KeycloakSession` belongs to keycloak-server-spi while `ClientPolicyManager` belongs to keycloak-services. The latter is not visible from the former. Considering signatures of methods in `ClientPolicyManager`, it seems to be difficult to implement `ClientPolicyManager` interface in keycloak-server-spi and `DefaultClientPolicyManager implements ClientPolicyManager` class in keycloak-services. Is it inevitably necessary to do so instead of the current `ClientPolicyManager`'s method call directly? ",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,437085138,2020-06-09T01:20:46Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyCondition.java,"@@ -0,0 +1,181 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.models.ClientModel;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.provider.Provider;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientregistration.ClientRegistrationContext;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;+import org.keycloak.services.resources.admin.AdminAuth;++/**+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this condition to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyCondition extends Provider {++    @Override+    default void close() {}++    /**+     * returns true if this condition is evaluated to check+     * whether the client satisfies this condition on the event specified as a parameter.+     * A condition can be implemented to be evaluated on some events while not on others.+     * On the event specified as the parameter, this condition is skipped if this method returns false.+     *+     * @param event defined in {@link ClientPolicyEvent}+     * @return true if this condition is evaluated on the event.+     */+    default boolean isEvaluatedOnEvent(String event) {return true;}","The just idea for removing `boolean isEvaluatedOnEvent(String event)` is as follows :>1. This condition is not needed to be evaluated.`boolean isSatisfiedOn...()` throws `ClientPolicyException` without stacktrace.>2. This condition is needed to be evaluated. Therefore, keycloak tries to evaluate this condition to check whether the client who sent the request satisfies this condition and it indeed satisfies.`boolean isSatisfiedOn...()` returns true.>3. This condition is needed to be evaluated. Therefore, keycloak tries to evaluate this condition to check whether the client who sent the request satisfies this condition and it does NOT satisfies.`boolean isSatisfiedOn...()` returns false.I'm not sure whether it is appropriate to use Exception for such the use. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7152,437454086,2020-06-09T14:11:38Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/idm/store/ldap/LDAPContextManager.java,"@@ -76,15 +80,22 @@ private void createLdapContext() throws NamingException {          ldapContext = new InitialLdapContext(connProp, null);         if (ldapConfig.isStartTls()) {+            SSLSocketFactory sslSocketFactory = null;+            String useTruststoreSpi = ldapConfig.getUseTruststoreSpi();+            if (useTruststoreSpi != null && useTruststoreSpi.equals(LDAPConstants.USE_TRUSTSTORE_ALWAYS)) {+                TruststoreProviderFactory truststoreFactory = (TruststoreProviderFactory) session.getKeycloakSessionFactory().getProviderFactory(TruststoreProvider.class, ""file"");","I think that lines 86-87 should be replaced with:````TruststoreProvider provider = session.getProvider(TruststoreProvider.class);````This is more proper use of KeycloakSession SPI and at the same time, it is not hardcoded to ""file"" provider - the users can in theory replace the ""file"" provider with something else",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6926,437482847,2020-06-09T14:48:33Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UsersResource.java,"@@ -56,6 +56,10 @@     @Produces(MediaType.APPLICATION_JSON)     List<UserRepresentation> search(@QueryParam(""username"") String username); +    @GET+    @Produces(MediaType.APPLICATION_JSON)+    List<UserRepresentation> search(@QueryParam(""username"") String username, @QueryParam(""exact"") Boolean exact);","I believe admin client should rather add `exact` on the parameter-richest variant of `search(String search, Integer firstResult, Integer maxResults, Boolean briefRepresentation)`. \<sigh>Pity Java does not have any support for default parameter values.\</sigh>",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7153,437489346,2020-06-09T14:56:49Z,model/infinispan/src/main/java/org/keycloak/connections/infinispan/TopologyInfo.java,"@@ -63,7 +63,7 @@ public TopologyInfo(EmbeddedCacheManager cacheManager, Config.Scope config, bool         if (!embedded) {             Transport transport = cacheManager.getTransport();             if (transport != null) {-                nodeName = transport.getAddress().toString();+                nodeName = cacheManager.getCacheManagerConfiguration().transport().nodeName();","Cluster tests using the main dist are passing for me locally except for the AuthenticationSessionFailoverClusterTest, which is the one that makes more use of this change.I'm testing now without this change to see how it goes and try to find another approach to the problem if that is causing issues.But CI is failing with ""failed to update database"", which is quite weird as this changeset is not supposed to cause that. Also investigating.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6926,437578827,2020-06-09T16:54:31Z,integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UsersResource.java,"@@ -56,6 +56,10 @@     @Produces(MediaType.APPLICATION_JSON)     List<UserRepresentation> search(@QueryParam(""username"") String username); +    @GET+    @Produces(MediaType.APPLICATION_JSON)+    List<UserRepresentation> search(@QueryParam(""username"") String username, @QueryParam(""exact"") Boolean exact);","I see your point. However, that is going to break people using that method. What I can do is add a new variant of it with the new parameter.The method you mentioned means also another type of query that looks up multiple properties (iirc, email, username, first/last names).This one is specific for username and for other usages the API is ready. The focus here is really the API.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7146,437601009,2020-06-09T17:31:40Z,services/src/main/java/org/keycloak/services/resources/LoginActionsService.java,"@@ -380,31 +379,43 @@ public Response resetCredentialsGET(@QueryParam(AUTH_SESSION_ID) String authSess             if (!realm.isResetPasswordAllowed()) {                 event.event(EventType.RESET_PASSWORD);                 event.error(Errors.NOT_ALLOWED);-                return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.RESET_CREDENTIAL_NOT_ALLOWED);+                return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.RESET_CREDENTIAL_NOT_ALLOWED);              }-            authSession = createAuthenticationSessionForClient();+            authSession = createAuthenticationSessionForClient(clientId);             return processResetCredentials(false, null, authSession, null);         }          event.event(EventType.RESET_PASSWORD);         return resetCredentials(authSessionId, code, execution, clientId, tabId);     } -    AuthenticationSessionModel createAuthenticationSessionForClient()-      throws UriBuilderException, IllegalArgumentException {+    AuthenticationSessionModel createAuthenticationSessionForClient(String clientID)+            throws UriBuilderException, IllegalArgumentException {         AuthenticationSessionModel authSession; -        // set up the account service as the endpoint to call.-        ClientModel client = SystemClientUtil.getSystemClient(realm);+        ClientModel client = session.realms().getClientByClientId(clientID, realm);+        String redirectUri = null;++        if (client == null) {+            client = SystemClientUtil.getSystemClient(realm);+        } else {+            redirectUri = client.getRedirectUris()+                    .stream()+                    .findFirst()+                    .orElse(null);+        }++        if (redirectUri == null) {+            redirectUri = Urls.accountBase(session.getContext().getUri().getBaseUri()).path(""/"").build(realm.getName()).toString();","+1 to remove this and move after line 401. The thing is, that with the current code, it can happen that ""redirectUri"" is set to the redirectUri of the account client, even if client_id is different than account. This can have various side-effects. If the null redirectUri is the issue, then it might be better to throw the exception in case of null redirectUri",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7136,438176327,2020-06-10T14:40:26Z,services/src/main/java/org/keycloak/services/filters/KeycloakTransactionCommitter.java,"@@ -36,13 +36,20 @@ public class KeycloakTransactionCommitter implements ContainerResponseFilter {      @Override-    public void filter(ContainerRequestContext containerRequestContext, ContainerResponseContext containerResponseContext) throws IOException {-        KeycloakTransaction tx = Resteasy.getContextData(KeycloakTransaction.class);+    public void filter(ContainerRequestContext containerRequestContext, ContainerResponseContext containerResponseContext) {+        KeycloakTransaction tx =  Resteasy.getContextData(KeycloakTransaction.class);",```suggestion        KeycloakTransaction tx = Resteasy.getContextData(KeycloakTransaction.class);```,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7153,438246963,2020-06-10T16:13:52Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/cluster/AuthenticationSessionFailoverClusterTest.java,"@@ -83,8 +84,17 @@ public void setup() {                 .build();          userId = ApiUtil.createUserAndResetPasswordWithAdminClient(adminClient.realm(""test""), user, ""password"");-        getCleanup().addUserId(userId);+        +        //TODO: weird behavior when doing Quarkus where only one of the required actions above are persisted, so we workaround by forcing an update to the user with the 2 actions we want+        UserResource userResource = adminClient.realm(testRealm.getRealm()).users().get(userId);+        UserRepresentation userRepresentation = userResource.toRepresentation();+        +        if (userRepresentation.getRequiredActions().size() < 2) {+            userRepresentation.setRequiredActions(user.getRequiredActions());+            userResource.update(userRepresentation);+        } +        getCleanup().addUserId(userId);","Humm ... The same line and assertion. It seems to be related.We had some related issues in Quarkus but they were fixed. So I was thinking it was Quarkus specific, but it seems to be a common issue.We do have similar tests that perform the same initialization steps using required actions, so I'm pretty sure it is not an issue on the server.Do you have an idea when this issue started to happen? Or you just caught it?It might be related to some changes I sent to the JPA model, although not sure because, as I said, some other tests perform the same steps and are working fine.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7080,438615140,2020-06-11T08:09:37Z,server-spi/src/main/java/org/keycloak/models/utils/UserModelDelegate.java,"@@ -44,16 +44,6 @@ public String getId() {         return delegate.getId();     } -    @Override-    public String getUsername() {","I think it it not very good to remove those methods from UserModelDelegate? IMO you always want to call delegate rather than rely on default implementations from UserModel. In some cases, the methods on the delegate can do something different that call ""setAttribute/getAttribute"" . I hope it is possible to revert changes in UserModelDelegate class entirely.",
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/7075,438740321,2020-06-11T12:17:22Z,distribution/feature-packs/server-feature-pack/src/main/resources/licenses/keycloak/licenses.xml,"@@ -861,214 +861,422 @@       </licenses>     </other>     <other>-      <description>Axios</description>+      <description>@emotion/memoize</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/axios/dist/axios.min.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/axios/axios/v0.19.0/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/emotion-js/emotion/tree/master/next-packages/memoize/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>ChangeCase</description>+      <description>@emotion/unitless</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/camel-case/camel-case.js</file>-        <file>themes/keycloak-preview/account/resources/node_modules/lower-case/lower-case.js</file>-        <file>themes/keycloak-preview/account/resources/node_modules/no-case/no-case.js</file>-        <file>themes/keycloak-preview/account/resources/node_modules/no-case/vendor/camel-case-regexp.js</file>-        <file>themes/keycloak-preview/account/resources/node_modules/no-case/vendor/camel-case-upper-regexp.js</file>-        <file>themes/keycloak-preview/account/resources/node_modules/no-case/vendor/non-word-regexp.js</file>-        <file>themes/keycloak-preview/account/resources/node_modules/upper-case/upper-case.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/blakeembrey/change-case/v3.0.0/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/emotion-js/emotion/tree/master/next-packages/unitless/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>Emotion</description>+      <description>@emotion/hash</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/emotion/dist/emotion.umd.min.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/emotion-js/emotion/v9.2.12/packages/emotion/package.json</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/emotion-js/emotion/tree/master/next-packages/hash/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>ExecutionEnvironment</description>+      <description>@emotion/stylis</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/exenv/index.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>BSD 3-clause New or Revised License</name>-          <url>https://raw.githubusercontent.com/JedWatson/exenv/v1.2.2/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/emotion-js/emotion/tree/master/next-packages/stylis/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>focus-trap-react</description>+      <description>stylis-rule-sheet</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/focus-trap-react/dist/focus-trap-react.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/davidtheclark/focus-trap-react/4.0.1/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/thysultan/stylis.js/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>focus-trap</description>+      <description>create-emotion</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/focus-trap/dist/focus-trap.min.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/davidtheclark/focus-trap/3.0.0/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/emotion-js/emotion/tree/master/packages/create-emotion/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>Moment.js</description>+      <description>emotion</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/moment/min/moment-with-locales.min.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/moment/moment/2.22.2/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/emotion-js/emotion/tree/master/packages/emotion/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>upper-case</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/blakeembrey/upper-case/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>lower-case</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/blakeembrey/lower-case/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>no-case</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/blakeembrey/no-case/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>camel-case</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/blakeembrey/camel-case/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>@patternfly</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/patternfly/patternfly-react/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>tabbable</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/davidtheclark/tabbable/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>xtend</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/Raynos/xtend/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>focus-trap</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/davidtheclark/focus-trap/master/LICENSE</url>         </license>       </licenses>     </other>     <other>       <description>prop-types</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/prop-types/prop-types.min.js</file>+        <file>themes/keycloak/common/resources/web_modules/common/index-fd2ed651.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/facebook/prop-types/v15.6.2/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/facebook/prop-types/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>React</description>+      <description>popper.js</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/react-dom/umd/react-dom.production.min.js</file>-        <file>themes/keycloak-preview/account/resources/node_modules/react-router-dom/umd/react-router-dom.min.js</file>-        <file>themes/keycloak-preview/account/resources/node_modules/react/umd/react.production.min.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/facebook/react/v16.8.5/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/FezVrasta/popper.js/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>SystemJS</description>+      <description>tippy.js</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/systemjs/dist/system.src.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/systemjs/systemjs/0.20.19/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/atomiks/tippyjs/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>Tippy.js</description>+      <description>tslib</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/tippy.js/dist/tippy.min.js</file>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/atomiks/tippyjs/v3.4.1/LICENSE</url>+          <name>Apache-2.0</name>+          <url>https://raw.githubusercontent.com/Microsoft/tslib/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>Patternfly 4</description>+      <description>file-selector</description>       <locations>-        <directory>themes/keycloak-preview/account/resources/node_modules/@patternfly/patternfly</directory>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/patternfly/patternfly-next/v2.26.5/LICENSE.txt</url>+          <name>MIT</name>+          <url/>         </license>       </licenses>     </other>     <other>-      <description>Patternfly 4 React Core</description>+      <description>attr-accept</description>       <locations>-        <directory>themes/keycloak-preview/account/resources/node_modules/@patternfly/react-core</directory>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/patternfly/patternfly-react/%40patternfly/react-core%403.35.0/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/okonet/attr-accept/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>Patternfly 4 React Icons</description>+      <description>react-dropzone</description>       <locations>-        <directory>themes/keycloak-preview/account/resources/node_modules/@patternfly/react-icons</directory>+        <file>themes/keycloak/common/resources/web_modules/@patternfly/react-core.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/patternfly/patternfly-react/%40patternfly/react-icons%403.11.0/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/react-dropzone/react-dropzone/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>Patternfly 4 React Styles</description>+      <description>@pika/react</description>       <locations>-        <directory>themes/keycloak-preview/account/resources/node_modules/@patternfly/react-styles</directory>+        <file>themes/keycloak/common/resources/web_modules/react.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/patternfly/patternfly-react/%40patternfly/react-styles%403.5.13/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/facebook/react/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>Patternfly 4 React Tokens</description>+      <description>@pika/react-dom</description>       <locations>-        <directory>themes/keycloak-preview/account/resources/node_modules/@patternfly/react-tokens</directory>+        <file>themes/keycloak/common/resources/web_modules/react-dom.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/patternfly/patternfly-react/%40patternfly/react-tokens%402.6.16/LICENSE</url>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/facebook/react/master/LICENSE</url>         </license>       </licenses>     </other>     <other>-      <description>Tippy.js React</description>+      <description>warning</description>       <locations>-        <file>themes/keycloak-preview/account/resources/node_modules/@tippy.js/react/dist/Tippy.min.js</file>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>       </locations>       <licenses>         <license>-          <name>MIT License</name>-          <url>https://raw.githubusercontent.com/atomiks/tippy.js-react/v1.1.1/LICENSE</url>+          <name>MIT</name>+          <url>https://github.com/BerkeleyTrue/warning/raw/master/LICENSE.md</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>invariant</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/zertosh/invariant/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>resolve-pathname</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/mjackson/resolve-pathname/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>value-equal</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/mjackson/value-equal/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>history</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/ReactTraining/history/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>react-router</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/ReactTraining/react-router/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>react-router-dom</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/ReactTraining/react-router/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>isarray</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/juliangruber/isarray/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>path-to-regexp</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>MIT</name>+          <url>https://raw.githubusercontent.com/pillarjs/path-to-regexp/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>hoist-non-react-statics</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/react-router-dom.js</file>+      </locations>+      <licenses>+        <license>+          <name>BSD-3-Clause</name>+          <url>https://raw.githubusercontent.com/mridgway/hoist-non-react-statics/master/LICENSE</url>+        </license>+      </licenses>+    </other>+    <other>+      <description>object-assign</description>+      <locations>+        <file>themes/keycloak/common/resources/web_modules/common/index-fd2ed651.js</file>",> Last thing to do is to run [download-license-files.sh](https://github.com/keycloak/keycloak/blob/master/distribution/licenses-common/download-license-files.sh).I already did that...,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7150,438863235,2020-06-11T15:18:17Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -825,6 +823,10 @@                 configUrl = 'keycloak.json';             } else if (typeof config === 'string') {                 configUrl = config;+            } else if (typeof config === ""object"") {","Good to know, but isn't this already handled by `if (!config) {` a few lines above?See: https://github.com/keycloak/keycloak/blob/0ce69d0a92478970609c53eaba79e9bb097e7ecf/adapters/oidc/js/src/main/resources/keycloak.js#L822",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7080,438917537,2020-06-11T16:29:54Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java,"@@ -87,12 +87,12 @@ public UserModel getUserById(String id, RealmModel realm) {     private UserModel createUser(RealmModel realm, String username) {         return new AbstractUserAdapterFederatedStorage(session, realm,  model) {             @Override-            public String getUsername() {+            public String doGetUsername() {",The UserStorage SPI needs to be backwards compatible. It means that UserStorage providers developed in the previous Keycloak versions must still work with the newest version without any changes needed in their sources. So the BackwardsCompatibilityUserStorage provider should still work without this change needed... The similar will be good for other user storage providers - will be nice if no changes are required in them,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7080,438923885,2020-06-11T16:40:45Z,server-spi/src/main/java/org/keycloak/storage/adapter/AbstractUserAdapter.java,"@@ -60,6 +60,13 @@ public AbstractUserAdapter(KeycloakSession session, RealmModel realm, ComponentM         this.storageProviderModel = storageProviderModel;     } +    abstract protected String doGetUsername();","I hope it will be possible to make the things working without this change. Introducing method ""doGetUsername"" on the UserStorage SPI seems like a workaround to me and doesn't improve the usability of UserStorage SPI. See my other comment for the class BackwardsCompatibilityUserStorageMaybe if you re-add the methods to UserModelDelegate back, then this change is not needed? In ideal case, if no changes are needed in AbstractUserAdapter class, it will be ideal :) ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7080,438924374,2020-06-11T16:41:34Z,server-spi/src/main/java/org/keycloak/storage/adapter/AbstractUserAdapterFederatedStorage.java,"@@ -64,6 +65,20 @@ public AbstractUserAdapterFederatedStorage(KeycloakSession session, RealmModel r         this.storageProviderModel = storageProviderModel;     } +    protected abstract String doGetUsername();",See my comment for AbstractUserAdapter class. I think this applies here as well - for both doGetUsername and doSetUsername methods.,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7067,439027769,2020-06-11T19:44:52Z,themes/src/main/resources/theme/keycloak-preview/account/src/app/account-service/account.service.ts,"@@ -84,14 +84,16 @@ class AccountServiceClient {         return response;     } -    private handleError(response: HttpResponse): void {+    private handleError(response: HttpResponse<any>): void {","Avoid 'any'.This should work:```   private handleError(response: HttpResponse): void {        if (response != null && response.status === 401) {            // session timed out?            this.kcSvc.login();        }        const errorResponse = response.data as {errorMessage?: string, error?: string};        if (response != null && response.data != null) {            ContentAlert.danger(                `${response.statusText}: ${errorResponse.errorMessage ? errorResponse.errorMessage : ''} ${errorResponse.error ? errorResponse.error : ''}`            );        } else {            ContentAlert.danger(response.statusText);        }    }```",
31658331,Martin-Idel-SI,https://api.github.com/repos/keycloak/keycloak/pulls/7080,439243999,2020-06-12T07:04:20Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java,"@@ -87,12 +87,12 @@ public UserModel getUserById(String id, RealmModel realm) {     private UserModel createUser(RealmModel realm, String username) {         return new AbstractUserAdapterFederatedStorage(session, realm,  model) {             @Override-            public String getUsername() {+            public String doGetUsername() {","I can see that you'd like to have backwards compatibility. The reasons I did this change is the default methods `getUsername()` and `setUsername(String name)` on `UserModel`:- Since they are default methods, the `AbstractUserAdapterFederatedStorage` is not abstract anymore- if you fail to override the `getUsername()` method, you will run into an infinite loop, because the `getUsername()` default method calls the `getFirstAttribute` method, which in AbstractUserAdapterFederatedStorage MUST call the `getUsername` method in order to be able to get the username from somewhere else and keep consistency (i.e. we still want to have `username` accessible as attribute. In other words, not introducing this method, everything works completely fine if you override all important methods correctly, but the compiler won't stop you anymore. With the workaround, it's more consistent.Now, if you say that the AbstractAdapters may not change for backwards compatibility, then that's what needs to happen, so let's see what our options are:- Delete the method again and swallow the possibility of infinite loops as outlined above (as well as weird naming ""Abstract"" of non-abstract class)- Do not have a default implementation of `getUsername()` and `setUsername(...)` on `UserModel`, but require each subclass to provide it. This is a bit inconsistent with the handling of the other methods but that shouldn't really be a problemThe latter is the safest method so I'm going to implement this and let you have a look!",
31658331,Martin-Idel-SI,https://api.github.com/repos/keycloak/keycloak/pulls/7080,439461477,2020-06-12T14:42:17Z,server-spi/src/main/java/org/keycloak/models/utils/UserModelDelegate.java,"@@ -44,16 +44,6 @@ public String getId() {         return delegate.getId();     } -    @Override-    public String getUsername() {","The problem is that this introduces potential inconsistencies: I have two ways to access and/or change those attributes. If one way behaves differently than the other, this will lead to subtle and hard to debug bugs. That's why I would've deprecated and deleted those methods altogether but I can see that the effort involved is much larger as of now (for instance ftl templates rely on those methods), so we keep those methods. This is in general true for all subclasses of `UserModel`. For the `AbstractUserAdapterFederatedStorage` this is discussed in the other comment and there is a solution to ensure consistent behaviour as long as the implementation does not override the methods to get or set attributes. I didn't see any other implementation of that interface I thought was modeled for inheritance, but if it is possible to provide UserModel implementations via SPI then we definitely should think about this again. ",
52915386,huangwenkan9,https://api.github.com/repos/keycloak/keycloak/pulls/7015,439704207,2020-06-13T03:19:03Z,services/src/main/java/org/keycloak/social/instagram/InstagramIdentityProvider.java,"@@ -46,23 +47,20 @@ public InstagramIdentityProvider(KeycloakSession session, OAuth2IdentityProvider  	protected BrokeredIdentityContext doGetFederatedIdentity(String accessToken) { 		try {-			JsonNode raw = SimpleHttp.doGet(PROFILE_URL,session).param(""access_token"", accessToken).asJson();+			JsonNode raw = SimpleHttp.doGet(PROFILE_URL,session)+				.param(""access_token"", accessToken)+				.param(""fields"", PROFILE_FIELDS)+				.asJson(); 			 			JsonNode profile = raw.get(""data""); 			 			logger.debug(profile.toString());  			String id = getJsonProperty(profile, ""id"");+	  		String username = getJsonProperty(profile, ""username"");","raw not 'data' of node```suggestion			logger.debug(raw.toString());						String id = getJsonProperty(raw, ""id"");	  		String username = getJsonProperty(raw, ""username"");```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/7150,439742169,2020-06-13T14:14:16Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -438,15 +438,13 @@                 baseUrl = kc.endpoints.authorize();",If we're going to make these changes we also need to make sure that the TypeScript definitions are updated. The JSDoc on the `scope` field on the `KeycloakLoginOptions` interface must no longer be private and include some descriptive text for the field itself.And we'll have to add the same `scope` field to the `KeycloakConfig` interface which is used for the configuration passed into the constructor.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7080,439973609,2020-06-15T07:16:38Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java,"@@ -87,12 +87,12 @@ public UserModel getUserById(String id, RealmModel realm) {     private UserModel createUser(RealmModel realm, String username) {         return new AbstractUserAdapterFederatedStorage(session, realm,  model) {             @Override-            public String getUsername() {+            public String doGetUsername() {","Thanks for bringing this. Yes, I think the latter option should be OK. The ""getUsername()"" and ""setUsername()"" may not be available by default on the UserModel. At least, I don't see any issues with that right now...Just FYI. the fact that ""Abstract""* class doesn't have any abstract methods, it can still be declared as ""abstract"" class. But that's really just a detail and maybe not so relevant...",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7080,440089599,2020-06-15T10:47:06Z,services/src/main/java/org/keycloak/theme/FreeMarkerUtil.java,"@@ -73,8 +73,8 @@ public String processTemplate(Object data, String templateName, Theme theme) thr     }      private Template getTemplate(String templateName, Theme theme) throws IOException {-        Configuration cfg = new Configuration();-        +        Configuration cfg = new Configuration(Configuration.VERSION_2_3_26);","Not sure to be honest as I don't know what the implications really are here. It seems this requires FreeMarker to do additional reflection of the classes, which could be expensive? Also, what would break in existing templates with this?",
31658331,Martin-Idel-SI,https://api.github.com/repos/keycloak/keycloak/pulls/7080,440092205,2020-06-15T10:52:35Z,server-spi/src/main/java/org/keycloak/models/utils/UserModelDelegate.java,"@@ -44,16 +44,6 @@ public String getId() {         return delegate.getId();     } -    @Override-    public String getUsername() {","It's possible (see the two last commits). However, please note the duplicate code I had to introduce to keep consistency!",
31658331,Martin-Idel-SI,https://api.github.com/repos/keycloak/keycloak/pulls/7080,440096583,2020-06-15T11:01:20Z,services/src/main/java/org/keycloak/theme/FreeMarkerUtil.java,"@@ -73,8 +73,8 @@ public String processTemplate(Object data, String templateName, Theme theme) thr     }      private Template getTemplate(String templateName, Theme theme) throws IOException {-        Configuration cfg = new Configuration();-        +        Configuration cfg = new Configuration(Configuration.VERSION_2_3_26);","Yes in the sense that it requires FreeMarker to also see default methods, but I'd think this should be done in the same pass where Freemarker retrieves the other getter/setter methods, so this shouldn't have a large overhead (if any).However, some things may break: Here is an overview: https://freemarker.apache.org/docs/api/freemarker/template/Configuration.html#Configuration-freemarker.template.Version- - since I have no idea what features are used, it's hard for me to judge if this is a problem. I ran some console tests and all seemed fine, so I was confident enough to propose this change.As I said, the alternative would be to not use default methods but duplicate the methods to all implementing classes.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7167,440366193,2020-06-15T18:29:11Z,adapters/oidc/js/src/main/resources/keycloak.d.ts,"@@ -215,6 +215,8 @@ declare namespace Keycloak { 		redirectUri?: string; 	} +	interface KeycloakRegisterOptions extends Omit<KeycloakLoginOptions, 'action'> { }","I don't think this is quite right.  Today it is valid to pass the action as a register option as long as it is set to 'register'.  So this could possibly break existing code.What do you think of this instead?`type KeycloakRegisterOptions = Omit<KeycloakLoginOptions, 'action'> & {action?: 'register'}`",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,440431817,2020-06-15T20:36:09Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java,"@@ -153,6 +155,12 @@ private Response process(MultivaluedMap<String, String> params) {             return errorResponse;         } +        try {+            ClientPolicyManager.triggerOnAuthorizationRequest(parsedResponseType, request, redirectUri, session);",I've treated this matter as follows :- Crate `ClientPolicyContext` in keycloak-server-spi interface only have a method for returning an event.- `ClientPolicyManager` interface in keycloak-server-spi receives this `ClientPolicyContext` as an argument.- `KeycloakSession` interface in keycloak-server-spi has the method to get `ClientPolicyManager`.- An implementation class of `ClientPolicyContext` in keycloak-services implements actual methods depending on an event defined in `ClientPolicyEvent`.,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7150,440473394,2020-06-15T22:06:10Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -432,21 +436,19 @@             }              var baseUrl;-            if (options && options.action == 'register') {+            if (options && options.action === 'register') {                 baseUrl = kc.endpoints.register();             } else {                 baseUrl = kc.endpoints.authorize();             } -            var scope;-            if (options && options.scope) {-                if (options.scope.indexOf(""openid"") != -1) {-                    scope = options.scope;-                } else {-                    scope = ""openid "" + options.scope;-                }-            } else {+            var scope = options && options.scope || kc.scope || config.scope;",we check the scope parameter for:- `options` are the login options- `kc.scope` potentially derived from `keycloak.json`- `config.scope` the explicit keycloak configuration.,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7150,440474777,2020-06-15T22:09:45Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -432,21 +436,19 @@             }              var baseUrl;-            if (options && options.action == 'register') {+            if (options && options.action === 'register') {                 baseUrl = kc.endpoints.register();             } else {                 baseUrl = kc.endpoints.authorize();             } -            var scope;-            if (options && options.scope) {-                if (options.scope.indexOf(""openid"") != -1) {-                    scope = options.scope;-                } else {-                    scope = ""openid "" + options.scope;-                }-            } else {+            var scope = options && options.scope || kc.scope || config.scope;","It would be much better IMHO to create a dedicated config object from `keycloak.json` instead of ""parking"" the configuration in the `kc` keycloak instance, but this would require a larger refactoring...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7080,440738040,2020-06-16T10:08:28Z,services/src/main/java/org/keycloak/theme/FreeMarkerUtil.java,"@@ -73,8 +73,8 @@ public String processTemplate(Object data, String templateName, Theme theme) thr     }      private Template getTemplate(String templateName, Theme theme) throws IOException {-        Configuration cfg = new Configuration();-        +        Configuration cfg = new Configuration(Configuration.VERSION_2_3_26);","Just an idea, but will it help to use the ""wrapper"" object, which has the methods getX/setX overriden? I can imagine some change like this:```-  freemarkerContextAttributes.put(""user"", userModel);+ UserModelDelegate wrapper = new UserModelDelegate(userModel);+ freemarkerContextAttributes.put(""user"", wrapper);```Can it help?If not, is it the possibility to have some other Wrapper class similar to for example org.keycloak.forms.login.freemarker.model.ProfileBean ?If nothing of those helps (or it becomes unecessary complex and ugly code), if you have an opportunity to add the details what exactly the error is and where it happens, it will be helpful. Hopefully we can figure something.The set of version in the Configuration may work as the last possibility, but will be nice to avoid since we are not 100% sure of all the possible side-effects.",
31658331,Martin-Idel-SI,https://api.github.com/repos/keycloak/keycloak/pulls/7080,440833763,2020-06-16T13:06:21Z,services/src/main/java/org/keycloak/theme/FreeMarkerUtil.java,"@@ -73,8 +73,8 @@ public String processTemplate(Object data, String templateName, Theme theme) thr     }      private Template getTemplate(String templateName, Theme theme) throws IOException {-        Configuration cfg = new Configuration();-        +        Configuration cfg = new Configuration(Configuration.VERSION_2_3_26);","I'm sure we'll figure something out!The problem is actually very simple: I found it first in the `resource-detail.ftl`. The corresponding `AuthorizationBean` contains permissions which contain a `RequesterBean` which contains a `UserModel` (the requester). Now, without this change, the ftl-template cannot be rendered correctly, because `permission.requester.username` is null in this line: https://github.com/keycloak/keycloak/blob/3d5e9760977ac84f627abe28a2df91dd860c13ff/themes/src/main/resources/theme/base/account/resource-detail.ftl#L121 And the reason it's null is because this refers to the method `getUsername` on the `UserModel`- but it doesn't exist for FTL as default methods don't exist for without this change (this is due to the JavaBean specification which doesn't understand default methods).Now, clearly that's just one instance of where this fails as the UserModel is also present in other beans. Also, since get/setUsername are not default implemented anymore this particular issue will not arise anymore, but the same problem will be whenever we need get/setEmail or firstName, lastName.So for me, there would be several solutions to this:- directly grab the attribute of the user in the FTL templates via something like `permission.requester.attributes[""username""][0]` or similar. This is not very nice and very error prone as I don't see a good way to find all instances where this could be a problem. Also, this breaks custom templates.- Add the configuration option as above: least intrusive from a code perspective which is why I proposed this change first, but may have unwanted side-effects. I've never really worked with FTL, so I can't say much about it- Remove the default methods and just implement them on all subclasses. Since we do essentially the same for `getUsername` it seems those subclasses aren't too many due to the hierarchy of subclasses.- Add a wrapper object to all places where UserModel is used in the beans. Sounds weird and error prone and results in quite a few changes- Add an abstract subclass of UserModel and derive all classes that don't override the default methods from this subclass: I don't particularly like to add yet another level to the hierarchy, it's already quite deep- Make UserModel an abstract class instead of an interface (I haven't tested it though): This should also work, but may not be nice from an architectural standpoint.I'm probably going to try out the third option. This leads to some code duplication, but the code changes are easiest to get right, so maybe that's the best way to go?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7150,441047903,2020-06-16T18:13:51Z,adapters/oidc/js/src/main/resources/keycloak.d.ts,"@@ -49,9 +49,22 @@ declare namespace Keycloak { 		 * Client identifier, example: 'myapp' 		 */ 		clientId: string;++		/**+		 * Scope to use for the 'scope' login url parameter.+		 * The scope 'openid' will be added to the scope if it is missing or undefined.+		 */+		scope?: string;","Do we need the scope parameter in both `KeycloakConfig` and `KeycloakInitOptions`? `KeycloakConfig` is an equivalent of `AdapterConfig` class for Java adapters and it contains no scope parameter, so I would prefer to remove it, WDYT?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6667,441131382,2020-06-16T20:45:35Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -107,7 +109,20 @@ public UsersResource(RealmModel realm, AdminPermissionEvaluator auth, AdminEvent     @POST     @Consumes(MediaType.APPLICATION_JSON)     public Response createUser(final UserRepresentation rep) {-        auth.users().requireManage();","I did not catch this before, but I think we should first try to check `requireManage` and only in case we get an exception (lacking permission) we fallback to your changes that rely on the fine-grained permission.The reason behind this comment is that we avoid people not using fine-grained permissions to not be impacted by the additional checks you are adding.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7146,441299546,2020-06-17T06:03:07Z,services/src/main/java/org/keycloak/protocol/oidc/utils/RedirectUtils.java,"@@ -195,4 +196,27 @@ private static String getSingleValidRedirectUri(Collection<String> validRedirect         }         return validRedirect;     }++    public static String getValidRedirectUriWithRootUrl(ClientModel client) {+        return (client != null) ? getValidRedirectUriWithRootUrl(client.getRootUrl(), client.getRedirectUris()) : null;+    }++    public static String getValidRedirectUriWithRootUrl(String rootUrl, Collection<String> redirectUris) {","I see there is existing method `RedirectUtils.resolveValidRedirects(KeycloakSession session, String rootUrl, Set<String> validRedirects) ` , which seems to already quite similar thing you introduced here? Will it be possible to use the existing method as much as possible to avoid some duplicated code logic? ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7080,441316567,2020-06-17T06:47:08Z,services/src/main/java/org/keycloak/theme/FreeMarkerUtil.java,"@@ -73,8 +73,8 @@ public String processTemplate(Object data, String templateName, Theme theme) thr     }      private Template getTemplate(String templateName, Theme theme) throws IOException {-        Configuration cfg = new Configuration();-        +        Configuration cfg = new Configuration(Configuration.VERSION_2_3_26);","As I pointed, if there is some easy way to address this like for example using this in the AuthorizationBean constructor: `this.user = new UserModelDelegate(user);`, it will be fine to me.The solution with adding to subclasses however works for me as well.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7150,441319913,2020-06-17T06:54:27Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/javascript/JavascriptAdapterTest.java,"@@ -400,6 +398,58 @@ public void loginRequiredAction() {                 .init(defaultArguments(), this::assertSuccessfullyLoggedIn);     } +    /**+     * Test for scope handling via {@code initOptions}: <pre>{@code+     * Keycloak keycloak = new Keycloak(); keycloak.init({.... scope: ""profile email phone""})+     * }</pre>+     * See KEYCLOAK-14412+     */+    @Test+    public void testScopeInInitOptionsShouldBeConsideredByLoginUrl() {++        JSObjectBuilder initOptions = defaultArguments()+                .loginRequiredOnLoad()+                // phone is optional client scope+                .add(""scope"", ""profile email phone"");++        try {+            testExecutor.init(initOptions);+            // This throws exception because when JavascriptExecutor waits for AsyncScript to finish+            // it is redirected to login page and executor gets no response++            throw new RuntimeException(""Probably the login-required OnLoad mode doesn't work, because testExecutor should fail with error that page was redirected."");+        } catch (WebDriverException ex) {+            // should happen+        }++        testExecutor.loginForm(testUser, this::assertOnTestAppUrl)+                .init(initOptions, this::assertSuccessfullyLoggedIn)+        .executeScript(""return window.keycloak.tokenParsed.scope"", assertOutputContains(""phone""));+    }++    /**+     * Test for scope handling via {@code loginOptions}: <pre>{@code+     * Keycloak keycloak = new Keycloak(); keycloak.login({.... scope: ""profile email phone""})+     * }</pre>+     * See KEYCLOAK-14412+     */+    @Test+    public void testScopeInLoginOptionsShouldBeConsideredByLoginUrl() {++        try {+            testExecutor.configure()+                        .init(defaultArguments());+        } catch (WebDriverException ex) {+            // should happen+        }++        JSObjectBuilder loginOptions = JSObjectBuilder.create().add(""scope"", ""profile email phone"");++        testExecutor.login(loginOptions.build(), (JavascriptStateValidator) (driver, output, events) -> {+            assertThat(jsDriver.getCurrentUrl(), containsString(""&scope=openid%20profile%20email%20phone""));","The JavascriptAdapter tests are a little bit confusing in this. They are mixing two variable names `driver` and `jsDriver`. Out testsuite has two browsers because JS adapter doesn't work in Htmlunit, which is the default browser for majority of tests (it is default because it is fast). So we added `jsDriver` as the second browser, which defaults to Phantomjs. This browser is able to work with JS adapter. Now the `JavascriptStateValidator` is there for checking the state after some Javascript piece of code was executed. It has three parameters `(driver, output, events)`. At the moment, the `driver` parameter is maybe a little bit redundant here as we always use `jsDriver`, but this can change in the future. So it would be better to use it here like this:```suggestion            assertThat(driver.getCurrentUrl(), containsString(""&scope=openid%20profile%20email%20phone""));```this way you use a webdriver provided by testExecutor and function (in this case `login()`) can decide what browser to use for validating the condition.One more thing, you don't need to use the `testExecutor` for everything, the `jsDriver` (do not use `driver` outside of) is available even outside of testExecutor and it is perfectly ok to use it.",
61687012,Aboullos,https://api.github.com/repos/keycloak/keycloak/pulls/7114,441405449,2020-06-17T09:20:17Z,themes/src/main/resources-community/theme/base/account/messages/messages_es.properties,"@@ -133,6 +187,9 @@ federatedIdentityLinkNotActiveMessage=Esta identidad ya no est\u00E1 activa federatedIdentityRemovingLastProviderMessage=No puedes eliminar la \u00FAltima identidad federada porque no tienes fijada una contrase\u00F1a. identityProviderRedirectErrorMessage=Error en la redirecci\u00F3n al proveedor de identidad identityProviderRemovedMessage=Proveedor de identidad borrado correctamente.+identityProviderAlreadyLinkedMessage=La identidad devuelta por el proveedor de identidad ya est\u00E1 asociada a otro usuario.","Here I think it should use the parameter slot {0} as in the English version:""La identidad devuelta por {0} ya est\u00E1 asociada a otro usuario.""",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,441436598,2020-06-17T10:11:09Z,server-spi-private/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionProvider.java,"@@ -0,0 +1,47 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import org.keycloak.provider.Provider;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.clientpolicy.ClientPolicyException;++/**+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this condition to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyConditionProvider extends Provider {++    final String SKIP_EVALUATION = ""skip-evaluation"";",What's the purpose of ClientPolicyException with `skip-evaluation` error? Shouldn't a condition just return `true` rather than throw an exception with `skip-evaluation`?,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,441442272,2020-06-17T10:21:27Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor.impl;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientUpdateContext;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;++public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutorProvider {","I would rename this to something like `AbstractAugumentingClientRegistrationPolicyExecutor`. This is not really an abstract client policy executor, but rather a specific type of client policy exectuor.I'd also move the IS_AUGMENT field from `ClientPolicyExecutorProviderFactory` and move it to this class, then add the logic `if (Boolean.valueOf(componentModel.getConfig().getFirst(ClientPolicyExecutorProviderFactory.IS_AUGMENT)))` here instead of requiring the implementing classes to do that.Finally I would also add the augument config property options to this class, so sub-classes don't have to add it. If they just want to add something they can do something like:    getConfigProperties() {        List<ProviderConfigProperty l = super.getConfigProperties();        l.add(...)    } ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,441450859,2020-06-17T10:37:52Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/TestPKCEEnforceExecutorFactory.java,"@@ -0,0 +1,70 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor.impl;++import java.util.Arrays;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;++public class TestPKCEEnforceExecutorFactory implements ClientPolicyExecutorProviderFactory {++    public static final String PROVIDER_ID = ""test-pkce-enforce-executor"";","`pkce-enforce` and drop `Test` from class name, see previous comment for details",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/7167,441671696,2020-06-17T16:25:22Z,adapters/oidc/js/src/main/resources/keycloak.d.ts,"@@ -215,6 +215,8 @@ declare namespace Keycloak { 		redirectUri?: string; 	} +	interface KeycloakRegisterOptions extends Omit<KeycloakLoginOptions, 'action'> { }","It might be valid, but in code we never use the `action` property for any registration related methods. If anyone is passing in this parameter, or any other parameter not in the interface for that matter it will rightly produce an exception during compilation of TypeScript code.The question is, is that really a breaking change? It does not affect any code running in production, rather only projects taking advantage of TypeScript where the author makes a conscious decision to update this specific dependency and build a new version of their application.I think it's good to be explicit about what is present and used and what is not to avoid confusion, and I think that others using TypeScript would want to have the same behaviour.That said, if we do want to keep scope around we might as well use `KeycloakLoginOptions` directly as the `action` property is already optional there.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7167,441781608,2020-06-17T19:25:37Z,adapters/oidc/js/src/main/resources/keycloak.d.ts,"@@ -215,6 +215,8 @@ declare namespace Keycloak { 		redirectUri?: string; 	} +	interface KeycloakRegisterOptions extends Omit<KeycloakLoginOptions, 'action'> { }",I do think it really is a breaking change.But I can buy the argument that we should discourage anyone from passing in the `action` property anyway.  So maybe that's not such a bad thing.I'll approve as-is.,X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7064,441810650,2020-06-17T20:22:21Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java,"@@ -945,6 +976,56 @@ protected Response exchangeClientToClient(UserModel targetUser, UserSessionModel         return cors.builder(Response.ok(res, MediaType.APPLICATION_JSON_TYPE)).build();     } +    protected Response exchangeClientToSAML2Client(UserModel targetUser, UserSessionModel targetUserSession, String requestedTokenType,+                                                  ClientModel targetClient, String audience, String scope) {+        // Create authSession with target SAML 2.0 client and authenticated user+        LoginProtocolFactory factory = (LoginProtocolFactory) session.getKeycloakSessionFactory()+                .getProviderFactory(LoginProtocol.class, SamlProtocol.LOGIN_PROTOCOL);+        SamlService samlService = (SamlService) factory.createProtocolEndpoint(realm, event);+        ResteasyProviderFactory.getInstance().injectProperties(samlService);+        AuthenticationSessionModel authSession = samlService.getOrCreateLoginSessionForIdpInitiatedSso(session, realm,+                targetClient, null);+        if (authSession == null) {+            logger.error(""SAML assertion consumer url not set up"");+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, ""Client requires assertion consumer url set up"", Response.Status.BAD_REQUEST);+        }++        authSession.setAuthenticatedUser(targetUser);++        event.session(targetUserSession);++        AuthenticationManager.setClientScopesInSession(authSession);+        ClientSessionContext clientSessionCtx = TokenManager.attachAuthenticationSession(this.session, targetUserSession,+                authSession);++        updateUserSessionFromClientAuth(targetUserSession);++        // Create SAML 2.0 Assertion Response+        SamlClient samlClient = new SamlClient(targetClient);+        SamlProtocol samlProtocol = new TokenExchangeSamlProtocol(samlClient).setEventBuilder(event).setHttpHeaders(headers).setRealm(realm)+                .setSession(session).setUriInfo(session.getContext().getUri());++        Response samlAssertion = samlProtocol.authenticated(authSession, targetUserSession, clientSessionCtx);+        if (samlAssertion.getStatus() != 200) {+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, ""Can not get SAML 2.0 token"", Response.Status.BAD_REQUEST);+        }+        String xmlString = (String) samlAssertion.getEntity();+        String encodedXML = Base64Url.encode(xmlString.getBytes(GeneralConstants.SAML_CHARSET));++        int assertionLifespan = samlClient.getAssertionLifespan();++        AccessTokenResponse res = new AccessTokenResponse();",Could you include `issued_token_type` and set it to `urn:ietf:params:oauth:token-type:saml2`. See https://tools.ietf.org/id/draft-ietf-oauth-token-exchange-19.html#rfc.section.3.I guess that would mean creating a `TokenExchangeResponse` extending `AccessTokenResponse` ? Reason being that we use that new class only for token exchange and don't touch the oauth2 part. Also easier to support additional parameters in the future that could be specific of exchange.,
11720274,julian-berbel,https://api.github.com/repos/keycloak/keycloak/pulls/7114,441900308,2020-06-18T00:14:58Z,themes/src/main/resources-community/theme/base/login/messages/messages_es.properties,"@@ -34,10 +37,16 @@ emailForgotTitle=\u00BFHas olvidado tu contrase\u00F1a? updatePasswordTitle=Modificaci\u00F3n de contrase\u00F1a codeSuccessTitle=C\u00F3digo de \u00E9xito codeErrorTitle=C\u00F3digo de error: {0}+displayUnsupported=No se admite el tipo de visualizaci\u00F3n solicitado+browserRequired=Se requiere un navegador para el inicio de sesi\u00F3n+browserContinue=Se requiere un navegador para completar el inicio de sesi\u00F3n+browserContinuePrompt=\u00BFAbrir el navegador y continuar  el inicio de sesi\u00F3n? [y/n]:","Agreed, as long as those are valid inputs :laughing: ",
28739,wadahiro,https://api.github.com/repos/keycloak/keycloak/pulls/7064,442055874,2020-06-18T08:26:49Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java,"@@ -945,6 +976,56 @@ protected Response exchangeClientToClient(UserModel targetUser, UserSessionModel         return cors.builder(Response.ok(res, MediaType.APPLICATION_JSON_TYPE)).build();     } +    protected Response exchangeClientToSAML2Client(UserModel targetUser, UserSessionModel targetUserSession, String requestedTokenType,+                                                  ClientModel targetClient, String audience, String scope) {+        // Create authSession with target SAML 2.0 client and authenticated user+        LoginProtocolFactory factory = (LoginProtocolFactory) session.getKeycloakSessionFactory()+                .getProviderFactory(LoginProtocol.class, SamlProtocol.LOGIN_PROTOCOL);+        SamlService samlService = (SamlService) factory.createProtocolEndpoint(realm, event);+        ResteasyProviderFactory.getInstance().injectProperties(samlService);+        AuthenticationSessionModel authSession = samlService.getOrCreateLoginSessionForIdpInitiatedSso(session, realm,+                targetClient, null);+        if (authSession == null) {+            logger.error(""SAML assertion consumer url not set up"");+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, ""Client requires assertion consumer url set up"", Response.Status.BAD_REQUEST);+        }++        authSession.setAuthenticatedUser(targetUser);++        event.session(targetUserSession);++        AuthenticationManager.setClientScopesInSession(authSession);+        ClientSessionContext clientSessionCtx = TokenManager.attachAuthenticationSession(this.session, targetUserSession,+                authSession);++        updateUserSessionFromClientAuth(targetUserSession);++        // Create SAML 2.0 Assertion Response+        SamlClient samlClient = new SamlClient(targetClient);+        SamlProtocol samlProtocol = new TokenExchangeSamlProtocol(samlClient).setEventBuilder(event).setHttpHeaders(headers).setRealm(realm)+                .setSession(session).setUriInfo(session.getContext().getUri());++        Response samlAssertion = samlProtocol.authenticated(authSession, targetUserSession, clientSessionCtx);+        if (samlAssertion.getStatus() != 200) {+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, ""Can not get SAML 2.0 token"", Response.Status.BAD_REQUEST);+        }+        String xmlString = (String) samlAssertion.getEntity();+        String encodedXML = Base64Url.encode(xmlString.getBytes(GeneralConstants.SAML_CHARSET));++        int assertionLifespan = samlClient.getAssertionLifespan();++        AccessTokenResponse res = new AccessTokenResponse();","@pedroigor > Could you include issued_token_type and set it to `urn:ietf:params:oauth:token-type:saml2`It's already included in the following code through `AccessTokenResponse#setOtherClaims` method:https://github.com/keycloak/keycloak/pull/7064/files#diff-ec5f9626f53934cdc3ad494e198f1902R1021But there is no assertion in the test code. I'll add the assertion.> I guess that would mean creating a `TokenExchangeResponse` extending `AccessTokenResponse`- Create `TokenExchangeResponse` extending `AccessTokenResponse` as new class- Add `issuedTokenType` field and set/get method into the new class- Fix the existing token exchange code for OIDC client and external clients (implementation of `ExchangeTokenToIdentityProviderToken`)to use the new response classIs the above fix OK?Also, I noticed the current token exchange code doesn't follow the spec.- Exchange for OIDC client doesn't include `issued_token_type` claim.- Refresh token for OIDC client isn't stored in `access_token` claim when `requested_token_type` is refresh token type. https://github.com/keycloak/keycloak/blob/6dde131609551621eba102d71c5897a350d7ce64/services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java#L930-L933- ID token is issued by the `scope` parameter. Should we issue the id token when `requested_token_type` is id token type?https://github.com/keycloak/keycloak/blob/6dde131609551621eba102d71c5897a350d7ce64/services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java#L935-L938- ID token for external client isn't stored in `access_token` claim when `requested_token_type` is id token type. https://github.com/keycloak/keycloak/blob/7efaf9869acbb328f9dd8b159460cec7de6bc010/services/src/main/java/org/keycloak/broker/oidc/AbstractOAuth2IdentityProvider.java#L225-L230Should I fix those issues in this pull request too?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7176,442080174,2020-06-18T09:05:32Z,services/src/test/java/org/keycloak/vault/PlainTextVaultProviderFactoryTest.java,"@@ -70,6 +91,1258 @@ public void shouldReturnNullWhenWithNullDirectory() {     }      /**+     * A whitebox implementation of the Realm model, which is needed to extract realm name.+     * Please use only for testing {@link FilesPlainTextVaultProviderFactory}.+     */+    private static class VaultRealmModel implements RealmModel {","Remove changes to RealmModel as this is not needed, then revert this class as well",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7176,442082140,2020-06-18T09:08:34Z,themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -533,3 +533,8 @@ form#kc-select-back-form div.login-pf-social-section {     padding-left: 0px;     border-left: 0px; }++.delete-account-text {+    font-size: large;+    font-weight: 600;+}",Remove this and use btn-danger class on button instead,X
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7177,442111393,2020-06-18T09:58:33Z,adapters/oidc/js/src/main/resources/login-status-iframe.html,"@@ -54,7 +54,11 @@                         }                         if (!cookie) {                             if (sessionState != '') {-                                callback('changed');+                                // Adapter was authenticated (session ID exists) but session cookie is not found.+                                // Either user was logged out shortly after authentication but before this iframe could be+                                // loaded (usually just a few seconds), which is really a corner case, or 3rd part cookies+                                // are blocked which is the most probable scenario.+                                callback('cookie_not_found');","@stianst I was thinking the same first, but then I realised this piece of code is visited only on the first iframe call. Every other call already has the `init` object/variable created so it will end up here: https://github.com/keycloak/keycloak/blob/master/adapters/oidc/js/src/main/resources/login-status-iframe.html#L71I can't see any other way how to find out whether 3rd party cookies are blocked. WDYT?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7177,442172819,2020-06-18T11:59:47Z,adapters/oidc/js/src/main/resources/login-status-iframe.html,"@@ -54,7 +54,11 @@                         }                         if (!cookie) {                             if (sessionState != '') {-                                callback('changed');+                                // Adapter was authenticated (session ID exists) but session cookie is not found.+                                // Either user was logged out shortly after authentication but before this iframe could be+                                // loaded (usually just a few seconds), which is really a corner case, or 3rd part cookies+                                // are blocked which is the most probable scenario.+                                callback('cookie_not_found');","Thanks for pointing this out. jFTR, with @stianst we were discussing changing the callback here to `unchanged`. But this brings other problems.The main problem is how to tell the adapter that iframe doesn't work. So as I see it, we've got following options.**Option 1*** Fully comply with specs, i.e. return `unchanged`.* Adapter doesn't know that iframe is not working.* Standard check-sso (the one without iframe, not the silent one) won't work:https://github.com/keycloak/keycloak/blob/ec9bf6206e3d937a974ac84b9618c00823edc884/adapters/oidc/js/src/main/resources/keycloak.js#L283-L288This will have to be reworked not to rely on iframe at all.A redirect to KC would always be performed even if the user is not logged in. Regardless if iframe is enabled or not because we can't know if it works or not.* Initialization with token also won't work as before:https://github.com/keycloak/keycloak/blob/ec9bf6206e3d937a974ac84b9618c00823edc884/adapters/oidc/js/src/main/resources/keycloak.js#L319-L331The token won't be checked.* Silent check-sso cannot work and user will always have to invoke login manually.**Option 2*** Hybrid solution: fully comply with the specs by default, but our JS adapter would use a special ""mode"" of the login iframe so that it would use `cookie_not_found` in the callback.* Everything would work as before, except obviously the silent check-sso and single logout.",
31658331,Martin-Idel-SI,https://api.github.com/repos/keycloak/keycloak/pulls/7080,442444224,2020-06-18T19:10:55Z,services/src/main/java/org/keycloak/theme/FreeMarkerUtil.java,"@@ -73,8 +73,8 @@ public String processTemplate(Object data, String templateName, Theme theme) thr     }      private Template getTemplate(String templateName, Theme theme) throws IOException {-        Configuration cfg = new Configuration();-        +        Configuration cfg = new Configuration(Configuration.VERSION_2_3_26);","I ended up adding subclasses - please have a look. I feel that this approach is the safest, as everything looks as before for FTL templates.All tests already ran beforehand since the only test failure I saw was actually related to the username field and I had already removed the default methods before. I tried using wrapper objects but was left unsatisfied whether I actually solved all problems and if somebody uses custom FTL files, those could easily break if I overlook something. I could add a comment to the wrapper class (and the one set of duplicate methods in the infinispan/UserAdapter) to move to default methods once this is no longer a problem in FTL (maybe you will make a switch to a newer version for different reasons).",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7097,442657932,2020-06-19T06:38:02Z,services/src/main/java/org/keycloak/services/resources/admin/RoleContainerResource.java,"@@ -148,6 +151,38 @@ public Response createRole(final RoleRepresentation rep) {                 adminEvent.resource(ResourceType.REALM_ROLE);             } +            // Handling of nested composite roles for KEYCLOAK-12754+            if (rep.isComposite() && rep.getComposites() != null) {+                RoleRepresentation.Composites composites = rep.getComposites();++                Set<String> compositeRealmRoles = composites.getRealm();+                if (compositeRealmRoles != null && !compositeRealmRoles.isEmpty()) {+                    Set<RoleModel> realmRoles = compositeRealmRoles.stream()+                            .map(realm::getRole)+                            .filter(Objects::nonNull)","I wonder if there should be some validation that all the composite roles actually exist. Would it make sense to fail the operation if a role was not found, not just ignore it? (This applies for client roles below as well.) We do that for the composite endpoint:https://github.com/keycloak/keycloak/blob/6f2ca347e164ecd141eac633ac4577b5768c9d01/services/src/main/java/org/keycloak/services/resources/admin/RoleContainerResource.java#L286-L288On the other hand, we lack validation on most endpoints in general, so...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6900,442724294,2020-06-19T09:11:05Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProviderFactory.java,"@@ -247,7 +248,7 @@ protected void checkRemoteCaches(KeycloakSession session) {         Cache<String, SessionEntityWrapper<UserSessionEntity>> sessionsCache = ispn.getCache(InfinispanConnectionProvider.USER_SESSION_CACHE_NAME);         boolean sessionsRemoteCache = checkRemoteCache(session, sessionsCache, (RealmModel realm) -> {             // We won't write to the remoteCache during token refresh, so the timeout needs to be longer.-            return realm.getSsoSessionMaxLifespan() * 1000;+            return Time.currentTimeMillis() + (realm.getSsoSessionMaxLifespan() * 1000L);","I don't think that adding ""Time.currentTimeMillis()"" is correct here?This is idle timeout. Hence if ""Time.currentTimeMillis"" is added, it means the expiration won't be around 10 hours (as default SSO session max lifespan), but around 40+ years (Time since 1 Jan 1970).When you use something like `(1000L * realm.getSsoSessionMaxLifespan()`, it should do the trick with retype to long though?This applies for all the other places in this PR.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7021,442779968,2020-06-19T11:11:18Z,services/src/main/java/org/keycloak/social/github/GitHubIdentityProvider.java,"@@ -35,18 +35,79 @@  */ public class GitHubIdentityProvider extends AbstractOAuth2IdentityProvider implements SocialIdentityProvider { -	public static final String AUTH_URL = ""https://github.com/login/oauth/authorize"";-	public static final String TOKEN_URL = ""https://github.com/login/oauth/access_token"";-	public static final String PROFILE_URL = ""https://api.github.com/user"";-	public static final String EMAIL_URL = ""https://api.github.com/user/emails"";-	public static final String DEFAULT_SCOPE = ""user:email"";--	public GitHubIdentityProvider(KeycloakSession session, OAuth2IdentityProviderConfig config) {-		super(session, config);-		config.setAuthorizationUrl(AUTH_URL);-		config.setTokenUrl(TOKEN_URL);-		config.setUserInfoUrl(PROFILE_URL);-	}+    public static final String DEFAULT_BASE_URL = ""https://github.com"";+    public static final String AUTH_FRAGMENT = ""/login/oauth/authorize"";+    public static final String TOKEN_FRAGMENT = ""/login/oauth/access_token"";+    public static final String DEFAULT_AUTH_URL = DEFAULT_BASE_URL + AUTH_FRAGMENT;+    public static final String DEFAULT_TOKEN_URL = DEFAULT_BASE_URL + TOKEN_FRAGMENT;+    /** @deprecated Use {@link #DEFAULT_AUTH_URL} instead. */+    @Deprecated+    public static final String AUTH_URL = DEFAULT_AUTH_URL;+    /** @deprecated Use {@link #DEFAULT_TOKEN_URL} instead. */+    @Deprecated+    public static final String TOKEN_URL = DEFAULT_TOKEN_URL;",Do we really need this if it's deprecated? My IDE tells me it's not used anywhere.,X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7021,442779990,2020-06-19T11:11:23Z,services/src/main/java/org/keycloak/social/github/GitHubIdentityProvider.java,"@@ -35,18 +35,79 @@  */ public class GitHubIdentityProvider extends AbstractOAuth2IdentityProvider implements SocialIdentityProvider { -	public static final String AUTH_URL = ""https://github.com/login/oauth/authorize"";-	public static final String TOKEN_URL = ""https://github.com/login/oauth/access_token"";-	public static final String PROFILE_URL = ""https://api.github.com/user"";-	public static final String EMAIL_URL = ""https://api.github.com/user/emails"";-	public static final String DEFAULT_SCOPE = ""user:email"";--	public GitHubIdentityProvider(KeycloakSession session, OAuth2IdentityProviderConfig config) {-		super(session, config);-		config.setAuthorizationUrl(AUTH_URL);-		config.setTokenUrl(TOKEN_URL);-		config.setUserInfoUrl(PROFILE_URL);-	}+    public static final String DEFAULT_BASE_URL = ""https://github.com"";+    public static final String AUTH_FRAGMENT = ""/login/oauth/authorize"";+    public static final String TOKEN_FRAGMENT = ""/login/oauth/access_token"";+    public static final String DEFAULT_AUTH_URL = DEFAULT_BASE_URL + AUTH_FRAGMENT;+    public static final String DEFAULT_TOKEN_URL = DEFAULT_BASE_URL + TOKEN_FRAGMENT;+    /** @deprecated Use {@link #DEFAULT_AUTH_URL} instead. */+    @Deprecated+    public static final String AUTH_URL = DEFAULT_AUTH_URL;+    /** @deprecated Use {@link #DEFAULT_TOKEN_URL} instead. */+    @Deprecated+    public static final String TOKEN_URL = DEFAULT_TOKEN_URL;++    public static final String DEFAULT_API_URL = ""https://api.github.com"";+    public static final String PROFILE_FRAGMENT = ""/user"";+    public static final String EMAIL_FRAGMENT = ""/user/emails"";+    public static final String DEFAULT_PROFILE_URL = DEFAULT_API_URL + PROFILE_FRAGMENT;+    public static final String DEFAULT_EMAIL_URL = DEFAULT_API_URL + EMAIL_FRAGMENT;+    /** @deprecated Use {@link #DEFAULT_PROFILE_URL} instead. */+    @Deprecated+    public static final String PROFILE_URL = DEFAULT_PROFILE_URL;+    /** @deprecated Use {@link #DEFAULT_EMAIL_URL} instead. */+    @Deprecated+    public static final String EMAIL_URL = DEFAULT_EMAIL_URL;",Do we really need this if it's deprecated? My IDE tells me it's not used anywhere.,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,442817151,2020-06-19T12:41:26Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestAuthnMethodsConditionFactory.java,"@@ -0,0 +1,85 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition.impl;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;++public class TestAuthnMethodsConditionFactory implements ClientPolicyConditionProviderFactory {++    public static final String PROVIDER_ID = ""test-authnmethods-condition"";","Having `Test` prefix on class name is confusing to me. At first I was thinking this had to do with testing.Another thing is classes being in `impl` package, this is not a convention we use in Keycloak codebase elsewhere.PROVIDER_ID should just be ""authnmethods"". I find ""Test"" confusing and ""condition"" is already implied as it's ""authnmethods"" of ""client-policy-condition"" SPI.",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,442818064,2020-06-19T12:43:24Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestClientRolesConditionFactory.java,"@@ -0,0 +1,77 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition.impl;++import java.util.ArrayList;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;++public class TestClientRolesConditionFactory implements ClientPolicyConditionProviderFactory {++    public static final String PROVIDER_ID = ""test-clientroles-condition"";","I'd just use `clientroles` and drop `Test` from class-name, see previous comment for more details",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,442818385,2020-06-19T12:44:05Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/TestClientAuthenticationExecutorFactory.java,"@@ -0,0 +1,78 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor.impl;++import java.util.Arrays;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;++public class TestClientAuthenticationExecutorFactory implements ClientPolicyExecutorProviderFactory {++    public static final String PROVIDER_ID = ""test-client-authn-executor"";",`client-authn` and drop `Test` from class name. See previous comment for more details,
31658331,Martin-Idel-SI,https://api.github.com/repos/keycloak/keycloak/pulls/7080,442842747,2020-06-19T13:32:54Z,services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpReviewProfileAuthenticator.java,"@@ -46,6 +46,10 @@ public class IdpReviewProfileAuthenticator extends AbstractIdpAuthenticator {      private static final Logger logger = Logger.getLogger(IdpReviewProfileAuthenticator.class);+    private static final String FIRST_NAME = ""lastName"";","Yes, since we didn't rename anything in the end, we can just remove the changes (Done).They were made originally because the form data fields are independent of the UserModel field names (or at least it seemed that way). I still think that maybe you'd want to have independent constants because those two areas could change independently, but it's not necessary, so I reverted the change.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7177,442878262,2020-06-19T14:38:22Z,adapters/oidc/js/src/main/resources/login-status-iframe.html,"@@ -54,7 +54,11 @@                         }                         if (!cookie) {                             if (sessionState != '') {-                                callback('changed');+                                // Adapter was authenticated (session ID exists) but session cookie is not found.+                                // Either user was logged out shortly after authentication but before this iframe could be+                                // loaded (usually just a few seconds), which is really a corner case, or 3rd part cookies+                                // are blocked which is the most probable scenario.+                                callback('cookie_not_found');","Scratch that, option 2 won't work. In case of non-silent check-sso, it wouldn't work. Even if the iframe would return `cookie_not_found`, it wouldn't return it in case of check-sso  it would always return `unchaged` which would make check-sso completely unusable with 3rd party cookies blocked. At the same time, forcing the browser to redirect to KC with `prompt=none` even if cookies aren't blocked is unnecessary overhead, so it's not an option either. That will have to be done only when cookies are blocked.I'll add an explicit and independent check for 3rd party cookies blocking when initializing the iframe, something like: https://github.com/mindmup/3rdpartycookiecheck. This will solve all the issues. Iframe will be still OIDC compliant (actually untouched by this PR) and at the same time automatically disabled if 3rd party cookies are blocked.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7183,443023702,2020-06-19T20:07:11Z,.github/workflows/ci-x.yml,"@@ -51,3 +51,5 @@ jobs:         run: mvn clean install -B -Pquarkus,auth-server-quarkus -DskipTests -f testsuite/pom.xml       - name: Run base tests         run: mvn clean install -B -Pquarkus,auth-server-quarkus -f testsuite/integration-arquillian/tests/base/pom.xml | misc/log/trimmer.sh; exit ${PIPESTATUS[0]}+      - name: Run cluster tests+        run: mvn clean install -B -Pauth-server-cluster-quarkus -Dsession.cache.owners=2 -Dtest=**.cluster.** -f testsuite/integration-arquillian/pom.xml  | misc/log/trimmer.sh; exit",Maybe because you want to run them in parallel. I've changed the workflow as per your comment.,
6265563,zak905,https://api.github.com/repos/keycloak/keycloak/pulls/7176,443146060,2020-06-20T17:19:10Z,themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -533,3 +533,8 @@ form#kc-select-back-form div.login-pf-social-section {     padding-left: 0px;     border-left: 0px; }++.delete-account-text {+    font-size: large;+    font-weight: 600;+}",This style is not meant for the button. It is meant for the paragraph here: https://github.com/keycloak/keycloak/blob/3441357ddfb17fd84ed294a1315d64e5e5c60c21/themes/src/main/resources/theme/base/login/delete-account-confirm.ftl#L16,
4305789,alexandredantas,https://api.github.com/repos/keycloak/keycloak/pulls/6900,443170067,2020-06-21T00:29:55Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProviderFactory.java,"@@ -247,7 +248,7 @@ protected void checkRemoteCaches(KeycloakSession session) {         Cache<String, SessionEntityWrapper<UserSessionEntity>> sessionsCache = ispn.getCache(InfinispanConnectionProvider.USER_SESSION_CACHE_NAME);         boolean sessionsRemoteCache = checkRemoteCache(session, sessionsCache, (RealmModel realm) -> {             // We won't write to the remoteCache during token refresh, so the timeout needs to be longer.-            return realm.getSsoSessionMaxLifespan() * 1000;+            return Time.currentTimeMillis() + (realm.getSsoSessionMaxLifespan() * 1000L);","Hi Marek! No problems :)Actually, when a remote Infinispan cache is set up the model expects an epoch, not a lifespan, this is why adding Time.currentTimeMillis solves the issue. I'm using `org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory` to marshall data from keycloak to hot rod server",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,443268424,2020-06-21T23:43:59Z,server-spi-private/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionProvider.java,"@@ -0,0 +1,47 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import org.keycloak.provider.Provider;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.clientpolicy.ClientPolicyException;++/**+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this condition to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyConditionProvider extends Provider {++    final String SKIP_EVALUATION = ""skip-evaluation"";","Why this exception for notifying skipping the evaluation of the condition is as follows.Assume that-  `ClientPolicyConditionProvider.isSatisfiedOnEvent()` returns true if this condition is not evaluated on the event.- On some event, all conditions of the policy are not evaluated. (e.g. On authorization request, the condition for checking Client App's IP is not possible to be evaluated because the browser is the HTTP Client, not Client App.)- When this event happens, the executors of the policy are executed because all conditions of the policy return trues even these conditions are not evaluated.To avoid this situation, I've explicitly distinguished situations between ""evaluated and satisfied (returns true)"", ""evaluated but not satisfied the condition (returns false)"" and ""not evaluated (throws exception) "".",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,443293282,2020-06-22T02:46:56Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor.impl;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientUpdateContext;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;++public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutorProvider {","I see, I'll revise codes as you mentioned. IMO, `getConfigProperties()` has to be implemented on Factory class so that I'll add `AbstractAugumentingClientRegistrationPolicyExecutorFactory`. WDYT?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,443301604,2020-06-22T03:32:48Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestClientRolesCondition.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition.impl;++import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.impl.ClientPolicyLogger;++public class TestClientRolesCondition implements ClientPolicyConditionProvider {",It is test use only so that I'll move these Test... classes to testsuite-providers project.,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,443303279,2020-06-22T03:42:03Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/TestPKCEEnforceExecutorFactory.java,"@@ -0,0 +1,70 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor.impl;++import java.util.Arrays;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;++public class TestPKCEEnforceExecutorFactory implements ClientPolicyExecutorProviderFactory {++    public static final String PROVIDER_ID = ""test-pkce-enforce-executor"";",It is test use only so that I'll move these Test... classes to testsuite-providers project. I'll support this executor as the sub task defined in [Client Policy - Executor : Enforce Proof Key for Code Exchange (PKCE)](https://issues.redhat.com/browse/KEYCLOAK-14201) afterwards.,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,443349722,2020-06-22T06:52:40Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestAuthnMethodsConditionFactory.java,"@@ -0,0 +1,85 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition.impl;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;++public class TestAuthnMethodsConditionFactory implements ClientPolicyConditionProviderFactory {++    public static final String PROVIDER_ID = ""test-authnmethods-condition"";",It is test use only so that I'll move these Test... classes to testsuite-providers project. I'll support this executor as the sub task defined in [Client Policy - Executor : Enforce more secure client authentication method when client registration](https://issues.redhat.com/browse/KEYCLOAK-14199) afterwards.,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,443351808,2020-06-22T06:57:44Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestClientRolesConditionFactory.java,"@@ -0,0 +1,77 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition.impl;++import java.util.ArrayList;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;++public class TestClientRolesConditionFactory implements ClientPolicyConditionProviderFactory {++    public static final String PROVIDER_ID = ""test-clientroles-condition"";",It is test use only so that I'll move these Test... classes to testsuite-providers project.,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,443352156,2020-06-22T06:58:31Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/TestClientAuthenticationExecutorFactory.java,"@@ -0,0 +1,78 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor.impl;++import java.util.Arrays;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;++public class TestClientAuthenticationExecutorFactory implements ClientPolicyExecutorProviderFactory {++    public static final String PROVIDER_ID = ""test-client-authn-executor"";",It is test use only so that I'll move these Test... classes to testsuite-providers project.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/6900,443427701,2020-06-22T09:22:26Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProviderFactory.java,"@@ -247,7 +248,7 @@ protected void checkRemoteCaches(KeycloakSession session) {         Cache<String, SessionEntityWrapper<UserSessionEntity>> sessionsCache = ispn.getCache(InfinispanConnectionProvider.USER_SESSION_CACHE_NAME);         boolean sessionsRemoteCache = checkRemoteCache(session, sessionsCache, (RealmModel realm) -> {             // We won't write to the remoteCache during token refresh, so the timeout needs to be longer.-            return realm.getSsoSessionMaxLifespan() * 1000;+            return Time.currentTimeMillis() + (realm.getSsoSessionMaxLifespan() * 1000L);","Hi Alexandre,I am not sure how you figured this statement? When looking at the javadoc of method org.infinispan.commons.api.BasicCache and method `put(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit maxIdleTimeUnit)` , it mentions this for the maxIdleTime field: the maximum amount of time this key is allowed to be idle for before it is considered as expired .This is the method, which Keycloak internally calls. So I don't understand why this is supposed to be the epoch? Any more info about this?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7177,443630752,2020-06-22T15:09:49Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/SuiteContext.java,"@@ -58,7 +60,9 @@      * True if the testsuite is running in the adapter backward compatibility testing mode,      * i.e. if the tests are running against newer auth server      */-    private static final boolean adapterCompatTesting = Boolean.parseBoolean(System.getProperty(""testsuite.adapter.compat.testing""));+    private static final boolean adapterCompatTesting = parseBoolean(System.getProperty(""testsuite.adapter.compat.testing""));++    private static final boolean browserStrictCookies = parseBoolean(System.getProperty(""browser.strict.cookies""));","I wouldn't add the suggested comparison to localhost here. The `browserStrictCookies` property just tells us the browser treats cookies in some way and doesn't tell us when they'll be blocked. It's up to the test to know it.Also, when the tests fail without setting proper hosts for server, it's actually correct behavior IMHO. It points out a miscofigured test.But I agree maybe we could add a special Maven profile to set hosts to some precofigured values. But I'm not sure about it if we want to hardcode a 3rd party services directly into POM. IMHO that belongs to the test pipeline.",
4305789,alexandredantas,https://api.github.com/repos/keycloak/keycloak/pulls/6900,443764702,2020-06-22T19:00:41Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProviderFactory.java,"@@ -247,7 +248,7 @@ protected void checkRemoteCaches(KeycloakSession session) {         Cache<String, SessionEntityWrapper<UserSessionEntity>> sessionsCache = ispn.getCache(InfinispanConnectionProvider.USER_SESSION_CACHE_NAME);         boolean sessionsRemoteCache = checkRemoteCache(session, sessionsCache, (RealmModel realm) -> {             // We won't write to the remoteCache during token refresh, so the timeout needs to be longer.-            return realm.getSsoSessionMaxLifespan() * 1000;+            return Time.currentTimeMillis() + (realm.getSsoSessionMaxLifespan() * 1000L);","I've set up my environment as described below:1 - An external Infinispan Hot Rod Server with JDBC store configuration```Configuration persistentCacheConfiguration = new ConfigurationBuilder()                    .memory().size(100).evictionStrategy(EvictionStrategy.REMOVE)                    .persistence().addStore(JdbcStringBasedStoreConfigurationBuilder.class)                    .table()                    .idColumnName(""id"")                    .idColumnType(""varchar(1000)"")                    .dataColumnName(""data"")                    .dataColumnType(""bytea"")                    .timestampColumnName(""expire"")                    .timestampColumnType(""bigint"")                    .dropOnExit(false)                    .createOnStart(true)                    .tableNamePrefix(""ispn"")                    .connectionPool()                    .connectionUrl(cfg.get(""DATABASE_JDBC_URL""))                    .driverClass(cfg.get(""DATABASE_JDBC_DRIVER""))                    .password(cfg.get(""DATABASE_PASSWORD""))                    .username(cfg.get(""DATABASE_USERNAME""))                    .build();            DefaultCacheManager defaultCacheManager = new DefaultCacheManager(                    new GlobalConfigurationBuilder()                            .defaultCacheName(""sessions"")                            .build(), persistentCacheConfiguration);            defaultCacheManager.createCache(""___script_cache"", new ConfigurationBuilder().build());            defaultCacheManager.createCache(""clientSessions"", persistentCacheConfiguration);            defaultCacheManager.createCache(""offlineClientSessions"", persistentCacheConfiguration);            defaultCacheManager.createCache(""offlineSessions"", persistentCacheConfiguration);            defaultCacheManager.createCache(""actionTokens"", persistentCacheConfiguration);            defaultCacheManager.createCache(""loginFailures"", persistentCacheConfiguration);            new HotRodServer().start(new HotRodServerConfigurationBuilder().host(""127.0.0.1"").port(11322).build(),                    defaultCacheManager);```2 - Remote socket configuration```/socket-binding-group=standard-sockets/remote-destination-outbound-socket-binding=remote-cache:add(host=""127.0.0.1"", port=""11322"")```3 - Cache configuration```/subsystem=infinispan/cache-container=keycloak/local-cache=sessions/store=remote:add(cache=""sessions"", remote-servers=[remote-cache], preload=false, purge=false, passivation=false, shared=false, properties={rawValues=true, marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory, protocolVersion=${env.HOTROD_VERSION:2.8}}){allow-resource-service-restart=true}/subsystem=infinispan/cache-container=keycloak/local-cache=clientSessions/store=remote:add(cache=""clientSessions"", remote-servers=[remote-cache], preload=false, purge=false, passivation=false, shared=false, properties={rawValues=true, marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory, protocolVersion=${env.HOTROD_VERSION:2.8}}){allow-resource-service-restart=true}/subsystem=infinispan/cache-container=keycloak/local-cache=offlineClientSessions/store=remote:add(cache=""offlineClientSessions"", remote-servers=[remote-cache], preload=false, purge=false, passivation=false, shared=false, properties={rawValues=true, marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory, protocolVersion=${env.HOTROD_VERSION:2.8}}){allow-resource-service-restart=true}/subsystem=infinispan/cache-container=keycloak/local-cache=offlineSessions/store=remote:add(cache=""offlineSessions"", remote-servers=[remote-cache], preload=false, purge=false, passivation=false, shared=false, properties={rawValues=true, marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory, protocolVersion=${env.HOTROD_VERSION:2.8}}){allow-resource-service-restart=true}/subsystem=infinispan/cache-container=keycloak/local-cache=authenticationSessions/store=remote:add(cache=""authenticationSessions"", remote-servers=[remote-cache], preload=false, purge=false, passivation=false, shared=false, properties={rawValues=true, marshaller=org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory, protocolVersion=${env.HOTROD_VERSION:2.8}}){allow-resource-service-restart=true}```After performing a login on Keycloak, I retrieved some data from database table ispn_clientSessions. There the timestamp field is not a max idle but an epoch.I understand that model written to the database is just a serialization of the cache object, including timestamp definition.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7021,444183735,2020-06-23T12:27:41Z,themes/src/main/resources/theme/base/admin/resources/partials/realm-identity-provider-github-ext.html,"@@ -0,0 +1,18 @@+<fieldset>","I have to say, the UI looks a bit confusing.![Screenshot 2020-06-23 at 14 21 44](https://user-images.githubusercontent.com/13906855/85403028-fe857800-b55c-11ea-8a4d-3fd05a8357dd.png)The ""Override Identity Provider Settings"" looks like it belongs to what's beneath it (Base URL, etc.).Maybe we don't need to hide it at all. It could be visible with some prefix (like ""Enterprise Base URL"" or something like that) and with explaining tooltip that a default value will be used if empty.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7021,444204034,2020-06-23T13:00:42Z,services/src/test/java/org/keycloak/social/github/GitHubIdentityProviderTest.java,"@@ -0,0 +1,73 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.social.github;++import static org.junit.Assert.*;++import org.junit.Test;+import org.keycloak.broker.oidc.OAuth2IdentityProviderConfig;++/**+ * Unit test for {@link org.keycloak.social.github.GitHubIdentityProvider}.+ *+ * @author Neon Ngo+ */+public class GitHubIdentityProviderTest {",I believe we should have an integration test for this as well as we're not running unit tests anywhere. I know we cannot test against a real enterprise instance (or can we? :)) but we could at least try to input some fake values in the Admin Console and try to login and check the browser really fails to load the GitHub login page. This way we'll be sure Admin Console works properly with this new settings (even though we won't test the API endpoints but it's not possible without actually performing login).Could you please add some test like that? You can use [SocialLoginTest](https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/SocialLoginTest.java).,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7198,444399282,2020-06-23T17:44:12Z,themes/src/main/resources-community/theme/base/email/messages/messages_cs.properties,"@@ -0,0 +1,47 @@+# encoding: utf-8+emailVerificationSubject=Oven e-mailu+emailVerificationBody=Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu \n\n{0}\n\nTento odkaz vypr za {1} minuty.\n\nPokud jste tento et nevytvoili, tuto zprvu ignorujte.+emailVerificationBodyHtml=<p>Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu. </p><p><a href=""{0}"">Odkaz na oven e-mailov adresy</a></p><p>Platnost odkazu vypr za {1} minut.</p><p>Pokud jste tento et nevytvoili, tuto zprvu ignorujte.</p>+emailTestSubject=[KEYCLOAK] - testovac zprva+emailTestBody=Toto je testovac zprva+emailTestBodyHtml=<p>Toto je testovac zprva </p>+identityProviderLinkSubject=Odkaz {0}+identityProviderLinkBody=Nkdo chce propojit v et ""{1}"" s tem ""{0}"" uivatele {2}. Pokud jste to vy, kliknte na ne uveden odkaz a propojte ty. \n\n{3}\n\nPlatnost tohoto odkazu je {5}.\n\nPokud nechcete propojit et, tuto zprvu ignorujte. Pokud propojte ty, budete se moci pihlsit jako {1} pomoc {0}.+identityProviderLinkBodyHtml=<p>Nkdo prv podal o zmnu hesla u vaeho tu {2}. Pokud jste to vy, pro jeho zmnu kliknte na odkaz ne.</p><p><a href=""{0}"">Odkaz na zmnu hesla.</a></p><p>Platnost tohoto odkazu je {3}.</p><p>Pokud heslo zmnit nechcete, tuto zprvu ignorujte a nic se nezmn.</p>+passwordResetSubject=Zapomenut heslo+passwordResetBody=Nkdo prv podal o zmnu hesla u vaeho tu {2}. Pokud jste to vy, pro jeho zmnu kliknte na odkaz ne.\n\n{0}\n\nPlatnost tohoto odkazu je {3}.\n\nPokud heslo zmnit nechcete, tuto zprvu ignorujte a nic se nezmn.+passwordResetBodyHtml=<p> Nkdo prv podal o zmnu poven vaeho tu {2}. Pokud jste to vy, kliknte na odkaz ne, abyste je resetovali.</p><p><a href=""{0}"">Odkaz na obnoven poven </a></p><p> Platnost tohoto odkazu vypr bhem {1} minut.</p><p> Pokud nechcete obnovit vae poven, ignorujte tuto zprvu a nic se nezmn.</p>+executeActionsSubject=Aktualizujte svj et+executeActionsBody=V administrtor vs podal o proveden nsledujcch akc u tu {2}: {3}. Zante kliknutm na ne uveden odkaz.\n\n{0}\n\nPlatnost tohoto odkazu je {4}.\n\nPokud si nejste jisti, zda je tento poadavek v podku, ignorujte tuto zprvu.+executeActionsBodyHtml=<p>V administrtor vs podal o proveden nsledujcch akc u tu {2}: {3}. Zante kliknutm na ne uveden odkaz.</p><p><a href=""{0}"">Odkaz na aktualizaci tu.</a></p><p>Platnost tohoto odkazu je {4}.</p><p>Pokud si nejste jisti, zda je tento poadavek v podku, ignorujte tuto zprvu.</p>+eventLoginErrorSubject=Chyba pihlen+eventLoginErrorBody=Nkdo se nespn pokusil pihlsit k tu {0} z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventLoginErrorBodyHtml=<p>Nkdo se nespn pokusil pihlsit k tu {0} z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventRemoveTotpSubject=Odebrat TOTP+eventRemoveTotpBody=V tu {0} bylo odebrno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventRemoveTotpBodyHtml=<p>V tu {0} bylo odebrno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventUpdatePasswordSubject=Aktualizace hesla+eventUpdatePasswordBody=V tu {0} bylo zmnno heslo z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventUpdatePasswordBodyHtml=<p>V tu {0} bylo zmnno heslo z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventUpdateTotpSubject=Aktualizace OTP+eventUpdateTotpBody=V tu {0} bylo zmnno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventUpdateTotpBodyHtml=<p>V tu {0} bylo zmnno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>++requiredAction.CONFIGURE_TOTP=Konfigurace OTP+requiredAction.terms_and_conditions=Smluvn podmnky+requiredAction.UPDATE_PASSWORD=Aktualizace hesla+requiredAction.UPDATE_PROFILE=Aktualizace profilu+requiredAction.VERIFY_EMAIL=Oven e-mailu++# units for link expiration timeout formatting+linkExpirationFormatter.timePeriodUnit.seconds=sekundy","```suggestionlinkExpirationFormatter.timePeriodUnit.seconds=sekund```and alternatives for 2, 3, and 4 (similarly to what you have for _minutes_ below)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7198,444399530,2020-06-23T17:44:40Z,themes/src/main/resources-community/theme/base/email/messages/messages_cs.properties,"@@ -0,0 +1,47 @@+# encoding: utf-8+emailVerificationSubject=Oven e-mailu+emailVerificationBody=Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu \n\n{0}\n\nTento odkaz vypr za {1} minuty.\n\nPokud jste tento et nevytvoili, tuto zprvu ignorujte.+emailVerificationBodyHtml=<p>Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu. </p><p><a href=""{0}"">Odkaz na oven e-mailov adresy</a></p><p>Platnost odkazu vypr za {1} minut.</p><p>Pokud jste tento et nevytvoili, tuto zprvu ignorujte.</p>+emailTestSubject=[KEYCLOAK] - testovac zprva+emailTestBody=Toto je testovac zprva+emailTestBodyHtml=<p>Toto je testovac zprva </p>+identityProviderLinkSubject=Odkaz {0}+identityProviderLinkBody=Nkdo chce propojit v et ""{1}"" s tem ""{0}"" uivatele {2}. Pokud jste to vy, kliknte na ne uveden odkaz a propojte ty. \n\n{3}\n\nPlatnost tohoto odkazu je {5}.\n\nPokud nechcete propojit et, tuto zprvu ignorujte. Pokud propojte ty, budete se moci pihlsit jako {1} pomoc {0}.+identityProviderLinkBodyHtml=<p>Nkdo prv podal o zmnu hesla u vaeho tu {2}. Pokud jste to vy, pro jeho zmnu kliknte na odkaz ne.</p><p><a href=""{0}"">Odkaz na zmnu hesla.</a></p><p>Platnost tohoto odkazu je {3}.</p><p>Pokud heslo zmnit nechcete, tuto zprvu ignorujte a nic se nezmn.</p>+passwordResetSubject=Zapomenut heslo+passwordResetBody=Nkdo prv podal o zmnu hesla u vaeho tu {2}. Pokud jste to vy, pro jeho zmnu kliknte na odkaz ne.\n\n{0}\n\nPlatnost tohoto odkazu je {3}.\n\nPokud heslo zmnit nechcete, tuto zprvu ignorujte a nic se nezmn.+passwordResetBodyHtml=<p> Nkdo prv podal o zmnu poven vaeho tu {2}. Pokud jste to vy, kliknte na odkaz ne, abyste je resetovali.</p><p><a href=""{0}"">Odkaz na obnoven poven </a></p><p> Platnost tohoto odkazu vypr bhem {1} minut.</p><p> Pokud nechcete obnovit vae poven, ignorujte tuto zprvu a nic se nezmn.</p>+executeActionsSubject=Aktualizujte svj et+executeActionsBody=V administrtor vs podal o proveden nsledujcch akc u tu {2}: {3}. Zante kliknutm na ne uveden odkaz.\n\n{0}\n\nPlatnost tohoto odkazu je {4}.\n\nPokud si nejste jisti, zda je tento poadavek v podku, ignorujte tuto zprvu.+executeActionsBodyHtml=<p>V administrtor vs podal o proveden nsledujcch akc u tu {2}: {3}. Zante kliknutm na ne uveden odkaz.</p><p><a href=""{0}"">Odkaz na aktualizaci tu.</a></p><p>Platnost tohoto odkazu je {4}.</p><p>Pokud si nejste jisti, zda je tento poadavek v podku, ignorujte tuto zprvu.</p>+eventLoginErrorSubject=Chyba pihlen+eventLoginErrorBody=Nkdo se nespn pokusil pihlsit k tu {0} z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventLoginErrorBodyHtml=<p>Nkdo se nespn pokusil pihlsit k tu {0} z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventRemoveTotpSubject=Odebrat TOTP+eventRemoveTotpBody=V tu {0} bylo odebrno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventRemoveTotpBodyHtml=<p>V tu {0} bylo odebrno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventUpdatePasswordSubject=Aktualizace hesla+eventUpdatePasswordBody=V tu {0} bylo zmnno heslo z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventUpdatePasswordBodyHtml=<p>V tu {0} bylo zmnno heslo z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventUpdateTotpSubject=Aktualizace OTP+eventUpdateTotpBody=V tu {0} bylo zmnno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventUpdateTotpBodyHtml=<p>V tu {0} bylo zmnno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>++requiredAction.CONFIGURE_TOTP=Konfigurace OTP+requiredAction.terms_and_conditions=Smluvn podmnky+requiredAction.UPDATE_PASSWORD=Aktualizace hesla+requiredAction.UPDATE_PROFILE=Aktualizace profilu+requiredAction.VERIFY_EMAIL=Oven e-mailu++# units for link expiration timeout formatting+linkExpirationFormatter.timePeriodUnit.seconds=sekundy+linkExpirationFormatter.timePeriodUnit.seconds.1=sekunda+linkExpirationFormatter.timePeriodUnit.minutes=minuty+linkExpirationFormatter.timePeriodUnit.minutes.1=minuta+linkExpirationFormatter.timePeriodUnit.minutes.2=minuty+linkExpirationFormatter.timePeriodUnit.minutes.3=minuty+linkExpirationFormatter.timePeriodUnit.minutes.4=minuty+linkExpirationFormatter.timePeriodUnit.hours=hodiny","```suggestionlinkExpirationFormatter.timePeriodUnit.hours=hodin```and alternatives for 2, 3, and 4 (similarly to what you have for _minutes_ above)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7198,444399714,2020-06-23T17:45:00Z,themes/src/main/resources-community/theme/base/email/messages/messages_cs.properties,"@@ -0,0 +1,47 @@+# encoding: utf-8+emailVerificationSubject=Oven e-mailu+emailVerificationBody=Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu \n\n{0}\n\nTento odkaz vypr za {1} minuty.\n\nPokud jste tento et nevytvoili, tuto zprvu ignorujte.+emailVerificationBodyHtml=<p>Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu. </p><p><a href=""{0}"">Odkaz na oven e-mailov adresy</a></p><p>Platnost odkazu vypr za {1} minut.</p><p>Pokud jste tento et nevytvoili, tuto zprvu ignorujte.</p>+emailTestSubject=[KEYCLOAK] - testovac zprva+emailTestBody=Toto je testovac zprva+emailTestBodyHtml=<p>Toto je testovac zprva </p>+identityProviderLinkSubject=Odkaz {0}+identityProviderLinkBody=Nkdo chce propojit v et ""{1}"" s tem ""{0}"" uivatele {2}. Pokud jste to vy, kliknte na ne uveden odkaz a propojte ty. \n\n{3}\n\nPlatnost tohoto odkazu je {5}.\n\nPokud nechcete propojit et, tuto zprvu ignorujte. Pokud propojte ty, budete se moci pihlsit jako {1} pomoc {0}.+identityProviderLinkBodyHtml=<p>Nkdo prv podal o zmnu hesla u vaeho tu {2}. Pokud jste to vy, pro jeho zmnu kliknte na odkaz ne.</p><p><a href=""{0}"">Odkaz na zmnu hesla.</a></p><p>Platnost tohoto odkazu je {3}.</p><p>Pokud heslo zmnit nechcete, tuto zprvu ignorujte a nic se nezmn.</p>+passwordResetSubject=Zapomenut heslo+passwordResetBody=Nkdo prv podal o zmnu hesla u vaeho tu {2}. Pokud jste to vy, pro jeho zmnu kliknte na odkaz ne.\n\n{0}\n\nPlatnost tohoto odkazu je {3}.\n\nPokud heslo zmnit nechcete, tuto zprvu ignorujte a nic se nezmn.+passwordResetBodyHtml=<p> Nkdo prv podal o zmnu poven vaeho tu {2}. Pokud jste to vy, kliknte na odkaz ne, abyste je resetovali.</p><p><a href=""{0}"">Odkaz na obnoven poven </a></p><p> Platnost tohoto odkazu vypr bhem {1} minut.</p><p> Pokud nechcete obnovit vae poven, ignorujte tuto zprvu a nic se nezmn.</p>+executeActionsSubject=Aktualizujte svj et+executeActionsBody=V administrtor vs podal o proveden nsledujcch akc u tu {2}: {3}. Zante kliknutm na ne uveden odkaz.\n\n{0}\n\nPlatnost tohoto odkazu je {4}.\n\nPokud si nejste jisti, zda je tento poadavek v podku, ignorujte tuto zprvu.+executeActionsBodyHtml=<p>V administrtor vs podal o proveden nsledujcch akc u tu {2}: {3}. Zante kliknutm na ne uveden odkaz.</p><p><a href=""{0}"">Odkaz na aktualizaci tu.</a></p><p>Platnost tohoto odkazu je {4}.</p><p>Pokud si nejste jisti, zda je tento poadavek v podku, ignorujte tuto zprvu.</p>+eventLoginErrorSubject=Chyba pihlen+eventLoginErrorBody=Nkdo se nespn pokusil pihlsit k tu {0} z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventLoginErrorBodyHtml=<p>Nkdo se nespn pokusil pihlsit k tu {0} z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventRemoveTotpSubject=Odebrat TOTP+eventRemoveTotpBody=V tu {0} bylo odebrno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventRemoveTotpBodyHtml=<p>V tu {0} bylo odebrno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventUpdatePasswordSubject=Aktualizace hesla+eventUpdatePasswordBody=V tu {0} bylo zmnno heslo z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventUpdatePasswordBodyHtml=<p>V tu {0} bylo zmnno heslo z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>+eventUpdateTotpSubject=Aktualizace OTP+eventUpdateTotpBody=V tu {0} bylo zmnno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.+eventUpdateTotpBodyHtml=<p>V tu {0} bylo zmnno nastaven OTP z {1}. Pokud jste to nebyli vy, kontaktujte administrtora.</p>++requiredAction.CONFIGURE_TOTP=Konfigurace OTP+requiredAction.terms_and_conditions=Smluvn podmnky+requiredAction.UPDATE_PASSWORD=Aktualizace hesla+requiredAction.UPDATE_PROFILE=Aktualizace profilu+requiredAction.VERIFY_EMAIL=Oven e-mailu++# units for link expiration timeout formatting+linkExpirationFormatter.timePeriodUnit.seconds=sekundy+linkExpirationFormatter.timePeriodUnit.seconds.1=sekunda+linkExpirationFormatter.timePeriodUnit.minutes=minuty+linkExpirationFormatter.timePeriodUnit.minutes.1=minuta+linkExpirationFormatter.timePeriodUnit.minutes.2=minuty+linkExpirationFormatter.timePeriodUnit.minutes.3=minuty+linkExpirationFormatter.timePeriodUnit.minutes.4=minuty+linkExpirationFormatter.timePeriodUnit.hours=hodiny+linkExpirationFormatter.timePeriodUnit.hours.1=hodina+linkExpirationFormatter.timePeriodUnit.days=dny","```suggestionlinkExpirationFormatter.timePeriodUnit.days=dn```and alternatives for 2, 3, and 4 (similarly to what you have for _minutes_ above)",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7040,444762965,2020-06-24T09:23:59Z,services/src/main/java/org/keycloak/social/facebook/FacebookIdentityProvider.java,"@@ -18,34 +18,30 @@ package org.keycloak.social.facebook;  import com.fasterxml.jackson.databind.JsonNode;-import org.keycloak.OAuthErrorException;++import org.apache.commons.lang.StringUtils;",Just a nitpick. This import seems to be unused.,X
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7104,445140283,2020-06-24T20:04:24Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestAuthnMethodsConditionFactory.java,"@@ -0,0 +1,85 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition.impl;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;+import org.keycloak.services.clientregistration.policy.RegistrationAuth;++public class TestAuthnMethodsConditionFactory implements ClientPolicyConditionProviderFactory {++    public static final String PROVIDER_ID = ""test-authnmethods-condition"";++    public static final String AUTH_METHOD = ""auth-method"";+    public static final String BY_ADMIN_REST_API = ""ByAdminRestAPI"";+    public static final String BY_DYNAMIC_ANONYMOUS = RegistrationAuth.ANONYMOUS.name();+    public static final String BY_DYNAMIC_AUTHENTICATED = RegistrationAuth.AUTHENTICATED.name();","I see, I'll treat this matter as follows.- move this class to testsuite-providers project because it is test use only.- the following options about who tries to create/update a client are supported.  - authenticated-user  - anonymous  - initial-access-token  - registration-access-token- hold a token (initial-access-token, registration-access-token, access-token) in `ClientUpdateContext` in order for us to use it to do some policy operation based on it in the future.WDYT? ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/6809,446341761,2020-06-26T18:22:43Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/authz/UmaRepresentationTest.java,"@@ -0,0 +1,173 @@+package org.keycloak.testsuite.authz;++import org.jboss.resteasy.mock.MockHttpRequest;+import org.junit.Assert;+import org.junit.Test;+import org.keycloak.admin.client.resource.RealmResource;+import org.keycloak.authorization.AuthorizationProvider;+import org.keycloak.authorization.client.resource.PermissionResource;+import org.keycloak.forms.account.freemarker.model.AuthorizationBean;+import org.keycloak.forms.account.freemarker.model.AuthorizationBean.ResourceBean;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.representations.idm.authorization.*;+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer;++import java.net.URISyntaxException;+import java.util.List;++@AuthServerContainerExclude(AuthServer.REMOTE)+public class UmaRepresentationTest extends AbstractResourceServerTest {+    private ResourceRepresentation resource;+    private PermissionResource permission;++    private void createPermissionTicket() {+        PermissionTicketRepresentation ticket = new PermissionTicketRepresentation();+        ticket.setOwner(resource.getOwner().getId());+        ticket.setResource(resource.getId());+        ticket.setRequesterName(""kolo"");+        ticket.setScopeName(""ScopeA"");+        ticket.setGranted(true);+        permission.create(ticket);+    }++    @Test+    public void testCanRepresentPermissionTicketWithNamesOfResourceOwnedByUser() throws Exception {+        resource = addResource(""Resource A"", ""marta"", true, ""ScopeA"");+        permission = getAuthzClient().protection(""marta"", ""password"").permission();+        createPermissionTicket();++        List<PermissionTicketRepresentation> permissionTickets = permission.find(resource.getId(), null, null, null, null, true, null, null);+        Assert.assertFalse(permissionTickets.isEmpty());+        Assert.assertEquals(1, permissionTickets.size());++        PermissionTicketRepresentation ticket = permissionTickets.get(0);+        Assert.assertEquals(ticket.getOwnerName(), ""marta"");+        Assert.assertEquals(ticket.getRequesterName(), ""kolo"");+        Assert.assertEquals(ticket.getResourceName(), ""Resource A"");+        Assert.assertEquals(ticket.getScopeName(), ""ScopeA"");+        Assert.assertTrue(ticket.isGranted());+    }++    @Test+    public void testCanRepresentPermissionTicketWithNamesOfResourceOwnedByClient() throws Exception {+        resource = addResource(""Resource A"", getClient(getRealm()).toRepresentation().getId(), true, ""ScopeA"");+        permission = getAuthzClient().protection().permission();+        createPermissionTicket();++        List<PermissionTicketRepresentation> permissionTickets = permission.find(resource.getId(), null, null, null, null, true, null, null);+        Assert.assertFalse(permissionTickets.isEmpty());+        Assert.assertEquals(1, permissionTickets.size());++        PermissionTicketRepresentation ticket = permissionTickets.get(0);+        Assert.assertEquals(ticket.getOwnerName(), ""resource-server-test"");+        Assert.assertEquals(ticket.getRequesterName(), ""kolo"");+        Assert.assertEquals(ticket.getResourceName(), ""Resource A"");+        Assert.assertEquals(ticket.getScopeName(), ""ScopeA"");+        Assert.assertTrue(ticket.isGranted());+    }++    @Test+    public void testCanRepresentPolicyResultGrantOfResourceOwnedByUser() throws Exception {+        resource = addResource(""Resource A"", ""marta"", true, ""ScopeA"");+        permission = getAuthzClient().protection(""marta"", ""password"").permission();+        createPermissionTicket();++        RealmResource realm = getRealm();+        String resourceServerId = getClient(realm).toRepresentation().getId();+        UserRepresentation user = realm.users().search(""kolo"").get(0);++        PolicyEvaluationRequest request = new PolicyEvaluationRequest();+        request.setUserId(user.getId());+        request.setClientId(resourceServerId);+        request.addResource(""Resource A"", ""ScopeA"");+        PolicyEvaluationResponse result = getClient(realm).authorization().policies().evaluate(request);+        Assert.assertEquals(result.getStatus(), DecisionEffect.PERMIT);++        List<PolicyEvaluationResponse.EvaluationResultRepresentation> evaluations = result.getResults();+        Assert.assertFalse(evaluations.isEmpty());+        Assert.assertEquals(1, evaluations.size());++        List<PolicyEvaluationResponse.PolicyResultRepresentation> policies = evaluations.get(0).getPolicies();+        Assert.assertFalse(evaluations.isEmpty());+        Assert.assertEquals(1, evaluations.size());++        String description = policies.get(0).getPolicy().getDescription();+        Assert.assertTrue(description.startsWith(""Resource owner (marta) grants access""));+    }++    @Test+    public void testCanRepresentPolicyResultGrantOfResourceOwnedByClient() throws Exception {+        resource = addResource(""Resource A"", getClient(getRealm()).toRepresentation().getId(), true, ""ScopeA"");+        permission = getAuthzClient().protection().permission();+        createPermissionTicket();++        RealmResource realm = getRealm();+        String resourceServerId = getClient(realm).toRepresentation().getId();+        UserRepresentation user = realm.users().search(""kolo"").get(0);++        PolicyEvaluationRequest request = new PolicyEvaluationRequest();+        request.setUserId(user.getId());+        request.setClientId(resourceServerId);+        request.addResource(""Resource A"", ""ScopeA"");+        PolicyEvaluationResponse result = getClient(realm).authorization().policies().evaluate(request);+        Assert.assertEquals(result.getStatus(), DecisionEffect.PERMIT);++        List<PolicyEvaluationResponse.EvaluationResultRepresentation> evaluations = result.getResults();+        Assert.assertFalse(evaluations.isEmpty());+        Assert.assertEquals(1, evaluations.size());++        List<PolicyEvaluationResponse.PolicyResultRepresentation> policies = evaluations.get(0).getPolicies();+        Assert.assertFalse(evaluations.isEmpty());+        Assert.assertEquals(1, evaluations.size());++        String description = policies.get(0).getPolicy().getDescription();+        Assert.assertTrue(description.startsWith(""Resource owner (resource-server-test) grants access""));+    }++    @Test+    public void testCanRepresentResourceBeanOfResourceOwnedByUser() throws Exception {+        resource = addResource(""Resource A"", ""marta"", true, ""ScopeA"");++        testingClient.server().run(session -> {",Tests should pass if you use a method reference here as follows https://github.com/keycloak/keycloak/blob/419d9c63510a95498e98807fc8e85758a14dc4ec/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/AuthzCleanupTest.java#L102.,
989572,nngo,https://api.github.com/repos/keycloak/keycloak/pulls/7021,446933443,2020-06-29T12:31:17Z,services/src/main/java/org/keycloak/social/github/GitHubIdentityProvider.java,"@@ -35,18 +35,79 @@  */ public class GitHubIdentityProvider extends AbstractOAuth2IdentityProvider implements SocialIdentityProvider { -	public static final String AUTH_URL = ""https://github.com/login/oauth/authorize"";-	public static final String TOKEN_URL = ""https://github.com/login/oauth/access_token"";-	public static final String PROFILE_URL = ""https://api.github.com/user"";-	public static final String EMAIL_URL = ""https://api.github.com/user/emails"";-	public static final String DEFAULT_SCOPE = ""user:email"";--	public GitHubIdentityProvider(KeycloakSession session, OAuth2IdentityProviderConfig config) {-		super(session, config);-		config.setAuthorizationUrl(AUTH_URL);-		config.setTokenUrl(TOKEN_URL);-		config.setUserInfoUrl(PROFILE_URL);-	}+    public static final String DEFAULT_BASE_URL = ""https://github.com"";+    public static final String AUTH_FRAGMENT = ""/login/oauth/authorize"";+    public static final String TOKEN_FRAGMENT = ""/login/oauth/access_token"";+    public static final String DEFAULT_AUTH_URL = DEFAULT_BASE_URL + AUTH_FRAGMENT;+    public static final String DEFAULT_TOKEN_URL = DEFAULT_BASE_URL + TOKEN_FRAGMENT;+    /** @deprecated Use {@link #DEFAULT_AUTH_URL} instead. */+    @Deprecated+    public static final String AUTH_URL = DEFAULT_AUTH_URL;+    /** @deprecated Use {@link #DEFAULT_TOKEN_URL} instead. */+    @Deprecated+    public static final String TOKEN_URL = DEFAULT_TOKEN_URL;","that is right, TOKEN_URL is not used in this class, but since it is public, I didn't want to remove it, hence I deprecated in flavor is better named DEFAULT_TOKEN_URL",
989572,nngo,https://api.github.com/repos/keycloak/keycloak/pulls/7021,446933574,2020-06-29T12:31:29Z,services/src/main/java/org/keycloak/social/github/GitHubIdentityProvider.java,"@@ -35,18 +35,79 @@  */ public class GitHubIdentityProvider extends AbstractOAuth2IdentityProvider implements SocialIdentityProvider { -	public static final String AUTH_URL = ""https://github.com/login/oauth/authorize"";-	public static final String TOKEN_URL = ""https://github.com/login/oauth/access_token"";-	public static final String PROFILE_URL = ""https://api.github.com/user"";-	public static final String EMAIL_URL = ""https://api.github.com/user/emails"";-	public static final String DEFAULT_SCOPE = ""user:email"";--	public GitHubIdentityProvider(KeycloakSession session, OAuth2IdentityProviderConfig config) {-		super(session, config);-		config.setAuthorizationUrl(AUTH_URL);-		config.setTokenUrl(TOKEN_URL);-		config.setUserInfoUrl(PROFILE_URL);-	}+    public static final String DEFAULT_BASE_URL = ""https://github.com"";+    public static final String AUTH_FRAGMENT = ""/login/oauth/authorize"";+    public static final String TOKEN_FRAGMENT = ""/login/oauth/access_token"";+    public static final String DEFAULT_AUTH_URL = DEFAULT_BASE_URL + AUTH_FRAGMENT;+    public static final String DEFAULT_TOKEN_URL = DEFAULT_BASE_URL + TOKEN_FRAGMENT;+    /** @deprecated Use {@link #DEFAULT_AUTH_URL} instead. */+    @Deprecated+    public static final String AUTH_URL = DEFAULT_AUTH_URL;+    /** @deprecated Use {@link #DEFAULT_TOKEN_URL} instead. */+    @Deprecated+    public static final String TOKEN_URL = DEFAULT_TOKEN_URL;++    public static final String DEFAULT_API_URL = ""https://api.github.com"";+    public static final String PROFILE_FRAGMENT = ""/user"";+    public static final String EMAIL_FRAGMENT = ""/user/emails"";+    public static final String DEFAULT_PROFILE_URL = DEFAULT_API_URL + PROFILE_FRAGMENT;+    public static final String DEFAULT_EMAIL_URL = DEFAULT_API_URL + EMAIL_FRAGMENT;+    /** @deprecated Use {@link #DEFAULT_PROFILE_URL} instead. */+    @Deprecated+    public static final String PROFILE_URL = DEFAULT_PROFILE_URL;+    /** @deprecated Use {@link #DEFAULT_EMAIL_URL} instead. */+    @Deprecated+    public static final String EMAIL_URL = DEFAULT_EMAIL_URL;","that is right, EMAIL_URL is not used in this class, but since it is public, I didn't want to remove it, hence I deprecated in flavor is better named DEFAULT_EMAIL_URL",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7218,448305811,2020-07-01T11:43:02Z,themes/src/main/resources/theme/keycloak-man/account/resources/content/keycloak-man/sample-overview.js,"@@ -0,0 +1,80 @@+/*","@jonkoops Snowpack is an ""unbundled"" bundler.  We are using Babel to handle the JSX.This is kind of a long story, but we did it this way to improve the developer experience.  Snowpack is mainly used to bundle the libraries each into a single file.  This allows us to have an unbundled application that doesn't require hundreds of small downloads.So with this architecture, you can do what we show in `sample-overview.js` and `who-is-keycloak-man.js`.  That is, you can drop a plain javascript file into the app and it will just load it and run it.  If we had used a traditional bundler like WebPack, this would be far more difficult to achieve.As for the ""Keycloak Man Loves JSX"" page, this shows the same toolchain we used to create the whole New Account Console.  You don't technically need to use Snowpack for the example as the React and PatternFly libraries already live in themes/keycloak/common/resources/web_modules.  Running snowpack as part of the example just made it easier to create the example.  I'm sure if I spent some more time on it, I could figure out how to do away with that part.  If you have a suggestion I'd love to hear it.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7136,449345502,2020-07-03T02:25:50Z,quarkus/runtime/src/main/java/org/keycloak/provider/quarkus/KeycloakConfigSourceProvider.java,"@@ -58,23 +55,16 @@         }          if (filePath != null) {-            sources.add(wrap(new KeycloakPropertiesConfigSource.InFileSystem(filePath)));+            sources.add(new KeycloakPropertiesConfigSource.InFileSystem(filePath));",I'm doing similar changes in another PR. I'm wondering if we should get first my changes even though we need some more discussion around configuration.It should not be a problem as most of the changes are necessary.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,449451266,2020-07-03T08:29:45Z,saml-core-api/src/main/java/org/keycloak/saml/common/constants/JBossSAMLURIConstants.java,"@@ -65,6 +65,7 @@     HOLDER_OF_KEY(""urn:oasis:names:tc:SAML:2.0:cm:holder-of-key""),      METADATA_NSURI(""urn:oasis:names:tc:SAML:2.0:metadata""),+    ENTITY_ATTRIBUTES(""urn:oasis:names:tc:SAML:metadata:attribute""),","Please use a name ending in _NSURI and signalling the source, e.g.:```suggestion    // http://docs.oasis-open.org/security/saml/Post2.0/sstc-metadata-attr-cd-01.pdf    METADATA_ENTITY_ATTRIBUTES_NSURI(""urn:oasis:names:tc:SAML:metadata:attribute""),```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,449452152,2020-07-03T08:31:26Z,saml-core-api/src/main/java/org/keycloak/saml/common/constants/GeneralConstants.java,"@@ -150,6 +150,9 @@     String BASE64_ENCODE_WSTRUST_SECRET_KEY = ""picketlink.wstrust.base64_encode_wstrust_secret_key"";      String HTTP_HEADER_X_REQUESTED_WITH = ""X-Requested-With"";+    +    String MACEDIR =""http://macedir.org/entity-category"";+    String HIDE_FOR_DISCOVERY= ""http://refeds.org/category/hide-from-discovery"";","These constants should be only in the services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderFactory.java```suggestion    String MACEDIR_ENTITY_CATEGORY = ""http://macedir.org/entity-category"";    String REFEDS_HIDE_FOR_DISCOVERY = ""http://refeds.org/category/hide-from-discovery"";```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,449463311,2020-07-03T08:53:33Z,saml-core-api/src/main/java/org/keycloak/dom/saml/v2/metadata/EntityAttributes.java,"@@ -0,0 +1,66 @@+package org.keycloak.dom.saml.v2.metadata;",This file belongs to a separate package. Lets call it ```suggestionpackage org.keycloak.dom.saml.v2.mdattr;```,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,449478723,2020-07-03T09:23:10Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -52,6 +52,8 @@     public static final String WANT_ASSERTIONS_SIGNED = ""wantAssertionsSigned"";     public static final String WANT_AUTHN_REQUESTS_SIGNED = ""wantAuthnRequestsSigned"";     public static final String XML_SIG_KEY_INFO_KEY_NAME_TRANSFORMER = ""xmlSigKeyInfoKeyNameTransformer"";+    public static final String HIDE_ON_LOGIN = ""hideOnLoginPage"";+    public static final String ENABLED = ""enabled"";","Remove, there is already `enabled` property in the parent class.",X
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,449561810,2020-07-03T12:38:05Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -52,6 +52,8 @@     public static final String WANT_ASSERTIONS_SIGNED = ""wantAssertionsSigned"";     public static final String WANT_AUTHN_REQUESTS_SIGNED = ""wantAuthnRequestsSigned"";     public static final String XML_SIG_KEY_INFO_KEY_NAME_TRANSFORMER = ""xmlSigKeyInfoKeyNameTransformer"";+    public static final String HIDE_ON_LOGIN = ""hideOnLoginPage"";+    public static final String ENABLED = ""enabled"";","I know it. The problem is that importFrom method in class IdentityProvidersResource ( rest api for import identity provider from url or file) is returning only IdentityProviderModel.config. Property enabled in IdentityProviderModel is not in this map. As a result when you import a Saml Identity Provider from url or file , property enabled will not returned from rest api. Do you suggest another solution?",
30341294,trickert76,https://api.github.com/repos/keycloak/keycloak/pulls/7189,449566519,2020-07-03T12:49:06Z,adapters/oidc/spring-boot-adapter-core/src/main/java/org/keycloak/adapters/springboot/KeycloakSpringBootConfigResolver.java,"@@ -21,13 +21,15 @@ import org.keycloak.adapters.KeycloakDeploymentBuilder; import org.keycloak.adapters.OIDCHttpFacade; import org.keycloak.representations.adapters.config.AdapterConfig;+import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration;  @Configuration public class KeycloakSpringBootConfigResolver implements org.keycloak.adapters.KeycloakConfigResolver {      private KeycloakDeployment keycloakDeployment; +    @Autowired","Ah, sorry for my late response. Good point. I'd like to try that. Because of my vacation for two weeks, I need to postpone that til mid of July. Is that okay? Also I say, that field injection with AutoWired is not best practice but constructor injection is better. But in that case, the class signature changes, what I would like to avoid. Also - another point - we could create a public setAdapterConfig() or replace the private field with a protected field. In both cases the Spring application which is WAR-deployment-aware can set the AdapterConfig explicitly.But first, I'll try `required=false`",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/6996,449570704,2020-07-03T12:58:21Z,saml-core/src/main/java/org/keycloak/saml/SPMetadataDescriptor.java,"@@ -17,59 +17,108 @@  package org.keycloak.saml; +import org.keycloak.dom.saml.v2.metadata.*;","Please do not use star imports, import explicitly each class",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,449578010,2020-07-03T13:15:19Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -965,6 +965,7 @@ module.controller('RealmIdentityProviderCtrl', function($scope, $filter, $upload         for (var key in data) {             $scope.identityProvider.config[key] = data[key];         }+        $scope.identityProvider.enabled = data[""enabled""];","Related to my comment in SAMLIdentityProviderConfig, data returned from rest api return only Map. ""enabled"" key containing in data Map will never affect identityProvider.enabled with previous code. Do you suggest another solution?My current implementation need a change in order to take into account that ""enabled"" key will not exist in Map for all other Identity providers except than SAML Identity Provider. I proposed to be : `if (data[""enabled""] != undefined) {        	$scope.identityProvider.enabled = data[""enabled""];        }`",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,449596944,2020-07-03T13:57:36Z,saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/metadata/SAMLAttributeParser.java,"@@ -16,20 +16,12 @@  */ package org.keycloak.saml.processing.core.parsers.saml.metadata; -import org.keycloak.dom.saml.v2.assertion.AttributeType;-import org.keycloak.saml.common.exceptions.ParsingException;-import org.keycloak.saml.common.util.StaxParserUtil;-import org.keycloak.saml.processing.core.parsers.saml.assertion.SAMLAttributeValueParser;--import javax.xml.stream.XMLEventReader;-import javax.xml.stream.events.StartElement;- /**  * Parse the <conditions> in the saml assertion  *  * @since Oct 14, 2010  */-public class SAMLAttributeParser extends AbstractStaxSamlMetadataParser<AttributeType> {+public class SAMLAttributeParser extends SAMLAttributeTypeParser {",org.keycloak.saml.processing.core.parsers.saml.assertion.SAMLAttributeParser  will be used in this PR. This SAMLAttributeParser existed in code and it was not used. Do you want to keep org.keycloak.saml.processing.core.parsers.saml.metadata.SAMLAttributeParser same as Keycloak master or to remove it?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7136,449612406,2020-07-03T14:32:43Z,quarkus/runtime/src/main/java/org/keycloak/provider/quarkus/QuarkusClientConnectionFilter.java,"@@ -0,0 +1,97 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.provider.quarkus;++import io.quarkus.vertx.web.RouteFilter;+import io.vertx.core.Handler;+import io.vertx.core.http.HttpServerRequest;+import io.vertx.ext.web.RoutingContext;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Resteasy;+import org.keycloak.models.KeycloakSession;+import org.keycloak.services.filters.AbstractClientConnectionServletFilter;++import javax.inject.Inject;+import javax.ws.rs.container.ContainerRequestContext;+import javax.ws.rs.container.PreMatching;+import javax.ws.rs.ext.Provider;++@PreMatching+@Provider+public class QuarkusClientConnectionFilter implements javax.ws.rs.container.ContainerRequestFilter {++    @Inject+    RoutingContext routingContext;++    @Override+    public void filter(ContainerRequestContext containerRequestContext) {+        HttpServerRequest request = routingContext.request();+        ClientConnection connection = createConnection(request);++        AbstractClientConnectionServletFilter servletFilter = new AbstractClientConnectionServletFilter() {",The fact we are creating instances of `AbstractClientConnectionServletFilter` on every request is not ideal. As well as duplicating code when pushing context data.We could potentially override methods and have the main logic from the abstract class.,X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7136,449649712,2020-07-03T16:15:37Z,quarkus/runtime/src/main/java/org/keycloak/provider/quarkus/QuarkusClientConnectionFilter.java,"@@ -0,0 +1,97 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.provider.quarkus;++import io.quarkus.vertx.web.RouteFilter;+import io.vertx.core.Handler;+import io.vertx.core.http.HttpServerRequest;+import io.vertx.ext.web.RoutingContext;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Resteasy;+import org.keycloak.models.KeycloakSession;+import org.keycloak.services.filters.AbstractClientConnectionServletFilter;++import javax.inject.Inject;+import javax.ws.rs.container.ContainerRequestContext;+import javax.ws.rs.container.PreMatching;+import javax.ws.rs.ext.Provider;++@PreMatching+@Provider+public class QuarkusClientConnectionFilter implements javax.ws.rs.container.ContainerRequestFilter {++    @Inject+    RoutingContext routingContext;++    @Override+    public void filter(ContainerRequestContext containerRequestContext) {+        HttpServerRequest request = routingContext.request();+        ClientConnection connection = createConnection(request);++        AbstractClientConnectionServletFilter servletFilter = new AbstractClientConnectionServletFilter() {","That would be ideal if the same approach could be used in Wildfly, however it seems that this is not possible, servlet filter approach is not compatible with the vert.x filters, and it does not seem possible to use a common approach. So instantiating a _small_ instance seemed an acceptable alternative. Yet if you find a better alternative that would work for both, that would be indeed better.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7032,449669742,2020-07-03T17:45:12Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -120,7 +120,6 @@ public RealmModel getRealm(String id) {         for (String id : entities) {             RealmModel realm = session.realms().getRealm(id);             if (realm != null) realms.add(realm);-            em.flush();","This is interesting point. See #6012, the call to `flush` reportedly improved the performance for bigger number of realms.  As I mentioned in the https://github.com/keycloak/keycloak/pull/6012#pullrequestreview-311328910 comment, I'd rather have no `flush` whatsoever in the JPA layer. Yet now I wonder which of the alternatives is better.Could you please try the same patch without this `flush` and report the results here?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7187,450175294,2020-07-06T12:06:37Z,services/src/main/java/org/keycloak/services/resources/KeycloakApplication.java,"@@ -107,6 +109,7 @@ public KeycloakApplication() {             singletons.add(new RealmsResource());             singletons.add(new AdminRoot());             classes.add(ThemeResource.class);+            classes.add(CachingGZIPEncodingInterceptor.class);",Should this be a singleton instead?,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7187,450193742,2020-07-06T12:43:06Z,services/src/main/java/org/keycloak/services/filters/CachingGZIPEncodingInterceptor.java,"@@ -0,0 +1,90 @@+package org.keycloak.services.filters;++import org.apache.commons.io.IOUtils;+import org.apache.commons.io.output.TeeOutputStream;+import org.jboss.resteasy.plugins.interceptors.encoding.GZIPEncodingInterceptor;+import org.jboss.resteasy.resteasy_jaxrs.i18n.LogMessages;+import org.keycloak.common.Profile;++import javax.annotation.Priority;+import javax.ws.rs.Priorities;+import javax.ws.rs.WebApplicationException;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.UriInfo;+import javax.ws.rs.ext.Provider;+import javax.ws.rs.ext.WriterInterceptorContext;+import java.io.ByteArrayOutputStream;+import java.io.FileInputStream;+import java.io.FileOutputStream;+import java.io.IOException;+import java.io.OutputStream;+import java.nio.file.Files;+import java.nio.file.Path;+import java.nio.file.Paths;++@Provider+@Priority(Priorities.ENTITY_CODER)+public class CachingGZIPEncodingInterceptor extends GZIPEncodingInterceptor {++    private final Path tmpDir;+    @Context+    private UriInfo uriInfo;++    public CachingGZIPEncodingInterceptor() {+        try {+            this.tmpDir = Files.createTempDirectory(""gzip-cache"");+        } catch (IOException e) {+            throw new RuntimeException(""could not create temp gzip cache directory"");+        }+    }++    public static class CacheCommittedGZIPOutputStream extends CommittedGZIPOutputStream {+        protected CacheCommittedGZIPOutputStream(final OutputStream delegate) {+            super(delegate, null);+        }+    }++    @Override+    public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException {+        LogMessages.LOGGER.debugf(""Interceptor : %s,  Method : aroundWriteTo"", getClass().getName());++        Object encoding = context.getHeaders().getFirst(HttpHeaders.CONTENT_ENCODING);+        final boolean featureEnabled = Profile.isFeatureEnabled(Profile.Feature.GZIP);++        if (encoding != null && encoding.toString().equalsIgnoreCase(""gzip"") && featureEnabled) {+            OutputStream old = context.getOutputStream();++            final String fileName = uriInfo.getPath();+            final Path zipFile = Paths.get(tmpDir.toString(), fileName);++            // Any content length set will be obsolete+            context.getHeaders().remove(""Content-Length"");",If compressed data is cached we'd have the real content-length wouldn't we?,
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/7187,450212939,2020-07-06T13:17:08Z,services/src/main/java/org/keycloak/services/filters/CachingGZIPEncodingInterceptor.java,"@@ -0,0 +1,90 @@+package org.keycloak.services.filters;++import org.apache.commons.io.IOUtils;+import org.apache.commons.io.output.TeeOutputStream;+import org.jboss.resteasy.plugins.interceptors.encoding.GZIPEncodingInterceptor;+import org.jboss.resteasy.resteasy_jaxrs.i18n.LogMessages;+import org.keycloak.common.Profile;++import javax.annotation.Priority;+import javax.ws.rs.Priorities;+import javax.ws.rs.WebApplicationException;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.UriInfo;+import javax.ws.rs.ext.Provider;+import javax.ws.rs.ext.WriterInterceptorContext;+import java.io.ByteArrayOutputStream;+import java.io.FileInputStream;+import java.io.FileOutputStream;+import java.io.IOException;+import java.io.OutputStream;+import java.nio.file.Files;+import java.nio.file.Path;+import java.nio.file.Paths;++@Provider+@Priority(Priorities.ENTITY_CODER)+public class CachingGZIPEncodingInterceptor extends GZIPEncodingInterceptor {++    private final Path tmpDir;+    @Context+    private UriInfo uriInfo;++    public CachingGZIPEncodingInterceptor() {+        try {+            this.tmpDir = Files.createTempDirectory(""gzip-cache"");","How do I know the version has changed? Seems that version is part of the request path, when the version changes the old versions are no longer needed, is that always true?Isn't the `java.io.tmpdir` variable set to the tmp dir in the distribution? If not what is the way to create a temp folder, I couldn't find it in the code base.",
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/7187,450222819,2020-07-06T13:32:53Z,services/src/main/java/org/keycloak/services/resources/KeycloakApplication.java,"@@ -107,6 +109,7 @@ public KeycloakApplication() {             singletons.add(new RealmsResource());             singletons.add(new AdminRoot());             classes.add(ThemeResource.class);+            classes.add(CachingGZIPEncodingInterceptor.class);","it should be added to the providers, I thought that was what the `classes` where for...",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7187,450240047,2020-07-06T13:59:18Z,services/src/main/java/org/keycloak/services/resources/KeycloakApplication.java,"@@ -107,6 +109,7 @@ public KeycloakApplication() {             singletons.add(new RealmsResource());             singletons.add(new AdminRoot());             classes.add(ThemeResource.class);+            classes.add(CachingGZIPEncodingInterceptor.class);","classes.add - adds providers where there is a new instance created for each request, while singletons.add adds providers where the same instance is used for all requests. If this is changed to singletons.add then you can have some code in the constructor that is only ran once and not for every request + there's less classes for gc.",
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,450280016,2020-07-06T14:56:27Z,services/src/main/java/org/keycloak/userprofile/LegacyUserProfileProvider.java,"@@ -0,0 +1,206 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import org.jboss.logging.Logger;+import org.keycloak.common.util.ObjectUtil;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.representations.idm.UserAttributesRepresentation;+import org.keycloak.services.messages.Messages;+import org.keycloak.userprofile.util.UpdateUserProfileContext;+import org.keycloak.userprofile.validation.StaticValidators;+import org.keycloak.userprofile.validation.UserProfileValidationResult;+import org.keycloak.userprofile.validation.ValidationChainBuilder;+import org.keycloak.userprofile.validation.ValidationScenario;++import java.util.Collections;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public class LegacyUserProfileProvider extends AbstractUserProfileProvider {++    private static final Logger logger = Logger.getLogger(LegacyUserProfileProvider.class);+++    public static final String PROVIDER_ID = ""legacy-user-profile"";++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    @Override+    public UserProfileValidationResult validate(UserAttributesRepresentation rep, UpdateUserProfileContext user, ValidationScenario validationScenario) {+        RealmModel realm = this.session.getContext().getRealm();++        ValidationChainBuilder builder = ValidationChainBuilder.builder();+        switch (validationScenario) {+            case UserResource:+                break;+            case IdpReview:+                addBasicValidators(builder, !realm.isRegistrationEmailAsUsername());+                break;+            case Account:+            case RegistrationProfile:+            case UpdateProfile:+                addBasicValidators(builder, !realm.isRegistrationEmailAsUsername() && realm.isEditUsernameAllowed());+                addSessionValidators(builder);+                break;+            case RegistrationUserCreation:+                addUserCreationValidators(builder);+                break;+        }+        return new UserProfileValidationResult(builder.build().validate(rep, user));+    }++    private void addUserCreationValidators(ValidationChainBuilder builder) {+        RealmModel realm = this.session.getContext().getRealm();++        if (realm.isRegistrationEmailAsUsername()) {","This is needed because of the ""chained action"" approach in the registration. May it should be considered to adapt the registration flow in order to remove this switch so we can go here with configuration only. ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7184,450283749,2020-07-06T15:01:35Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PathCache.java,"@@ -115,12 +123,19 @@ private PathConfig removeIfExpired(CacheEntry cached) {             return null;         } +        PathConfig config = cached.value();+         if (cached.isExpired()) {             remove(cached.key());+            +            if (config != null && config.getPath() != null) {+                // also remove from pre-defined paths map so that changes on the server are properly reflected+                paths.remove(config.getPath());","@mhajas I see your point in that comment. And the reason is that `lazy-load-paths` is set to false so the resource will never be fetched again.I guess we should only remove if that flag is marked as true so that the application can fetch again resources from server. But your comment raises another question if you have paths with a specific configuration in your deployment configuration, they'll also be lost ... Let me create some tests based on your findings.",X
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7176,450384892,2020-07-06T17:49:39Z,themes/src/main/resources/theme/keycloak-preview/account/messages/messages_en.properties,"@@ -110,3 +111,6 @@ removeModalTitle=Remove Access removeModalMessage=This will remove the currently granted access permission for {0}. You will need to grant access again if you want to use this app. confirmButton=Confirm infoMessage=By clicking 'Remove Access', you will remove granted permissions of this application. This application will no longer use your information.++#Delete Account page+deleteAccountSummary=Deleting your account will erase all your data and log you out immediately. ","I know this might sound far-fetched, but the account console is used by novice users.  We shouldn't tell them it will ""erase all your data"".  They might think it will wipe the hard drive.Though I'm a bit hard-pressed to suggest what the text should actually be.  @andymunro?",
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/7187,450619374,2020-07-07T05:29:32Z,services/src/main/java/org/keycloak/services/resources/KeycloakApplication.java,"@@ -107,6 +109,7 @@ public KeycloakApplication() {             singletons.add(new RealmsResource());             singletons.add(new AdminRoot());             classes.add(ThemeResource.class);+            classes.add(CachingGZIPEncodingInterceptor.class);","I don't know why, but when I add it to `singletons` it doesn't use the Interceptor.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7187,450631785,2020-07-07T06:11:43Z,services/src/main/java/org/keycloak/services/filters/CachingGZIPEncodingInterceptor.java,"@@ -0,0 +1,90 @@+package org.keycloak.services.filters;++import org.apache.commons.io.IOUtils;+import org.apache.commons.io.output.TeeOutputStream;+import org.jboss.resteasy.plugins.interceptors.encoding.GZIPEncodingInterceptor;+import org.jboss.resteasy.resteasy_jaxrs.i18n.LogMessages;+import org.keycloak.common.Profile;++import javax.annotation.Priority;+import javax.ws.rs.Priorities;+import javax.ws.rs.WebApplicationException;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.UriInfo;+import javax.ws.rs.ext.Provider;+import javax.ws.rs.ext.WriterInterceptorContext;+import java.io.ByteArrayOutputStream;+import java.io.FileInputStream;+import java.io.FileOutputStream;+import java.io.IOException;+import java.io.OutputStream;+import java.nio.file.Files;+import java.nio.file.Path;+import java.nio.file.Paths;++@Provider+@Priority(Priorities.ENTITY_CODER)+public class CachingGZIPEncodingInterceptor extends GZIPEncodingInterceptor {++    private final Path tmpDir;+    @Context+    private UriInfo uriInfo;++    public CachingGZIPEncodingInterceptor() {+        try {+            this.tmpDir = Files.createTempDirectory(""gzip-cache"");",https://github.com/keycloak/keycloak/blob/master/common/src/main/java/org/keycloak/common/Version.java#L35During startup this field is set to a randomly generated string specific for that version and that installation of KC. So if this doesn't match the version that was previously cached the old cached versions should be deleted. Perhaps the simplest would be to just add to a the folder `gzip-cache/Version.RESOURCES_VERSION` then make sure there is no other directories within gzip-cache than the current?,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7136,450901568,2020-07-07T14:20:15Z,services/src/main/java/org/keycloak/services/filters/AbstractClientConnectionFilter.java,"@@ -0,0 +1,66 @@+package org.keycloak.services.filters;++/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++import java.util.function.Consumer;+import java.util.function.Function;+import java.util.function.Supplier;++import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Resteasy;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.KeycloakTransactionManager;+import org.keycloak.services.resources.KeycloakApplication;+++public abstract class AbstractClientConnectionFilter {","Rename to something like AbstractRequestFilter, including renaming subclasses.",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,450972901,2020-07-07T15:58:01Z,services/src/main/java/org/keycloak/authentication/requiredactions/DeleteAccount.java,"@@ -0,0 +1,156 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import java.io.IOException;+import java.util.Objects;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.InitiatedActionSupport;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionFactory;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.freemarker.model.UrlBean;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.ForbiddenException;+import org.keycloak.theme.Theme;++public class DeleteAccount implements RequiredActionProvider, RequiredActionFactory {++  public static final String PROVIDER_ID = ""delete_account"";++  private static final Logger logger = Logger.getLogger(DeleteAccount.class);++  @Override+  public String getDisplayText() {+    return ""Delete Account"";+  }++  @Override+  public void evaluateTriggers(RequiredActionContext context) {++  }++  @Override+  public void requiredActionChallenge(RequiredActionContext context) {+    KeycloakSession session = context.getSession();+    RealmModel realm = context.getRealm();++    Theme theme = null;++    try {+      theme = session.theme().getTheme(Theme.Type.LOGIN);+    }+    catch (IOException e) {+      logger.error(""failed to read theme: "", e);+      context.failure();+    }++    context.challenge(context.form().setAttribute(""url"", new UrlBean(realm, theme, context.getUriInfo().getBaseUri(), context.getActionUrl())).createForm(""delete-account-confirm.ftl""));",Setting the `url` attribute is not necessary here. It's already part of:https://github.com/keycloak/keycloak/blob/5b017e930dc791f0bdb1a74b31d0852636facb8a/services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java#L405,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7184,450975309,2020-07-07T16:01:25Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PathCache.java,"@@ -42,14 +43,17 @@      private final long maxAge;     private final boolean enabled;+    private final Map<String, PathConfig> paths;+    private final PolicyEnforcerConfig config;",This is unused,X
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7184,450977316,2020-07-07T16:04:37Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PolicyEnforcer.java,"@@ -263,20 +267,35 @@ public PathConfig matches(String targetUri) {             pathConfig = super.matches(targetUri);              if (enforcerConfig.getLazyLoadPaths() || enforcerConfig.getPathCacheConfig() != null) {",Why are we doing lazy loading even if lazy loading is disabled and cache is enabled?: `|| enforcerConfig.getPathCacheConfig() != null`?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7184,450979845,2020-07-07T16:08:31Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PolicyEnforcer.java,"@@ -263,20 +267,35 @@ public PathConfig matches(String targetUri) {             pathConfig = super.matches(targetUri);              if (enforcerConfig.getLazyLoadPaths() || enforcerConfig.getPathCacheConfig() != null) {-                if ((pathConfig == null || (pathConfig.getPath().contains(""*"")))) {+                if ((pathConfig == null || pathConfig.isInvalidated() || pathConfig.getPath().contains(""*""))) {                     try {                         List<ResourceRepresentation> matchingResources = authzClient.protection().resource().findByMatchingUri(targetUri); -                        if (!matchingResources.isEmpty()) {+                        if (matchingResources.isEmpty()) {+                            // if this config is invalidated (e.g.: due to cache expiration) we remove and return null+                            if (pathConfig != null && pathConfig.isInvalidated()) {+                                paths.remove(targetUri);+                                return null;+                            }+                        } else {                             Map<String, Map<String, Object>> cipConfig = null;                             PolicyEnforcerConfig.EnforcementMode enforcementMode = PolicyEnforcerConfig.EnforcementMode.ENFORCING;+                            ResourceRepresentation targetResource = matchingResources.get(0);                              if (pathConfig != null) {                                 cipConfig = pathConfig.getClaimInformationPointConfig();                                 enforcementMode = pathConfig.getEnforcementMode();+                            } else {+                                for (PathConfig existingPath : paths.values()) {+                                    if (existingPath.getId().equals(targetResource.getId()) +                                            && existingPath.isStatic()+                                            && !PolicyEnforcerConfig.EnforcementMode.DISABLED.equals(existingPath.getEnforcementMode())) {","Could you please elaborate a little bit more on why is this condition necessary? I would understand it without the exclamation mark in the last condition, but not with it. Maybe in some example situation when this happens.",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,450983125,2020-07-07T16:13:19Z,services/src/main/java/org/keycloak/authentication/requiredactions/DeleteAccount.java,"@@ -0,0 +1,156 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import java.io.IOException;+import java.util.Objects;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.InitiatedActionSupport;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionFactory;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.freemarker.model.UrlBean;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.ForbiddenException;+import org.keycloak.theme.Theme;++public class DeleteAccount implements RequiredActionProvider, RequiredActionFactory {++  public static final String PROVIDER_ID = ""delete_account"";++  private static final Logger logger = Logger.getLogger(DeleteAccount.class);++  @Override+  public String getDisplayText() {+    return ""Delete Account"";+  }++  @Override+  public void evaluateTriggers(RequiredActionContext context) {++  }++  @Override+  public void requiredActionChallenge(RequiredActionContext context) {+    KeycloakSession session = context.getSession();+    RealmModel realm = context.getRealm();++    Theme theme = null;++    try {+      theme = session.theme().getTheme(Theme.Type.LOGIN);+    }+    catch (IOException e) {+      logger.error(""failed to read theme: "", e);+      context.failure();+    }++    context.challenge(context.form().setAttribute(""url"", new UrlBean(realm, theme, context.getUriInfo().getBaseUri(), context.getActionUrl())).createForm(""delete-account-confirm.ftl""));+  }+++  @Override+  public void processAction(RequiredActionContext context) {+    KeycloakSession session = context.getSession();+    EventBuilder eventBuilder = context.getEvent();+    KeycloakContext keycloakContext = session.getContext();+    RealmModel realm = keycloakContext.getRealm();+    UserModel user = keycloakContext.getAuthenticationSession().getAuthenticatedUser();++    try {+      ClientModel accountClient = session.clientStorageManager().getClientByClientId(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID, realm);+      checkClientHasDeleteAccountRole(accountClient);+      session.sessions().removeUserSessions(realm, user);+      session.users().removeUser(realm, user);+      session.userStorageManager().removeUser(realm, user);",Should we use `UserManager` instead?https://github.com/keycloak/keycloak/blob/76bfbad2c46732ba0a827972754557bb172435f2/server-spi/src/main/java/org/keycloak/models/UserManager.java#L31-L33I guess we want to use some existing logic for this to e.g. fire the standard `UserRemoved` event as well (some listeners might be relying on this).Also I don't think we need to manually remove user sessions.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,450986091,2020-07-07T16:18:07Z,services/src/main/java/org/keycloak/authentication/requiredactions/DeleteAccount.java,"@@ -0,0 +1,160 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import java.io.IOException;+import java.util.Objects;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.InitiatedActionSupport;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionFactory;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.freemarker.model.UrlBean;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.ForbiddenException;+import org.keycloak.theme.Theme;++public class DeleteAccount implements RequiredActionProvider, RequiredActionFactory {++  public static final String PROVIDER_ID = ""delete_account"";++  private static final Logger logger = Logger.getLogger(DeleteAccount.class);++  @Override+  public String getDisplayText() {+    return ""Delete Account"";+  }++  @Override+  public void evaluateTriggers(RequiredActionContext context) {++  }++  @Override+  public void requiredActionChallenge(RequiredActionContext context) {+    KeycloakSession session = context.getSession();+    RealmModel realm = context.getRealm();++    createChallengeResponse(context, session, realm);+  }+++  @Override+  public void processAction(RequiredActionContext context) {+    KeycloakSession session = context.getSession();+    EventBuilder eventBuilder = context.getEvent();+    KeycloakContext keycloakContext = session.getContext();+    RealmModel realm = keycloakContext.getRealm();+    UserModel user = keycloakContext.getAuthenticationSession().getAuthenticatedUser();++    try {+      ClientModel accountClient = session.clientStorageManager().getClientByClientId(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID, realm);+      checkClientHasDeleteAccountRole(accountClient);+      session.sessions().removeUserSessions(realm, user);+      session.users().removeUser(realm, user);+      session.userStorageManager().removeUser(realm, user);","I agree with @stianst here. We should check if user has the role (that belongs to the account client, so it's not a realm role).",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,450987813,2020-07-07T16:20:53Z,services/src/main/java/org/keycloak/authentication/requiredactions/DeleteAccount.java,"@@ -0,0 +1,156 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import java.io.IOException;+import java.util.Objects;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.InitiatedActionSupport;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionFactory;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.freemarker.model.UrlBean;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.ForbiddenException;+import org.keycloak.theme.Theme;++public class DeleteAccount implements RequiredActionProvider, RequiredActionFactory {++  public static final String PROVIDER_ID = ""delete_account"";++  private static final Logger logger = Logger.getLogger(DeleteAccount.class);++  @Override+  public String getDisplayText() {+    return ""Delete Account"";+  }++  @Override+  public void evaluateTriggers(RequiredActionContext context) {++  }++  @Override+  public void requiredActionChallenge(RequiredActionContext context) {+    KeycloakSession session = context.getSession();+    RealmModel realm = context.getRealm();++    Theme theme = null;++    try {+      theme = session.theme().getTheme(Theme.Type.LOGIN);+    }+    catch (IOException e) {+      logger.error(""failed to read theme: "", e);+      context.failure();+    }++    context.challenge(context.form().setAttribute(""url"", new UrlBean(realm, theme, context.getUriInfo().getBaseUri(), context.getActionUrl())).createForm(""delete-account-confirm.ftl""));+  }+++  @Override+  public void processAction(RequiredActionContext context) {+    KeycloakSession session = context.getSession();+    EventBuilder eventBuilder = context.getEvent();+    KeycloakContext keycloakContext = session.getContext();+    RealmModel realm = keycloakContext.getRealm();+    UserModel user = keycloakContext.getAuthenticationSession().getAuthenticatedUser();++    try {+      ClientModel accountClient = session.clientStorageManager().getClientByClientId(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID, realm);+      checkClientHasDeleteAccountRole(accountClient);+      session.sessions().removeUserSessions(realm, user);+      session.users().removeUser(realm, user);+      session.userStorageManager().removeUser(realm, user);++      eventBuilder.clone().event(EventType.DELETE_ACCOUNT).client(keycloakContext.getClient()).user(user)","I don't think you need to clone the `eventBuilder`, right?",
6265563,zak905,https://api.github.com/repos/keycloak/keycloak/pulls/7176,451065392,2020-07-07T18:35:02Z,themes/src/main/resources/theme/keycloak-preview/account/resources/content.json,"@@ -56,5 +56,14 @@     ""modulePath"": ""/content/my-resources-page/MyResourcesPage.js"",     ""componentName"": ""MyResourcesPage"",     ""hidden"": ""!features.isMyResourcesEnabled""+  },+  {+    ""id"": ""deleteAccount"",",maybe the `fa-trash` or `pf-icon-delete` ? https://www.patternfly.org/v4/design-guidelines/styles/icons,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,451512595,2020-07-08T12:39:43Z,server-spi-private/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionProvider.java,"@@ -0,0 +1,47 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import org.keycloak.provider.Provider;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.clientpolicy.ClientPolicyException;++/**+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.+ * It is sufficient for the implementer of this condition to implement methods in which they are interested+ * and {@link isEvaluatedOnEvent} method.+ */+public interface ClientPolicyConditionProvider extends Provider {++    final String SKIP_EVALUATION = ""skip-evaluation"";","I don't like the use of an exception in this way.What about something like:default Vote applyPolicy(ClientPolicyContext context)Where Vote is an enum with values YES, NO, ABSTAIN",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7104,451515783,2020-07-08T12:45:05Z,services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java,"@@ -0,0 +1,157 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.HashMap;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.common.Profile;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyManager;+import org.keycloak.services.clientpolicy.ClientPolicyProvider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;++public class DefaultClientPolicyManager implements ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(DefaultClientPolicyManager.class);++    private final KeycloakSession session;+    private final Map<String, List<ClientPolicyProvider>> providersMap = new HashMap<>();++    public DefaultClientPolicyManager(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public void triggerOnEvent(ClientPolicyContext context) throws ClientPolicyException {+        if (!Profile.isFeatureEnabled(Profile.Feature.CLIENT_POLICIES)) return;+        ClientPolicyLogger.logv(logger, ""Client Policy Operation : event = {0}"", context.getEvent());+        doPolicyOperation(+                (ClientPolicyConditionProvider condition) -> condition.isSatisfiedOnEvent(context),+                (ClientPolicyExecutorProvider executor) -> executor.executeOnEvent(context)+            );+    }++    private void doPolicyOperation(ClientConditionOperation condition, ClientExecutorOperation executor) throws ClientPolicyException {+        RealmModel realm = session.getContext().getRealm();+        for (ClientPolicyProvider policy : getProviders(realm)) {+            ClientPolicyLogger.logv(logger, ""Policy Operation : name = {0}, provider id = {1}"", policy.getName(), policy.getProviderId());+            if (!isSatisfied(policy, condition)) continue;+            execute(policy, executor);+        }+    }++    private List<ClientPolicyProvider> getProviders(RealmModel realm) {+        List<ClientPolicyProvider> providers = providersMap.get(realm.getId());+        if (providers == null) {+            providers = new LinkedList<>();+            List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());+            for (ComponentModel policyModel : policyModels) {+                try {+                    ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);+                    ClientPolicyLogger.logv(logger, ""Loaded Policy Name = {0}"", policyModel.getName());+                    session.enlistForClose(policy);+                    providers.add(policy);+                } catch (Throwable t) {+                    logger.errorv(t, ""Failed to load provider {0}"", policyModel.getId());+                }+            }+            providersMap.put(realm.getId(), providers);+        } else {+            ClientPolicyLogger.log(logger, ""Use cached policies."");+        }+        return providers;+    }++    private boolean isSatisfied(+            ClientPolicyProvider policy,+            ClientConditionOperation op) {++        List<ClientPolicyConditionProvider> conditions = policy.getConditions();++        if (conditions == null || conditions.isEmpty()) {+            ClientPolicyLogger.log(logger, ""NEGATIVE :: This policy is not applied. No condition exists."");+            return false;+        }++        boolean ret = false;+        for (ClientPolicyConditionProvider condition : conditions) {+            try {+                if (!op.run(condition)) {+                    ClientPolicyLogger.logv(logger, ""NEGATIVE :: This policy is not applied. condition not satisfied. name = {0}, provider id = {1}, "", condition.getName(), condition.getProviderId());+                    return false;+                } else {+                    ret = true;+                }+            } catch (ClientPolicyException cpe) {+                if (cpe.getError().equals(ClientPolicyConditionProvider.SKIP_EVALUATION)) {+                    ClientPolicyLogger.logv(logger, ""SKIP : This condition is not evaluated due to its nature. name = {0}, provider id = {1}"", condition.getName(), condition.getProviderId());+                    continue;+                }+                ClientPolicyLogger.logv(logger, ""CONDITION EXCEPTION : name = {0}, provider id = {1}, error = {2}, error_detail = {3}"", condition.getName(), condition.getProviderId(), cpe.getError(), cpe.getErrorDetail());+                return false;",Thinking about this some more I wonder if skipping the policies on an exception is a good thing. It could result in some error in a condition resulting in accepting things that shouldn't be accepted. Wonder if we should fail the request in this case instead.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7184,451797214,2020-07-08T20:09:21Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PolicyEnforcer.java,"@@ -263,20 +267,35 @@ public PathConfig matches(String targetUri) {             pathConfig = super.matches(targetUri);              if (enforcerConfig.getLazyLoadPaths() || enforcerConfig.getPathCacheConfig() != null) {","To be honest, I don't know the exact reason. This is also something I would like to check and possibly remove so that we only fetch resources if lazy load is enabled. There must be some use case in test that relies on it.We can create a JIRA and look at that more closely.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7246,452016642,2020-07-09T07:26:15Z,saml-core/src/main/java/org/keycloak/saml/processing/core/saml/v2/writers/BaseWriter.java,"@@ -174,6 +175,8 @@ public void writeAttributeTypeWithoutRootTag(AttributeType attributeType) throws                     	writeNameIDTypeAttributeValue((NameIDType) attributeValue);                     } else if (attributeValue instanceof XMLGregorianCalendar) {                         writeDateAttributeValue((XMLGregorianCalendar) attributeValue);+                    } else if (attributeValue instanceof Element) {+                        StaxUtil.writeDOMElement(writer, (Element) attributeValue);","Currently it is expected that `attributeValue` starts with `AttributeValue` element. Yet for the sake of consistency with the rest of the values and enforcing schema compliance, the attribute value should only be the value without `AttributeValue`. In other words, introduce a `writeElementAttributeValue(Element attributeValue)` method similar to e.g. `writeNameIDTypeAttributeValue`",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7007,452036172,2020-07-09T08:02:09Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -121,6 +125,10 @@ public Response performLogin(AuthenticationRequest request) {                 authnRequest = it.next().beforeSendingLoginRequest(authnRequest, request.getAuthenticationSession());             } +            destinationUrl = ofNullable(authnRequest.getDestination())+                    .map(URI::toString)+                    .orElseThrow(() -> new IdentityBrokerException(""No destination in login request""));+","There should be no exception thrown. The destination is attribute only mandatory in certain cases, see the SAML spec above.The code should be similar to:```javaif (authnRequest.getDestination() != null) {    destinationUrl = authnRequest.getDestination().toString();}```Similar code needs to be in `keycloakInitiatedBrowserLogout` and `backchannelLogout` methods.",
35632862,mwalliczek,https://api.github.com/repos/keycloak/keycloak/pulls/7246,452055285,2020-07-09T08:35:35Z,saml-core/src/main/java/org/keycloak/saml/processing/core/saml/v2/writers/BaseWriter.java,"@@ -174,6 +175,8 @@ public void writeAttributeTypeWithoutRootTag(AttributeType attributeType) throws                     	writeNameIDTypeAttributeValue((NameIDType) attributeValue);                     } else if (attributeValue instanceof XMLGregorianCalendar) {                         writeDateAttributeValue((XMLGregorianCalendar) attributeValue);+                    } else if (attributeValue instanceof Element) {+                        StaxUtil.writeDOMElement(writer, (Element) attributeValue);","Thanks for the suggestions - I changed the code in the proposed way. Because the type of the AttributeValue is variable, I created a new AttributeValueElementType class to contain both the type and the element.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7004,452080185,2020-07-09T09:17:29Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -91,13 +93,15 @@ public Response performLogin(AuthenticationRequest request) {                 protocolBinding = JBossSAMLURIConstants.SAML_HTTP_POST_BINDING.get();             } +            String loginHint = request.getHttpRequest().getUri().getQueryParameters().getFirst(LOGIN_HINT_QUERY_PARAMETER);","This needs to be guarded by a configuration that mimics OIDC identity provider `loginHint` configuration which will be disabled by default:1. Move `OAuth2IdentityProviderConfig`'s `isLoginHint` and `setLoginHint` to IdentityProviderModel2. Add a `QueryParam(OIDCLoginProtocol.LOGIN_HINT_PARAM)` to authentication session in `IdentityBrokerService.performLogin` similarly to https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java#L4453. In this place, only use `request.getAuthenticationSession().getClientNote(OIDCLoginProtocol.LOGIN_HINT_PARAM)`Also update `realm-identity-provider-saml.html` to configure loginHint similarly to `realm-identity-provider-oidc.html`, and ensure that the label and label hint are properly adjusted to SAML terms.The tests need to check that the settings of the loginHint configuration in SAML identity provider respect the settings.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,452283732,2020-07-09T15:00:24Z,saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/metadata/SAMLMetadataQNames.java,"@@ -77,14 +77,15 @@     ATTR_IS_REQUIRED(null, ""isRequired""),     ATTR_NAME(null, ""Name""),     ATTR_NAME_FORMAT(null, ""NameFormat""),-+    ENTITY_ATTRIBUTES(JBossSAMLURIConstants.METADATA_ENTITY_ATTRIBUTES_NSURI, ""EntityAttributes""),","This belongs below to L 88, the namespace is other (see comment below)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,452293002,2020-07-09T15:13:13Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -52,6 +52,8 @@     public static final String WANT_ASSERTIONS_SIGNED = ""wantAssertionsSigned"";     public static final String WANT_AUTHN_REQUESTS_SIGNED = ""wantAuthnRequestsSigned"";     public static final String XML_SIG_KEY_INFO_KEY_NAME_TRANSFORMER = ""xmlSigKeyInfoKeyNameTransformer"";+    public static final String HIDE_ON_LOGIN = ""hideOnLoginPage"";+    public static final String ENABLED = ""enabled"";","In that case it is necessary to use a specific name, plain `enable` would be confusing with the property above.```suggestion    public static final String ENABLED_FROM_METADATA = ""enabledFromMetadata"";```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,452296648,2020-07-09T15:18:37Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -965,6 +965,9 @@ module.controller('RealmIdentityProviderCtrl', function($scope, $filter, $upload         for (var key in data) {             $scope.identityProvider.config[key] = data[key];         }+        if (data[""enabled""] != undefined) {+            $scope.identityProvider.enabled = data[""enabled""];","```suggestion        if (data[""enabledFromMetadata""] !== undefined) {            $scope.identityProvider.enabled = data[""enabledFromMetadata""];```(Please note `!==` and not `!=`)",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7231,452441599,2020-07-09T19:28:02Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -495,13 +495,13 @@ public void evictRealmOnRemoval(RealmModel realm) {      @Override     public ClientModel addClient(RealmModel realm, String clientId) {",What about this method and the other client-specific methods? Should we introduce a `ClientCacheSession` class and move this functionality there or is this class meant to serve as `CacheSession` for both of them and then maybe we could rename it?,
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,452696531,2020-07-10T08:21:05Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderFactory.java,"@@ -152,6 +158,18 @@ public SAMLIdentityProviderConfig createConfig() {                             samlIdentityProviderConfig.setEncryptionPublicKey(defaultCertificate);                         }                     }+                    +                    samlIdentityProviderConfig.setEnabledConfig(entityType.getValidUntil() == null || entityType.getValidUntil().toGregorianCalendar().getTime().after(new Date()) );+                    +                	//check for hide on login attribute+        			if ( entityType.getExtensions() != null && entityType.getExtensions().getEntityAttributes() != null ) {+        			    for (AttributeType attribute :  entityType.getExtensions().getEntityAttributes().getAttribute()) {+        				    if (MACEDIR_ENTITY_CATEGORY.equals(attribute.getName()) && attribute.getAttributeValue().contains(REFEDS_HIDE_FROM_DISCOVERY) )",attributeValue is a List in class AttributeType which is instantiated as empty list as you can see.Moreover it is error to check equality between String and List.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7021,452795965,2020-07-10T11:52:15Z,themes/src/main/resources/theme/base/admin/resources/partials/realm-identity-provider-github-ext.html,"@@ -0,0 +1,18 @@+<fieldset>","I wouldn't use override section for this at all. IMHO it can be placed directly among other config options. Look e.g. at PayPal. It has a sandbox settings (which effectively changes the endpoints) and it's not placed in a collapsed section.If we place in in the collapsed override section, that section should probably be placed at the very bottom, similarly to e.g. client config.",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7021,452798870,2020-07-10T11:59:14Z,services/src/test/java/org/keycloak/social/github/GitHubIdentityProviderTest.java,"@@ -0,0 +1,73 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.social.github;++import static org.junit.Assert.*;++import org.junit.Test;+import org.keycloak.broker.oidc.OAuth2IdentityProviderConfig;++/**+ * Unit test for {@link org.keycloak.social.github.GitHubIdentityProvider}.+ *+ * @author Neon Ngo+ */+public class GitHubIdentityProviderTest {","Since our options are a bit limited here (we don't have the test environment for this, i.e GitHub Enterprise), I'd imagine something like:1. Configure GitHub IdP with overiden endpoints using REST API (like other tests in the class do).2. Invoke login using that IdP and check you were redirected to correct (non-existing) URL.I don't think we can do much more here.",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,452843979,2020-07-10T13:29:51Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/IdentityProviderTest.java,"@@ -608,6 +609,11 @@ public void testSamlImportAndExport() throws URISyntaxException, IOException, Pa         form.addFormData(""file"", body, MediaType.APPLICATION_XML_TYPE, ""saml-idp-metadata.xml"");          Map<String, String> result = realm.identityProviders().importFrom(form);+       //firtsly check and remove enabled from result","I will add seperate test method for disabled IdP.The difference between enabledFromMetadata with others properties is that enabledFromMetadata is not existed in config that saved in database. Moreover, assertSamlConfig is executed again after retrieving IdP from database. I will made appropriate changes to test in order to check appropriate value of enabledFromMetadata  and enable field for enabled and disabled IdP.",X
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,452854300,2020-07-10T13:47:29Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/IdentityProviderTest.java,"@@ -608,6 +609,11 @@ public void testSamlImportAndExport() throws URISyntaxException, IOException, Pa         form.addFormData(""file"", body, MediaType.APPLICATION_XML_TYPE, ""saml-idp-metadata.xml"");          Map<String, String> result = realm.identityProviders().importFrom(form);+       //firtsly check and remove enabled from result+        boolean enabled = Boolean.valueOf(result.get(""enabled""));+        result.remove(""enabled"");","I strongly agree with you. However, in class IdentityProviderTest only literals are used and I want class writing to be similar.If you insist, I could add literal for this or for all config properties.",
35632862,mwalliczek,https://api.github.com/repos/keycloak/keycloak/pulls/7246,453472610,2020-07-13T08:10:54Z,saml-core-api/src/main/java/org/keycloak/dom/saml/v2/assertion/AttributeValueElementType.java,"@@ -0,0 +1,27 @@+package org.keycloak.dom.saml.v2.assertion;++import java.io.Serializable;++import org.w3c.dom.Element;++public class AttributeValueElementType implements Serializable {++    private String type;","I just read the specification one more time and I think you were right with the first comment: The type attribute at attributeValue is obsolete, when the child is an element with its own type and namespace declaration.The type is only necessary at simple elements like string and date, but not at complex elements.So I removed the type and the AttributeValueType completly.Sorry for the confusion.",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,453481185,2020-07-13T08:30:54Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderFactory.java,"@@ -152,6 +158,18 @@ public SAMLIdentityProviderConfig createConfig() {                             samlIdentityProviderConfig.setEncryptionPublicKey(defaultCertificate);                         }                     }+                    +                    samlIdentityProviderConfig.setEnabledConfig(entityType.getValidUntil() == null || entityType.getValidUntil().toGregorianCalendar().getTime().after(new Date()) );",new Date() return Keycloak server local Date time.Time class you mean org.keycloak.common.util.Time? This method return second and Java Date(long date) wait for milliseconds.If you insist I could write it as : samlIdentityProviderConfig.setEnabledConfig(entityType.getValidUntil() == null || entityType.getValidUntil().toGregorianCalendar().getTime().after(new Date(Time.currentTime() * 1000)) );,
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,453496667,2020-07-13T08:55:19Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -965,6 +965,9 @@ module.controller('RealmIdentityProviderCtrl', function($scope, $filter, $upload         for (var key in data) {             $scope.identityProvider.config[key] = data[key];         }+        if (data[""enabled""] != undefined) {+            $scope.identityProvider.enabled = data[""enabled""];","Ok.Moreover, I observed that if I import an enabled SAML IdP , enabled will be off although enabledFromMetadata will be true.If I change onoffswitch attribute to onoffswitchvalue ( realm-identity-provider-saml.html line 39) , import will work correctly. However, when admin create or edit SAML Idp, enabled is always off. The problem is that identityProvider.enabled is initiated as boolean and data return string as value.How should I write code correctly without changing app.js ( lines 2236-2366)?",
8242900,looorent,https://api.github.com/repos/keycloak/keycloak/pulls/7007,453512137,2020-07-13T09:19:48Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -162,6 +167,12 @@ public void backchannelLogout(KeycloakSession session, UserSessionModel userSess         JaxrsSAML2BindingBuilder binding = buildLogoutBinding(session, userSession, realm);         try {             LogoutRequestType logoutRequest = buildLogoutRequest(userSession, uriInfo, realm, singleLogoutServiceUrl);+            if (logoutRequest.getDestination() != null) {+                singleLogoutServiceUrl = logoutRequest.getDestination().toString();+            } else {","I managed this case exactly as it is done a few lines above. This method does not support blank values for `singleLogoutServiceUrl`, should we allow blank values after building the logout request anyway?https://github.com/keycloak/keycloak/blob/f8a4f66d6c183de894a8a436f9e35dfa3248e862/services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java#L163",
8242900,looorent,https://api.github.com/repos/keycloak/keycloak/pulls/7007,453513305,2020-07-13T09:21:36Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -186,6 +197,11 @@ public Response keycloakInitiatedBrowserLogout(KeycloakSession session, UserSess        } else {             try {                 LogoutRequestType logoutRequest = buildLogoutRequest(userSession, uriInfo, realm, singleLogoutServiceUrl);+                if (logoutRequest.getDestination() != null) {+                    singleLogoutServiceUrl = logoutRequest.getDestination().toString();+                } else {+                    return null;",Same answer as above. This is inspired from this existing line:https://github.com/keycloak/keycloak/blob/f8a4f66d6c183de894a8a436f9e35dfa3248e862/services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java#L183,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7231,454163186,2020-07-14T07:37:41Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -495,13 +495,13 @@ public void evictRealmOnRemoval(RealmModel realm) {      @Override     public ClientModel addClient(RealmModel realm, String clientId) {","Yup, in the long term, this should be the way. This will be handled as part of the caching layer in store.x in some of the follow-up PR",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,454275631,2020-07-14T11:01:38Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -965,6 +965,9 @@ module.controller('RealmIdentityProviderCtrl', function($scope, $filter, $upload         for (var key in data) {             $scope.identityProvider.config[key] = data[key];         }+        if (data[""enabled""] != undefined) {+            $scope.identityProvider.enabled = data[""enabled""];","```suggestion            $scope.identityProvider.enabled = data[""enabledFromMetadata""] == ""true"";```",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7111,454293007,2020-07-14T11:37:22Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -965,6 +965,9 @@ module.controller('RealmIdentityProviderCtrl', function($scope, $filter, $upload         for (var key in data) {             $scope.identityProvider.config[key] = data[key];         }+        if (data[""enabled""] != undefined) {+            $scope.identityProvider.enabled = data[""enabled""];","You are right. However, if must exists for other Identity Providers like OIDC. In these Identity Providers enabledFromMetadata will not exist in data.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7227,454620958,2020-07-14T20:22:29Z,model/jpa/src/main/java/org/keycloak/authorization/jpa/store/JPAResourceStore.java,"@@ -145,15 +145,7 @@ private void findByOwnerFilter(String ownerId, String resourceServerId, Consumer         }          ResourceStore resourceStore = provider.getStoreFactory().getResourceStore();-        List<String> result = query.getResultList();--        for (String entity : result) {-            Resource cached = resourceStore.findById(entity, resourceServerId);-            -            if (cached != null) {-                consumer.accept(cached);-            }-        }+        query.getResultStream().map(id -> resourceStore.findById(id.getId(), resourceServerId)).forEach(consumer);","But now it is doing a request for the same ResrouceEntity twice. You get a list of ResrouceEntity (not only id but full ResourceEntity), then for each ResrouceEntity you just get `id`, and then do another request for ResrouceEntity, which was already loaded by the previous query. You probably want to change `r` to `r.id` [here](https://github.com/keycloak/keycloak/pull/7227/files#diff-99e590ff1a5d4b89767173cfa4708f88R60) to not have two queries for the same ResrouceEntity. Or am I missing something?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,454998386,2020-07-15T12:01:37Z,services/src/main/java/org/keycloak/storage/ClientStorageManager.java,"@@ -151,14 +153,18 @@ public ClientModel getClientByClientId(String clientId, RealmModel realm) {     }      @Override-    public List<ClientModel> searchClientsByClientId(String clientId, Integer firstResult, Integer maxResults, RealmModel realm) {-        List<ClientModel> clients = session.clientLocalStorage().searchClientsByClientId(clientId,  firstResult, maxResults, realm);-        if (clients != null) {-            return clients;+    public Stream<ClientModel> searchClientsByClientIdStream(String clientId, Integer firstResult, Integer maxResults, RealmModel realm) {+        Stream<ClientModel> clients = session.clientLocalStorage().searchClientsByClientIdStream(clientId,  firstResult, maxResults, realm);+        Iterator<ClientModel> iterator = clients.iterator();+        if (iterator.hasNext()) {+            return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false);         }         for (ClientLookupProvider provider : getEnabledStorageProviders(session, realm, ClientLookupProvider.class)) {-            clients = provider.searchClientsByClientId(clientId, firstResult, maxResults, realm);-            if (clients != null) return clients;+            clients = provider.searchClientsByClientIdStream(clientId, firstResult, maxResults, realm);+            iterator = clients.iterator();+            if (iterator.hasNext()) {+                return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false);+            }","Could be perhaps like this:```javaStream<ClientModel> local = session.clientLocalStorage().searchClientsByClientIdStream(clientId,  firstResult, maxResults, realm);Stream<ClientModel> ext = getEnabledStorageProviders(session, realm, ClientLookupProvider.class).stream()    .map(p -> p.searchClientsByClientIdStream(clientId,  firstResult, maxResults, realm))    .flatMap(Function.identity());return Stream.concat(local, ext);```",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7231,455562664,2020-07-16T07:21:04Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/ClientAdapter.java,"@@ -53,7 +53,7 @@ public ClientAdapter(RealmModel cachedRealm, CachedClient cached, RealmCacheSess     private void getDelegateForUpdate() {         if (updated == null) {             cacheSession.registerClientInvalidation(cached.getId(), cached.getClientId(), cachedRealm.getId());-            updated = cacheSession.getRealmDelegate().getClientById(cached.getId(), cachedRealm);+            updated = cacheSession.getClientDelegate().getClientById(cached.getId(), cachedRealm);","```suggestion            updated = cacheSession.getClientDelegate().getClientById(cachedRealm, cached.getId());```We should use new non-deprecated method instead. Newly depricated `ClientLookupProvider.getClientById(String, RealmModel)`, `ClientLookupProvider.getClientByClientId(String, RealmModel)` and `ClientLookupProvider.searchClientsByClientId(String, Integer, Integer, RealmModel)` are used in several places in codebase including testsuite.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7231,455564281,2020-07-16T07:24:17Z,server-spi/src/main/java/org/keycloak/models/ClientProvider.java,"@@ -20,30 +20,92 @@ import org.keycloak.storage.client.ClientLookupProvider;  import java.util.List;-import java.util.Set;  /**+ * Provider of the client records.+ *  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>  * @version $Revision: 1 $  */ public interface ClientProvider extends ClientLookupProvider, Provider {++    /**+     * Returns the clients of the given realm.+     * @param realm Realm.+     * @param firstResult First result to return. Ignored if negative or {@code null}.+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.+     * @return List of the clients. Never returns {@code null}.+     */     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults); -    List<ClientModel> getClients(RealmModel realm);+    /**+     * Returns all the clients of the given realm.+     * Effectively the same as the call {@code getClients(realm, null, null)}.+     * @param realm Realm.+     * @return List of the clients. Never returns {@code null}.+     */+    default List<ClientModel> getClients(RealmModel realm) {+        return this.getClients(realm, null, null);+    } -    ClientModel addClient(RealmModel realm, String clientId);+    /**+     * Adds a client with given {@code clientId} to the given realm.+     * The internal ID of the client will be created automatically.+     * @param realm Realm owning this client.+     * @param clientId String that identifies the client to the external parties.+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.+     * @return Model of the created client.+     */+    default ClientModel addClient(RealmModel realm, String clientId) {+        return addClient(realm, null, clientId);+    } +    /**+     * Adds a client with given internal ID and {@code clientId} to the given realm.+     * @param realm Realm owning this client.+     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store+     * @param clientId String that identifies the client to the external parties.+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.+     * @return Model of the created client.+     * @throws IllegalArgumentException If {@code id} does not conform+     *   the format understood by the underlying store.+     */     ClientModel addClient(RealmModel realm, String id, String clientId); -    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);--    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);+    /**+     * Returns number of clients in the given realm+     * @param realm Realm.+     * @return Number of the clients in the given realm.+     */+    long getClientsCount(RealmModel realm); -    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);+    /**+     * Returns a list of clients that are expected to always show up in account console.+     * @param realm Realm owning the clients.+     * @return List of the clients. Never returns {@code null}.+     */+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm); -    Set<RoleModel> getClientRoles(RealmModel realm, ClientModel client);+    /**+     * Removes given client from the given realm.+     * @param id Internal ID of the client+     * @param realm Realm.+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.+     * @deprecated Use {@link #removeClient(RealmModel, String)} instead.+     */+    default boolean removeClient(String id, RealmModel realm) { return this.removeClient(realm, id); }","dtto, this deprecated method is still used in the codebase",X
8414918,iankko,https://api.github.com/repos/keycloak/keycloak/pulls/7157,455690856,2020-07-16T10:36:23Z,distribution/feature-packs/server-feature-pack/src/main/resources/licenses/keycloak/licenses.xml,"@@ -103,7 +103,7 @@     <dependency>       <groupId>org.codehaus.plexus</groupId>       <artifactId>plexus-utils</artifactId>-      <version>3.0.22</version>+      <version>3.1.1</version>",Spoken with @martin-kanis further about this. And looks there's a licenses dependency cleanup necessary. It will be done in the future (tracked via [KEYCLOAK-14792](https://issues.redhat.com/browse/KEYCLOAK-14792) issue),
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7104,455943165,2020-07-16T17:13:34Z,services/src/main/java/org/keycloak/services/clientpolicy/ClientUpdateContext.java,"@@ -0,0 +1,75 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import org.keycloak.models.ClientModel;+import org.keycloak.models.UserModel;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.representations.idm.ClientRepresentation;++/**+ * Represents the context in the client registration/update by Dynamic Client Registration or Admin REST API.+ */+public interface ClientUpdateContext extends ClientPolicyContext {","Does this interface need to have default methods? I see that most of the implementations need to override all the methods (with the exception of getClientToBeUpdated in case of ""Register"" classes). IMO it will be better if this interface don't have default methods - maybe with the exception of ""getClientToBeUpdated"" method.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7104,455948930,2020-07-16T17:22:56Z,server-spi-private/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProvider.java,"@@ -0,0 +1,48 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.List;++import org.keycloak.provider.Provider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;++/**+ * Provides Client Policy which accommodates several Conditions and Executors.+ */+public interface ClientPolicyProvider extends Provider {","@tnorimat @stianst Maybe you discuss this already, but I am not 100% sure if ClientPolicyProvider need to be really Java provider? Isn't it rather just a ComponentModel?Per my understanding, the ClientPolicy provides binding between the set of conditions and executors. Hence usually I the typical administrator will create the policy instance in the admin console. And then he create some conditions and executors and bind them to this policy.I am probably missing some use-case why the ClientPolicyProvider is beneficial as a java provider rather than as a ""model"" ?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7104,455952890,2020-07-16T17:29:19Z,services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java,"@@ -0,0 +1,156 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.HashMap;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.common.Profile;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyManager;+import org.keycloak.services.clientpolicy.ClientPolicyProvider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;++public class DefaultClientPolicyManager implements ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(DefaultClientPolicyManager.class);++    private final KeycloakSession session;+    private final Map<String, List<ClientPolicyProvider>> providersMap = new HashMap<>();++    public DefaultClientPolicyManager(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public void triggerOnEvent(ClientPolicyContext context) throws ClientPolicyException {+        if (!Profile.isFeatureEnabled(Profile.Feature.CLIENT_POLICIES)) return;","@tnorimat @stianst I have some concerns about the security of this.I am thinking of some scenario like:- Administrator start the server with the CLIENT_POLICIES feature enabled- Administrator configures some client policies- Administrator restart the server, but he forgets to enable the CLIENT_POLICIES feature for some reason (For example he is migrating from one environment to another and startup commands are slightly different etc).- Client policies now won't be triggered at all, which can result in some potential unexpected issues (in theory even security issues).Do we want some better protection against this scenario? For example if CLIENT_POLICIES feature is not enabled, BUT there are some client policies in the DB, then throw the exception at startup - or at least big warning.I've just checked that for example WebAuthn works this way (If there is WebAuthn feature disabled BUT WebAuthn required action is registered in the realm, then the exception is thrown during attempt to authenticate user).",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7231,456374796,2020-07-17T11:04:20Z,server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java,"@@ -28,7 +28,66 @@  * @version $Revision: 1 $  */ public interface ClientLookupProvider {-    ClientModel getClientById(String id, RealmModel realm);-    ClientModel getClientByClientId(String clientId, RealmModel realm);-    List<ClientModel> searchClientsByClientId(String clientId, Integer firstResult, Integer maxResults, RealmModel realm);+    +    /**+     * Exact search for a client by its internal ID.+     * @param realm Realm to limit the search.+     * @param id Internal ID+     * @return Model of the client, or {@code null} if no client is found.+     */+    ClientModel getClientById(RealmModel realm, String id);++    /**+     * Exact search for a client by its internal ID.+     * @param realm Realm to limit the search.+     * @param id Internal ID+     * @return Model of the client, or {@code null} if no client is found.+     * @deprecated Use {@link #getClientById(org.keycloak.models.RealmModel, java.lang.String)} instead.+     */+    default ClientModel getClientById(String id, RealmModel realm) { return getClientById(realm, id); }++    /**+     * Exact search for a client by its public client identifier.+     * @param realm Realm to limit the search for clients.+     * @param clientId String that identifies the client to the external parties.+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.+     * @return Model of the client, or {@code null} if no client is found.+     */+    ClientModel getClientByClientId(RealmModel realm, String clientId);++    /**+     * Exact search for a client by its public client identifier.+     * @param realm Realm to limit the search.+     * @param clientId String that identifies the client to the external parties.+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.+     * @return Model of the client, or {@code null} if no client is found.+     * @deprecated Use {@link #getClientByClientId(org.keycloak.models.RealmModel, java.lang.String)} instead.+     */+    default ClientModel getClientByClientId(String clientId, RealmModel realm) { return getClientByClientId(realm, clientId); }++    /**+     * Case-insensitive search for clients that contain the given string in their public client identifier.+     * @param realm Realm to limit the search for clients.+     * @param clientId Searched substring of the public client+     *   identifier ({@code client_id} in OIDC or {@code entityID} in SAML.)+     * @param firstResult First result to return. Ignored if negative or {@code null}.+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.+     * @return Model of the client, or {@code null} if no client is found.+     * @deprecated Use {@link #searchClientsByClientId} instead.","This one is actually not deprecated, right?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7104,456423608,2020-07-17T12:54:52Z,services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java,"@@ -0,0 +1,156 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.util.HashMap;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.common.Profile;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyManager;+import org.keycloak.services.clientpolicy.ClientPolicyProvider;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;++public class DefaultClientPolicyManager implements ClientPolicyManager {++    private static final Logger logger = Logger.getLogger(DefaultClientPolicyManager.class);++    private final KeycloakSession session;+    private final Map<String, List<ClientPolicyProvider>> providersMap = new HashMap<>();++    public DefaultClientPolicyManager(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public void triggerOnEvent(ClientPolicyContext context) throws ClientPolicyException {+        if (!Profile.isFeatureEnabled(Profile.Feature.CLIENT_POLICIES)) return;","Yes, this is not the reason to block this PR in my opinion.This is probably not specific to this PR, but rather a general thing. I am not sure if some better care should be taken for various features/profiles to be enabled, configured and then accidentally disabled after migration to another environment. I can see the potential for unexpected issues and some of them even security related. But maybe I am just overthinking this :) We can see if someone reports some similar issue in the future...",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7021,456429834,2020-07-17T13:06:56Z,services/src/test/java/org/keycloak/social/github/GitHubIdentityProviderTest.java,"@@ -0,0 +1,73 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.social.github;++import static org.junit.Assert.*;++import org.junit.Test;+import org.keycloak.broker.oidc.OAuth2IdentityProviderConfig;++/**+ * Unit test for {@link org.keycloak.social.github.GitHubIdentityProvider}.+ *+ * @author Neon Ngo+ */+public class GitHubIdentityProviderTest {",We don't have such test but it's just a matter of adding new config record to the IdP. You can take some inspiration from [here](https://github.com/keycloak/keycloak/blob/4cd5ace80070c970b859fd15cb4ba80cafddf1a5/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/SocialLoginTest.java#L394),
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7155,457085038,2020-07-20T06:12:05Z,server-spi-private/src/main/java/org/keycloak/userprofile/AbstractUserProfileProvider.java,"@@ -0,0 +1,57 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public abstract class AbstractUserProfileProvider implements UserProfileProvider {",Remove this Abstract class it has no use,X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7155,457092311,2020-07-20T06:26:28Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfileProvider.java,"@@ -0,0 +1,35 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import org.keycloak.userprofile.util.UpdateUserProfileContext;+import org.keycloak.userprofile.validation.UserProfileValidationResult;+import org.keycloak.provider.Provider;+import org.keycloak.provider.ProviderFactory;+import org.keycloak.representations.idm.UserAttributesRepresentation;+import org.keycloak.userprofile.validation.ValidationScenario;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public interface UserProfileProvider extends Provider, ProviderFactory<UserProfileProvider> {++    UserProfileValidationResult validate(UserAttributesRepresentation rep, UpdateUserProfileContext user, ValidationScenario validationScenario);","`Representation` classes are used by Keycloak for REST endpoints, not for internal APIs. I also don't understand what the difference is between `rep` and `user`. Why are there two classes for the user profile values?For `ValidationScenario` I had to actually search for usage to figure out what the difference values meant as they where not quite clear to me. So I think there's some improvements that can be made there.For the validate method I had something like the following in mind:```UserProfileValidationResult validate(UserUpdateContext context)```````interface UserUpdateContext:boolean isCreate();UserUpdateEvent getEvent()UserProfile getCurrent() // Returns null if createUserProfile getUpdated()``````enum UserUpdateEvent:ADMIN, ACCOUNT, REQUIRED_ACTION, IDP``````interface UserProfile:String getId();String getName;getAttributes, etc.````UserProfile` is an interface so that a wrapper can be made for the different cases when a user profile is updated, without having to copy all values into the new class.```class UserProfileValidationResultboolean isValid();Map<String, Set<String>> getErrors();````UserProfileValidationResult` holds some sort of map with a string of error messages for keys. ",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7155,457095816,2020-07-20T06:32:40Z,server-spi-private/src/main/java/org/keycloak/userprofile/validation/UserProfileValidationResult.java,"@@ -0,0 +1,48 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile.validation;++import java.util.List;+import java.util.stream.Collectors;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public class UserProfileValidationResult {","I would expect validate to return only errors, not success. Hence it should just be a list of attributes that has not passed validation, and the error messages for them.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7231,457374425,2020-07-20T13:19:12Z,model/map/src/main/java/org/keycloak/models/map/common/Serialization.java,"@@ -0,0 +1,61 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common;++import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;+import com.fasterxml.jackson.annotation.JsonIgnore;+import com.fasterxml.jackson.annotation.JsonInclude;+import com.fasterxml.jackson.annotation.PropertyAccessor;+import com.fasterxml.jackson.databind.ObjectMapper;+import com.fasterxml.jackson.databind.SerializationFeature;+import java.io.IOException;++/**+ *+ * @author hmlnarik+ */+public class Serialization {++    public static final ObjectMapper MAPPER = new ObjectMapper();","> Does it need to be public?No, it need not, yet having it public helps in `ConcurrentHashMapStorageProvider` to use the same way of entity serialization as this ""cloning"" utility, and that in turn helps to debug issues with storing a representation of entities.> Wondering if public would cause people misusing this instance and not using the method.This instance should not be ordinarily visible to the public since model/map module (as well as any from the model/ modules) is not usually included as a dependency.> I think I understand why you have another instance of `ObjectMapper` and `JsonSerialization` is not enough. But is there some way to just reuse `JsonSerialization` ?Having these two separately is a better option, since the aim is to minimize impact on the existing code. The way of serialization is different (fields vs getters/setters), and aim is to have the entitites decoupled from serialization annotations. In the case of this `Serialization` class, jackson annotations on the fields (e.g. `@JsonIgnore`) are never in the entity, and are located in the serialization logics, i.e. in `Serialization` class. This makes it easy to decouple entities from their physical storage layout.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7231,457379093,2020-07-20T13:24:24Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientAdapter.java,"@@ -0,0 +1,540 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.client;++import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ProtocolMapperModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RoleModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import com.google.common.base.Functions;+import java.security.MessageDigest;+import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collection;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;++/**+ *+ * @author hmlnarik+ */+public abstract class MapClientAdapter extends AbstractClientModel<MapClientEntity> implements ClientModel {","`AbstractClientModel` only contains methods that operate on data that are not directly stored in entity and are delegated via `session` object. The implementation can choose to store the physical format (i.e. the entity) in any way - e.g. json, POJO, DB columns in tables - and should implement the `ClientModel` methods accordingly without any prescription from a predecessor.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7231,457393683,2020-07-20T13:40:29Z,model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java,"@@ -0,0 +1,508 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.client;++import org.keycloak.models.ProtocolMapperModel;+import org.keycloak.models.map.common.AbstractEntity;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.LinkedHashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Map.Entry;+import java.util.Objects;+import java.util.Set;+import java.util.function.Function;+import java.util.stream.Collectors;+import java.util.stream.Stream;++/**+ *+ * @author hmlnarik+ */+public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {++    private K id;+    private String realmId;++    private String clientId;+    private String name;+    private String description;+    private Set<String> redirectUris = new HashSet<>();+    private boolean enabled;+    private boolean alwaysDisplayInConsole;+    private String clientAuthenticatorType;+    private String secret;+    private String registrationToken;+    private String protocol;+    private Map<String, String> attributes = new HashMap<>();+    private Map<String, String> authFlowBindings = new HashMap<>();+    private boolean publicClient;+    private boolean fullScopeAllowed;+    private boolean frontchannelLogout;+    private int notBefore;+    private Set<String> scope = new HashSet<>();+    private Set<String> webOrigins = new HashSet<>();+    private Map<String, ProtocolMapperModel> protocolMappers = new HashMap<>();+    private Map<String, Boolean> clientScopes = new HashMap<>();+    private Set<String> scopeMappings = new LinkedHashSet<>();+    private List<String> defaultRoles = new LinkedList<>();+    private boolean surrogateAuthRequired;+    private String managementUrl;+    private String rootUrl;+    private String baseUrl;+    private boolean bearerOnly;+    private boolean consentRequired;+    private boolean standardFlowEnabled;+    private boolean implicitFlowEnabled;+    private boolean directAccessGrantsEnabled;+    private boolean serviceAccountsEnabled;+    private int nodeReRegistrationTimeout;++    /**+     * Flag signalizing that any of the setters has been meaningfully used.+     */+    protected boolean updated;++    protected AbstractClientEntity() {","`*Entity` is private class and the high-level code only uses `*Model` implementations.In the particular case of map models introduced here, if the client code fails to update the `updated` state, then the entity is never persisted (see `MapKeycloakTransaction.putIfChanged(K, V, Predicate<V>)`). Other implementations can choose another mechanism, e.g. by returning unmodifiable collections as you suggested.Generally, the model implementations ensure that the contract of updating the `updated` is properly maintained, e.g. by only exposing read-only collections for getters, and separate methods for modifying the collections. Cf. ProtocolMappers handling in `MapClientAdapter`.",X
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7155,457857009,2020-07-21T06:05:15Z,services/src/main/java/org/keycloak/authentication/forms/RegistrationProfile.java,"@@ -57,41 +63,25 @@ public String getHelpText() {     }      @Override-    public void validate(ValidationContext context) {+    public void validate(org.keycloak.authentication.ValidationContext context) {         MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();-        List<FormMessage> errors = new ArrayList<>();+        UserAttributesRepresentation rep = AttributeFormDataProcessor.toAttributesRepresentation(formData); -        context.getEvent().detail(Details.REGISTER_METHOD, ""form"");-        String eventError = Errors.INVALID_REGISTRATION;--        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_FIRST_NAME)))) {-            errors.add(new FormMessage(RegistrationPage.FIELD_FIRST_NAME, Messages.MISSING_FIRST_NAME));-        }--        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_LAST_NAME)))) {-            errors.add(new FormMessage(RegistrationPage.FIELD_LAST_NAME, Messages.MISSING_LAST_NAME));-        }+        UserProfileProvider userProfile = context.getSession().getProvider(UserProfileProvider.class, LegacyUserProfileProvider.PROVIDER_ID); -        String email = formData.getFirst(Validation.FIELD_EMAIL);-        boolean emailValid = true;-        if (Validation.isBlank(email)) {-            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.MISSING_EMAIL));-            emailValid = false;-        } else if (!Validation.isEmailValid(email)) {-            context.getEvent().detail(Details.EMAIL, email);-            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.INVALID_EMAIL));-            emailValid = false;-        }--        if (emailValid && !context.getRealm().isDuplicateEmailsAllowed() && context.getSession().users().getUserByEmail(email, context.getRealm()) != null) {-            eventError = Errors.EMAIL_IN_USE;-            formData.remove(Validation.FIELD_EMAIL);-            context.getEvent().detail(Details.EMAIL, email);-            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.EMAIL_EXISTS));-        }+        context.getEvent().detail(Details.REGISTER_METHOD, ""form"");+        UserProfileValidationResult result = userProfile.validate(rep, null, ValidationScenario.RegistrationProfile);+        List<FormMessage> errors = Validation.getFormErrorsFromValidation(result);          if (errors.size() > 0) {-            context.error(eventError);+            if (result.hasFailureOfErrorType(Messages.EMAIL_EXISTS, Messages.INVALID_EMAIL))+                context.getEvent().detail(Details.EMAIL, rep.firstAttribute(UserModel.EMAIL));++            if (result.hasFailureOfErrorType(Messages.EMAIL_EXISTS)) {+                context.error(Errors.EMAIL_IN_USE);+                formData.remove(""email"");+            } else","I think looking for specific error messages like this is too brittle, perhaps it would be better to have a `UserProfileValidationException` with sub-classes like `EmailInUseException` instead here?",
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,457965660,2020-07-21T09:34:03Z,server-spi-private/src/main/java/org/keycloak/userprofile/validation/UserProfileValidationResult.java,"@@ -0,0 +1,48 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile.validation;++import java.util.List;+import java.util.stream.Collectors;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public class UserProfileValidationResult {","validate also returns state changes e.g. an attribute has been changed. This is needed for decision making later on. Alternatively, we would have validation results and change results grouped in a general result class. ",X
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,457969734,2020-07-21T09:41:08Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfileProvider.java,"@@ -0,0 +1,35 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import org.keycloak.userprofile.util.UpdateUserProfileContext;+import org.keycloak.userprofile.validation.UserProfileValidationResult;+import org.keycloak.provider.Provider;+import org.keycloak.provider.ProviderFactory;+import org.keycloak.representations.idm.UserAttributesRepresentation;+import org.keycloak.userprofile.validation.ValidationScenario;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public interface UserProfileProvider extends Provider, ProviderFactory<UserProfileProvider> {++    UserProfileValidationResult validate(UserAttributesRepresentation rep, UpdateUserProfileContext user, ValidationScenario validationScenario);++    void update(UserAttributesRepresentation rep, UpdateUserProfileContext user, ValidationScenario validationScenario);","Would you prefer a UserUpdateProvider instead? To me, it was important to have a unique entry point for updating users as the old behavior was very error-prone (and yes I found ""relevant"" errors in the different code paths which are gone now). I would prefer a single stable update method. Rather in this provider or its own one. This also would enable profile implementations to execute actions ""on save"" e.g. external replication or data source checks. But may I'm wrong here. ",
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,457971060,2020-07-21T09:43:27Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfileSpi.java,"@@ -0,0 +1,48 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import org.keycloak.provider.Provider;+import org.keycloak.provider.ProviderFactory;+import org.keycloak.provider.Spi;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public class UserProfileSpi implements Spi {++    @Override+    public boolean isInternal() {+        return false;+    }++    @Override+    public String getName() {+        return ""userProfile"";+    }++    @Override+    public Class<? extends Provider> getProviderClass() {+        return UserProfileProvider.class;+    }++    @Override+    public Class<? extends ProviderFactory> getProviderFactoryClass() {+        return UserProfileProvider.class;","Okay, we were not sure about that (both patterns are applied in the codebase and its hard to guess when it's appropriate).will be fixed. ",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7267,457990010,2020-07-21T10:17:06Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -16,640 +16,16 @@  */ package org.keycloak.testsuite; -import io.appium.java_client.AppiumDriver;-import org.apache.commons.configuration.ConfigurationException;-import org.apache.commons.configuration.PropertiesConfiguration;-import org.jboss.arquillian.container.test.api.RunAsClient;-import org.jboss.arquillian.drone.api.annotation.Drone;-import org.jboss.arquillian.graphene.page.Page;-import org.jboss.arquillian.test.api.ArquillianResource;-import org.jboss.logging.Logger;-import org.junit.After;-import org.junit.Before;-import org.junit.runner.RunWith;-import org.keycloak.admin.client.Keycloak;-import org.keycloak.admin.client.resource.AuthenticationManagementResource;-import org.keycloak.admin.client.resource.RealmsResource;-import org.keycloak.admin.client.resource.UserResource;-import org.keycloak.admin.client.resource.UsersResource;-import org.keycloak.common.util.KeycloakUriBuilder;-import org.keycloak.common.util.Time;-import org.keycloak.representations.idm.ClientRepresentation;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RequiredActionProviderRepresentation;-import org.keycloak.representations.idm.UserRepresentation;-import org.keycloak.services.resources.account.AccountFormService;-import org.keycloak.testsuite.admin.ApiUtil;-import org.keycloak.testsuite.arquillian.AuthServerTestEnricher;-import org.keycloak.testsuite.arquillian.KcArquillian;-import org.keycloak.testsuite.arquillian.SuiteContext;-import org.keycloak.testsuite.arquillian.TestContext;-import org.keycloak.testsuite.auth.page.AuthRealm;-import org.keycloak.testsuite.auth.page.AuthServer;-import org.keycloak.testsuite.auth.page.AuthServerContextRoot;-import org.keycloak.testsuite.auth.page.WelcomePage;-import org.keycloak.testsuite.auth.page.account.Account;-import org.keycloak.testsuite.auth.page.login.OIDCLogin;-import org.keycloak.testsuite.auth.page.login.UpdatePassword;-import org.keycloak.testsuite.client.KeycloakTestingClient;-import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;-import org.keycloak.testsuite.util.DroneUtils;-import org.keycloak.testsuite.util.OAuthClient;-import org.keycloak.testsuite.util.TestCleanup;-import org.keycloak.testsuite.util.TestEventsLogger;-import org.openqa.selenium.WebDriver;--import javax.ws.rs.NotFoundException;-import javax.ws.rs.core.UriBuilder;--import java.io.IOException;-import java.io.InputStream;-import java.io.PipedInputStream;-import java.io.PipedOutputStream;-import java.io.PrintWriter;-import java.net.URI;-import java.net.URISyntaxException;-import java.util.ArrayList;-import java.util.Arrays;-import java.util.Calendar;-import java.util.Collections;-import java.util.List;-import java.util.Map;-import java.util.Scanner;--import static org.hamcrest.Matchers.equalTo;-import static org.hamcrest.Matchers.is;-import static org.junit.Assert.assertThat;-import static org.keycloak.testsuite.admin.Users.setPasswordFor;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_HOST;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_PORT;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SCHEME;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SSL_REQUIRED;-import static org.keycloak.testsuite.auth.page.AuthRealm.MASTER;-import static org.keycloak.testsuite.util.URLUtils.navigateToUri;-import static org.keycloak.testsuite.util.ServerURLs.removeDefaultPorts;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.arquillian.annotation.DisableFeature;  /**- *- * @author tkyjovsk+ * Old tests that use AbstractKeycloakTest assume that we are using the old+ * account console.+ * + * @author Stan Silvert  */-@RunWith(KcArquillian.class)-@RunAsClient-public abstract class AbstractKeycloakTest {","I have to admit I don't like the approach with renaming and creating new abstract classes. The naming is quite confusing  `AbstractKeycloakTest` vs `MainAbstractKeycloakTest`. But more importantly, it breaks the class hierarchy which results in duplicate code e.g. in `AbstractUiTest`.The way I see it we have two options.1. Move the abstract class that disables the new console much, much lower in the hierarchy. So that the abstract classes could be used by the new console tests and code duplication wouldn't be necessary.2. Disable the new console in the first abstract class and then re-enable it only in the tests that need it. The number of tests for the new console is really just a fraction of what we have, so maybe that would be a cleaner approach.In any case, this change should be as small as possible because it's only temporary. Sooner or later the old console will be deprecated and we'll have to fix all the tests that rely on it.",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7267,458002881,2020-07-21T10:41:20Z,services/src/main/java/org/keycloak/theme/DefaultThemeManager.java,"@@ -72,7 +73,7 @@ public Theme getTheme(String name, Theme.Type type) {         if (theme == null) {             theme = loadTheme(name, type);             if (theme == null) {-                theme = loadTheme(""keycloak"", type);+                theme = loadTheme(""keycloak.v2"", type);",I'm not sure if it isn't confusing that all themes (even the old ones) use `v2` with the old `keycloak` still available. The problem I see is that `keycloak` and `keycloak.v2` are technically same themes (except account console) but the `v2` could make the impression something's new in all themes.But I'm ok with this if @stianst is.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7272,458340348,2020-07-21T19:35:51Z,model/jpa/src/main/java/org/keycloak/models/jpa/entities/ClientEntity.java,"@@ -130,6 +130,12 @@     @Column(name=""BASE_URL"")     private String baseUrl; +    @Column(name=""BACKCHANNEL_LOGOUT_URL"")","Instead of changing DDL, could we just persist the new data as client attributes? Similar to what we do with `org.keycloak.protocol.oidc.OIDCConfigAttributes#JWKS_URL`.It should help to avoid all the migration-related code herein ...",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7267,458357849,2020-07-21T20:09:21Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -16,640 +16,16 @@  */ package org.keycloak.testsuite; -import io.appium.java_client.AppiumDriver;-import org.apache.commons.configuration.ConfigurationException;-import org.apache.commons.configuration.PropertiesConfiguration;-import org.jboss.arquillian.container.test.api.RunAsClient;-import org.jboss.arquillian.drone.api.annotation.Drone;-import org.jboss.arquillian.graphene.page.Page;-import org.jboss.arquillian.test.api.ArquillianResource;-import org.jboss.logging.Logger;-import org.junit.After;-import org.junit.Before;-import org.junit.runner.RunWith;-import org.keycloak.admin.client.Keycloak;-import org.keycloak.admin.client.resource.AuthenticationManagementResource;-import org.keycloak.admin.client.resource.RealmsResource;-import org.keycloak.admin.client.resource.UserResource;-import org.keycloak.admin.client.resource.UsersResource;-import org.keycloak.common.util.KeycloakUriBuilder;-import org.keycloak.common.util.Time;-import org.keycloak.representations.idm.ClientRepresentation;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RequiredActionProviderRepresentation;-import org.keycloak.representations.idm.UserRepresentation;-import org.keycloak.services.resources.account.AccountFormService;-import org.keycloak.testsuite.admin.ApiUtil;-import org.keycloak.testsuite.arquillian.AuthServerTestEnricher;-import org.keycloak.testsuite.arquillian.KcArquillian;-import org.keycloak.testsuite.arquillian.SuiteContext;-import org.keycloak.testsuite.arquillian.TestContext;-import org.keycloak.testsuite.auth.page.AuthRealm;-import org.keycloak.testsuite.auth.page.AuthServer;-import org.keycloak.testsuite.auth.page.AuthServerContextRoot;-import org.keycloak.testsuite.auth.page.WelcomePage;-import org.keycloak.testsuite.auth.page.account.Account;-import org.keycloak.testsuite.auth.page.login.OIDCLogin;-import org.keycloak.testsuite.auth.page.login.UpdatePassword;-import org.keycloak.testsuite.client.KeycloakTestingClient;-import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;-import org.keycloak.testsuite.util.DroneUtils;-import org.keycloak.testsuite.util.OAuthClient;-import org.keycloak.testsuite.util.TestCleanup;-import org.keycloak.testsuite.util.TestEventsLogger;-import org.openqa.selenium.WebDriver;--import javax.ws.rs.NotFoundException;-import javax.ws.rs.core.UriBuilder;--import java.io.IOException;-import java.io.InputStream;-import java.io.PipedInputStream;-import java.io.PipedOutputStream;-import java.io.PrintWriter;-import java.net.URI;-import java.net.URISyntaxException;-import java.util.ArrayList;-import java.util.Arrays;-import java.util.Calendar;-import java.util.Collections;-import java.util.List;-import java.util.Map;-import java.util.Scanner;--import static org.hamcrest.Matchers.equalTo;-import static org.hamcrest.Matchers.is;-import static org.junit.Assert.assertThat;-import static org.keycloak.testsuite.admin.Users.setPasswordFor;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_HOST;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_PORT;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SCHEME;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SSL_REQUIRED;-import static org.keycloak.testsuite.auth.page.AuthRealm.MASTER;-import static org.keycloak.testsuite.util.URLUtils.navigateToUri;-import static org.keycloak.testsuite.util.ServerURLs.removeDefaultPorts;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.arquillian.annotation.DisableFeature;  /**- *- * @author tkyjovsk+ * Old tests that use AbstractKeycloakTest assume that we are using the old+ * account console.+ * + * @author Stan Silvert  */-@RunWith(KcArquillian.class)-@RunAsClient-public abstract class AbstractKeycloakTest {","> I have to admit I don't like the approach with renaming and creating new abstract classes. The naming is quite confusing  `AbstractKeycloakTest` vs `MainAbstractKeycloakTest`. But more importantly, it breaks the class hierarchy which results in duplicate code e.g. in `AbstractUiTest`.> > The way I see it we have two options.> > 1. Move the abstract class that disables the new console much, much lower in the hierarchy. So that the abstract classes could be used by the new console tests and code duplication wouldn't be necessary.> 2. Disable the new console in the first abstract class and then re-enable it only in the tests that need it. The number of tests for the new console is really just a fraction of what we have, so maybe that would be a cleaner approach.> > In any case, this change should be as small as possible because it's only temporary. Sooner or later the old console will be deprecated and we'll have to fix all the tests that rely on it.I'm not really happy with this either.I spent a fair amount of time trying to figure out what would be the least disruptive to the current code base.I don't think your first suggestion would work at all without changing a lot of tests.  If I recall, a lot of tests extend AbstractKeycloakTest directly.I wouldn't want to go through all the tests that need new account console and enable NAC individually.  That just seems wrong since we want to use NAC going forward.IMO, the only thing that made the code a little more ugly was that I had to copy some code from AbstractAuthorizationTest to AbstractUITest.  Because of the way the hierarchy is set up there was no good way to get around it without figuring out exactly what each test was using from the base class.This is what happens when a code base relies so heavily on inheritance instead of delegation.That being said, the whole thing could definitely use some refactoring but it's just a matter of deciding how much time you want to spend.  ",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7267,458554136,2020-07-22T06:03:43Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -16,640 +16,16 @@  */ package org.keycloak.testsuite; -import io.appium.java_client.AppiumDriver;-import org.apache.commons.configuration.ConfigurationException;-import org.apache.commons.configuration.PropertiesConfiguration;-import org.jboss.arquillian.container.test.api.RunAsClient;-import org.jboss.arquillian.drone.api.annotation.Drone;-import org.jboss.arquillian.graphene.page.Page;-import org.jboss.arquillian.test.api.ArquillianResource;-import org.jboss.logging.Logger;-import org.junit.After;-import org.junit.Before;-import org.junit.runner.RunWith;-import org.keycloak.admin.client.Keycloak;-import org.keycloak.admin.client.resource.AuthenticationManagementResource;-import org.keycloak.admin.client.resource.RealmsResource;-import org.keycloak.admin.client.resource.UserResource;-import org.keycloak.admin.client.resource.UsersResource;-import org.keycloak.common.util.KeycloakUriBuilder;-import org.keycloak.common.util.Time;-import org.keycloak.representations.idm.ClientRepresentation;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RequiredActionProviderRepresentation;-import org.keycloak.representations.idm.UserRepresentation;-import org.keycloak.services.resources.account.AccountFormService;-import org.keycloak.testsuite.admin.ApiUtil;-import org.keycloak.testsuite.arquillian.AuthServerTestEnricher;-import org.keycloak.testsuite.arquillian.KcArquillian;-import org.keycloak.testsuite.arquillian.SuiteContext;-import org.keycloak.testsuite.arquillian.TestContext;-import org.keycloak.testsuite.auth.page.AuthRealm;-import org.keycloak.testsuite.auth.page.AuthServer;-import org.keycloak.testsuite.auth.page.AuthServerContextRoot;-import org.keycloak.testsuite.auth.page.WelcomePage;-import org.keycloak.testsuite.auth.page.account.Account;-import org.keycloak.testsuite.auth.page.login.OIDCLogin;-import org.keycloak.testsuite.auth.page.login.UpdatePassword;-import org.keycloak.testsuite.client.KeycloakTestingClient;-import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;-import org.keycloak.testsuite.util.DroneUtils;-import org.keycloak.testsuite.util.OAuthClient;-import org.keycloak.testsuite.util.TestCleanup;-import org.keycloak.testsuite.util.TestEventsLogger;-import org.openqa.selenium.WebDriver;--import javax.ws.rs.NotFoundException;-import javax.ws.rs.core.UriBuilder;--import java.io.IOException;-import java.io.InputStream;-import java.io.PipedInputStream;-import java.io.PipedOutputStream;-import java.io.PrintWriter;-import java.net.URI;-import java.net.URISyntaxException;-import java.util.ArrayList;-import java.util.Arrays;-import java.util.Calendar;-import java.util.Collections;-import java.util.List;-import java.util.Map;-import java.util.Scanner;--import static org.hamcrest.Matchers.equalTo;-import static org.hamcrest.Matchers.is;-import static org.junit.Assert.assertThat;-import static org.keycloak.testsuite.admin.Users.setPasswordFor;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_HOST;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_PORT;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SCHEME;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SSL_REQUIRED;-import static org.keycloak.testsuite.auth.page.AuthRealm.MASTER;-import static org.keycloak.testsuite.util.URLUtils.navigateToUri;-import static org.keycloak.testsuite.util.ServerURLs.removeDefaultPorts;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.arquillian.annotation.DisableFeature;  /**- *- * @author tkyjovsk+ * Old tests that use AbstractKeycloakTest assume that we are using the old+ * account console.+ * + * @author Stan Silvert  */-@RunWith(KcArquillian.class)-@RunAsClient-public abstract class AbstractKeycloakTest {","> I don't think your first suggestion would work at all without changing a lot of tests. If I recall, a lot of tests extend AbstractKeycloakTest directly.Ah, yes, you're correct. Option 1 won't work. > I wouldn't want to go through all the tests that need new account console and enable NAC individually. That just seems wrong since we want to use NAC going forward.Actually, I think you wouldn't need to go trough all the tests that need NAC. The annotations to enable it are already there, the only change we'd have to do now is to disable NAC in the most abstract class. Once we fixed the tests to work with NAC, we'll just remove those annotations. That seems to me like the least invasive option. If it works, of course. ;)> That being said, the whole thing could definitely use some refactoring but it's just a matter of deciding how much time you want to spend.+1000That being said, it's ugly but we don't need to make it even more ugly now. :)",X
50862958,benjamin37,https://api.github.com/repos/keycloak/keycloak/pulls/7272,458765449,2020-07-22T12:48:08Z,model/jpa/src/main/java/org/keycloak/models/jpa/entities/ClientEntity.java,"@@ -130,6 +130,12 @@     @Column(name=""BASE_URL"")     private String baseUrl; +    @Column(name=""BACKCHANNEL_LOGOUT_URL"")","Done, we also removed the database migration files. No need to do database changes any more.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7267,458771871,2020-07-22T12:58:51Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -16,640 +16,16 @@  */ package org.keycloak.testsuite; -import io.appium.java_client.AppiumDriver;-import org.apache.commons.configuration.ConfigurationException;-import org.apache.commons.configuration.PropertiesConfiguration;-import org.jboss.arquillian.container.test.api.RunAsClient;-import org.jboss.arquillian.drone.api.annotation.Drone;-import org.jboss.arquillian.graphene.page.Page;-import org.jboss.arquillian.test.api.ArquillianResource;-import org.jboss.logging.Logger;-import org.junit.After;-import org.junit.Before;-import org.junit.runner.RunWith;-import org.keycloak.admin.client.Keycloak;-import org.keycloak.admin.client.resource.AuthenticationManagementResource;-import org.keycloak.admin.client.resource.RealmsResource;-import org.keycloak.admin.client.resource.UserResource;-import org.keycloak.admin.client.resource.UsersResource;-import org.keycloak.common.util.KeycloakUriBuilder;-import org.keycloak.common.util.Time;-import org.keycloak.representations.idm.ClientRepresentation;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RequiredActionProviderRepresentation;-import org.keycloak.representations.idm.UserRepresentation;-import org.keycloak.services.resources.account.AccountFormService;-import org.keycloak.testsuite.admin.ApiUtil;-import org.keycloak.testsuite.arquillian.AuthServerTestEnricher;-import org.keycloak.testsuite.arquillian.KcArquillian;-import org.keycloak.testsuite.arquillian.SuiteContext;-import org.keycloak.testsuite.arquillian.TestContext;-import org.keycloak.testsuite.auth.page.AuthRealm;-import org.keycloak.testsuite.auth.page.AuthServer;-import org.keycloak.testsuite.auth.page.AuthServerContextRoot;-import org.keycloak.testsuite.auth.page.WelcomePage;-import org.keycloak.testsuite.auth.page.account.Account;-import org.keycloak.testsuite.auth.page.login.OIDCLogin;-import org.keycloak.testsuite.auth.page.login.UpdatePassword;-import org.keycloak.testsuite.client.KeycloakTestingClient;-import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;-import org.keycloak.testsuite.util.DroneUtils;-import org.keycloak.testsuite.util.OAuthClient;-import org.keycloak.testsuite.util.TestCleanup;-import org.keycloak.testsuite.util.TestEventsLogger;-import org.openqa.selenium.WebDriver;--import javax.ws.rs.NotFoundException;-import javax.ws.rs.core.UriBuilder;--import java.io.IOException;-import java.io.InputStream;-import java.io.PipedInputStream;-import java.io.PipedOutputStream;-import java.io.PrintWriter;-import java.net.URI;-import java.net.URISyntaxException;-import java.util.ArrayList;-import java.util.Arrays;-import java.util.Calendar;-import java.util.Collections;-import java.util.List;-import java.util.Map;-import java.util.Scanner;--import static org.hamcrest.Matchers.equalTo;-import static org.hamcrest.Matchers.is;-import static org.junit.Assert.assertThat;-import static org.keycloak.testsuite.admin.Users.setPasswordFor;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_HOST;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_PORT;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SCHEME;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SSL_REQUIRED;-import static org.keycloak.testsuite.auth.page.AuthRealm.MASTER;-import static org.keycloak.testsuite.util.URLUtils.navigateToUri;-import static org.keycloak.testsuite.util.ServerURLs.removeDefaultPorts;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.arquillian.annotation.DisableFeature;  /**- *- * @author tkyjovsk+ * Old tests that use AbstractKeycloakTest assume that we are using the old+ * account console.+ * + * @author Stan Silvert  */-@RunWith(KcArquillian.class)-@RunAsClient-public abstract class AbstractKeycloakTest {","> Actually, I think you wouldn't need to go trough all the tests that need NAC. The annotations to enable it are already there, the only change we'd have to do now is to disable NAC in the most abstract class. Once we fixed the tests to work with NAC, we'll just remove those annotations. That seems to me like the least invasive option. If it works, of course. ;)> I tried that and it didn't appear to work.  Even if it did things would get confusing.  You end up with an inheritance hierarchy where a base class has `@EnableFeature` and a subclass has `@DisableFeature`.  Or vice versa.  So you don't know who wins.I did find that using the annotation on a method takes precedence, over having it at the class level.  So that helped out a bit.",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7267,458859551,2020-07-22T15:00:46Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -16,640 +16,16 @@  */ package org.keycloak.testsuite; -import io.appium.java_client.AppiumDriver;-import org.apache.commons.configuration.ConfigurationException;-import org.apache.commons.configuration.PropertiesConfiguration;-import org.jboss.arquillian.container.test.api.RunAsClient;-import org.jboss.arquillian.drone.api.annotation.Drone;-import org.jboss.arquillian.graphene.page.Page;-import org.jboss.arquillian.test.api.ArquillianResource;-import org.jboss.logging.Logger;-import org.junit.After;-import org.junit.Before;-import org.junit.runner.RunWith;-import org.keycloak.admin.client.Keycloak;-import org.keycloak.admin.client.resource.AuthenticationManagementResource;-import org.keycloak.admin.client.resource.RealmsResource;-import org.keycloak.admin.client.resource.UserResource;-import org.keycloak.admin.client.resource.UsersResource;-import org.keycloak.common.util.KeycloakUriBuilder;-import org.keycloak.common.util.Time;-import org.keycloak.representations.idm.ClientRepresentation;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RequiredActionProviderRepresentation;-import org.keycloak.representations.idm.UserRepresentation;-import org.keycloak.services.resources.account.AccountFormService;-import org.keycloak.testsuite.admin.ApiUtil;-import org.keycloak.testsuite.arquillian.AuthServerTestEnricher;-import org.keycloak.testsuite.arquillian.KcArquillian;-import org.keycloak.testsuite.arquillian.SuiteContext;-import org.keycloak.testsuite.arquillian.TestContext;-import org.keycloak.testsuite.auth.page.AuthRealm;-import org.keycloak.testsuite.auth.page.AuthServer;-import org.keycloak.testsuite.auth.page.AuthServerContextRoot;-import org.keycloak.testsuite.auth.page.WelcomePage;-import org.keycloak.testsuite.auth.page.account.Account;-import org.keycloak.testsuite.auth.page.login.OIDCLogin;-import org.keycloak.testsuite.auth.page.login.UpdatePassword;-import org.keycloak.testsuite.client.KeycloakTestingClient;-import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;-import org.keycloak.testsuite.util.DroneUtils;-import org.keycloak.testsuite.util.OAuthClient;-import org.keycloak.testsuite.util.TestCleanup;-import org.keycloak.testsuite.util.TestEventsLogger;-import org.openqa.selenium.WebDriver;--import javax.ws.rs.NotFoundException;-import javax.ws.rs.core.UriBuilder;--import java.io.IOException;-import java.io.InputStream;-import java.io.PipedInputStream;-import java.io.PipedOutputStream;-import java.io.PrintWriter;-import java.net.URI;-import java.net.URISyntaxException;-import java.util.ArrayList;-import java.util.Arrays;-import java.util.Calendar;-import java.util.Collections;-import java.util.List;-import java.util.Map;-import java.util.Scanner;--import static org.hamcrest.Matchers.equalTo;-import static org.hamcrest.Matchers.is;-import static org.junit.Assert.assertThat;-import static org.keycloak.testsuite.admin.Users.setPasswordFor;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_HOST;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_PORT;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SCHEME;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SSL_REQUIRED;-import static org.keycloak.testsuite.auth.page.AuthRealm.MASTER;-import static org.keycloak.testsuite.util.URLUtils.navigateToUri;-import static org.keycloak.testsuite.util.ServerURLs.removeDefaultPorts;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.arquillian.annotation.DisableFeature;  /**- *- * @author tkyjovsk+ * Old tests that use AbstractKeycloakTest assume that we are using the old+ * account console.+ * + * @author Stan Silvert  */-@RunWith(KcArquillian.class)-@RunAsClient-public abstract class AbstractKeycloakTest {","IMHO there's no problem with a parent class disabling feature and some child re-enabling it. I'm sure we could fix the implementation if it doesn't work like that.As an alternative, we could globally disable NAS on testsuite level by some other way (without using the annotation) and use the annotation just for enabling where needed. It's all just temporary anyway so we should do as little changes in the class hierarchy as possible.",X
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7267,459384691,2020-07-23T11:34:45Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -16,640 +16,16 @@  */ package org.keycloak.testsuite; -import io.appium.java_client.AppiumDriver;-import org.apache.commons.configuration.ConfigurationException;-import org.apache.commons.configuration.PropertiesConfiguration;-import org.jboss.arquillian.container.test.api.RunAsClient;-import org.jboss.arquillian.drone.api.annotation.Drone;-import org.jboss.arquillian.graphene.page.Page;-import org.jboss.arquillian.test.api.ArquillianResource;-import org.jboss.logging.Logger;-import org.junit.After;-import org.junit.Before;-import org.junit.runner.RunWith;-import org.keycloak.admin.client.Keycloak;-import org.keycloak.admin.client.resource.AuthenticationManagementResource;-import org.keycloak.admin.client.resource.RealmsResource;-import org.keycloak.admin.client.resource.UserResource;-import org.keycloak.admin.client.resource.UsersResource;-import org.keycloak.common.util.KeycloakUriBuilder;-import org.keycloak.common.util.Time;-import org.keycloak.representations.idm.ClientRepresentation;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RequiredActionProviderRepresentation;-import org.keycloak.representations.idm.UserRepresentation;-import org.keycloak.services.resources.account.AccountFormService;-import org.keycloak.testsuite.admin.ApiUtil;-import org.keycloak.testsuite.arquillian.AuthServerTestEnricher;-import org.keycloak.testsuite.arquillian.KcArquillian;-import org.keycloak.testsuite.arquillian.SuiteContext;-import org.keycloak.testsuite.arquillian.TestContext;-import org.keycloak.testsuite.auth.page.AuthRealm;-import org.keycloak.testsuite.auth.page.AuthServer;-import org.keycloak.testsuite.auth.page.AuthServerContextRoot;-import org.keycloak.testsuite.auth.page.WelcomePage;-import org.keycloak.testsuite.auth.page.account.Account;-import org.keycloak.testsuite.auth.page.login.OIDCLogin;-import org.keycloak.testsuite.auth.page.login.UpdatePassword;-import org.keycloak.testsuite.client.KeycloakTestingClient;-import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;-import org.keycloak.testsuite.util.DroneUtils;-import org.keycloak.testsuite.util.OAuthClient;-import org.keycloak.testsuite.util.TestCleanup;-import org.keycloak.testsuite.util.TestEventsLogger;-import org.openqa.selenium.WebDriver;--import javax.ws.rs.NotFoundException;-import javax.ws.rs.core.UriBuilder;--import java.io.IOException;-import java.io.InputStream;-import java.io.PipedInputStream;-import java.io.PipedOutputStream;-import java.io.PrintWriter;-import java.net.URI;-import java.net.URISyntaxException;-import java.util.ArrayList;-import java.util.Arrays;-import java.util.Calendar;-import java.util.Collections;-import java.util.List;-import java.util.Map;-import java.util.Scanner;--import static org.hamcrest.Matchers.equalTo;-import static org.hamcrest.Matchers.is;-import static org.junit.Assert.assertThat;-import static org.keycloak.testsuite.admin.Users.setPasswordFor;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_HOST;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_PORT;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SCHEME;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SSL_REQUIRED;-import static org.keycloak.testsuite.auth.page.AuthRealm.MASTER;-import static org.keycloak.testsuite.util.URLUtils.navigateToUri;-import static org.keycloak.testsuite.util.ServerURLs.removeDefaultPorts;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.arquillian.annotation.DisableFeature;  /**- *- * @author tkyjovsk+ * Old tests that use AbstractKeycloakTest assume that we are using the old+ * account console.+ * + * @author Stan Silvert  */-@RunWith(KcArquillian.class)-@RunAsClient-public abstract class AbstractKeycloakTest {","> IMHO there's no problem with a parent class disabling feature and some child re-enabling it. I'm sure we could fix the implementation if it doesn't work like that.> I think it is a problem because there is no hard and fast rule about who should win.  And even if you know how to determine the winner you must inspect the entire hierarchy to find all the @Enable and @Disable annotations.  That's very confusing for the developer.> As an alternative, we could globally disable NAS on testsuite level by some other way (without using the annotation) and use the annotation just for enabling where needed. It's all just temporary anyway so we should do as little changes in the class hierarchy as possible.We both agree that things have gotten messy.  Let's fix it in another JIRA.",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7267,459416325,2020-07-23T12:37:59Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -16,640 +16,16 @@  */ package org.keycloak.testsuite; -import io.appium.java_client.AppiumDriver;-import org.apache.commons.configuration.ConfigurationException;-import org.apache.commons.configuration.PropertiesConfiguration;-import org.jboss.arquillian.container.test.api.RunAsClient;-import org.jboss.arquillian.drone.api.annotation.Drone;-import org.jboss.arquillian.graphene.page.Page;-import org.jboss.arquillian.test.api.ArquillianResource;-import org.jboss.logging.Logger;-import org.junit.After;-import org.junit.Before;-import org.junit.runner.RunWith;-import org.keycloak.admin.client.Keycloak;-import org.keycloak.admin.client.resource.AuthenticationManagementResource;-import org.keycloak.admin.client.resource.RealmsResource;-import org.keycloak.admin.client.resource.UserResource;-import org.keycloak.admin.client.resource.UsersResource;-import org.keycloak.common.util.KeycloakUriBuilder;-import org.keycloak.common.util.Time;-import org.keycloak.representations.idm.ClientRepresentation;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RequiredActionProviderRepresentation;-import org.keycloak.representations.idm.UserRepresentation;-import org.keycloak.services.resources.account.AccountFormService;-import org.keycloak.testsuite.admin.ApiUtil;-import org.keycloak.testsuite.arquillian.AuthServerTestEnricher;-import org.keycloak.testsuite.arquillian.KcArquillian;-import org.keycloak.testsuite.arquillian.SuiteContext;-import org.keycloak.testsuite.arquillian.TestContext;-import org.keycloak.testsuite.auth.page.AuthRealm;-import org.keycloak.testsuite.auth.page.AuthServer;-import org.keycloak.testsuite.auth.page.AuthServerContextRoot;-import org.keycloak.testsuite.auth.page.WelcomePage;-import org.keycloak.testsuite.auth.page.account.Account;-import org.keycloak.testsuite.auth.page.login.OIDCLogin;-import org.keycloak.testsuite.auth.page.login.UpdatePassword;-import org.keycloak.testsuite.client.KeycloakTestingClient;-import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;-import org.keycloak.testsuite.util.DroneUtils;-import org.keycloak.testsuite.util.OAuthClient;-import org.keycloak.testsuite.util.TestCleanup;-import org.keycloak.testsuite.util.TestEventsLogger;-import org.openqa.selenium.WebDriver;--import javax.ws.rs.NotFoundException;-import javax.ws.rs.core.UriBuilder;--import java.io.IOException;-import java.io.InputStream;-import java.io.PipedInputStream;-import java.io.PipedOutputStream;-import java.io.PrintWriter;-import java.net.URI;-import java.net.URISyntaxException;-import java.util.ArrayList;-import java.util.Arrays;-import java.util.Calendar;-import java.util.Collections;-import java.util.List;-import java.util.Map;-import java.util.Scanner;--import static org.hamcrest.Matchers.equalTo;-import static org.hamcrest.Matchers.is;-import static org.junit.Assert.assertThat;-import static org.keycloak.testsuite.admin.Users.setPasswordFor;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_HOST;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_PORT;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SCHEME;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SSL_REQUIRED;-import static org.keycloak.testsuite.auth.page.AuthRealm.MASTER;-import static org.keycloak.testsuite.util.URLUtils.navigateToUri;-import static org.keycloak.testsuite.util.ServerURLs.removeDefaultPorts;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.arquillian.annotation.DisableFeature;  /**- *- * @author tkyjovsk+ * Old tests that use AbstractKeycloakTest assume that we are using the old+ * account console.+ * + * @author Stan Silvert  */-@RunWith(KcArquillian.class)-@RunAsClient-public abstract class AbstractKeycloakTest {","> I think it is a problem because there is no hard and fast rule about who should win. And even if you know how to determine the winner you must inspect the entire hierarchy to find all the @enable and @disable annotations. That's very confusing for the developer.It already works like that  the entire hierarchy is transparently checked for the annotations thanks to [`@Inherited`](https://github.com/keycloak/keycloak/blob/74988a3f21c26764e01956ff8c9ef5cea865cb2d/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/annotation/EnableFeature.java#L19). ;) And to clearly determine who wins is just a matter of updating [`checkAnnotatedElementForFeatureAnnotations`](https://github.com/keycloak/keycloak/blob/74988a3f21c26764e01956ff8c9ef5cea865cb2d/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/containers/KeycloakContainerFeaturesController.java#L148-L168). I still believe this is a cleaner way than to break the class hierarchy.> We both agree that things have gotten messy. Let's fix it in another JIRA.Sure, a follow-up JIRA can fix things but IMHO we don't need to make it even more messy in this PR. :)",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459744977,2020-07-23T21:43:25Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -620,31 +622,30 @@ public RoleModel addRealmRole(RealmModel realm, String id, String name) {             Long loaded = cache.getCurrentRevision(cacheKey);             Set<RoleModel> model = getRealmDelegate().getRealmRoles(realm);","`getRealmRoles(realm)` is now deprecated so I guess we shouldn't use it, right? ",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459746574,2020-07-23T21:46:51Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -654,46 +655,45 @@ public RoleModel addRealmRole(RealmModel realm, String id, String name) {          if (query == null) {             Long loaded = cache.getCurrentRevision(cacheKey);-            Set<RoleModel> model = getRealmDelegate().getClientRoles(realm, client);+            Set<RoleModel> model = getRealmDelegate().getClientRoles(realm, client, null, null);","the same here, `getClientRoles(realm, client, null, null)` is now deprecated.",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459749112,2020-07-23T21:53:02Z,server-spi/src/main/java/org/keycloak/models/RealmProvider.java,"@@ -147,14 +177,14 @@ default ClientModel addClient(RealmModel realm, String clientId) {     /**      * @deprecated Use the corresponding method from {@link ClientProvider}. */     @Override-    default List<ClientModel> getClients(RealmModel realm) {-        return this.getClients(realm, null, null);+    default Stream<ClientModel> getClientsStream(RealmModel realm) {",Why is new method `getClientsStream` added here in `RealmProvider`? I think we should leave original methods here as deprecated and add the new 'Stream' ones into `ClientProvider`.,X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459753101,2020-07-23T22:02:18Z,server-spi/src/main/java/org/keycloak/models/RoleContainerModel.java,"@@ -47,12 +49,27 @@      boolean removeRole(RoleModel role); -    Set<RoleModel> getRoles();-    -    Set<RoleModel> getRoles(Integer firstResult, Integer maxResults);+    @Deprecated+    default Set<RoleModel> getRoles() {",This method is now deprecated but still used across the codebase.,X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459757831,2020-07-23T22:14:20Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java,"@@ -152,7 +152,7 @@ public void unregisterNode(String nodeHost) {         return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);     } -//    @Override+    @Override","Line 164-167: `public List<ClientModel> getClients(RealmModel realm)` doesn't have to be implemented here, right? It's deprecated and it's used nowhere.",X
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459764425,2020-07-23T22:32:07Z,server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java,"@@ -71,22 +73,38 @@      * @param clientId Searched substring of the public client      *   identifier ({@code client_id} in OIDC or {@code entityID} in SAML.)      * @param firstResult First result to return. Ignored if negative or {@code null}.-     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.-     * @return Model of the client, or {@code null} if no client is found.+     * @param maxResults Maximum number of results to return. Ignored if negative or {@code null}.+     * @return List of ClientModel or an empty list if no client is found.+     * @deprecated Use {@link #searchClientsByClientIdStream(org.keycloak.models.RealmModel, java.lang.String, java.lang.Integer, java.lang.Integer)} instead.      */-    List<ClientModel> searchClientsByClientId(RealmModel realm, String clientId, Integer firstResult, Integer maxResults);+    @Deprecated+    default List<ClientModel> searchClientsByClientId(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {","This method wasn't declared in previous version of Keycloak, so I believe we don't have to deprecate it and we can remove it instead.",X
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459883296,2020-07-24T07:01:38Z,services/src/main/java/org/keycloak/services/DefaultKeycloakSessionFactory.java,"@@ -59,6 +59,8 @@     // TODO: Likely should be changed to int and use Time.currentTime() to be compatible with all our ""time"" reps     protected long serverStartupTimestamp; +    private long clientStorageProviderTimeout;","I believe `DefaultKeycloakSessionFactory` is the right place for the time being, since the configuration option should only be parsed once rather than with every `DefaultKeycloakSession` instantiation.Sadly, `ClientStorageManager` is not instantiated as other SPIs so lacks ability to be configured in the init() method, and we have to simulate it from here. In the future, once we refactor the `ClientStorageManager` to be more SPI-like, it will be moved accordingly.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459918132,2020-07-24T08:26:02Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -620,31 +622,30 @@ public RoleModel addRealmRole(RealmModel realm, String id, String name) {             Long loaded = cache.getCurrentRevision(cacheKey);             Set<RoleModel> model = getRealmDelegate().getRealmRoles(realm);","This is an excellent question.Generally, this is the case. In this case, it is however justified, as the cache provider is the final recipient of all the roles that it needs to cache, and it needs to process all of them, so it would collect them anyway.Later, we can think of optimizations like lazy-loading of the role details, and only returning stubs with IDs that would load the details only after when they are accessed. This would help across multiple places in caching.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459957346,2020-07-24T09:50:17Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -620,31 +622,30 @@ public RoleModel addRealmRole(RealmModel realm, String id, String name) {             Long loaded = cache.getCurrentRevision(cacheKey);             Set<RoleModel> model = getRealmDelegate().getRealmRoles(realm);","So maybe we shouldn't deprecate the method(s) after all. As far as I understand there are cases when using non-stream method is actually more efficient, right?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7263,459985472,2020-07-24T10:59:00Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -620,31 +622,30 @@ public RoleModel addRealmRole(RealmModel realm, String id, String name) {             Long loaded = cache.getCurrentRevision(cacheKey);             Set<RoleModel> model = getRealmDelegate().getRealmRoles(realm);",So after discussion with @hmlnarik we agreed we should add comment something like `// this method is used intentionally here because ...` to places where the deprecated methods are used.,
15000073,DaSmoo,https://api.github.com/repos/keycloak/keycloak/pulls/7272,460793447,2020-07-27T10:23:46Z,services/src/main/java/org/keycloak/jose/jws/DefaultTokenManager.java,"@@ -129,6 +135,7 @@ public String signatureAlgorithm(TokenCategory category) {             case ACCESS:                 return getSignatureAlgorithm(OIDCConfigAttributes.ACCESS_TOKEN_SIGNED_RESPONSE_ALG);             case ID:+            case LOGOUT:","We used the ID token implementation because in the specification it says that the logout token should be encrypted and validated similar to the id token. In particular 2.6 ""Logout Token Validation"" it describes the use of the encryption, used for the ID token during client registration. So we tried to reuse the current id token implementation parts instead of adding new ones. ",
15000073,DaSmoo,https://api.github.com/repos/keycloak/keycloak/pulls/7272,460794271,2020-07-27T10:25:28Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCLoginProtocolService.java,"@@ -240,13 +250,23 @@ public Object issueUserInfo() {         return endpoint;     } +    /* old deprecated logout endpoint needs to be removed in the future+    * https://issues.redhat.com/browse/KEYCLOAK-2940 */     @Path(""logout"")     public Object logout() {         LogoutEndpoint endpoint = new LogoutEndpoint(tokenManager, realm, event);         ResteasyProviderFactory.getInstance().injectProperties(endpoint);         return endpoint;     } +    /* new logout endpoint  */+    @Path(""logout-v2"")","Sure, we will add the logout parts to the existing logout endpoint. This was the part where we didn't know how far the deprecation will go, that's why we create a new Endpoint class. Just to be clear, from @stianst comment ""You can ignore updating the logout endpoint as part of this, we'll handle that as a separate issue. Take a look at https://issues.redhat.com/browse/KEYCLOAK-11603 for more detail"", i understand now that we ignore the deprecation but add all methods to the existing LogoutEndpoint() is that correct? ",X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7272,460882403,2020-07-27T13:17:54Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCLoginProtocolService.java,"@@ -240,13 +250,23 @@ public Object issueUserInfo() {         return endpoint;     } +    /* old deprecated logout endpoint needs to be removed in the future+    * https://issues.redhat.com/browse/KEYCLOAK-2940 */     @Path(""logout"")     public Object logout() {         LogoutEndpoint endpoint = new LogoutEndpoint(tokenManager, realm, event);         ResteasyProviderFactory.getInstance().injectProperties(endpoint);         return endpoint;     } +    /* new logout endpoint  */+    @Path(""logout-v2"")","Yes, we can always refactor later to deprecate and have a new endpoint, ",X
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7267,461747292,2020-07-28T17:23:16Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/AbstractKeycloakTest.java,"@@ -16,640 +16,16 @@  */ package org.keycloak.testsuite; -import io.appium.java_client.AppiumDriver;-import org.apache.commons.configuration.ConfigurationException;-import org.apache.commons.configuration.PropertiesConfiguration;-import org.jboss.arquillian.container.test.api.RunAsClient;-import org.jboss.arquillian.drone.api.annotation.Drone;-import org.jboss.arquillian.graphene.page.Page;-import org.jboss.arquillian.test.api.ArquillianResource;-import org.jboss.logging.Logger;-import org.junit.After;-import org.junit.Before;-import org.junit.runner.RunWith;-import org.keycloak.admin.client.Keycloak;-import org.keycloak.admin.client.resource.AuthenticationManagementResource;-import org.keycloak.admin.client.resource.RealmsResource;-import org.keycloak.admin.client.resource.UserResource;-import org.keycloak.admin.client.resource.UsersResource;-import org.keycloak.common.util.KeycloakUriBuilder;-import org.keycloak.common.util.Time;-import org.keycloak.representations.idm.ClientRepresentation;-import org.keycloak.representations.idm.RealmRepresentation;-import org.keycloak.representations.idm.RequiredActionProviderRepresentation;-import org.keycloak.representations.idm.UserRepresentation;-import org.keycloak.services.resources.account.AccountFormService;-import org.keycloak.testsuite.admin.ApiUtil;-import org.keycloak.testsuite.arquillian.AuthServerTestEnricher;-import org.keycloak.testsuite.arquillian.KcArquillian;-import org.keycloak.testsuite.arquillian.SuiteContext;-import org.keycloak.testsuite.arquillian.TestContext;-import org.keycloak.testsuite.auth.page.AuthRealm;-import org.keycloak.testsuite.auth.page.AuthServer;-import org.keycloak.testsuite.auth.page.AuthServerContextRoot;-import org.keycloak.testsuite.auth.page.WelcomePage;-import org.keycloak.testsuite.auth.page.account.Account;-import org.keycloak.testsuite.auth.page.login.OIDCLogin;-import org.keycloak.testsuite.auth.page.login.UpdatePassword;-import org.keycloak.testsuite.client.KeycloakTestingClient;-import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;-import org.keycloak.testsuite.util.DroneUtils;-import org.keycloak.testsuite.util.OAuthClient;-import org.keycloak.testsuite.util.TestCleanup;-import org.keycloak.testsuite.util.TestEventsLogger;-import org.openqa.selenium.WebDriver;--import javax.ws.rs.NotFoundException;-import javax.ws.rs.core.UriBuilder;--import java.io.IOException;-import java.io.InputStream;-import java.io.PipedInputStream;-import java.io.PipedOutputStream;-import java.io.PrintWriter;-import java.net.URI;-import java.net.URISyntaxException;-import java.util.ArrayList;-import java.util.Arrays;-import java.util.Calendar;-import java.util.Collections;-import java.util.List;-import java.util.Map;-import java.util.Scanner;--import static org.hamcrest.Matchers.equalTo;-import static org.hamcrest.Matchers.is;-import static org.junit.Assert.assertThat;-import static org.keycloak.testsuite.admin.Users.setPasswordFor;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_HOST;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_PORT;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SCHEME;-import static org.keycloak.testsuite.util.ServerURLs.AUTH_SERVER_SSL_REQUIRED;-import static org.keycloak.testsuite.auth.page.AuthRealm.MASTER;-import static org.keycloak.testsuite.util.URLUtils.navigateToUri;-import static org.keycloak.testsuite.util.ServerURLs.removeDefaultPorts;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.arquillian.annotation.DisableFeature;  /**- *- * @author tkyjovsk+ * Old tests that use AbstractKeycloakTest assume that we are using the old+ * account console.+ * + * @author Stan Silvert  */-@RunWith(KcArquillian.class)-@RunAsClient-public abstract class AbstractKeycloakTest {",@ssilvert PTAL at https://github.com/ssilvert/keycloak/pull/8. It makes the enabling/disabling features more predictable so that we can disable NAC in abstract test class and the re-enable it in NAC tests.@mhajas Could you please check https://github.com/ssilvert/keycloak/pull/8/commits/82fd457246afbb56bb08d397bd7853e21073c5cf if it makes sense to you? It touches your `KeycloakContainerFeaturesController`.,X
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7220,462257855,2020-07-29T12:24:32Z,server-spi/src/main/java/org/keycloak/models/credential/PasswordCredentialModel.java,"@@ -15,7 +15,7 @@     private final PasswordCredentialData credentialData;     private final PasswordSecretData secretData; -    private PasswordCredentialModel(PasswordCredentialData credentialData, PasswordSecretData secretData) {+    public PasswordCredentialModel(PasswordCredentialData credentialData, PasswordSecretData secretData) {","@mposolda Yeah, you're right about the credential data. I was thinking about a separated and more general-purpose thing like what you mentioned before in regards to something like ""otherClaims"". And possibly avoid migration, etc.But if you think we can reuse that column, that is fine.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462261313,2020-07-29T12:30:47Z,distribution/server-x/src/main/content/bin/kc.sh,"@@ -41,7 +42,11 @@ do           fi           ;;       --config-file)-          SERVER_OPTS=""$SERVER_OPTS -Dkeycloak.config.file=$2""+          SERVER_OPTS=""$SERVER_OPTS -Dkc.config.file=$2""",Is this change correct? Under https://github.com/keycloak/keycloak-community/blob/master/design/keycloak.x/configuration.md#installation-layout I see keycloak.config-file .,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462263103,2020-07-29T12:33:55Z,distribution/server-x/src/main/content/bin/kc.sh,"@@ -77,10 +86,11 @@ if [ ""$DEBUG_MODE"" = ""true"" ]; then fi  CLASSPATH_OPTS=""$DIRNAME/../lib/quarkus-run.jar:$DIRNAME/../lib/main/*""+CONFIG_ARGS=""-Dkeycloak.config.args=${CONFIG_ARGS#?}""","The ""keycloak.config.args"" is also not mentioned anywhere under https://github.com/keycloak/keycloak-community/blob/master/design/keycloak.x/configuration.md, but I suppose you guys agree on this before?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462264282,2020-07-29T12:36:05Z,distribution/server-x/src/main/content/conf/keycloak.properties,"@@ -1,7 +1,5 @@ # Default Non-Production Grade Datasource-hibernate-orm.dialect=org.hibernate.dialect.H2Dialect-datasource.driver=org.h2.jdbcx.JdbcDataSource-datasource.url = jdbc:h2:file:${keycloak.home.dir}/data/keycloakdb;;AUTO_SERVER=TRUE-datasource.username = sa-datasource.password = keycloak-datasource.jdbc.transactions=xa\ No newline at end of file+database.vendor=h2+database.url = jdbc:h2:file:${keycloak.home.dir}/data/keycloakdb;;AUTO_SERVER=TRUE","This is bit different than the proposed value here https://github.com/keycloak/keycloak-community/blob/master/design/keycloak.x/configuration.md#database, but I suppose this is implementation detail? Having ""keycloakdb"" is probably better, so maybe alternative is to fix the specification page rather than this PR?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462265722,2020-07-29T12:38:46Z,quarkus/README.md,"@@ -32,8 +32,11 @@ The distribution packages (ZIP and TAR) should be available at [../distribution/  ## Running -    java -jar server/target/lib/quarkus-run.jar-    +By default, the HTTP port is disabled and you need to provide the key material to configure HTTPS. If you want to enable+the HTTP port, run the server in development mode as follows:++    java -Dquarkus.profile=dev -jar server/target/lib/quarkus-run.jar","Is this instructions up-to-date? I am seeing:- https://github.com/keycloak/keycloak-community/blob/master/design/keycloak.x/configuration.md#quarkus-options mentions that we may not expose quarkus options directly- https://github.com/keycloak/keycloak-community/blob/master/design/keycloak.x/configuration.md#profile mentions only ""profile.dev"" without the ""quarkus"" prefix.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462267982,2020-07-29T12:42:42Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/Providers.java,"@@ -0,0 +1,47 @@+package org.keycloak.quarkus.deployment;++import java.util.Arrays;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Map;+import java.util.Set;++import org.keycloak.Config;+import org.keycloak.connections.jpa.DefaultJpaConnectionProviderFactory;+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProviderFactory;+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;+import org.keycloak.provider.KeycloakDeploymentInfo;+import org.keycloak.provider.ProviderFactory;+import org.keycloak.provider.ProviderManager;+import org.keycloak.provider.Spi;+import org.keycloak.transaction.JBossJtaTransactionManagerLookup;++public final class Providers {++    public static Map<Spi, Set<Class<? extends ProviderFactory>>> load() {+        ProviderManager pm = new ProviderManager(+                KeycloakDeploymentInfo.create().services(), new BuildClassLoader(),+                Config.scope().getArray(""providers""));","The ""providers"" field is again not mentioned anywhere under https://github.com/keycloak/keycloak-community/blob/master/design/keycloak.x/configuration.md#spis-and-provider-configuration , but I suppose you guys agree on this?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462306107,2020-07-29T13:40:14Z,quarkus/runtime/src/test/java/org/keycloak/provider/quarkus/ConfigurationTest.java,"@@ -0,0 +1,167 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.provider.quarkus;++import static org.junit.Assert.assertEquals;++import java.lang.reflect.Field;+import java.util.HashMap;+import java.util.Map;+import java.util.Properties;++import io.smallrye.config.SmallRyeConfig;+import org.eclipse.microprofile.config.ConfigProvider;+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;+import org.junit.After;+import org.junit.Test;+import org.keycloak.Config;+import org.keycloak.configuration.KeycloakConfigSourceProvider;+import org.keycloak.configuration.MicroProfileConfigProvider;++import io.quarkus.runtime.configuration.ConfigUtils;+import io.smallrye.config.SmallRyeConfigProviderResolver;++public class ConfigurationTest {++    private static final Properties SYSTEM_PROPERTIES = (Properties) System.getProperties().clone();+    private static final Map<String, String> ENVIRONMENT_VARIABLES = new HashMap<>(System.getenv());++    @SuppressWarnings(""unchecked"")+    public static void putEnvVar(String name, String value) {+        Map<String, String> env = System.getenv();+        Field field = null;+        try {+            field = env.getClass().getDeclaredField(""m"");",Will this work for various java versions etc? I found this https://stackoverflow.com/questions/8168884/how-to-test-code-dependent-on-environment-variables-using-junit and I wonder if its better alternative?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462309883,2020-07-29T13:45:22Z,testsuite/integration-arquillian/servers/auth-server/quarkus/src/main/content/conf/keycloak.properties,"@@ -1,24 +1,20 @@ hostname.default.frontendUrl = ${keycloak.frontendUrl:} -# Datasource-datasource.jdbc.transactions=xa- # H2-hibernate-orm.dialect=org.hibernate.dialect.H2Dialect-datasource.driver=org.h2.jdbcx.JdbcDataSource-datasource.url = jdbc:h2:file:${keycloak.home.dir}/data/keycloakdb;AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1-datasource.username = sa-datasource.password = keycloak+database.vendor=h2+database.url = jdbc:h2:file:${keycloak.home.dir}/data/keycloakdb;AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1+database.username = sa+database.password = keycloak  # SSL-http.ssl.certificate.key-store-file=${keycloak.home.dir}/conf/keycloak.jks-http.ssl.certificate.key-store-password=secret-http.ssl.certificate.trust-store-file=${keycloak.home.dir}/conf/keycloak.truststore-http.ssl.certificate.trust-store-password=secret-http.ssl.client-auth=REQUEST+https.certificate.key-store-file=${keycloak.home.dir}/conf/keycloak.jks+https.certificate.key-store-password=secret+https.certificate.trust-store-file=${keycloak.home.dir}/conf/keycloak.truststore+https.certificate.trust-store-password=secret+https.client-auth=REQUEST  # Proxy-http.proxy-address-forwarding=true+quarkus.http.proxy-address-forwarding=true","Should this be changed to ""proxy.mode"" as mentioned in https://github.com/keycloak/keycloak-community/blob/master/design/keycloak.x/configuration.md#proxy-mode .",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462315697,2020-07-29T13:53:03Z,quarkus/runtime/src/test/java/org/keycloak/provider/quarkus/ConfigurationTest.java,"@@ -0,0 +1,167 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.provider.quarkus;++import static org.junit.Assert.assertEquals;++import java.lang.reflect.Field;+import java.util.HashMap;+import java.util.Map;+import java.util.Properties;++import io.smallrye.config.SmallRyeConfig;+import org.eclipse.microprofile.config.ConfigProvider;+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;+import org.junit.After;+import org.junit.Test;+import org.keycloak.Config;+import org.keycloak.configuration.KeycloakConfigSourceProvider;+import org.keycloak.configuration.MicroProfileConfigProvider;++import io.quarkus.runtime.configuration.ConfigUtils;+import io.smallrye.config.SmallRyeConfigProviderResolver;++public class ConfigurationTest {++    private static final Properties SYSTEM_PROPERTIES = (Properties) System.getProperties().clone();+    private static final Map<String, String> ENVIRONMENT_VARIABLES = new HashMap<>(System.getenv());++    @SuppressWarnings(""unchecked"")+    public static void putEnvVar(String name, String value) {+        Map<String, String> env = System.getenv();+        Field field = null;+        try {+            field = env.getClass().getDeclaredField(""m"");","On the other hand, I guess we may not want to introduce dependency on another library even for tests? Maybe just inspire from it or just go with you what you have (if you know it will work in various java versions we need to support).",