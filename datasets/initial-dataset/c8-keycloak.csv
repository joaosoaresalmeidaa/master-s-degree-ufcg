user_id,user_login,pull_request_url,comment_id,created_at,path,diff_hunk,content,code_smell
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7290,462472918,2020-07-29T17:39:41Z,distribution/server-x/src/main/content/conf/keycloak.properties,"@@ -1,7 +1,5 @@ # Default Non-Production Grade Datasource-hibernate-orm.dialect=org.hibernate.dialect.H2Dialect-datasource.driver=org.h2.jdbcx.JdbcDataSource-datasource.url = jdbc:h2:file:${keycloak.home.dir}/data/keycloakdb;;AUTO_SERVER=TRUE-datasource.username = sa-datasource.password = keycloak-datasource.jdbc.transactions=xa\ No newline at end of file+database.vendor=h2+database.url = jdbc:h2:file:${keycloak.home.dir}/data/keycloakdb;;AUTO_SERVER=TRUE","Another point of discussion, the distribution should default to `h2` == `file`. But nothing stop us to also have a `database.vendor` == `h2-mem`.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7305,462991968,2020-07-30T13:22:58Z,services/src/main/java/org/keycloak/storage/RoleStorageManager.java,"@@ -0,0 +1,239 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.storage;++import java.util.LinkedList;+import java.util.List;+import java.util.stream.Stream;+import org.jboss.logging.Logger;+import org.keycloak.common.util.reflections.Types;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RoleModel;+import org.keycloak.models.RoleProvider;+import org.keycloak.storage.role.RoleLookupProvider;+import org.keycloak.storage.role.RoleStorageProvider;+import org.keycloak.storage.role.RoleStorageProviderFactory;+import org.keycloak.storage.role.RoleStorageProviderModel;+import org.keycloak.utils.ServicesUtils;++public class RoleStorageManager implements RoleProvider {",This class doesn't implement methods `removeRoles(realm/client)`.,
5397858,Norwae,https://api.github.com/repos/keycloak/keycloak/pulls/7220,465049781,2020-08-04T13:28:20Z,server-spi/src/main/java/org/keycloak/models/credential/dto/PasswordSecretData.java,"@@ -26,9 +40,15 @@ public PasswordSecretData(@JsonProperty(""value"") String value, @JsonProperty(""sa         }     } +    /**+     * Default creator (Secret consists only of a value and a single salt)+     * @param value hash value+     * @param salt salt+     */     public PasswordSecretData(String value, byte[] salt) {         this.value = value;         this.salt = salt;+        this.additionalParameters = new MultivaluedHashMap<>();","Doing so would require me to give up the `final` modifier on the fields (lazy creation), or alternatively allow the field to be `null`. Since all the explicitly-modeled fields are `final` in these types, I would prefer to not break this pattern (principle of least surprise). Again, I will defer to your judgement here, but I at least wanted to raise the point.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7316,465138963,2020-08-04T15:31:15Z,themes/src/main/resources/theme/keycloak/common/resources/node_modules/angular-translate/dist/angular-translate.js,"@@ -2014,7 +2014,7 @@ function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvide               deferred.reject(applyNotFoundIndicators(_translationId));","This is not really our code, not sure if makes sense to change this one if they could be reverted once the library is updated.@ssilvert makes sense?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7317,465148386,2020-08-04T15:44:52Z,server-spi/src/main/java/org/keycloak/models/ActionToken.java,"@@ -0,0 +1,43 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++/**+* Entity for generate-action-token service endpoint.+* @author VerHext+*/++package org.keycloak.models;++public class ActionToken {","I would just avoid having this class but building the JSON response with the ""token"" claim.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7220,465209347,2020-08-04T17:22:34Z,server-spi/src/main/java/org/keycloak/models/credential/dto/PasswordSecretData.java,"@@ -26,9 +40,15 @@ public PasswordSecretData(@JsonProperty(""value"") String value, @JsonProperty(""sa         }     } +    /**+     * Default creator (Secret consists only of a value and a single salt)+     * @param value hash value+     * @param salt salt+     */     public PasswordSecretData(String value, byte[] salt) {         this.value = value;         this.salt = salt;+        this.additionalParameters = new MultivaluedHashMap<>();",I prefer the lazy creation or maybe you can just initialize as an empty collection when the instance is created using this constructor?,
25115243,waigel,https://api.github.com/repos/keycloak/keycloak/pulls/7317,465281362,2020-08-04T19:30:28Z,server-spi/src/main/java/org/keycloak/models/ActionToken.java,"@@ -0,0 +1,43 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++/**+* Entity for generate-action-token service endpoint.+* @author VerHext+*/++package org.keycloak.models;++public class ActionToken {",You're right. I have now removed the class.,
10135727,fidgi,https://api.github.com/repos/keycloak/keycloak/pulls/7317,465551330,2020-08-05T08:11:20Z,services/src/main/java/org/keycloak/services/resources/admin/UserResource.java,"@@ -845,6 +870,28 @@ public Response executeActionsEmail(@QueryParam(OIDCLoginProtocol.REDIRECT_URI_P         }     } +     /**+     * Generate action tokens endpoint+     *+     * Returns a token to perform a set of required actions. The clientId parameters are+     * optional.+     *+     * @param clientId Client id",missing redirectUri parameter in the JavaDoc,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7298,466293878,2020-08-06T09:42:31Z,themes/src/main/resources/theme/keycloak/common/resources/package.json,"@@ -22,6 +22,7 @@     ""jquery"": ""3.5.1"",     ""ng-file-upload"": ""12.2.13"",     ""patternfly"": ""3.59.4"",+    ""@patternfly/patternfly"": ""4.23.3"",",Just a general comment unrelated to this line. I believe we'll have to [update the licenses](https://github.com/keycloak/keycloak/blob/191c9753decfb9d4338503d4390444c5da29e937/docs/dependency-license-information.md) for this.,
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7298,466451456,2020-08-06T14:25:13Z,themes/src/main/resources/theme/keycloak/common/resources/node_modules/@patternfly/patternfly/sass-utilities/scss-variables.scss,"@@ -0,0 +1,309 @@+// This file is for initial variable values.+// All variables should have a valid css value,+// and use !default so they can be overwritten.++// `$pf-global--concept--PropiertyCamelCase--modifier--state`++// Patternfly options+//+// Quickly modify global styling by enabling or disabling optional features.+$pf-global--enable-reset: false !default;","@vmuzikar yes, you're correct, this line was edited manually according to the instructions mentioned here:https://github.com/patternfly/patternfly/blame/master/src/site/pages/upgrade-guide.md#L13Regarding the future update we will simply set the property back to the default value.",
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7298,466474541,2020-08-06T14:57:20Z,themes/src/main/resources/theme/keycloak/common/resources/node_modules/@patternfly/patternfly/sass-utilities/scss-variables.scss,"@@ -0,0 +1,309 @@+// This file is for initial variable values.+// All variables should have a valid css value,+// and use !default so they can be overwritten.++// `$pf-global--concept--PropiertyCamelCase--modifier--state`++// Patternfly options+//+// Quickly modify global styling by enabling or disabling optional features.+$pf-global--enable-reset: false !default;","> > > Thanks @Pepo48! Changes as such look good to me but at the same time I'm not sure if this is a valid change as a standalone. I understand that the ultimate goal is to migrate login theme from PF3 to PF4, correct? But what this PR does is it ""just"" adds a new dependency to the project without actually using it. So e.g. if there were a release in the mean time, it would include a lots of new files that would be unused. But I also understand that the point here is to make small steps in each PR. So I'll leave this up to @ssilvert whether this is ok or not.@vmuzikar exactly, that was actually the main question - what approach to choose? Whether to create one big PR with the package upgrade and all the screens update or divide it to smaller steps... We've chose the second option and therefore none of the theme.properties files are changed in this PR.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7323,467085265,2020-08-07T14:43:06Z,services/src/main/java/org/keycloak/social/apple/AppleIdentityProvider.java,"@@ -0,0 +1,311 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.social.apple;++import com.fasterxml.jackson.core.JsonProcessingException;+import com.fasterxml.jackson.databind.JsonNode;+import com.fasterxml.jackson.databind.ObjectMapper;+import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.broker.oidc.AbstractOAuth2IdentityProvider;+import org.keycloak.broker.oidc.mappers.AbstractJsonUserAttributeMapper;+import org.keycloak.broker.provider.*;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.broker.social.SocialIdentityProvider;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.crypto.*;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.jose.jws.JWSBuilder;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.jose.jws.crypto.RSAProvider;+import org.keycloak.keys.loader.PublicKeyStorageManager;+import org.keycloak.models.*;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.ErrorPage;+import org.keycloak.services.Urls;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.FormParam;+import javax.ws.rs.POST;+import javax.ws.rs.WebApplicationException;+import javax.ws.rs.core.*;+import java.security.KeyFactory;+import java.security.NoSuchAlgorithmException;+import java.security.PrivateKey;+import java.security.PublicKey;+import java.security.spec.InvalidKeySpecException;+import java.security.spec.PKCS8EncodedKeySpec;+import java.util.Base64;++/**+ * @author Emilien Bondu+ */+public class AppleIdentityProvider extends AbstractOAuth2IdentityProvider<AppleIdentityProviderConfig> implements+        SocialIdentityProvider<AppleIdentityProviderConfig> {++    private static final String OAUTH2_PARAMETER_CODE = ""code"";++    private static final String OAUTH2_PARAMETER_STATE = ""state"";++    private static final String OAUTH2_PARAMETER_USER = ""user"";++    public static final String ACCESS_DENIED = ""access_denied"";++    protected static ObjectMapper mapper = new ObjectMapper();++    public static final String AUTH_URL = ""https://appleid.apple.com/auth/authorize?response_mode=form_post"";++    public static final String TOKEN_URL = ""https://appleid.apple.com/auth/token"";++    public static final String ISSUER = ""https://appleid.apple.com"";++    public static final String JWKS_URL = ""https://appleid.apple.com/auth/keys"";++    public static final String EMAIL_SCOPE = ""email"";++    public static final String NAME_SCOPE = ""name"";++    protected static final Logger logger = Logger.getLogger(AppleIdentityProvider.class);++    public AppleIdentityProvider(KeycloakSession session, AppleIdentityProviderConfig config) {+        super(session, config);++        config.setAuthorizationUrl(AUTH_URL);+        config.setTokenUrl(TOKEN_URL);+        config.setClientAuthMethod(OIDCLoginProtocol.CLIENT_SECRET_POST);+        config.setIssuer(ISSUER);+        config.setUseJwksUrl(true);+        config.setValidateSignature(true);+        config.setJwksUrl(JWKS_URL);+        String defaultScope = config.getDefaultScope();++        String privateKeyContent = config.getP8Content();++        try {+            KeyFactory kf = KeyFactory.getInstance(""ECDSA"");","But don't worry about realm's key too much. It was an idea and I'm not sure if it will fit here.Btw, this method may also be useful `org.keycloak.broker.oidc.AbstractOAuth2IdentityProvider#getSignatureContext`. Also note that the base classes should also support JWT authentication already. See `org.keycloak.broker.oidc.AbstractOAuth2IdentityProvider#authenticateTokenRequest`.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,467880406,2020-08-10T12:50:50Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/DeleteAccountPage.java,"@@ -0,0 +1,32 @@+package org.keycloak.testsuite.ui.account2.page;++import javax.ws.rs.core.UriBuilder;++import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++/**+ * @author Zakaria Amine <zakaria.amine88@gmail.com>+ */+public class DeleteAccountPage extends AbstractLoggedInPage  {++  @FindBy(id = ""delete-account-btn"")+  private WebElement deleteButton;++  @Override+  public String getPageId() {+    return ""delete-account"";+  }++  public String getPath() {+    return UriBuilder.fromPath(this.getAuthRoot()).path(""realms"").path(TEST).path(""account"").buildFromEncoded(""/#/delete-account"").toString();+  }",This method is unused.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,467906885,2020-08-10T13:34:36Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/DeleteAccountTest.java,"@@ -0,0 +1,210 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.ui.account2;++import java.net.URI;+import java.util.Arrays;+import java.util.List;+import java.util.Objects;+import java.util.concurrent.TimeUnit;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Assert;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.RequiredActionProviderRepresentation;+import org.keycloak.representations.idm.RoleRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.ui.account2.page.AbstractLoggedInPage;+import org.keycloak.testsuite.ui.account2.page.DeleteAccountPage;+import org.keycloak.testsuite.ui.account2.page.WelcomeScreen;+import org.keycloak.testsuite.util.UserBuilder;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;++/**+ * @author Zakaria Amine <zakaria.amine88@gmail.com>+ */+public class DeleteAccountTest extends BaseAccountPageTest {++  @Page+  private DeleteAccountPage deleteAccountPage;++  @Page+  private WelcomeScreen welcomeScreen;++  @Rule+  public AssertEvents events = new AssertEvents(this);++  @Override+  protected AbstractLoggedInPage getAccountPage() {+    return deleteAccountPage;+  }++  @Override+  public void navigateBeforeTest() {+    super.navigateBeforeTest();+  }++  @Override+  @Test+  public void navigationTest() {+    enableDeleteAccountRequiredAction();+    addDeleteAccountRoleToUserClientRoles();+    driver.navigate().refresh();+    super.navigationTest();+    disableDeleteAccountRequiredAction();+    removeDeleteAccountRoleToUserClientRoles();+  }++  @Test+  public void deleteOwnAccountPageNotVisibleAndNotAccessibleWithoutUserRole() {+    enableDeleteAccountRequiredAction();+    List<WebElement> accountLinks = driver.findElements(By.cssSelector(""div[id^=\""landing-\""]""));+   Assert.assertTrue(accountLinks.stream().noneMatch(link -> link.getAttribute(""id"").contains(""delete-account"")));",Please try to avoid using selectors directly in tests. This way you copy-paste some logic and it's the hard to fix if something changes in the page and all selectors have to be updated. Please include it in Page Objects instead.I presume this was supposed to test the links on Welcome Screen (the `landing-` prefix). Therefore this test technically belongs to the `WelcomeScreenTest`. Maybe you could add something like this to the `WelcomeScreenTest` to make it consistent with other similar tests:https://github.com/keycloak/keycloak/blob/c20766f2d793b42bed4c26e390d46e4e359d559d/testsuite/integration-arquillian/tests/other/baseui/src/test/java/org/keycloak/testsuite/ui/account2/WelcomeScreenTest.java#L114-L122,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,467911655,2020-08-10T13:41:48Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/DeleteAccountTest.java,"@@ -0,0 +1,210 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.ui.account2;++import java.net.URI;+import java.util.Arrays;+import java.util.List;+import java.util.Objects;+import java.util.concurrent.TimeUnit;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Assert;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.RequiredActionProviderRepresentation;+import org.keycloak.representations.idm.RoleRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.ui.account2.page.AbstractLoggedInPage;+import org.keycloak.testsuite.ui.account2.page.DeleteAccountPage;+import org.keycloak.testsuite.ui.account2.page.WelcomeScreen;+import org.keycloak.testsuite.util.UserBuilder;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;++/**+ * @author Zakaria Amine <zakaria.amine88@gmail.com>+ */+public class DeleteAccountTest extends BaseAccountPageTest {++  @Page+  private DeleteAccountPage deleteAccountPage;++  @Page+  private WelcomeScreen welcomeScreen;++  @Rule+  public AssertEvents events = new AssertEvents(this);++  @Override+  protected AbstractLoggedInPage getAccountPage() {+    return deleteAccountPage;+  }++  @Override+  public void navigateBeforeTest() {+    super.navigateBeforeTest();+  }++  @Override+  @Test+  public void navigationTest() {+    enableDeleteAccountRequiredAction();+    addDeleteAccountRoleToUserClientRoles();+    driver.navigate().refresh();+    super.navigationTest();+    disableDeleteAccountRequiredAction();+    removeDeleteAccountRoleToUserClientRoles();+  }++  @Test+  public void deleteOwnAccountPageNotVisibleAndNotAccessibleWithoutUserRole() {+    enableDeleteAccountRequiredAction();+    List<WebElement> accountLinks = driver.findElements(By.cssSelector(""div[id^=\""landing-\""]""));+   Assert.assertTrue(accountLinks.stream().noneMatch(link -> link.getAttribute(""id"").contains(""delete-account"")));+    deleteAccountPage.navigateTo();+    pageNotFound.assertCurrent();+    //reset role back since realm is shared among tests+    disableDeleteAccountRequiredAction();+  }+++  @Test+  public void deleteOwnAccountPageNotVisibleAndNotAccessibleWithoutDeleteAccountActionEnabled() {+    addDeleteAccountRoleToUserClientRoles();+    List<WebElement>  accountLinks = driver.findElements(By.cssSelector(""div[id^=\""landing-\""]""));+    Assert.assertTrue(accountLinks.stream().noneMatch(link -> link.getAttribute(""id"").contains(""delete-account"")));+    deleteAccountPage.navigateTo();+    pageNotFound.assertCurrent();+    removeDeleteAccountRoleToUserClientRoles();+  }++  @Test+  public void deleteOwnAccountAIACancellationSucceeds() {+    enableDeleteAccountRequiredAction();+    addDeleteAccountRoleToUserClientRoles();+    deleteAccountPage.navigateTo();+    deleteAccountPage.getDeleteAccountButton().click();+    loginToAccount();+    URI uri = URI.create(driver.getCurrentUrl());+    Assert.assertTrue(uri.getPath().contains(""login-actions""));+    Assert.assertTrue(uri.getQuery().contains(""execution=delete_account""));+    driver.findElement(By.cssSelector(""button[name='cancel-aia']"")).click();","Please create a Page Object for this, similar to e.g. [`UpdatePassword`](https://github.com/keycloak/keycloak/blob/65f51b7b83271bc42de923b3625cac8a69e8e9a2/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/auth/page/login/UpdatePassword.java).",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,467919386,2020-08-10T13:53:31Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/DeleteAccountTest.java,"@@ -0,0 +1,210 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.ui.account2;++import java.net.URI;+import java.util.Arrays;+import java.util.List;+import java.util.Objects;+import java.util.concurrent.TimeUnit;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Assert;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.RequiredActionProviderRepresentation;+import org.keycloak.representations.idm.RoleRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.ui.account2.page.AbstractLoggedInPage;+import org.keycloak.testsuite.ui.account2.page.DeleteAccountPage;+import org.keycloak.testsuite.ui.account2.page.WelcomeScreen;+import org.keycloak.testsuite.util.UserBuilder;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;++/**+ * @author Zakaria Amine <zakaria.amine88@gmail.com>+ */+public class DeleteAccountTest extends BaseAccountPageTest {","A generic comment for this test. I believe you could move setting up the required action and assigning the roles to the user to `addTestRealms` or `afterAbstractKeycloakTestRealmImport`, similarly to e.g. [`LinkedAccountsTest`](https://github.com/keycloak/keycloak/blob/4c17fa86640e8336dd0080fc0cf1aba6aeeeabb7/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/LinkedAccountsTest.java#L78-L111) and [`SigningInTest`](https://github.com/keycloak/keycloak/blob/deead471a97c2ee812925f77cfa8b66c69a3c58b/testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java#L97-L131), respectively. Checks for the navigation link presence should be moved to the `WelcomeScreenTest` where similar tests like that are.This would make the test much more clean, remove repetitively calling `enableDeleteAccountRequiredAction`, `addDeleteAccountRoleToUserClientRoles`, `disableDeleteAccountRequiredAction`, `removeDeleteAccountRoleToUserClientRoles` as well as it would remove the need to override `navigationTest` and call `deleteAccountPage.navigateTo();` before most of the tests.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,467926118,2020-08-10T14:03:34Z,server-spi-private/src/main/java/org/keycloak/migration/migrators/MigrateTo12_0_0.java,"@@ -0,0 +1,28 @@+package org.keycloak.migration.migrators;++import java.util.Objects;++import org.keycloak.migration.ModelVersion;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.KeycloakSession;++public class MigrateTo12_0_0 implements Migration {",Should we add a test for this to [`MigrationTest`](https://github.com/keycloak/keycloak/blob/c403aa49f724fec793e3babc3de4bf4e9753bf24/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/migration/MigrationTest.java)?,
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7278,471561788,2020-08-17T15:33:49Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/UpdatingClientSourceCondition.java,"@@ -58,9 +58,9 @@ private boolean isAuthMethodMatched(String authMethod) {         if (authMethod == null) return false;          ClientPolicyLogger.log(logger, ""auth method = "" + authMethod);-        componentModel.getConfig().get(TestAuthnMethodsConditionFactory.AUTH_METHOD).stream().forEach(i -> ClientPolicyLogger.log(logger, ""auth method expected = "" + i));+        componentModel.getConfig().get(UpdatingClientSourceConditionFactory.UPDATE_CLIENT_SOURCE).stream().forEach(i -> ClientPolicyLogger.log(logger, ""auth method expected = "" + i));","Call to stream().forEach() can be simplified by removing `stream`:```componentModel.getConfig().get(UpdatingClientSourceConditionFactory.UPDATE_CLIENT_SOURCE).forEach(i -> ClientPolicyLogger.log(logger, ""auth method expected = "" + i));```",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7278,471577763,2020-08-17T15:57:31Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java,"@@ -496,11 +496,11 @@ public void testMultiplePolicies() throws ClientRegistrationException, ClientPol         registerCondition(""TestClientRolesCondition-alpha"", policyAlphaName);         logger.info(""... Registered Condition : TestClientRolesCondition-alpha""); -        createCondition(""TestAuthnMethodsCondition-alpha"", TestAuthnMethodsConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {-            setConditionRegistrationMethods(provider, new ArrayList<>(Arrays.asList(TestAuthnMethodsConditionFactory.BY_AUTHENTICATED_USER)));+        createCondition(""UpdatingClientSourceCondition-alpha"", UpdatingClientSourceConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            setConditionRegistrationMethods(provider, new ArrayList<>(Arrays.asList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER)));",`new ArrayList<>(Arrays.asList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER))`This collection seems to be an immutable list - maybe we could use `Collections.singletonList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER)`Since the collection will be immutable it will reduce possible states of the tests that will make it more 'specific',
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7278,471578537,2020-08-17T15:58:30Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java,"@@ -433,11 +433,11 @@ public void testCreateUpdateDeleteExecutorRuntime() throws ClientRegistrationExc         registerCondition(""TestClientRolesCondition"", policyName);         logger.info(""... Registered Condition : TestClientRolesCondition""); -        createCondition(""TestAuthnMethodsCondition"", TestAuthnMethodsConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {-            setConditionRegistrationMethods(provider, new ArrayList<>(Arrays.asList(TestAuthnMethodsConditionFactory.BY_AUTHENTICATED_USER)));+        createCondition(""UpdatingClientSourceCondition"", UpdatingClientSourceConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            setConditionRegistrationMethods(provider, new ArrayList<>(Arrays.asList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER)));",`new ArrayList<>(Arrays.asList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER))`This collection seems to be an immutable list - maybe we could use `Collections.singletonList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER)`Since the collection will be immutable it will reduce possible states of the tests that will make it more 'specific',
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7278,471579098,2020-08-17T15:59:31Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java,"@@ -579,11 +579,11 @@ private void setupPolicyAcceptableAuthType(String policyName) {         createPolicy(policyName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);         logger.info(""... Created Policy : "" + policyName); -        createCondition(""TestAuthnMethodsCondition"", TestAuthnMethodsConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {-            setConditionRegistrationMethods(provider, new ArrayList<>(Arrays.asList(TestAuthnMethodsConditionFactory.BY_AUTHENTICATED_USER)));+        createCondition(""UpdatingClientSourceCondition"", UpdatingClientSourceConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            setConditionRegistrationMethods(provider, new ArrayList<>(Arrays.asList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER)));",`new ArrayList<>(Arrays.asList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER))`This collection seems to be an immutable list - maybe we could use `Collections.singletonList(UpdatingClientSourceConditionFactory.BY_AUTHENTICATED_USER)`Since the collection will be immutable it will reduce possible states of the tests that will make it more 'specific',
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7278,471579317,2020-08-17T15:59:52Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java,"@@ -601,11 +601,11 @@ private void setupPolicyAuthzCodeFlowUnderMultiPhasePolicy(String policyName) {         createPolicy(policyName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);         logger.info(""... Created Policy : "" + policyName); -        createCondition(""TestAuthnMethodsCondition"", TestAuthnMethodsConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {-            setConditionRegistrationMethods(provider, new ArrayList<>(Arrays.asList(TestAuthnMethodsConditionFactory.BY_INITIAL_ACCESS_TOKEN)));+        createCondition(""UpdatingClientSourceCondition"", UpdatingClientSourceConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            setConditionRegistrationMethods(provider, new ArrayList<>(Arrays.asList(UpdatingClientSourceConditionFactory.BY_INITIAL_ACCESS_TOKEN)));",`ArrayList<>(Arrays.asList(UpdatingClientSourceConditionFactory.BY_INITIAL_ACCESS_TOKEN))`This collection seems to be an immutable list - maybe we could use `Collections.singletonList(UpdatingClientSourceConditionFactory.BY_INITIAL_ACCESS_TOKEN)`Since the collection will be immutable it will reduce possible states of the tests that will make it more 'specific',
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7302,473043801,2020-08-19T13:49:16Z,services/src/main/java/org/keycloak/services/resources/admin/UserResource.java,"@@ -465,40 +465,39 @@ public void removeFederatedIdentity(final @PathParam(""provider"") String provider     @Produces(MediaType.APPLICATION_JSON)     public List<Map<String, Object>> getConsents() {         auth.users().requireView(user);-        List<Map<String, Object>> result = new LinkedList<>();          Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user); -        for (ClientModel client : realm.getClients()) {-            UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());-            boolean hasOfflineToken = offlineClients.contains(client);--            if (consent == null && !hasOfflineToken) {-                continue;-            }--            UserConsentRepresentation rep = (consent == null) ? null : ModelToRepresentation.toRepresentation(consent);--            Map<String, Object> currentRep = new HashMap<>();-            currentRep.put(""clientId"", client.getClientId());-            currentRep.put(""grantedClientScopes"", (rep==null ? Collections.emptyList() : rep.getGrantedClientScopes()));-            currentRep.put(""createdDate"", (rep==null ? null : rep.getCreatedDate()));-            currentRep.put(""lastUpdatedDate"", (rep==null ? null : rep.getLastUpdatedDate()));--            List<Map<String, String>> additionalGrants = new LinkedList<>();-            if (hasOfflineToken) {-                Map<String, String> offlineTokens = new HashMap<>();-                offlineTokens.put(""client"", client.getId());-                // TODO: translate-                offlineTokens.put(""key"", ""Offline Token"");-                additionalGrants.add(offlineTokens);-            }-            currentRep.put(""additionalGrants"", additionalGrants);--            result.add(currentRep);-        }--        return result;+        return session.clients().getClientsStream(realm)+                .map(client -> {+                    UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());+                    boolean hasOfflineToken = offlineClients.contains(client);++                    if (consent == null && !hasOfflineToken) {+                        return null;+                    }++                    UserConsentRepresentation rep = (consent == null) ? null : ModelToRepresentation.toRepresentation(consent);++                    Map<String, Object> currentRep = new HashMap<>();+                    currentRep.put(""clientId"", client.getClientId());+                    currentRep.put(""grantedClientScopes"", (rep == null ? Collections.emptyList() : rep.getGrantedClientScopes()));+                    currentRep.put(""createdDate"", (rep == null ? null : rep.getCreatedDate()));+                    currentRep.put(""lastUpdatedDate"", (rep == null ? null : rep.getLastUpdatedDate()));++                    List<Map<String, String>> additionalGrants = new LinkedList<>();+                    if (hasOfflineToken) {+                        Map<String, String> offlineTokens = new HashMap<>();+                        offlineTokens.put(""client"", client.getId());+                        // TODO: translate+                        offlineTokens.put(""key"", ""Offline Token"");+                        additionalGrants.add(offlineTokens);+                    }+                    currentRep.put(""additionalGrants"", additionalGrants);+                    return currentRep;+                })+                .filter(Objects::nonNull)+                .collect(Collectors.toList());",Can this be broken down to remove dependency on offlineClients and extracted to a named method rather than anonymous method?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7346,474713054,2020-08-21T13:54:37Z,services/src/main/java/org/keycloak/storage/AbstractStorageManager.java,"@@ -0,0 +1,170 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.storage;++import org.keycloak.Config;+import org.keycloak.component.ComponentFactory;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.provider.Provider;+import org.keycloak.utils.ServicesUtils;++import java.util.function.Function;+import java.util.stream.Stream;++/**+ *+ * @param <ProviderType> This type will be used for looking for factories that produce instances of desired providers+ * @param <StorageProviderModelType> Type of model used for creating provider, it needs to extend + *                                  CacheableStorageProviderModel as it has {@code isEnabled()} method and also extend+ *                                  PrioritizedComponentModel which is required for sorting providers based on its+ *                                  priorities+ */+public abstract class AbstractStorageManager<ProviderType extends Provider,+        StorageProviderModelType extends CacheableStorageProviderModel> {++    /**+     * Timeouts are used as time boundary for obtaining models from an external storage. Default value is set+     * to 3000 milliseconds and it's configurable.+     */+    private static final Long STORAGE_PROVIDER_DEFAULT_TIMEOUT = 3000L;+    protected final KeycloakSession session;+    private Long storageProviderTimeout;++    public AbstractStorageManager(KeycloakSession session) {+        this.session = session;+    }++    /**+     * Turns ComponentModel class, to desired StorageProviderModelType.+     *+     * @param componentModel ComponentModel obtained from database/storage+     * @return desired StorageProviderModelType+     */+    protected abstract StorageProviderModelType toStorageProviderModelType(ComponentModel componentModel);++    /**+     *+     * @return Class of ProviderType, used for obtaining factories, that produce desired CreatedProviderType,+     * and ComponentModels+     */+    protected abstract Class<ProviderType> getProviderTypeClass();+    protected abstract String getConfigScope();++    protected Long getStorageProviderTimeout() {+        if (storageProviderTimeout == null) {+            storageProviderTimeout = Config.scope(getConfigScope()).getLong(""storageProviderTimeout"", STORAGE_PROVIDER_DEFAULT_TIMEOUT);+        }+        return storageProviderTimeout;+    }++    /**+     * Returns a factory with the providerId, which produce instances of type CreatedProviderType+     * @param providerId id of factory that produce desired instances+     * @return A factory that implements {@code ComponentFactory<CreatedProviderType, ProviderType>}+     */+    protected <T extends ProviderType> ComponentFactory<T, ProviderType> getStorageProviderFactory(String providerId) {+        return (ComponentFactory<T, ProviderType>) session.getKeycloakSessionFactory()+                .getProviderFactory(getProviderTypeClass(), providerId);+    }++    /**+     *+     * @param realm realm+     * @return enabled storage providers for realm and @{code getProviderTypeClass()}+     */+    protected Stream<ProviderType> getEnabledStorageProviders(RealmModel realm) {+        return getStorageProviderModels(realm, getProviderTypeClass())+                .map(this::toStorageProviderModelType)+                .filter(StorageProviderModelType::isEnabled)+                .sorted(StorageProviderModelType.comparator)+                .map(this::getStorageProviderInstance);+    }++    /**+     * Gets all enabled StorageProviders, applies applyFunction on each of them and then join the results together.+     *+     * !! Each StorageProvider has a limited time to respond, if it fails to do it, empty stream is returned !!+     *+     * @param realm realm+     * @param applyFunction function that is applied on StorageProviders+     * @param <R> result of applyFunction+     * @return a stream with all results from all StorageProviders+     */+    protected <R> Stream<R> applyOnEnabledStorageProvidersWithTimeout(RealmModel realm, Function<ProviderType, ? extends Stream<R>> applyFunction) {+        return getEnabledStorageProviders(realm).flatMap(ServicesUtils.timeBound(session,+                    getStorageProviderTimeout(), applyFunction));+    }++    /**+     * Returns an instance of provider with the providerId within the realm.+     * @param realm realm+     * @param providerId id of ComponentModel within database/storage+     * @return an instance of type CreatedProviderType+     */+    protected ProviderType getStorageProviderInstance(RealmModel realm, String providerId) {+        ComponentModel componentModel = realm.getComponent(providerId);+        if (componentModel == null) {+            return null;+        }+        +        return getStorageProviderInstance(toStorageProviderModelType(componentModel));+    }++    /**+     * Returns an instance of provider for the model+     * @param model StorageProviderModel obtained from database/storage+     * @return an instance of type CreatedProviderType+     */+    protected ProviderType getStorageProviderInstance(StorageProviderModelType model) {+        // TODO: Add type checking.","I believe this can be omitted. Failing the check would cause and exception raised here in runtime, or some sort of exception (likely related to class-casting) later. From my POV, a proper check should be rather on the factory level.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7111,475390186,2020-08-24T07:21:12Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -965,6 +965,9 @@ module.controller('RealmIdentityProviderCtrl', function($scope, $filter, $upload         for (var key in data) {             $scope.identityProvider.config[key] = data[key];         }+        if (data[""enabledFromMetadata""] !== undefined ) {+            $scope.identityProvider.enabled = data[""enabledFromMetadata""] == ""true"";",`enabledFromMetadata` should be also removed from `$scope.identityProvider.config`.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7346,475602110,2020-08-24T13:33:06Z,services/src/main/java/org/keycloak/storage/GroupStorageManager.java,"@@ -0,0 +1,144 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.storage;++import org.keycloak.component.ComponentModel;+import org.keycloak.models.GroupModel;+import org.keycloak.models.GroupProvider;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RoleModel;+import org.keycloak.storage.group.GroupLookupProvider;+import org.keycloak.storage.group.GroupStorageProvider;+import org.keycloak.storage.group.GroupStorageProviderModel;+import org.keycloak.utils.ServicesUtils;++import java.util.List;+import java.util.stream.Collectors;+import java.util.stream.Stream;++public class GroupStorageManager extends AbstractStorageManager<GroupStorageProvider, GroupStorageProviderModel> implements GroupProvider {++    public GroupStorageManager(KeycloakSession session) {+        super(session);","Could be ```suggestion        super(session, GroupStorageProvider.class, GroupStorageProviderModel::new);```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7346,475603176,2020-08-24T13:34:46Z,services/src/main/java/org/keycloak/storage/AbstractStorageManager.java,"@@ -0,0 +1,162 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.storage;++import org.keycloak.Config;+import org.keycloak.component.ComponentFactory;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.provider.Provider;+import org.keycloak.utils.ServicesUtils;++import java.util.function.Function;+import java.util.stream.Stream;++/**+ *+ * @param <ProviderType> This type will be used for looking for factories that produce instances of desired providers+ * @param <StorageProviderModelType> Type of model used for creating provider, it needs to extend + *                                  CacheableStorageProviderModel as it has {@code isEnabled()} method and also extend+ *                                  PrioritizedComponentModel which is required for sorting providers based on its+ *                                  priorities+ */+public abstract class AbstractStorageManager<ProviderType extends Provider,+        StorageProviderModelType extends CacheableStorageProviderModel> {++    /**+     * Timeouts are used as time boundary for obtaining models from an external storage. Default value is set+     * to 3000 milliseconds and it's configurable.+     */+    private static final Long STORAGE_PROVIDER_DEFAULT_TIMEOUT = 3000L;+    protected final KeycloakSession session;+    private Long storageProviderTimeout;++    public AbstractStorageManager(KeycloakSession session) {","Could be ```suggestion    public AbstractStorageManager(KeycloakSession session, Class<ProviderType> providerTypeClass, Function<ComponentModel, StorageProviderModelType> componentToStorageProvider) {```",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7334,475603701,2020-08-24T13:35:31Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/openshift/OpenShiftTokenReviewEndpointTest.java,"@@ -228,29 +241,10 @@ public void customScopes() {     }      @Test-    public void emptyScope() throws Exception {-        ClientRepresentation clientRep = testRealm().clients().findByClientId(""test-app"").get(0);-        List<ClientScopeRepresentation> scopesBefore = testRealm().clients().get(clientRep.getId()).getDefaultClientScopes();--        try (ClientAttributeUpdater cau = ClientAttributeUpdater.forClient(adminClient, ""test"", clientRep.getClientId())-                .setConsentRequired(false)-                .setFullScopeAllowed(false)-                .setDefaultClientScopes(Collections.EMPTY_LIST)-                .update()) {--            oauth.openid(false);-            try {-                new Review()-                        .invoke()-                        .assertSuccess()-                        .assertEmptyScope();-            } finally {-                oauth.openid(true);-            }-        }-        // The default client scopes should be same like before.-        int scopesAfterSize = testRealm().clients().get(clientRep.getId()).getDefaultClientScopes().size();-        assertEquals(scopesBefore.size(), scopesAfterSize);+    public void emptyAudience() {+        new Review().username(""empty-audience"")+                .invoke()",Is this really invoked without audience? I can see it added here:https://github.com/keycloak/keycloak/blob/39b05b499c238899bb9d02ef681e500dc58fd38e/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/openshift/OpenShiftTokenReviewEndpointTest.java#L379But maybe I'm just missing something. :),
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/7334,475621683,2020-08-24T13:50:28Z,core/src/main/java/org/keycloak/TokenVerifier.java,"@@ -366,11 +366,18 @@ private void removeCheck(Predicate<? super T> check) {     /**      * Add check for verifying that token contains the expectedAudience      *-     * @param expectedAudience Audience, which needs to be in the target token. Can't be null+     * @param expectedAudiences Audiences, which needs to be in the target token. Can be <code>null</code>.      * @return This token verifier      */-    public TokenVerifier<T> audience(String expectedAudience) {-        return this.replaceCheck(AudienceCheck.class, true, new AudienceCheck(expectedAudience));+    public TokenVerifier<T> audience(String... expectedAudiences) {+        if (expectedAudiences == null || expectedAudiences.length == 0) {+            return this.replaceCheck(AudienceCheck.class, true, new AudienceCheck(null));","The behavior remains the same here. In the old code, (with `String expectedAudience`), if you pass null there, you will effectively invoke `return this.replaceCheck(AudienceCheck.class, true, new AudienceCheck(null));`The problem with the updated code is that the argument can be a null or an empty array. In both cases, I'm explicitly adding `return this.replaceCheck(AudienceCheck.class, true, new AudienceCheck(null));`.In both cases, this blows up in the runtime [here](https://github.com/keycloak/keycloak/blob/39b05b499c238899bb9d02ef681e500dc58fd38e/core/src/main/java/org/keycloak/TokenVerifier.java#L148).",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7372,478320492,2020-08-27T10:34:52Z,services/src/main/java/org/keycloak/encoding/ResourceEncodingHelper.java,"@@ -0,0 +1,30 @@+package org.keycloak.encoding;++import org.keycloak.models.KeycloakSession;++import java.util.Arrays;+import java.util.List;++public class ResourceEncodingHelper {++    private static final List<String> EXCLUDE_ENCODING = Arrays.asList(""image/png"", ""image/jpeg"");",Perhaps we should externalize this list to make it configurable.,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7372,478551593,2020-08-27T16:37:36Z,themes/src/main/resources/theme/keycloak-preview/account/index.ftl,"@@ -109,8 +109,8 @@             </#list>         </#if> -        <link rel=""stylesheet"" type=""text/css"" href=""${resourceCommonUrl}/web_modules/@patternfly/react-core/dist/styles/base.css""/>-        <link rel=""stylesheet"" type=""text/css"" href=""${resourceCommonUrl}/web_modules/@patternfly/react-core/dist/styles/app.css""/>+        <link rel=""stylesheet"" type=""text/css"" href=""${resourceCommonUrl}/web_modules/@patternfly/react-core/dist/styles/base.css"" rel=""preload""/>+        <link rel=""stylesheet"" type=""text/css"" href=""${resourceCommonUrl}/web_modules/@patternfly/react-core/dist/styles/app.css"" rel=""preload""/>","```suggestion        <link rel=""stylesheet"" type=""text/css"" href=""${resourceCommonUrl}/web_modules/@patternfly/react-core/dist/styles/base.css"" rel=""preload"" as=""style""/>        <link rel=""stylesheet"" type=""text/css"" href=""${resourceCommonUrl}/web_modules/@patternfly/react-core/dist/styles/app.css"" rel=""preload"" as=""style""/>```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7307,480366053,2020-08-31T19:58:29Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -148,6 +160,52 @@ private String getEntityId(UriInfo uriInfo, RealmModel realm) {         return UriBuilder.fromUri(uriInfo.getBaseUri()).path(""realms"").path(realm.getName()).build().toString();     } +    static class AuthnContextClassRefJsonObject {",Is this class necessary? Can the serialized form be just a list of `String`s instead?Note: Changing this to `String` would have impact on themes as well.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7307,480366540,2020-08-31T19:59:33Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -148,6 +160,52 @@ private String getEntityId(UriInfo uriInfo, RealmModel realm) {         return UriBuilder.fromUri(uriInfo.getBaseUri()).path(""realms"").path(realm.getName()).build().toString();     } +    static class AuthnContextClassRefJsonObject {+        public String uri;+    }++    private List<String> getAuthnContextClassRefUris() {+        ArrayList<String> output = new ArrayList<String>();++        String authnContextClassRefs = getConfig().getAuthnContextClassRefs();+        if (authnContextClassRefs == null || authnContextClassRefs.length() == 0)+            return output;++        try {+            AuthnContextClassRefJsonObject[] jsonObjects = JsonSerialization.readValue(authnContextClassRefs, AuthnContextClassRefJsonObject[].class);","```suggestion            return Arrays.asList(JsonSerialization.readValue(authnContextClassRefs, String[].class));```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7278,481924613,2020-09-02T09:15:40Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/UpdatingClientSourceConditionFactory.java,"@@ -74,7 +74,7 @@ public String getId() {      @Override     public String getHelpText() {-        return null;+        return ""It uses the source of updating client to determine whether the policy is applied."";","I suggest to make the help text a bit more clear as it will be displayed in the UI and will be nice to make it a bit more obvious what exactly it means?For example ""The condition checks the context how is client created/updated to determine whether the policy is applied. For example it checks if client is created with admin REST API or OIDC dynamic client registration. And for the letter case if it is ANONYMOUS client registration or AUTHENTICATED client registration with Initial access token or Registration access token and so on.""Also my vote is to rename the class to ""UpdatingClientContextCondition"" (and similarly rename the provider ID) as the ""source"" implies that condition is interested about concrete user, who creates/updatest the client rather about the ""context"" how is the client created/updated (admin REST API, OIDC dynamic client registration etc).@stianst @valb3r What is your though on the above?",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7278,482699849,2020-09-03T04:41:10Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/UpdatingClientSourceConditionFactory.java,"@@ -74,7 +74,7 @@ public String getId() {      @Override     public String getHelpText() {-        return null;+        return ""It uses the source of updating client to determine whether the policy is applied."";","@mposolda > I suggest to make the help text a bit more clear as it will be displayed in the UI and will be nice to make it a bit more obvious what exactly it means?Yes, it is a good idea > Also my vote is to rename the class to ""UpdatingClientContextCondition"" (and similarly rename the provider ID) as the ""source"" implies that condition is interested about concrete user, who creates/updatest the client rather about the ""context"" how is the client created/updated (admin REST API, OIDC dynamic client registration etc).Makes sense to me, also `ClientUpdateContextCondition` might be clearer as is composed from ClientUpdateContext + Condition that are key entities now for the class",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7371,482725336,2020-09-03T06:08:56Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties,"@@ -242,6 +242,8 @@ includeInAccessToken.label=Add to access token includeInAccessToken.tooltip=Should the claim be added to the access token? includeInUserInfo.label=Add to userinfo includeInUserInfo.tooltip=Should the claim be added to the userinfo?+includeInAccessTokenResponse.label=Add to access token response+includeInAccessTokenResponse.tooltip=Should the claim be added to the access token response?",```suggestionincludeInAccessTokenResponse.tooltip=Should the claim be added to the access token response? Should only be used for informative and non-sensitive data```,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7278,482738089,2020-09-03T06:39:48Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/UpdatingClientSourceConditionFactory.java,"@@ -74,7 +74,7 @@ public String getId() {      @Override     public String getHelpText() {-        return null;+        return ""It uses the source of updating client to determine whether the policy is applied."";",@valb3r I'd like to rename the class name and its provider id as you proposed. @mposolda  WDYT?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7302,483001028,2020-09-03T14:00:58Z,authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/role/RolePolicyProviderFactory.java,"@@ -163,7 +164,7 @@ private void updateRoles(Policy policy, AuthorizationProvider authorization, Set                         role = realm.getRoleById(roleName);                     }                 } else {-                    ClientModel client = realm.getClientByClientId(clientId);+                    ClientModel client = session.clients().getClientByClientId(realm, clientId);","The original version (via `realm`) should serve as a shortcut to the new version (via `session`), so they are effectively equivalent. There is no strong rule which drives which use when though.From readability perspective, the physical storage layer, it may be preferrable to use the latter approach with `session`, but in the logical layer (e.g. from services), the former would likely prevail.We could perhaps add a comment in the javadoc to these shortcuts similar to `This call is effectively the same as {@code session.clients().getClientByClientId(this, clientId);}.`.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7387,485533216,2020-09-09T11:19:26Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -472,24 +472,23 @@ public Long getGroupsCountByNameContaining(RealmModel realm, String search) {      @Override     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());--        return ref.getGroups().stream()-                .filter(g -> GroupEntity.TOP_PARENT_ID.equals(g.getParentId()))-                .map(g -> session.groups().getGroupById(realm, g.getId()))-                .sorted(Comparator.comparing(GroupModel::getName));+        return getTopLevelGroupsStream(realm, null, null);     }      @Override     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer first, Integer max) {-        Stream<String> groupIds =  em.createNamedQuery(""getTopLevelGroupIds"", String.class)+        TypedQuery<String> groupsQuery =  em.createNamedQuery(""getTopLevelGroupIds"", String.class)                 .setParameter(""realm"", realm.getId())-                .setParameter(""parent"", GroupEntity.TOP_PARENT_ID)-                .setFirstResult(first)-                .setMaxResults(max)-                .getResultStream();+                .setParameter(""parent"", GroupEntity.TOP_PARENT_ID); -        return closing(groupIds.map(realm::getGroupById));+        if (first != null && max != null) {+            groupsQuery = groupsQuery.setFirstResult(first).setMaxResults(max);+        }++        return closing(groupsQuery.getResultStream()+                .map(realm::getGroupById)+                .sorted(Comparator.comparing(GroupModel::getName))",Can this `Comparator` be extracted to a constant (and similarly for other `Comparator`s in this PR)?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7395,485561516,2020-09-09T12:11:20Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientRolesCondition.java,"@@ -61,13 +60,10 @@ public ClientPolicyVote applyPolicy(ClientPolicyContext context) throws ClientPo     private boolean isRolesMatched(ClientModel client) {         if (client == null) return false; -        List<String> rolesForMatching = getRolesForMatching();+        Stream<String> rolesForMatching = getRolesStreamForMatching();         if (rolesForMatching == null) return false; -        client.getRoles().stream().forEach(i -> ClientPolicyLogger.log(logger, ""client role = "" + i.getName()));","Maybe it is possible to add the condition like ""if (log.isTraceEnabled()"" or something like that to save the iterations over the streams in case that logging is not enabled. Maybe very little performance improvement, but it will be probably there?",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7395,485709474,2020-09-09T15:37:27Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientRolesCondition.java,"@@ -61,13 +60,10 @@ public ClientPolicyVote applyPolicy(ClientPolicyContext context) throws ClientPo     private boolean isRolesMatched(ClientModel client) {         if (client == null) return false; -        List<String> rolesForMatching = getRolesForMatching();+        Stream<String> rolesForMatching = getRolesStreamForMatching();         if (rolesForMatching == null) return false; -        client.getRoles().stream().forEach(i -> ClientPolicyLogger.log(logger, ""client role = "" + i.getName()));-        rolesForMatching.stream().forEach(i -> ClientPolicyLogger.log(logger, ""roles expected = "" + i));--        boolean isMatched = rolesForMatching.stream().anyMatch(i->client.getRoles().stream().anyMatch(j->j.getName().equals(i)));+        boolean isMatched = rolesForMatching.anyMatch(i->client.getRolesStream().anyMatch(j->j.getName().equals(i)));","This line seem to have performance bottleneck `client.getRolesStream()` stream is opened for each element of `rolesForMatching`I would propose something of (using Sets from Guava) as it may improve readabiliy - `Sets.intersection` instead of `anyMatch(i -> anyMatch)`:```private boolean isRolesMatched(ClientModel client) {        if (client == null) return false;        Set<String> rolesForMatching = getRolesStreamForMatching();        if (rolesForMatching == null) return false;        Set<String> clientRoles = client.getRolesStream().map(RoleModel::getName).collect(Collectors.toSet());        boolean isMatched = !Sets.intersection(clientRoles, rolesForMatching).isEmpty();                if (isMatched) {            ClientPolicyLogger.log(logger, ""role matched."");        } else {            ClientPolicyLogger.log(logger, ""role unmatched."");        }        return isMatched;    }    private Set<String> getRolesStreamForMatching() {        if (componentModel.getConfig() == null) return null;        List<String> roles = componentModel.getConfig().get(ClientRolesConditionFactory.ROLES);        if (roles == null) {            return null;        }        return new HashSet<>(roles);    }```@mposolda What do you think (gauva is already available in BOM)?",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7395,485710508,2020-09-09T15:38:53Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java,"@@ -399,21 +399,21 @@ public void testCreateUpdateDeleteConditionRuntime() throws ClientRegistrationEx         try {             successfulLoginAndLogout(clientId, clientSecret);  -            createCondition(""TestClientRolesCondition"", TestClientRolesConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            createCondition(""ClientRolesCondition"", ClientRolesConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {","`ClientRolesCondition` is duplicated many times, maybe we can introduce constant for it?",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7371,485792952,2020-09-09T17:25:52Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -611,6 +612,20 @@ public AccessToken transformAccessToken(KeycloakSession session, AccessToken tok         return token;     } +    public AccessTokenResponse transformAccessTokenResponse(KeycloakSession session, AccessTokenResponse token,","```suggestion    public AccessTokenResponse transformAccessTokenResponse(KeycloakSession session, AccessTokenResponse tokenResponse,```I think parameters and local variables referencing `AccessTokenResponse` should be named `response` or `tokenResponse` instead of just `token` which is somewhat misleading.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/7393,485938925,2020-09-09T21:43:37Z,services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java,"@@ -341,116 +341,4 @@ public void setLabel(final @PathParam(""credentialId"") String credentialId, Strin //        session.userCredentialManager().moveCredentialTo(realm, user, credentialId, newPreviousCredentialId); //    } ","We have some unused imports which are safe to remove like:```import org.keycloak.credential.PasswordCredentialProvider;import org.keycloak.credential.PasswordCredentialProviderFactory;import org.keycloak.events.EventType;import javax.ws.rs.POST;```Also, please remove:```private final EventBuilder event;```",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7387,486159408,2020-09-10T08:28:41Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -472,24 +472,23 @@ public Long getGroupsCountByNameContaining(RealmModel realm, String search) {      @Override     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());--        return ref.getGroups().stream()-                .filter(g -> GroupEntity.TOP_PARENT_ID.equals(g.getParentId()))-                .map(g -> session.groups().getGroupById(realm, g.getId()))-                .sorted(Comparator.comparing(GroupModel::getName));+        return getTopLevelGroupsStream(realm, null, null);     }      @Override     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer first, Integer max) {-        Stream<String> groupIds =  em.createNamedQuery(""getTopLevelGroupIds"", String.class)+        TypedQuery<String> groupsQuery =  em.createNamedQuery(""getTopLevelGroupIds"", String.class)                 .setParameter(""realm"", realm.getId())-                .setParameter(""parent"", GroupEntity.TOP_PARENT_ID)-                .setFirstResult(first)-                .setMaxResults(max)-                .getResultStream();+                .setParameter(""parent"", GroupEntity.TOP_PARENT_ID); -        return closing(groupIds.map(realm::getGroupById));+        if (first != null && max != null) {","This something we should probably unify across the whole codebase because I saw more approaches to this [(for example).](https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java#L460). Maybe we should add this to the cleanup task.I did it this way because it is used here, but I will fix: https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/services/resources/admin/GroupsResource.java#L84",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7393,486257537,2020-09-10T11:17:19Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -395,17 +395,6 @@ public Response updateConsent(final @PathParam(""clientId"") String clientId,                                   final ConsentRepresentation consent) {         return upsert(clientId, consent);     }-    -    @Path(""/totp/remove"")-    @DELETE-    public Response removeTOTP() {-        auth.require(AccountRoles.MANAGE_ACCOUNT);-        -        session.userCredentialManager().disableCredentialType(realm, user, CredentialModel.OTP);",Just a very small nit pick.```javaimport org.keycloak.credential.CredentialModel;```is also unused now.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7387,486560751,2020-09-10T18:44:46Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -472,24 +472,23 @@ public Long getGroupsCountByNameContaining(RealmModel realm, String search) {      @Override     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());--        return ref.getGroups().stream()-                .filter(g -> GroupEntity.TOP_PARENT_ID.equals(g.getParentId()))-                .map(g -> session.groups().getGroupById(realm, g.getId()))-                .sorted(Comparator.comparing(GroupModel::getName));+        return getTopLevelGroupsStream(realm, null, null);     }      @Override     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer first, Integer max) {-        Stream<String> groupIds =  em.createNamedQuery(""getTopLevelGroupIds"", String.class)+        TypedQuery<String> groupsQuery =  em.createNamedQuery(""getTopLevelGroupIds"", String.class)                 .setParameter(""realm"", realm.getId())-                .setParameter(""parent"", GroupEntity.TOP_PARENT_ID)-                .setFirstResult(first)-                .setMaxResults(max)-                .getResultStream();+                .setParameter(""parent"", GroupEntity.TOP_PARENT_ID); -        return closing(groupIds.map(realm::getGroupById));+        if (first != null && max != null) {","Absolutely agree, we should follow single approach to these parameters. Thanks for fixing.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7387,486876263,2020-09-11T08:57:43Z,model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java,"@@ -0,0 +1,308 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.group;++import org.jboss.logging.Logger;+import org.keycloak.models.GroupModel;+import org.keycloak.models.GroupProvider;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;++import java.util.Comparator;+import java.util.Objects;+import java.util.UUID;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Stream;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;++public class MapGroupProvider implements GroupProvider {++    private static final Logger LOG = Logger.getLogger(MapGroupProvider.class);+    private static final Predicate<MapGroupEntity> ALWAYS_FALSE = c -> { return false; };+    private final KeycloakSession session;+    final MapKeycloakTransaction<UUID, MapGroupEntity> tx;+    private final MapStorage<UUID, MapGroupEntity> groupStore;++    public MapGroupProvider(KeycloakSession session, MapStorage<UUID, MapGroupEntity> groupStore) {+        this.session = session;+        this.groupStore = groupStore;+        this.tx = new MapKeycloakTransaction<>(groupStore);+        session.getTransactionManager().enlist(tx);+    }++    private MapGroupEntity registerEntityForChanges(MapGroupEntity origEntity) {+        final MapGroupEntity res = Serialization.from(origEntity);+        tx.putIfChanged(origEntity.getId(), res, MapGroupEntity::isUpdated);+        return res;+    }++    private Function<MapGroupEntity, GroupModel> entityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapGroupAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private Predicate<MapGroupEntity> entityRealmFilter(RealmModel realm) {+        if (realm == null || realm.getId() == null) {+            return MapGroupProvider.ALWAYS_FALSE;+        }+        String realmId = realm.getId();+        return entity -> Objects.equals(realmId, entity.getRealmId());+    }++    @Override+    public GroupModel getGroupById(RealmModel realm, String id) {+        if (id == null) {+            return null;+        }++        LOG.tracef(""getGroupById(%s, %s)%s"", realm, id, getShortStackTrace());+++        UUID uid;+        try {+            uid = UUID.fromString(id);+        } catch (IllegalArgumentException ex) {+            return null;+        }+        +        MapGroupEntity entity = tx.get(uid, groupStore::get);+        return (entity == null || ! entityRealmFilter(realm).test(entity))+                ? null+                : entityToAdapterFunc(realm).apply(entity);+    }++    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {+        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()+                .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()+                .filter(Objects::nonNull);+        return Stream.concat(tx.createdValuesStream(groupStore.keySet()), updatedAndNotRemovedGroupsStream);+    }++    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {+        return getNotRemovedUpdatedGroupsStream()+                .filter(entityRealmFilter(realm));+    }++    @Override+    public Stream<GroupModel> getGroupsStream(RealmModel realm) {+        LOG.tracef(""getGroupsStream(%s)%s"", realm, getShortStackTrace());+        return getUnsortedGroupEntitiesStream(realm)+                .map(entityToAdapterFunc(realm))+                .sorted(GroupModel.COMPARATOR)+                ;+    }++    @Override+    public Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {+        Stream<GroupModel> groupModelStream = ids.map(id -> session.groups().getGroupById(realm, id))+                .sorted(Comparator.comparing(GroupModel::getName));++        if (search != null) {+            String s = search.toLowerCase();+            groupModelStream = groupModelStream.filter(groupModel -> groupModel.getName().toLowerCase().contains(s));+        }++        if (first != null && first > 0) {+            groupModelStream = groupModelStream.skip(first);+        }++        if (max != null && max > 0) {+            groupModelStream = groupModelStream.limit(max);+        }++        return groupModelStream;+    }++    @Override+    public Long getGroupsCount(RealmModel realm, Boolean onlyTopGroups) {+        LOG.tracef(""getGroupsCount(%s, %s)%s"", realm, onlyTopGroups, getShortStackTrace());+        Stream<MapGroupEntity> groupModelStream = getUnsortedGroupEntitiesStream(realm);++        if (onlyTopGroups) {+            groupModelStream = groupModelStream.filter(groupEntity -> Objects.isNull(groupEntity.getParentId()));+        }+        +        return groupModelStream.count();+    }++    @Override+    public Long getGroupsCountByNameContaining(RealmModel realm, String search) {+        return searchForGroupByNameStream(realm, search, null, null).count();+    }++    @Override+    public Stream<GroupModel> getGroupsByRoleStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {+        LOG.tracef(""getGroupsByRole(%s, %s, %d, %d)%s"", realm, role, firstResult, maxResults, getShortStackTrace());+        Stream<GroupModel> groupModelStream = getGroupsStream(realm).filter(groupModel -> groupModel.hasRole(role));++        if (firstResult != null && firstResult > 0) {+            groupModelStream = groupModelStream.skip(firstResult);+        }+        +        if (maxResults != null && maxResults > 0) {+            groupModelStream = groupModelStream.limit(maxResults);+        }++        return groupModelStream;+    }++    @Override+    public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {+        LOG.tracef(""getTopLevelGroupsStream(%s)%s"", realm, getShortStackTrace());+        return getGroupsStream(realm)+                .filter(groupModel -> Objects.isNull(groupModel.getParentId()));+    }++    @Override+    public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer firstResult, Integer maxResults) {+        Stream<GroupModel> groupModelStream = getTopLevelGroupsStream(realm);+        +        if (firstResult != null && firstResult > 0) {+            groupModelStream = groupModelStream.skip(firstResult);+        }+        +        if (maxResults != null && maxResults > 0) {+            groupModelStream = groupModelStream.limit(maxResults);+        }+        +        return groupModelStream;+        +    }++    @Override+    public Stream<GroupModel> searchForGroupByNameStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {+        LOG.tracef(""searchForGroupByNameStream(%s, %s, %d, %d)%s"", realm, search, firstResult, maxResults, getShortStackTrace());+        Stream<GroupModel> groupModelStream = getGroupsStream(realm)+                .filter(groupModel -> groupModel.getName().contains(search));++        if (firstResult != null) {+            groupModelStream = groupModelStream.skip(firstResult);+        }++        if (maxResults != null) {+            groupModelStream = groupModelStream.limit(maxResults);+        }++        return groupModelStream;+    }++    @Override+    public GroupModel createGroup(RealmModel realm, String id, String name, GroupModel toParent) {+        LOG.tracef(""createGroup(%s, %s, %s, %s)%s"", realm, id, name, toParent, getShortStackTrace());+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        // Check Db constraint: uniqueConstraints = { @UniqueConstraint(columnNames = {""REALM_ID"", ""PARENT_GROUP"", ""NAME""})}","The thing here is, that in the database we have a constraint that checks there are no two groups with the same name and parent. Here, we need to do it manually.",
2139274,jan-berge-ommedal,https://api.github.com/repos/keycloak/keycloak/pulls/7323,487082349,2020-09-11T14:27:43Z,services/src/main/java/org/keycloak/social/apple/AppleIdentityProvider.java,"@@ -0,0 +1,264 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.social.apple;++import com.fasterxml.jackson.core.JsonProcessingException;+import com.fasterxml.jackson.databind.JsonNode;+import com.fasterxml.jackson.databind.ObjectMapper;+import org.apache.commons.lang.StringUtils;+import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.broker.oidc.OIDCIdentityProvider;+import org.keycloak.broker.oidc.OIDCIdentityProviderConfig;+import org.keycloak.broker.oidc.mappers.AbstractJsonUserAttributeMapper;+import org.keycloak.broker.provider.BrokeredIdentityContext;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.broker.social.SocialIdentityProvider;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.crypto.KeyWrapper;+import org.keycloak.crypto.ServerECDSASignatureSignerContext;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.jose.jws.JWSBuilder;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.ErrorPage;+import org.keycloak.services.Urls;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.FormParam;+import javax.ws.rs.POST;+import javax.ws.rs.WebApplicationException;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.Response;+import java.security.KeyFactory;+import java.security.PrivateKey;+import java.security.spec.PKCS8EncodedKeySpec;+import java.util.Base64;++/**+ * @author Emilien Bondu+ */+public class AppleIdentityProvider extends OIDCIdentityProvider implements SocialIdentityProvider<OIDCIdentityProviderConfig> {++    private static final String OAUTH2_PARAMETER_CODE = ""code"";++    private static final String OAUTH2_PARAMETER_STATE = ""state"";++    private static final String OAUTH2_PARAMETER_USER = ""user"";++    public static final String ACCESS_DENIED = ""access_denied"";++    protected static ObjectMapper mapper = new ObjectMapper();++    public static final String AUTH_URL = ""https://appleid.apple.com/auth/authorize?response_mode=form_post"";++    public static final String TOKEN_URL = ""https://appleid.apple.com/auth/token"";++    public static final String ISSUER = ""https://appleid.apple.com"";++    public static final String JWKS_URL = ""https://appleid.apple.com/auth/keys"";++    public static final String EMAIL_SCOPE = ""email"";++    public static final String NAME_SCOPE = ""name"";++    protected static final Logger logger = Logger.getLogger(AppleIdentityProvider.class);++    public AppleIdentityProvider(KeycloakSession session, AppleIdentityProviderConfig config) {+        super(session, config);++        config.setAuthorizationUrl(AUTH_URL);+        config.setTokenUrl(TOKEN_URL);+        config.setClientAuthMethod(OIDCLoginProtocol.CLIENT_SECRET_POST);+        config.setIssuer(ISSUER);+        config.setUseJwksUrl(true);+        config.setValidateSignature(true);+        config.setJwksUrl(JWKS_URL);+        String defaultScope = config.getDefaultScope();++        if (!isValidSecret(config.getClientSecret())) {+            config.setClientSecret(generateJWS(+                    config.getP8Content(),+                    config.getKeyId(),+                    config.getTeamId())+            );+        }++        if (defaultScope ==  null || defaultScope.trim().equals("""")) {+            config.setDefaultScope(""openid""+ "" "" + NAME_SCOPE+ "" "" + EMAIL_SCOPE);+        }+    }++    @Override+    protected String getDefaultScopes() {+        return ""openid""+ "" "" + NAME_SCOPE+ "" "" + EMAIL_SCOPE;+    }+","Are you missing an override here so that the Endpoint class is actually instantiated?```    @Override    public Object callback(RealmModel realm, AuthenticationCallback callback, EventBuilder event) {        return new Endpoint(realm, callback, event);    }```",
2139274,jan-berge-ommedal,https://api.github.com/repos/keycloak/keycloak/pulls/7323,487085296,2020-09-11T14:32:25Z,services/src/main/java/org/keycloak/social/apple/AppleIdentityProvider.java,"@@ -0,0 +1,264 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.social.apple;++import com.fasterxml.jackson.core.JsonProcessingException;+import com.fasterxml.jackson.databind.JsonNode;+import com.fasterxml.jackson.databind.ObjectMapper;+import org.apache.commons.lang.StringUtils;+import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.broker.oidc.OIDCIdentityProvider;+import org.keycloak.broker.oidc.OIDCIdentityProviderConfig;+import org.keycloak.broker.oidc.mappers.AbstractJsonUserAttributeMapper;+import org.keycloak.broker.provider.BrokeredIdentityContext;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.broker.social.SocialIdentityProvider;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.crypto.KeyWrapper;+import org.keycloak.crypto.ServerECDSASignatureSignerContext;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.jose.jws.JWSBuilder;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.ErrorPage;+import org.keycloak.services.Urls;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.FormParam;+import javax.ws.rs.POST;+import javax.ws.rs.WebApplicationException;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.Response;+import java.security.KeyFactory;+import java.security.PrivateKey;+import java.security.spec.PKCS8EncodedKeySpec;+import java.util.Base64;++/**+ * @author Emilien Bondu+ */+public class AppleIdentityProvider extends OIDCIdentityProvider implements SocialIdentityProvider<OIDCIdentityProviderConfig> {++    private static final String OAUTH2_PARAMETER_CODE = ""code"";++    private static final String OAUTH2_PARAMETER_STATE = ""state"";++    private static final String OAUTH2_PARAMETER_USER = ""user"";++    public static final String ACCESS_DENIED = ""access_denied"";++    protected static ObjectMapper mapper = new ObjectMapper();++    public static final String AUTH_URL = ""https://appleid.apple.com/auth/authorize?response_mode=form_post"";++    public static final String TOKEN_URL = ""https://appleid.apple.com/auth/token"";++    public static final String ISSUER = ""https://appleid.apple.com"";++    public static final String JWKS_URL = ""https://appleid.apple.com/auth/keys"";++    public static final String EMAIL_SCOPE = ""email"";++    public static final String NAME_SCOPE = ""name"";++    protected static final Logger logger = Logger.getLogger(AppleIdentityProvider.class);++    public AppleIdentityProvider(KeycloakSession session, AppleIdentityProviderConfig config) {+        super(session, config);++        config.setAuthorizationUrl(AUTH_URL);+        config.setTokenUrl(TOKEN_URL);+        config.setClientAuthMethod(OIDCLoginProtocol.CLIENT_SECRET_POST);+        config.setIssuer(ISSUER);+        config.setUseJwksUrl(true);+        config.setValidateSignature(true);+        config.setJwksUrl(JWKS_URL);+        String defaultScope = config.getDefaultScope();++        if (!isValidSecret(config.getClientSecret())) {+            config.setClientSecret(generateJWS(+                    config.getP8Content(),+                    config.getKeyId(),+                    config.getTeamId())+            );+        }++        if (defaultScope ==  null || defaultScope.trim().equals("""")) {+            config.setDefaultScope(""openid""+ "" "" + NAME_SCOPE+ "" "" + EMAIL_SCOPE);+        }+    }++    @Override+    protected String getDefaultScopes() {+        return ""openid""+ "" "" + NAME_SCOPE+ "" "" + EMAIL_SCOPE;+    }++    protected class Endpoint {+        protected RealmModel realm;++        protected AuthenticationCallback callback;++        protected EventBuilder event;++        @Context+        protected KeycloakSession session;++        @Context+        protected ClientConnection clientConnection;++        @Context+        protected HttpHeaders headers;++        public Endpoint(RealmModel realm, AuthenticationCallback callback, EventBuilder event) {+            this.realm = realm;+            this.callback = callback;+            this.event = event;+        }++        @POST+        public Response authResponse(@FormParam(AppleIdentityProvider.OAUTH2_PARAMETER_STATE) String state,+                                     @FormParam(AppleIdentityProvider.OAUTH2_PARAMETER_CODE) String authorizationCode,+                                     @FormParam(AppleIdentityProvider.OAUTH2_PARAMETER_USER) String user,+                                     @FormParam(OAuth2Constants.ERROR) String error) {+            if (error != null) {+                logger.error(error + "" for broker login "" + getConfig().getProviderId());+                if (error.equals(ACCESS_DENIED)) {+                    return callback.cancelled(state);+                } else if (error.equals(OAuthErrorException.LOGIN_REQUIRED) || error.equals(OAuthErrorException.INTERACTION_REQUIRED)) {+                    return callback.error(state, error);+                } else {+                    return callback.error(state, Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);+                }+            }++            try {+                if (authorizationCode != null) {++                    String response = generateTokenRequest(authorizationCode).asString();++                    BrokeredIdentityContext federatedIdentity = getFederatedIdentity(user, response);+                    federatedIdentity.setIdpConfig(getConfig());+                    federatedIdentity.setIdp(AppleIdentityProvider.this);+                    federatedIdentity.setCode(state);+                    return callback.authenticated(federatedIdentity);+                }+            } catch (WebApplicationException e) {+                return e.getResponse();+            } catch (Exception e) {+                logger.error(""Failed to make identity provider oauth callback"", e);+            }+            event.event(EventType.LOGIN);+            event.error(Errors.IDENTITY_PROVIDER_LOGIN_FAILURE);+            return ErrorPage.error(session, null, Response.Status.BAD_GATEWAY, Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);+        }++        public BrokeredIdentityContext getFederatedIdentity(String userData, String response) throws JsonProcessingException {+            JsonNode encodedIdToken = mapper.readTree(response).get(""id_token"");++            JsonWebToken idToken = validateToken(encodedIdToken.asText(), false);++            BrokeredIdentityContext user = new BrokeredIdentityContext(idToken.getSubject());+            user.setUsername(idToken.getSubject());+            if (userData !=null) {+                JsonNode profile = mapper.readTree(userData);+                String email = profile.get(""email"").asText();++                String firstName = profile.get(""name"").get(""firstName"").asText();+                String lastName = profile.get(""name"").get(""lastName"").asText();++                user.setEmail(email);+                user.setFirstName(firstName);+                user.setLastName(lastName);+                user.setUsername(firstName + "" "" + lastName);+                AbstractJsonUserAttributeMapper.storeUserProfileForMapper(user, profile, getConfig().getAlias());+            }++            return user;","The returned BrokeredIdentityContext doesn't contain the nonce in the context data, which causes the flow to fail at a later stage inside OIDCIdentityProvider.preprocessFederatedIdentity() where a nonce is expected to be present.",
50862958,benjamin37,https://api.github.com/repos/keycloak/keycloak/pulls/7408,487716854,2020-09-14T07:50:14Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/UserInfoEndpoint.java,"@@ -225,6 +226,24 @@ private Response issueUserInfo(String tokenString) {         // any attempt to customize the value of this field should be done through a different claim         claims.put(""sub"", userInfo.getSubject()); +        if (userInfo.getRealmAccess() != null) {+            Map<String, Set<String>> realmAccess = new HashMap<>();+            realmAccess.put(""roles"", userInfo.getRealmAccess().getRoles());+            claims.put(""realm_access"", realmAccess);+        }++        if (userInfo.getResourceAccess() != null && !userInfo.getResourceAccess().isEmpty()) {+            Map<String, Map<String, Set<String>>> resourceAccessMap = new HashMap<>();++            for (Map.Entry<String, AccessToken.Access> resourceAccessMapEntry : userInfo.getResourceAccess()+                    .entrySet()) {+                Map<String, Set<String>> resourceAccess = new HashMap<>();+                resourceAccess.put(""roles"", resourceAccessMapEntry.getValue().getRoles());+                resourceAccessMap.put(resourceAccessMapEntry.getKey(), resourceAccess);+            }+            claims.put(""resource_access"", resourceAccessMap);+        }","The current mechanism is the following:Some lines above in https://github.com/keycloak/keycloak/blob/3186f1b5a9103383b4f4d8b6f595449055c44b5b/services/src/main/java/org/keycloak/protocol/oidc/endpoints/UserInfoEndpoint.java#L215-L219the protocol mappers are used to create an access token with all the information that should be available in the user info endpoint. This is done in a generic way that applies to the access token, id token and user info.If the default claim name for realm roles/client roles are not modified the roles are stored in a separate field in the access token, see https://github.com/keycloak/keycloak/blob/3186f1b5a9103383b4f4d8b6f595449055c44b5b/services/src/main/java/org/keycloak/protocol/oidc/mappers/AbstractUserRoleMappingMapper.java#L139-L169Since only `otherClaims` field is used to put info to the user info endpoint the bug occurs.Which way would you suggest to properly fix this bug? I see the following options1. Use the `realmAccess` and `resourceAccess` properties in the access token that the protocol mappers provided. Just fetch the information of them and put it in the user info right here. That's the current version of the PR.2. Add the information to the protocol mappers that they should map the roles in a ""user info endpoint"" way. In this case just put the roles in `otherClaims` field of the token.3. Don't use a special field for `realmAccess` and `resourceAccess` anymore such that the values are always provided in `otherClaims`.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7387,487964879,2020-09-14T14:16:49Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -415,15 +415,51 @@ public void moveGroup(RealmModel realm, GroupModel group, GroupModel toParent) {         group.setParent(toParent);         if (toParent != null) toParent.addChild(group);         else session.groups().addTopLevelGroup(realm, group);++        // TODO: Remove em.flush(), currently this needs to be there to translate ConstraintViolationException to+        //  DuplicateModelException {@link PersistenceExceptionConverter} is not called if the+        //  ConstraintViolationException is not thrown in method called directly from EntityManager+        em.flush();     }      @Override     public Stream<GroupModel> getGroupsStream(RealmModel realm) {-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());+        return closing(em.createNamedQuery(""getGroupIdsByRealm"", String.class)+                .setParameter(""realm"", realm.getId())+                .getResultStream())+                .map(g -> session.groups().getGroupById(realm, g));+    }++    @Override+    public Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {+        if (search == null) search = """";++        TypedQuery<String> query = em.createNamedQuery(""getGroupIdsByNameContainingFromIdList"", String.class)+                .setParameter(""realm"", realm.getId())+                .setParameter(""search"", search)","There need to be two queries, one with and one without `search` parameter, for performance reasons to prevent seq scan in case of no search",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7387,488001760,2020-09-14T15:01:18Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -415,15 +415,51 @@ public void moveGroup(RealmModel realm, GroupModel group, GroupModel toParent) {         group.setParent(toParent);         if (toParent != null) toParent.addChild(group);         else session.groups().addTopLevelGroup(realm, group);++        // TODO: Remove em.flush(), currently this needs to be there to translate ConstraintViolationException to+        //  DuplicateModelException {@link PersistenceExceptionConverter} is not called if the+        //  ConstraintViolationException is not thrown in method called directly from EntityManager+        em.flush();     }      @Override     public Stream<GroupModel> getGroupsStream(RealmModel realm) {-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());+        return closing(em.createNamedQuery(""getGroupIdsByRealm"", String.class)+                .setParameter(""realm"", realm.getId())+                .getResultStream())+                .map(g -> session.groups().getGroupById(realm, g));+    }++    @Override+    public Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {+        if (search == null) search = """";++        TypedQuery<String> query = em.createNamedQuery(""getGroupIdsByNameContainingFromIdList"", String.class)+                .setParameter(""realm"", realm.getId())+                .setParameter(""search"", search)+                .setParameter(""ids"", ids.collect(Collectors.toList()));++        if (first != null && first > 0) {+            query = query.setFirstResult(first);+        }++        if (max != null && max > 0) {+            query = query.setMaxResults(max);+        }++        return closing(query.getResultStream())+                .map(g -> session.groups().getGroupById(realm, g));+    } -        return ref.getGroups().stream()-                .map(g -> session.groups().getGroupById(realm, g.getId()))-                .sorted(Comparator.comparing(GroupModel::getName));+    @Override+    public Long getGroupsCount(RealmModel realm, Stream<String> ids, String search) {+        if (search == null) search = """";++        return em.createNamedQuery(""getGroupCountByNameContainingFromIdList"", Long.class)","I believe there is no need for such a function. We should probably throw an exception here if the search is `null`. It doesn't make sense to search for a count of groups with ids (we can just use the size of ids list). In the adapter layer, we should make sure no such call is made.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7387,488007722,2020-09-14T15:08:01Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -415,15 +415,51 @@ public void moveGroup(RealmModel realm, GroupModel group, GroupModel toParent) {         group.setParent(toParent);         if (toParent != null) toParent.addChild(group);         else session.groups().addTopLevelGroup(realm, group);++        // TODO: Remove em.flush(), currently this needs to be there to translate ConstraintViolationException to+        //  DuplicateModelException {@link PersistenceExceptionConverter} is not called if the+        //  ConstraintViolationException is not thrown in method called directly from EntityManager+        em.flush();     }      @Override     public Stream<GroupModel> getGroupsStream(RealmModel realm) {-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());+        return closing(em.createNamedQuery(""getGroupIdsByRealm"", String.class)+                .setParameter(""realm"", realm.getId())+                .getResultStream())+                .map(g -> session.groups().getGroupById(realm, g));+    }++    @Override+    public Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {+        if (search == null) search = """";++        TypedQuery<String> query = em.createNamedQuery(""getGroupIdsByNameContainingFromIdList"", String.class)+                .setParameter(""realm"", realm.getId())+                .setParameter(""search"", search)+                .setParameter(""ids"", ids.collect(Collectors.toList()));++        if (first != null && first > 0) {+            query = query.setFirstResult(first);+        }++        if (max != null && max > 0) {+            query = query.setMaxResults(max);+        }++        return closing(query.getResultStream())+                .map(g -> session.groups().getGroupById(realm, g));+    } -        return ref.getGroups().stream()-                .map(g -> session.groups().getGroupById(realm, g.getId()))-                .sorted(Comparator.comparing(GroupModel::getName));+    @Override+    public Long getGroupsCount(RealmModel realm, Stream<String> ids, String search) {+        if (search == null) search = """";++        return em.createNamedQuery(""getGroupCountByNameContainingFromIdList"", Long.class)","Looked at it again and an exception is probably not the best, but we can just call ids.count() or in case of the upper `ids.map(id -> session.groups().getGroupById(realm, id))`, it should be probably faster, WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7408,488139718,2020-09-14T18:33:09Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oidc/UserInfoTest.java,"@@ -675,4 +703,73 @@ private void testSuccessSignedResponse(Algorithm sigAlg) throws Exception {          return tokenResponse;     }++    private void includeRolesInUserInfoEndpoint() {",Is it possible to merge methods includeRolesInUserInfoEndpoint and excludeRolesInUserInfoEndpoint into single method with the boolean parameter? Something like:```private void switchIncludeRolesInUserInfoEndpoint(boolean includeRoles)```This should avoid some code duplications as both methods are quite similar (with the exception of true/false when switching INCLUDE_IN_USERINFO flag).,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/7176,488469536,2020-09-15T08:06:59Z,services/src/main/java/org/keycloak/utils/UserHelper.java,"@@ -0,0 +1,48 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.utils;++import java.util.Objects;+import java.util.Set;++import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RequiredActionProviderModel;+import org.keycloak.models.RoleModel;+import org.keycloak.models.UserModel;++public class UserHelper {++  public static boolean hasAccountClientDeleteAccountRole(UserModel user, ClientModel accountClientModel) {+    if (Objects.isNull(user)) {+      return false;+    }++    Set<RoleModel> acountClientRoleMappings = user.getClientRoleMappings(accountClientModel);+    return Objects.nonNull(acountClientRoleMappings) && acountClientRoleMappings.stream().anyMatch((role) -> Objects.equals(role.getName(),+        AccountRoles.DELETE_ACCOUNT));+  }++  public static boolean isDeleteAccountAllowed(RealmModel realm, UserModel user) {+    RequiredActionProviderModel deleteAction = realm.getRequiredActionProviderByAlias(""delete_account"");+    return hasAccountClientDeleteAccountRole(user, realm.getClientByClientId(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID)) && Objects.nonNull(deleteAction) && deleteAction.isEnabled();+  }++}","Get rid of this class. We don't want to introduce a new class for something simple as this. Also, the logic here is not correct, see my example in DeleteAction.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7176,488824465,2020-09-15T17:05:33Z,themes/src/main/resources/theme/keycloak-preview/account/index.ftl,"@@ -45,7 +45,8 @@                 isLinkedAccountsEnabled : ${realm.identityFederationEnabled?c},                 isEventsEnabled : ${isEventsEnabled?c},                 isMyResourcesEnabled : ${(realm.userManagedAccessAllowed && isAuthorizationEnabled)?c},-                isTotpConfigured : ${isTotpConfigured?c}+                isTotpConfigured : ${isTotpConfigured?c},+                deleteAccountAllowed : ${deleteAccountAllowed?c}",@stianst I'm ok with this as long as the proper check is done on the server as the page is being rendered.  Is there something that would be different on the client side?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7387,488902013,2020-09-15T19:06:09Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -415,15 +415,51 @@ public void moveGroup(RealmModel realm, GroupModel group, GroupModel toParent) {         group.setParent(toParent);         if (toParent != null) toParent.addChild(group);         else session.groups().addTopLevelGroup(realm, group);++        // TODO: Remove em.flush(), currently this needs to be there to translate ConstraintViolationException to+        //  DuplicateModelException {@link PersistenceExceptionConverter} is not called if the+        //  ConstraintViolationException is not thrown in method called directly from EntityManager+        em.flush();     }      @Override     public Stream<GroupModel> getGroupsStream(RealmModel realm) {-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());+        return closing(em.createNamedQuery(""getGroupIdsByRealm"", String.class)+                .setParameter(""realm"", realm.getId())+                .getResultStream())+                .map(g -> session.groups().getGroupById(realm, g));+    }++    @Override+    public Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {+        if (search == null) search = """";++        TypedQuery<String> query = em.createNamedQuery(""getGroupIdsByNameContainingFromIdList"", String.class)+                .setParameter(""realm"", realm.getId())+                .setParameter(""search"", search)+                .setParameter(""ids"", ids.collect(Collectors.toList()));++        if (first != null && first > 0) {+            query = query.setFirstResult(first);+        }++        if (max != null && max > 0) {+            query = query.setMaxResults(max);+        }++        return closing(query.getResultStream())+                .map(g -> session.groups().getGroupById(realm, g));+    } -        return ref.getGroups().stream()-                .map(g -> session.groups().getGroupById(realm, g.getId()))-                .sorted(Comparator.comparing(GroupModel::getName));+    @Override+    public Long getGroupsCount(RealmModel realm, Stream<String> ids, String search) {+        if (search == null) search = """";++        return em.createNamedQuery(""getGroupCountByNameContainingFromIdList"", Long.class)",Generally this would be faster but less precise. It is possible that the ID list is obsolete since there is no guarantee of referential integrity across the group store and other stores. Hence it still makes sense to perform the query.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7176,489235064,2020-09-16T07:51:17Z,services/src/main/java/org/keycloak/authentication/requiredactions/DeleteAccount.java,"@@ -0,0 +1,166 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import java.io.IOException;+import java.util.Objects;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.InitiatedActionSupport;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionFactory;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.freemarker.model.UrlBean;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserManager;+import org.keycloak.models.UserModel;+import org.keycloak.services.ForbiddenException;+import org.keycloak.services.messages.Messages;+import org.keycloak.theme.Theme;+import org.keycloak.utils.UserHelper;++public class DeleteAccount implements RequiredActionProvider, RequiredActionFactory {++  public static final String PROVIDER_ID = ""delete_account"";++  private static final Logger logger = Logger.getLogger(DeleteAccount.class);++  @Override+  public String getDisplayText() {+    return ""Delete Account"";+  }++  @Override+  public void evaluateTriggers(RequiredActionContext context) {++  }++  @Override+  public void requiredActionChallenge(RequiredActionContext context) {+    UserModel user = context.getAuthenticationSession().getAuthenticatedUser();+    RealmModel realm = context.getRealm();++    if(!UserHelper.isDeleteAccountAllowed(realm, user)) {+      throw new ForbiddenException();+    }++    context.challenge(context.form().createForm(""delete-account-confirm.ftl""));+  }+++  @Override+  public void processAction(RequiredActionContext context) {+    KeycloakSession session = context.getSession();+    EventBuilder eventBuilder = context.getEvent();+    KeycloakContext keycloakContext = session.getContext();+    RealmModel realm = keycloakContext.getRealm();+    UserModel user = keycloakContext.getAuthenticationSession().getAuthenticatedUser();++    try {+      if(!UserHelper.isDeleteAccountAllowed(realm, user)) {+        throw new ForbiddenException();+      }+      boolean removed = new UserManager(session).removeUser(realm, user);++      if (removed) {+        eventBuilder.event(EventType.DELETE_ACCOUNT)+            .client(keycloakContext.getClient())+            .user(user)+            .detail(Details.USERNAME, user.getUsername())+            .success();+      } else {+        eventBuilder.event(EventType.DELETE_ACCOUNT)+            .client(keycloakContext.getClient())+            .user(user)+            .detail(Details.USERNAME, user.getUsername())+            .error(""User could not be deleted"");+        context.failure();","+1In case of the authentication flows, the reset of the flow can be done with the usage of method `AuthenticationFlowContext.resetFlow()` or eventually the `AuthenticationFlowContext.resetFlow(Runnable afterResetListener)`, which allows to trigger some code after the reset of the authentication session is done. This will do all the mentioned things (cleanup user from the authSession, cleanup the state of the authentication flow etc). See the `AuthenticationProcessor.resetFlow` to see the details of everything, which is done.It seems that RequiredActionContext does not yet have this possibility to reset the flow, so the new method may need to be added to RequiredActionContext.It will be ideal if actual ""implementation"" of the reset flow (currently `AuthenticationProcessor.resetFlow`) is somehow shared for both authenticationFlowContext and RequiredActionContext, so that there is not same duplicated code for this implementation. Maybe just some static method, which can be called from both places will do the trick - or maybe there is some even more elegant solution.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7419,489410683,2020-09-16T12:50:20Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java,"@@ -0,0 +1,508 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import java.io.IOException;+import java.io.InputStream;+import java.util.Arrays;+import java.util.HashSet;+import java.util.Set;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.util.StreamUtil;+import org.keycloak.common.util.Time;+import org.keycloak.component.ComponentModel;+import org.keycloak.connections.httpclient.HttpClientProvider;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.Urls;+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyLogger;+import org.keycloak.util.JsonSerialization;++import com.fasterxml.jackson.annotation.JsonProperty;+import com.fasterxml.jackson.databind.JsonNode;++public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {++    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);++    private final KeycloakSession session;+    private final ComponentModel componentModel;++    private AuthorizationEndpointRequestObject parsedRequestObject;++    public static final String INVALID_REQUEST_OBJECT = ""invalid_request_object"";++    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {+        this.session = session;+        this.componentModel = componentModel;+    }++    @Override+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {+        switch (context.getEvent()) {+            case AUTHORIZATION_REQUEST:+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),+                    authorizationRequestContext.getAuthorizationEndpointRequest(),+                    authorizationRequestContext.getRedirectUri());+                break;+            default:+                return;+        }+    }++    public void executeOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Authz Endpoint - authz request"");++        // Only support GET+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);++        // check whether whether request object exists+        if (requestParam == null && requestUriParam == null) {+            ClientPolicyLogger.log(logger, ""request object not exist."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter"");+        }++        // check whether request_uri is https scheme+        if (requestUriParam != null && !requestUriParam.startsWith(""https://"")) {+            ClientPolicyLogger.log(logger, ""request_uri scheme is not https."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter: request_uri"");+        }++        // check whether request object can be retrieved from request_uri+        String retrievedRequestObject = null;+        if (requestParam != null) {+            retrievedRequestObject = requestParam;+        } else {+            try (InputStream is = session.getProvider(HttpClientProvider.class).get(requestUriParam)) {+                retrievedRequestObject = StreamUtil.readString(is);+            } catch (IOException e) {+                ClientPolicyLogger.log(logger, ""failed to retrieve request object from request_uri."");+                throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter: request_uri"");+            }+        }++        // check whether request object can be parsed successfully+        JWSInput input;+        try {+            input = new JWSInput(retrievedRequestObject);+            parsedRequestObject = JsonSerialization.readValue(input.getContent(), AuthorizationEndpointRequestObject.class);+        } catch (JWSInputException | IOException e) {+            ClientPolicyLogger.log(logger, ""failed to parse request object."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid request object"");+        }++        if (logger.isTraceEnabled()) {+            DumpQueryParameters();+            DumpRequestObject();+        }++        // check whether scope exists in both query parameter and request object+        if (params.getFirst(OIDCLoginProtocol.SCOPE_PARAM) == null || parsedRequestObject.getScope() == null) {+            ClientPolicyLogger.log(logger, ""scope does not exists."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Missing parameter : scope"");+        }++        // check whether ""exp"" claim exists+        if (parsedRequestObject.getExp() == null) {+            ClientPolicyLogger.log(logger, ""exp claim not incuded."");+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, ""Missing parameter : exp"");+        }++        // check whether request object not expired+        long exp = parsedRequestObject.getExp().longValue();+        if (Time.currentTime() > exp) { // TODO: Time.currentTime() is int while exp is long...+            ClientPolicyLogger.log(logger, ""request object expired."");+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, ""Request Expired"");+        }++        // check whether ""aud"" claim exists+        String[] aud = parsedRequestObject.getAudience();+        if (aud == null) {+            ClientPolicyLogger.log(logger, ""aud claim not incuded."");+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, ""Missing parameter : aud"");+        }++        // check whether ""aud"" claim points to this keycloak as authz server+        String iss = Urls.realmIssuer(session.getContext().getUri().getBaseUri(), session.getContext().getRealm().getName());+        if (!Arrays.asList(aud).contains(iss)) {+            ClientPolicyLogger.log(logger, ""aud not points to the intended realm."");+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, ""Invalid parameter : aud"");+        }++        // confirm whether all parameters in query string are included in the request object, and have the same values+        // argument ""request"" are parameters overridden by parameters in request object+        if (KNOWN_REQ_PARAMS.stream().filter(s->params.containsKey(s)).anyMatch(s->!isSameParameterIncluded(s, params.getFirst(s), parsedRequestObject))) {+            ClientPolicyLogger.log(logger, ""not all parameters in query string are included in the request object, and have the same values."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter"");+        }++        ClientPolicyLogger.log(logger, ""Passed."");+    }++    private static final Set<String> KNOWN_REQ_PARAMS = new HashSet<>();+    static {+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.CLIENT_ID_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.RESPONSE_TYPE_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.RESPONSE_MODE_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.REDIRECT_URI_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.STATE_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.SCOPE_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.LOGIN_HINT_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.PROMPT_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.NONCE_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.MAX_AGE_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.UI_LOCALES_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.REQUEST_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.REQUEST_URI_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.CLAIMS_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.ACR_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.CODE_CHALLENGE_PARAM);+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.CODE_CHALLENGE_METHOD_PARAM);+        KNOWN_REQ_PARAMS.add(OAuth2Constants.DISPLAY);+    }++    private boolean isSameParameterIncluded(String param, String value, AuthorizationEndpointRequestObject request) {+        if (OIDCLoginProtocol.CLIENT_ID_PARAM.equals(param)) {+            return request.getClientId() != null && request.getClientId().equals(value);+        } else if (OIDCLoginProtocol.RESPONSE_TYPE_PARAM.equals(param)) {+            return request.getResponseType() != null && request.getResponseType().equals(value);+        } else if (OIDCLoginProtocol.RESPONSE_MODE_PARAM.equals(param)) {+            return request.getResponseMode() != null && request.getResponseMode().equals(value);+        } else if (OIDCLoginProtocol.REDIRECT_URI_PARAM.equals(param)) {+            return request.getRedirectUriParam() != null && request.getRedirectUriParam().equals(value);+        } else if (OIDCLoginProtocol.STATE_PARAM.equals(param)) {+            return request.getState() != null && request.getState().equals(value);+        } else if (OIDCLoginProtocol.SCOPE_PARAM.equals(param)) {+            return request.getScope() != null && request.getScope().equals(value);+        } else if (OIDCLoginProtocol.LOGIN_HINT_PARAM.equals(param)) {+            return request.getLoginHint() != null && request.getLoginHint().equals(value);+        } else if (OIDCLoginProtocol.PROMPT_PARAM.equals(param)) {+            return request.getPrompt() != null && request.getPrompt().equals(value);+        } else if (OIDCLoginProtocol.NONCE_PARAM.equals(param)) {+            return request.getNonce() != null && request.getNonce().equals(value);+        } else if (OIDCLoginProtocol.MAX_AGE_PARAM.equals(param)) {+            return request.getMax_age() != null && request.getMax_age().toString().equals(value);+        } else if (OIDCLoginProtocol.UI_LOCALES_PARAM.equals(param)) {+            return request.getUiLocales() != null && request.getUiLocales().equals(value);+        } else if (OIDCLoginProtocol.CLAIMS_PARAM.equals(param)) { // TODO : need some canonicalization for comparing in its meaning, not simply compare in its representation+            return request.getClaims() != null && request.getClaims().toString().equals(value);+        } else if (OIDCLoginProtocol.ACR_PARAM.equals(param)) {+            return request.getAcr() != null && request.getAcr().equals(value);+        } else if (OIDCLoginProtocol.CODE_CHALLENGE_PARAM.equals(param)) {+            return request.getCodeChallenge() != null && request.getCodeChallenge().equals(value);+        } else if (OIDCLoginProtocol.CODE_CHALLENGE_METHOD_PARAM.equals(param)) {+            return request.getCodeChallengeMethod() != null && request.getCodeChallengeMethod().equals(value);+        }+        return true;+    }++	public static class AuthorizationEndpointRequestObject extends JsonWebToken {++        @JsonProperty(OIDCLoginProtocol.CLIENT_ID_PARAM)+        String clientId;++        @JsonProperty(OIDCLoginProtocol.RESPONSE_TYPE_PARAM)+        String responseType;++        @JsonProperty(OIDCLoginProtocol.RESPONSE_MODE_PARAM)+        String responseMode;++        @JsonProperty(OIDCLoginProtocol.REDIRECT_URI_PARAM)+        String redirectUriParam;++        @JsonProperty(OIDCLoginProtocol.STATE_PARAM)+        String state;++        @JsonProperty(OIDCLoginProtocol.SCOPE_PARAM)+        String scope;++        @JsonProperty(OIDCLoginProtocol.LOGIN_HINT_PARAM)+        String loginHint;++        @JsonProperty(OIDCLoginProtocol.PROMPT_PARAM)+        String prompt;++        @JsonProperty(OIDCLoginProtocol.NONCE_PARAM)+        String nonce;++        Integer max_age;++        @JsonProperty(OIDCLoginProtocol.UI_LOCALES_PARAM)+        String uiLocales;++        @JsonProperty(OIDCLoginProtocol.CLAIMS_PARAM)+        JsonNode claims;++        @JsonProperty(OIDCLoginProtocol.ACR_PARAM)+        String acr;++        @JsonProperty(OAuth2Constants.DISPLAY)+        String display;++        @JsonProperty(OIDCLoginProtocol.CODE_CHALLENGE_PARAM)+        String codeChallenge;++        @JsonProperty(OIDCLoginProtocol.CODE_CHALLENGE_METHOD_PARAM)+        String codeChallengeMethod;++        @JsonProperty(AdapterConstants.KC_IDP_HINT)+        String idpHint;++        @JsonProperty(Constants.KC_ACTION)+        String action;++        public String getClientId() {+            return clientId;+        }++        public void setClientId(String clientId) {+            this.clientId =  clientId;+        }++        public String getResponseType() {+            return responseType;+        }++        public void setResponseType(String responseType) {+            this.responseType = responseType;+        }++        public String getResponseMode() {+            return responseMode;+        }++        public void setResponseMode(String responseMode) {+            this.responseMode = responseMode;+        }++        public String getRedirectUriParam() {+            return redirectUriParam;+        }++        public void setRedirectUriParam(String redirectUriParam) {+            this.redirectUriParam = redirectUriParam;+        }++        public String getState() {+            return state;+        }++        public void setState(String state) {+            this.state = state;+        }++        public String getScope() {+            return scope;+        }++        public void setScope(String scope) {+            this.scope = scope;+        }++        public String getLoginHint() {+            return loginHint;+        }++        public void setLoginHint(String loginHint) {+            this.loginHint = loginHint;+        }++        public String getPrompt() {+            return prompt;+        }++        public void setPrompt(String prompt) {+            this.prompt = prompt;+        }++        public String getNonce() {+            return nonce;+        }++        public void getNonce(String nonce) {+            this.nonce = nonce;+        }++        public Integer getMax_age() {+            return max_age;+        }++        public void setMax_age(Integer max_age) {+            this.max_age = max_age;+        }++        public String getUiLocales() {+            return uiLocales;+        }++        public void setUiLocales(String uiLocales) {+            this.uiLocales = uiLocales;+        }++        public JsonNode getClaims() {+            return claims;+        }++        public void setClaims(JsonNode claims) {+            this.claims = claims;+        }++        public String getAcr() {+            return acr;+        }++        public void setAcr(String acr) {+            this.acr = acr;+        }++        public String getCodeChallenge() {+            return codeChallenge;+        }++        public void setCodeChallenge(String codeChallenge) {+            this.codeChallenge = codeChallenge;+        }++        public String getCodeChallengeMethod() {+            return codeChallengeMethod;+        }++        public void setCodeChallengeMethod(String codeChallengeMethod) {+            this.codeChallengeMethod = codeChallengeMethod;+        }++        public String getDisplay() {+            return display;+        }++        public void setDisplay(String display) {+            this.display = display;+        }++        public String getIdpHint() {+            return idpHint;+        }++        public void setIdpHint(String idpHint) {+            this.idpHint = idpHint;+        }++        public String getAction() {+            return action;+        }++        public void setAction(String action) {+            this.action = action;+        }++    }++    @Override+    public String getName() {+        return componentModel.getName();+    }++    @Override+    public String getProviderId() {+        return componentModel.getProviderId();+    }++    private void DumpQueryParameters() {+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();+        params.keySet().forEach(s->ClientPolicyLogger.logv(logger, ""Query Parameter : {0} = {1}"", s, params.getFirst(s)));+    }++    private void DumpRequestObject() {+        if (parsedRequestObject.getId() != null) ","If we move most of the claims to the ""otherClaims"" and not explicitly contain them as properties of the AuthorizationEndpointRequestObject  (See my comment above), then this algorithm can be perhaps easier without explicitly naming every property. Just dumping the ""otherClaims"" map will do the thing.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7419,489410998,2020-09-16T12:50:49Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java,"@@ -0,0 +1,508 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import java.io.IOException;+import java.io.InputStream;+import java.util.Arrays;+import java.util.HashSet;+import java.util.Set;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.util.StreamUtil;+import org.keycloak.common.util.Time;+import org.keycloak.component.ComponentModel;+import org.keycloak.connections.httpclient.HttpClientProvider;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.Urls;+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyLogger;+import org.keycloak.util.JsonSerialization;++import com.fasterxml.jackson.annotation.JsonProperty;+import com.fasterxml.jackson.databind.JsonNode;++public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {++    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);++    private final KeycloakSession session;+    private final ComponentModel componentModel;++    private AuthorizationEndpointRequestObject parsedRequestObject;++    public static final String INVALID_REQUEST_OBJECT = ""invalid_request_object"";++    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {+        this.session = session;+        this.componentModel = componentModel;+    }++    @Override+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {+        switch (context.getEvent()) {+            case AUTHORIZATION_REQUEST:+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),+                    authorizationRequestContext.getAuthorizationEndpointRequest(),+                    authorizationRequestContext.getRedirectUri());+                break;+            default:+                return;+        }+    }++    public void executeOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Authz Endpoint - authz request"");++        // Only support GET+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);++        // check whether whether request object exists+        if (requestParam == null && requestUriParam == null) {+            ClientPolicyLogger.log(logger, ""request object not exist."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter"");+        }++        // check whether request_uri is https scheme+        if (requestUriParam != null && !requestUriParam.startsWith(""https://"")) {+            ClientPolicyLogger.log(logger, ""request_uri scheme is not https."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter: request_uri"");+        }++        // check whether request object can be retrieved from request_uri+        String retrievedRequestObject = null;+        if (requestParam != null) {+            retrievedRequestObject = requestParam;+        } else {+            try (InputStream is = session.getProvider(HttpClientProvider.class).get(requestUriParam)) {+                retrievedRequestObject = StreamUtil.readString(is);+            } catch (IOException e) {+                ClientPolicyLogger.log(logger, ""failed to retrieve request object from request_uri."");+                throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter: request_uri"");+            }+        }++        // check whether request object can be parsed successfully+        JWSInput input;+        try {+            input = new JWSInput(retrievedRequestObject);+            parsedRequestObject = JsonSerialization.readValue(input.getContent(), AuthorizationEndpointRequestObject.class);+        } catch (JWSInputException | IOException e) {+            ClientPolicyLogger.log(logger, ""failed to parse request object."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid request object"");+        }++        if (logger.isTraceEnabled()) {+            DumpQueryParameters();+            DumpRequestObject();+        }++        // check whether scope exists in both query parameter and request object+        if (params.getFirst(OIDCLoginProtocol.SCOPE_PARAM) == null || parsedRequestObject.getScope() == null) {+            ClientPolicyLogger.log(logger, ""scope does not exists."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Missing parameter : scope"");+        }++        // check whether ""exp"" claim exists+        if (parsedRequestObject.getExp() == null) {+            ClientPolicyLogger.log(logger, ""exp claim not incuded."");+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, ""Missing parameter : exp"");+        }++        // check whether request object not expired+        long exp = parsedRequestObject.getExp().longValue();+        if (Time.currentTime() > exp) { // TODO: Time.currentTime() is int while exp is long...+            ClientPolicyLogger.log(logger, ""request object expired."");+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, ""Request Expired"");+        }++        // check whether ""aud"" claim exists+        String[] aud = parsedRequestObject.getAudience();+        if (aud == null) {+            ClientPolicyLogger.log(logger, ""aud claim not incuded."");+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, ""Missing parameter : aud"");+        }++        // check whether ""aud"" claim points to this keycloak as authz server+        String iss = Urls.realmIssuer(session.getContext().getUri().getBaseUri(), session.getContext().getRealm().getName());+        if (!Arrays.asList(aud).contains(iss)) {+            ClientPolicyLogger.log(logger, ""aud not points to the intended realm."");+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, ""Invalid parameter : aud"");+        }++        // confirm whether all parameters in query string are included in the request object, and have the same values+        // argument ""request"" are parameters overridden by parameters in request object+        if (KNOWN_REQ_PARAMS.stream().filter(s->params.containsKey(s)).anyMatch(s->!isSameParameterIncluded(s, params.getFirst(s), parsedRequestObject))) {","The algorithm here and in the ""isSameParameterIncluded"" is a bit uneffective IMO. It iterates through all the OIDC supported parameters and calls very big amount of ""if"" and ""equals"" inside ""isSameParameterIncluded"" . Also will require change in the code upon any new supported OIDC parameter and whole ""isSameParameterIncluded"" does not scale etc.Maybe it is possible to leverage the fact that OIDC query parameter names are the same as parameters inside ""request"" object. Instead of adding all the passed ""request"" parameters as properties of the AuthorizationEndpointRequestObject, it may be better to just keep lots of those properties as generic properties in the ""otherClaims"" map. Then the algorithm should be possibly made more effective like for example something like this:```for (Map.Entry<String, List<String>> param : params.entrySet()) {    if (KNOWN_REQ_PARAMS.contains(param.getKey()) {        String requestValue = parsedRequestObject.getOtherClaim().get(param.getKey());        if (requestValue == null || requestValue.equals(param.getValue() {            // Throw error here. It can contain the name of the failing parameter in the trace logging message, which is advantage IMO        }    }}```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7419,489414360,2020-09-16T12:55:59Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java,"@@ -0,0 +1,508 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import java.io.IOException;+import java.io.InputStream;+import java.util.Arrays;+import java.util.HashSet;+import java.util.Set;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.util.StreamUtil;+import org.keycloak.common.util.Time;+import org.keycloak.component.ComponentModel;+import org.keycloak.connections.httpclient.HttpClientProvider;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.Urls;+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyLogger;+import org.keycloak.util.JsonSerialization;++import com.fasterxml.jackson.annotation.JsonProperty;+import com.fasterxml.jackson.databind.JsonNode;++public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {++    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);++    private final KeycloakSession session;+    private final ComponentModel componentModel;++    private AuthorizationEndpointRequestObject parsedRequestObject;++    public static final String INVALID_REQUEST_OBJECT = ""invalid_request_object"";++    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {+        this.session = session;+        this.componentModel = componentModel;+    }++    @Override+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {+        switch (context.getEvent()) {+            case AUTHORIZATION_REQUEST:+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),+                    authorizationRequestContext.getAuthorizationEndpointRequest(),+                    authorizationRequestContext.getRedirectUri());+                break;+            default:+                return;+        }+    }++    public void executeOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Authz Endpoint - authz request"");++        // Only support GET+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);++        // check whether whether request object exists+        if (requestParam == null && requestUriParam == null) {+            ClientPolicyLogger.log(logger, ""request object not exist."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter"");+        }++        // check whether request_uri is https scheme+        if (requestUriParam != null && !requestUriParam.startsWith(""https://"")) {+            ClientPolicyLogger.log(logger, ""request_uri scheme is not https."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter: request_uri"");+        }++        // check whether request object can be retrieved from request_uri+        String retrievedRequestObject = null;+        if (requestParam != null) {+            retrievedRequestObject = requestParam;+        } else {+            try (InputStream is = session.getProvider(HttpClientProvider.class).get(requestUriParam)) {","This means that when ""request_uri"" is used, then there will be 2 HTTP requests needed to ""request_uri"" during single AuthorizationEndpoint request. Because it is also loaded and parsed in the AuthzEndpointRequestObjectParser.Also even if ""request"" object is used (and not ""request_uri""), the parsing of ""request"" object is duplicated currently etc.I hope it is possible to somehow share the loading/parsing of the ""request"" object with the AuthzEndpointRequestObjectParser? This would mean that it would need to be done only once per AuthorizationEndpoint request and also will avoid some code duplications. Maybe parsed ""request"" can be saved as attribute of KeycloakSession for example?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7419,490527183,2020-09-17T19:59:18Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java,"@@ -0,0 +1,508 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import java.io.IOException;+import java.io.InputStream;+import java.util.Arrays;+import java.util.HashSet;+import java.util.Set;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.util.StreamUtil;+import org.keycloak.common.util.Time;+import org.keycloak.component.ComponentModel;+import org.keycloak.connections.httpclient.HttpClientProvider;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.Urls;+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyLogger;+import org.keycloak.util.JsonSerialization;++import com.fasterxml.jackson.annotation.JsonProperty;+import com.fasterxml.jackson.databind.JsonNode;++public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {++    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);++    private final KeycloakSession session;+    private final ComponentModel componentModel;++    private AuthorizationEndpointRequestObject parsedRequestObject;++    public static final String INVALID_REQUEST_OBJECT = ""invalid_request_object"";++    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {+        this.session = session;+        this.componentModel = componentModel;+    }++    @Override+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {+        switch (context.getEvent()) {+            case AUTHORIZATION_REQUEST:+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),+                    authorizationRequestContext.getAuthorizationEndpointRequest(),+                    authorizationRequestContext.getRedirectUri());+                break;+            default:+                return;+        }+    }++    public void executeOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Authz Endpoint - authz request"");++        // Only support GET+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);++        // check whether whether request object exists+        if (requestParam == null && requestUriParam == null) {+            ClientPolicyLogger.log(logger, ""request object not exist."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter"");+        }++        // check whether request_uri is https scheme+        if (requestUriParam != null && !requestUriParam.startsWith(""https://"")) {+            ClientPolicyLogger.log(logger, ""request_uri scheme is not https."");+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter: request_uri"");+        }++        // check whether request object can be retrieved from request_uri+        String retrievedRequestObject = null;+        if (requestParam != null) {+            retrievedRequestObject = requestParam;+        } else {+            try (InputStream is = session.getProvider(HttpClientProvider.class).get(requestUriParam)) {","@tnorimat It seems to me that some basic verifications like those lines https://github.com/Hitachi/keycloak/blob/KEYCLOAK-14204/services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java#L90-L105 can be still kept on `SecureRequestObjectExecutor`. However the downloading from ""request_uri"" and parsing ""request"" can be done on `AuthzEndpointRequestObjectParser` and then saved as attribute in the KeycloakSession. If there is some issue in downloading the ""request_uri"" or parsing the ""request"" object, then the exception will be thrown earlier in the `AuthzEndpointRequestObjectParser` (not in the `SecureRequestObjectExecutor`), which is fine IMO.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7419,491942329,2020-09-21T10:34:18Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/request/AuthzEndpointRequestParser.java,"@@ -46,8 +46,11 @@      */     public static final int ADDITIONAL_REQ_PARAMS_MAX_SIZE = 200; +    public static final String AUTHZ_REQUEST_PARAMS = ""RawRequesParameters"";","I am not sure about introducing constant AUTHZ_REQUEST_PARAMS and the attribute in KeycloakSession for this. It seems to me that requestParameters can be quite useful thing in general for ClientExecutors, so maybe the requestPArameters can be added directly as a field to the AuthorizationRequestContext class? The AuthorizationRequestContext is created from AuthorizationEndpoint.process method, which has access to the request parameters, so it should work fine?On the other hand, the ""request"" object itself (AUTHZ_REQUEST_OBJECT) is not be so widely used IMO, so I agree to keep it as an attribute in KeycloakSession as you did in this PR.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7412,492117208,2020-09-21T14:58:09Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java,"@@ -1210,6 +1214,22 @@ public Response permissionGrant() {             AccessToken accessToken = Tokens.getAccessToken(session);              if (accessToken == null) {+                try {+                    // In case the access token is invalid because it's expired or the user is disabled, identify the client+                    // from the access token anyway in order to set correct CORS headers.+                    TokenVerifier<AccessToken> verifier = TokenVerifier.create(accessTokenString, AccessToken.class)+                            .withDefaultChecks()+                            .realmUrl(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()))+                            .checkActive(false);+                    String kid = verifier.getHeader().getKeyId();+                    String algorithm = verifier.getHeader().getAlgorithm().name();+                    SignatureVerifierContext signatureVerifier = session.getProvider(SignatureProvider.class, algorithm).verifier(kid);+                    verifier.verifierContext(signatureVerifier);+                    AccessToken invalidToken = verifier.verify().getToken();","You don't need to fake-verify the token just to parse it. You can do something like:```suggestion                    AccessToken invalidToken = new JWSInput(accessTokenString).readJsonContent(AccessToken.class);```Maybe there's even more efficient solution, I'm not sure.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7320,492118521,2020-09-21T14:59:13Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmLocalizationProvider.java,"@@ -0,0 +1,163 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.jpa;++import org.keycloak.models.RealmLocalizationProvider;+import org.keycloak.models.RealmModel;+import org.keycloak.models.jpa.entities.RealmLocalizationTextEntity;++import java.util.HashMap;+import java.util.List;+import java.util.Map;++import javax.persistence.EntityManager;+import javax.persistence.TypedQuery;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.CriteriaDelete;+import javax.persistence.criteria.Root;++public class JpaRealmLocalizationProvider implements RealmLocalizationProvider {","This provider has many calls to `em.flush()`. These calls should be called only exceptionally, since they disrupt transaction processing. Are those really necessary?",
11198630,danielFesenmeyer,https://api.github.com/repos/keycloak/keycloak/pulls/7319,492123786,2020-09-21T15:03:57Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java,"@@ -841,42 +841,60 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin             predicates.add(root.get(""serviceAccountClientLink"").isNull());         } -        for (Map.Entry<String, String> entry : attributes.entrySet()) {-            String key = entry.getKey();-            String value = entry.getValue();+        final String idpAlias = attributes.get(UserModel.IDP_ALIAS);+        final String idpUserId = attributes.get(UserModel.IDP_USER_ID);+        if (idpAlias != null) {",My colleagues and I thought that it would be better to have the idp-search separated from the search for other attributes. One reason was that we decided that the idp-parameters have to be always searched for exactly - this is different from the other attributes for which a contains-search is provided.But I can also understand the advantage of combining the idp-search with other attributes - the search would be more powerful.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7035,492670102,2020-09-22T11:48:18Z,themes/src/main/resources/theme/base/admin/resources/partials/user-detail.html,"@@ -97,6 +97,42 @@                 </div>                 <kc-tooltip>{{:: 'email-verified.tooltip' | translate}}</kc-tooltip>             </div>+            <div class=""form-group clearfix block"" data-ng-if=""create"">+                <label class=""col-md-2 control-label"" for=""selected-groups"">{{:: 'groups-joining' | translate}}</label>+                <div class=""col-sm-6"">+                    <table class=""table table-striped table-bordered"" style=""margin-top: 0px"" id=""selected-groups"">+                        <thead>+                        <tr>+                            <th class=""kc-table-actions"" colspan=""2"">+                                <div class=""form-inline col-md-12"" style=""width: 107%"">+                                    <div class=""form-group"" style=""width: 100%"">+                                        <div class=""input-group"" style=""width: 100%"">+                                            <input type=""hidden"" ui-select2=""groupsUiSelect"" id=""groups"" data-ng-change=""selectGroup(selectedGroup);"" data-ng-model=""selectedGroup"" data-placeholder=""{{:: 'groups-joining-select.placeholder' | translate}}...""/>","I'm no UX expert but I'm not sure this is ok from the UX PoV. You have a search field and then you have a table below with selected values. Both have a remove button, one as a cross symbol, the other as a bigger button with text:![Screenshot 2020-09-22 at 13 39 45](https://user-images.githubusercontent.com/13906855/93877750-3a091d00-fcd9-11ea-8987-becdbda6ac66.png)This feels to me a bit confusing and even inconsistent with other places.Couldn't we use the same approach as with e.g. Required Actions?![Screenshot 2020-09-22 at 13 47 23](https://user-images.githubusercontent.com/13906855/93878325-2c07cc00-fcda-11ea-86f2-b50cc6e6244d.png)",
6166832,clementcur,https://api.github.com/repos/keycloak/keycloak/pulls/7035,492764840,2020-09-22T14:09:11Z,themes/src/main/resources/theme/base/admin/resources/partials/user-detail.html,"@@ -97,6 +97,42 @@                 </div>                 <kc-tooltip>{{:: 'email-verified.tooltip' | translate}}</kc-tooltip>             </div>+            <div class=""form-group clearfix block"" data-ng-if=""create"">+                <label class=""col-md-2 control-label"" for=""selected-groups"">{{:: 'groups-joining' | translate}}</label>+                <div class=""col-sm-6"">+                    <table class=""table table-striped table-bordered"" style=""margin-top: 0px"" id=""selected-groups"">+                        <thead>+                        <tr>+                            <th class=""kc-table-actions"" colspan=""2"">+                                <div class=""form-inline col-md-12"" style=""width: 107%"">+                                    <div class=""form-group"" style=""width: 100%"">+                                        <div class=""input-group"" style=""width: 100%"">+                                            <input type=""hidden"" ui-select2=""groupsUiSelect"" id=""groups"" data-ng-change=""selectGroup(selectedGroup);"" data-ng-model=""selectedGroup"" data-placeholder=""{{:: 'groups-joining-select.placeholder' | translate}}...""/>","I've copy-pasted a component used in Permissions UI:![image](https://user-images.githubusercontent.com/6166832/93893134-970ece00-fced-11ea-9e6f-cfa4c838dd2c.png)IMO, a tabular view better highlights groups hierarchy, compared to a ""tags input"".",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,493418236,2020-09-23T10:22:52Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/DeleteAccountActionConfirmPage.java,"@@ -0,0 +1,40 @@+package org.keycloak.testsuite.ui.account2.page;++import org.keycloak.testsuite.auth.page.AuthRealm;+import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIUtils.clickLink;++public class DeleteAccountActionConfirmPage extends AuthRealm {","This should extend the [`RequiredActions`](https://github.com/keycloak/keycloak/blob/65f51b7b83271bc42de923b3625cac8a69e8e9a2/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/auth/page/login/RequiredActions.java) class, similarily to e.g. [`UpdatePassword`](https://github.com/keycloak/keycloak/blob/65f51b7b83271bc42de923b3625cac8a69e8e9a2/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/auth/page/login/UpdatePassword.java) page object. Should be also placed in the same package to be available for other tests too.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7438,493517052,2020-09-23T12:14:37Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/AbstractPairwiseSubMapper.java,"@@ -90,7 +90,7 @@ protected void setAccessTokenSubject(IDToken token, String pairwiseSub) {     }      protected void setUserInfoTokenSubject(IDToken token, String pairwiseSub) {-        token.setSubject(pairwiseSub);+        token.getOtherClaims().put(""sub"", pairwiseSub);","I agree that this is strange workaround, however it seems as the safest what can be done IMO.The problem is one bigger issue that UserInfoTokenMapper class accepts ""AccessToken"" as an argument for some reason. This doesn't makes sense to me as it should instead accept ""UserInfo"" representation as an argument. This will allow to cleanup these workarounds and the strange code in UserInfoEndpoint, which need to manually convert token into the ""claims"" map. I've created JIRA for this few days ago https://issues.redhat.com/browse/KEYCLOAK-15537 . I suggest to address that one as a follow-up to remove workarounds. For now, I am just accepting the PR as it seems as the safest way for the backport to z-stream. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7319,493619371,2020-09-23T14:03:38Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java,"@@ -841,42 +841,60 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin             predicates.add(root.get(""serviceAccountClientLink"").isNull());         } -        for (Map.Entry<String, String> entry : attributes.entrySet()) {-            String key = entry.getKey();-            String value = entry.getValue();+        final String idpAlias = attributes.get(UserModel.IDP_ALIAS);+        final String idpUserId = attributes.get(UserModel.IDP_USER_ID);+        if (idpAlias != null) {","> One reason was that we decided that the idp-parameters have to be always searched for exactly - this is different from the other attributes for which a contains-search is provided.This limitation is a reasonable one, since it would be strange to search for an identity provider alias / username via a substring search. Still, JPA storage search would benefit from allowing for combining the predicates, so that it would be possible to search for e.g. enabled users coming from the given idp.",
6166832,clementcur,https://api.github.com/repos/keycloak/keycloak/pulls/7035,494478571,2020-09-24T17:09:48Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/users.js,"@@ -513,6 +515,39 @@ module.controller('UserDetailCtrl', function($scope, realm, user, BruteForceUser         }     } +    function pushSelectedGroupsToUser() {+        var groups = $scope.user.groups;+        if ($scope.selectedGroups) {","Since every node of the groups tree is now listed in search results, it's possible to add both parent and child groups.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7449,494782848,2020-09-25T06:51:03Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/KeycloakRecorder.java,"@@ -106,57 +109,102 @@ public void configSessionFactory(         QuarkusKeycloakSessionFactory.setInstance(new QuarkusKeycloakSessionFactory(factories, defaultProviders, reaugmented));     } -    public void setBuildTimeProperties(Map<String, String> buildTimeProperties, Boolean rebuild, String configArgs) {+    /**+     * <p>Validate the build time properties with any property passed during runtime in order to advertise any difference with the+     * server image state.+     * +     * <p>This method also keep the build time properties available at runtime.+     * +     * +     * @param buildTimeProperties the build time properties set when running the last re-augmentation+     * @param rebuild indicates whether or not the server was re-augmented+     * @param configArgs the configuration args if provided when the server was re-augmented+     */+    public void validateAndSetBuildTimeProperties(Map<String, String> buildTimeProperties, Boolean rebuild, String configArgs) {         BUILD_TIME_PROPERTIES = buildTimeProperties;         String configHelpText = configArgs;          for (String propertyName : getConfig().getPropertyNames()) {-            if (!propertyName.startsWith(MicroProfileConfigProvider.NS_KEYCLOAK_PREFIX)) {+            // we should only validate if there is a server image and if the property is a runtime property+            if (!shouldValidate(propertyName, rebuild)) {                 continue;             } -            String buildValue = Environment.getBuiltTimeProperty(propertyName).orElseGet(new Supplier<String>() {-                @Override -                public String get() {-                    return Environment.getBuiltTimeProperty(PropertyMappers.toCLIFormat(propertyName)).orElse(null);-                }+            // try to resolve any property set using profiles+            if (propertyName.startsWith(""%"")) {+                propertyName = propertyName.substring(propertyName.indexOf('.') + 1);+            }++            String finalPropertyName = propertyName;+            String buildValue = Environment.getBuiltTimeProperty(PropertyMappers.toCLIFormat(finalPropertyName))+                    .orElseGet(new Supplier<String>() {+                        @Override +                        public String get() {+                            return Environment.getBuiltTimeProperty(finalPropertyName).orElse(null);+                        }             });              ConfigValue value = getConfig().getConfigValue(propertyName);+            +            // if no value found we try to resolve using the CLI format+            if (value == null || value.getValue() == null) {+                value = getConfig().getConfigValue(PropertyMappers.toCLIFormat(propertyName));+            } -            if (buildValue != null && isRuntimeValue(value) && !buildValue.equalsIgnoreCase(value.getValue())) {+            if (value.getValue() != null && !value.getValue().equalsIgnoreCase(buildValue)) {                 if (configHelpText != null) {-                    String currentProp = ""--"" + PropertyMappers.toCLIFormat(propertyName).substring(3) + ""="" + buildValue;-                    String newProp = ""--"" + PropertyMappers.toCLIFormat(propertyName).substring(3) + ""="" + value.getValue();-                    -                    if (configHelpText.contains(currentProp)) {-                        LOGGER.warnf(""The new value [%s] of the property [%s] in [%s] differs from the value [%s] set into the server image. The new value will override the value set into the server image."", value.getValue(), propertyName, value.getConfigSourceName(), buildValue);-                        configHelpText = configHelpText.replaceAll(currentProp, newProp);-                    } else if (!configHelpText.contains(""--"" + PropertyMappers.toCLIFormat(propertyName).substring(3))) {-                        configHelpText += newProp;+                    if (buildValue != null) {+                        String currentProp =+                                ""--"" + PropertyMappers.toCLIFormat(propertyName).substring(3) + ""="" + buildValue;+                        String newProp =+                                ""--"" + PropertyMappers.toCLIFormat(propertyName).substring(3) + ""="" + value.getValue();++                        if (configHelpText.contains(currentProp)) {+                            LOGGER.warnf(""The new value [%s] of the property [%s] in [%s] differs from the value [%s] set into the server image. The new value will override the value set into the server image."",+                                    value.getValue(), propertyName, value.getConfigSourceName(), buildValue);+                            configHelpText = configHelpText.replaceAll(currentProp, newProp);+                        } else if (!configHelpText+                                .contains(""--"" + PropertyMappers.toCLIFormat(propertyName).substring(3))) {+                            LOGGER.warnf(""The new value [%s] of the property [%s] in [%s] differs from the value [%s] set into the server image. The new value will override the value set into the server image."",+                                    value.getValue(), propertyName, value.getConfigSourceName(), buildValue);+                            configHelpText += "" "" + newProp;+                        }+                    } else if (!BUILD_TIME_PROPERTIES.keySet().stream()+                            .anyMatch(new Predicate<String>() {+                                @Override+                                public boolean test(String s) {+                                    return PropertyMappers.canonicalFormat(finalPropertyName)+                                            .equalsIgnoreCase(PropertyMappers.canonicalFormat(s));+                                }+                            })) {+                        String prop = ""--"" + PropertyMappers.toCLIFormat(propertyName).substring(3) + ""="" + value.getValue();++                        if (!configHelpText.contains(prop)) {+                            LOGGER.warnf(""New property [%s] set with value [%s] in [%s]. This property is not persisted into the server image."",+                                    propertyName, value.getValue(), value.getConfigSourceName(), buildValue);+                            configHelpText += "" "" + prop;+                        }                     }                 }-            } else if (configHelpText != null && rebuild && isRuntimeValue(value)) {-                String prop = ""--"" + PropertyMappers.toCLIFormat(propertyName).substring(3) + ""="" + value.getValue();--                if (!configHelpText.contains(prop)) {-                    LOGGER.infof(""New property [%s] set with value [%s] in [%s]. This property is not persisted into the server image."",-                            propertyName, value.getValue(), value.getConfigSourceName(), buildValue);-                    configHelpText += "" "" + prop;-                }             }         }          if (configArgs != null && !configArgs.equals(configHelpText)) {-            LOGGER.infof(""Please, run the 'config' command if you want to configure the server image with the new property values:\n\t%s config %s"", Environment.getCommand(), String.join("" "", configHelpText.split("","")));+            LOGGER.warnf(""Please, run the 'config' command if you want to persist the new configuration into the server image:\n\n\t%s config %s\n"", Environment.getCommand(), String.join("" "", configHelpText.split("","")));         }     } -    private boolean isRuntimeValue(ConfigValue value) {-        String name = value.getName();-        return value.getValue() != null && !PropertyMappers.isBuildTimeProperty(name)-                && !""kc.version"".equals(name) && !""kc.config.args"".equals(-                name) && !""kc.home.dir"".equals(name);+    private boolean shouldValidate(String name, boolean rebuild) {+        return rebuild && name.contains(MicroProfileConfigProvider.NS_KEYCLOAK_PREFIX) +                && (!PropertyMappers.isBuildTimeProperty(name)+                && !""kc.version"".equals(name) ","Instead of this hardcoded list, we can maybe have some collection of those commands? Also it may be nice to have some class like ""QuarkusConstants"", so that we can use something like ""!QuarkusConstants.KC_CONFIG_FILE.equals(name)"" instead of ""!""kc.config.file"".equals(name) ?However I don't consider this as a blocker for this PR, but rather something for later :-)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7450,495116085,2020-09-25T16:57:34Z,quarkus/runtime/src/main/java/org/keycloak/configuration/PropertyMappers.java,"@@ -133,6 +131,19 @@ private static void configureDatabasePropertyMappers() {         createWithDefault(""db.pool.max-size"", ""quarkus.datasource.jdbc.max-size"", String.valueOf(100), ""The maximum size of the connection pool."");     } +    private static void configureClustering() {+        createWithDefault(""cluster.enabled"", ""kc.spi.connections-infinispan.default.clustered"", ""placeholder"", (value, context) -> {","@pedroigor I needed to use ""placeholder"" for the defaultValue as the transformer function is not executed in case that value is null. If we want to remove the workaround with ""placeholder"", we may need to change this line and remove the need to have non-null defaultValue - https://github.com/keycloak/keycloak/blob/master/quarkus/runtime/src/main/java/org/keycloak/configuration/PropertyMapper.java#L137 .Then it will be possible to run transformer function even if ""value"" is null - which I am not 100% sure we want to support? WDYT?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7155,496124414,2020-09-28T17:41:12Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfile.java,"@@ -0,0 +1,39 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import java.util.List;+import java.util.Map;++/**+ * Abstraction, which allows to update the user in various contexts (Required action of already existing user, or first identity provider+ * login when user doesn't yet exists in Keycloak DB)+ *+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public interface UserProfile {","Maybe we can make life easier for implementors if we change some methods like that:```    default String getFirstAttributeValue(String attributeKey) {        List<String> values = getAttributes().getOrDefault(name, Collections.emptyList());                if (values.isEmpty()) {            return null;        }                return values.get(0);    }    default List<String> getAttribute(String attributeKey) {        return getAttributes().get(key);    }```So that you only need to override `getId` and `getAttributes`. The latter being the real source of data.I'm also wondering if we should not have attributes in a separate structure similar to [Attributes](https://wildfly-security.github.io/wildfly-elytron/1.13.x/api-javadoc/org/wildfly/security/authz/Attributes.html). One of the main points being that we can add more controls such as read/write flags without impacting the main `UserProfile` API.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7155,496137968,2020-09-28T18:04:54Z,services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpReviewProfileAuthenticator.java,"@@ -110,28 +127,37 @@ protected void actionImpl(AuthenticationFlowContext context, SerializedBrokeredI             return;         } -        String username = realm.isRegistrationEmailAsUsername() ? formData.getFirst(UserModel.EMAIL) : formData.getFirst(UserModel.USERNAME);-        userCtx.setUsername(username);-        userCtx.setFirstName(formData.getFirst(UserModel.FIRST_NAME));-        userCtx.setLastName(formData.getFirst(UserModel.LAST_NAME));+        UserProfileUpdateHelper.update(UserUpdateEvent.IdpReview, context.getSession(), new UserModelDelegate(null) {",I think `UserProfileUpdateHelper` can be simpler if we just pass the attribute map instead of the `UserModel`. It would avoid having to create this anonymous class to work around the contract to only fetch attributes.I'm also wondering why the logic on `UserProfileUpdateHelper` is not on the `UserProfileProvider` itself?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7155,496149810,2020-09-28T18:26:55Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfileProviderFactory.java,"@@ -0,0 +1,27 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import org.keycloak.provider.ProviderFactory;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public interface UserProfileProviderFactory extends  ProviderFactory<UserProfileProvider> {","I think we could have some methods here to create the `UserProfileProvider` instance without pushing too much to clients of the API. For instance:```Map<String, List<String>> newAttributes = // obtain attributes to updateUserProfileProviderFactory factory = // obtain factory from sessionUserProfileProvider provider = factory.create(UserUpdateEvent.IdpReview, user.getAttributes(), newAttributes);UserProfileValidationResult result = profileProvider.validate();```This can hide some implementation details such as the `UserProfileContext` implementation that should be used. As well as the different `UserProfile` implementations (if we really need all those impls). In fact, another approach to the API could be:```Map<String, List<String>> newAttributes = // obtain attributes to updateUserProfileProvider provider = // obtain provider from factoryUserProfileValidationResult result = profileProvider.validate(UserProfile.forIdpReview(userCtx), newAttributes);```So that the event would become irrelevant and we could check for the context based on the type of the `UserProfile` instance.In addition to that, the user ID also works like any other attribute into the attribute map that is the real source of data and data structure we care about to perform the validations. The `Attributes` API I gave as an example could also help to make this SPI more attribute oriented and simplify even more how clients pass over the attributes from the different places in Keycloak as well as using different sources.I've also another idea for this SPI based on events. But I think it would demand changes that we probably don't want now to include a more generic and robust event system in Keycloak.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7155,496157779,2020-09-28T18:41:37Z,services/src/main/java/org/keycloak/userprofile/utils/UserProfileUpdateHelper.java,"@@ -0,0 +1,97 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile.utils;++import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.userprofile.validation.UserUpdateEvent;++import java.util.Collections;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public class UserProfileUpdateHelper {++    public static void update(UserUpdateEvent userUpdateEvent, KeycloakSession session, UserModel currentUser, StoredUserProfile updatedUser) {+        update(userUpdateEvent, session, currentUser, updatedUser, true);+    }+++    public static void update(UserUpdateEvent userUpdateEvent, KeycloakSession session, UserModel currentUser, StoredUserProfile updatedUser, boolean removeMissingAttributes) {+        RealmModel realm = session.getContext().getRealm();++        if (updatedUser.getAttributes() == null || updatedUser.getAttributes().size() == 0)+            return;++        //The Idp review does not respect ""isEditUserNameAllowed"" therefore we have to miss the check here+        if (!userUpdateEvent.equals(UserUpdateEvent.IdpReview)) {+            //This step has to be done before email is assigned to the username if isRegistrationEmailAsUsername is set+            //Otherwise email change will not reflect in username changes.+            if (updatedUser.getFirstAttribute(UserModel.USERNAME) != null && !realm.isEditUsernameAllowed()) {+                updatedUser.removeAttribute(UserModel.USERNAME);+            }+        }++        if (updatedUser.getFirstAttribute(UserModel.EMAIL) != null && updatedUser.getFirstAttribute(UserModel.EMAIL).isEmpty()) {+            updatedUser.removeAttribute(UserModel.EMAIL);+            updatedUser.setAttribute(UserModel.EMAIL, Collections.singletonList(null));",Why create an attribute with a list of `null` values ?,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7425,497587760,2020-09-30T15:09:10Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java,"@@ -241,17 +233,19 @@ public LDAPStorageProvider create(KeycloakSession session, ComponentModel model)     // Check if it's some performance overhead to create this map in every request. But probably not...     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());-        List<ComponentModel> mapperComponents = realm.getComponents(ldapModel.getId(), LDAPStorageMapper.class.getName());--        Map<ComponentModel, LDAPConfigDecorator> result = new HashMap<>();-        for (ComponentModel mapperModel : mapperComponents) {-            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory().getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());-            if (mapperFactory instanceof LDAPConfigDecorator) {-                result.put(mapperModel, (LDAPConfigDecorator) mapperFactory);-            }-        }--        return result;+        return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())+                .filter(mapperModel -> {+                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()+                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());+                    return mapperFactory instanceof LDAPConfigDecorator;","Suggestion: This can be replaced by LDAPConfigDecorator.isInstance() in a single statement```suggestion                    LDAPConfigDecorator.isInstance(session.getKeycloakSessionFactory()                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId()));```",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7425,497679953,2020-09-30T17:24:31Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java,"@@ -241,17 +233,19 @@ public LDAPStorageProvider create(KeycloakSession session, ComponentModel model)     // Check if it's some performance overhead to create this map in every request. But probably not...     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());-        List<ComponentModel> mapperComponents = realm.getComponents(ldapModel.getId(), LDAPStorageMapper.class.getName());--        Map<ComponentModel, LDAPConfigDecorator> result = new HashMap<>();-        for (ComponentModel mapperModel : mapperComponents) {-            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory().getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());-            if (mapperFactory instanceof LDAPConfigDecorator) {-                result.put(mapperModel, (LDAPConfigDecorator) mapperFactory);-            }-        }--        return result;+        return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())+                .filter(mapperModel -> {+                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()+                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());+                    return mapperFactory instanceof LDAPConfigDecorator;+                })+                .collect(HashMap::new,+                        (map, mapperModel) -> {+                            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()+                                    .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());+                            map.put(mapperModel, (LDAPConfigDecorator) mapperFactory);+                        },+                        HashMap::putAll);","I'm not 100% sure, but couldn't this be handled with```suggestion                        .collect(Collectors.toMap(Function.identity, mapperModel -> (LDAPConfigDecorator) session.getKeycloakSessionFactory()                                .getProviderFactory(LDAPStorageManager.class, mapperModel.getProviderId())));```Just suggesting something off the top of myhead, syntax might be a bit off",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7425,497739382,2020-09-30T19:10:16Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1725,15 +1669,13 @@ public AuthenticationFlowModel addAuthenticationFlow(AuthenticationFlowModel mod     }      @Override-    public List<AuthenticationExecutionModel> getAuthenticationExecutions(String flowId) {+    public Stream<AuthenticationExecutionModel> getAuthenticationExecutionsStream(String flowId) {         AuthenticationFlowEntity flow = em.getReference(AuthenticationFlowEntity.class, flowId);          return flow.getExecutions().stream()                 .filter(e -> getId().equals(e.getRealm().getId()))                 .map(this::entityToModel)-                .sorted(AuthenticationExecutionModel.ExecutionComparator.SINGLETON)-                .collect(Collectors.collectingAndThen(-                        Collectors.toList(), Collections::unmodifiableList));+                .sorted(AuthenticationExecutionModel.ExecutionComparator.SINGLETON);","Question: since this returns a sorted stream, shouldn't every use of this method that consumes the stream with forEach use forEachOrdered instead? If order was relevant in the original list-based implementation I believe we need to pay attention to that.Also, if order is important shouldn't the Javadoc in the interface mention that the returned stream is sorted and that if order is important forEachOrdered should be used when consuming the stream?",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7425,497951360,2020-10-01T02:33:55Z,services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java,"@@ -3,6 +3,7 @@ import com.fasterxml.jackson.annotation.JsonIgnore; import org.jboss.logging.Logger; import org.jboss.resteasy.annotations.cache.NoCache;+import org.keycloak.TokenVerifier;",Is this used in this class?,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7425,498081836,2020-10-01T08:45:35Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java,"@@ -241,17 +233,19 @@ public LDAPStorageProvider create(KeycloakSession session, ComponentModel model)     // Check if it's some performance overhead to create this map in every request. But probably not...     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());-        List<ComponentModel> mapperComponents = realm.getComponents(ldapModel.getId(), LDAPStorageMapper.class.getName());--        Map<ComponentModel, LDAPConfigDecorator> result = new HashMap<>();-        for (ComponentModel mapperModel : mapperComponents) {-            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory().getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());-            if (mapperFactory instanceof LDAPConfigDecorator) {-                result.put(mapperModel, (LDAPConfigDecorator) mapperFactory);-            }-        }--        return result;+        return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())+                .filter(mapperModel -> {+                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()+                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());+                    return mapperFactory instanceof LDAPConfigDecorator;","maybe like this? `mapperModel -> session.getKeycloakSessionFactory()                        .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId()) instanceof LDAPConfigDecorator`",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7425,498087977,2020-10-01T08:55:39Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java,"@@ -286,11 +283,13 @@ public UserModel addUser(RealmModel realm, String username) {          realm.getDefaultGroupsStream().forEach(proxy::joinGroup); -        for (RequiredActionProviderModel r : realm.getRequiredActionProviders()) {-            if (r.isEnabled() && r.isDefaultAction()) {-                proxy.addRequiredAction(r.getAlias());-            }-        }+        Optional<String> requiredAction = realm.getRequiredActionProvidersStream()+                .filter(RequiredActionProviderModel::isEnabled)+                .filter(RequiredActionProviderModel::isDefaultAction)+                .map(RequiredActionProviderModel::getAlias)+                .findFirst();+        if (requiredAction.isPresent())+            proxy.addRequiredAction(requiredAction.get());","Looking more into this, I think I wrongly understood the original method. I'm changing it to `realm.getRequiredActionProvidersStream()                .filter(RequiredActionProviderModel::isEnabled)                .filter(RequiredActionProviderModel::isDefaultAction)                .map(RequiredActionProviderModel::getAlias)                .forEach(proxy::addRequiredAction);`  which should have the same semantic. ",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7425,498106829,2020-10-01T09:27:35Z,model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java,"@@ -1725,15 +1669,13 @@ public AuthenticationFlowModel addAuthenticationFlow(AuthenticationFlowModel mod     }      @Override-    public List<AuthenticationExecutionModel> getAuthenticationExecutions(String flowId) {+    public Stream<AuthenticationExecutionModel> getAuthenticationExecutionsStream(String flowId) {         AuthenticationFlowEntity flow = em.getReference(AuthenticationFlowEntity.class, flowId);          return flow.getExecutions().stream()                 .filter(e -> getId().equals(e.getRealm().getId()))                 .map(this::entityToModel)-                .sorted(AuthenticationExecutionModel.ExecutionComparator.SINGLETON)-                .collect(Collectors.collectingAndThen(-                        Collectors.toList(), Collections::unmodifiableList));+                .sorted(AuthenticationExecutionModel.ExecutionComparator.SINGLETON);",I think you are right. I switched to `forEachOrdered` from `forEach` in each usage. One concern which I have is whether the corresponding methods in `infinispan/RealmAdapter` will preserve the ordering in case the data was cached.,
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,498138684,2020-10-01T10:21:22Z,core/src/main/java/org/keycloak/representations/account/UserRepresentation.java,"@@ -94,4 +97,13 @@ public void setAttributes(Map<String, List<String>> attributes) {         this.attributes = attributes;     } +    public void singleAttribute(String name, String value) {+        if (this.attributes == null) attributes = new HashMap<>();+        attributes.put(name, (value == null ? new ArrayList<String>() : Arrays.asList(value)));",the check does not check for attribute values but for the attribute list. If the list is not initialized (which is likely due to the nature of the Representation objects) this should IMHO nothing the user of this function has to deal with.,
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,498214791,2020-10-01T12:44:49Z,services/src/main/java/org/keycloak/userprofile/utils/UserProfileUpdateHelper.java,"@@ -0,0 +1,97 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile.utils;++import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.userprofile.validation.UserUpdateEvent;++import java.util.Collections;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public class UserProfileUpdateHelper {++    public static void update(UserUpdateEvent userUpdateEvent, KeycloakSession session, UserModel currentUser, StoredUserProfile updatedUser) {+        update(userUpdateEvent, session, currentUser, updatedUser, true);+    }+++    public static void update(UserUpdateEvent userUpdateEvent, KeycloakSession session, UserModel currentUser, StoredUserProfile updatedUser, boolean removeMissingAttributes) {+        RealmModel realm = session.getContext().getRealm();++        if (updatedUser.getAttributes() == null || updatedUser.getAttributes().size() == 0)+            return;++        //The Idp review does not respect ""isEditUserNameAllowed"" therefore we have to miss the check here+        if (!userUpdateEvent.equals(UserUpdateEvent.IdpReview)) {+            //This step has to be done before email is assigned to the username if isRegistrationEmailAsUsername is set+            //Otherwise email change will not reflect in username changes.+            if (updatedUser.getFirstAttribute(UserModel.USERNAME) != null && !realm.isEditUsernameAllowed()) {+                updatedUser.removeAttribute(UserModel.USERNAME);+            }+        }++        if (updatedUser.getFirstAttribute(UserModel.EMAIL) != null && updatedUser.getFirstAttribute(UserModel.EMAIL).isEmpty()) {+            updatedUser.removeAttribute(UserModel.EMAIL);+            updatedUser.setAttribute(UserModel.EMAIL, Collections.singletonList(null));","because for example this test expects that the handling of email is """" -> null while this is not the case anywhere else... https://github.com/keycloak/keycloak/blob/74988a3f21c26764e01956ff8c9ef5cea865cb2d/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/ResetPasswordTest.java#L836",
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,498216375,2020-10-01T12:47:11Z,services/src/main/java/org/keycloak/userprofile/utils/UserProfileUpdateHelper.java,"@@ -0,0 +1,97 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile.utils;++import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.userprofile.validation.UserUpdateEvent;++import java.util.Collections;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;++/**+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public class UserProfileUpdateHelper {++    public static void update(UserUpdateEvent userUpdateEvent, KeycloakSession session, UserModel currentUser, StoredUserProfile updatedUser) {+        update(userUpdateEvent, session, currentUser, updatedUser, true);+    }+++    public static void update(UserUpdateEvent userUpdateEvent, KeycloakSession session, UserModel currentUser, StoredUserProfile updatedUser, boolean removeMissingAttributes) {+        RealmModel realm = session.getContext().getRealm();++        if (updatedUser.getAttributes() == null || updatedUser.getAttributes().size() == 0)+            return;++        //The Idp review does not respect ""isEditUserNameAllowed"" therefore we have to miss the check here+        if (!userUpdateEvent.equals(UserUpdateEvent.IdpReview)) {+            //This step has to be done before email is assigned to the username if isRegistrationEmailAsUsername is set+            //Otherwise email change will not reflect in username changes.+            if (updatedUser.getFirstAttribute(UserModel.USERNAME) != null && !realm.isEditUsernameAllowed()) {+                updatedUser.removeAttribute(UserModel.USERNAME);+            }+        }++        if (updatedUser.getFirstAttribute(UserModel.EMAIL) != null && updatedUser.getFirstAttribute(UserModel.EMAIL).isEmpty()) {+            updatedUser.removeAttribute(UserModel.EMAIL);+            updatedUser.setAttribute(UserModel.EMAIL, Collections.singletonList(null));",I invested time in keeping the api of the validation as consistent as possible. But there are inconsistencies in the code Thats why I initially put the user update method into the user profile. That would have enabled to override the behaviour for the old very inconsistent code path while having a clean new store method in the future. But Stian argued against this as the profile should not care about storage but validation only. So I moved the code to this helper class and out of the SPI interface.,
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,498222902,2020-10-01T12:57:23Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfile.java,"@@ -0,0 +1,39 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import java.util.List;+import java.util.Map;++/**+ * Abstraction, which allows to update the user in various contexts (Required action of already existing user, or first identity provider+ * login when user doesn't yet exists in Keycloak DB)+ *+ * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>+ */+public interface UserProfile {",As I tried to explain in the other comment regards the interface of the userprofile. The current UserProfile interface is actually just an attributes interfaces (may a bad one) but I'm right now not sure how to go towards your solution.  I will push what I understood soon..,
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,498224607,2020-10-01T12:59:56Z,services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpReviewProfileAuthenticator.java,"@@ -110,28 +127,37 @@ protected void actionImpl(AuthenticationFlowContext context, SerializedBrokeredI             return;         } -        String username = realm.isRegistrationEmailAsUsername() ? formData.getFirst(UserModel.EMAIL) : formData.getFirst(UserModel.USERNAME);-        userCtx.setUsername(username);-        userCtx.setFirstName(formData.getFirst(UserModel.FIRST_NAME));-        userCtx.setLastName(formData.getFirst(UserModel.LAST_NAME));+        UserProfileUpdateHelper.update(UserUpdateEvent.IdpReview, context.getSession(), new UserModelDelegate(null) {","Regards the position of user profile itself see other comment.Regards the AttributeList.This won't work because of the nature of the different UserModel implementations (e,g, for idpReview). Some just are not useable as simple attribute list. (Their interface for the attributes does not work consistently) ",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7425,498457394,2020-10-01T19:06:20Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java,"@@ -286,11 +283,13 @@ public UserModel addUser(RealmModel realm, String username) {          realm.getDefaultGroupsStream().forEach(proxy::joinGroup); -        for (RequiredActionProviderModel r : realm.getRequiredActionProviders()) {-            if (r.isEnabled() && r.isDefaultAction()) {-                proxy.addRequiredAction(r.getAlias());-            }-        }+        Optional<String> requiredAction = realm.getRequiredActionProvidersStream()+                .filter(RequiredActionProviderModel::isEnabled)+                .filter(RequiredActionProviderModel::isDefaultAction)+                .map(RequiredActionProviderModel::getAlias)+                .findFirst();+        if (requiredAction.isPresent())+            proxy.addRequiredAction(requiredAction.get());","Yeah, I agree with you here. I remember seeing something very similar in another class, I'll try to locate it so you can fix both places if needed",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7320,498720535,2020-10-02T09:41:44Z,server-spi/src/main/java/org/keycloak/models/RealmProvider.java,"@@ -85,6 +86,18 @@ default GroupModel createGroup(RealmModel realm, String name, GroupModel toParen     void removeExpiredClientInitialAccess();     void decreaseRemainingCount(RealmModel realm, ClientInitialAccessModel clientInitialAccess); // Separate provider method to ensure we decrease remainingCount atomically instead of doing classic update +    void saveLocalizationText(String realmId, String locale, String key, String text);++    void saveLocalizationTexts(String locale, Map<String, String> localizationTexts, RealmModel realm);",Please keep `RealmModel` / `realmId` as the first parameter of the added methods (applies to all of the added methods).Is there a reason why there is sometimes `String realmId` and `RealmModel` other times? Could this be done consistently with the rest of the methods in this class?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7214,498730391,2020-10-02T10:02:57Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcOidcBrokerConfigurationUserInfoOnlyMappers.java,"@@ -0,0 +1,82 @@+package org.keycloak.testsuite.broker;++import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.IdentityProviderSyncMode;+import org.keycloak.protocol.ProtocolMapperUtils;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.mappers.OIDCAttributeMapperHelper;+import org.keycloak.protocol.oidc.mappers.UserAttributeMapper;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.ProtocolMapperRepresentation;++import java.util.Arrays;+import java.util.Collections;+import java.util.List;+import java.util.Map;++import static org.keycloak.testsuite.broker.BrokerTestConstants.*;+import static org.keycloak.testsuite.broker.BrokerTestTools.*;++/**+ * @author hmlnarik+ */+public class KcOidcBrokerConfigurationUserInfoOnlyMappers extends KcOidcBrokerConfiguration {++    public static final KcOidcBrokerConfigurationUserInfoOnlyMappers INSTANCE = new KcOidcBrokerConfigurationUserInfoOnlyMappers();++    protected static final String ATTRIBUTE_TO_MAP_USER_INFO = ""user-attribute-ufo"";+++    @Override+    public List<ClientRepresentation> createProviderClients() {+        ClientRepresentation client = new ClientRepresentation();+        client.setId(CLIENT_ID);+        client.setClientId(getIDPClientIdInProviderRealm());+        client.setName(CLIENT_ID);+        client.setSecret(CLIENT_SECRET);+        client.setEnabled(true);++        client.setRedirectUris(Collections.singletonList(getConsumerRoot() ++                ""/auth/realms/"" + REALM_CONS_NAME + ""/broker/"" + IDP_OIDC_ALIAS + ""/endpoint/*""));++        client.setAdminUrl(getConsumerRoot() ++                ""/auth/realms/"" + REALM_CONS_NAME + ""/broker/"" + IDP_OIDC_ALIAS + ""/endpoint"");++        ProtocolMapperRepresentation userAttrMapper = new ProtocolMapperRepresentation();+        userAttrMapper.setName(""attribute - name"");+        userAttrMapper.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);+        userAttrMapper.setProtocolMapper(UserAttributeMapper.PROVIDER_ID);++        Map<String, String> userAttrMapperConfig = userAttrMapper.getConfig();+        userAttrMapperConfig.put(ProtocolMapperUtils.USER_ATTRIBUTE, ATTRIBUTE_TO_MAP_USER_INFO);+        userAttrMapperConfig.put(OIDCAttributeMapperHelper.TOKEN_CLAIM_NAME, ATTRIBUTE_TO_MAP_USER_INFO);+        userAttrMapperConfig.put(OIDCAttributeMapperHelper.JSON_TYPE, ProviderConfigProperty.STRING_TYPE);+        userAttrMapperConfig.put(OIDCAttributeMapperHelper.INCLUDE_IN_ACCESS_TOKEN, ""false"");+        userAttrMapperConfig.put(OIDCAttributeMapperHelper.INCLUDE_IN_ID_TOKEN, ""false"");+        userAttrMapperConfig.put(OIDCAttributeMapperHelper.INCLUDE_IN_USERINFO, ""true"");+        userAttrMapperConfig.put(ProtocolMapperUtils.MULTIVALUED, ""true"");+++        client.setProtocolMappers(Arrays.asList(userAttrMapper));++        return Collections.singletonList(client);+    }++    @Override+    protected void applyDefaultConfiguration(final Map<String, String> config, IdentityProviderSyncMode syncMode) {+        config.put(IdentityProviderModel.SYNC_MODE, syncMode.toString());","Is it possible that this method will call something like:```super.applyDefaultConfiguration(config, syncMode);```at the beginning and then it will just add/remove additional fields, which differ from the default configuration used by KcOidcBrokerConfiguration.applyDefaultConfiguration method?This will allow to remove bunch of duplicated code from this PR for the properties, which are same as in KcOidcBrokerConfiguration. Also it will clearly show what properties are important for this test.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7214,498730855,2020-10-02T10:04:07Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/OidcUserInfoClaimToRoleMapperTest.java,"@@ -0,0 +1,168 @@+package org.keycloak.testsuite.broker;++import com.google.common.collect.ImmutableList;+import com.google.common.collect.ImmutableMap;+import org.jetbrains.annotations.NotNull;+import org.junit.Test;+import org.keycloak.admin.client.resource.IdentityProviderResource;+import org.keycloak.broker.oidc.mappers.ClaimToRoleMapper;+import org.keycloak.broker.provider.ConfigConstants;+import org.keycloak.models.IdentityProviderMapperModel;+import org.keycloak.models.IdentityProviderMapperSyncMode;+import org.keycloak.representations.idm.IdentityProviderMapperRepresentation;+import org.keycloak.representations.idm.IdentityProviderRepresentation;+import org.keycloak.representations.idm.UserRepresentation;++import java.util.List;++import static org.keycloak.models.IdentityProviderMapperSyncMode.FORCE;+import static org.keycloak.models.IdentityProviderMapperSyncMode.LEGACY;++/**+ * @author <a href=""mailto:external.martin.idel@bosch.io"">Martin Idel</a>+ */+public class OidcUserInfoClaimToRoleMapperTest extends AbstractRoleMapperTest {","Is it possible to remove some @Test methods from this class? It looks that this class is just copy/pasted from the existing class OidcClaimToRoleMapperTest and it adds all the tests, which were added by the original class. However we don't need 8 new test methods for fixing this single bug? I hope that 1 or 2 test methods should be sufficient?I mean tests are good, but too much tests adds overhead and additional time to run the code + additional maintenance price etc :-)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7214,498733465,2020-10-02T10:10:11Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcOidcBrokerConfigurationUserInfoOnlyMappers.java,"@@ -0,0 +1,82 @@+package org.keycloak.testsuite.broker;++import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.IdentityProviderSyncMode;+import org.keycloak.protocol.ProtocolMapperUtils;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.mappers.OIDCAttributeMapperHelper;+import org.keycloak.protocol.oidc.mappers.UserAttributeMapper;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.ProtocolMapperRepresentation;++import java.util.Arrays;+import java.util.Collections;+import java.util.List;+import java.util.Map;++import static org.keycloak.testsuite.broker.BrokerTestConstants.*;+import static org.keycloak.testsuite.broker.BrokerTestTools.*;++/**+ * @author hmlnarik+ */+public class KcOidcBrokerConfigurationUserInfoOnlyMappers extends KcOidcBrokerConfiguration {++    public static final KcOidcBrokerConfigurationUserInfoOnlyMappers INSTANCE = new KcOidcBrokerConfigurationUserInfoOnlyMappers();++    protected static final String ATTRIBUTE_TO_MAP_USER_INFO = ""user-attribute-ufo"";+++    @Override+    public List<ClientRepresentation> createProviderClients() {+        ClientRepresentation client = new ClientRepresentation();","Is it possible to call```List<ClientRepresentation> clients = super.createProviderClients();```at the beginning and then just update the configuration of the particular client based on what is needed for your test? This will allow to remove duplicated code copy/pasted from the parent class. See some other classes, which do the same approach - for example KcOidcBrokerClientSecretJwtTest.KcOidcBrokerConfigurationWithJWTAuthentication.I suggest to also take the approach with the anonymous configuration class as used by KcOidcBrokerClientSecretJwtTest is also good as the ""kcOidcBrokerConfigurationUserInfoOnlyMappers"" is used just by your test class and hence it is not needed to introduce another public class ""kcOidcBrokerConfigurationUserInfoOnlyMappers"" to Keycloak codebase for this.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7462,498735748,2020-10-02T10:15:04Z,services/src/main/java/org/keycloak/services/util/CookieHelper.java,"@@ -106,20 +108,15 @@ public static void addCookie(String name, String value, String path, String doma      private static Set<String> getInternalCookieValue(String name) {         HttpHeaders headers = Resteasy.getContextData(HttpHeaders.class);-         Set<String> cookiesVal = new HashSet<>();          // check for cookies in the request headers-        List<String> cookieHeader = headers.getRequestHeaders().get(HttpHeaders.COOKIE);-        if (cookieHeader != null) {-            logger.debugv(""{1} cookie found in the request's header"", name);-            cookieHeader.stream().map(s -> parseCookie(s, name)).forEach(cookiesVal::addAll);-        }+        cookiesVal.addAll(parseCookie(headers.getRequestHeaders().getFirst(HttpHeaders.COOKIE), name));","As per https://tools.ietf.org/html/rfc6265#section-5.4, ""When the user agent generates an HTTP request, the user agent MUST NOT attach more than one Cookie header field."".As per parsing multiple cookies within the same header, the test is checking that. As long as they have different values.But again, I'm not sure if this code is necessary for two main reasons:* Old and EOL browser support seems to be the reason behind that code* Resteasy should parse the cookies just like that already ?Plus the fact that we are adding some overhead on every request to parse the header whenever a cookie is queried.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7457,498760976,2020-10-02T11:17:07Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCAdvancedConfigWrapper.java,"@@ -114,6 +114,21 @@ public boolean isUseMtlsHokToken() {         return Boolean.parseBoolean(useUtlsHokToken);     } +    // KEYCLOAK-9551 Client Credentials Grant generates refresh token+    // https://tools.ietf.org/html/rfc6749#section-4.4.3+    public boolean isUseRefreshTokenForClientCredentialsGrant() {+        // ""true"" -> we allow use of refresh_token for client_credentials grant by default for backwards compatibility+        String val = getAttribute(OIDCConfigAttributes.USE_REFRESH_TOKEN_FOR_CLIENT_CREDENTIALS_GRANT, ""true"");","Will it be possible that newly created clients will have this ""false"" by default and won't generate refresh tokens, but the clients migrated from previous version will have this ""true"" for backwards compatibility?@stianst @pedroigor Do you agree with the migration behaviour as mentioned above?@thomasdarimont Regarding your question in the JIRA about version on the representations, the RealmRepresentation class has field ""keycloakVersion"" . So this can be perhaps used to check if it is migration from older version or not? If the field is not present, we may stick to default behaviour (false). WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7214,499402948,2020-10-05T07:50:22Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/OidcUserInfoClaimToRoleMapperTest.java,"@@ -0,0 +1,95 @@+package org.keycloak.testsuite.broker;++import com.google.common.collect.ImmutableList;+import com.google.common.collect.ImmutableMap;+import org.junit.Test;+import org.keycloak.admin.client.resource.IdentityProviderResource;+import org.keycloak.broker.oidc.mappers.ClaimToRoleMapper;+import org.keycloak.broker.provider.ConfigConstants;+import org.keycloak.models.IdentityProviderMapperModel;+import org.keycloak.models.IdentityProviderMapperSyncMode;+import org.keycloak.representations.idm.IdentityProviderMapperRepresentation;+import org.keycloak.representations.idm.IdentityProviderRepresentation;+import org.keycloak.representations.idm.UserRepresentation;++import java.util.List;++public class OidcUserInfoClaimToRoleMapperTest extends AbstractRoleMapperTest {++    private static final String USER_INFO_CLAIM = KcOidcBrokerClientUserInfoTest.ATTRIBUTE_TO_MAP_USER_INFO;+    private static final String USER_INFO_CLAIM_VALUE = ""value 1"";+    private String claimOnSecondLogin = """";++    @Override+    protected BrokerConfiguration getBrokerConfiguration() {+        return new KcOidcBrokerClientUserInfoTest().getBrokerConfiguration();","I think you can remove the class ""KcOidcBrokerClientUserInfoTest"" entirely and move the class KcOidcBrokerClientUserInfoTest.KcOidcBrokerConfigurationUserInfoOnlyMappers as the private method to this class? Also move the constant ATTRIBUTE_TO_MAP_USER_INFO from that class directly to your ""OidcUserInfoClaimToRoleMapperTest""",
26164793,bs-matil,https://api.github.com/repos/keycloak/keycloak/pulls/7155,499787640,2020-10-05T18:22:32Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -275,6 +222,39 @@ public ResourcesService resources() {      // TODO Federated identities +    /**+     * Returns the applications with the given id in the specified realm.+     *+     * @param clientId client id to search for+     * @return application with the provided id+     */+    @Path(""/applications/{clientId}"")+    @GET+    @Produces(MediaType.APPLICATION_JSON)",looks like accidentally. Shall I open a PR for removal?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7444,500257504,2020-10-06T13:03:36Z,model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java,"@@ -0,0 +1,344 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.role;++import org.jboss.logging.Logger;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;++import org.keycloak.models.RoleModel;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.common.Serialization;+import java.util.Comparator;+import java.util.Objects;+import java.util.UUID;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.models.map.storage.MapStorage;+import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import org.keycloak.models.RoleContainerModel;+import org.keycloak.models.RoleProvider;+import org.keycloak.models.map.common.StreamUtils;++public class MapRoleProvider implements RoleProvider {++    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };+    private final KeycloakSession session;+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;+    private final MapStorage<UUID, MapRoleEntity> roleStore;++    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {+        @Override+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {+            String r1 = o1 == null ? null : o1.getName();+            String r2 = o2 == null ? null : o2.getName();+            return r1 == r2 ? 0+              : r1 == null ? -1+              : r2 == null ? 1+              : r1.compareTo(r2);++        }+    };++    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {+        this.session = session;+        this.roleStore = roleStore;+        this.tx = new MapKeycloakTransaction<>(roleStore);+        session.getTransactionManager().enlist(tx);+    }++    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller++        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {+        final MapRoleEntity res = Serialization.from(origEntity);+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);+        return res;+    }++    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {+        if (realm == null || realm.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String realmId = realm.getId();+        return entity -> Objects.equals(realmId, entity.getRealmId());+    }++    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {+        if (client == null || client.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String clientId = client.getId();+        return entity -> entity.isClientRole() && +                Objects.equals(clientId, entity.getClientId());+    }++    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()+          .filter(Objects::nonNull);+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);+    }++    @Override+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""addRealmRole(%s, %s, %s)%s"", realm.getName(), id, name, getShortStackTrace());++        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());+        entity.setName(name);+        entity.setRealmId(realm.getId());+        if (tx.get(entity.getId(), roleStore::get) != null) {+            throw new ModelDuplicateException(""Role exists: "" + id);+        }+        tx.putIfAbsent(entity.getId(), entity);+        return entityToAdapterFunc(realm).apply(entity);+    }++    @Override+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {+        Stream<RoleModel> s = getRealmRolesStream(realm);+        if (first != null && first >= 0) {+            s = s.skip(first);+        }+        if (max != null && max >= 0) {+            s = s.limit(max);+        }+        return s;+    }++    @Override+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {+        return getNotRemovedUpdatedRolesStream()+                .filter(entityRealmFilter(realm))+                .filter(this::isRealmRole)+                .sorted(COMPARE_BY_NAME)+                .map(entityToAdapterFunc(realm));+    }++    private boolean isRealmRole(MapRoleEntity role) {+        return ! role.isClientRole();+    }++    @Override+    public RoleModel addClientRole(ClientModel client, String id, String name) {",Here we should check that there is no client role with the name for the client. This is enforced [here](https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/models/jpa/entities/RoleEntity.java#L55) for the jpa layer.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7444,500258565,2020-10-06T13:05:05Z,model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java,"@@ -0,0 +1,344 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.role;++import org.jboss.logging.Logger;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;++import org.keycloak.models.RoleModel;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.common.Serialization;+import java.util.Comparator;+import java.util.Objects;+import java.util.UUID;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.models.map.storage.MapStorage;+import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import org.keycloak.models.RoleContainerModel;+import org.keycloak.models.RoleProvider;+import org.keycloak.models.map.common.StreamUtils;++public class MapRoleProvider implements RoleProvider {++    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };+    private final KeycloakSession session;+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;+    private final MapStorage<UUID, MapRoleEntity> roleStore;++    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {+        @Override+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {+            String r1 = o1 == null ? null : o1.getName();+            String r2 = o2 == null ? null : o2.getName();+            return r1 == r2 ? 0+              : r1 == null ? -1+              : r2 == null ? 1+              : r1.compareTo(r2);++        }+    };++    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {+        this.session = session;+        this.roleStore = roleStore;+        this.tx = new MapKeycloakTransaction<>(roleStore);+        session.getTransactionManager().enlist(tx);+    }++    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller++        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {+        final MapRoleEntity res = Serialization.from(origEntity);+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);+        return res;+    }++    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {+        if (realm == null || realm.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String realmId = realm.getId();+        return entity -> Objects.equals(realmId, entity.getRealmId());+    }++    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {+        if (client == null || client.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String clientId = client.getId();+        return entity -> entity.isClientRole() && +                Objects.equals(clientId, entity.getClientId());+    }++    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()+          .filter(Objects::nonNull);+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);+    }++    @Override+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {",Here we should check that there is no realm role with the name for the realm. This is enforced [here](https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/models/jpa/entities/RoleEntity.java#L55) for the jpa layer.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7431,500524636,2020-10-06T18:53:01Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -57,6 +58,9 @@      UserModel getServiceAccount(ClientModel client);     List<UserModel> getUsers(RealmModel realm, boolean includeServiceAccounts);+    default Stream<UserModel> getUsersStream(RealmModel realm, boolean includeServiceAccounts) {+        return getUsers(realm, includeServiceAccounts).stream();+    }","With Realms, Roles, etc, we are doing the other way around - adding the stream variant and making the old list-based methods. Are we changing this?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7455,501228826,2020-10-07T18:35:30Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/SetClientNoteAuthenticator.java,"@@ -0,0 +1,150 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.testsuite.forms;++import java.util.List;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.Authenticator;+import org.keycloak.authentication.AuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.sessions.AuthenticationSessionModel;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class SetClientNoteAuthenticator implements Authenticator, AuthenticatorFactory {++    protected static final Logger logger = Logger.getLogger(SetClientNoteAuthenticator.class);++    public static final String PROVIDER_ID = ""set-client-note-authenticator"";++    // Query parameters of this name will be used to save the client note to authentication session+    public static final String PREFIX = ""note-"";++    @Override+    public void authenticate(AuthenticationFlowContext context) {+        MultivaluedMap<String, String> inputData = context.getHttpRequest().getDecodedFormParameters();","@pedroigor Sure, this is not safe. This is testsuite-only authenticator, which is not intended to be ever used in production. I've used authenticator just to be able to test this for the OAuth2 DirectGrant, as the Docker protocol automated tests don't work.As you pointed, in case of the docker protocol, it is currently hardcoded - the note is set in the DockerEndpoint class. Other protocols (OIDC, SAML) currently don't have support for transient session in this PR - with the only exception of the testsuite, which have this SetClientNoteAuthenticator .Do you think that we need authenticator to be added to the main codebase to be able to have transient sessions per flow? I can think that OAuth2 Resource Owner Password Credentials Grant (Direct Grant) in some cases doesn't need user session at all. AFAIK Sometimes people use DirectGrant just for the single authentication to some CLI app and never need to refresh or introspect tokens etc. Not sure if this is useful also for some other protocols - like for example SAML ECP? WDYT?",
61745358,lhanusov,https://api.github.com/repos/keycloak/keycloak/pulls/7437,501470516,2020-10-08T06:13:06Z,services/src/main/java/org/keycloak/utils/ReservedCharValidator.java,"@@ -22,14 +22,16 @@ /**  *  * @author Stan Silvert+ * @author Lukas Hanusovsky lhanusov@redhat.com  */ public class ReservedCharValidator {",@ssilvert I changed the ReservedChars array and added there 3 new chars. Also Hynek proposed to refactor the whole class and change the for-each loop into regex validation. What do you think?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7455,501573957,2020-10-08T09:23:40Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/SetClientNoteAuthenticator.java,"@@ -0,0 +1,150 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.testsuite.forms;++import java.util.List;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.Authenticator;+import org.keycloak.authentication.AuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.sessions.AuthenticationSessionModel;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class SetClientNoteAuthenticator implements Authenticator, AuthenticatorFactory {++    protected static final Logger logger = Logger.getLogger(SetClientNoteAuthenticator.class);++    public static final String PROVIDER_ID = ""set-client-note-authenticator"";++    // Query parameters of this name will be used to save the client note to authentication session+    public static final String PREFIX = ""note-"";++    @Override+    public void authenticate(AuthenticationFlowContext context) {+        MultivaluedMap<String, String> inputData = context.getHttpRequest().getDecodedFormParameters();","@hmlnarik @pedroigor Well, I am starting to think that Authenticator approach may be nice and will have some advantages :) Administrator can decide if he wants to create transient session by simply adding the authenticator to the authentication flow. May be useful for DirectGrant or SAML ECP. For Docker protocol, we can have this authenticator in the flow by default, but admin will have a chance to remove it if he wants and have sessions persistent for docker as well for some reason.Authenticatior will have some additional flexibility that administrator may want to persist sessions just under specified condition (hence the authenticator can be added to some conditional subflow and be triggered just in case of the condition passed)... This is something, which won't be easily available if we have this as hardcoded option of the authentication flow.On the other hand, this won't be classic ""Authenticator"", but rather some kind of interceptor in the authentication flow. But our Authentication SPI don't have this concept, so just use it as implementation of ""Authenticator"" interface can be possible.So my ideal way would be to change this PR to have the Authenticator approach, but if you prefer, I can keep it as is and just update the documentation. WDYT?I agree that docs will need to be updated. As pointed, transient session would mean that introspection, ""refresh token"" or ""Revoke session"" won't be possible. I will update the docs once we refine whether to go with authenticator approach or keep the PR as is.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7455,501751977,2020-10-08T14:10:12Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/SetClientNoteAuthenticator.java,"@@ -0,0 +1,150 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.testsuite.forms;++import java.util.List;++import javax.ws.rs.core.MultivaluedMap;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.Authenticator;+import org.keycloak.authentication.AuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.sessions.AuthenticationSessionModel;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class SetClientNoteAuthenticator implements Authenticator, AuthenticatorFactory {++    protected static final Logger logger = Logger.getLogger(SetClientNoteAuthenticator.class);++    public static final String PROVIDER_ID = ""set-client-note-authenticator"";++    // Query parameters of this name will be used to save the client note to authentication session+    public static final String PREFIX = ""note-"";++    @Override+    public void authenticate(AuthenticationFlowContext context) {+        MultivaluedMap<String, String> inputData = context.getHttpRequest().getDecodedFormParameters();","@hmlnarik @pedroigor Ok, Thanks. Let's wait with the authenticator or something else to later if needed. The docs PR is here https://github.com/keycloak/keycloak-documentation/pull/1045 .I did not know SAML ECP profile does not have separate flow, Thanks for clarifying. I somehow assumed that yes based on the fact that Direct grant (OAuth2 Resource Owner PAssword Credentials) has it and I though this is somehow similar.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7437,501981892,2020-10-08T20:05:49Z,services/src/main/java/org/keycloak/utils/ReservedCharValidator.java,"@@ -22,14 +22,16 @@ /**  *  * @author Stan Silvert+ * @author Lukas Hanusovsky lhanusov@redhat.com  */ public class ReservedCharValidator {",You can get the disallowed character encountered by the regex via capturing groups. Regex has linear complexity while current `validate` complexity is O(nm).,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7482,502588956,2020-10-09T17:57:10Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -1414,8 +1414,7 @@ private static ClientModel createClient(KeycloakSession session, RealmModel real          if (resourceRep.getProtocolMappers() != null) {             // first, remove all default/built in mappers-            Set<ProtocolMapperModel> mappers = client.getProtocolMappers();-            for (ProtocolMapperModel mapper : mappers) client.removeProtocolMapper(mapper);+            client.getProtocolMappersStream().forEach(client::removeProtocolMapper);",Is there a chance that a concurrent modification exception is thrown here?,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7482,502594418,2020-10-09T18:08:28Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -1606,8 +1605,7 @@ public static ClientScopeModel createClientScope(KeycloakSession session, RealmM         if (resourceRep.getProtocol() != null) clientScope.setProtocol(resourceRep.getProtocol());         if (resourceRep.getProtocolMappers() != null) {             // first, remove all default/built in mappers-            Set<ProtocolMapperModel> mappers = clientScope.getProtocolMappers();-            for (ProtocolMapperModel mapper : mappers) clientScope.removeProtocolMapper(mapper);+            clientScope.getProtocolMappersStream().forEach(clientScope::removeProtocolMapper);",Same: Is there a chance that a concurrent modification exception is thrown here?,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7425,502602545,2020-10-09T18:25:17Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java,"@@ -47,24 +47,17 @@ import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery; import org.keycloak.storage.ldap.idm.query.internal.LDAPQueryConditionsBuilder; import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;-import org.keycloak.storage.ldap.mappers.FullNameLDAPStorageMapper;-import org.keycloak.storage.ldap.mappers.FullNameLDAPStorageMapperFactory;-import org.keycloak.storage.ldap.mappers.HardcodedLDAPAttributeMapper;-import org.keycloak.storage.ldap.mappers.HardcodedLDAPAttributeMapperFactory;-import org.keycloak.storage.ldap.mappers.LDAPConfigDecorator;-import org.keycloak.storage.ldap.mappers.LDAPStorageMapper;-import org.keycloak.storage.ldap.mappers.LDAPStorageMapperFactory;-import org.keycloak.storage.ldap.mappers.UserAttributeLDAPStorageMapper;-import org.keycloak.storage.ldap.mappers.UserAttributeLDAPStorageMapperFactory;+import org.keycloak.storage.ldap.mappers.*;",Star import that was reverted in previous classes is used here,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7442,502760716,2020-10-10T07:49:57Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -55,9 +55,33 @@     public static final String ENABLED_FROM_METADATA  = ""enabledFromMetadata"";     public static final String AUTHN_CONTEXT_COMPARISON_TYPE = ""authnContextComparisonType"";     public static final String AUTHN_CONTEXT_CLASS_REFS = ""authnContextClassRefs"";-    public static final String AUTHN_CONTEXT_DECL_REFS = ""authnContextDeclRefs"";-    public static final String SIGN_SP_METADATA = ""signSpMetadata"";-+    public static final String AUTHN_CONTEXT_DECL_REFS = ""authnContextDeclRefs"";   +    public static final String SIGN_SP_METADATA = ""signSpMetadata""; +    // entity attributes+    public static final String RESEARCH_SCHOLARSHIP = ""researchAndScholarship"";+    public static final String GEANT_DATA_PROTECTION_CODE = ""geantDataProtectionCode"";+    // description extensions+    public static final String REGISTRATION_AUTHORITY = ""registrationAuthority"";+    public static final String REGISTRATION_POLICY = ""registrationPolicy"";+    // UIinfo fields+    public static final String DISPLAY_NAME = ""displayName"";+    public static final String DESCRIPTION = ""description"";+    public static final String INFORMATION_URL = ""informationURL"";+    public static final String PRIVACY_STATEMENT_URL = ""privacyStatementURL"";+    public static final String LOGO = ""logo"";+    public static final String LOGO_HEIGHT = ""logoHeight"";+    public static final String LOGO_WIDTH = ""logoWidth"";+    // organization- contact person+    public static final String ORGANIZATION_NAME = ""organizationName"";+    public static final String ORGANIZATION_DISPLAY_NAME = ""organizationDisplayName"";+    public static final String ORGANIZATION_URL = ""organizationURL"";+    public static final String CONTACT_TYPE = ""contactType"";+    public static final String CONTACT_COMPANY = ""contactCompany"";+    public static final String CONTACT_GIVEN_NAME = ""contactGivenName"";+    public static final String CONTACT_SURNAME = ""contactSurname"";+    public static final String CONTACT_EMAIL_ADDRESS = ""contactEmailAddress"";+    public static final String CONTACT_TELEMPHONE_NUMBER = ""contactTelephoneNumber"";",Prefix all metadata constants by `MD_` / `MDUI_` to distinguish descriptive properties from those used for flow.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7457,503120541,2020-10-12T08:22:44Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java,"@@ -743,6 +744,13 @@ public Response clientCredentialsGrant() {          event.success(); +        // KEYCLOAK-9551 Client Credentials Grant generates refresh token handling+        if (!useRefreshToken) {","So the other PR for ""transient sessions"" was merged before yours, see the commit https://github.com/keycloak/keycloak/commit/ff05072c164d95e5084fba7d556820d1ccbe7f31 . So I suggest that you rebase to latest master and do:- When calling ""createUserSession"" in TokenEndpoint.clientCredentialsGrant(), you can add the flag PERSISTENT or TRANSIENT as last parameter to the method based on if refreshToken is required. This will allow to remove TODO I've added in the other PR. Also it won't be needed to call this ""removeUserSession"", so it can be removed entirely.",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7442,503146531,2020-10-12T09:03:26Z,server-spi/src/main/java/org/keycloak/models/RealmModel.java,"@@ -396,6 +396,7 @@     void updateIdentityProvider(IdentityProviderModel identityProvider);     Set<IdentityProviderMapperModel> getIdentityProviderMappers();     Set<IdentityProviderMapperModel> getIdentityProviderMappersByAlias(String brokerAlias);+    Set<IdentityProviderMapperModel> getIdentityProviderMappersByAliasAndMapper(String brokerAlias, String identityProviderMapper);","I believe that Java code should have as less as possible loops in lists for having better performance.See my updating code in model\infinispan\src\main\java\org\keycloak\models\cache\infinispan\RealmAdapter.java .However,if you ensist, I will do the required change.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7470,503386250,2020-10-12T15:51:56Z,themes/src/main/resources/theme/base/login/login.ftl,"@@ -1,10 +1,10 @@ <#import ""template.ftl"" as layout>","A comment unrelated to this file.![Screenshot 2020-10-12 at 17 38 54](https://user-images.githubusercontent.com/13906855/95766038-fd668b00-0cb2-11eb-9097-370c030cfe36.png)Just a few nit picks on the OTP registration form:* The ""Device Name"" input field looks different from the input field above. Isn't it perhaps missing some CSS class?* When the content is too long and needs to be scrolled, the background is acting somewhat weird. But this issue was present even before so maybe it's out of scope of this PR.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7470,503401472,2020-10-12T16:18:42Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -113,27 +110,28 @@           <#-- App-initiated actions should not see warning messages about the need to complete the action -->           <#-- during login.                                                                               -->           <#if displayMessage && message?has_content && (message.type != 'warning' || !isAppInitiatedAction??)>-              <div class=""alert alert-${message.type}"">-                  <#if message.type = 'success'><span class=""${properties.kcFeedbackSuccessIcon!}""></span></#if>-                  <#if message.type = 'warning'><span class=""${properties.kcFeedbackWarningIcon!}""></span></#if>-                  <#if message.type = 'error'><span class=""${properties.kcFeedbackErrorIcon!}""></span></#if>-                  <#if message.type = 'info'><span class=""${properties.kcFeedbackInfoIcon!}""></span></#if>-                  <span class=""kc-feedback-text"">${kcSanitize(message.summary)?no_esc}</span>+              <div class=""alert-${message.type} ${properties.kcAlertClass} pf-m-<#if message.type = 'error'>danger<#else>${message.type}</#if>"">","Found a few notification nitpicks:* The font size is much bigger than the rest of the text. They should be probably matching but the other text is maybe too small? Maybe they could meet somewhere in the middle, a compromise?* The notification box is probably missing some bottom margin.![Screenshot 2020-10-12 at 18 14 15](https://user-images.githubusercontent.com/13906855/95769015-7cf65900-0cb7-11eb-865e-7a8ec6cef048.png)",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7437,503462145,2020-10-12T18:20:37Z,services/src/main/java/org/keycloak/utils/ReservedCharValidator.java,"@@ -22,14 +22,16 @@ /**  *  * @author Stan Silvert+ * @author Lukas Hanusovsky lhanusov@redhat.com  */ public class ReservedCharValidator {","> You can get the disallowed character encountered by the regex via capturing groups. Regex has linear complexity while current `validate` complexity is O(nm).I doubt that there is actually a meaningful performance benefit because n and m are so small.  And regex solutions often to lead to code that is hard to read.But like I said, either way is fine with me.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7415,504440712,2020-10-14T06:51:01Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPReadOnlyTest.java,"@@ -125,6 +127,23 @@ public void testReadOnlyWithTOTPEnabled() {         user.removeCredential(totpCredentialId);     } +    // KEYCLOAK-3365+    @Test+    public void testReadOnlyUserDoesNotThrowIfUnchanged() {+        UserResource user = ApiUtil.findUserByUsernameId(testRealm(), ""johnkeycloak"");","Do you please have a chance to update this test a bit and test that requiredAction add/remove works? As I believe that is the main reason why you created this PR. I mean something similar to this:```        UserResource user = ApiUtil.findUserByUsernameId(testRealm(), ""johnkeycloak"");        UserRepresentation userRepresentation = user.toRepresentation();        user.setRequiredActions(Collections.singletonList(UserModel.RequiredAction.CONFIGURE_TOTP.toString());        user.update(userRepresentation);        // Check and revert required action        userRepresentation = user.toRepresentation();        Assert.assertEquals(user.toRepresentation().getRequiredActions().getSize(), 1);        Assert.assertEquals(user.toRepresentation().getRequiredActions().get(0), UserModel.RequiredAction.CONFIGURE_TOTP.toString());        user.setRequiredActions(Collections.emptyList());        user.update(userRepresentation);```",
6265563,zak905,https://api.github.com/repos/keycloak/keycloak/pulls/7176,506952092,2020-10-17T15:06:51Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/page/DeleteAccountPage.java,"@@ -0,0 +1,29 @@+package org.keycloak.testsuite.ui.account2.page;++import javax.ws.rs.core.UriBuilder;++import org.openqa.selenium.By;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIUtils.clickLink;++/**+ * @author Zakaria Amine <zakaria.amine88@gmail.com>+ */+public class DeleteAccountPage extends AbstractLoggedInPage  {++  @Override+  public String getPageId() {+    return ""delete-account"";+  }++  @Override+  public boolean isCurrent() {+    return driver.getTitle().contains(""Keycloak Account Management"") && driver.getCurrentUrl().split(""\\?"")[0].endsWith(""/account/#/delete-account"");","since now moving the functionality to Account page, I will be deleting this class. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7444,507198460,2020-10-18T18:48:09Z,model/jpa/src/main/java/org/keycloak/models/jpa/RoleAdapter.java,"@@ -214,7 +201,7 @@ public int hashCode() {         return getId().hashCode();     } -    public static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {+    private static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {",`static` is better since there is one parameter less to pass (`this`).,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7470,507638473,2020-10-19T10:26:35Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -1,4 +1,4 @@-<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false displayWide=false showAnotherWayIfPresent=true>+<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false showAnotherWayIfPresent=true> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""  ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">","@vmuzikar @pdrozd Thanks for your comments. IE doesn't support `var()` function, so it's not possible to load the variables. In this case, there should be some default hardcoded values in main `.css` file. But, it's contradicted against what @ssilvert suggested above. Then, there will be duplicate properties in  the main `.css` file, in order to keep compatibility with various browsers. However, it's true, the login screen should be displayed properly on all browsers, so I'll add the default values. I just wanted to highlight this issue.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7470,507639991,2020-10-19T10:29:15Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -1,4 +1,4 @@-<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false displayWide=false showAnotherWayIfPresent=true>+<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false showAnotherWayIfPresent=true> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""  ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">","Just for the record, here's an [official guide for IE11 support in PF4](https://github.com/patternfly/patternfly/wiki/IE11-Support).",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7444,508281940,2020-10-20T07:49:08Z,model/jpa/src/main/java/org/keycloak/models/jpa/RoleAdapter.java,"@@ -214,7 +201,7 @@ public int hashCode() {         return getId().hashCode();     } -    public static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {+    private static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {","> It doesn't have to be static any more, thanks. The check is although still necessary. `model` could be instance of `infinispan.RoleAdapter`I see it now, thanks for explanation. I thought the model can't be anything else than `jpa.RoleAdapter`.> `static` is better since there is one parameter less to pass (`this`).Well if it would be non-static, there are still 2 parameter because we can get rid of EntityManager, since it is part of `this`. Looking at it again, I would say it is not a big difference between static and non-static here, but maybe I am missing something. We can leave it as it is.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7097,508840130,2020-10-20T21:07:37Z,services/src/main/java/org/keycloak/services/resources/admin/RoleContainerResource.java,"@@ -148,6 +151,38 @@ public Response createRole(final RoleRepresentation rep) {                 adminEvent.resource(ResourceType.REALM_ROLE);             } +            // Handling of nested composite roles for KEYCLOAK-12754+            if (rep.isComposite() && rep.getComposites() != null) {+                RoleRepresentation.Composites composites = rep.getComposites();++                Set<String> compositeRealmRoles = composites.getRealm();+                if (compositeRealmRoles != null && !compositeRealmRoles.isEmpty()) {+                    Set<RoleModel> realmRoles = compositeRealmRoles.stream()+                            .map(realm::getRole)+                            .filter(Objects::nonNull)","@vmuzikar sorry for the long delay,.. I just rebased the PR and added the requested checks, to ensure that the roles contained in the composite role exist. The code now throws a `NotFoundException` if a nested role does not exist.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7516,509040456,2020-10-21T07:13:08Z,themes/src/main/resources/theme/keycloak/login/theme.properties,"@@ -2,7 +2,7 @@ parent=base import=common/keycloak  styles=css/login.css-stylesCommon=node_modules/patternfly/dist/css/patternfly.min.css node_modules/patternfly/dist/css/patternfly-additions.min.css lib/zocial/zocial.css+stylesCommon=node_modules/patternfly/dist/css/patternfly.min.css web_modules/@patternfly/react-core/dist/styles/app.css web_modules/@patternfly/react-core/dist/styles/base.css node_modules/patternfly/dist/css/patternfly-additions.min.css lib/patternfly4/tile.css","I have some issues with margin and padding. If you add the `css` file in this order, like below, it should resolve that.`base.css, app.css, patternfly.min.css, patternfly-additions.min.css tile.css`",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7516,509046115,2020-10-21T07:23:33Z,themes/src/main/resources/theme/keycloak/common/resources/lib/patternfly4/tile.css,"@@ -0,0 +1,100 @@+.pf-c-tile {","@Pepo48 Have you tried this on IE? IE doesn't support `var()` function. The basic screens should be available even in IE, as it was discussed [here](https://github.com/keycloak/keycloak/pull/7470#discussion_r503393541). So, there should be, at least, some similar appearance like with PF4.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7516,509050965,2020-10-21T07:31:40Z,themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -515,8 +515,12 @@ a.zocial  {     width: 100%; } -.login-pf-page .card-pf{-  margin-bottom: 10px;+.otp-tile {+    padding: 1.5rem;","Is it possible to add any `margin-bottom`? If user have defined f.e. 3 OTP credentials with longer name, there are two rows, but there are no space between them.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/7150,509106943,2020-10-21T08:55:55Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -438,15 +438,13 @@                 baseUrl = kc.endpoints.authorize();","Sure, you can find them in the same directory right [here](https://github.com/keycloak/keycloak/blob/master/adapters/oidc/js/src/main/resources/keycloak.d.ts).",
12183470,sventorben,https://api.github.com/repos/keycloak/keycloak/pulls/7466,509453189,2020-10-21T17:02:48Z,services/src/main/java/org/keycloak/services/resources/admin/UsersResource.java,"@@ -150,6 +152,8 @@ public Response createUser(final UserRepresentation rep) {         }          try {+            UserEventContext userEvent = UserEvents.createByAdmin(session, rep).firePreEvent();","Should this really be fired in the Ressource. Should not this be implemented in the UserStorageProvider or UserStorageManager? I am just wondering because there may be use cases where creation or deletion of a user may not be triggered by an API. For example, UserStorageManager has a feature 'import validation' which deletes users from Keycloak when they are invalid or do not exist any longern in the system integrated by the federation provider.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7470,509927607,2020-10-22T07:09:20Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -1,4 +1,4 @@-<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false displayWide=false showAnotherWayIfPresent=true>+<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false showAnotherWayIfPresent=true> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""  ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">","I'd say, there could be some basic (not like with PF4) functionality/appearance in login screens and inform customer/user, that the IE support will be dropped out soon and that there is a need for using other browser. I mean, there could be some warning alert with the message. At this time, IMHO, it's not a big deal for customer/user switch to another browser. AFAIK, IE is barely supported by Microsoft, so I think, there is no need for us support that in the big manner either. WDYT?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7442,510251596,2020-10-22T15:24:04Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -18,13 +18,17 @@  import static org.keycloak.common.util.UriUtils.checkUrl; +import java.io.IOException;+import java.util.Map;+ import org.keycloak.common.enums.SslRequired; import org.keycloak.dom.saml.v2.protocol.AuthnContextComparisonType; import org.keycloak.models.IdentityProviderModel; import org.keycloak.models.KeycloakSession; import org.keycloak.models.RealmModel; import org.keycloak.protocol.saml.SamlPrincipalType; import org.keycloak.saml.common.util.XmlKeyInfoKeyNameTransformer;+import org.keycloak.util.JsonSerialization;",Remove unused imports,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7442,510255386,2020-10-22T15:28:55Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -335,11 +362,169 @@ public void setSignSpMetadata(boolean signSpMetadata) {         getConfig().put(SIGN_SP_METADATA, String.valueOf(signSpMetadata));     } +    public String getSamlAttributes() throws IOException {+        return getConfig().get(SAML_ATTRIBUTES) ;+    }++    public void setSamlAttributes(String attributes) throws IOException {+        getConfig().put(SAML_ATTRIBUTES, attributes);+    }++    public String getdrpiRegistrationAuthority() {+        return getConfig().get(MDRPI_REGISTRATION_AUTHORITY);+    }++    public void setdrpiRegistrationAuthority(String mdrpiRegistrationAuthority) {+        getConfig().put(MDRPI_REGISTRATION_AUTHORITY, mdrpiRegistrationAuthority);+    }++    public String getdrpiRegistrationPolicy() {+        return getConfig().get(MDRPI_REGISTRATION_POLICY);+    }++    public void setdrpiRegistrationPolicy(String mdrpiRegistrationPolicy) {+        getConfig().put(MDRPI_REGISTRATION_POLICY, mdrpiRegistrationPolicy);+    }++    public String getConfigMduiDisplayName() {+        return getConfig().get(MDUI_DISPLAY_NAME);+    }++    public void setConfigMduiDisplayName(String mduiDisplayName) {+        getConfig().put(MDUI_DISPLAY_NAME, mduiDisplayName);+    }++    public String getMduiDescription() {+        return getConfig().get(MDUI_DESCRIPTION);+    }++    public void setMduiDescription(String mduiDescription) {+        getConfig().put(MDUI_DESCRIPTION, mduiDescription);+    }++    public String getMduiInformationURL() {+        return getConfig().get(MDUI_INFORMATION_URL);+    }++    public void setMduiInformationURL(String mduiInformationURL) {+        getConfig().put(MDUI_INFORMATION_URL, mduiInformationURL);+    }++    public String getMduiPrivacyStatementURL() {+        return getConfig().get(MDUI_PRIVACY_STATEMENT_URL);+    }++    public void setMduiPrivacyStatementURL(String mduiPrivacyStatementURL) {+        getConfig().put(MDUI_PRIVACY_STATEMENT_URL, mduiPrivacyStatementURL);+    }++    public String getMduiLogo() {+        return getConfig().get(MDUI_LOGO);+    }++    public void setMduiLogo(String mduiLogo) {+        getConfig().put(MDUI_LOGO, mduiLogo);+    }++    public Integer getMduiLogoHeight() {+        return getConfig().get(MDUI_LOGO_HEIGHT) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_HEIGHT));+    }++    public void setMduiLogoHeight(Integer mduiLogoHeight) {+        getConfig().put(MDUI_LOGO_HEIGHT, String.valueOf(mduiLogoHeight));+    }++    public Integer getMduiLogoWidth() {+        return getConfig().get(MDUI_LOGO_WIDTH) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_WIDTH));+    }++    public void setMduiLogoWidth(Integer mduiLogoWidth) {+        getConfig().put(MDUI_LOGO_WIDTH, String.valueOf(mduiLogoWidth));+    }++    public String getMdOrganizationName() {+        return getConfig().get(MD_ORGANIZATION_NAME);+    }++    public void setMdOrganizationName(String mdOrganizationName) {+        getConfig().put(MD_ORGANIZATION_NAME, mdOrganizationName);+    }++    public String getMdOrganizationDisplayName() {+        return getConfig().get(MD_ORGANIZATION_DISPLAY_NAME);+    }++    public void setMdOrganizationDisplayName(String mdOrganizationDisplayName) {+        getConfig().put(MD_ORGANIZATION_DISPLAY_NAME, mdOrganizationDisplayName);+    }++    public String getMdOrganizationURL() {+        return getConfig().get(MD_ORGANIZATION_URL);+    }++    public void setMdOrganizationURL(String mdOrganizationURL) {+        getConfig().put(MD_ORGANIZATION_URL, mdOrganizationURL);+    }++    public String getMdContactType() {+        return getConfig().get(MD_CONTACT_TYPE);+    }++    public void setMdContactType(String mdContactType) {+        getConfig().put(MD_CONTACT_TYPE, mdContactType);+    }++    public String getMdContactCompany() {+        return getConfig().get(MD_CONTACT_COMPANY);+    }++    public void setMdContactCompany(String mdContactCompany) {+        getConfig().put(MD_CONTACT_COMPANY, mdContactCompany);+    }++    public String getMdContactGivenName() {+        return getConfig().get(MD_CONTACT_GIVEN_NAME);+    }++    public void setMdContactGivenName(String mdContactGivenName) {+        getConfig().put(MD_CONTACT_GIVEN_NAME, mdContactGivenName);+    }++    public String getMdContactSurname() {+        return getConfig().get(MD_CONTACT_SURNAME);+    }++    public void setMdContactSurname(String mdContactSurname) {+        getConfig().put(MD_CONTACT_SURNAME, mdContactSurname);+    }++    public String getMdContactEmailAddress() {+        return getConfig().get(MD_CONTACT_EMAIL_ADDRESS);+    }++    public void setMdContactEmailAddress(String mdContactEmailAddress) {+        getConfig().put(MD_CONTACT_EMAIL_ADDRESS, mdContactEmailAddress);","Model should use the `List` for list parameters. Conversion to `String` needs to happen when obtaining / storing the value from / to the `getConfig()` map.Use `JsonSerialization` to properly serialize list attributes.This applies to MdContactTelephoneNumber just the same.```suggestion    public void setMdContactEmailAddress(List<String> mdContactEmailAddress) {        getConfig().put(MD_CONTACT_EMAIL_ADDRESS, JsonSerialization.serialize(mdContactEmailAddress));```",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7176,510671402,2020-10-23T06:52:28Z,services/src/main/java/org/keycloak/authentication/requiredactions/DeleteAccount.java,"@@ -0,0 +1,172 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.authentication.InitiatedActionSupport;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionFactory;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserManager;+import org.keycloak.models.UserModel;+import org.keycloak.services.ForbiddenException;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.messages.Messages;++public class DeleteAccount implements RequiredActionProvider, RequiredActionFactory {",> So I would update to not show the delete button as then it's consistent with other actions.@stianst You mean hide the Cancel button unless it's AIA?,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7470,510807116,2020-10-23T11:04:18Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -1,4 +1,4 @@-<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false displayWide=false showAnotherWayIfPresent=true>+<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false showAnotherWayIfPresent=true> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""  ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">","If this PR works correctly with IE, there won't be error with another screens. PF3 and PF4 work simultaneously, so some of the additional PRs don't have to be merged, if they have some issue with IE yet. The additional PRs only upgrade the components, which look, in most cases, very similar. This PR will work with IE, and I think, it's sufficient so far. So there won't be any follow-up task for IE workaround. Everything will be included in each PR.",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7442,510824428,2020-10-23T11:41:36Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -335,11 +362,169 @@ public void setSignSpMetadata(boolean signSpMetadata) {         getConfig().put(SIGN_SP_METADATA, String.valueOf(signSpMetadata));     } +    public String getSamlAttributes() throws IOException {+        return getConfig().get(SAML_ATTRIBUTES) ;+    }++    public void setSamlAttributes(String attributes) throws IOException {+        getConfig().put(SAML_ATTRIBUTES, attributes);+    }++    public String getdrpiRegistrationAuthority() {+        return getConfig().get(MDRPI_REGISTRATION_AUTHORITY);+    }++    public void setdrpiRegistrationAuthority(String mdrpiRegistrationAuthority) {+        getConfig().put(MDRPI_REGISTRATION_AUTHORITY, mdrpiRegistrationAuthority);+    }++    public String getdrpiRegistrationPolicy() {+        return getConfig().get(MDRPI_REGISTRATION_POLICY);+    }++    public void setdrpiRegistrationPolicy(String mdrpiRegistrationPolicy) {+        getConfig().put(MDRPI_REGISTRATION_POLICY, mdrpiRegistrationPolicy);+    }++    public String getConfigMduiDisplayName() {+        return getConfig().get(MDUI_DISPLAY_NAME);+    }++    public void setConfigMduiDisplayName(String mduiDisplayName) {+        getConfig().put(MDUI_DISPLAY_NAME, mduiDisplayName);+    }++    public String getMduiDescription() {+        return getConfig().get(MDUI_DESCRIPTION);+    }++    public void setMduiDescription(String mduiDescription) {+        getConfig().put(MDUI_DESCRIPTION, mduiDescription);+    }++    public String getMduiInformationURL() {+        return getConfig().get(MDUI_INFORMATION_URL);+    }++    public void setMduiInformationURL(String mduiInformationURL) {+        getConfig().put(MDUI_INFORMATION_URL, mduiInformationURL);+    }++    public String getMduiPrivacyStatementURL() {+        return getConfig().get(MDUI_PRIVACY_STATEMENT_URL);+    }++    public void setMduiPrivacyStatementURL(String mduiPrivacyStatementURL) {+        getConfig().put(MDUI_PRIVACY_STATEMENT_URL, mduiPrivacyStatementURL);+    }++    public String getMduiLogo() {+        return getConfig().get(MDUI_LOGO);+    }++    public void setMduiLogo(String mduiLogo) {+        getConfig().put(MDUI_LOGO, mduiLogo);+    }++    public Integer getMduiLogoHeight() {+        return getConfig().get(MDUI_LOGO_HEIGHT) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_HEIGHT));+    }++    public void setMduiLogoHeight(Integer mduiLogoHeight) {+        getConfig().put(MDUI_LOGO_HEIGHT, String.valueOf(mduiLogoHeight));+    }++    public Integer getMduiLogoWidth() {+        return getConfig().get(MDUI_LOGO_WIDTH) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_WIDTH));+    }++    public void setMduiLogoWidth(Integer mduiLogoWidth) {+        getConfig().put(MDUI_LOGO_WIDTH, String.valueOf(mduiLogoWidth));+    }++    public String getMdOrganizationName() {+        return getConfig().get(MD_ORGANIZATION_NAME);+    }++    public void setMdOrganizationName(String mdOrganizationName) {+        getConfig().put(MD_ORGANIZATION_NAME, mdOrganizationName);+    }++    public String getMdOrganizationDisplayName() {+        return getConfig().get(MD_ORGANIZATION_DISPLAY_NAME);+    }++    public void setMdOrganizationDisplayName(String mdOrganizationDisplayName) {+        getConfig().put(MD_ORGANIZATION_DISPLAY_NAME, mdOrganizationDisplayName);+    }++    public String getMdOrganizationURL() {+        return getConfig().get(MD_ORGANIZATION_URL);+    }++    public void setMdOrganizationURL(String mdOrganizationURL) {+        getConfig().put(MD_ORGANIZATION_URL, mdOrganizationURL);+    }++    public String getMdContactType() {+        return getConfig().get(MD_CONTACT_TYPE);+    }++    public void setMdContactType(String mdContactType) {+        getConfig().put(MD_CONTACT_TYPE, mdContactType);+    }++    public String getMdContactCompany() {+        return getConfig().get(MD_CONTACT_COMPANY);+    }++    public void setMdContactCompany(String mdContactCompany) {+        getConfig().put(MD_CONTACT_COMPANY, mdContactCompany);+    }++    public String getMdContactGivenName() {+        return getConfig().get(MD_CONTACT_GIVEN_NAME);+    }++    public void setMdContactGivenName(String mdContactGivenName) {+        getConfig().put(MD_CONTACT_GIVEN_NAME, mdContactGivenName);+    }++    public String getMdContactSurname() {+        return getConfig().get(MD_CONTACT_SURNAME);+    }++    public void setMdContactSurname(String mdContactSurname) {+        getConfig().put(MD_CONTACT_SURNAME, mdContactSurname);+    }++    public String getMdContactEmailAddress() {+        return getConfig().get(MD_CONTACT_EMAIL_ADDRESS);+    }++    public void setMdContactEmailAddress(String mdContactEmailAddress) {+        getConfig().put(MD_CONTACT_EMAIL_ADDRESS, mdContactEmailAddress);","How will this be implemented in ui taking into account that config in IdentityProviderRepresentation is Map<String,String>? User should not edit json.That's why I concat list to String with comma seperator.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7470,510889109,2020-10-23T13:37:16Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -1,4 +1,4 @@-<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false displayWide=false showAnotherWayIfPresent=true>+<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false showAnotherWayIfPresent=true> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""  ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">","@Pepo48 @mabartos From my PoV it feels kinda broken in IE. Just compare the following screenshots (left is PF3 in IE, right PF4 in IE):![image](https://user-images.githubusercontent.com/13906855/97010006-21dd2580-1545-11eb-99e7-3f348548e0c4.png)![image-2](https://user-images.githubusercontent.com/13906855/97010010-23a6e900-1545-11eb-9ed1-b4e8f5718bd1.png)Notice the input fields which I think are missing some padding, notification looks akward. And it's possible there'll be some more broken components. I think it's definitely a downgrade in UX for IE users.But I don't want to block this so I'll leave the decision to others if this is good enough or not.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7442,511064024,2020-10-23T18:27:04Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -335,11 +362,169 @@ public void setSignSpMetadata(boolean signSpMetadata) {         getConfig().put(SIGN_SP_METADATA, String.valueOf(signSpMetadata));     } +    public String getSamlAttributes() throws IOException {+        return getConfig().get(SAML_ATTRIBUTES) ;+    }++    public void setSamlAttributes(String attributes) throws IOException {+        getConfig().put(SAML_ATTRIBUTES, attributes);+    }++    public String getdrpiRegistrationAuthority() {+        return getConfig().get(MDRPI_REGISTRATION_AUTHORITY);+    }++    public void setdrpiRegistrationAuthority(String mdrpiRegistrationAuthority) {+        getConfig().put(MDRPI_REGISTRATION_AUTHORITY, mdrpiRegistrationAuthority);+    }++    public String getdrpiRegistrationPolicy() {+        return getConfig().get(MDRPI_REGISTRATION_POLICY);+    }++    public void setdrpiRegistrationPolicy(String mdrpiRegistrationPolicy) {+        getConfig().put(MDRPI_REGISTRATION_POLICY, mdrpiRegistrationPolicy);+    }++    public String getConfigMduiDisplayName() {+        return getConfig().get(MDUI_DISPLAY_NAME);+    }++    public void setConfigMduiDisplayName(String mduiDisplayName) {+        getConfig().put(MDUI_DISPLAY_NAME, mduiDisplayName);+    }++    public String getMduiDescription() {+        return getConfig().get(MDUI_DESCRIPTION);+    }++    public void setMduiDescription(String mduiDescription) {+        getConfig().put(MDUI_DESCRIPTION, mduiDescription);+    }++    public String getMduiInformationURL() {+        return getConfig().get(MDUI_INFORMATION_URL);+    }++    public void setMduiInformationURL(String mduiInformationURL) {+        getConfig().put(MDUI_INFORMATION_URL, mduiInformationURL);+    }++    public String getMduiPrivacyStatementURL() {+        return getConfig().get(MDUI_PRIVACY_STATEMENT_URL);+    }++    public void setMduiPrivacyStatementURL(String mduiPrivacyStatementURL) {+        getConfig().put(MDUI_PRIVACY_STATEMENT_URL, mduiPrivacyStatementURL);+    }++    public String getMduiLogo() {+        return getConfig().get(MDUI_LOGO);+    }++    public void setMduiLogo(String mduiLogo) {+        getConfig().put(MDUI_LOGO, mduiLogo);+    }++    public Integer getMduiLogoHeight() {+        return getConfig().get(MDUI_LOGO_HEIGHT) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_HEIGHT));+    }++    public void setMduiLogoHeight(Integer mduiLogoHeight) {+        getConfig().put(MDUI_LOGO_HEIGHT, String.valueOf(mduiLogoHeight));+    }++    public Integer getMduiLogoWidth() {+        return getConfig().get(MDUI_LOGO_WIDTH) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_WIDTH));+    }++    public void setMduiLogoWidth(Integer mduiLogoWidth) {+        getConfig().put(MDUI_LOGO_WIDTH, String.valueOf(mduiLogoWidth));+    }++    public String getMdOrganizationName() {+        return getConfig().get(MD_ORGANIZATION_NAME);+    }++    public void setMdOrganizationName(String mdOrganizationName) {+        getConfig().put(MD_ORGANIZATION_NAME, mdOrganizationName);+    }++    public String getMdOrganizationDisplayName() {+        return getConfig().get(MD_ORGANIZATION_DISPLAY_NAME);+    }++    public void setMdOrganizationDisplayName(String mdOrganizationDisplayName) {+        getConfig().put(MD_ORGANIZATION_DISPLAY_NAME, mdOrganizationDisplayName);+    }++    public String getMdOrganizationURL() {+        return getConfig().get(MD_ORGANIZATION_URL);+    }++    public void setMdOrganizationURL(String mdOrganizationURL) {+        getConfig().put(MD_ORGANIZATION_URL, mdOrganizationURL);+    }++    public String getMdContactType() {+        return getConfig().get(MD_CONTACT_TYPE);+    }++    public void setMdContactType(String mdContactType) {+        getConfig().put(MD_CONTACT_TYPE, mdContactType);+    }++    public String getMdContactCompany() {+        return getConfig().get(MD_CONTACT_COMPANY);+    }++    public void setMdContactCompany(String mdContactCompany) {+        getConfig().put(MD_CONTACT_COMPANY, mdContactCompany);+    }++    public String getMdContactGivenName() {+        return getConfig().get(MD_CONTACT_GIVEN_NAME);+    }++    public void setMdContactGivenName(String mdContactGivenName) {+        getConfig().put(MD_CONTACT_GIVEN_NAME, mdContactGivenName);+    }++    public String getMdContactSurname() {+        return getConfig().get(MD_CONTACT_SURNAME);+    }++    public void setMdContactSurname(String mdContactSurname) {+        getConfig().put(MD_CONTACT_SURNAME, mdContactSurname);+    }++    public String getMdContactEmailAddress() {+        return getConfig().get(MD_CONTACT_EMAIL_ADDRESS);+    }++    public void setMdContactEmailAddress(String mdContactEmailAddress) {+        getConfig().put(MD_CONTACT_EMAIL_ADDRESS, mdContactEmailAddress);","Joining the attributes or even assuming that they are serializable to `String` is a wrong assumption. Let me reiterate:> The way it is now completely ignores information about the attribute dataformat, and relies on uncertain fact that the attributes are of string type.You need to introduce a SPI that would handle custom attributes. That way you can have the geant and other plugged in.I agree that there is no expectation that user would edit JSON. How that is propagated to UI depends on how the SPI is designed, but can and has to be done purely in the SPI. Note that SPI can provide its partials which are then dynamically included in the UI (see `ng-include`), it can interact with UI via REST endpoints etc.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7524,511896260,2020-10-26T11:38:22Z,server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java,"@@ -160,6 +160,11 @@ public String getFirstAttribute(String name) {         return value;     } +    @Override",You kept the original deprecated method on purpose?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7444,511911311,2020-10-26T12:07:29Z,model/jpa/src/main/java/org/keycloak/models/jpa/RoleAdapter.java,"@@ -214,7 +201,7 @@ public int hashCode() {         return getId().hashCode();     } -    public static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {+    private RoleEntity toRoleEntity(RoleModel model, EntityManager em) {",We can remove EntityManager parameter since it is not static anymore.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7444,511935983,2020-10-26T12:52:52Z,model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java,"@@ -0,0 +1,361 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.role;++import org.jboss.logging.Logger;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;++import org.keycloak.models.RoleModel;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.common.Serialization;+import java.util.Comparator;+import java.util.Objects;+import java.util.UUID;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.models.map.storage.MapStorage;+import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import org.keycloak.models.RoleContainerModel;+import org.keycloak.models.RoleProvider;+import org.keycloak.models.map.common.StreamUtils;++public class MapRoleProvider implements RoleProvider {++    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };+    private final KeycloakSession session;+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;+    private final MapStorage<UUID, MapRoleEntity> roleStore;++    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {+        @Override+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {+            String r1 = o1 == null ? null : o1.getName();+            String r2 = o2 == null ? null : o2.getName();+            return r1 == r2 ? 0+              : r1 == null ? -1+              : r2 == null ? 1+              : r1.compareTo(r2);++        }+    };++    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {+        this.session = session;+        this.roleStore = roleStore;+        this.tx = new MapKeycloakTransaction<>(roleStore);+        session.getTransactionManager().enlist(tx);+    }++    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller++        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {+        final MapRoleEntity res = Serialization.from(origEntity);+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);+        return res;+    }++    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {+        if (realm == null || realm.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String realmId = realm.getId();+        return entity -> Objects.equals(realmId, entity.getRealmId());+    }++    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {+        if (client == null || client.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String clientId = client.getId();+        return entity -> entity.isClientRole() && +                Objects.equals(clientId, entity.getClientId());+    }++    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()+          .filter(Objects::nonNull);+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);+    }++    @Override+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {+        if (getRealmRole(realm, name) != null) {+            throw new ModelDuplicateException();",Missing exception message.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7444,511936045,2020-10-26T12:53:01Z,model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java,"@@ -0,0 +1,361 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.role;++import org.jboss.logging.Logger;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;++import org.keycloak.models.RoleModel;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.common.Serialization;+import java.util.Comparator;+import java.util.Objects;+import java.util.UUID;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.models.map.storage.MapStorage;+import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import org.keycloak.models.RoleContainerModel;+import org.keycloak.models.RoleProvider;+import org.keycloak.models.map.common.StreamUtils;++public class MapRoleProvider implements RoleProvider {++    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };+    private final KeycloakSession session;+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;+    private final MapStorage<UUID, MapRoleEntity> roleStore;++    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {+        @Override+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {+            String r1 = o1 == null ? null : o1.getName();+            String r2 = o2 == null ? null : o2.getName();+            return r1 == r2 ? 0+              : r1 == null ? -1+              : r2 == null ? 1+              : r1.compareTo(r2);++        }+    };++    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {+        this.session = session;+        this.roleStore = roleStore;+        this.tx = new MapKeycloakTransaction<>(roleStore);+        session.getTransactionManager().enlist(tx);+    }++    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller++        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {+        final MapRoleEntity res = Serialization.from(origEntity);+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);+        return res;+    }++    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {+        if (realm == null || realm.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String realmId = realm.getId();+        return entity -> Objects.equals(realmId, entity.getRealmId());+    }++    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {+        if (client == null || client.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String clientId = client.getId();+        return entity -> entity.isClientRole() && +                Objects.equals(clientId, entity.getClientId());+    }++    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()+          .filter(Objects::nonNull);+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);+    }++    @Override+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {+        if (getRealmRole(realm, name) != null) {+            throw new ModelDuplicateException();+        }++        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""addRealmRole(%s, %s, %s)%s"", realm.getName(), id, name, getShortStackTrace());++        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());+        entity.setName(name);+        entity.setRealmId(realm.getId());+        if (tx.get(entity.getId(), roleStore::get) != null) {+            throw new ModelDuplicateException(""Role exists: "" + id);+        }+        tx.putIfAbsent(entity.getId(), entity);+        return entityToAdapterFunc(realm).apply(entity);+    }++    @Override+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {+        Stream<RoleModel> s = getRealmRolesStream(realm);+        if (first != null && first >= 0) {+            s = s.skip(first);+        }+        if (max != null && max >= 0) {+            s = s.limit(max);+        }+        return s;+    }++    @Override+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {+        return getNotRemovedUpdatedRolesStream()+                .filter(entityRealmFilter(realm))+                .filter(this::isRealmRole)+                .sorted(COMPARE_BY_NAME)+                .map(entityToAdapterFunc(realm));+    }++    private boolean isRealmRole(MapRoleEntity role) {+        return ! role.isClientRole();+    }++    @Override+    public RoleModel addClientRole(ClientModel client, String id, String name) {+        if (getClientRole(client, name) != null) {+            throw new ModelDuplicateException();",Missing exception message.,
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7442,511941415,2020-10-26T13:02:09Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -335,11 +362,169 @@ public void setSignSpMetadata(boolean signSpMetadata) {         getConfig().put(SIGN_SP_METADATA, String.valueOf(signSpMetadata));     } +    public String getSamlAttributes() throws IOException {+        return getConfig().get(SAML_ATTRIBUTES) ;+    }++    public void setSamlAttributes(String attributes) throws IOException {+        getConfig().put(SAML_ATTRIBUTES, attributes);+    }++    public String getdrpiRegistrationAuthority() {+        return getConfig().get(MDRPI_REGISTRATION_AUTHORITY);+    }++    public void setdrpiRegistrationAuthority(String mdrpiRegistrationAuthority) {+        getConfig().put(MDRPI_REGISTRATION_AUTHORITY, mdrpiRegistrationAuthority);+    }++    public String getdrpiRegistrationPolicy() {+        return getConfig().get(MDRPI_REGISTRATION_POLICY);+    }++    public void setdrpiRegistrationPolicy(String mdrpiRegistrationPolicy) {+        getConfig().put(MDRPI_REGISTRATION_POLICY, mdrpiRegistrationPolicy);+    }++    public String getConfigMduiDisplayName() {+        return getConfig().get(MDUI_DISPLAY_NAME);+    }++    public void setConfigMduiDisplayName(String mduiDisplayName) {+        getConfig().put(MDUI_DISPLAY_NAME, mduiDisplayName);+    }++    public String getMduiDescription() {+        return getConfig().get(MDUI_DESCRIPTION);+    }++    public void setMduiDescription(String mduiDescription) {+        getConfig().put(MDUI_DESCRIPTION, mduiDescription);+    }++    public String getMduiInformationURL() {+        return getConfig().get(MDUI_INFORMATION_URL);+    }++    public void setMduiInformationURL(String mduiInformationURL) {+        getConfig().put(MDUI_INFORMATION_URL, mduiInformationURL);+    }++    public String getMduiPrivacyStatementURL() {+        return getConfig().get(MDUI_PRIVACY_STATEMENT_URL);+    }++    public void setMduiPrivacyStatementURL(String mduiPrivacyStatementURL) {+        getConfig().put(MDUI_PRIVACY_STATEMENT_URL, mduiPrivacyStatementURL);+    }++    public String getMduiLogo() {+        return getConfig().get(MDUI_LOGO);+    }++    public void setMduiLogo(String mduiLogo) {+        getConfig().put(MDUI_LOGO, mduiLogo);+    }++    public Integer getMduiLogoHeight() {+        return getConfig().get(MDUI_LOGO_HEIGHT) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_HEIGHT));+    }++    public void setMduiLogoHeight(Integer mduiLogoHeight) {+        getConfig().put(MDUI_LOGO_HEIGHT, String.valueOf(mduiLogoHeight));+    }++    public Integer getMduiLogoWidth() {+        return getConfig().get(MDUI_LOGO_WIDTH) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_WIDTH));+    }++    public void setMduiLogoWidth(Integer mduiLogoWidth) {+        getConfig().put(MDUI_LOGO_WIDTH, String.valueOf(mduiLogoWidth));+    }++    public String getMdOrganizationName() {+        return getConfig().get(MD_ORGANIZATION_NAME);+    }++    public void setMdOrganizationName(String mdOrganizationName) {+        getConfig().put(MD_ORGANIZATION_NAME, mdOrganizationName);+    }++    public String getMdOrganizationDisplayName() {+        return getConfig().get(MD_ORGANIZATION_DISPLAY_NAME);+    }++    public void setMdOrganizationDisplayName(String mdOrganizationDisplayName) {+        getConfig().put(MD_ORGANIZATION_DISPLAY_NAME, mdOrganizationDisplayName);+    }++    public String getMdOrganizationURL() {+        return getConfig().get(MD_ORGANIZATION_URL);+    }++    public void setMdOrganizationURL(String mdOrganizationURL) {+        getConfig().put(MD_ORGANIZATION_URL, mdOrganizationURL);+    }++    public String getMdContactType() {+        return getConfig().get(MD_CONTACT_TYPE);+    }++    public void setMdContactType(String mdContactType) {+        getConfig().put(MD_CONTACT_TYPE, mdContactType);+    }++    public String getMdContactCompany() {+        return getConfig().get(MD_CONTACT_COMPANY);+    }++    public void setMdContactCompany(String mdContactCompany) {+        getConfig().put(MD_CONTACT_COMPANY, mdContactCompany);+    }++    public String getMdContactGivenName() {+        return getConfig().get(MD_CONTACT_GIVEN_NAME);+    }++    public void setMdContactGivenName(String mdContactGivenName) {+        getConfig().put(MD_CONTACT_GIVEN_NAME, mdContactGivenName);+    }++    public String getMdContactSurname() {+        return getConfig().get(MD_CONTACT_SURNAME);+    }++    public void setMdContactSurname(String mdContactSurname) {+        getConfig().put(MD_CONTACT_SURNAME, mdContactSurname);+    }++    public String getMdContactEmailAddress() {+        return getConfig().get(MD_CONTACT_EMAIL_ADDRESS);+    }++    public void setMdContactEmailAddress(String mdContactEmailAddress) {+        getConfig().put(MD_CONTACT_EMAIL_ADDRESS, mdContactEmailAddress);","Here, I am not refereing to attributes and proposed SPI solution. md:EmailAddress and md:TelephoneNumber are List<String> as you can see in [documentation](https://docs.oasis-open.org/security/saml/v2.0/saml-metadata-2.0-os.pdf) and in Keycloak code. In my last commit, I propose a solution based on your comment.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7444,511945109,2020-10-26T13:08:37Z,model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java,"@@ -0,0 +1,361 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.role;++import org.jboss.logging.Logger;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;++import org.keycloak.models.RoleModel;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.common.Serialization;+import java.util.Comparator;+import java.util.Objects;+import java.util.UUID;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.models.map.storage.MapStorage;+import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import org.keycloak.models.RoleContainerModel;+import org.keycloak.models.RoleProvider;+import org.keycloak.models.map.common.StreamUtils;++public class MapRoleProvider implements RoleProvider {++    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };+    private final KeycloakSession session;+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;+    private final MapStorage<UUID, MapRoleEntity> roleStore;++    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {+        @Override+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {+            String r1 = o1 == null ? null : o1.getName();+            String r2 = o2 == null ? null : o2.getName();+            return r1 == r2 ? 0+              : r1 == null ? -1+              : r2 == null ? 1+              : r1.compareTo(r2);++        }+    };++    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {+        this.session = session;+        this.roleStore = roleStore;+        this.tx = new MapKeycloakTransaction<>(roleStore);+        session.getTransactionManager().enlist(tx);+    }++    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller++        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {+        final MapRoleEntity res = Serialization.from(origEntity);+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);+        return res;+    }++    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {+        if (realm == null || realm.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String realmId = realm.getId();+        return entity -> Objects.equals(realmId, entity.getRealmId());+    }++    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {+        if (client == null || client.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String clientId = client.getId();+        return entity -> entity.isClientRole() && +                Objects.equals(clientId, entity.getClientId());+    }++    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()+          .filter(Objects::nonNull);+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);+    }++    @Override+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {+        if (getRealmRole(realm, name) != null) {+            throw new ModelDuplicateException();+        }++        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""addRealmRole(%s, %s, %s)%s"", realm.getName(), id, name, getShortStackTrace());++        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());+        entity.setName(name);+        entity.setRealmId(realm.getId());+        if (tx.get(entity.getId(), roleStore::get) != null) {+            throw new ModelDuplicateException(""Role exists: "" + id);+        }+        tx.putIfAbsent(entity.getId(), entity);+        return entityToAdapterFunc(realm).apply(entity);+    }++    @Override+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {+        Stream<RoleModel> s = getRealmRolesStream(realm);+        if (first != null && first >= 0) {+            s = s.skip(first);+        }+        if (max != null && max >= 0) {+            s = s.limit(max);+        }+        return s;+    }++    @Override+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {+        return getNotRemovedUpdatedRolesStream()+                .filter(entityRealmFilter(realm))+                .filter(this::isRealmRole)+                .sorted(COMPARE_BY_NAME)+                .map(entityToAdapterFunc(realm));+    }++    private boolean isRealmRole(MapRoleEntity role) {+        return ! role.isClientRole();+    }++    @Override+    public RoleModel addClientRole(ClientModel client, String id, String name) {+        if (getClientRole(client, name) != null) {+            throw new ModelDuplicateException();+        }++        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""addClientRole(%s, %s, %s)%s"", client.getClientId(), id, name, getShortStackTrace());++        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());+        entity.setName(name);+        entity.setClientRole(true);+        entity.setClientId(client.getId());+        if (tx.get(entity.getId(), roleStore::get) != null) {+            throw new ModelDuplicateException(""Role exists: "" + id);+        }+        tx.putIfAbsent(entity.getId(), entity);+        return entityToAdapterFunc(client.getRealm()).apply(entity);+    }++    @Override+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {+        Stream<RoleModel> s = getClientRolesStream(client);+        if (first != null && first > 0) {+            s = s.skip(first);+        }+        if (max != null && max >= 0) {+            s = s.limit(max);+        }+        return s;+    }++    @Override+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {+        return getNotRemovedUpdatedRolesStream()+                .filter(entityRealmFilter(client.getRealm()))+                .filter(entityClientFilter(client))+                .sorted(COMPARE_BY_NAME)+                .map(entityToAdapterFunc(client.getRealm()));+    }+    @Override+    public boolean removeRole(RoleModel role) {+        LOG.tracef(""removeRole(%s(%s))%s"", role.getName(), role.getId(), getShortStackTrace());++        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();++        session.users().preRemove(realm, role);++        RoleContainerModel container = role.getContainer();+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {+            container.removeDefaultRoles(role.getName());+        }++        //remove role from realm-roles composites+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {","Should we create `RoleModel` for each entity? We can work with entities and then turn to model only those that need to be updated (so that we add entities to transaction). Or we can maybe get rid of models here completely and work with entities only. Because if I see correctly, the MapRoleAdapter just call an operation on the entity. WDYT? @hmlnarik Maybe you could have also something to say to this.I am asking also because I am doing something similar for users, so if it is incorrect I need to make few changes.",
6265563,zak905,https://api.github.com/repos/keycloak/keycloak/pulls/7176,512012538,2020-10-26T14:41:01Z,services/src/main/java/org/keycloak/authentication/requiredactions/DeleteAccount.java,"@@ -0,0 +1,172 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.requiredactions;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.authentication.InitiatedActionSupport;+import org.keycloak.authentication.RequiredActionContext;+import org.keycloak.authentication.RequiredActionFactory;+import org.keycloak.authentication.RequiredActionProvider;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserManager;+import org.keycloak.models.UserModel;+import org.keycloak.services.ForbiddenException;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.messages.Messages;++public class DeleteAccount implements RequiredActionProvider, RequiredActionFactory {","Good catch. If I remember well, we discussed this on the mailing list. Maybe it would make sens in the future to have AIA only actions. As a workaround now, I just added a check for `context.getAuthenticationSession().getClientNote(Constants.KC_ACTION)`, if is set to `delete_action`, then I display the cancel button, otherwise just the confirm button alone. ",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7524,512079416,2020-10-26T16:05:20Z,server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java,"@@ -160,6 +160,11 @@ public String getFirstAttribute(String name) {         return value;     } +    @Override","No, that was definitely a brain fart :)",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7470,512123193,2020-10-26T17:01:29Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -1,4 +1,4 @@-<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false displayWide=false showAnotherWayIfPresent=true>+<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false showAnotherWayIfPresent=true> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""  ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">","@vmuzikar Thanks for your review. I know, there is some issue with register alert (some alert with longer message). But in the follow-up task with registration, there won't be this alert, but the errors will be under the inputs. Otherwise, the simple alert looks almost normal. What about edit these minor changes in follow-up task, which I'm currently working on in order to not block other PRs, which depend on this PR?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7524,512274520,2020-10-26T21:18:27Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java,"@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {             }         } -        List<UserModel> searchResults =new LinkedList<UserModel>();-         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);-        int counter = 0;-        for (LDAPObject ldapUser : ldapUsers) {-            if (counter++ < firstResult) continue;-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);-                searchResults.add(imported);-            }-        }--        return searchResults;+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));     }      @Override-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);     }      @Override-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())-                .sorted(ldapMappersComparator.sortAsc())-                .collect(Collectors.toList());--        for (ComponentModel mapperModel : sortedMappers) {-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);--            // Sufficient for now-            if (users.size() > 0) {-                return users;-            }-        }-        return Collections.emptyList();+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())+            .sorted(ldapMappersComparator.sortAsc())+            .map(mapperModel ->+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))+            .filter(list -> list.size() > 0)+            .findFirst().orElse(null);+        return users == null ? Stream.empty() : users.stream();",Prefer `list.isEmpty()` to `list.size()` where possible. The former is simple check while the latter may need to enumerate the items e.g. in case of `LinkedList`,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7524,512482069,2020-10-27T08:02:59Z,services/src/main/java/org/keycloak/storage/UserStorageManager.java,"@@ -608,14 +600,13 @@ public UserModel getServiceAccount(ClientModel client) {     }      @Override-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {         if (user == null) throw new IllegalStateException(""Federated user no longer valid"");-        Set<FederatedIdentityModel> set = new HashSet<>();-        if (StorageId.isLocalStorage(user)) {-            set.addAll(localStorage().getFederatedIdentities(user, realm));-        }-        if (getFederatedStorage() != null) set.addAll(getFederatedStorage().getFederatedIdentities(user.getId(), realm));-        return set;+        Stream<FederatedIdentityModel> stream = StorageId.isLocalStorage(user) ?+                localStorage().getFederatedIdentitiesStream(user, realm) : Stream.empty();+        if (getFederatedStorage() != null)+            stream = Streams.concat(stream, getFederatedStorage().getFederatedIdentitiesStream(user.getId(), realm));","Well, this is a good question. However, I don't think we should. The federatedStorage is something little bit confusing, I spent quite a lot of time on investigating what is it for. If I understand correctly, this is the point: if you have some users, from external storage/provider and you are not able to store some keycloak specific properties (attributes, roles, groups etc.) in that external storage, you can configure keycloak to store it for you using this federatedStorage. For example you store a user with id `id_pointing_to_external_storage` have roles `admin` and `manager`. So whenever there is a call to federatedStorage for `FederatedIdentityModel`, it should be a call to a database/map storage (in future). See current [jpa implementation](https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java).Therefore, If we would time bound federated storage, the same logic would apply also to `localStorage()` and I don't like this idea. WDYT? ",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7470,512523609,2020-10-27T09:11:27Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -1,4 +1,4 @@-<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false displayWide=false showAnotherWayIfPresent=true>+<#macro registrationLayout bodyClass="""" displayInfo=false displayMessage=true displayRequiredFields=false showAnotherWayIfPresent=true> <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""  ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">","I think the misaligned notification icons affect all notifications, not just alerts with a longer message. It's apparent on your screenshot above too.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7442,512525975,2020-10-27T09:15:13Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -335,11 +362,169 @@ public void setSignSpMetadata(boolean signSpMetadata) {         getConfig().put(SIGN_SP_METADATA, String.valueOf(signSpMetadata));     } +    public String getSamlAttributes() throws IOException {+        return getConfig().get(SAML_ATTRIBUTES) ;+    }++    public void setSamlAttributes(String attributes) throws IOException {+        getConfig().put(SAML_ATTRIBUTES, attributes);+    }++    public String getdrpiRegistrationAuthority() {+        return getConfig().get(MDRPI_REGISTRATION_AUTHORITY);+    }++    public void setdrpiRegistrationAuthority(String mdrpiRegistrationAuthority) {+        getConfig().put(MDRPI_REGISTRATION_AUTHORITY, mdrpiRegistrationAuthority);+    }++    public String getdrpiRegistrationPolicy() {+        return getConfig().get(MDRPI_REGISTRATION_POLICY);+    }++    public void setdrpiRegistrationPolicy(String mdrpiRegistrationPolicy) {+        getConfig().put(MDRPI_REGISTRATION_POLICY, mdrpiRegistrationPolicy);+    }++    public String getConfigMduiDisplayName() {+        return getConfig().get(MDUI_DISPLAY_NAME);+    }++    public void setConfigMduiDisplayName(String mduiDisplayName) {+        getConfig().put(MDUI_DISPLAY_NAME, mduiDisplayName);+    }++    public String getMduiDescription() {+        return getConfig().get(MDUI_DESCRIPTION);+    }++    public void setMduiDescription(String mduiDescription) {+        getConfig().put(MDUI_DESCRIPTION, mduiDescription);+    }++    public String getMduiInformationURL() {+        return getConfig().get(MDUI_INFORMATION_URL);+    }++    public void setMduiInformationURL(String mduiInformationURL) {+        getConfig().put(MDUI_INFORMATION_URL, mduiInformationURL);+    }++    public String getMduiPrivacyStatementURL() {+        return getConfig().get(MDUI_PRIVACY_STATEMENT_URL);+    }++    public void setMduiPrivacyStatementURL(String mduiPrivacyStatementURL) {+        getConfig().put(MDUI_PRIVACY_STATEMENT_URL, mduiPrivacyStatementURL);+    }++    public String getMduiLogo() {+        return getConfig().get(MDUI_LOGO);+    }++    public void setMduiLogo(String mduiLogo) {+        getConfig().put(MDUI_LOGO, mduiLogo);+    }++    public Integer getMduiLogoHeight() {+        return getConfig().get(MDUI_LOGO_HEIGHT) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_HEIGHT));+    }++    public void setMduiLogoHeight(Integer mduiLogoHeight) {+        getConfig().put(MDUI_LOGO_HEIGHT, String.valueOf(mduiLogoHeight));+    }++    public Integer getMduiLogoWidth() {+        return getConfig().get(MDUI_LOGO_WIDTH) == null ? null : Integer.valueOf(getConfig().get(MDUI_LOGO_WIDTH));+    }++    public void setMduiLogoWidth(Integer mduiLogoWidth) {+        getConfig().put(MDUI_LOGO_WIDTH, String.valueOf(mduiLogoWidth));+    }++    public String getMdOrganizationName() {+        return getConfig().get(MD_ORGANIZATION_NAME);+    }++    public void setMdOrganizationName(String mdOrganizationName) {+        getConfig().put(MD_ORGANIZATION_NAME, mdOrganizationName);+    }++    public String getMdOrganizationDisplayName() {+        return getConfig().get(MD_ORGANIZATION_DISPLAY_NAME);+    }++    public void setMdOrganizationDisplayName(String mdOrganizationDisplayName) {+        getConfig().put(MD_ORGANIZATION_DISPLAY_NAME, mdOrganizationDisplayName);+    }++    public String getMdOrganizationURL() {+        return getConfig().get(MD_ORGANIZATION_URL);+    }++    public void setMdOrganizationURL(String mdOrganizationURL) {+        getConfig().put(MD_ORGANIZATION_URL, mdOrganizationURL);+    }++    public String getMdContactType() {+        return getConfig().get(MD_CONTACT_TYPE);+    }++    public void setMdContactType(String mdContactType) {+        getConfig().put(MD_CONTACT_TYPE, mdContactType);+    }++    public String getMdContactCompany() {+        return getConfig().get(MD_CONTACT_COMPANY);+    }++    public void setMdContactCompany(String mdContactCompany) {+        getConfig().put(MD_CONTACT_COMPANY, mdContactCompany);+    }++    public String getMdContactGivenName() {+        return getConfig().get(MD_CONTACT_GIVEN_NAME);+    }++    public void setMdContactGivenName(String mdContactGivenName) {+        getConfig().put(MD_CONTACT_GIVEN_NAME, mdContactGivenName);+    }++    public String getMdContactSurname() {+        return getConfig().get(MD_CONTACT_SURNAME);+    }++    public void setMdContactSurname(String mdContactSurname) {+        getConfig().put(MD_CONTACT_SURNAME, mdContactSurname);+    }++    public String getMdContactEmailAddress() {+        return getConfig().get(MD_CONTACT_EMAIL_ADDRESS);+    }++    public void setMdContactEmailAddress(String mdContactEmailAddress) {+        getConfig().put(MD_CONTACT_EMAIL_ADDRESS, mdContactEmailAddress);","Comma is a not often used but still valid character in email address. See https://tools.ietf.org/html/rfc5321#section-4.1.2. Do use JSON (and only plain, not pretty-printed which eats space in database without any value). Addresses like `""smith,jr.""@domain.com` are valid.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7536,512640458,2020-10-27T12:10:25Z,server-spi/src/main/java/org/keycloak/models/ClientModel.java,"@@ -34,10 +36,33 @@     String PUBLIC_KEY = ""publicKey"";     String X509CERTIFICATE = ""X509Certificate""; +    interface ClientCreationEvent extends ProviderEvent {+        ClientModel getCreatedClient();+    }++    // Called also during client creation after client is fully initialized (including all attributes etc)+    interface ClientUpdatedEvent extends ProviderEvent {+        ClientModel getUpdatedClient();+        KeycloakSession getKeycloakSession();+    }++    interface ClientRemovedEvent extends ProviderEvent {+        ClientModel getClient();+        KeycloakSession getKeycloakSession();+    }+     /**-     * Stores the current state of the client immediately to the underlying store, similarly to a commit.+     * Notifies other providers that this client has been updated.+     * <p>+     * After a client is updated, providers can register for {@link ClientUpdatedEvent}.+     * The setters in this model do not send an update for individual updates of the model.+     * This method is here to allow for sending this event for this client,+     * allowsing for to group multiple changes of a client and signal that+     * all the changes in this client have been performed.      *-     * @deprecated Do not use, to be removed+     * @see ProviderEvent+     * @see ProviderEventManager+     * @see ClientUpdatedEvent      */     void updateClient();","@hmlnarik Do you know about any scenario/place where this method is really necessary and it is not possible to make it work in the way that everything is committed and everyone notified at the end of the transaction? To me this still seems like something we should get rid of eventually, I think the code would be easier to understand and also debugging would be easier without this idea of notifying/flushing in the middle of transaction. I understand it is not possible now, as apparently there is a lot of code relying on it, but we should not support using it, therefore I would leave the `@deprecated` comment as is or at least I would add some warning to the javadoc that this should be used only in case it is really necessary.",
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7516,512969932,2020-10-27T19:28:48Z,themes/src/main/resources/theme/keycloak/common/resources/lib/patternfly4/tile.css,"@@ -0,0 +1,100 @@+.pf-c-tile {",@mabartos (cc: @vmuzikar ) I completely revamped the css styles of the tile component. Now the screen is IE11 compatible:![obrzok](https://user-images.githubusercontent.com/12138171/97352393-ffc00c00-1892-11eb-94fe-f7e7d5439ef9.png),
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7444,513008886,2020-10-27T20:28:05Z,model/map/src/main/java/org/keycloak/models/map/role/AbstractRoleEntity.java,"@@ -0,0 +1,147 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.role;++import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import org.keycloak.models.map.common.AbstractEntity;++public abstract class AbstractRoleEntity<K> implements AbstractEntity<K> {++    private K id;+    private String realmId;++    private String name;+    private String description;+    private boolean clientRole;+    private String clientId;+    private Set<K> compositeRoles = new HashSet<>();","You're right, from long term perspective it'd be good to have it as `String`. Thank you",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7444,513053421,2020-10-27T21:49:13Z,model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java,"@@ -0,0 +1,361 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.role;++import org.jboss.logging.Logger;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;++import org.keycloak.models.RoleModel;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.common.Serialization;+import java.util.Comparator;+import java.util.Objects;+import java.util.UUID;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.models.map.storage.MapStorage;+import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import org.keycloak.models.RoleContainerModel;+import org.keycloak.models.RoleProvider;+import org.keycloak.models.map.common.StreamUtils;++public class MapRoleProvider implements RoleProvider {++    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };+    private final KeycloakSession session;+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;+    private final MapStorage<UUID, MapRoleEntity> roleStore;++    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {+        @Override+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {+            String r1 = o1 == null ? null : o1.getName();+            String r2 = o2 == null ? null : o2.getName();+            return r1 == r2 ? 0+              : r1 == null ? -1+              : r2 == null ? 1+              : r1.compareTo(r2);++        }+    };++    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {+        this.session = session;+        this.roleStore = roleStore;+        this.tx = new MapKeycloakTransaction<>(roleStore);+        session.getTransactionManager().enlist(tx);+    }++    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller++        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {+        final MapRoleEntity res = Serialization.from(origEntity);+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);+        return res;+    }++    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {+        if (realm == null || realm.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String realmId = realm.getId();+        return entity -> Objects.equals(realmId, entity.getRealmId());+    }++    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {+        if (client == null || client.getId() == null) {+            return MapRoleProvider.ALWAYS_FALSE;+        }+        String clientId = client.getId();+        return entity -> entity.isClientRole() && +                Objects.equals(clientId, entity.getClientId());+    }++    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()+          .filter(Objects::nonNull);+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);+    }++    @Override+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {+        if (getRealmRole(realm, name) != null) {+            throw new ModelDuplicateException();+        }++        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""addRealmRole(%s, %s, %s)%s"", realm.getName(), id, name, getShortStackTrace());++        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());+        entity.setName(name);+        entity.setRealmId(realm.getId());+        if (tx.get(entity.getId(), roleStore::get) != null) {+            throw new ModelDuplicateException(""Role exists: "" + id);+        }+        tx.putIfAbsent(entity.getId(), entity);+        return entityToAdapterFunc(realm).apply(entity);+    }++    @Override+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {+        Stream<RoleModel> s = getRealmRolesStream(realm);+        if (first != null && first >= 0) {+            s = s.skip(first);+        }+        if (max != null && max >= 0) {+            s = s.limit(max);+        }+        return s;+    }++    @Override+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {+        return getNotRemovedUpdatedRolesStream()+                .filter(entityRealmFilter(realm))+                .filter(this::isRealmRole)+                .sorted(COMPARE_BY_NAME)+                .map(entityToAdapterFunc(realm));+    }++    private boolean isRealmRole(MapRoleEntity role) {+        return ! role.isClientRole();+    }++    @Override+    public RoleModel addClientRole(ClientModel client, String id, String name) {+        if (getClientRole(client, name) != null) {+            throw new ModelDuplicateException();+        }++        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""addClientRole(%s, %s, %s)%s"", client.getClientId(), id, name, getShortStackTrace());++        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());+        entity.setName(name);+        entity.setClientRole(true);+        entity.setClientId(client.getId());+        if (tx.get(entity.getId(), roleStore::get) != null) {+            throw new ModelDuplicateException(""Role exists: "" + id);+        }+        tx.putIfAbsent(entity.getId(), entity);+        return entityToAdapterFunc(client.getRealm()).apply(entity);+    }++    @Override+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {+        Stream<RoleModel> s = getClientRolesStream(client);+        if (first != null && first > 0) {+            s = s.skip(first);+        }+        if (max != null && max >= 0) {+            s = s.limit(max);+        }+        return s;+    }++    @Override+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {+        return getNotRemovedUpdatedRolesStream()+                .filter(entityRealmFilter(client.getRealm()))+                .filter(entityClientFilter(client))+                .sorted(COMPARE_BY_NAME)+                .map(entityToAdapterFunc(client.getRealm()));+    }+    @Override+    public boolean removeRole(RoleModel role) {+        LOG.tracef(""removeRole(%s(%s))%s"", role.getName(), role.getId(), getShortStackTrace());++        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();++        session.users().preRemove(realm, role);++        RoleContainerModel container = role.getContainer();+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {+            container.removeDefaultRoles(role.getName());+        }++        //remove role from realm-roles composites+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {","I've changed it according to your suggestion. Thank you. The code is a little bit longer and maybe slightly less readable, but as you said by this approach we got rid of sorting and turning all entities to model. I'd like to also hear @hmlnarik's opinion on this.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7533,514207774,2020-10-29T12:06:47Z,adapters/spi/tomcat-adapter-spi/src/main/java/org/keycloak/adapters/tomcat/GenericPrincipalFactory.java,"@@ -22,13 +22,7 @@  import javax.security.auth.Subject; import java.security.Principal;-import java.security.acl.Group;-import java.util.ArrayList;-import java.util.Collection;-import java.util.Enumeration;-import java.util.Iterator;-import java.util.List;-import java.util.Set;+import java.util.*;","Can you please remove ""start"" imports and use the individual classes as was before? In general, we try to avoid star imports in our java classes.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7552,515022224,2020-10-30T11:11:13Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/KeycloakProcessor.java,"@@ -102,7 +102,7 @@ void configureHibernate(KeycloakRecorder recorder, HibernateOrmConfig config, Li      *       * @param recorder      */-    @Record(ExecutionTime.STATIC_INIT)+    @Record(ExecutionTime.RUNTIME_INIT)","Yes, it is ..After analyzing the flame graph   for a startup I noticed stacks related to loading factory classes during static init. Where changing to runtime (main method) it does not show up. O noticed a slight improvement, thus the change.Also, I think that initialization makes more sense in the main method after all configuration is processed during static init.",
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7516,516814413,2020-11-03T16:53:11Z,themes/src/main/resources/theme/keycloak/common/resources/lib/patternfly4/tile.css,"@@ -0,0 +1,202 @@+/*Internet Explorer 11 compatibility workaround - IE does not support CSS variables */","edit: sry @vmuzikar, I misunderstood your input at first, to clarify that - it's just partially custom, the vast majority of the code comes from PF4 [1] and the IE optimization part is actually the only custom piece of code. In other words, we could eventually move just the IE workaround part from there (e.g. to login.css). But just a suggestion ;).[1] https://github.com/patternfly/patternfly/blob/84ae888cf912693b209ac0cf8f63b3ab3ddf59c2/src/patternfly/components/Tile/tile.scss",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7554,517226644,2020-11-04T10:01:10Z,themes/src/main/resources/theme/base/login/login-otp.ftl,"@@ -1,5 +1,5 @@ <#import ""template.ftl"" as layout>-    <@layout.registrationLayout; section>+    <@layout.registrationLayout displayMessage=!messagesPerField.existsError('totp'); section>",Why to make this change in this PR? Shouldn't it belong to https://github.com/keycloak/keycloak/pull/7516 which addresses migration of this file?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7554,517247099,2020-11-04T10:34:17Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/LoginTotpPage.java,"@@ -45,15 +45,30 @@     @FindBy(className = ""alert-error"")     private WebElement loginErrorMessage; +    @FindBy(id = ""input-error-otp-code"")+    private WebElement totpInputCodeError;+     public void login(String totp) {         otpInput.clear();         if (totp != null) otpInput.sendKeys(totp);          submitButton.click();     } -    public String getError() {-        return loginErrorMessage != null ? loginErrorMessage.getText() : null;+    public String getAlertError() {+        try {+            return UIUtils.getTextFromElement(loginErrorMessage);+        } catch (NoSuchElementException e) {+            return null;+        }+    }++    public String getInputError(){+        try {+            return UIUtils.getTextFromElement(totpInputCodeError);+        } catch (NoSuchElementException e) {+            return null;+        }",Why to make this change in this PR? Shouldn't it belong to https://github.com/keycloak/keycloak/pull/7516 which addresses migration of this file?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7546,517278870,2020-11-04T11:30:44Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/RegisterInputErrors.java,"@@ -0,0 +1,96 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.pages;++import org.openqa.selenium.NoSuchElementException;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIUtils.getTextFromElement;++/**+ * @author <a href=""mailto:mabartos@redhat.com"">Martin Bartos</a>+ */+public class RegisterInputErrors {","I wonder whether we need this class at all. It combines fields from `AccountFields` and `PasswordFields` POs. Wouldn't it make more sense to place the webelements to the POs that they belong to?Also, `AccountFields` is not used only for registration but profile updates as well, so at the very least the name of this class is IMHO a bit misleading. So maybe we should at least rename it.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7463,517346730,2020-11-04T13:36:35Z,distribution/adapters/fuse-adapter-zip/src/main/resources/licenses/keycloak/licenses.xml,"@@ -103,11 +103,11 @@     <dependency>       <groupId>org.apache.httpcomponents</groupId>       <artifactId>httpclient</artifactId>-      <version>4.5.2</version>+      <version>4.5.12</version>","This is not correct, in Fuse we use https://github.com/keycloak/keycloak/blob/master/pom.xml#L1700-L1701",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7463,517346766,2020-11-04T13:36:38Z,distribution/adapters/fuse-adapter-zip/src/main/resources/licenses/keycloak/licenses.xml,"@@ -125,11 +125,11 @@     <dependency>       <groupId>org.apache.httpcomponents</groupId>       <artifactId>httpcore</artifactId>-      <version>4.4.4</version>+      <version>4.4.13</version>","This is not correct, in Fuse we use https://github.com/keycloak/keycloak/blob/master/pom.xml#L1700-L1701",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7554,517371743,2020-11-04T14:12:50Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/UpdateProfileErrors.java,"@@ -0,0 +1,74 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.pages;++import org.openqa.selenium.NoSuchElementException;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIUtils.getTextFromElement;++/**+ * @author <a href=""mailto:mabartos@redhat.com"">Martin Bartos</a>+ */+public class UpdateProfileErrors {","I didn't want to hide main components in `LoginUpdateProfilePage` by a lot of error fields. So, IMO, it's nicer to separate errors from the other components. WDYT @vmuzikar ?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7554,517372765,2020-11-04T14:14:14Z,themes/src/main/resources/theme/base/login/login-otp.ftl,"@@ -1,5 +1,5 @@ <#import ""template.ftl"" as layout>-    <@layout.registrationLayout; section>+    <@layout.registrationLayout displayMessage=!messagesPerField.existsError('totp'); section>","Ok, I'm fine with that. I'm just starting to be a little bit concerned because there are too many parallel PRs, all touching similar thing, all need to work together, sometimes even touch the same files. So let's hope it'll all work together well once merged. :)",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7554,517374749,2020-11-04T14:17:03Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/UpdateProfileErrors.java,"@@ -0,0 +1,74 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.pages;++import org.openqa.selenium.NoSuchElementException;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIUtils.getTextFromElement;++/**+ * @author <a href=""mailto:mabartos@redhat.com"">Martin Bartos</a>+ */+public class UpdateProfileErrors {","If you really want to put it inside a separate class, I'd make it a nested class inside `LoginUpdateProfilePage` as it really belongs to it. ;)",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7516,517379945,2020-11-04T14:24:00Z,themes/src/main/resources/theme/keycloak/common/resources/lib/patternfly4/tile.css,"@@ -0,0 +1,202 @@+/*Internet Explorer 11 compatibility workaround - IE does not support CSS variables */","Btw, why not to put these changes into `login.css` alongside other IE hacks?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7488,517392868,2020-11-04T14:41:39Z,themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -574,6 +574,81 @@ ul#kc-totp-supported-apps {     width: 40%; } +/* Internet Explorer 11 compatibility workaround for select-authenticator screen */",I'm afraid I have to bug you a bit more with IE. It seems there's some overflow when the text is longer.![Capture](https://user-images.githubusercontent.com/13906855/98124882-09113000-1eb4-11eb-8c3c-859191ddd17c.PNG),
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7488,517565474,2020-11-04T19:00:26Z,themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -574,6 +574,81 @@ ul#kc-totp-supported-apps {     width: 40%; } +/* Internet Explorer 11 compatibility workaround for select-authenticator screen */+@media all and (-ms-high-contrast: none),+(-ms-high-contrast: active) {+    .select-auth-box-parent:hover .select-auth-box-headline,+    .select-auth-box-parent:hover .select-auth-box-icon,+    .select-auth-box-parent:hover .select-auth-box-arrow,+    .select-auth-box-parent:hover .select-auth-box-desc {+        color: #06c;+    }+    .select-auth-box-parent {+        border-top: 1px solid #f0f0f0;+        padding-top: 1rem;+        padding-bottom: 1rem;+        cursor: pointer;+    }+    .select-auth-box-parent:hover {+        border-top: 1px solid #06c;+    }++    .select-auth-box-headline {+        font-size: 16px;+        font-weight: bold;+    }++    .select-auth-box-desc {+        font-size: 14px;+    }+}+/* End of IE11 workaround for select-authenticator screen */++.select-auth-box-arrow{+    display: flex;+    align-items: center;+    margin-right: 2rem;+}++.select-auth-box-icon{+    display: flex;+    flex: 0 0 2em;+    justify-content: center;+    margin-right: 1rem;+    margin-left: 3rem;+}++.select-auth-box-parent:hover .select-auth-box-headline,+.select-auth-box-parent:hover .select-auth-box-icon,+.select-auth-box-parent:hover .select-auth-box-arrow,+.select-auth-box-parent:hover .select-auth-box-desc{+    color: var(--pf-global--primary-color--100);+}++.select-auth-box-parent{+    border-top: 1px solid var(--pf-global--palette--black-200);+    padding-top: 1rem;+    padding-bottom: 1rem;+    cursor: pointer;+}++.select-auth-box-parent:hover{+    border-top: 1px solid var(--pf-global--primary-color--100);","@vmuzikar: Martin asked me the exact same question couple days ago. I remember that during the initial polishing in May I removed the horizontal bottom line based on the comment[1] from @stianst but I left the top horizontal line based on PF guidelines[2]:![image](https://user-images.githubusercontent.com/12138171/98156007-771b1e80-1ed7-11eb-9dd0-38fb0ccdd3b5.png)So I don't know now, any thoughts?[1] https://issues.redhat.com/browse/KEYCLOAK-12824?focusedCommentId=14084158&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14084158[2] https://www.patternfly.org/v4/components/login-page/design-guidelines/",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7488,517854345,2020-11-05T08:01:04Z,themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -574,6 +574,81 @@ ul#kc-totp-supported-apps {     width: 40%; } +/* Internet Explorer 11 compatibility workaround for select-authenticator screen */+@media all and (-ms-high-contrast: none),+(-ms-high-contrast: active) {+    .select-auth-box-parent:hover .select-auth-box-headline,+    .select-auth-box-parent:hover .select-auth-box-icon,+    .select-auth-box-parent:hover .select-auth-box-arrow,+    .select-auth-box-parent:hover .select-auth-box-desc {+        color: #06c;+    }+    .select-auth-box-parent {+        border-top: 1px solid #f0f0f0;+        padding-top: 1rem;+        padding-bottom: 1rem;+        cursor: pointer;+    }+    .select-auth-box-parent:hover {+        border-top: 1px solid #06c;+    }++    .select-auth-box-headline {+        font-size: 16px;+        font-weight: bold;+    }++    .select-auth-box-desc {+        font-size: 14px;+    }+}+/* End of IE11 workaround for select-authenticator screen */++.select-auth-box-arrow{+    display: flex;+    align-items: center;+    margin-right: 2rem;+}++.select-auth-box-icon{+    display: flex;+    flex: 0 0 2em;+    justify-content: center;+    margin-right: 1rem;+    margin-left: 3rem;+}++.select-auth-box-parent:hover .select-auth-box-headline,+.select-auth-box-parent:hover .select-auth-box-icon,+.select-auth-box-parent:hover .select-auth-box-arrow,+.select-auth-box-parent:hover .select-auth-box-desc{+    color: var(--pf-global--primary-color--100);+}++.select-auth-box-parent{+    border-top: 1px solid var(--pf-global--palette--black-200);+    padding-top: 1rem;+    padding-bottom: 1rem;+    cursor: pointer;+}++.select-auth-box-parent:hover{+    border-top: 1px solid var(--pf-global--primary-color--100);",I wouldn't add the bottom line to normal (non-hover) state to keep it compliant with the [PF4 guidelines](https://www.patternfly.org/v4/images/multi-factor.1cc14528bafc7a0cac690fb3105ee2e1.png).So maybe we could take some other approach for the hover effect (which is not covered in the guideline if I'm correct). What about adding a light blue background color to the button on hover (instead of changing the line and text color)? WDYT @mabartos @Pepo48?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7546,517859284,2020-11-05T08:11:06Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/RegisterInputErrors.java,"@@ -0,0 +1,96 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.pages;++import org.openqa.selenium.NoSuchElementException;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIUtils.getTextFromElement;++/**+ * @author <a href=""mailto:mabartos@redhat.com"">Martin Bartos</a>+ */+public class RegisterInputErrors {","IMHO `GeneralInputErrors` is even more confusing. :) It's too ... general? It implies any input field error belongs here, which is not true, right?I still feel it should be split and placed directly into the POs they belong to (`AccountFields` and `PasswordFields`). But if we leave it in a single separate class, maybe we could call it `ProfileInputErrors` or something? WDYT?",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7463,517944636,2020-11-05T10:27:21Z,model/infinispan/src/test/java/org/keycloak/models/sessions/infinispan/initializer/ConcurrencyVersioningTest.java,"@@ -234,19 +234,16 @@ public static void endBatch(Cache<String, String> cache) {       protected DefaultCacheManager getVersionedCacheManager() {-        GlobalConfigurationBuilder gcb = new GlobalConfigurationBuilder();---        boolean clustered = false;         boolean async = false;-        boolean allowDuplicateJMXDomains = true;+        boolean clustered = false;",I'm wondering what is purpose of these boolean variables across *Test.java classes when they are never changed. They could be probably eliminated and code could be simplified.,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7546,517976690,2020-11-05T11:21:35Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/RegisterInputErrors.java,"@@ -0,0 +1,96 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.pages;++import org.openqa.selenium.NoSuchElementException;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++import static org.keycloak.testsuite.util.UIUtils.getTextFromElement;++/**+ * @author <a href=""mailto:mabartos@redhat.com"">Martin Bartos</a>+ */+public class RegisterInputErrors {","@vmuzikar I removed the separate class and divided the methods into `AccountFields` and `PasswordFields`. Now, I'm waiting for tests result.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7569,517984046,2020-11-05T11:34:41Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanSingleUseTokenStoreProviderFactory.java,"@@ -52,28 +52,32 @@ private void lazyInit(KeycloakSession session) {         if (tokenCache == null) {             synchronized (this) {                 if (tokenCache == null) {-                    InfinispanConnectionProvider connections = session.getProvider(InfinispanConnectionProvider.class);-                    Cache cache = connections.getCache(InfinispanConnectionProvider.ACTION_TOKEN_CACHE);--                    RemoteCache remoteCache = InfinispanUtil.getRemoteCache(cache);--                    if (remoteCache != null) {-                        LOG.debugf(""Having remote stores. Using remote cache '%s' for single-use cache of token"", remoteCache.getName());-                        this.tokenCache = () -> {-                            // Doing this way as flag is per invocation-                            return remoteCache.withFlags(Flag.FORCE_RETURN_VALUE);-                        };-                    } else {-                        LOG.debugf(""Not having remote stores. Using normal cache '%s' for single-use cache of token"", cache.getName());-                        this.tokenCache = () -> {-                            return cache;-                        };-                    }+                    this.tokenCache = getActionTokenCache(session);                 }             }         }     } +    static Supplier getActionTokenCache(KeycloakSession session) {",Nice one the removal of duplicates for this piece.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7569,518046172,2020-11-05T13:23:25Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -233,28 +235,43 @@ public boolean checkTokenValidForIntrospection(KeycloakSession session, RealmMod             return false;         } -        boolean valid = false;+        TokenRevocationStoreProvider revocationStore = session.getProvider(TokenRevocationStoreProvider.class);+        if (revocationStore.isRevoked(token.getId())) {","Yes, the session will be still alive once access tokens are revoked. Few points to this:-  Specification https://tools.ietf.org/html/rfc7009 does not prescribe the behaviour in this case. It explicitly mentions: ""If the token passed to the request is an access token, the server MAY revoke the respective refresh token as well."" .- Regarding session revoke for access tokens, I was thinking about the following scenario:-- Public client ""foo"" obtains tokens through the Browser UI-- Client ""foo"" sends the token to the resource-server ""bar""-- Resource server ""bar"" is bad citizen and he decides to revoke the access token sent to it. Nothing prevents him to do so, as the ""foo"" is public client and hence Keycloak will just need to accept the access token sent to it for the revocation-- Now if the session will be logged-out as well, it would give the resource server ""bar"" the power to revoke sessions of client ""foo"" . Which IMO is not great behaviour. That's why I've not invalidated the session for the access token.WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7569,518119298,2020-11-05T15:03:42Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -233,28 +235,43 @@ public boolean checkTokenValidForIntrospection(KeycloakSession session, RealmMod             return false;         } -        boolean valid = false;+        TokenRevocationStoreProvider revocationStore = session.getProvider(TokenRevocationStoreProvider.class);+        if (revocationStore.isRevoked(token.getId())) {","Yeah, however in case of the public clients, the client authentication is just verification that there is parameter like ""client_id=foo"" . It seems our TokenRevocationEndpoint calls the ""AuthorizeClientUtil.authorizeClient"", which does just this for public clients. So it is not real authentication. The specs does not enforce client authentication, it allows public clients as well, so we are fine with regards to the specs IMO...",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7541,518480965,2020-11-06T02:04:30Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -653,30 +654,39 @@ public String getDescriptor() throws Exception {     }      public static String getIDPMetadataDescriptor(UriInfo uriInfo, KeycloakSession session, RealmModel realm) {-        Set<KeyWrapper> keys = new TreeSet<>((o1, o2) -> o1.getStatus() == o2.getStatus() // Status can be only PASSIVE OR ACTIVE, push PASSIVE to end of list-          ? (int) (o2.getProviderPriority() - o1.getProviderPriority())-          : (o1.getStatus() == KeyStatus.PASSIVE ? 1 : -1));-        keys.addAll(session.keys().getKeys(realm, KeyUse.SIG, Algorithm.RS256));-         try {-            List<Element> signingKeys = new ArrayList<Element>();-            for (KeyWrapper key : keys) {-                signingKeys.add(IDPMetadataDescriptor.buildKeyInfoElement(key.getKid(), PemUtils.encodeCertificate(key.getCertificate())));-            }+            List<Element> signingKeys = new LinkedList<>();+            session.keys().getKeysStream(realm, KeyUse.SIG, Algorithm.RS256)+                    .sorted(SamlService::compareKeys)+                    .forEach(key -> {+                        try {+                            Element element = IDPMetadataDescriptor+                                    .buildKeyInfoElement(key.getKid(), PemUtils.encodeCertificate(key.getCertificate()));+                            signingKeys.add(element);+                        } catch (ParserConfigurationException e) {+                            throw new RuntimeException(e);+                        }+                    });",Wouldn't it be better to map the keys to elements and then collect into a list at the end instead of populating the list as part of a forEach?,
8414918,iankko,https://api.github.com/repos/keycloak/keycloak/pulls/7463,518699536,2020-11-06T11:44:10Z,distribution/adapters/fuse-adapter-zip/src/main/resources/licenses/keycloak/licenses.xml,"@@ -103,11 +103,11 @@     <dependency>       <groupId>org.apache.httpcomponents</groupId>       <artifactId>httpclient</artifactId>-      <version>4.5.2</version>+      <version>4.5.12</version>","@martin-kanis Right, great catch Martin, thanks! The script have their versions mangled, because at the moment there are two duplicate definitions of both the `org.apache.httpcomponents:httpclient` and `org.apachehttpcomponents.httpcore` artifacts in the Keycloak / RH-SSO Fuse adapter license files:- The first definition came from [[KEYCLOAK-11764] Upgrade to Wildfly 19](https://github.com/keycloak/keycloak/commit/d4eeed306be1bb0a605c5d1154c33a1aabc7fb96#diff-563f018fb700a0ff7c27d000892069ce2e96474417d2d9eb17ec62fa1e4b5382L106) change- While the second from [[KEYCLOAK-15892] Can not install 7.4.3.CR1 Fuse adapter](https://github.com/keycloak/keycloak/commit/c8d0f2c59cddd3a719a6c03c8d1b267eeddd50c6#diff-563f018fb700a0ff7c27d000892069ce2e96474417d2d9eb17ec62fa1e4b5382R128) changeSince assuming there can be just one version of a specific artifact defined in the license files (if there are two versions of the same, how would be determined which of them should be actually used), tried to consolidate them via 67dfcac commit (intentionally left it separated so you can better double check / verify) -- basically:1. Dropped the duplicate entries (from both the respective _license.xml_ files and from the *.txt files),2. And kept only former versions of these artifacts for both the Keycloak and RH-SSO adapters (or more exactly, those versions listed in ```apache.httpcomponents.fuse.version``` and ```apache.httpcomponents.httpcore.fuse.version``` properties)Please double-check if the state after the 67dfcac commit is the expected one (IOW there should be just one version of those artifacts listed in Fuse adapter files & their versions should match the aforementioned two properties)Also filed KEYCLOAK-16200 to prevent re-occurrence of duplicate entries in license files, and KEYCLOAK-16202 not to have versions of `httpclient` / `httpcore` in Fuse adapter updated, if it gets updated as part of the Wildfly upgrade (IOW let them get upgraded on other places within the repo, for the purpose of e.g. the testsuite or quarkus reference, but skip the Fuse adapter entries).",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7463,518710543,2020-11-06T12:07:27Z,distribution/adapters/fuse-adapter-zip/src/main/resources/licenses/keycloak/licenses.xml,"@@ -103,11 +103,11 @@     <dependency>       <groupId>org.apache.httpcomponents</groupId>       <artifactId>httpclient</artifactId>-      <version>4.5.2</version>+      <version>4.5.12</version>",@iankko Thanks for the update. I think the state of 67dfcac is correct one i.e my understanding is that Fuse licenses should contain entries **only** for httpcomponents used in Fuse (4.5.2 and 4.4.4)  and **don't contain** versions from EAP. @drichtarik is that correct?,
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7442,519612858,2020-11-09T07:57:12Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderConfig.java,"@@ -18,13 +18,17 @@  import static org.keycloak.common.util.UriUtils.checkUrl; +import java.io.IOException;+import java.util.Map;+ import org.keycloak.common.enums.SslRequired; import org.keycloak.dom.saml.v2.protocol.AuthnContextComparisonType; import org.keycloak.models.IdentityProviderModel; import org.keycloak.models.KeycloakSession; import org.keycloak.models.RealmModel; import org.keycloak.protocol.saml.SamlPrincipalType; import org.keycloak.saml.common.util.XmlKeyInfoKeyNameTransformer;+import org.keycloak.util.JsonSerialization;",This class was changed and these imports are used.,
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7488,520183222,2020-11-09T23:19:33Z,themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -574,6 +574,81 @@ ul#kc-totp-supported-apps {     width: 40%; } +/* Internet Explorer 11 compatibility workaround for select-authenticator screen */","Fixed by adding:https://github.com/keycloak/keycloak/blob/4a2849b1467b8567a48328a776acef004b568e6e/themes/src/main/resources/theme/keycloak/login/resources/css/login.css#L605-L607It just seems to be another IE specific bug/feature, where it needs the explicit request[1].[1] https://stackoverflow.com/a/35113633",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7594,521180856,2020-11-11T08:02:57Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureSessionEnforceExecutor.java,"@@ -0,0 +1,87 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import org.jboss.logging.Logger;+import org.keycloak.OAuthErrorException;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyLogger;+import org.keycloak.util.TokenUtil;++public class SecureSessionEnforceExecutor implements ClientPolicyExecutorProvider {++    private static final Logger logger = Logger.getLogger(SecureSessionEnforceExecutor.class);++    private final KeycloakSession session;+    private final ComponentModel componentModel;++    public SecureSessionEnforceExecutor(KeycloakSession session, ComponentModel componentModel) {+        this.session = session;+        this.componentModel = componentModel;+    }++    @Override+    public String getName() {+        return componentModel.getName();+    }++    @Override+    public String getProviderId() {+        return componentModel.getProviderId();+    }++    @Override+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {+        switch (context.getEvent()) {+            case AUTHORIZATION_REQUEST:+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),+                    authorizationRequestContext.getAuthorizationEndpointRequest(),+                    authorizationRequestContext.getRedirectUri());+                return;+            default:+                return;+        }+    }++    private void executeOnAuthorizationRequest(+            OIDCResponseType parsedResponseType,+            AuthorizationEndpointRequest request,+            String redirectUri) throws ClientPolicyException {+        ClientPolicyLogger.log(logger, ""Authz Endpoint - authz request"");+        if (TokenUtil.isOIDCRequest(request.getScope())) {+            if(request.getNonce() == null) {+                ClientPolicyLogger.log(logger, ""Missing parameter: nonce"");+                throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Missing parameter: nonce"");+            }+        } else {+            if(request.getState() == null) {","Just to doublechec, wouldn't it be better to check that ""state"" parameter is always there? In other words, remove it from the ""else"" branch? This would mean that for OIDC clients, both ""state"" and ""nonce"" will be enforced, which IMO is fine behaviour?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7594,521185857,2020-11-11T08:14:00Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java,"@@ -812,6 +813,61 @@ public void testClientIpAddressCondition() throws ClientRegistrationException, C         }     } +    @Test+    public void testSecureSessionEnforceExecutor() throws ClientRegistrationException, ClientPolicyException {+        String policyBetaName = ""MyPolicy-beta"";+        createPolicy(policyBetaName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);+        logger.info(""... Created Policy : "" + policyBetaName);++        createCondition(""ClientRolesCondition-beta"", ClientRolesConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {","This is out of scope of this PR, but I wonder if we plan to have the condition, which will always evaluate to true? Or something like this... I can imagine that enforcing ""state"" and ""nonce"" parameter is something, which many deployments may want by default without a need for the client to match any special condition. WDYT? Just an idea for the future, nothing needed in this PR :-)",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7594,521228421,2020-11-11T09:31:17Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java,"@@ -812,6 +813,61 @@ public void testClientIpAddressCondition() throws ClientRegistrationException, C         }     } +    @Test+    public void testSecureSessionEnforceExecutor() throws ClientRegistrationException, ClientPolicyException {+        String policyBetaName = ""MyPolicy-beta"";+        createPolicy(policyBetaName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);+        logger.info(""... Created Policy : "" + policyBetaName);++        createCondition(""ClientRolesCondition-beta"", ClientRolesConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {","@mposolda Yes, I totally agree with you. This ""always true"" condition is needed to realize [pre-set policy](https://github.com/keycloak/keycloak-community/blob/master/design/client-policies.md#pre-set-policy) which are adopted to all clients.I'd like to implement this condition afterwards. Thank you.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7595,521293815,2020-11-11T11:29:17Z,services/src/main/java/org/keycloak/services/resources/SessionCodeChecks.java,"@@ -397,8 +397,8 @@ private Response restartAuthenticationSessionFromCookie(RootAuthenticationSessio             return Response.status(Response.Status.FOUND).location(redirectUri).build();         } else {             // Finally need to show error as all the fallbacks failed-            event.error(Errors.INVALID_CODE);-            return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_CODE);+            event.error(Errors.DISABLED_COOKIES);","The else branch handles the case `authSession == null`The [RestartLoginCookie.restartSession(..)](https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/RestartLoginCookie.java#L137) method contains multiple code paths that could return `null` besides those caused by missing cookies.I think you should check here, whether the cookies (e.g. KC_RESTART etc.) are really missing.",
15000073,DaSmoo,https://api.github.com/repos/keycloak/keycloak/pulls/7595,521371617,2020-11-11T13:51:34Z,services/src/main/java/org/keycloak/services/resources/SessionCodeChecks.java,"@@ -397,8 +397,8 @@ private Response restartAuthenticationSessionFromCookie(RootAuthenticationSessio             return Response.status(Response.Status.FOUND).location(redirectUri).build();         } else {             // Finally need to show error as all the fallbacks failed-            event.error(Errors.INVALID_CODE);-            return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_CODE);+            event.error(Errors.DISABLED_COOKIES);","Hey @thomasdarimont,i added a new method in the RestartLoginCookie class which tries to extract the cookie. The new error message is only used when in this method the extraction fails.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7596,521372714,2020-11-11T13:53:25Z,model/jpa/src/main/java/org/keycloak/models/jpa/entities/RealmLocalizationTextsEntity.java,"@@ -76,15 +77,25 @@ public int hashCode() {     private String locale;      @Column(name = ""TEXTS"")-    @Convert(converter = MapStringConverter.class)","I've updated my PR to use the constant. Also I've added TODO to revert this change once quarkus fix is applied and we can update to the quarkus version with the fix. I did not changed the ""MapStringConverter"" class itself. Is it fine for you that way?",
15000073,DaSmoo,https://api.github.com/repos/keycloak/keycloak/pulls/7595,521991476,2020-11-12T10:15:46Z,services/src/main/java/org/keycloak/services/resources/SessionCodeChecks.java,"@@ -397,8 +397,8 @@ private Response restartAuthenticationSessionFromCookie(RootAuthenticationSessio             return Response.status(Response.Status.FOUND).location(redirectUri).build();         } else {             // Finally need to show error as all the fallbacks failed-            event.error(Errors.INVALID_CODE);-            return ErrorPage.error(session, authSession, Response.Status.BAD_REQUEST, Messages.INVALID_CODE);+            event.error(Errors.DISABLED_COOKIES);","Hey @thomasdarimont,are you sure that this is how it would work at this point? The restartSession() method returns either null or the AuthenticatedSessionModel. In the calling method I cannot distinguish why the restartSession() method had an error and returned null. The topic with the public API makes total sense, I had not thought about that before. I might have to change the error handling in the restartSession() method. According to the declaration it should throw an exception, but there is no exception built in. Would that be a better way? I think the restartAuthenticationSessionFromCookie() method also logs a ServiceLogger exception in the try/catch block but I don't think this is reached because the restartSession method always returns null or the AuthenticatedSessionModel.greetings David",
8417158,slaskawi,https://api.github.com/repos/keycloak/keycloak/pulls/7600,522030293,2020-11-12T11:18:37Z,quarkus/deployment/src/test/java/test/org/keycloak/quarkus/services/health/KeycloakReadyHealthCheckTest.java,"@@ -0,0 +1,63 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package test.org.keycloak.quarkus.services.health;++import io.quarkus.test.QuarkusUnitTest;+import org.hamcrest.Matchers;+import org.jboss.shrinkwrap.api.ShrinkWrap;+import org.jboss.shrinkwrap.api.spec.JavaArchive;+import org.junit.jupiter.api.Test;+import org.junit.jupiter.api.extension.RegisterExtension;++import java.sql.SQLException;++import static io.restassured.RestAssured.given;++public class KeycloakReadyHealthCheckTest {++    @RegisterExtension+    static final QuarkusUnitTest test = new QuarkusUnitTest()",I believe one more test - simulate that a database is down and check if the Readiness Probe returns a failure.I believe the easiest way to do it is to modify the way we wire the Agroal bean. Maybe we should create an adapter there (e.g. `DelegatingDatasource`) and inject a mock during testing there.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7600,522297784,2020-11-12T17:47:01Z,quarkus/deployment/src/test/java/test/org/keycloak/quarkus/services/health/KeycloakReadyHealthCheckTest.java,"@@ -0,0 +1,63 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package test.org.keycloak.quarkus.services.health;++import io.quarkus.test.QuarkusUnitTest;+import org.hamcrest.Matchers;+import org.jboss.shrinkwrap.api.ShrinkWrap;+import org.jboss.shrinkwrap.api.spec.JavaArchive;+import org.junit.jupiter.api.Test;+import org.junit.jupiter.api.extension.RegisterExtension;++import java.sql.SQLException;++import static io.restassured.RestAssured.given;++public class KeycloakReadyHealthCheckTest {++    @RegisterExtension+    static final QuarkusUnitTest test = new QuarkusUnitTest()",You should be able to inject the datasource bean and then try to call close (or reset metrics). I did a quick test here and it seems to work.You may want a separate test for down status though.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7600,522368251,2020-11-12T19:31:29Z,quarkus/deployment/src/test/java/test/org/keycloak/quarkus/services/health/KeycloakReadyHealthCheckTest.java,"@@ -0,0 +1,63 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package test.org.keycloak.quarkus.services.health;++import io.quarkus.test.QuarkusUnitTest;+import org.hamcrest.Matchers;+import org.jboss.shrinkwrap.api.ShrinkWrap;+import org.jboss.shrinkwrap.api.spec.JavaArchive;+import org.junit.jupiter.api.Test;+import org.junit.jupiter.api.extension.RegisterExtension;++import java.sql.SQLException;++import static io.restassured.RestAssured.given;++public class KeycloakReadyHealthCheckTest {++    @RegisterExtension+    static final QuarkusUnitTest test = new QuarkusUnitTest()",@slaskawi It may be an option to not boot the application at all (considering we have integration already) for more advanced scenarios so you can just set some impl directly to the health check class. It should help with crazy scenarios and much easier to implement.Adding a bean to just allow testing seems too much because at runtime we only need the real datasource. You may also consider `@Priority` annotation. Not sure if it may help here.,
1251974,miquelsi,https://api.github.com/repos/keycloak/keycloak/pulls/7600,522929407,2020-11-13T12:49:03Z,quarkus/deployment/src/test/java/test/org/keycloak/quarkus/services/health/KeycloakReadyHealthCheckTest.java,"@@ -0,0 +1,63 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package test.org.keycloak.quarkus.services.health;++import io.quarkus.test.QuarkusUnitTest;+import org.hamcrest.Matchers;+import org.jboss.shrinkwrap.api.ShrinkWrap;+import org.jboss.shrinkwrap.api.spec.JavaArchive;+import org.junit.jupiter.api.Test;+import org.junit.jupiter.api.extension.RegisterExtension;++import java.sql.SQLException;++import static io.restassured.RestAssured.given;++public class KeycloakReadyHealthCheckTest {++    @RegisterExtension+    static final QuarkusUnitTest test = new QuarkusUnitTest()",Thanks for the tip @pedroigor. I've added a new test class for negative cases.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7599,523021802,2020-11-13T15:25:47Z,model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java,"@@ -691,12 +691,12 @@ public CredentialModel getStoredCredentialById(RealmModel realm, UserModel user,      @Override     public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {-        return getStoredCredentials(realm, user.getId());+        return getStoredCredentialsStream(realm, user.getId()).collect(Collectors.toList());",This part confuses me little bit. We wanted to keep original collection based methods in `UserCredentialStore` and deprecate those in `UserFederatedUserCredentialStore`?I know we had some discussion around this but I don't remember exact outcome.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7267,523044803,2020-11-13T16:01:31Z,services/src/main/java/org/keycloak/theme/DefaultThemeManager.java,"@@ -81,9 +91,18 @@ public Theme getTheme(String name, Theme.Type type) {                 theme = factory.addCachedTheme(name, type, theme);             }         }+        +        if (!isAccount2Enabled && theme.getName().equals(""keycloak.v2"")) {+            theme = loadTheme(""keycloak"", type);+        }+        +        if (!isAccount2Enabled && theme.getName().equals(""rhsso.v2"")) {+            theme = loadTheme(""rhsso"", type);+        }","I haven't deeply investigated this, but it seems to me a bit suspicious. Why is it even necessary? Don't we set the correct theme here?https://github.com/keycloak/keycloak/blob/734ffb8f4212a947297935b0542f9a16fd02098f/services/src/main/java/org/keycloak/theme/DefaultThemeManager.java#L85",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7267,523102748,2020-11-13T17:20:31Z,themes/src/main/resources/theme/keycloak.v2/account/src/package.json,"@@ -1,7 +1,7 @@ {-  ""name"": ""keycloak-preview"",+  ""name"": ""keycloak.v2"",",This comment is unrelated to this line.There seems to be something wrong with the dist. It's ~50MB larger. I think the [resources filtering](https://github.com/keycloak/keycloak/blob/734ffb8f4212a947297935b0542f9a16fd02098f/themes/pom.xml#L85-L130) doesn't work anymore.,
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/7267,523448747,2020-11-14T18:33:40Z,themes/src/main/resources/theme/keycloak.v2/account/src/package.json,"@@ -1,7 +1,7 @@ {-  ""name"": ""keycloak-preview"",+  ""name"": ""keycloak.v2"",",> This comment is unrelated to this line.> > There seems to be something wrong with the dist. It's ~50MB larger. I think the [resources filtering](https://github.com/keycloak/keycloak/blob/734ffb8f4212a947297935b0542f9a16fd02098f/themes/pom.xml#L85-L130) doesn't work anymore.Should be fixed now.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7599,525922965,2020-11-18T09:09:24Z,services/src/main/java/org/keycloak/forms/account/freemarker/model/AccountFederatedIdentityBean.java,"@@ -47,15 +48,13 @@     public AccountFederatedIdentityBean(KeycloakSession session, RealmModel realm, UserModel user, URI baseUri, String stateChecker) {         this.session = session; -        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);-         AtomicInteger availableIdentities = new AtomicInteger(0);         this.identities = realm.getIdentityProvidersStream()                 .filter(IdentityProviderModel::isEnabled)                 .map(provider -> {                     String providerId = provider.getAlias(); -                    FederatedIdentityModel identity = getIdentity(identities, providerId);+                    FederatedIdentityModel identity = getIdentity(session.users().getFederatedIdentitiesStream(user, realm), providerId);","Here can you confirm my assumption the cached version of `getFederatedIdentitiesStream(user, realm)` will be used to prevent multiple database calls? ",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7599,525947217,2020-11-18T09:45:19Z,services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java,"@@ -110,7 +111,8 @@ public Response linkedAccounts() {      public SortedSet<LinkedAccountRepresentation> getLinkedAccounts(KeycloakSession session, RealmModel realm, UserModel user) {         Set<String> socialIds = findSocialIds();-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);+        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentitiesStream(user, realm)+                .collect(Collectors.toSet());","Maybe you can do similar thing which you did in one of the previous classes? `toLinkedAccountRepresentation(provider, socialIds, session.users().getFederatedIdentitiesStream(user, realm));` + rewrite `getIdentity` method to accept a stream.  But only if the same predicate about caching is valid to avoid performance degradation.  ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7540,526684605,2020-11-19T08:44:15Z,services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java,"@@ -976,12 +976,12 @@ public Response authenticateOnly() throws AuthenticationFlowException {         AuthenticationFlow authenticationFlow = createFlowExecution(this.flowId, null);         Response challenge = authenticationFlow.processFlow();         if (challenge != null) return challenge;-        if (authenticationSession.getAuthenticatedUser() == null) {",Is it possible to avoid changes in this class in this PR?,
6265563,zak905,https://api.github.com/repos/keycloak/keycloak/pulls/7176,526765565,2020-11-19T10:48:55Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/DeleteAccountActionTest.java,"@@ -0,0 +1,118 @@+package org.keycloak.testsuite.actions;++import java.util.Arrays;+import java.util.List;+import java.util.Objects;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Assert;+import org.junit.Before;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.admin.client.resource.UserResource;+import org.keycloak.authentication.requiredactions.DeleteAccount;+import org.keycloak.events.EventType;+import org.keycloak.models.AccountRoles;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.RequiredActionProviderRepresentation;+import org.keycloak.representations.idm.RoleRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.auth.page.login.DeleteAccountActionConfirmPage;+import org.keycloak.testsuite.pages.ErrorPage;+import org.keycloak.testsuite.pages.LoginPage;+import org.keycloak.testsuite.util.UserBuilder;++public class DeleteAccountActionTest extends AbstractTestRealmKeycloakTest {++  @Rule+  public AssertEvents events = new AssertEvents(this);++  @Page+  public DeleteAccountActionConfirmPage deleteAccountPage;++  @Page+  protected LoginPage loginPage;++  @Page+  protected ErrorPage errorPage;++  @Override+  public void configureTestRealm(RealmRepresentation testRealm) {+  }++  @Before+  public void setUpAction() {+    UserRepresentation user = ActionUtil.findUserWithAdminClient(adminClient, ""test-user@localhost"");+    UserBuilder.edit(user).requiredAction(DeleteAccount.PROVIDER_ID);+    testRealm().users().get(user.getId()).update(user);+    addDeleteAccountRoleToUserClientRoles();++    RequiredActionProviderRepresentation rep = testRealm().flows().getRequiredAction(DeleteAccount.PROVIDER_ID);+    rep.setEnabled(true);+    adminClient.realm(""test"").flows().updateRequiredAction(DeleteAccount.PROVIDER_ID, rep);+  }++  @Test+  public void deleteAccountActionSucceeds() {+    loginPage.open();++    loginPage.login(""test-user@localhost"", ""password"");++    Assert.assertTrue(deleteAccountPage.isCurrent());++    deleteAccountPage.clickConfirmAction();++    events.expect(EventType.DELETE_ACCOUNT);++    List<UserRepresentation> users = testRealm().users().search(""test-user@localhost"");++    Assert.assertEquals(users.size(), 0);+  }++  @Test+  public void deleteAccountFailsWithoutRoleFails() {+    removeDeleteAccountRoleFromUserClientRoles();+    loginPage.open();++    loginPage.login(""test-user@localhost"", ""password"");++    Assert.assertTrue(errorPage.isCurrent());++    Assert.assertEquals(errorPage.getError(), ""You do not have enough permissions to delete your own account, contact admin."");+  }+++  private void addDeleteAccountRoleToUserClientRoles() {+    createDeleteAccountRoleIfNotExists();+    UserRepresentation user = ActionUtil.findUserWithAdminClient(adminClient, ""test-user@localhost"");+    ApiUtil.assignClientRoles(adminClient.realm(""test""), user.getId(), ""account"", AccountRoles.DELETE_ACCOUNT);+  }++  private void createDeleteAccountRoleIfNotExists() {+    RoleRepresentation deleteRole = new RoleRepresentation();+    deleteRole.setName(AccountRoles.DELETE_ACCOUNT);++    try {+      adminClient.realm(""test"").roles().create(deleteRole);+    }+    catch (Exception exp) {++    }+  }","yeah seems to be useless, not sure what I thought back then, this snippet was just copied from the `DeleteAccountTest`. Removed. ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7628,527721893,2020-11-20T14:19:02Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientUpdateSourceHostsCondition.java,"@@ -0,0 +1,85 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import java.util.Collections;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyLogger;+import org.keycloak.services.clientpolicy.ClientPolicyVote;++public class ClientUpdateSourceHostsCondition implements ClientPolicyConditionProvider {++    private static final Logger logger = Logger.getLogger(ClientUpdateSourceHostsCondition.class);++    private final KeycloakSession session;+    private final ComponentModel componentModel;++    public ClientUpdateSourceHostsCondition(KeycloakSession session, ComponentModel componentModel) {+        this.session = session;+        this.componentModel = componentModel;+    }++    @Override+    public String getName() {+        return componentModel.getName();+    }++    @Override+    public String getProviderId() {+        return componentModel.getProviderId();+    }++    @Override+    public ClientPolicyVote applyPolicy(ClientPolicyContext context) throws ClientPolicyException {+        switch (context.getEvent()) {+        case REGISTER:+        case UPDATE:+            if (isHostMatched()) return ClientPolicyVote.YES;+            return ClientPolicyVote.NO;+        default:+            return ClientPolicyVote.ABSTAIN;+        }+    }++    private boolean isHostMatched() {+        String host = session.getContext().getRequestHeaders().getHeaderString(""Host"");","I think that ""Host"" headers refers to the server host, rather than the host of the client.I think you can take a look for the inspiration to the TrustedHostClientRegistrationPolicy . That one also provides some additional flexibility (EG. checking the domains instead of the pure hosts) and hence I suggest to just re-use some code from it to have similar flexibility here (also considering that we're going to replace ""Client Registration Policies"" by ""Client Policies"", we may need at least same flexibility, which is provided by the existing client registration policies)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7628,527730406,2020-11-20T14:31:28Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientUpdateSourceHostsCondition.java,"@@ -0,0 +1,85 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import java.util.Collections;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyLogger;+import org.keycloak.services.clientpolicy.ClientPolicyVote;++public class ClientUpdateSourceHostsCondition implements ClientPolicyConditionProvider {++    private static final Logger logger = Logger.getLogger(ClientUpdateSourceHostsCondition.class);++    private final KeycloakSession session;+    private final ComponentModel componentModel;++    public ClientUpdateSourceHostsCondition(KeycloakSession session, ComponentModel componentModel) {+        this.session = session;+        this.componentModel = componentModel;+    }++    @Override+    public String getName() {+        return componentModel.getName();+    }++    @Override+    public String getProviderId() {+        return componentModel.getProviderId();+    }++    @Override+    public ClientPolicyVote applyPolicy(ClientPolicyContext context) throws ClientPolicyException {+        switch (context.getEvent()) {+        case REGISTER:+        case UPDATE:+            if (isHostMatched()) return ClientPolicyVote.YES;+            return ClientPolicyVote.NO;+        default:+            return ClientPolicyVote.ABSTAIN;+        }+    }++    private boolean isHostMatched() {+        String host = session.getContext().getRequestHeaders().getHeaderString(""Host"");","Also question is, if to ""merge"" this with the existing ""Client IP"" condition and just have same condition for both? So that admin can choose if he wants to use IP Address or the hostname? AFAIR this is supported by the TrustedHostClientRegistrationPolicy",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7628,528430068,2020-11-23T00:31:56Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientUpdateSourceHostsCondition.java,"@@ -0,0 +1,85 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.condition;++import java.util.Collections;+import java.util.List;++import org.jboss.logging.Logger;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.ClientPolicyLogger;+import org.keycloak.services.clientpolicy.ClientPolicyVote;++public class ClientUpdateSourceHostsCondition implements ClientPolicyConditionProvider {++    private static final Logger logger = Logger.getLogger(ClientUpdateSourceHostsCondition.class);++    private final KeycloakSession session;+    private final ComponentModel componentModel;++    public ClientUpdateSourceHostsCondition(KeycloakSession session, ComponentModel componentModel) {+        this.session = session;+        this.componentModel = componentModel;+    }++    @Override+    public String getName() {+        return componentModel.getName();+    }++    @Override+    public String getProviderId() {+        return componentModel.getProviderId();+    }++    @Override+    public ClientPolicyVote applyPolicy(ClientPolicyContext context) throws ClientPolicyException {+        switch (context.getEvent()) {+        case REGISTER:+        case UPDATE:+            if (isHostMatched()) return ClientPolicyVote.YES;+            return ClientPolicyVote.NO;+        default:+            return ClientPolicyVote.ABSTAIN;+        }+    }++    private boolean isHostMatched() {+        String host = session.getContext().getRequestHeaders().getHeaderString(""Host"");","@mposolda I see, I agree with you. I would like to re-implement this condition to integrate the following 3 condition that has been planned originally.- [KEYCLOAK-14197 Client Policy - Condition : Client - Client Host](https://issues.redhat.com/browse/KEYCLOAK-14197)- [KEYCLOAK-14198 Client Policy - Condition : Client - Client IP](https://issues.redhat.com/browse/KEYCLOAK-14198) (I'll delete already merged this condition)- [KEYCLOAK-14194 Client Policy - Condition : Client - Client Domain Name](https://issues.redhat.com/browse/KEYCLOAK-14194)When re-implementing this condition, I will re-use codes from `TrustedHostClientRegistrationPolicy`.WDYT?",
8414918,iankko,https://api.github.com/repos/keycloak/keycloak/pulls/7463,528718646,2020-11-23T13:54:33Z,distribution/adapters/fuse-adapter-zip/src/main/resources/licenses/keycloak/licenses.xml,"@@ -103,11 +103,11 @@     <dependency>       <groupId>org.apache.httpcomponents</groupId>       <artifactId>httpclient</artifactId>-      <version>4.5.2</version>+      <version>4.5.12</version>","Previously checked this with @pskopek Per the conclusion listing the same artifact in the same license file with two different versions would be an error. This is already fixed, resolving",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7495,528822273,2020-11-23T16:11:08Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/AppInitiatedActionUpdateProfileTest.java,"@@ -111,6 +113,8 @@ public void updateProfileLoginFirst() {         updateProfilePage.update(""New first"", ""New last"", ""new@email.com"", ""test-user@localhost"");          events.expectLogin().assertEvent();+        events.expectRequiredAction(EventType.UPDATE_PROFILE).detail(Details.PREVIOUS_FIRST_NAME, ""Tom"").detail(Details.UPDATED_FIRST_NAME, ""New first"").assertEvent();+        events.expectRequiredAction(EventType.UPDATE_PROFILE).detail(Details.PREVIOUS_LAST_NAME, ""Brady"").detail(Details.UPDATED_LAST_NAME, ""New last"").assertEvent();         events.expectRequiredAction(EventType.UPDATE_EMAIL).detail(Details.PREVIOUS_EMAIL, ""test-user@localhost"").detail(Details.UPDATED_EMAIL, ""new@email.com"").assertEvent();         events.expectRequiredAction(EventType.UPDATE_PROFILE).assertEvent();","The PR looks better now, however it still triggers 3 UPDATE_PROFILE events for each update of user, which is not ideal IMO. It will be better to have just single UPDATE_PROFILE event for each update, but just have the fields for firstName and lastname as the details. So for example for this test method ""updateProfileLoginFirst()"" , you won't have 2 UPDATE_PROFILE events (currently on lines 116 and 117), but you will have just the single UPDATE_PROFILE event (currently on line 119) with the details similar to this:```events.expectRequiredAction(EventType.UPDATE_PROFILE)    .detail(Details.PREVIOUS_FIRST_NAME, ""Tom"").detail(Details.UPDATED_FIRST_NAME, ""New first"")    .detail(Details.PREVIOUS_LAST_NAME, ""Brady"").detail(Details.UPDATED_LAST_NAME, ""New last"")    .assertEvent();```Is it possible to do it this way in this PR?",
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7488,529462110,2020-11-24T11:08:00Z,themes/src/main/resources/theme/keycloak/login/resources/css/login.css,"@@ -574,6 +574,81 @@ ul#kc-totp-supported-apps {     width: 40%; } +/* Internet Explorer 11 compatibility workaround for select-authenticator screen */+@media all and (-ms-high-contrast: none),+(-ms-high-contrast: active) {+    .select-auth-box-parent:hover .select-auth-box-headline,+    .select-auth-box-parent:hover .select-auth-box-icon,+    .select-auth-box-parent:hover .select-auth-box-arrow,+    .select-auth-box-parent:hover .select-auth-box-desc {+        color: #06c;+    }+    .select-auth-box-parent {+        border-top: 1px solid #f0f0f0;+        padding-top: 1rem;+        padding-bottom: 1rem;+        cursor: pointer;+    }+    .select-auth-box-parent:hover {+        border-top: 1px solid #06c;+    }++    .select-auth-box-headline {+        font-size: 16px;+        font-weight: bold;+    }++    .select-auth-box-desc {+        font-size: 14px;+    }+}+/* End of IE11 workaround for select-authenticator screen */++.select-auth-box-arrow{+    display: flex;+    align-items: center;+    margin-right: 2rem;+}++.select-auth-box-icon{+    display: flex;+    flex: 0 0 2em;+    justify-content: center;+    margin-right: 1rem;+    margin-left: 3rem;+}++.select-auth-box-parent:hover .select-auth-box-headline,+.select-auth-box-parent:hover .select-auth-box-icon,+.select-auth-box-parent:hover .select-auth-box-arrow,+.select-auth-box-parent:hover .select-auth-box-desc{+    color: var(--pf-global--primary-color--100);+}++.select-auth-box-parent{+    border-top: 1px solid var(--pf-global--palette--black-200);+    padding-top: 1rem;+    padding-bottom: 1rem;+    cursor: pointer;+}++.select-auth-box-parent:hover{+    border-top: 1px solid var(--pf-global--primary-color--100);",@vmuzikar @mabartos Haley from PF team suggested that we might to take inspiration from the hover effect of selectable-tabs PF component [1]. But I guess it's up to us to make the final decision :)[1] https://www.patternfly.org/v4/components/data-list/#selectable-rows,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7631,529592027,2020-11-24T14:36:09Z,model/test/pom.xml,"@@ -0,0 +1,146 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">+    <modelVersion>4.0.0</modelVersion>+    <parent>+        <groupId>org.keycloak</groupId>+        <artifactId>keycloak-model-pom</artifactId>+        <version>12.0.0-SNAPSHOT</version>+    </parent>+    <artifactId>keycloak-model-test</artifactId>+    <name>Tests for logical storage layer</name>+    <description>Tests for storage layer functionality targetting logical layer, i.e. models</description>+    <packaging>jar</packaging>+    +    <properties>+        <keycloak.connectionsJpa.driver>org.h2.Driver</keycloak.connectionsJpa.driver>+        <keycloak.connectionsJpa.database>keycloak</keycloak.connectionsJpa.database>+        <keycloak.connectionsJpa.user>sa</keycloak.connectionsJpa.user>+        <keycloak.connectionsJpa.password></keycloak.connectionsJpa.password>+        <keycloak.connectionsJpa.url>jdbc:h2:mem:test;MVCC=TRUE;DB_CLOSE_DELAY=-1</keycloak.connectionsJpa.url>+        <jdbc.mvn.groupId>com.h2database</jdbc.mvn.groupId>+        <jdbc.mvn.artifactId>h2</jdbc.mvn.artifactId>+        <jdbc.mvn.version>${h2.version}</jdbc.mvn.version>+        <log4j.configuration>file:${project.build.directory}/dependency/log4j.properties</log4j.configuration>+    </properties>+    +    <dependencies>+        <dependency>+            <groupId>junit</groupId>+            <artifactId>junit</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.hamcrest</groupId>+            <artifactId>hamcrest-all</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>log4j</groupId>+            <artifactId>log4j</artifactId>+        </dependency>+        <dependency>+            <groupId>org.slf4j</groupId>+            <artifactId>slf4j-api</artifactId>+        </dependency>+        <dependency>+            <groupId>org.slf4j</groupId>+            <artifactId>slf4j-log4j12</artifactId>+        </dependency>+        <dependency>+            <groupId>org.keycloak</groupId>+            <artifactId>keycloak-services</artifactId>+        </dependency>+        <dependency>+            <groupId>org.keycloak</groupId>+            <artifactId>keycloak-server-spi-private</artifactId>+        </dependency>+        <dependency>+            <groupId>org.keycloak</groupId>+            <artifactId>keycloak-server-spi</artifactId>+        </dependency>+        <dependency>+            <groupId>${jdbc.mvn.groupId}</groupId>+            <artifactId>${jdbc.mvn.artifactId}</artifactId>+            <version>${jdbc.mvn.version}</version>+            <scope>test</scope>+        </dependency>++        <dependency>+            <groupId>org.keycloak</groupId>+            <artifactId>keycloak-model-jpa</artifactId>+        </dependency>+        <dependency>+            <groupId>org.keycloak</groupId>+            <artifactId>keycloak-model-infinispan</artifactId>+        </dependency>+        <dependency>+            <groupId>org.keycloak</groupId>+            <artifactId>keycloak-model-map</artifactId>+        </dependency>+        <dependency>+            <groupId>org.keycloak.testsuite</groupId>+            <artifactId>integration-arquillian-testsuite-providers</artifactId>+            <version>${project.version}</version>+        </dependency>+    </dependencies>++    <build>",Can we move this to `Jpa.java` similarly as here: https://github.com/keycloak/keycloak/pull/7631/files#diff-adb86e93a714c2707c31d84c0b63fe5c07cd426b7c6d81c83f85f13942a92267R44-R46?,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7599,532845426,2020-11-30T19:29:16Z,server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java,"@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);         if (passwordHistoryPolicyValue != -1) {-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);-            for (CredentialModel cred : storedPasswords) {-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()","Maybe worth to consider this: ```suggestion            if (session.userCredentialManager()                    .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)                    .map(PasswordCredentialModel::createFromCredentialModel)                    .anyMatch(passwordCredential -> {                        PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());                        return hash != null && hash.verify(password, passwordCredential);                    })) {                return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);            }```",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7599,532846451,2020-11-30T19:30:47Z,server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java,"@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);         if (passwordHistoryPolicyValue != -1) {-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);-            for (CredentialModel cred : storedPasswords) {-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()+                    .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)+                    .map(PasswordCredentialModel::createFromCredentialModel)+                    .collect(Collectors.toList());+            for (PasswordCredentialModel passwordCredential : passwordCredentials) {                 PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());-                if (hash == null) continue;-                if (hash.verify(password, passwordCredential)) {+                if (hash != null && hash.verify(password, passwordCredential)) {                     return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);                 }             }              if (passwordHistoryPolicyValue > 0) {-                List<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);-                List<CredentialModel> recentPasswordHistory = getRecent(passwordHistory, passwordHistoryPolicyValue - 1);-                for (CredentialModel cred : recentPasswordHistory) {-                    PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);+                Stream<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);+                List<PasswordCredentialModel> recentPasswordHistory = this.getRecent(passwordHistory, passwordHistoryPolicyValue - 1)+                        .map(PasswordCredentialModel::createFromCredentialModel)+                        .collect(Collectors.toList());+                for (PasswordCredentialModel passwordCredential : recentPasswordHistory) {",Maybe something similar could be used as in suggestion above.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7647,535075793,2020-12-03T10:34:24Z,testsuite/model/pom.xml,"@@ -127,14 +132,28 @@         <profile>             <id>jpa-federation+infinispan</id>",When I run this combination locally I get ```Caused by: org.hibernate.HibernateException: The internal connection pool has reached its maximum size and no connection is currently available!	at org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PooledConnections.poll(DriverManagerConnectionProviderImpl.java:322)	at org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl.getConnection(DriverManagerConnectionProviderImpl.java:189)	at org.hibernate.internal.NonContextualJdbcConnectionAccess.obtainConnection(NonContextualJdbcConnectionAccess.java:35)	at org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.acquireConnectionIfNeeded(LogicalConnectionManagedImpl.java:106)	at org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getPhysicalConnection(LogicalConnectionManagedImpl.java:136)	at org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.getConnectionForTransactionManagement(LogicalConnectionManagedImpl.java:254)	at org.hibernate.resource.jdbc.internal.LogicalConnectionManagedImpl.begin(LogicalConnectionManagedImpl.java:262)	at org.hibernate.resource.transaction.backend.jdbc.internal.JdbcResourceLocalTransactionCoordinatorImpl$TransactionDriverControlImpl.begin(JdbcResourceLocalTransactionCoordinatorImpl.java:236)	at org.hibernate.engine.transaction.internal.TransactionImpl.begin(TransactionImpl.java:86)	at org.keycloak.connections.jpa.JpaKeycloakTransaction.begin(JpaKeycloakTransaction.java:42)	at org.keycloak.services.DefaultKeycloakTransactionManager.enlist(DefaultKeycloakTransactionManager.java:54)	at org.keycloak.connections.jpa.DefaultJpaConnectionProviderFactory.create(DefaultJpaConnectionProviderFactory.java:92)	at org.keycloak.connections.jpa.DefaultJpaConnectionProviderFactory.create(DefaultJpaConnectionProviderFactory.java:59)	at org.keycloak.services.DefaultKeycloakSession.getProvider(DefaultKeycloakSession.java:274)	at org.keycloak.models.jpa.JpaUserProviderFactory.create(JpaUserProviderFactory.java:51)	at org.keycloak.models.jpa.JpaUserProviderFactory.create(JpaUserProviderFactory.java:33)	at org.keycloak.services.DefaultKeycloakSession.getProvider(DefaultKeycloakSession.java:274)	at org.keycloak.services.DefaultKeycloakSession.userLocalStorage(DefaultKeycloakSession.java:194)	at org.keycloak.storage.UserStorageManager.localStorage(UserStorageManager.java:78)	at org.keycloak.storage.UserStorageManager.lambda$addUser$4(UserStorageManager.java:193)```I need to investigate it further to know what is going on and if it's only env issue on my end.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7645,535905894,2020-12-04T08:01:58Z,server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java,"@@ -18,15 +18,52 @@ package org.keycloak.events;  import org.keycloak.events.admin.AdminEvent;+import org.keycloak.models.KeycloakTransaction; import org.keycloak.provider.Provider;  /**  * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>+ *+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it+ * will happen during the main transaction commit. This means the execution, corresponding to the triggered event,+ * may end up with a failure. Therefore, each implementation of this interface should consider using an internal+ * {@link KeycloakTransaction} for firing events only in case the main transaction ends up successfuly. This can be",_Firing_ an event should be precondition for this interface's methods to be invoked. Maybe _persisting_ would express the intention? (same in the javadocs below),
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7645,535986818,2020-12-04T10:13:04Z,server-spi/src/main/java/org/keycloak/models/UserModel.java,"@@ -143,6 +158,11 @@      String getEmail(); +    /**+     * Sets email for this user, email should be switched to lowercase before setting.","This is because JPA layer is doing it [this way](https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java#L331). If we decide to change this to not use lowercase, we should probably do this in separate Jira across whole codebase. ",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7645,535991714,2020-12-04T10:20:47Z,server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java,"@@ -18,15 +18,52 @@ package org.keycloak.events;  import org.keycloak.events.admin.AdminEvent;+import org.keycloak.models.KeycloakTransaction; import org.keycloak.provider.Provider;  /**  * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>+ *+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it+ * will happen during the main transaction commit. This means the execution, corresponding to the triggered event,+ * may end up with a failure. Therefore, each implementation of this interface should consider using an internal+ * {@link KeycloakTransaction} for firing events only in case the main transaction ends up successfuly. This can be","WDYT?```Therefore, each implementation of this interface should consider persisting events and act upon them only when the main transaction was successful. This can be achieved by enlisting the internal transaction to {@link org.keycloak.models.KeycloakTransactionManager} using the {@link org.keycloak.models.KeycloakTransactionManager#enlistAfterCompletion(KeycloakTransaction)} method.```",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7649,536136878,2020-12-04T14:26:48Z,server-spi/src/main/java/org/keycloak/sessions/AuthenticationSessionProvider.java,"@@ -31,27 +31,87 @@     /**      * Creates and registers a new authentication session with random ID. Authentication session      * entity will be prefilled with current timestamp, the given realm and client.+     * @param realm {@code RealmModel}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.      */     RootAuthenticationSessionModel createRootAuthenticationSession(RealmModel realm); -    RootAuthenticationSessionModel createRootAuthenticationSession(String id, RealmModel realm);+    /**+     * Creates a new root authentication session specified by the provided id and realm.+     * @param id {@code String}+     * @param realm {@code RealmModel}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.+     * @deprecated Use {@link #createRootAuthenticationSession(RealmModel, String)} createRootAuthenticationSession} instead.+     */+    @Deprecated+    default RootAuthenticationSessionModel createRootAuthenticationSession(String id, RealmModel realm) {+        return createRootAuthenticationSession(realm, id);+    } +    /**+     * Creates a new root authentication session specified by the provided realm and id.+     * @param realm {@code RealmModel}+     * @param id {@code String}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.+     */+    RootAuthenticationSessionModel createRootAuthenticationSession(RealmModel realm, String id);++    /**+     * Returns the root authentication session specified by the provided realm and id.+     * @param realm {@code RealmModel}+     * @param authenticationSessionId {@code RootAuthenticationSessionModel}+     * @return Returns found {@code RootAuthenticationSessionModel} or {@code null} if no root authentication session is found.+     */     RootAuthenticationSessionModel getRootAuthenticationSession(RealmModel realm, String authenticationSessionId); -    void removeRootAuthenticationSession(RealmModel realm, RootAuthenticationSessionModel authenticationSession);+    /**+     * Removes provided root authentication session.+     * @param realm {@code RealmModel}+     * @param authenticationSession {@code RootAuthenticationSessionModel}+     * @deprecated Use {@link #removeRootAuthenticationSession(RootAuthenticationSessionModel)} removeRootAuthenticationSession} instead.+     */+    @Deprecated+    default void removeRootAuthenticationSession(RealmModel realm, RootAuthenticationSessionModel authenticationSession) {+        removeRootAuthenticationSession(authenticationSession);+    }++    /**+     * Removes provided root authentication session.+     * @param authenticationSession {@code RootAuthenticationSessionModel}+     */+    void removeRootAuthenticationSession(RootAuthenticationSessionModel authenticationSession);","Because I deprecated `removeRootAuthenticationSession(RealmModel realm, RootAuthenticationSessionModel authenticationSession)` as realm parameter is not used.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7649,536197569,2020-12-04T15:52:38Z,server-spi/src/main/java/org/keycloak/sessions/AuthenticationSessionProvider.java,"@@ -31,27 +31,87 @@     /**      * Creates and registers a new authentication session with random ID. Authentication session      * entity will be prefilled with current timestamp, the given realm and client.+     * @param realm {@code RealmModel}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.      */     RootAuthenticationSessionModel createRootAuthenticationSession(RealmModel realm); -    RootAuthenticationSessionModel createRootAuthenticationSession(String id, RealmModel realm);+    /**+     * Creates a new root authentication session specified by the provided id and realm.+     * @param id {@code String}+     * @param realm {@code RealmModel}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.+     * @deprecated Use {@link #createRootAuthenticationSession(RealmModel, String)} createRootAuthenticationSession} instead.+     */+    @Deprecated+    default RootAuthenticationSessionModel createRootAuthenticationSession(String id, RealmModel realm) {+        return createRootAuthenticationSession(realm, id);+    } +    /**+     * Creates a new root authentication session specified by the provided realm and id.+     * @param realm {@code RealmModel}+     * @param id {@code String}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.+     */+    RootAuthenticationSessionModel createRootAuthenticationSession(RealmModel realm, String id);++    /**+     * Returns the root authentication session specified by the provided realm and id.+     * @param realm {@code RealmModel}+     * @param authenticationSessionId {@code RootAuthenticationSessionModel}+     * @return Returns found {@code RootAuthenticationSessionModel} or {@code null} if no root authentication session is found.+     */     RootAuthenticationSessionModel getRootAuthenticationSession(RealmModel realm, String authenticationSessionId); -    void removeRootAuthenticationSession(RealmModel realm, RootAuthenticationSessionModel authenticationSession);+    /**+     * Removes provided root authentication session.+     * @param realm {@code RealmModel}+     * @param authenticationSession {@code RootAuthenticationSessionModel}+     * @deprecated Use {@link #removeRootAuthenticationSession(RootAuthenticationSessionModel)} removeRootAuthenticationSession} instead.+     */+    @Deprecated+    default void removeRootAuthenticationSession(RealmModel realm, RootAuthenticationSessionModel authenticationSession) {+        removeRootAuthenticationSession(authenticationSession);+    }++    /**+     * Removes provided root authentication session.+     * @param authenticationSession {@code RootAuthenticationSessionModel}+     */+    void removeRootAuthenticationSession(RootAuthenticationSessionModel authenticationSession);",Realm parameter is not used in the current implementation but is necessary to be retained for larger deployments with different logic of distributing sessions could leverage it.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7649,536197651,2020-12-04T15:52:44Z,server-spi/src/main/java/org/keycloak/sessions/AuthenticationSessionProvider.java,"@@ -31,27 +31,87 @@     /**      * Creates and registers a new authentication session with random ID. Authentication session      * entity will be prefilled with current timestamp, the given realm and client.+     * @param realm {@code RealmModel}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.      */     RootAuthenticationSessionModel createRootAuthenticationSession(RealmModel realm); -    RootAuthenticationSessionModel createRootAuthenticationSession(String id, RealmModel realm);+    /**+     * Creates a new root authentication session specified by the provided id and realm.+     * @param id {@code String}+     * @param realm {@code RealmModel}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.+     * @deprecated Use {@link #createRootAuthenticationSession(RealmModel, String)} createRootAuthenticationSession} instead.+     */+    @Deprecated+    default RootAuthenticationSessionModel createRootAuthenticationSession(String id, RealmModel realm) {+        return createRootAuthenticationSession(realm, id);+    } +    /**+     * Creates a new root authentication session specified by the provided realm and id.+     * @param realm {@code RealmModel}+     * @param id {@code String}+     * @return Returns created {@code RootAuthenticationSessionModel}. Never returns {@code null}.+     */+    RootAuthenticationSessionModel createRootAuthenticationSession(RealmModel realm, String id);++    /**+     * Returns the root authentication session specified by the provided realm and id.+     * @param realm {@code RealmModel}+     * @param authenticationSessionId {@code RootAuthenticationSessionModel}+     * @return Returns found {@code RootAuthenticationSessionModel} or {@code null} if no root authentication session is found.+     */     RootAuthenticationSessionModel getRootAuthenticationSession(RealmModel realm, String authenticationSessionId); -    void removeRootAuthenticationSession(RealmModel realm, RootAuthenticationSessionModel authenticationSession);+    /**+     * Removes provided root authentication session.+     * @param realm {@code RealmModel}+     * @param authenticationSession {@code RootAuthenticationSessionModel}+     * @deprecated Use {@link #removeRootAuthenticationSession(RootAuthenticationSessionModel)} removeRootAuthenticationSession} instead.+     */+    @Deprecated+    default void removeRootAuthenticationSession(RealmModel realm, RootAuthenticationSessionModel authenticationSession) {+        removeRootAuthenticationSession(authenticationSession);+    }++    /**+     * Removes provided root authentication session.+     * @param authenticationSession {@code RootAuthenticationSessionModel}+     */+    void removeRootAuthenticationSession(RootAuthenticationSessionModel authenticationSession); +    /**+     * Removes a root authentication session by the given id.+     * @param id {@code String}+     */+    void removeRootAuthenticationSessionById(String id);","This needs to be done via the other method. Auth sessions are always tied to realm, `RealmModel` is thus a mandatory parameter.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7636,537551240,2020-12-07T14:31:27Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -747,99 +747,119 @@ module.controller('RealmPasswordPolicyCtrl', function($scope, Realm, realm, $htt     }; }); -module.controller('RealmDefaultRolesCtrl', function ($scope, $route, Realm, realm, roles, Notifications, ClientRole, Client) {+module.controller('RealmDefaultRolesCtrl', function ($scope, $route, realm, roles, Notifications, ClientRole, Client, RoleRealmComposites, RoleClientComposites, ComponentUtils, $http) {      console.log('RealmDefaultRolesCtrl');      $scope.realm = realm;--    $scope.availableRealmRoles = [];+    $scope.availableRealmRoles = angular.copy(roles);     $scope.selectedRealmRoles = [];     $scope.selectedRealmDefRoles = [];      $scope.availableClientRoles = [];     $scope.selectedClientRoles = [];     $scope.selectedClientDefRoles = []; -    if (!$scope.realm.hasOwnProperty('defaultRoles') || $scope.realm.defaultRoles === null) {-        $scope.realm.defaultRoles = [];+    for (var j = 0; j < $scope.availableRealmRoles.length; j++) {+        if ($scope.availableRealmRoles[j].id === realm.defaultRole.id) {+            var realmRole = $scope.availableRealmRoles[j];+            var idx = $scope.availableRealmRoles.indexOf(realmRole);+            $scope.availableRealmRoles.splice(idx, 1);+            break;+        }     } -    // Populate available roles. Available roles are neither already assigned-    for (var i = 0; i < roles.length; i++) {-        var item = roles[i].name;--        if ($scope.realm.defaultRoles.indexOf(item) < 0) {-            $scope.availableRealmRoles.push(item);+    $scope.realmMappings = RoleRealmComposites.query({realm : realm.realm, role : realm.defaultRole.id}, function(){+        for (var i = 0; i < $scope.realmMappings.length; i++) {+            var role = $scope.realmMappings[i];+            for (var j = 0; j < $scope.availableRealmRoles.length; j++) {+                var realmRole = $scope.availableRealmRoles[j];+                if (realmRole.id === role.id) {+                    var idx = $scope.availableRealmRoles.indexOf(realmRole);+                    if (idx !== -1) {+                        $scope.availableRealmRoles.splice(idx, 1);+                        break;+                    }+                }+            }         }-    }+    });      $scope.addRealmDefaultRole = function () { -        // Remove selected roles from the Available roles and add them to realm default roles (move from left to right).-        for (var i = 0; i < $scope.selectedRealmRoles.length; i++) {-            var selectedRole = $scope.selectedRealmRoles[i];--            $scope.realm.defaultRoles.push(selectedRole);--            var index = $scope.availableRealmRoles.indexOf(selectedRole);-            if (index > -1) {-                $scope.availableRealmRoles.splice(index, 1);+        $scope.selectedRealmRolesToAdd = JSON.parse('[' + $scope.selectedRealmRoles + ']');+        $http.post(authUrl + '/admin/realms/' + realm.realm + '/roles-by-id/' + realm.defaultRole.id + '/composites',+            $scope.selectedRealmRolesToAdd).then(function() {+            // Remove selected roles from the Available roles and add them to realm default roles (move from left to right).+            for (var i = 0; i < $scope.selectedRealmRolesToAdd.length; i++) {+                var selectedRole = $scope.selectedRealmRolesToAdd[i];+                var index = ComponentUtils.findIndexById($scope.availableRealmRoles, selectedRole.id);+                if (index > -1) {+                    $scope.availableRealmRoles.splice(index, 1);+                    $scope.realmMappings.push(selectedRole);+                }             }-        }--        $scope.selectedRealmRoles = []; -        // Update/save the realm with new default roles.-        Realm.update($scope.realm, function () {-            Notifications.success(""Realm default roles updated."");+            $scope.selectedRealmRoles = [];+            $scope.selectedRealmRolesToAdd = [];+            Notifications.success(""Default roles updated."");         });     };      $scope.deleteRealmDefaultRole = function () { -        // Remove selected roles from the realm default roles and add them to available roles (move from right to left).-        for (var i = 0; i < $scope.selectedRealmDefRoles.length; i++) {-            $scope.availableRealmRoles.push($scope.selectedRealmDefRoles[i]);--            var index = $scope.realm.defaultRoles.indexOf($scope.selectedRealmDefRoles[i]);-            if (index > -1) {-                $scope.realm.defaultRoles.splice(index, 1);+        $scope.selectedClientRolesToRemove = JSON.parse('[' + $scope.selectedRealmDefRoles + ']');+        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/roles-by-id/' + realm.defaultRole.id + '/composites',","This seems like a duplicity of this: https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/base/admin/resources/js/services.js#L1059If I understand it correctly this function should provide all functionality necessary for default tab to work, so we could remove almost all code from here and add just call to `roleControl()` function. Have you tried it?",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7652,537750240,2020-12-07T18:57:32Z,services/src/main/java/org/keycloak/services/resources/account/SessionResource.java,"@@ -88,33 +89,31 @@ public SessionResource(KeycloakSession session, Auth auth, HttpRequest request)     @NoCache     public Collection<DeviceRepresentation> devices() {","We can change it to stream, but I don't see how to make use of something like you mentioned. If I could map the session into devices then I could filter the devices as shown in that example, but then I would no longer have a reference to the session and it is needed to properly create the device representation.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7636,538217841,2020-12-08T10:27:23Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -747,99 +747,119 @@ module.controller('RealmPasswordPolicyCtrl', function($scope, Realm, realm, $htt     }; }); -module.controller('RealmDefaultRolesCtrl', function ($scope, $route, Realm, realm, roles, Notifications, ClientRole, Client) {+module.controller('RealmDefaultRolesCtrl', function ($scope, $route, realm, roles, Notifications, ClientRole, Client, RoleRealmComposites, RoleClientComposites, ComponentUtils, $http) {      console.log('RealmDefaultRolesCtrl');      $scope.realm = realm;--    $scope.availableRealmRoles = [];+    $scope.availableRealmRoles = angular.copy(roles);     $scope.selectedRealmRoles = [];     $scope.selectedRealmDefRoles = [];      $scope.availableClientRoles = [];     $scope.selectedClientRoles = [];     $scope.selectedClientDefRoles = []; -    if (!$scope.realm.hasOwnProperty('defaultRoles') || $scope.realm.defaultRoles === null) {-        $scope.realm.defaultRoles = [];+    for (var j = 0; j < $scope.availableRealmRoles.length; j++) {+        if ($scope.availableRealmRoles[j].id === realm.defaultRole.id) {+            var realmRole = $scope.availableRealmRoles[j];+            var idx = $scope.availableRealmRoles.indexOf(realmRole);+            $scope.availableRealmRoles.splice(idx, 1);+            break;+        }     } -    // Populate available roles. Available roles are neither already assigned-    for (var i = 0; i < roles.length; i++) {-        var item = roles[i].name;--        if ($scope.realm.defaultRoles.indexOf(item) < 0) {-            $scope.availableRealmRoles.push(item);+    $scope.realmMappings = RoleRealmComposites.query({realm : realm.realm, role : realm.defaultRole.id}, function(){+        for (var i = 0; i < $scope.realmMappings.length; i++) {+            var role = $scope.realmMappings[i];+            for (var j = 0; j < $scope.availableRealmRoles.length; j++) {+                var realmRole = $scope.availableRealmRoles[j];+                if (realmRole.id === role.id) {+                    var idx = $scope.availableRealmRoles.indexOf(realmRole);+                    if (idx !== -1) {+                        $scope.availableRealmRoles.splice(idx, 1);+                        break;+                    }+                }+            }         }-    }+    });      $scope.addRealmDefaultRole = function () { -        // Remove selected roles from the Available roles and add them to realm default roles (move from left to right).-        for (var i = 0; i < $scope.selectedRealmRoles.length; i++) {-            var selectedRole = $scope.selectedRealmRoles[i];--            $scope.realm.defaultRoles.push(selectedRole);--            var index = $scope.availableRealmRoles.indexOf(selectedRole);-            if (index > -1) {-                $scope.availableRealmRoles.splice(index, 1);+        $scope.selectedRealmRolesToAdd = JSON.parse('[' + $scope.selectedRealmRoles + ']');+        $http.post(authUrl + '/admin/realms/' + realm.realm + '/roles-by-id/' + realm.defaultRole.id + '/composites',+            $scope.selectedRealmRolesToAdd).then(function() {+            // Remove selected roles from the Available roles and add them to realm default roles (move from left to right).+            for (var i = 0; i < $scope.selectedRealmRolesToAdd.length; i++) {+                var selectedRole = $scope.selectedRealmRolesToAdd[i];+                var index = ComponentUtils.findIndexById($scope.availableRealmRoles, selectedRole.id);+                if (index > -1) {+                    $scope.availableRealmRoles.splice(index, 1);+                    $scope.realmMappings.push(selectedRole);+                }             }-        }--        $scope.selectedRealmRoles = []; -        // Update/save the realm with new default roles.-        Realm.update($scope.realm, function () {-            Notifications.success(""Realm default roles updated."");+            $scope.selectedRealmRoles = [];+            $scope.selectedRealmRolesToAdd = [];+            Notifications.success(""Default roles updated."");         });     };      $scope.deleteRealmDefaultRole = function () { -        // Remove selected roles from the realm default roles and add them to available roles (move from right to left).-        for (var i = 0; i < $scope.selectedRealmDefRoles.length; i++) {-            $scope.availableRealmRoles.push($scope.selectedRealmDefRoles[i]);--            var index = $scope.realm.defaultRoles.indexOf($scope.selectedRealmDefRoles[i]);-            if (index > -1) {-                $scope.realm.defaultRoles.splice(index, 1);+        $scope.selectedClientRolesToRemove = JSON.parse('[' + $scope.selectedRealmDefRoles + ']');+        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/roles-by-id/' + realm.defaultRole.id + '/composites',","I was trying to re-use `roleControl` method [1] but I wasn't able to do it successfully. So I ended up with current state. But if you know how to do it, I'll be grateful for the advise (or contribution :) ).[1] https://github.com/keycloak/keycloak/blob/master/themes/src/main/resources/theme/base/admin/resources/js/services.js#L965",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7645,538754005,2020-12-08T19:40:43Z,server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java,"@@ -214,7 +214,7 @@ default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {      * @param firstResult      * @param maxResults      * @return-     * @deprecated Use {@link #searchForUserStream(String, RealmModel, int, int) searchForUserStream} instead.+     * @deprecated Use {@link #searchForUserStream(String, RealmModel, Integer, Integer) searchForUserStream} instead.      */     @Deprecated     List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults);",Should we also update `UserPropertyFileStorage` from testsuite-providers to implement stream-Integer variant instead of the deprecated one?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7645,539077157,2020-12-09T07:45:07Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java,"@@ -152,18 +162,10 @@ private void removeUser(UserEntity user) {         String id = user.getId();         em.createNamedQuery(""deleteUserRoleMappingsByUser"").setParameter(""user"", user).executeUpdate();         em.createNamedQuery(""deleteUserGroupMembershipsByUser"").setParameter(""user"", user).executeUpdate();-        em.createNamedQuery(""deleteFederatedIdentityByUser"").setParameter(""user"", user).executeUpdate();","Yop you are right, with the second comment. If I understood it correctly the way it was before was causing some exception, that is why there was needed to call `flush()` twice and also `clear()`.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7645,539087160,2020-12-09T08:03:46Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LoginTest.java,"@@ -89,11 +90,11 @@  * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>  */ public class LoginTest extends AbstractTestRealmKeycloakTest {-+    ","I always thought that when I see this in a commit it is something that was there before, and Intellij is automatically fixing it. I hope it is not always the other way around, that I accidentally added it. Thanks for spotting this I will be checking this in future commits.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7645,539105008,2020-12-09T08:30:49Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPBinaryAttributesTest.java,"@@ -156,18 +158,16 @@ public void test03WritableMapper() {         // Assert he is found including jpegPhoto         joe = getUserAndAssertPhoto(""joephoto"", true); +        // Assert that local storage doesn't contain LDAPConstants.JPEG_PHOTO, it should be stored in the LDAP+        String joeId = joe.getId();+        testingClient.server().run(session -> {+            RealmModel test = session.realms().getRealmByName(""test"");+            UserModel userById = session.userLocalStorage().getUserById(joeId, test);++            assertThat(userById.getAttributes().get(LDAPConstants.JPEG_PHOTO), is(nullValue()));+        }); -        // Try to update him with some big non-LDAP mapped attribute. It will fail-        try {-            joe.getAttributes().put(""someOtherPhoto"", Arrays.asList(JPEG_PHOTO_BASE64));-            adminClient.realm(""test"").users().get(joe.getId()).update(joe);-            Assert.fail(""Not expected to successfully update user"");-        } catch (ClientErrorException cee) {-            // Expected-        }","This test is testing that attribute with name `LDAPConstants.JPEG_PHOTO` is not stored in local storage but in LDAP because of the mapper created on line 147. The original implementation was relying on the fact that the database is not even able to store such a long value > 255 character (probably depending on DB). This means that if storing of  `LDAPConstants.JPEG_PHOTO` attribute passed it was not stored in DB but in LDAP. However, if we try to store attribute `someOtherPhoto` with the same value, it will throw `ClientErrorException` because this time DB will refuse the value.However, with Map storage we can store such values, therefore this test was not working correctly. I changed it so that we are not testing based on DB refusing the value, but we just check local storage for the attribute not to be present there.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7636,539226352,2020-12-09T11:25:50Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -747,99 +747,119 @@ module.controller('RealmPasswordPolicyCtrl', function($scope, Realm, realm, $htt     }; }); -module.controller('RealmDefaultRolesCtrl', function ($scope, $route, Realm, realm, roles, Notifications, ClientRole, Client) {+module.controller('RealmDefaultRolesCtrl', function ($scope, $route, realm, roles, Notifications, ClientRole, Client, RoleRealmComposites, RoleClientComposites, ComponentUtils, $http) {      console.log('RealmDefaultRolesCtrl');      $scope.realm = realm;--    $scope.availableRealmRoles = [];+    $scope.availableRealmRoles = angular.copy(roles);     $scope.selectedRealmRoles = [];     $scope.selectedRealmDefRoles = [];      $scope.availableClientRoles = [];     $scope.selectedClientRoles = [];     $scope.selectedClientDefRoles = []; -    if (!$scope.realm.hasOwnProperty('defaultRoles') || $scope.realm.defaultRoles === null) {-        $scope.realm.defaultRoles = [];+    for (var j = 0; j < $scope.availableRealmRoles.length; j++) {+        if ($scope.availableRealmRoles[j].id === realm.defaultRole.id) {+            var realmRole = $scope.availableRealmRoles[j];+            var idx = $scope.availableRealmRoles.indexOf(realmRole);+            $scope.availableRealmRoles.splice(idx, 1);+            break;+        }     } -    // Populate available roles. Available roles are neither already assigned-    for (var i = 0; i < roles.length; i++) {-        var item = roles[i].name;--        if ($scope.realm.defaultRoles.indexOf(item) < 0) {-            $scope.availableRealmRoles.push(item);+    $scope.realmMappings = RoleRealmComposites.query({realm : realm.realm, role : realm.defaultRole.id}, function(){+        for (var i = 0; i < $scope.realmMappings.length; i++) {+            var role = $scope.realmMappings[i];+            for (var j = 0; j < $scope.availableRealmRoles.length; j++) {+                var realmRole = $scope.availableRealmRoles[j];+                if (realmRole.id === role.id) {+                    var idx = $scope.availableRealmRoles.indexOf(realmRole);+                    if (idx !== -1) {+                        $scope.availableRealmRoles.splice(idx, 1);+                        break;+                    }+                }+            }         }-    }+    });      $scope.addRealmDefaultRole = function () { -        // Remove selected roles from the Available roles and add them to realm default roles (move from left to right).-        for (var i = 0; i < $scope.selectedRealmRoles.length; i++) {-            var selectedRole = $scope.selectedRealmRoles[i];--            $scope.realm.defaultRoles.push(selectedRole);--            var index = $scope.availableRealmRoles.indexOf(selectedRole);-            if (index > -1) {-                $scope.availableRealmRoles.splice(index, 1);+        $scope.selectedRealmRolesToAdd = JSON.parse('[' + $scope.selectedRealmRoles + ']');+        $http.post(authUrl + '/admin/realms/' + realm.realm + '/roles-by-id/' + realm.defaultRole.id + '/composites',+            $scope.selectedRealmRolesToAdd).then(function() {+            // Remove selected roles from the Available roles and add them to realm default roles (move from left to right).+            for (var i = 0; i < $scope.selectedRealmRolesToAdd.length; i++) {+                var selectedRole = $scope.selectedRealmRolesToAdd[i];+                var index = ComponentUtils.findIndexById($scope.availableRealmRoles, selectedRole.id);+                if (index > -1) {+                    $scope.availableRealmRoles.splice(index, 1);+                    $scope.realmMappings.push(selectedRole);+                }             }-        }--        $scope.selectedRealmRoles = []; -        // Update/save the realm with new default roles.-        Realm.update($scope.realm, function () {-            Notifications.success(""Realm default roles updated."");+            $scope.selectedRealmRoles = [];+            $scope.selectedRealmRolesToAdd = [];+            Notifications.success(""Default roles updated."");         });     };      $scope.deleteRealmDefaultRole = function () { -        // Remove selected roles from the realm default roles and add them to available roles (move from right to left).-        for (var i = 0; i < $scope.selectedRealmDefRoles.length; i++) {-            $scope.availableRealmRoles.push($scope.selectedRealmDefRoles[i]);--            var index = $scope.realm.defaultRoles.indexOf($scope.selectedRealmDefRoles[i]);-            if (index > -1) {-                $scope.realm.defaultRoles.splice(index, 1);+        $scope.selectedClientRolesToRemove = JSON.parse('[' + $scope.selectedRealmDefRoles + ']');+        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/roles-by-id/' + realm.defaultRole.id + '/composites',","I don't know how to do it, I just saw it has some similar parts so I was wondering whether it is possible to use it.  But if you tried it and it didn't work, lets leave it as it is.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7645,539255660,2020-12-09T12:13:18Z,server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java,"@@ -214,7 +214,7 @@ default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {      * @param firstResult      * @param maxResults      * @return-     * @deprecated Use {@link #searchForUserStream(String, RealmModel, int, int) searchForUserStream} instead.+     * @deprecated Use {@link #searchForUserStream(String, RealmModel, Integer, Integer) searchForUserStream} instead.      */     @Deprecated     List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults);","At this moment, either option is open. It would be better to follow @vramik's suggestion if that does not represent a big amount of work at this point. In the opposite case, we can postpone this for either cleanup or even later when removing the interaces.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7652,539808208,2020-12-10T03:01:33Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java,"@@ -112,10 +113,8 @@ public void testOfflineSessionsCrud(KeycloakSession session) {             // Key is userSession ID, values are client UUIDS             // Persist 3 created userSessions and clientSessions as offline             ClientModel testApp = realm.getClientByClientId(""test-app"");-            List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp);-            for (UserSessionModel userSession : userSessions) {-                offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));-            }+            currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())","It doesn't work in this case because createOfflineSessionIncludeClientSessions is creating new sessions while the stream is still being processed, which leads to concurrent modification exception. The prior approach collects the elements first and then attempts to add new offline sessions which now doesn't make changes to the stream source.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7657,540843524,2020-12-11T10:24:14Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java,"@@ -0,0 +1,80 @@+package org.keycloak.connections.jpa.updater.liquibase.custom;++import java.util.HashMap;+import java.util.HashSet;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;++import liquibase.change.ChangeMetaData;+import liquibase.change.DatabaseChange;+import liquibase.change.DatabaseChangeNote;+import liquibase.change.core.CreateIndexChange;+import liquibase.database.AbstractJdbcDatabase;+import liquibase.database.Database;+import liquibase.exception.DatabaseException;+import liquibase.exception.UnexpectedLiquibaseException;+import liquibase.executor.ExecutorService;+import liquibase.executor.LoggingExecutor;+import liquibase.snapshot.InvalidExampleException;+import liquibase.snapshot.SnapshotGeneratorFactory;+import liquibase.statement.SqlStatement;+import liquibase.statement.core.RawSqlStatement;+import liquibase.structure.core.Index;+import liquibase.structure.core.Schema;+import liquibase.structure.core.Table;++public class CustomCreateIndexChange extends CreateIndexChange {+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);++    @Override+    public SqlStatement[] generateStatements(Database database) {+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)+            return super.generateStatements(database);++        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);++        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)+            return super.generateStatements(database);++        try {+            if (!SnapshotGeneratorFactory.getInstance()+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))+                return super.generateStatements(database);++            int result = ExecutorService.getInstance().getExecutor(database)+                .queryForInt(new RawSqlStatement(""select count(*) from"" + getTableName()));","Have you chance to test this sql in various databases like MySQL, Oracle, Portgres and MSSQL? It seems there is missing whitespace character after `from` keyword. If I remember correctly there is also a need to properly escape schema for `select` statements when the table name is retrieved. Please see `CustomKeycloakTask.getTableName(String)` for more details.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7657,540846141,2020-12-11T10:28:17Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java,"@@ -109,12 +116,14 @@ protected void baseLiquibaseInitialization() {          // Use ""SELECT FOR UPDATE"" for locking database         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());-    } +        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);",I'd suggest to add a `//` comment with a note the `CustomCreateIndexChange` is registered for handle conditional indices creation,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7657,540880855,2020-12-11T11:27:52Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java,"@@ -0,0 +1,80 @@+package org.keycloak.connections.jpa.updater.liquibase.custom;++import java.util.HashMap;+import java.util.HashSet;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;++import liquibase.change.ChangeMetaData;+import liquibase.change.DatabaseChange;+import liquibase.change.DatabaseChangeNote;+import liquibase.change.core.CreateIndexChange;+import liquibase.database.AbstractJdbcDatabase;+import liquibase.database.Database;+import liquibase.exception.DatabaseException;+import liquibase.exception.UnexpectedLiquibaseException;+import liquibase.executor.ExecutorService;+import liquibase.executor.LoggingExecutor;+import liquibase.snapshot.InvalidExampleException;+import liquibase.snapshot.SnapshotGeneratorFactory;+import liquibase.statement.SqlStatement;+import liquibase.statement.core.RawSqlStatement;+import liquibase.structure.core.Index;+import liquibase.structure.core.Schema;+import liquibase.structure.core.Table;++public class CustomCreateIndexChange extends CreateIndexChange {+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);++    @Override+    public SqlStatement[] generateStatements(Database database) {+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)+            return super.generateStatements(database);++        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);++        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)",I'd suggest to introduce `private int indexCreationThreshold;` in this class and I'd also suggest following```suggestion        if (indexCreationThreshold instanceof Integer) {            this.indexCreationThreshold = (Integer) indexCreationThreshold;            if (this.indexCreationThreshold <= 0) return super.generateStatements(database);        } else {            return super.generateStatements(database);        }````instanceof ` should take care of `null` and we can avoid type casting on line 50. wdyt?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7640,542500380,2020-12-14T16:00:54Z,services/src/main/java/org/keycloak/authentication/authenticators/access/AllowAccessAuthenticatorFactory.java,"@@ -0,0 +1,101 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.authenticators.access;++import org.keycloak.Config;+import org.keycloak.authentication.Authenticator;+import org.keycloak.authentication.AuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;++import java.util.List;++/**+ * @author <a href=""mailto:mabartos@redhat.com"">Martin Bartos</a>+ */+public class AllowAccessAuthenticatorFactory implements AuthenticatorFactory {+    private final static AllowAccessAuthenticator SINGLETON = new AllowAccessAuthenticator();+    public static final String PROVIDER_ID = ""allow-access-authenticator"";++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    @Override+    public Authenticator create(KeycloakSession session) {+        return SINGLETON;+    }++    @Override+    public String getDisplayType() {+        return ""Allow access"";+    }++    @Override+    public String getReferenceCategory() {+        return null;+    }++    @Override+    public boolean isConfigurable() {+        return false;+    }++    private static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {+            AuthenticationExecutionModel.Requirement.REQUIRED,+            AuthenticationExecutionModel.Requirement.DISABLED+    };++    @Override+    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {+        return REQUIREMENT_CHOICES;+    }++    @Override+    public boolean isUserSetupAllowed() {+        return false;+    }++    @Override+    public String getHelpText() {+        return ""Allow access in conditional flows after satisfying the previous conditions."";","From the description, it seems the authenticator is applicable just in the conditional flows, but this is not true? So I would slightly change the description to maybe something like ""Authenticator will always successfully authenticate. Useful for example in the conditional flows to be used after satisfying the previous conditions""",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7640,542502141,2020-12-14T16:03:05Z,services/src/main/java/org/keycloak/authentication/authenticators/access/DenyAccessAuthenticatorFactory.java,"@@ -0,0 +1,102 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.authenticators.access;++import org.keycloak.Config;+import org.keycloak.authentication.Authenticator;+import org.keycloak.authentication.AuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;++import java.util.List;++/**+ * @author <a href=""mailto:mabartos@redhat.com"">Martin Bartos</a>+ */+public class DenyAccessAuthenticatorFactory implements AuthenticatorFactory {+    private static final DenyAccessAuthenticator SINGLETON = new DenyAccessAuthenticator();+    public static final String PROVIDER_ID = ""deny-access-authenticator"";++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    @Override+    public Authenticator create(KeycloakSession session) {+        return SINGLETON;+    }++    @Override+    public String getDisplayType() {+        return ""Deny access"";+    }++    @Override+    public String getReferenceCategory() {+        return null;+    }++    @Override+    public boolean isConfigurable() {+        return false;+    }++    private static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {+            AuthenticationExecutionModel.Requirement.REQUIRED,+            AuthenticationExecutionModel.Requirement.DISABLED+    };++    @Override+    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {+        return REQUIREMENT_CHOICES;+    }++    @Override+    public boolean isUserSetupAllowed() {+        return false;+    }++    @Override+    public String getHelpText() {+        return ""Deny access in conditional flows after satisfying the previous conditions."";",I think the similar comment applies here like I used for the AllowAccessAuthenticatorFactory.getHelpText() ?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7640,542510440,2020-12-14T16:13:43Z,services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalRoleAuthenticatorFactory.java,"@@ -81,7 +73,19 @@ public String getHelpText() {      @Override     public List<ProviderConfigProperty> getConfigProperties() {-        return commonConfig;+        ProviderConfigProperty role = new ProviderConfigProperty();+        role.setType(ProviderConfigProperty.ROLE_TYPE);+        role.setName(CONDITIONAL_USER_ROLE);+        role.setLabel(""User role"");+        role.setHelpText(""Role the user should have to execute this flow. Click 'Select Role' button to browse roles, or just type it in the textbox. To specify an application role the syntax is appname.approle, i.e. myapp.myrole"");++        ProviderConfigProperty negateOutput = new ProviderConfigProperty();+        negateOutput.setType(ProviderConfigProperty.BOOLEAN_TYPE);+        negateOutput.setName(CONF_NEGATE);+        negateOutput.setLabel(""Negate output"");+        negateOutput.setHelpText(""Apply a not to the check result"");","My vote would be to add more details to this help text to make it more obvious for the administrator. Like ""Apply a not to the check result. When this is true, then the condition will evaluate to true just if user does NOT have the specified role. When this is false, the condition will evaluate to true just if user has the specified role"".",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7640,542516171,2020-12-14T16:21:19Z,themes/src/main/resources/theme/base/login/messages/messages_en.properties,"@@ -392,3 +392,8 @@ loggingOutImmediately=Logging you out immediately accountUnusable=Any subsequent use of the application will not be possible with this account userDeletedSuccessfully=User deleted successfully +# Condition Errors in a Conditional flow+conditionFailed=Preconditions were not satisfied.","My vote is to simplify this and only use one failure message like ""You are not allowed to authenticate"" or ""Access denied"" or something like this. This is the only thing, which the typical user should know. He may not be interested (and sometimes he even should know) that the reason of the failed authentication is ""required role"" or ""preconditions were not satisifed"" or ""required authenticators"" . The typical user may not even know what these terms are :-) My vote would be to simplify this to only use single error message. This will hopefully simplify some logic in the authenticators itself around error messages?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7675,543119074,2020-12-15T07:50:45Z,services/src/main/java/org/keycloak/broker/saml/mappers/UsernameTemplateMapper.java,"@@ -92,10 +93,15 @@          TRANSFORMERS.put(""uppercase"", String::toUpperCase);         TRANSFORMERS.put(""lowercase"", String::toLowerCase);+        TRANSFORMERS.put(""localpart"", UsernameTemplateMapper::getEmailLocalPart);     }      public static final String PROVIDER_ID = ""saml-username-idp-mapper""; +    public static String getEmailLocalPart(String email) {+      return email.substring(0, email.lastIndexOf(""@""));","Apologies, I missed a potential for `IndexOutOfBoundsException` here in my preview review. `lastIndexOf` [can return negative value](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#lastIndexOf-int-) and this would [lead to the exception](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#substring(int,%20int)) because -1 < 0When at it, prefer the character form over the `String` one, ie.```suggestion      return email.substring(0, email.lastIndexOf('@'));```",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7657,544343881,2020-12-16T14:31:20Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java,"@@ -0,0 +1,188 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.connections.jpa.updater.liquibase.custom;++import java.io.StringWriter;++import org.jboss.logging.Logger;+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider;+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;++import liquibase.change.AddColumnConfig;+import liquibase.change.ChangeFactory;+import liquibase.change.ChangeMetaData;+import liquibase.change.ChangeParameterMetaData;+import liquibase.change.DatabaseChange;+import liquibase.change.core.CreateIndexChange;+import liquibase.database.AbstractJdbcDatabase;+import liquibase.database.Database;+import liquibase.exception.DatabaseException;+import liquibase.exception.UnexpectedLiquibaseException;+import liquibase.exception.ValidationErrors;+import liquibase.exception.Warnings;+import liquibase.executor.ExecutorService;+import liquibase.executor.LoggingExecutor;+import liquibase.snapshot.InvalidExampleException;+import liquibase.snapshot.SnapshotGeneratorFactory;+import liquibase.sqlgenerator.SqlGeneratorFactory;+import liquibase.statement.SqlStatement;+import liquibase.statement.core.CreateIndexStatement;+import liquibase.statement.core.RawSqlStatement;+import liquibase.structure.core.Schema;+import liquibase.structure.core.Table;++/**+ * @author <a href=""mailto:yoshiyuki.tabata.jy@hitachi.com"">Yoshiyuki Tabata</a>+ */+@DatabaseChange(name = ""createIndex"", description = ""Creates an index on an existing column or set of columns conditionally based on the number of records."", priority = ChangeMetaData.PRIORITY_DEFAULT+    + 1, appliesTo = ""index"")+public class CustomCreateIndexChange extends CreateIndexChange {+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);+    private int indexCreationThreshold;++    @Override+    public SqlStatement[] generateStatements(Database database) {+        // This check is for manual migration+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)+            return super.generateStatements(database);++        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)",What'd you say about idea to create make `DefaultLiquibaseConnectionProvider.indexCreationThreshold` `static` and to introduce ```    public static int getIndexCreationThreshold() {        return indexCreationThreshold;    }```there? We'd then be able to use ```if (DefaultLiquibaseConnectionProvider.getIndexCreationThreshold() <= 0)                return super.generateStatements(database);``` here instead of parsing `Integer` from attributes.,
34849594,y-tabata,https://api.github.com/repos/keycloak/keycloak/pulls/7657,544657580,2020-12-16T22:07:31Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java,"@@ -0,0 +1,188 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.connections.jpa.updater.liquibase.custom;++import java.io.StringWriter;++import org.jboss.logging.Logger;+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider;+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;++import liquibase.change.AddColumnConfig;+import liquibase.change.ChangeFactory;+import liquibase.change.ChangeMetaData;+import liquibase.change.ChangeParameterMetaData;+import liquibase.change.DatabaseChange;+import liquibase.change.core.CreateIndexChange;+import liquibase.database.AbstractJdbcDatabase;+import liquibase.database.Database;+import liquibase.exception.DatabaseException;+import liquibase.exception.UnexpectedLiquibaseException;+import liquibase.exception.ValidationErrors;+import liquibase.exception.Warnings;+import liquibase.executor.ExecutorService;+import liquibase.executor.LoggingExecutor;+import liquibase.snapshot.InvalidExampleException;+import liquibase.snapshot.SnapshotGeneratorFactory;+import liquibase.sqlgenerator.SqlGeneratorFactory;+import liquibase.statement.SqlStatement;+import liquibase.statement.core.CreateIndexStatement;+import liquibase.statement.core.RawSqlStatement;+import liquibase.structure.core.Schema;+import liquibase.structure.core.Table;++/**+ * @author <a href=""mailto:yoshiyuki.tabata.jy@hitachi.com"">Yoshiyuki Tabata</a>+ */+@DatabaseChange(name = ""createIndex"", description = ""Creates an index on an existing column or set of columns conditionally based on the number of records."", priority = ChangeMetaData.PRIORITY_DEFAULT+    + 1, appliesTo = ""index"")+public class CustomCreateIndexChange extends CreateIndexChange {+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);+    private int indexCreationThreshold;++    @Override+    public SqlStatement[] generateStatements(Database database) {+        // This check is for manual migration+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)+            return super.generateStatements(database);++        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);++        if (indexCreationThreshold instanceof Integer) {+            this.indexCreationThreshold = (Integer) indexCreationThreshold;+            if (this.indexCreationThreshold <= 0)+                return super.generateStatements(database);+        } else {+            return super.generateStatements(database);+        }+        try {+            if (!SnapshotGeneratorFactory.getInstance()+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))+                return super.generateStatements(database);++            int result = ExecutorService.getInstance().getExecutor(database).queryForInt(+                new RawSqlStatement(""SELECT COUNT(*) FROM "" + getTableNameForSqlSelects(database, getTableName())));++            if (result > this.indexCreationThreshold) {+                String loggingString = createLoggingString(database);+                logger.warnv(""Following index should be created: {0}"", loggingString);+                getChangeSet().setComments(loggingString);+                return new SqlStatement[] {};+            }++        } catch (DatabaseException | InvalidExampleException e) {+            throw new UnexpectedLiquibaseException(""Database error while index threshold validation."", e);+        }++        return super.generateStatements(database);+    }++    private String getTableNameForSqlSelects(Database database, String tableName) {+        String correctedSchemaName = database.escapeObjectName(database.getDefaultSchemaName(), Schema.class);+        return LiquibaseJpaUpdaterProvider.getTable(tableName, correctedSchemaName);+    }++    private String createLoggingString(Database database) throws DatabaseException {+        StringWriter writer = new StringWriter();+        LoggingExecutor loggingExecutor = new LoggingExecutor(ExecutorService.getInstance().getExecutor(database), writer,+            database);+        SqlStatement sqlStatement = new CreateIndexStatement(getIndexName(), getCatalogName(), getSchemaName(), getTableName(),+            this.isUnique(), getAssociatedWith(), getColumns().toArray(new AddColumnConfig[getColumns().size()]))+                .setTablespace(getTablespace()).setClustered(getClustered());++        loggingExecutor.execute(sqlStatement);++        return writer.toString();+    }++    @Override+    public boolean generateStatementsVolatile(Database database) {","Without these 3 override methods and without expressly calling the `generateStatements` method of the superclass, the `generateStatements` method of this class is called 14 times in one migration (so the warning outputs 14 times).I also considered the way to add if which judges the caller method by using stack trace in the `generateStatements` method, but I think the current way is smarter.If there is a better way, I'm happy if you tell me.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7677,554475087,2021-01-09T21:28:15Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/KeycloakProcessor.java,"@@ -250,34 +250,30 @@ void configureDevMode(BuildProducer<HotDeploymentWatchedFileBuildItem> hotFiles)         ProviderManager pm = new ProviderManager(KeycloakDeploymentInfo.create().services(), new BuildClassLoader());         Map<Spi, Map<Class<? extends Provider>, Map<String, ProviderFactory>>> factories = new HashMap<>(); -        for (Spi spi : pm.loadSpis()) {+        pm.loadSpis().forEach(spi -> {             Map<Class<? extends Provider>, Map<String, ProviderFactory>> providers = new HashMap<>(); -            for (ProviderFactory factory : pm.load(spi)) {-                if (Arrays.asList(-                        JBossJtaTransactionManagerLookup.class,-                        DefaultJpaConnectionProviderFactory.class,-                        DefaultLiquibaseConnectionProvider.class,-                        LiquibaseJpaUpdaterProviderFactory.class).contains(factory.getClass())) {-                    continue;-                }--                Config.Scope scope = Config.scope(spi.getName(), factory.getId());--                if (isEnabled(factory, scope)) {-                    if (spi.isInternal() && !isInternal(factory)) {-                        ServicesLogger.LOGGER.spiMayChange(factory.getId(), factory.getClass().getName(), spi.getName());-                    }--                    providers.computeIfAbsent(spi.getProviderClass(), aClass -> new HashMap<>()).put(factory.getId(),-                            factory);-                } else {-                    logger.debugv(""SPI {0} provider {1} disabled"", spi.getName(), factory.getId());-                }-            }-+            pm.load(spi).filter(factory -> !Arrays.asList(+                            JBossJtaTransactionManagerLookup.class,+                            DefaultJpaConnectionProviderFactory.class,+                            DefaultLiquibaseConnectionProvider.class,+                            LiquibaseJpaUpdaterProviderFactory.class).contains(factory.getClass()))",Rather predefine a `private static final Set` with the classes and refer to `contains` method of that one instead.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7677,554475177,2021-01-09T21:29:23Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/KeycloakProcessor.java,"@@ -250,34 +250,30 @@ void configureDevMode(BuildProducer<HotDeploymentWatchedFileBuildItem> hotFiles)         ProviderManager pm = new ProviderManager(KeycloakDeploymentInfo.create().services(), new BuildClassLoader());         Map<Spi, Map<Class<? extends Provider>, Map<String, ProviderFactory>>> factories = new HashMap<>(); -        for (Spi spi : pm.loadSpis()) {+        pm.loadSpis().forEach(spi -> {",I'd rather keep this class as it was.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7677,554475958,2021-01-09T21:37:51Z,server-spi-private/src/main/java/org/keycloak/provider/ProviderLoader.java,"@@ -18,6 +18,8 @@ package org.keycloak.provider;  import java.util.List;+import java.util.stream.Collectors;",I'd rather keep this class as is. This is not used often and stream processing here is not beneficial. This applies to dependent classes (like DefaultKeycloakSessionFactory) as well.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7699,555156685,2021-01-11T16:01:04Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java,"@@ -212,6 +212,9 @@ public Response logoutToken() {         try {             session.clientPolicy().triggerOnEvent(new LogoutRequestContext(form));         } catch (ClientPolicyException cpe) {+            if (MtlsHoKTokenUtil.CERT_VERIFY_ERROR_DESC.equals(cpe.getErrorDetail())) {","IMO it will be ideal, if there is no need to have the code here in the class LogoutEndpoint and manually ""translate"" the ClientPolicyException into proper ErrorResponse this way.Because if someone creates custom executor, which want to return special error/errorDescription/responseStatus, he won't be able to do that without changing all the catch blocks in the endpoints. And implementors of the executor providers won't have an option to change the endpoints...Is it possible that eiter:1) ClientPolicyException will encapsulate all the informations needed to construct the proper ErrorResponse. For example the ""status"" code can be added as an additional field to ClientPolicyException (it will be BAD_REQUEST by default and ""error"" field would be INVALID_REQUEST by default)2) There will be another method on the ClientPolicyExecutor to translate ClientPolicyException into the proper JAX-RS exceptionIt seems to me that (1) is simpler to do and probably ok to achieve this task? WDYT?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7673,555328870,2021-01-11T20:50:06Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -88,104 +185,182 @@     }      /**+     * Update client scopes in the stored user consent+     *+     * @param realm a reference to the realm+     * @param userId id of the user+     * @param consent new details of the user consent      *-     * @param realm-     * @param userId-     * @param consent      * @throws ModelException when consent doesn't exist for the userId      */     void updateConsent(RealmModel realm, String userId, UserConsentModel consent);++    /**+     * Remove a user consent given by the user id and client id+     *+     * @param realm a reference to the realm+     * @param userId id of the user+     * @param clientInternalId id of the client+     * @return {@code true} if the consent was removed, {@code false} otherwise+     */     boolean revokeConsentForClient(RealmModel realm, String userId, String clientInternalId); -    void setNotBeforeForUser(RealmModel realm, UserModel user, int notBefore);-    int getNotBeforeOfUser(RealmModel realm, UserModel user);+    /* FEDERATED IDENTITIES methods */      /**+     * Adds a federated identity link for the user within the realm      *-     * @param client-     * @throws IllegalArgumentException when there are more service accounts associated with the given clientId-     * @return+     * @param realm a reference to the realm+     * @param user the user model+     * @param socialLink the federated identity model containing all details of the association between the user and+     *                   the identity provider      */-    UserModel getServiceAccount(ClientModel client);+    void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink);      /**-     * @deprecated Use {@link #getUsersStream(RealmModel, boolean) getUsersStream} instead.+     * Removes federation link between the user and the identity provider given by its id+     *+     * @param realm a reference to the realm+     * @param user the user model+     * @param socialProvider social provider id","What is the ""social provider ID""? I believe it is an internal ID of a identity provider? A link to `{@link org.keycloak.models.IdentityProviderModel.getInternalId()} could help to disambiguate this.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7673,555388005,2021-01-11T22:44:56Z,model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java,"@@ -224,7 +213,7 @@ public FederatedIdentityModel getFederatedIdentity(UserModel user, String social     }      @Override-    public UserModel getUserByFederatedIdentity(FederatedIdentityModel socialLink, RealmModel realm) {+    public UserModel getUserByFederatedIdentity(RealmModel realm, FederatedIdentityModel socialLink) {","nit: Can we use `if (list.isEmpty())` on line 224, 310 and 495?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7673,555403196,2021-01-11T23:24:14Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -38,39 +38,136 @@         UserQueryProvider,         UserRegistrationProvider,         UserBulkUpdateProvider {-    // Note: The reason there are so many query methods here is for layering a cache on top of an persistent KeycloakSession -    void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink);-    boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider);-    void preRemove(RealmModel realm, IdentityProviderModel provider);-    void updateFederatedIdentity(RealmModel realm, UserModel federatedUser, FederatedIdentityModel federatedIdentityModel);+    /**+     * Sets the notBefore value for the given user+     *+     * @param realm a reference to the realm+     * @param user the user model+     * @param notBefore new value for notBefore+     *+     * @throws ModelException when user doesn't exist in the storage+     */+    void setNotBeforeForUser(RealmModel realm, UserModel user, int notBefore);++    /**+     * Gets the notBefore value for the given user+     *+     * @param realm a reference to the realm+     * @param user the user model+     * @return the value of notBefore+     *+     * @throws ModelException when user doesn't exist in the storage+     */+    int getNotBeforeOfUser(RealmModel realm, UserModel user);      /**-     * @deprecated Use {@link #getFederatedIdentitiesStream(UserModel, RealmModel) getFederatedIdentitiesStream} instead.+     * Return a UserModel representing service account of the client+     *+     * @param client the client model+     * @throws IllegalArgumentException when there are more service accounts associated with the given clientId+     * @return userModel representing service account of the client+     */+    UserModel getServiceAccount(ClientModel client);++    /**+     * @deprecated Use {@link #getUsersStream(RealmModel, boolean) getUsersStream} instead.","I've noticed you've removed (or not added) the name of the method from `@deprecated`. I guess it was done for better readability of javadoc, right? Isn't this one omitted? If so there are other places where the method name is present.One way or another I'd suggest to unify it, wdyt? I've commented with word 'name' to other occurrences I've found.But maybe I'm missing something and it really should be this way, in that case please ignore this one and all 'name' comments :)",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7673,555405458,2021-01-11T23:30:14Z,server-spi/src/main/java/org/keycloak/storage/user/UserLookupProvider.java,"@@ -27,16 +27,78 @@  * @version $Revision: 1 $  */ public interface UserLookupProvider {+","I wonder if the original class-level javadoc (line 23,24) shouldn't be updated as well. I might be wrong, but it seems to me it's outdated.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7677,555564602,2021-01-12T07:35:59Z,model/jpa/src/main/java/org/keycloak/models/jpa/GroupAdapter.java,"@@ -123,7 +123,7 @@ public void removeChild(GroupModel subGroup) {     public Stream<GroupModel> getSubGroupsStream() {         TypedQuery<String> query = em.createNamedQuery(""getGroupIdsByParent"", String.class);         query.setParameter(""parent"", group.getId());-        return closing(query.getResultStream().map(realm::getGroupById).filter(Objects::nonNull));+        return closing(query.getResultStream().map(realm::getGroupById).filter(Objects::nonNull).distinct());",The method used to return a set before streamification so I added `distinct()`. Looking more into SQL statement and its semantics I don't really see a situation where duplicate groups can occur.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7677,555622425,2021-01-12T09:22:21Z,model/jpa/src/main/java/org/keycloak/events/jpa/JpaAdminEventQuery.java,"@@ -153,11 +153,11 @@ public AdminEventQuery maxResults(int maxResults) {          TypedQuery<AdminEventEntity> query = em.createQuery(cq); -        if (firstResult != null) {+        if (firstResult != null && firstResult > 0) {",I'd say it doesn't provide big benefit because we still need to check and set `maxResults` to `DEFAULT_MAX_RESULTS`. See the else clause for details.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7673,555720408,2021-01-12T12:03:15Z,server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java,"@@ -173,15 +173,16 @@ default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {     }      /**-     * Search for users with username, email or first + last name that is like search string.+     * Searches for users with username, email or first + last name that is like search string.","Should we do searching like described? As far as I know our implementations doesn't search for all words in `search` separately. The way I understand it, it just checks if any of strings `username`, `email` and `first name + last name` contains `search` string. See https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java#L824-L833. Am I missing something?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7673,555755885,2021-01-12T13:06:39Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java,"@@ -386,41 +379,34 @@ public int getUsersCount(RealmModel realm) {         Stream<LDAPObject> stream = searchLDAP(realm, params).stream()             .filter(ldapObject -> {                 String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());-                return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);+                return (session.userLocalStorage().getUserByUsername(realm, ldapUsername) == null);             });-        if (firstResult > 0)-            stream = stream.skip(firstResult);-        if (maxResults >= 0)-            stream = stream.limit(maxResults);-        return stream.map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));-    } -    @Override-    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {-        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);+        return paginatedStream(stream, firstResult, maxResults).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));     }      @Override     public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, Integer firstResult, Integer maxResults) {+        int first = firstResult == null ? 0 : firstResult;+        int max = maxResults == null ? Integer.MAX_VALUE - 1 : maxResults;","Good question. I basically reused the default value that was there before. However, I am not sure it is correct, maybe we should create a Jira for this as [this](https://github.com/keycloak/keycloak/blob/master/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/membership/MembershipType.java#L87) can cause integer overflow when `firstResult > 1`. @hmlnarik WDYT? ",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7673,555759062,2021-01-12T13:12:16Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -38,39 +38,136 @@         UserQueryProvider,         UserRegistrationProvider,         UserBulkUpdateProvider {-    // Note: The reason there are so many query methods here is for layering a cache on top of an persistent KeycloakSession -    void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink);-    boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider);-    void preRemove(RealmModel realm, IdentityProviderModel provider);-    void updateFederatedIdentity(RealmModel realm, UserModel federatedUser, FederatedIdentityModel federatedIdentityModel);+    /**+     * Sets the notBefore value for the given user+     *+     * @param realm a reference to the realm+     * @param user the user model+     * @param notBefore new value for notBefore+     *+     * @throws ModelException when user doesn't exist in the storage+     */+    void setNotBeforeForUser(RealmModel realm, UserModel user, int notBefore);++    /**+     * Gets the notBefore value for the given user+     *+     * @param realm a reference to the realm+     * @param user the user model+     * @return the value of notBefore+     *+     * @throws ModelException when user doesn't exist in the storage+     */+    int getNotBeforeOfUser(RealmModel realm, UserModel user);      /**-     * @deprecated Use {@link #getFederatedIdentitiesStream(UserModel, RealmModel) getFederatedIdentitiesStream} instead.+     * Return a UserModel representing service account of the client+     *+     * @param client the client model+     * @throws IllegalArgumentException when there are more service accounts associated with the given clientId+     * @return userModel representing service account of the client+     */+    UserModel getServiceAccount(ClientModel client);++    /**+     * @deprecated Use {@link #getUsersStream(RealmModel, boolean) getUsersStream} instead.","This is my mistake. I thought I just accidentally added the method at the end of `@link` block (I thought I pressed something what I should not when Intellij tries to hint the method name), however, it seems that the method name is there on purpose. Thanks for spotting this, I will add the method name everywhere, I think it is more readable when there is only method name, or WDYT?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7673,555777781,2021-01-12T13:42:38Z,server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java,"@@ -323,14 +361,15 @@ default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {     }      /**-     * Get users that belong to a specific group. Implementations do not have to search in UserFederatedStorageProvider+     * Get users that belong to a specific group. Implementations do not have to search in {@code UserFederatedStorageProvider}","I agree, class javadoc would be best place to put this information",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7695,556344225,2021-01-13T08:33:16Z,themes/src/main/resources-community/theme/base/email/messages/messages_cs.properties,"@@ -1,7 +1,7 @@ # encoding: utf-8 emailVerificationSubject=Oven e-mailu-emailVerificationBody=Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu \n\n{0}\n\nTento odkaz vypr za {1} minuty.\n\nPokud jste tento et nevytvoili, tuto zprvu ignorujte.-emailVerificationBodyHtml=<p>Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu. </p><p><a href=""{0}"">Odkaz na oven e-mailov adresy</a></p><p>Platnost odkazu vypr za {1} minut.</p><p>Pokud jste tento et nevytvoili, tuto zprvu ignorujte.</p>+emailVerificationBody=Nkdo vytvoil et {2} s touto e-mailovou adresou. Pokud jste to vy, kliknte na ne uveden odkaz a ovte svou e-mailovou adresu \n\n{0}\n\nTento odkaz vypr za {4}.\n\nPokud jste tento et nevytvoili, tuto zprvu ignorujte.","Why 4th parameter ({4})? When I'm looking at how the `emailVerificationBody` message is used in `email-verification.ftl` `msg(""emailVerificationBody"",link, linkExpiration, realmName, linkExpirationFormatter(linkExpiration))` and I compare it with `en` translation: ""Someone has created a {2} account with this email address. If this was you, click the link below to verify your email address\n\n{0}\n\nThis link will expire within {3}.\n\nIf you didn''t create this account, just ignore this message.""It seems that parameters are indexed from 0 (`link` in this case) which means 4th parameter (`linkExpirationFormatter(linkExpiration)`) will have index 3. This seems to be the case for other translations as well. Am I missing something here?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7673,556399557,2021-01-13T10:01:03Z,server-spi/src/main/java/org/keycloak/storage/user/UserLookupProvider.java,"@@ -27,16 +27,78 @@  * @version $Revision: 1 $  */ public interface UserLookupProvider {+","I see. It works because when you log in, UserStorageManager will search all storage providers, that implement UserLookupProvider, for username/email. This means it should be enough to just implement UserLookupProvider and you should be able, to login with users stored in the storage. If you want some other functionality, for example, managing users via admin console, you need to implement also UserQueryProvider. After that, when UserStorageManager searches for all users, it will consider also users from your storage because you implemented UserQueryProvider. In code, this is handled by methods in [AbstractStorageManager](https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/storage/AbstractStorageManager.java), particularly in [getStorageProviderInstance(...)](https://github.com/keycloak/keycloak/blob/de09bdf32d6ede943bf2b0d60a9a452eef692129/services/src/main/java/org/keycloak/storage/AbstractStorageManager.java#L225) which will check, whether UserStorageProvider implements requested `capabilityInterface`.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,556429998,2021-01-13T10:50:43Z,model/map/src/main/java/org/keycloak/models/map/storage/ModelCriteriaBuilder.java,"@@ -0,0 +1,176 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage;++import org.keycloak.storage.SearchableModelField;++/**+ * Builder for criteria that can be used to limit results obtained from the store.+ * This class is used for similar purpose as e.g. JPA's {@code CriteriaBuilder},+ * however it is much simpler version as it is tailored to very specific needs+ * of future Keycloak store.+ * <p>+ * Implementations are expected to be immutable. The expected use is like this:+ * <pre>+ * cb = storage.getCriteriaBuilder();+ * storage.read(+ *   cb.or(+ *     cb.compare(FIELD1, EQ, 1).compare(FIELD2, EQ, 2),+ *     cb.compare(FIELD1, EQ, 3).compare(FIELD2, EQ, 4)+ *   )+ * );+ * </pre>+ * The above code should read items where+ * {@code (FIELD1 == 1 && FIELD2 == 2) || (FIELD1 == 3 && FIELD2 == 4)}.+ *+ * <p>+ * It is equivalent to this:+ * <pre>+ * cb = storage.getCriteriaBuilder();+ * storage.read(+ *   cb.or(+ *     cb.and(cb.compare(FIELD1, EQ, 1), cb.compare(FIELD2, EQ, 2)),+ *     cb.and(cb.compare(FIELD1, EQ, 3), cb.compare(FIELD2, EQ, 4))+ *   )+ * );+ * </pre>+ *+ * @author hmlnarik+ */+public interface ModelCriteriaBuilder {","Will there remain both KEYCLOAK-16584 and KEYCLOAK-16118 commits? It seems to me (and I might be wrong :) ) `ModelCriteriaBuilder` should rather belong to KEYCLOAK-16118 commit than to this one. But it'd mean to move all related code there so I'm not sure if it's worth it, wdyt?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,556430379,2021-01-13T10:51:26Z,model/map/src/main/java/org/keycloak/models/map/storage/ModelCriteriaBuilder.java,"@@ -0,0 +1,176 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates","Do we need to update the year to 2021? If so, there are other newly created classes or interfaces.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556447107,2021-01-13T11:19:39Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/LazyLoader.java,"@@ -37,4 +37,14 @@      * @return the data from source      */     D get(Supplier<S> source);++    /**+     * <p>Returns the data previously loaded (after a call to {@link #get(Supplier)}.+     *+     * <p>This method is specially useful when the calling code is interested on the data previously loaded without necessarily force+     * data to be loaded.+     *+     * @return the data previous loaded+     */+    D get();","This function is extremely helpful. I'd only suggest renaming it to make a strong distinction between this and the other `get` function, perhaps to `weakGet` or `tryGet`",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556449272,2021-01-13T11:23:22Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/DefaultLazyLoader.java,"@@ -28,20 +28,40 @@ public class DefaultLazyLoader<S, D> implements LazyLoader<S, D> {      private final Function<S, D> loader;-    private Supplier<D> fallback;+    private final Supplier<D> fallback;     private D data;      public DefaultLazyLoader(Function<S, D> loader, Supplier<D> fallback) {         this.loader = loader;         this.fallback = fallback;     } +    public DefaultLazyLoader(Function<S, D> loader) {+        this.loader = loader;+        this.fallback = null;+    }+     @Override     public D get(Supplier<S> sourceSupplier) {         if (data == null) {             S source = sourceSupplier.get();-            data = source == null ? fallback.get() : this.loader.apply(source);+            data = source == null ? getDefaultValue() : this.loader.apply(source);+        }+        return data;+    }++    @Override+    public D get() {+        if (data == null) {+            return getDefaultValue();","This implementation is different to the specification given in `LazyLoader`. Per specification, it should only return `data`.If this implementation should be the correct behaviour, then the Javadoc of `LazyLoader.get()` needs to be updated to include information that ""if `data` is not loaded, then default value is obtained from the `fallback` function if known, or `null` otherwise"".",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556468086,2021-01-13T11:58:28Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClientScope.java,"@@ -64,19 +74,23 @@ public String getName() {     public String getRealm() {         return realm;     }-    public Set<ProtocolMapperModel> getProtocolMappers() {-        return protocolMappers;+    public Set<ProtocolMapperModel> getProtocolMappers(Supplier<ClientScopeModel> scope) {+        return protocolMappers.get(scope);     }      public String getProtocol() {         return protocol;     } +    public Set<String> getScope(Supplier<ClientScopeModel> scope) {+        return this.scope.get(scope);+    }+     public Set<String> getScope() {-        return scope;+        return scope.get();","This changes semantics from the previous version. If the data has not been loaded, then a ""fallback"" value would be returned that may be out of sync. This may be desired, however it needs to be done in a differently named method, to clearly state that invalid value may be returned.@mhajas cc",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556474995,2021-01-13T12:11:34Z,services/src/main/java/org/keycloak/services/resources/admin/AdminConsole.java,"@@ -213,38 +221,32 @@ public Response whoAmI(final @Context HttpHeaders headers) {             displayName = user.getUsername();         } -        RealmModel masterRealm = getAdminstrationRealm(realmManager);-        Map<String, Set<String>> realmAccess = new HashMap<String, Set<String>>();-        if (masterRealm == null)+        RealmModel currentRealm = session.realms().getRealmByName(realmName);++        if (currentRealm == null)             throw new NotFoundException(""No realm found"");-        boolean createRealm = false;-        if (realm.equals(masterRealm)) {-            logger.debug(""setting up realm access for a master realm user"");-            createRealm = user.hasRole(masterRealm.getRole(AdminRoles.CREATE_REALM));-            addMasterRealmAccess(user, realmAccess);-        } else {-            logger.debug(""setting up realm access for a realm user"");-            addRealmAccess(realm, user, realmAccess);-        } +        Map<String, Set<String>> roles = calculateRoles(currentRealm, user);+        RealmModel masterRealm = new RealmManager(session).getKeycloakAdminstrationRealm();+        boolean createRealm = user.hasRole(masterRealm.getRole(AdminRoles.CREATE_REALM));         Locale locale = session.getContext().resolveLocale(user); -        return Response.ok(new WhoAmI(user.getId(), realm.getName(), displayName, createRealm, realmAccess, locale)).build();+        return Response.ok(new WhoAmI(user.getId(), realm.getName(), displayName, createRealm, roles, locale)).build();     } -    private void addRealmAccess(RealmModel realm, UserModel user, Map<String, Set<String>> realmAdminAccess) {-        RealmManager realmManager = new RealmManager(session);-        ClientModel realmAdminApp = realm.getClientByClientId(realmManager.getRealmAdminClientId(realm));-        getRealmAdminAccess(realm, realmAdminApp, user, realmAdminAccess);-    }+    private Map<String, Set<String>> calculateRoles(RealmModel realm, UserModel user) {+        ClientModel client = realm.getMasterAdminClient();+        Set<String> realmRoles = client.getRolesStream()+                .filter(user::hasRole)+                .map(RoleModel::getName)+                .collect(Collectors.toSet()); -    private void addMasterRealmAccess(UserModel user, Map<String, Set<String>> realmAdminAccess) {-        session.realms().getRealmsStream().forEach(realm -> {-            ClientModel realmAdminApp = realm.getMasterAdminClient();-            getRealmAdminAccess(realm, realmAdminApp, user, realmAdminAccess);-        });-    }+        Map<String, Set<String>> realmAccess = new HashMap<>(20);++        realmAccess.put(realm.getName(), realmRoles); +        return realmAccess;+    }","Can this be simplified to?```suggestion        return Collections.singletonMap(realm.getName(), realmRoles);    }```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556481160,2021-01-13T12:23:11Z,services/src/main/java/org/keycloak/services/resources/admin/RealmsAdminResource.java,"@@ -93,14 +94,26 @@ public RealmsAdminResource(AdminAuth auth, TokenManager tokenManager) {     @GET     @NoCache     @Produces(MediaType.APPLICATION_JSON)-    public Stream<RealmRepresentation> getRealms() {+    public Stream<RealmRepresentation> getRealms(@QueryParam(""basic"") String basic) {","This call produces an array of hashes like `[{id: ..., realm: ...}, ...{id: ..., realm: ...}]`. This contains lot of garbage and can be optimized to only return array of pairs like `[[""id1"", ""realm1""], [""id2"", ""realm2], ...]`Could there be an endpoint ""/list"" that the following implementation:```java    @GET    public Stream<String[]> listRealms() {        return session.realms().getRealmsStream()            map(r -> return new String[] {r.getId(), r.getName});    }```This would remove all the logic linked to serialization of RealmRepresentation which would in turn lead to a more performant behaviour.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556482917,2021-01-13T12:26:29Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClient.java,"@@ -166,12 +184,16 @@ public int getNotBefore() {         return notBefore;     } +    public Set<String> getScope(Supplier<ClientModel> client) {+        return scope.get(client);+    }+     public Set<String> getScope() {-        return scope;+        return scope.get();","This changes semantics from the previous version. If the data has not been loaded, then a ""fallback"" value would be returned that may be out of sync. This may be desired, however it needs to be done in a differently named method, to clearly state that invalid value may be returned.@mhajas cc",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556537066,2021-01-13T13:56:57Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedRealm.java,"@@ -51,6 +54,155 @@  */ public class CachedRealm extends AbstractExtendableRevisioned { +    private static Set<IdentityProviderMapperModel> fetchIdentityProviderMapperSet(RealmModel r) {+        return r.getIdentityProviderMappersStream().collect(Collectors.toSet());+    }++    private static List<RequiredCredentialModel> fetchRequiredCredentials(RealmModel r) {+        return r.getRequiredCredentialsStream().collect(Collectors.toList());+    }++    private static List<IdentityProviderModel> fetchIdentityProviders(RealmModel r) {+        return r.getIdentityProvidersStream().map(IdentityProviderModel::new)+                .collect(Collectors.toList());+    }++    private Map<String, AuthenticationFlowModel> fetchAuthenticationFlows(RealmModel r) {+        Map<String, AuthenticationFlowModel> flows = new HashMap<>();+        for (AuthenticationFlowModel flow : getAuthenticationFlowList(() -> r)) {+            flows.put(flow.getId(), flow);+        }+        return flows;+    }++    private MultivaluedHashMap<String, AuthenticationExecutionModel> fetchAuthenticationExecutions(RealmModel r) {+        MultivaluedHashMap<String, AuthenticationExecutionModel> flows = new MultivaluedHashMap<>();+        for (AuthenticationFlowModel flow : getAuthenticationFlowList(() -> r)) {+            flows.put(flow.getId(), new LinkedList<>());+            r.getAuthenticationExecutionsStream(flow.getId()).forEachOrdered(execution -> {+                flows.add(flow.getId(), execution);+            });+        }+        return flows;","Thank you. Yet I still wonder about the following:> I wonder whether MultivaluedHashMap actually makes any sense anymore, and whether we can do just with Map<String, List<AuthenticationExecutionModel>>? That would simplify the code even moreWDYT?Also the other methods below this one should be changed similarly",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556541937,2021-01-13T14:03:55Z,services/src/main/java/org/keycloak/services/resources/admin/RealmsAdminResource.java,"@@ -93,14 +94,26 @@ public RealmsAdminResource(AdminAuth auth, TokenManager tokenManager) {     @GET     @NoCache     @Produces(MediaType.APPLICATION_JSON)-    public Stream<RealmRepresentation> getRealms() {+    public Stream<RealmRepresentation> getRealms(@QueryParam(""basic"") String basic) {","You're right, that could mean changing the console as well. Could the parameter have a more descriptive name, like `idNameOnly`?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556544967,2021-01-13T14:08:15Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClient.java,"@@ -166,12 +184,16 @@ public int getNotBefore() {         return notBefore;     } +    public Set<String> getScope(Supplier<ClientModel> client) {+        return scope.get(client);+    }+     public Set<String> getScope() {-        return scope;+        return scope.get();",This needs to be done properly. The `getScope()` method is used e.g. from `HasRolePredicate` that would now get the default (empty) value and would stop working. Thus the semantics of `getScope` has changed in incompatible way and needs fixing. Perhaps we can leave the scope as the only non-lazily loaded parameters?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556546663,2021-01-13T14:10:49Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClientScope.java,"@@ -64,19 +74,23 @@ public String getName() {     public String getRealm() {         return realm;     }-    public Set<ProtocolMapperModel> getProtocolMappers() {-        return protocolMappers;+    public Set<ProtocolMapperModel> getProtocolMappers(Supplier<ClientScopeModel> scope) {+        return protocolMappers.get(scope);     }      public String getProtocol() {         return protocol;     } +    public Set<String> getScope(Supplier<ClientScopeModel> scope) {+        return this.scope.get(scope);+    }+     public Set<String> getScope() {-        return scope;+        return scope.get();",This needs fixing since the semantics has changed in the same way as in CachedClient. Let's discuss the solution to this issues there.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7718,556564733,2021-01-13T14:36:00Z,model/jpa/src/main/java/org/keycloak/events/jpa/JpaEventStoreProvider.java,"@@ -69,8 +75,38 @@ public void clear(String realmId) {     }      @Override-    public void clear(String realmId, long olderThan) {-        em.createQuery(""delete from EventEntity where realmId = :realmId and time < :time"").setParameter(""realmId"", realmId).setParameter(""time"", olderThan).executeUpdate();+    public void clearExpiredEvents() {+        // By default, realm provider is always ""jpa"", so we can optimize and delete all events in single SQL, assuming that realms are saved in the DB as well.+        // Fallback to model API just with different realm provider than ""jpa"" (This is never the case in standard Keycloak installations)+        if (KeycloakModelUtils.isRealmProviderJpa(session)) {+            boolean eventsToDeleteExists = true;+            int numDeleted = 0;+            while (eventsToDeleteExists) {","1. This can be a very long cycle, and since done in a single transaction, can happen to be run simultaneously for the same records by all the nodes in the cluster. Should the number of iterations be limited? Should it be possible to force previous behaviour even for `jpa` realm storage?2. Can it happen that the events would be generated faster than expired? Since there is now a roundtrip to the database, the deletion is overall slower than the original variant.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556580964,2021-01-13T14:56:50Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClient.java,"@@ -166,12 +184,16 @@ public int getNotBefore() {         return notBefore;     } +    public Set<String> getScope(Supplier<ClientModel> client) {+        return scope.get(client);+    }+     public Set<String> getScope() {-        return scope;+        return scope.get();","Originally the scope has been initialized with the set of scope loaded from the database.In this PR, this changes: if the scope has not been initialized via `getScope(Supplier<ClientModel> client)` and rather queried by this method `getScope()`, this would fall back to the `tryGetOrDefault` which, when not loaded, would return the `fallback` value (i.e. empty set).It needs to be fixed so that the `getScope()` always returns the proper scopes.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556586196,2021-01-13T15:03:19Z,services/src/main/java/org/keycloak/services/resources/admin/RealmsAdminResource.java,"@@ -93,14 +94,26 @@ public RealmsAdminResource(AdminAuth auth, TokenManager tokenManager) {     @GET     @NoCache     @Produces(MediaType.APPLICATION_JSON)-    public Stream<RealmRepresentation> getRealms() {+    public Stream<RealmRepresentation> getRealms(@QueryParam(""basic"") String basic) {","For something else than full object representation, there is already used `briefRepresentation`. Please keep parameter names consistent across code base",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556605694,2021-01-13T15:28:21Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClient.java,"@@ -166,12 +184,16 @@ public int getNotBefore() {         return notBefore;     } +    public Set<String> getScope(Supplier<ClientModel> client) {+        return scope.get(client);+    }+     public Set<String> getScope() {-        return scope;+        return scope.get();","I see. However, when running the predicate an empty scope list should not impact invalidations because the proper scopes should be loaded/updated when some code tries to access it. Whereas the client with a not yet loaded scope list is not really outdated. That is my thinking ...Do you have a specific scenario I can test to make sure there is an issue? My point being that loading scope mappings should really be delayed ...",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556634547,2021-01-13T15:56:26Z,services/src/main/java/org/keycloak/storage/RoleStorageManager.java,"@@ -69,6 +74,14 @@ public static RoleStorageProvider getStorageProvider(KeycloakSession session, Re       public static <T> Stream<RoleStorageProviderModel> getStorageProviders(RealmModel realm, KeycloakSession session, Class<T> type) {+        List<ProviderFactory> factories = session.getKeycloakSessionFactory()+                .getProviderFactories(RoleStorageProvider.class);++        // there is no need iterate over the database if there is no role storage provider+        if (factories.isEmpty()) {+            return Stream.empty();+        }+","This looks good to me, I like it. However, we should probably add it also to [AbstractStorageManager](https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/storage/AbstractStorageManager.java#L93), it should be used everywhere in future, so I think this is the correct place to add it.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556660165,2021-01-13T16:29:37Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClient.java,"@@ -166,12 +184,16 @@ public int getNotBefore() {         return notBefore;     } +    public Set<String> getScope(Supplier<ClientModel> client) {+        return scope.get(client);+    }+     public Set<String> getScope() {-        return scope;+        return scope.get();","> For the client, I'm still not convinced. Even when considering invalidations on other nodes.Is data consistency a convincing argument? Is working with wrong roles assigned to a client (as a result of not invalidating client when it should have been) a convincing argument?cc: @mposolda> I'll try to come up with something that does not involve pre-loading scope mappings. If it gets too complicated, I'll just fallback to pre-loading.Sounds good.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7712,556946259,2021-01-13T23:32:17Z,services/src/main/java/org/keycloak/services/resources/admin/RealmsAdminResource.java,"@@ -93,14 +94,26 @@ public RealmsAdminResource(AdminAuth auth, TokenManager tokenManager) {     @GET     @NoCache     @Produces(MediaType.APPLICATION_JSON)-    public Stream<RealmRepresentation> getRealms() {+    public Stream<RealmRepresentation> getRealms(@QueryParam(""basic"") String basic) {         Stream<RealmRepresentation> realms = session.realms().getRealmsStream()-                .map(this::toRealmRep)+                .map(realm -> toRealmRep(realm, Boolean.valueOf(basic)))                 .filter(Objects::nonNull);         return throwIfEmpty(realms, new ForbiddenException());     }      protected RealmRepresentation toRealmRep(RealmModel realm) {+        return toRealmRep(realm, false);+    }++    protected RealmRepresentation toRealmRep(RealmModel realm, boolean basic) {+        if (basic) {+            RealmRepresentation rep = new RealmRepresentation();++            rep.setId(realm.getId());+            rep.setRealm(realm.getName());++            return rep;","@mhajas Btw, if you are testing performance as well, you should also consider increasing the number of entries in both realms and users cache.My latest changes should reduce the time taken to get a token to ms, instead of seconds.I can share with you the database dump I'm using for tests.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7712,557207002,2021-01-14T08:39:42Z,services/src/main/java/org/keycloak/services/resources/admin/RealmsAdminResource.java,"@@ -93,14 +94,26 @@ public RealmsAdminResource(AdminAuth auth, TokenManager tokenManager) {     @GET     @NoCache     @Produces(MediaType.APPLICATION_JSON)-    public Stream<RealmRepresentation> getRealms() {+    public Stream<RealmRepresentation> getRealms(@QueryParam(""basic"") String basic) {","I agree with renaming the parameter to `briefRepresentation` we are already using it in many places. One more question, should we default to `true`? I am not sure about all places where this endpoint is used, but I can't imagine any usecase where it is necessary to obtain all realms in one place, so true as the default value makes sense to me. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7712,557250329,2021-01-14T09:22:17Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClient.java,"@@ -166,12 +184,16 @@ public int getNotBefore() {         return notBefore;     } +    public Set<String> getScope(Supplier<ClientModel> client) {+        return scope.get(client);+    }+     public Set<String> getScope() {-        return scope;+        return scope.get();","@pedroigor I did overlook that this can be a potential issue during my initial review. I did not review thoroughly as this is just draft, but anyway, I should spot this, my bad...I agree that inconsistency can probably happen. It is probably very hard to simulate - you would need to have client in the cache on both cluster nodes, but make sure that ""roleScopeMappings"" for the particular client are not yet loaded. In this case, HasRolePredicate may miss to invalidate the ""partially loaded"" client and stale cache entry can in theory happen in the cache. I can't guarantee 100% it won't happen. Those issues are hard to simulate. Usually, you can't simulate them with the automated tests and not even manually, but they often happen just in the production (customers environment) :-)IMO it may be better to be on the safe side and just skip lazy loading for roleScopeMappings of clientScopes and clients? We can just load roleScopeMappings eagerly. We will be safe and the performance penalty of this is really negligible due the:- Cached ClientScopes are already lazily loaded when realm is cached due your other changes- Cached clients are also lazily loaded just when needed- There is not much benefit of lazy loading role scope mappings as they are usually needed in same HTTP request when the particular CachedClientScope is needed. It looks that Cached clientScope is cached during the ""code-to-token"" request or ""refresh-token"" request. But same HTTP requests also calls ""CachedClientScope.getScope()"" and requires roleScopeMappings.- The client is usually cached at the point when OIDC AuthorizationEndpoint is called for this client (Login page is shown). The CachedClient.getScope() is called after successful authentication. So here there is small benefit of lazy loading as roleScopeMappings are not necessarily cached at the same HTTP request as the client itself. However quite negligible as user usually successfully finish the login once the client is first displayed.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7712,557284288,2021-01-14T10:14:15Z,services/src/main/java/org/keycloak/services/resources/admin/RealmsAdminResource.java,"@@ -93,14 +94,26 @@ public RealmsAdminResource(AdminAuth auth, TokenManager tokenManager) {     @GET     @NoCache     @Produces(MediaType.APPLICATION_JSON)-    public Stream<RealmRepresentation> getRealms() {+    public Stream<RealmRepresentation> getRealms(@QueryParam(""basic"") String basic) {","I'll change the name. A big one though :) But if we are using at other places, so let's keep consistency. Hope we can sort this out better when we review our APIs based on the guidelines.In regards to default to true, that could break backward compatibility. I would leave it as is.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,557355868,2021-01-14T12:21:14Z,model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupported.java,"@@ -0,0 +1,47 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage;++import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.storage.SearchableModelField;++/**+ *+ * @author hmlnarik+ */+public class CriterionNotSupported extends RuntimeException {+    private final SearchableModelField field;+    private final Operator op;",I miss the reason to have this parameters here as it seems to me those are not accessible via any methods. But maybe I'm overlooking something.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,557438586,2021-01-14T14:34:43Z,model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupported.java,"@@ -0,0 +1,47 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage;++import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.storage.SearchableModelField;++/**+ *+ * @author hmlnarik+ */+public class CriterionNotSupported extends RuntimeException {","Just a question, I've always seen classes which extends `Exception` or a subclass named with suffix ""Exception"". I'm not sure if it's a convention or a habit. Anyway I wanted to hear your opinion.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,557455991,2021-01-14T14:57:43Z,model/map/src/main/java/org/keycloak/models/map/storage/CriteriaOperator.java,"@@ -0,0 +1,247 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage;++import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import java.util.Arrays;+import java.util.Collection;+import java.util.Collections;+import java.util.EnumMap;+import java.util.EnumSet;+import java.util.HashSet;+import java.util.Objects;+import java.util.Set;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.logging.Level;+import java.util.logging.Logger;+import java.util.regex.Pattern;+import java.util.stream.Collectors;+import java.util.stream.Stream;++/**+ *+ * @author hmlnarik+ */+class CriteriaOperator {++    private static final EnumMap<Operator, Function<Object[], Predicate<Object>>> OPERATORS = new EnumMap<>(Operator.class);++    private static final Logger LOG = Logger.getLogger(CriteriaOperator.class.getSimpleName());++    private static final Predicate<Object> ALWAYS_FALSE = o -> false;++    static {+        OPERATORS.put(Operator.EQ, CriteriaOperator::eq);+        OPERATORS.put(Operator.NE, CriteriaOperator::ne);+        OPERATORS.put(Operator.EXISTS, CriteriaOperator::exists);+        OPERATORS.put(Operator.NOT_EXISTS, CriteriaOperator::notExists);+        OPERATORS.put(Operator.LT, CriteriaOperator::lt);+        OPERATORS.put(Operator.LE, CriteriaOperator::le);+        OPERATORS.put(Operator.GT, CriteriaOperator::gt);+        OPERATORS.put(Operator.GE, CriteriaOperator::ge);+        OPERATORS.put(Operator.IN, CriteriaOperator::in);+        OPERATORS.put(Operator.LIKE, CriteriaOperator::like);+        OPERATORS.put(Operator.ILIKE, CriteriaOperator::ilike);++        // Check that all operators are covered+        EnumSet<Operator> s = EnumSet.allOf(Operator.class);+        s.removeAll(OPERATORS.keySet());+        if (! s.isEmpty()) {+            throw new IllegalStateException(""Some operators are not implemented: "" + s);+        }+    }++    /**+     * Returns a predicate {@code P(x)} for comparing {@code value} and {@code x} as {@code x OP value}.+     * <b>Implementation note:</b> Note that this may mean reverse logic to e.g. {@link Comparable#compareTo}.+     * @param operator+     * @param value+     * @return+     */+    public static Predicate<Object> predicateFor(Operator op, Object[] value) {+        final Function<Object[], Predicate<Object>> funcToGetPredicate = OPERATORS.get(op);+        if (funcToGetPredicate == null) {+            throw new IllegalArgumentException(""Unknown operator: "" + op);+        }+        return funcToGetPredicate.apply(value);+    }++    public static Predicate<Object> eq(Object[] value) {+        if (value == null || value.length != 1) {+            throw new IllegalStateException(""Invalid argument: "" + Arrays.toString(value));+        }+        final Object value0 = value[0];+        return new Predicate<Object>() {",Can you please explain the benefit using anonymous inner class here for me?,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,557462832,2021-01-14T15:06:16Z,model/map/src/main/java/org/keycloak/models/map/storage/CriteriaOperator.java,"@@ -0,0 +1,247 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage;++import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import java.util.Arrays;+import java.util.Collection;+import java.util.Collections;+import java.util.EnumMap;+import java.util.EnumSet;+import java.util.HashSet;+import java.util.Objects;+import java.util.Set;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.logging.Level;+import java.util.logging.Logger;+import java.util.regex.Pattern;+import java.util.stream.Collectors;+import java.util.stream.Stream;++/**+ *+ * @author hmlnarik+ */+class CriteriaOperator {++    private static final EnumMap<Operator, Function<Object[], Predicate<Object>>> OPERATORS = new EnumMap<>(Operator.class);++    private static final Logger LOG = Logger.getLogger(CriteriaOperator.class.getSimpleName());++    private static final Predicate<Object> ALWAYS_FALSE = o -> false;++    static {+        OPERATORS.put(Operator.EQ, CriteriaOperator::eq);+        OPERATORS.put(Operator.NE, CriteriaOperator::ne);+        OPERATORS.put(Operator.EXISTS, CriteriaOperator::exists);+        OPERATORS.put(Operator.NOT_EXISTS, CriteriaOperator::notExists);+        OPERATORS.put(Operator.LT, CriteriaOperator::lt);+        OPERATORS.put(Operator.LE, CriteriaOperator::le);+        OPERATORS.put(Operator.GT, CriteriaOperator::gt);+        OPERATORS.put(Operator.GE, CriteriaOperator::ge);+        OPERATORS.put(Operator.IN, CriteriaOperator::in);+        OPERATORS.put(Operator.LIKE, CriteriaOperator::like);+        OPERATORS.put(Operator.ILIKE, CriteriaOperator::ilike);++        // Check that all operators are covered+        EnumSet<Operator> s = EnumSet.allOf(Operator.class);+        s.removeAll(OPERATORS.keySet());+        if (! s.isEmpty()) {+            throw new IllegalStateException(""Some operators are not implemented: "" + s);+        }+    }++    /**+     * Returns a predicate {@code P(x)} for comparing {@code value} and {@code x} as {@code x OP value}.+     * <b>Implementation note:</b> Note that this may mean reverse logic to e.g. {@link Comparable#compareTo}.+     * @param operator+     * @param value+     * @return+     */+    public static Predicate<Object> predicateFor(Operator op, Object[] value) {+        final Function<Object[], Predicate<Object>> funcToGetPredicate = OPERATORS.get(op);+        if (funcToGetPredicate == null) {+            throw new IllegalArgumentException(""Unknown operator: "" + op);+        }+        return funcToGetPredicate.apply(value);+    }++    public static Predicate<Object> eq(Object[] value) {+        if (value == null || value.length != 1) {","nit: this check could be potentially moved to private method as it's used multiple times within this class, but I'm really ok with the way how it's now. ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7718,558361598,2021-01-15T14:58:01Z,model/jpa/src/main/java/org/keycloak/events/jpa/JpaEventStoreProvider.java,"@@ -69,8 +75,38 @@ public void clear(String realmId) {     }      @Override-    public void clear(String realmId, long olderThan) {-        em.createQuery(""delete from EventEntity where realmId = :realmId and time < :time"").setParameter(""realmId"", realmId).setParameter(""time"", olderThan).executeUpdate();+    public void clearExpiredEvents() {+        // By default, realm provider is always ""jpa"", so we can optimize and delete all events in single SQL, assuming that realms are saved in the DB as well.+        // Fallback to model API just with different realm provider than ""jpa"" (This is never the case in standard Keycloak installations)+        if (KeycloakModelUtils.isRealmProviderJpa(session)) {+            boolean eventsToDeleteExists = true;+            int numDeleted = 0;+            while (eventsToDeleteExists) {","@hmlnarik I've did some performance testing with big number of login events and the ClearExpiredEvents is able to clear the 10K events on my laptop within 60 ms. Much better performance than before for the environment with 200 realms. Since last review, I've added ""long currentTimeMillis"" on the top of the method, so time is not changing when there are multiple iterations needed. As you pointed, the using latest time in the cycle caused issues as the ""delete"" SQL command finished, there were new events added to the table, hence the ""select"" SQL returned another items and there was a chance to have this cycle never-ending. With this change, it should always finish in the finite time.I have another alternative solution here https://github.com/mposolda/keycloak/commit/306b7a62250fc9701334aa5a4a92c532119e5c43 . This has advantage that it doesn't explicitly specify the event IDs in the IN clause. It tries to group realms by the expiration time and use single SQL delete command for each expiration time. Would be effective in case that most of the realms have same expiration times, which I think would be the case in most of the environments. In my local environment, I used 200 realms with 10 various expiration times and hence this run 10 SQL commands. The performance seems to be in general little worse than for the solution 1, however still able to always finish within less than 100 ms in the worst case (in most of the cases in less than 50 ms). In general, this may be more effective in case with same/similar eventExpiration for all realms. And it does not require stuff in the IN clause and can re-use indexes on the ""time"" column of EventEntity table, so I am slightly for use this one solution. WDYT?I've tried few other things to have more effective solution, which we discuss last time, but wasn't able to do the JPQL, which would work for all databases. For the native SQL, it is possible. I have at least 2 variants, which are able to remove all the events in single SQL command. Also the ""delete"" with the limits is possible with the native SQL. However that is native SQL, which I suppose is something, we want to avoid? WDYT?Since there can be limitations in some environments as mentioned in the other JIRA https://issues.redhat.com/browse/KEYCLOAK-16665 , I am slightly towards to have the option for fallback to the previous behaviour. I did not yet add it to the PR. Do you want me to add the option?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7718,558554572,2021-01-15T19:43:53Z,model/jpa/src/main/java/org/keycloak/events/jpa/JpaEventStoreProvider.java,"@@ -69,8 +75,38 @@ public void clear(String realmId) {     }      @Override-    public void clear(String realmId, long olderThan) {-        em.createQuery(""delete from EventEntity where realmId = :realmId and time < :time"").setParameter(""realmId"", realmId).setParameter(""time"", olderThan).executeUpdate();+    public void clearExpiredEvents() {+        // By default, realm provider is always ""jpa"", so we can optimize and delete all events in single SQL, assuming that realms are saved in the DB as well.+        // Fallback to model API just with different realm provider than ""jpa"" (This is never the case in standard Keycloak installations)+        if (KeycloakModelUtils.isRealmProviderJpa(session)) {+            boolean eventsToDeleteExists = true;+            int numDeleted = 0;+            while (eventsToDeleteExists) {","Thanks @mposolda, great job! Especially the results from your tests are clearly very good!I like the alternative solution better than the current one. With that one, the throughput in the events table should be better for the price of being negligibly slower and with the benefit of sending much less data over the wire due to the removed the `IN` clause.As for the native query, I'd rather suggest to avoid that one. IMO the performance gain is already tremendous and the maintenance cost would be smaller with only JPQL there. If needed, we could obtain the similar behaviour to the native query with `DELETE ... LIMIT` queries by imposing a condition to limit the delete to a closed interval `(time BETWEEN :x AND :y` rather than `time < :time`, but I believe even this may be unnecessary with the changes proposed in this PR.> Since there can be limitations in some environments as mentioned in the other JIRA https://issues.redhat.com/browse/KEYCLOAK-16665 , I am slightly towards to have the option for fallback to the previous behaviour. I did not yet add it to the PR. Do you want me to add the option?I would prefer the option present.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7718,559427195,2021-01-18T09:32:34Z,model/jpa/src/main/java/org/keycloak/events/jpa/JpaEventStoreProvider.java,"@@ -69,8 +75,38 @@ public void clear(String realmId) {     }      @Override-    public void clear(String realmId, long olderThan) {-        em.createQuery(""delete from EventEntity where realmId = :realmId and time < :time"").setParameter(""realmId"", realmId).setParameter(""time"", olderThan).executeUpdate();+    public void clearExpiredEvents() {+        // By default, realm provider is always ""jpa"", so we can optimize and delete all events in single SQL, assuming that realms are saved in the DB as well.+        // Fallback to model API just with different realm provider than ""jpa"" (This is never the case in standard Keycloak installations)+        if (KeycloakModelUtils.isRealmProviderJpa(session)) {+            boolean eventsToDeleteExists = true;+            int numDeleted = 0;+            while (eventsToDeleteExists) {","@hmlnarik Thanks!I replaced this PR with the ""alternative"" solution (The one, which avoids sending IDs in the IN clause).@hmlnarik @vramik Pipeline run with this patch is here: https://keycloak-jenkins.com/view/pipelines/job/universal-test-pipeline-server/2502 . There is no regression in the current master and especially the EventStoreProviderTest is passing on all the databases. However the issue is Oracle 19c RAC, which currently does not work in pipeline at all. No regression of this PR as it is failing for the master as well. Looks like the issue on the DB side. IMO it is probably better to wait with this PR until Oracle is fixed to be sure that no regression happens for the Oracle. WDYT?FYI. I've did some more testing with the 10 millions of events in the database spread over all 200 realms and the measure how much time the background task will take.Current master: Transaction timeout after 300 secondsPrevious solution (the one with the IDs in the IN clause): 103 secondsCurrent solution in the PR: 58 seconds",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,559496275,2021-01-18T11:22:14Z,model/map/src/main/java/org/keycloak/models/map/storage/MapStorage.java,"@@ -18,21 +18,68 @@  import java.util.Map; import java.util.Set;+import java.util.stream.Stream;  /**  *  * @author hmlnarik  */ public interface MapStorage<K, V> { -    V get(K key);+    /**+     * Creates an object in the store identified by given {@code key}.+     * @param key Key of the object as seen in the logical level+     * @param value Entity+     * @return Reference to the entity created in the store+     * @throws NullPointerException if object or its {@code id} is {@code null}+     */+    V create(K key, V value); -    V put(K key, V value);+    /**+     * Returns object with the given {@code key} from the storage or {@code null} if object does not exist.+     * @param key Must not be {@code null}.+     * @return See description+     */+    V read(K key);","Yes. Since it this note is there though, I believe there was a race condition between some of my commits and the review",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,559500157,2021-01-18T11:29:18Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java,"@@ -0,0 +1,136 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.chm;++import org.keycloak.models.map.storage.MapModelCriteriaBuilder;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapFieldPredicates;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.storage.SearchableModelField;+import java.util.Map;+import java.util.Map.Entry;+import java.util.concurrent.ConcurrentHashMap;+import java.util.concurrent.ConcurrentMap;+import java.util.stream.Stream;+import org.keycloak.models.map.storage.MapModelCriteriaBuilder.UpdatePredicatesFunc;+import java.util.Iterator;+import java.util.Objects;+import java.util.function.Predicate;++/**+ *+ * @author hmlnarik+ */+public class ConcurrentHashMapStorage<K, V extends AbstractEntity<K>, M> implements MapStorage<K, V, M> {++    private final ConcurrentMap<K, V> store = new ConcurrentHashMap<>();++    private final Map<SearchableModelField<M>, UpdatePredicatesFunc<K, V, M>> fieldPredicates;++    @SuppressWarnings(""unchecked"")+    public ConcurrentHashMapStorage(Class<M> modelClass) {+        this.fieldPredicates = MapFieldPredicates.getPredicates(modelClass);+    }++    @Override+    public V create(K key, V value) {+        return store.putIfAbsent(key, value);+    }++    @Override+    public V read(K key) {+        Objects.requireNonNull(key, ""Key must be non-null"");+        return store.get(key);+    }++    @Override+    public V update(K key, V value) {+        return store.replace(key, value);+    }++    @Override+    public boolean delete(K key) {+        return store.remove(key) != null;+    }++    @Override+    public long delete(ModelCriteriaBuilder<M> criteria) {+        long res;+        if (criteria == null) {+            res = store.size();+            store.clear();+            return res;+        }++        MapModelCriteriaBuilder<K, V, M> b = criteria.unwrap(MapModelCriteriaBuilder.class);+        if (b == null) {+            throw new IllegalStateException(""Incompatible class: "" + criteria.getClass());+        }+        Predicate<? super K> keyFilter = b.getKeyFilter();+        Predicate<? super V> entityFilter = b.getEntityFilter();+        res = 0;+        for (Iterator<Entry<K, V>> iterator = store.entrySet().iterator(); iterator.hasNext();) {+            Entry<K, V> next = iterator.next();+            if (keyFilter.test(next.getKey()) && entityFilter.test(next.getValue())) {+                res++;+                iterator.remove();+            }+        }+        return res;+    }++    @Override+    public ModelCriteriaBuilder<M> createCriteriaBuilder() {+        return new MapModelCriteriaBuilder<>(fieldPredicates);+    }++    @Override+    public MapKeycloakTransaction<K, V, M> createTransaction() {+        return new MapKeycloakTransaction<>(this);+    }+++    @Override+    public Stream<V> read(ModelCriteriaBuilder<M> criteria) {+        if (criteria == null) {+            return Stream.empty();+        }+        Stream<Entry<K, V>> stream = store.entrySet().stream();++        MapModelCriteriaBuilder<K, V, M> b = criteria.unwrap(MapModelCriteriaBuilder.class);+        if (b == null) {+            throw new IllegalStateException(""Incompatible class: "" + criteria.getClass());+        }+        Predicate<? super K> keyFilter = b.getKeyFilter();+        Predicate<? super V> entityFilter = b.getEntityFilter();+        stream = stream.filter(me -> keyFilter.test(me.getKey()) && entityFilter.test(me.getValue()));++        return stream.map(Map.Entry::getValue);+    }++    public Stream<V> read() {",Good catch. This method should have been removed.Reason for not including it in the interface is to remove easy way to read full database which is not desirable anywhere apart from test and development where it can be achieved via the existing `read(ModelCriteriaBuilder)` method.,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,559747955,2021-01-18T18:49:54Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/JpaUserSessionPersisterProvider.java,"@@ -239,6 +241,52 @@ public void removeExpired(RealmModel realm) {      } +    @Override+    public UserSessionModel loadUserSession(String userSessionId, boolean offline) {++        String offlineStr = offlineToString(offline);++        TypedQuery<PersistentUserSessionEntity> userSessionQuery = em.createNamedQuery(""findUserSession"", PersistentUserSessionEntity.class);+        userSessionQuery.setParameter(""offline"", offlineStr);+        userSessionQuery.setParameter(""userSessionId"", userSessionId);+        userSessionQuery.setMaxResults(1);++        List<PersistentUserSessionAdapter> result = userSessionQuery.getResultStream()+                .map(this::toAdapter)+                .collect(Collectors.toList());++        if (result.isEmpty()) {+            return null;+        }++        PersistentUserSessionAdapter userSession = result.get(0);++        TypedQuery<PersistentClientSessionEntity> clientSessionQuery = em.createNamedQuery(""findClientSessionsByUserSessions"", PersistentClientSessionEntity.class);","Thanks for your feedback @pedroigor > org.keycloak.models.jpa.session.JpaUserSessionPersisterProvider#loadUserSessionsThat's what I tried at first, but it turned out that [the session referenced by the `lastUserSessionId` parameter](https://github.com/keycloak/keycloak/blob/ba8e2fef6b0a47727f03d58f4fe2809d6e65c017/model/jpa/src/main/java/org/keycloak/models/jpa/session/PersistentUserSessionEntity.java#L41) is not included in the result... that's why I decided to implement the new method.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,559763453,2021-01-18T19:33:13Z,model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupportedException.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage;++import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.storage.SearchableModelField;++/**+ *+ * @author hmlnarik+ */+public class CriterionNotSupportedException extends RuntimeException {+    private final SearchableModelField field;+    private final Operator op;++    public CriterionNotSupportedException(SearchableModelField field, Operator op) {+        super(""Criterion not supported: operator: "" + op + "", field: "" + field);+        this.field = field;+        this.op = op;+    }++    public CriterionNotSupportedException(SearchableModelField field, Operator op, String message) {+        super(message);+        this.field = field;+        this.op = op;+    }++    public CriterionNotSupportedException(SearchableModelField field, Operator op, String message, Throwable cause) {+        super(message, cause);+        this.field = field;+        this.op = op;+    }++    public SearchableModelField getField() {","Now the parameters are accessible, but the methods are not used anywhere. Do you plan to have a use for them?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,560147697,2021-01-19T12:39:24Z,model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupportedException.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage;++import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.storage.SearchableModelField;++/**+ *+ * @author hmlnarik+ */+public class CriterionNotSupportedException extends RuntimeException {+    private final SearchableModelField field;+    private final Operator op;++    public CriterionNotSupportedException(SearchableModelField field, Operator op) {+        super(""Criterion not supported: operator: "" + op + "", field: "" + field);+        this.field = field;+        this.op = op;+    }++    public CriterionNotSupportedException(SearchableModelField field, Operator op, String message) {+        super(message);+        this.field = field;+        this.op = op;+    }++    public CriterionNotSupportedException(SearchableModelField field, Operator op, String message, Throwable cause) {+        super(message, cause);+        this.field = field;+        this.op = op;+    }++    public SearchableModelField getField() {",They will likely be used in an exception converter,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7722,560165895,2021-01-19T13:13:01Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/JpaUserSessionPersisterProvider.java,"@@ -239,6 +241,52 @@ public void removeExpired(RealmModel realm) {      } +    @Override+    public UserSessionModel loadUserSession(String userSessionId, boolean offline) {++        String offlineStr = offlineToString(offline);++        TypedQuery<PersistentUserSessionEntity> userSessionQuery = em.createNamedQuery(""findUserSession"", PersistentUserSessionEntity.class);+        userSessionQuery.setParameter(""offline"", offlineStr);+        userSessionQuery.setParameter(""userSessionId"", userSessionId);+        userSessionQuery.setMaxResults(1);++        List<PersistentUserSessionAdapter> result = userSessionQuery.getResultStream()+                .map(this::toAdapter)+                .collect(Collectors.toList());++        if (result.isEmpty()) {+            return null;+        }++        PersistentUserSessionAdapter userSession = result.get(0);++        TypedQuery<PersistentClientSessionEntity> clientSessionQuery = em.createNamedQuery(""findClientSessionsByUserSessions"", PersistentClientSessionEntity.class);+        clientSessionQuery.setParameter(""userSessionIds"", Collections.singleton(userSessionId));+        clientSessionQuery.setParameter(""offline"", offlineStr);+        List<PersistentClientSessionEntity> clientSessions = clientSessionQuery.getResultList();","Also consider using streams here:```suggestion        closing(clientSessionQuery.getResultStream()).forEach(clientSession -> {            PersistentAuthenticatedClientSessionAdapter clientSessAdapter = toAdapter(userSession.getRealm(), userSession, clientSession);            Map<String, AuthenticatedClientSessionModel> currentClientSessions = userSession.getAuthenticatedClientSessions();            // Case when client was removed in the meantime            if (clientSessAdapter.getClient() == null) {                removedClientUUIDs.add(clientSession.getClientId());            } else {                currentClientSessions.put(clientSession.getClientId(), clientSessAdapter);            }        });```",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7677,560178355,2021-01-19T13:34:57Z,server-spi/src/main/java/org/keycloak/models/RealmModel.java,"@@ -460,6 +523,11 @@         return getIdentityProviderMappersByAliasStream(brokerAlias).collect(Collectors.toSet());     } +    /**+     * Returns identity provider mappers by the provided alias as a stream.+     * @param brokerAlias {@code String} Broker's alias to filter results.+     * @return Stream of {@link IdentityProviderMapperModel} Never returns {@code null}.+     */     Stream<IdentityProviderMapperModel> getIdentityProviderMappersByAliasStream(String brokerAlias);      IdentityProviderMapperModel addIdentityProviderMapper(IdentityProviderMapperModel model);",That would be quite an extensive list of methods :) I would personally leave that for a separate task as it is not related to streamification cleanup but lets see what others think as well.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7677,560207293,2021-01-19T14:18:12Z,server-spi-private/src/main/java/org/keycloak/provider/ProviderLoader.java,"@@ -26,17 +26,14 @@      /**      * Load the SPI definitions themselves.-     *",Think we need some consensus on spacing - I usually leave a blank line between the method's description and parameters (much like the javadocs in the Java API classes) while this removes the blank line. The processed javadoc is identical but I wonder if we shouldn't pick one way of doing it and sticking to it.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/7677,560211814,2021-01-19T14:24:20Z,server-spi/src/main/java/org/keycloak/models/RoleMapperModel.java,"@@ -29,14 +29,14 @@     /**      * Returns set of realm roles that are directly set to this object.      * @return see description-     * @deprecated Use {@link #getRealmRoleMappingsStream()} getRealmRoleMappingsStream} instead.+     * @deprecated Use {@link #getRealmRoleMappingsStream() getRealmRoleMappingsStream} instead.      */     @Deprecated     Set<RoleModel> getRealmRoleMappings();      /**      * Returns stream of realm roles that are directly set to this object.-     * @return stream of {@link RoleModel}+     * @return Stream of {@link RoleModel}. Never returns {@code null}.","I think we again need some consensus on the description of the returned stream. When I documented I used a wording along the lines of ""@return a non-null {@link Stream} of realm roles"" whereas in this case the fact that the stream can't be null is communicated in a different way. Not a deal breaker for this particular PR, just something we might want to make consistent as part of a follow-up documentation Jira, for example.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7684,560218225,2021-01-19T14:32:22Z,model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java,"@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {             return null;         }         -        MapGroupEntity entity = tx.get(uid, groupStore::get);-        return (entity == null || ! entityRealmFilter(realm).test(entity))+        MapGroupEntity entity = tx.read(uid);+        String realmId = realm.getId();+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))                 ? null                 : entityToAdapterFunc(realm).apply(entity);     } -    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()-                .filter(Objects::nonNull);-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);-    }--    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {-        return getNotRemovedUpdatedGroupsStream()-                .filter(entityRealmFilter(realm));-    }-     @Override     public Stream<GroupModel> getGroupsStream(RealmModel realm) {+        return getGroupsStreamInternal(realm, null);+    }++    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {         LOG.tracef(""getGroupsStream(%s)%s"", realm, getShortStackTrace());-        return getUnsortedGroupEntitiesStream(realm)+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());","I was thinking about it, I decided for a more explicit ""WHERE clause"" as it then shows exact condition in full and is still short enough. I'm open to change it if there is a convincing argument though",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7684,560283290,2021-01-19T15:54:39Z,model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java,"@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {             return null;         }         -        MapGroupEntity entity = tx.get(uid, groupStore::get);-        return (entity == null || ! entityRealmFilter(realm).test(entity))+        MapGroupEntity entity = tx.read(uid);+        String realmId = realm.getId();+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))                 ? null                 : entityToAdapterFunc(realm).apply(entity);     } -    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()-                .filter(Objects::nonNull);-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);-    }--    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {-        return getNotRemovedUpdatedGroupsStream()-                .filter(entityRealmFilter(realm));-    }-     @Override     public Stream<GroupModel> getGroupsStream(RealmModel realm) {+        return getGroupsStreamInternal(realm, null);+    }++    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {         LOG.tracef(""getGroupsStream(%s)%s"", realm, getShortStackTrace());-        return getUnsortedGroupEntitiesStream(realm)+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());","I mean `realm.getId()` will throw NPE when realm is `null`. However, I am not sure this makes sense to add now. We are not checking many other parameters. Maybe we should add it to cleanup task to either document that NPE may be thrown when null parameter is passed or do some checking everywhere. I just wanted to point it out as this is change of behaviour in this PR. Before there was no user/group/role returned as ALWAYS_FALSE filter was used when realm was `null`.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,560531548,2021-01-19T22:13:49Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/JpaUserSessionPersisterProvider.java,"@@ -239,6 +241,52 @@ public void removeExpired(RealmModel realm) {      } +    @Override+    public UserSessionModel loadUserSession(String userSessionId, boolean offline) {++        String offlineStr = offlineToString(offline);++        TypedQuery<PersistentUserSessionEntity> userSessionQuery = em.createNamedQuery(""findUserSession"", PersistentUserSessionEntity.class);+        userSessionQuery.setParameter(""offline"", offlineStr);+        userSessionQuery.setParameter(""userSessionId"", userSessionId);+        userSessionQuery.setMaxResults(1);++        List<PersistentUserSessionAdapter> result = userSessionQuery.getResultStream()+                .map(this::toAdapter)+                .collect(Collectors.toList());++        if (result.isEmpty()) {+            return null;+        }++        PersistentUserSessionAdapter userSession = result.get(0);++        TypedQuery<PersistentClientSessionEntity> clientSessionQuery = em.createNamedQuery(""findClientSessionsByUserSessions"", PersistentClientSessionEntity.class);","... of course we could change the `sess.userSessionId > :lastSessionId` condition in the findUserSessions JPA query to `sess.userSessionId >= :lastSessionId`, but I'd also need to adjust the other conditions or pass dummy values (0?) for `lastCreatedOn`.hmmm, I still think that the two methods are fine for now.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7712,562625742,2021-01-22T13:21:02Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/DefaultLazyLoader.java,"@@ -28,14 +28,19 @@ public class DefaultLazyLoader<S, D> implements LazyLoader<S, D> {      private final Function<S, D> loader;-    private Supplier<D> fallback;+    private final Supplier<D> fallback;     private D data;      public DefaultLazyLoader(Function<S, D> loader, Supplier<D> fallback) {         this.loader = loader;         this.fallback = fallback;     } +    public DefaultLazyLoader(Function<S, D> loader) {+        this.loader = loader;+        this.fallback = null;",Don't we potentially risk an NPE here:https://github.com/keycloak/keycloak/blob/5a02edd02663905056d6744f299f3060afcd2232/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/DefaultLazyLoader.java#L48,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7712,562640184,2021-01-22T13:45:54Z,model/jpa/src/main/java/org/keycloak/models/jpa/entities/ClientEntity.java,"@@ -156,9 +157,10 @@     @ElementCollection     @Column(name=""ROLE_ID"")     @CollectionTable(name=""SCOPE_MAPPING"", joinColumns = { @JoinColumn(name=""CLIENT_ID"")})+    @BatchSize(size = 20)     private Set<String> scopeMappingIds;","Just out of curiosity, why aren't the scopes lazily loaded (and [lazily cached](https://github.com/keycloak/keycloak/blob/5a02edd02663905056d6744f299f3060afcd2232/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedClient.java#L78))? Is it better for performance (scopes are always needed)?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7736,564352390,2021-01-26T09:08:56Z,server-spi/src/main/java/org/keycloak/models/UserSessionProvider.java,"@@ -138,6 +138,14 @@ UserSessionModel createUserSession(String id, RealmModel realm, UserModel user,     void removeUserSession(RealmModel realm, UserSessionModel session);     void removeUserSessions(RealmModel realm, UserModel user); +    /**+     * Remove expired events in all the realms.+     * Implementation doesn't need to propagate removal of expired userSessions to userSessionPersister. Cleanup on persister will be called separately+     */+    default void removeAllExpired(KeycloakSession session) {",Is it necessary to introduce `KeycloakSession` parameter? `UserSessionProvider` instance is always aware of the session it was created with. Seems like this would introduce an exception to the rest of the methods.,
52280032,StefAtMentech,https://api.github.com/repos/keycloak/keycloak/pulls/7737,564557762,2021-01-26T14:35:47Z,services/src/main/java/org/keycloak/authorization/protection/permission/PermissionTicketService.java,"@@ -226,6 +226,52 @@ public Response find(@QueryParam(""scopeId"") String scopeId,                 .build();     } +    @Path(""/count"")+    @GET+    @Produces(""application/json"")+    public Response getResourceCount(@QueryParam(""scopeId"") String scopeId,+                                       @QueryParam(""resourceId"") String resourceId,+                                       @QueryParam(""owner"") String owner,+                                       @QueryParam(""requester"") String requester,+                                       @QueryParam(""granted"") Boolean granted,+                                       @QueryParam(""returnNames"") Boolean returnNames) {+        StoreFactory storeFactory = authorization.getStoreFactory();+        PermissionTicketStore permissionTicketStore = storeFactory.getPermissionTicketStore();+        Map<String, String> filters = new HashMap<>();++        if (resourceId != null) {","Line 238 - 267 have been copied from the find endpoint, so it's duplicate. Should it be extracted as a new method?",
52280032,StefAtMentech,https://api.github.com/repos/keycloak/keycloak/pulls/7737,564559546,2021-01-26T14:37:56Z,model/jpa/src/main/java/org/keycloak/authorization/jpa/store/JPAPermissionTicketStore.java,"@@ -57,6 +57,63 @@ public JPAPermissionTicketStore(EntityManager entityManager, AuthorizationProvid         this.provider = provider;     } +    @Override+    public long count(Map<String, String> attributes, String resourceServerId) {+        CriteriaBuilder builder = entityManager.getCriteriaBuilder();+        CriteriaQuery<Long> querybuilder = builder.createQuery(Long.class);+        Root<PermissionTicketEntity> root = querybuilder.from(PermissionTicketEntity.class);++        querybuilder.select(root.get(""id""));++        List<Predicate> predicates = new ArrayList();++        if (resourceServerId != null) {+            predicates.add(builder.equal(root.get(""resourceServer"").get(""id""), resourceServerId));+        }++        attributes.forEach((name, value) -> {+            if (PermissionTicket.ID.equals(name)) {+                predicates.add(root.get(name).in(value));+            } else if (PermissionTicket.SCOPE.equals(name)) {+                predicates.add(root.join(""scope"").get(""id"").in(value));+            } else if (PermissionTicket.SCOPE_IS_NULL.equals(name)) {+                if (Boolean.valueOf(value)) {+                    predicates.add(builder.isNull(root.get(""scope"")));+                } else {+                    predicates.add(builder.isNotNull(root.get(""scope"")));+                }+            } else if (PermissionTicket.RESOURCE.equals(name)) {+                predicates.add(root.join(""resource"").get(""id"").in(value));+            } else if (PermissionTicket.RESOURCE_NAME.equals(name)) {+                predicates.add(root.join(""resource"").get(""name"").in(value));+            } else if (PermissionTicket.OWNER.equals(name)) {+                predicates.add(builder.equal(root.get(""owner""), value));+            } else if (PermissionTicket.REQUESTER.equals(name)) {+                predicates.add(builder.equal(root.get(""requester""), value));+            } else if (PermissionTicket.GRANTED.equals(name)) {+                if (Boolean.valueOf(value)) {+                    predicates.add(builder.isNotNull(root.get(""grantedTimestamp"")));+                } else {+                    predicates.add(builder.isNull(root.get(""grantedTimestamp"")));+                }+            } else if (PermissionTicket.REQUESTER_IS_NULL.equals(name)) {+                predicates.add(builder.isNull(root.get(""requester"")));+            } else if (PermissionTicket.POLICY_IS_NOT_NULL.equals(name)) {+                predicates.add(builder.isNotNull(root.get(""policy"")));+            } else if (PermissionTicket.POLICY.equals(name)) {+                predicates.add(root.join(""policy"").get(""id"").in(value));+            } else {+                throw new RuntimeException(""Unsupported filter ["" + name + ""]"");+            }+        });++        querybuilder.where(predicates.toArray(new Predicate[predicates.size()])).orderBy(builder.asc(root.get(""id"")));++        TypedQuery query = entityManager.createQuery(querybuilder);","Line 62 - 112 have been copied from the .find() method, so it's duplicate. Should it be extracted as a new method?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,565513927,2021-01-27T17:52:55Z,services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java,"@@ -0,0 +1,281 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.ciba.decoupledauthn;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.keycloak.OAuthErrorException;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.common.util.Time;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.ciba.CIBAAuthReqId;+import org.keycloak.protocol.ciba.CIBAConstants;+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.Urls;++public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {","Maybe we can change this class to `HTTPAuthenticationProvider`?Or maybe, introduce the concept of an authentication channel and have `HttpAuthenticationChannel`.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,565576286,2021-01-27T19:28:25Z,services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java,"@@ -0,0 +1,281 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.ciba.decoupledauthn;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.keycloak.OAuthErrorException;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.common.util.Time;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.ciba.CIBAAuthReqId;+import org.keycloak.protocol.ciba.CIBAConstants;+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.Urls;++public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {++    private static final Logger logger = Logger.getLogger(DelegateDecoupledAuthenticationProvider.class);++    private final String decoupledAuthenticationRequestUri;++    public DelegateDecoupledAuthenticationProvider(KeycloakSession session, String decoupledAuthenticationRequestUri) {+        super(session);+        this.decoupledAuthenticationRequestUri = decoupledAuthenticationRequestUri;+    }++    private String scope;+    private String userSessionIdWillBeCreated;+    private String userIdToBeAuthenticated;+    private String authResultId;+    private int expiration;++    @Override+    protected String getScope() {+        return scope;+    }++    @Override+    protected String getUserSessionIdWillBeCreated() {+        return userSessionIdWillBeCreated;+    }++    @Override+    protected String getUserIdToBeAuthenticated() {+        return userIdToBeAuthenticated;+    }++    @Override+    protected String getAuthResultId() {+        return authResultId;+    }++    @Override+    protected int getExpiration() {+        return expiration;+    }++    @Override+    protected Response verifyDecoupledAuthnResult() {+        String decoupledAuthId = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_ID);+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);++        if (parseResult.isIllegalDecoupledAuthId()) {+            event.error(Errors.INVALID_INPUT);+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);+            // decoupled auth id format is invalid or it has already been used+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""invalid decoupled authn id"", Response.Status.BAD_REQUEST);+        } else if (parseResult.isExpiredDecoupledAuthId()) {+            event.error(Errors.SESSION_EXPIRED);+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);+            return cors.builder(Response.ok("""", MediaType.APPLICATION_JSON_TYPE)).build();+        }++        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();+        authResultId = decoupledAuthIdJwt.getAuthResultId();+        scope = decoupledAuthIdJwt.getScope();+        expiration = decoupledAuthIdJwt.getExp().intValue();+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member ""client"".+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());++        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);+        if (resolver == null) {+            throw new RuntimeException(""CIBA Login User Resolver not setup properly."");+        }+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_USER_INFO)).getId();",Shall we validate the inputs and avoid unexpected errors ? What happens if the form parameter is null ? I guess we want to return `400` ?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,565607680,2021-01-27T20:21:30Z,services/src/main/java/org/keycloak/protocol/ciba/utils/DecoupledAuthnResultParser.java,"@@ -0,0 +1,110 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.ciba.utils;++import java.util.Map;+import java.util.UUID;++import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.models.CodeToTokenStoreProvider;+import org.keycloak.models.KeycloakSession;++public class DecoupledAuthnResultParser {++    private static final Logger logger = Logger.getLogger(DecoupledAuthnResultParser.class);++    public static void persistDecoupledAuthnResult(KeycloakSession session, String id, DecoupledAuthnResult decoupledAuthnResultData, int expires_in) {+        CodeToTokenStoreProvider codeStore = session.getProvider(CodeToTokenStoreProvider.class);++        if (id == null) {+            throw new IllegalStateException(""ID not present in the data"");+        }+        UUID key = UUID.fromString(id);++        Map<String, String> serialized = decoupledAuthnResultData.serializeCode();+        codeStore.put(key, expires_in, serialized);","I think `expires_in` is in milliseconds and the provider is going to set expiration based on seconds. That would cause entries to take a lot of time to expire, and not really what you are expected.See https://github.com/keycloak/keycloak/blob/80f4bd382225d35b6177ce2c9b7ab7fa84e0d1fd/model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanCodeToTokenStoreProvider.java#L54.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7736,565981313,2021-01-28T10:27:30Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/util/SessionTimeouts.java,"@@ -0,0 +1,293 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.models.sessions.infinispan.util;++import org.keycloak.common.util.Time;+import org.keycloak.models.RealmModel;+import org.keycloak.models.sessions.infinispan.entities.AuthenticatedClientSessionEntity;+import org.keycloak.models.sessions.infinispan.entities.LoginFailureEntity;+import org.keycloak.models.sessions.infinispan.entities.UserSessionEntity;+import org.keycloak.models.utils.SessionTimeoutHelper;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class SessionTimeouts {++    /**+     * This indicates that entry is already expired and should be removed from the cache+     */+    public static final long ENTRY_EXPIRED_FLAG = -2l;++    /**+     * This is used just if timeouts are not set on the realm (usually happens just during tests when realm is created manually with the model API)+     */+    public static final int MINIMAL_EXPIRATION_SEC = 300;++    /**+     * Get the maximum lifespan, which this userSession can remain in the infinispan cache.+     * Returned value will be used as ""lifespan"" when calling put/replace operation in the infinispan cache for this entity+     *+     * @param realm+     * @param userSessionEntity+     * @return+     */+    public static Long getUserSessionLifespanMs(RealmModel realm, UserSessionEntity userSessionEntity) {+        int timeSinceSessionStart = Time.currentTime() - userSessionEntity.getStarted();++        int sessionMaxLifespan = Math.max(realm.getSsoSessionMaxLifespan(), MINIMAL_EXPIRATION_SEC);+        if (userSessionEntity.isRememberMe()) {+            sessionMaxLifespan = Math.max(realm.getSsoSessionMaxLifespanRememberMe(), sessionMaxLifespan);+        }++        long timeToExpire = sessionMaxLifespan - timeSinceSessionStart;++        // Indication that entry should be expired+        if (timeToExpire <=0) {+            return ENTRY_EXPIRED_FLAG;+        }++        return timeToExpire * 1000;","I would extract the multiplication to a method called ""toMillis()"" or something similar.  ",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7736,565986705,2021-01-28T10:35:19Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProviderFactory.java,"@@ -245,47 +247,48 @@ protected void checkRemoteCaches(KeycloakSession session) {         InfinispanConnectionProvider ispn = session.getProvider(InfinispanConnectionProvider.class);          Cache<String, SessionEntityWrapper<UserSessionEntity>> sessionsCache = ispn.getCache(InfinispanConnectionProvider.USER_SESSION_CACHE_NAME);-        boolean sessionsRemoteCache = checkRemoteCache(session, sessionsCache, (RealmModel realm) -> {+        RemoteCache sessionsRemoteCache = checkRemoteCache(session, sessionsCache, (RealmModel realm) -> {             // We won't write to the remoteCache during token refresh, so the timeout needs to be longer.             return realm.getSsoSessionMaxLifespan() * 1000;",Similar to note above. Consider an extraction of multiplication to a separate method in this class.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7736,566221711,2021-01-28T16:16:05Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/util/SessionTimeouts.java,"@@ -0,0 +1,293 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.models.sessions.infinispan.util;++import org.keycloak.common.util.Time;+import org.keycloak.models.RealmModel;+import org.keycloak.models.sessions.infinispan.entities.AuthenticatedClientSessionEntity;+import org.keycloak.models.sessions.infinispan.entities.LoginFailureEntity;+import org.keycloak.models.sessions.infinispan.entities.UserSessionEntity;+import org.keycloak.models.utils.SessionTimeoutHelper;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class SessionTimeouts {++    /**+     * This indicates that entry is already expired and should be removed from the cache+     */+    public static final long ENTRY_EXPIRED_FLAG = -2l;++    /**+     * This is used just if timeouts are not set on the realm (usually happens just during tests when realm is created manually with the model API)+     */+    public static final int MINIMAL_EXPIRATION_SEC = 300;++    /**+     * Get the maximum lifespan, which this userSession can remain in the infinispan cache.+     * Returned value will be used as ""lifespan"" when calling put/replace operation in the infinispan cache for this entity+     *+     * @param realm+     * @param userSessionEntity+     * @return+     */+    public static Long getUserSessionLifespanMs(RealmModel realm, UserSessionEntity userSessionEntity) {+        int timeSinceSessionStart = Time.currentTime() - userSessionEntity.getStarted();++        int sessionMaxLifespan = Math.max(realm.getSsoSessionMaxLifespan(), MINIMAL_EXPIRATION_SEC);+        if (userSessionEntity.isRememberMe()) {+            sessionMaxLifespan = Math.max(realm.getSsoSessionMaxLifespanRememberMe(), sessionMaxLifespan);+        }++        long timeToExpire = sessionMaxLifespan - timeSinceSessionStart;++        // Indication that entry should be expired+        if (timeToExpire <=0) {+            return ENTRY_EXPIRED_FLAG;+        }++        return timeToExpire * 1000;","I figured we already have the generic util method ""Time.toMillis"" for this, so I've just used that one :) Just changed the argument type to ""long"" for Time.toMillis (it was int before).",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7736,566300355,2021-01-28T18:03:41Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/util/SessionTimeouts.java,"@@ -0,0 +1,293 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.models.sessions.infinispan.util;++import org.keycloak.common.util.Time;+import org.keycloak.models.RealmModel;+import org.keycloak.models.sessions.infinispan.entities.AuthenticatedClientSessionEntity;+import org.keycloak.models.sessions.infinispan.entities.LoginFailureEntity;+import org.keycloak.models.sessions.infinispan.entities.UserSessionEntity;+import org.keycloak.models.utils.SessionTimeoutHelper;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class SessionTimeouts {++    /**+     * This indicates that entry is already expired and should be removed from the cache+     */+    public static final long ENTRY_EXPIRED_FLAG = -2l;++    /**+     * This is used just if timeouts are not set on the realm (usually happens just during tests when realm is created manually with the model API)+     */+    public static final int MINIMAL_EXPIRATION_SEC = 300;++    /**+     * Get the maximum lifespan, which this userSession can remain in the infinispan cache.+     * Returned value will be used as ""lifespan"" when calling put/replace operation in the infinispan cache for this entity+     *+     * @param realm+     * @param userSessionEntity+     * @return+     */+    public static Long getUserSessionLifespanMs(RealmModel realm, UserSessionEntity userSessionEntity) {",Should this return `long` rather than `Long`? It seems never to return `null`. (similarly for the rest of this class),
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566352703,2021-01-28T19:28:33Z,server-spi-private/src/main/java/org/keycloak/models/session/UserSessionPersisterProvider.java,"@@ -56,6 +56,37 @@     // Remove userSessions and clientSessions, which are expired     void removeExpired(RealmModel realm); +    /**+     * Loads the user session with the given userSessionId.+     * @param userSessionId+     * @param offline+     * @return+     */+    UserSessionModel loadUserSession(String userSessionId, boolean offline);++    /**+     * Loads the user sessions for the given {@link UserModel} in the given {@link RealmModel} if present.+     * @param firstResult+     * @param maxResults+     * @param realm+     * @param user+     * @param offline+     * @return+     */+    Stream<UserSessionModel> loadUserSessionsStream(Integer firstResult, Integer maxResults, RealmModel realm, UserModel user, boolean offline);","Please keep the order of parameters consistent with the rest of the code, `realm` and `user` should be first.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566352812,2021-01-28T19:28:42Z,server-spi-private/src/main/java/org/keycloak/models/session/UserSessionPersisterProvider.java,"@@ -56,6 +56,37 @@     // Remove userSessions and clientSessions, which are expired     void removeExpired(RealmModel realm); +    /**+     * Loads the user session with the given userSessionId.+     * @param userSessionId+     * @param offline+     * @return+     */+    UserSessionModel loadUserSession(String userSessionId, boolean offline);++    /**+     * Loads the user sessions for the given {@link UserModel} in the given {@link RealmModel} if present.+     * @param firstResult+     * @param maxResults+     * @param realm+     * @param user+     * @param offline+     * @return+     */+    Stream<UserSessionModel> loadUserSessionsStream(Integer firstResult, Integer maxResults, RealmModel realm, UserModel user, boolean offline);++    /**+     * Loads the user sessions for the given {@link ClientModel} in the given {@link RealmModel} if present.+     *+     * @param firstResult+     * @param maxResults+     * @param realm+     * @param client+     * @param offline+     * @return+     */+    Stream<UserSessionModel> loadUserSessionsStream(Integer firstResult, Integer maxResults, RealmModel realm, ClientModel client, boolean offline);","Please keep the order of parameters consistent with the rest of the code, `realm` and `user` should be first.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566353700,2021-01-28T19:30:09Z,server-spi-private/src/main/java/org/keycloak/models/session/UserSessionPersisterProvider.java,"@@ -78,6 +109,19 @@     Stream<UserSessionModel> loadUserSessionsStream(Integer firstResult, Integer maxResults, boolean offline,                                                     Integer lastCreatedOn, String lastUserSessionId); +    /**+     * Retrieves the count of user sessions+     * @param offline+     * @return+     */     int getUserSessionsCount(boolean offline); +    /**+     * Retrieves the count of user client-sessions for the given client+     * @param offline+     * @param clientModel+     * @return+     */+    int getUserSessionsCount(boolean offline, ClientModel clientModel);","Please keep the order of parameters consistent with the rest of the code, there should be `RealmModel realm` as well, and right after that `client`.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566356445,2021-01-28T19:34:57Z,server-spi-private/src/main/java/org/keycloak/models/session/UserSessionPersisterProvider.java,"@@ -56,6 +56,37 @@     // Remove userSessions and clientSessions, which are expired     void removeExpired(RealmModel realm); +    /**+     * Loads the user session with the given userSessionId.+     * @param userSessionId+     * @param offline+     * @return+     */+    UserSessionModel loadUserSession(String userSessionId, boolean offline);",This methods also needs to have `RealmModel realm` parameter to prevent cross-realm queries.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7738,566392936,2021-01-28T20:40:53Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/JpaUserSessionPersisterProviderFactory.java,"@@ -43,6 +44,11 @@ public void init(Config.Scope config) {      } +    @Override","Ah, my bad, it's already done. Please ignore this comment :-) ",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566402628,2021-01-28T20:58:54Z,server-spi-private/src/main/java/org/keycloak/models/session/UserSessionPersisterProvider.java,"@@ -56,6 +56,37 @@     // Remove userSessions and clientSessions, which are expired     void removeExpired(RealmModel realm); +    /**+     * Loads the user session with the given userSessionId.+     * @param userSessionId+     * @param offline+     * @return+     */+    UserSessionModel loadUserSession(String userSessionId, boolean offline);++    /**+     * Loads the user sessions for the given {@link UserModel} in the given {@link RealmModel} if present.+     * @param firstResult+     * @param maxResults+     * @param realm+     * @param user+     * @param offline+     * @return+     */+    Stream<UserSessionModel> loadUserSessionsStream(Integer firstResult, Integer maxResults, RealmModel realm, UserModel user, boolean offline);","That's what I did... look at [UserSessionPersisterProvider#loadUserSessions](https://github.com/keycloak/keycloak/blob/922d7da3aea4c512711afde2b6a4132382a933d3/server-spi-private/src/main/java/org/keycloak/models/session/UserSessionPersisterProvider.java#L64), but I'll adapt.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566404200,2021-01-28T21:01:46Z,server-spi-private/src/main/java/org/keycloak/models/session/UserSessionPersisterProvider.java,"@@ -78,6 +109,19 @@     Stream<UserSessionModel> loadUserSessionsStream(Integer firstResult, Integer maxResults, boolean offline,                                                     Integer lastCreatedOn, String lastUserSessionId); +    /**+     * Retrieves the count of user sessions+     * @param offline+     * @return+     */     int getUserSessionsCount(boolean offline); +    /**+     * Retrieves the count of user client-sessions for the given client+     * @param offline+     * @param clientModel+     * @return+     */+    int getUserSessionsCount(boolean offline, ClientModel clientModel);","I'll adapt and generally agree, but I think the realm makes no sense here since, the sole real implementation queries the `PersistentClientSessionEntity` via underlying query `PersistentClientSessionEntity.findClientSessionsCountByClient` filtered by the given client id. Also the entity `PersistentClientSessionEntity` does not have a `realmId` attribute.I can add the parameter but I'd need to ignore it in the JPA implementation.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566452377,2021-01-28T22:31:39Z,server-spi-private/src/main/java/org/keycloak/models/session/UserSessionPersisterProvider.java,"@@ -78,6 +109,19 @@     Stream<UserSessionModel> loadUserSessionsStream(Integer firstResult, Integer maxResults, boolean offline,                                                     Integer lastCreatedOn, String lastUserSessionId); +    /**+     * Retrieves the count of user sessions+     * @param offline+     * @return+     */     int getUserSessionsCount(boolean offline); +    /**+     * Retrieves the count of user client-sessions for the given client+     * @param offline+     * @param clientModel+     * @return+     */+    int getUserSessionsCount(boolean offline, ClientModel clientModel);","Fixed, by adding the `RealmModel` parameter which is ignored by the JPA implementation.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566708350,2021-01-29T10:02:39Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/PersistentUserSessionEntity.java,"@@ -37,11 +37,27 @@         @NamedQuery(name=""deleteExpiredUserSessions"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId AND sess.offline = :offline AND sess.lastSessionRefresh < :lastSessionRefresh""),         @NamedQuery(name=""updateUserSessionLastSessionRefresh"", query=""update PersistentUserSessionEntity sess set lastSessionRefresh = :lastSessionRefresh where sess.realmId = :realmId"" +                 "" AND sess.offline = :offline AND sess.userSessionId IN (:userSessionIds)""),-        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline""),+        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline and (sess.realmId = :realmId or :realmId is null)""),","Is there any valid way to have `realmId == NULL`? Any session belongs to a realm, so if `realmId` is `null`, this would indicate a bug.```suggestion        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline and sess.realmId = :realmId""),```This seems to stem from the change in `getUserSessionsCount(boolean offline)` that now delegates to `getUserSessionsCount(realm, offline)` and passes in `null` in `realm`. This change should be reverted, as the condition `realmID IS null` should lead to empty result.The change is only needed in the case of the newly introduced `int getUserSessionsCount(boolean offline, ClientModel clientModel);` variant that needs to have `RealmModel` as well.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566737543,2021-01-29T10:52:17Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/PersistentUserSessionEntity.java,"@@ -37,11 +37,27 @@         @NamedQuery(name=""deleteExpiredUserSessions"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId AND sess.offline = :offline AND sess.lastSessionRefresh < :lastSessionRefresh""),         @NamedQuery(name=""updateUserSessionLastSessionRefresh"", query=""update PersistentUserSessionEntity sess set lastSessionRefresh = :lastSessionRefresh where sess.realmId = :realmId"" +                 "" AND sess.offline = :offline AND sess.userSessionId IN (:userSessionIds)""),-        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline""),+        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline and (sess.realmId = :realmId or :realmId is null)""),","realm==null means that the count of all user sessions is returned, across all realms. This is currently used by [OfflinePersistentUserSessionLoader](https://github.com/keycloak/keycloak/blob/8432513daa1c19437b48b2a87dcc97e093212008/model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/initializer/OfflinePersistentUserSessionLoader.java#L67) and other places.The condition `and (sess.realmId = :realmId or :realmId is null)` allows to use the query for two use cases. Find counts by realm and across all realms.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566750344,2021-01-29T11:15:56Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/PersistentUserSessionEntity.java,"@@ -37,11 +37,27 @@         @NamedQuery(name=""deleteExpiredUserSessions"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId AND sess.offline = :offline AND sess.lastSessionRefresh < :lastSessionRefresh""),         @NamedQuery(name=""updateUserSessionLastSessionRefresh"", query=""update PersistentUserSessionEntity sess set lastSessionRefresh = :lastSessionRefresh where sess.realmId = :realmId"" +                 "" AND sess.offline = :offline AND sess.userSessionId IN (:userSessionIds)""),-        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline""),+        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline and (sess.realmId = :realmId or :realmId is null)""),","That's correct, but the query this way can effectively cause a database to perform evaluation of the `OR` condition instead of using index lookup. For that reason, two separate queries for this two cases would be preferrable.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,566989120,2021-01-29T17:45:52Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -607,6 +722,11 @@ public void removeUserSessions(RealmModel realm) {         clusterEventsSenderTx.addEvent(                 RemoveUserSessionsEvent.createEvent(RemoveUserSessionsEvent.class, InfinispanUserSessionProviderFactory.REMOVE_USER_SESSIONS_EVENT, session, realm.getId(), true),                 ClusterProvider.DCNotify.LOCAL_DC_ONLY);++        log.debugf(""Removing user sessions for realm via persistence provider. realm=%s"", realm.getId());","`RealmAdminResource#logoutAll` called when admin-console -> ""logout all sessions"" is invoked.The infinispan code path invalidates and clears all sessions from memory, hence offline-tokens can no longer be used.However, the offline user sessions remain listed in the database, but they cannot be reclaimed / reused anymore. Even a sever restart doesn't bring them life.I think this dangling (offline) user-sessions needs to be cleared from the database, if the sessions are removed.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,567684616,2021-02-01T09:43:17Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -607,6 +722,11 @@ public void removeUserSessions(RealmModel realm) {         clusterEventsSenderTx.addEvent(                 RemoveUserSessionsEvent.createEvent(RemoveUserSessionsEvent.class, InfinispanUserSessionProviderFactory.REMOVE_USER_SESSIONS_EVENT, session, realm.getId(), true),                 ClusterProvider.DCNotify.LOCAL_DC_ONLY);++        log.debugf(""Removing user sessions for realm via persistence provider. realm=%s"", realm.getId());","May I leave the code `UserSessionPersisterProvider#removeUserSessions(realm,offline)` in? This could then at least be used by users in custom extensions who need this functionality.Btw. I know of several customers who need a true logout-all feature including offline user-sessions.At a later stage we could add an optional `Boolean offlineSessions` parameter to `RealmAdminResource#logoutAll` to control the behavior.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,567737666,2021-02-01T11:04:15Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -270,8 +336,37 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool         return entity;     } +    private Stream<UserSessionModel> getUserSessionsFromPersistenceProviderStream(RealmModel realm, UserModel user, boolean offline) {+        UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class);+        return persister.loadUserSessionsStream(realm, user, offline, 0, null)+                .map(persistentUserSession -> getUserSessionEntityFromCacheOrImportIfNecessary(realm, offline, persistentUserSession))+                .filter(Objects::nonNull)+                .map(userSessionEntity -> wrap(realm, userSessionEntity, offline));+    }+++    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserSessionPredicate predicate, boolean offline) {++        if (offline && loadOfflineSessionsStatsFromDatabase) {++            // fetch the offline user-sessions from the persistence provider+            UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class);++            UserModel user = session.users().getUserById(realm, predicate.getUserId());+            if (user != null) {+                return persister.loadUserSessionsStream(realm, user, offline, 0, null);+            }++            // TODO add support for offline user-session lookup by brokerSessionId",@hmlnarik Based on the [discussion here](https://github.com/keycloak/keycloak/pull/7722#issuecomment-770723908): which exception should I throw here?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,567812431,2021-02-01T13:10:50Z,server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java,"@@ -394,12 +401,19 @@ public static RealmRepresentation toRepresentation(RealmModel realm, boolean int         rep.setWebAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister(webAuthnPolicy.isAvoidSameAuthenticatorRegister());         rep.setWebAuthnPolicyPasswordlessAcceptableAaguids(webAuthnPolicy.getAcceptableAaguids()); +        CIBAPolicy cibaPolicy = realm.getCIBAPolicy();","What you said is basically how we do things today. I was thinking about the opposite, where CIBA related properties are grouped within a top-level type as you did for the `RealmModel`.It sounds like a nitpick, but we have been discussing how to improve our extensibility so that you don't need to change core components such as the representation or model, when a new feature like CIBA needs to be introduced.For this concrete case, I think having `CIBAPolicy` in the representation (similarly as you did to the model) helps to track (at least for now, considering we are not yet there in terms of our extensibility goals) CIBA related code more easily. And a possible smother refactoring in the future.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7722,567963807,2021-02-01T16:32:30Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -270,8 +336,37 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool         return entity;     } +    private Stream<UserSessionModel> getUserSessionsFromPersistenceProviderStream(RealmModel realm, UserModel user, boolean offline) {+        UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class);+        return persister.loadUserSessionsStream(realm, user, offline, 0, null)+                .map(persistentUserSession -> getUserSessionEntityFromCacheOrImportIfNecessary(realm, offline, persistentUserSession))+                .filter(Objects::nonNull)+                .map(userSessionEntity -> wrap(realm, userSessionEntity, offline));+    }+++    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserSessionPredicate predicate, boolean offline) {++        if (offline && loadOfflineSessionsStatsFromDatabase) {++            // fetch the offline user-sessions from the persistence provider+            UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class);++            UserModel user = session.users().getUserById(realm, predicate.getUserId());+            if (user != null) {+                return persister.loadUserSessionsStream(realm, user, offline, 0, null);+            }++            // TODO add support for offline user-session lookup by brokerSessionId","My vote is to throw ModelException as InfinispanUserSessionProvider is model implementation.I am not 100% sure if we want to catch that exception in LogoutEndpoint and transform into some proper ErrorResponseException, or if we just don't handle exception? But IMO this is not user-related error (like for example updating password which doesn't match the password policy), but it is rather system error. Administrator should be aware that the use-case is not supported, so it will be ideal to make sure that it is shown in the server log and probably should be passed to the Event API as well.Will be great if you have a chance to add automated test for this error scenario or at least check it manually. WDYT?And I would throw the exception for both getOfflineUserSessionByBrokerSessionId and getOfflineUserSessionByBrokerUserId.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,568285402,2021-02-02T02:47:24Z,server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java,"@@ -394,12 +401,19 @@ public static RealmRepresentation toRepresentation(RealmModel realm, boolean int         rep.setWebAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister(webAuthnPolicy.isAvoidSameAuthenticatorRegister());         rep.setWebAuthnPolicyPasswordlessAcceptableAaguids(webAuthnPolicy.getAcceptableAaguids()); +        CIBAPolicy cibaPolicy = realm.getCIBAPolicy();","@pedroigor Thank you for the clarification. I would like to follow your idea, namely managing CIBA related properties without changing core components like representations and models.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7751,568378650,2021-02-02T07:35:07Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/LogoutTest.java,"@@ -328,6 +333,76 @@ public void backchannelLogoutRequest_RealmRS384_ClientRS512() throws Exception {         }     } +    @Test+    public void successfulKLogoutAfterEmptyBackChannelUrl() throws Exception {+        ClientsResource clients = adminClient.realm(oauth.getRealm()).clients();+        ClientRepresentation rep = clients.findByClientId(oauth.getClientId()).get(0);++        rep.getAttributes().put(OIDCConfigAttributes.BACKCHANNEL_LOGOUT_URL, """");++        clients.get(rep.getId()).update(rep);",Would this change be cleaned up in case of test failure?`ClientAttributeUpdater` class may help here,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7736,569243870,2021-02-03T09:08:57Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/remotestore/RemoteCacheSessionListener.java,"@@ -156,18 +183,35 @@ protected void replaceRemoteEntityInCache(K key, long eventVersion) {             }             SessionEntity remoteSession = remoteSessionVersioned.getValue().getEntity(); -            logger.debugf(""Read session entity from the remote cache: %s . replaceRetries=%d"", remoteSession.toString(), replaceRetries);+            logger.tracef(""Read session entity from the remote cache: %s . replaceRetries=%d"", remoteSession, replaceRetries);              SessionEntityWrapper<V> sessionWrapper = remoteSession.mergeRemoteEntityWithLocalEntity(localEntityWrapper); +            RealmModel realm = realmRef.get();+            if (realm == null) {++                KeycloakModelUtils.runJobInTransaction(sessionFactory, (session -> {++                    realmRef.set(session.realms().getRealm(sessionWrapper.getEntity().getRealmId()));++                }));++                realm = realmRef.get();+            }++            long lifespanMs = lifespanMsLoader.apply(realm, sessionWrapper.getEntity());+            long maxIdleTimeMs = maxIdleTimeMsLoader.apply(realm, sessionWrapper.getEntity());","Could determining `lifespanMs` and `maxIdleTimeMs` be returned back into the `runJobInTransaction` function? The current state may not work if e.g. the `realm` is only a partially cached object that does not have lifespans defined and delegates the lookup lazily only when queried; however this would fail since the lazy loading needs an active transaction and the transaction currently ends before this lookup.Disclaimer: We don't have it in the current codebase but it is possible, even with the current store, and it is one of the discussed optimization for the new store.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7736,569302965,2021-02-03T10:33:18Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/remotestore/RemoteCacheSessionListener.java,"@@ -156,18 +183,35 @@ protected void replaceRemoteEntityInCache(K key, long eventVersion) {             }             SessionEntity remoteSession = remoteSessionVersioned.getValue().getEntity(); -            logger.debugf(""Read session entity from the remote cache: %s . replaceRetries=%d"", remoteSession.toString(), replaceRetries);+            logger.tracef(""Read session entity from the remote cache: %s . replaceRetries=%d"", remoteSession, replaceRetries);              SessionEntityWrapper<V> sessionWrapper = remoteSession.mergeRemoteEntityWithLocalEntity(localEntityWrapper); +            RealmModel realm = realmRef.get();+            if (realm == null) {++                KeycloakModelUtils.runJobInTransaction(sessionFactory, (session -> {++                    realmRef.set(session.realms().getRealm(sessionWrapper.getEntity().getRealmId()));++                }));++                realm = realmRef.get();+            }++            long lifespanMs = lifespanMsLoader.apply(realm, sessionWrapper.getEntity());+            long maxIdleTimeMs = maxIdleTimeMsLoader.apply(realm, sessionWrapper.getEntity());","@hmlnarik Thanks for clarifying this. I did not consider this for the new store.So the points to consider:- lifespanMsLoader and maxIdleTimeMsLoader needs to be called within the transaction due the reason you mentioned- Obtaining of RealmModel can't be easily moved outside of `do-while` to the top. As the ID of the realm is retrieved from the session, which is loaded inside the `do` block. With my latest change, the load of the RealmModel will be done only once (due the realmRef), however it won't work due the previous point- Computing of `lifespanMs` and `maxIdleTimeMs` depends on the realm, but also on the sessionEntity and it's ""lastSessionRefresh"" (for UserSEssion) or ""timestamp"" (ClientSession). And this timestamps can change. For example in first iteration of `do` the session may have timestamp 1000, but in the second iteration, the timestamp can be 2000 (as there was an update from concurrent transaction, which updated the timestamp and which then caused this conflict and the fact that second iteration of `do` was needed).Regarding this, I see the options are:1) Wrap the whole `do-while` into the `runJobInTransaction` block2) Revert to the behaviour as was before the latest change.It seems the (1) is better due the fact that (2) can mean multiple transactions as you pointed (even if this shouldn't happen too often as it is not big chance that same session is updated concurrently, but it is indeed possibility).Any better idea?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7540,569706631,2021-02-03T19:56:43Z,services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpDetectExistingBrokerUserAuthenticator.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.authentication.authenticators.broker;++import org.jboss.logging.Logger;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.authenticators.broker.util.ExistingUserInfo;+import org.keycloak.authentication.authenticators.broker.util.SerializedBrokeredIdentityContext;+import org.keycloak.broker.provider.BrokeredIdentityContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.services.ServicesLogger;++import static org.keycloak.authentication.AuthenticationFlowError.UNKNOWN_USER;++public class IdpDetectExistingBrokerUserAuthenticator extends IdpCreateUserIfUniqueAuthenticator {++    private static final Logger logger = Logger.getLogger(IdpDetectExistingBrokerUserAuthenticator.class);++    @Override+    protected void authenticateImpl(AuthenticationFlowContext context, SerializedBrokeredIdentityContext serializedCtx, BrokeredIdentityContext brokerContext) {++        RealmModel realm = context.getRealm();++        if (context.getAuthenticationSession().getAuthNote(EXISTING_USER_INFO) != null) {+            context.attempted();+            return;+        }++        String username = getUsername(context, serializedCtx, brokerContext);+        if (username == null) {+            ServicesLogger.LOGGER.resetFlow(realm.isRegistrationEmailAsUsername() ? ""Email"" : ""Username"");+            context.getAuthenticationSession().setAuthNote(ENFORCE_UPDATE_PROFILE, ""true"");+            context.resetFlow();+            return;+        }++        ExistingUserInfo duplication = checkExistingUser(context, username, serializedCtx, brokerContext);++        if (duplication == null) {+            logger.errorf(""The user %s should be already registered in the realm to login  %s"",username,  realm.getName());+            context.failure(UNKNOWN_USER);","I see in the test, that user will see ""Invalid username or error"", which doesn't look like correct error message. There will be probably some better message like ""Invalid user"" ? It is available as a constant Messages.INVALID_USER.For the inspiration, I suggest to take a look for example here https://github.com/keycloak/keycloak/blob/12.0.0/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticator.java#L103 for how to throw the error message and ensure that correct event is triggered.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,569759984,2021-02-03T21:24:44Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/PersistentUserSessionEntity.java,"@@ -32,16 +32,32 @@  * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>  */ @NamedQueries({-        @NamedQuery(name=""deleteUserSessionsByRealm"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId""),+        @NamedQuery(name=""deleteUserSessionsByRealm"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId and sess.offline = coalesce(:offline, sess.offline) ""),         @NamedQuery(name=""deleteUserSessionsByUser"", query=""delete from PersistentUserSessionEntity sess where sess.userId = :userId""),         @NamedQuery(name=""deleteExpiredUserSessions"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId AND sess.offline = :offline AND sess.lastSessionRefresh < :lastSessionRefresh""),         @NamedQuery(name=""updateUserSessionLastSessionRefresh"", query=""update PersistentUserSessionEntity sess set lastSessionRefresh = :lastSessionRefresh where sess.realmId = :realmId"" +                 "" AND sess.offline = :offline AND sess.userSessionId IN (:userSessionIds)""),-        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline""),+        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline and sess.realmId = coalesce(:realmId, sess.realmId)""),         @NamedQuery(name=""findUserSessions"", query=""select sess from PersistentUserSessionEntity sess where sess.offline = :offline"" +                 "" AND (sess.createdOn > :lastCreatedOn OR (sess.createdOn = :lastCreatedOn AND sess.userSessionId > :lastSessionId))"" +-                "" order by sess.createdOn,sess.userSessionId"")-+                "" order by sess.createdOn,sess.userSessionId""),+        @NamedQuery(name=""findUserSession"", query=""select sess from PersistentUserSessionEntity sess where sess.offline = :offline"" ++                "" AND sess.userSessionId = :userSessionId AND sess.realmId = :realmId""),+        @NamedQuery(name=""findUserSessionsByUserId"", query=""select sess from PersistentUserSessionEntity sess where sess.offline = :offline"" ++                "" AND sess.realmId = :realmId AND sess.userId = :userId""),+        @NamedQuery(name=""findUserSessionsByClientId"", query=""SELECT sess FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" ++                "" ON sess.userSessionId = clientSess.userSessionId AND clientSess.clientId = :clientId WHERE sess.offline = :offline "" ++                "" AND sess.userSessionId = clientSess.userSessionId AND sess.realmId = :realmId AND clientSess.clientId = :clientId""),+        @NamedQuery(name=""findUserSessionsCountsByClientId"", query=""SELECT clientSess.clientId, count(clientSess) "" ++                "" FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" ++                "" ON sess.userSessionId = clientSess.userSessionId "" ++                // find all available offline user-session for all or specific clients in a realm+                "" AND clientSess.clientId = coalesce(:clientId, clientSess.clientId) "" ++                "" WHERE sess.offline = :offline "" ++                "" AND sess.userSessionId = clientSess.userSessionId AND sess.realmId = :realmId "" ++                // find all available offline user-session for all or specific clients in a realm+                "" AND clientSess.clientId = coalesce(:clientId, clientSess.clientId) "" ++                "" GROUP BY clientSess.clientId"")",Most of these queries resort to plain seq scan because of missing / inappropriate indices.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,569761701,2021-02-03T21:27:36Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -270,8 +337,41 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool         return entity;     } +    private Stream<UserSessionModel> getUserSessionsFromPersistenceProviderStream(RealmModel realm, UserModel user, boolean offline) {+        UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class);+        return persister.loadUserSessionsStream(realm, user, offline, 0, null)+                .map(persistentUserSession -> getUserSessionEntityFromCacheOrImportIfNecessary(realm, offline, persistentUserSession))+                .filter(Objects::nonNull)+                .map(userSessionEntity -> wrap(realm, userSessionEntity, offline));+    }+++    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserSessionPredicate predicate, boolean offline) {++        if (offline && loadOfflineSessionsStatsFromDatabase) {++            // fetch the offline user-sessions from the persistence provider+            UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class);++            UserModel user = session.users().getUserById(realm, predicate.getUser());+            if (user != null) {+                return persister.loadUserSessionsStream(realm, user, offline, 0, null);+            }++            if (predicate.getBrokerSessionId() != null) {+                // TODO add support for offline user-session lookup by brokerSessionId+                // currently it is not possible to access the brokerSessionId in offline user-session in a database agnostic way+                throw new ModelException(""Dynamic database lookup for offline user-sessions by brokerSessionId is currently not supported."");+            }++            if (predicate.getBrokerUserId() != null) {+                // TODO add support for offline user-session lookup by brokerUserId+                // currently it is not possible to access the brokerUserId in offline user-session in a database agnostic way+                throw new ModelException(""Dynamic database lookup for offline user-sessions by brokerUserId is currently not supported."");","```suggestion                throw new ModelException(""Dynamic database lookup for offline user-sessions by brokerUserId is currently only supported for preloaded sessions."");```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,569761852,2021-02-03T21:27:47Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -270,8 +337,41 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool         return entity;     } +    private Stream<UserSessionModel> getUserSessionsFromPersistenceProviderStream(RealmModel realm, UserModel user, boolean offline) {+        UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class);+        return persister.loadUserSessionsStream(realm, user, offline, 0, null)+                .map(persistentUserSession -> getUserSessionEntityFromCacheOrImportIfNecessary(realm, offline, persistentUserSession))+                .filter(Objects::nonNull)+                .map(userSessionEntity -> wrap(realm, userSessionEntity, offline));+    }+++    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserSessionPredicate predicate, boolean offline) {++        if (offline && loadOfflineSessionsStatsFromDatabase) {++            // fetch the offline user-sessions from the persistence provider+            UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class);++            UserModel user = session.users().getUserById(realm, predicate.getUser());+            if (user != null) {+                return persister.loadUserSessionsStream(realm, user, offline, 0, null);+            }++            if (predicate.getBrokerSessionId() != null) {+                // TODO add support for offline user-session lookup by brokerSessionId+                // currently it is not possible to access the brokerSessionId in offline user-session in a database agnostic way+                throw new ModelException(""Dynamic database lookup for offline user-sessions by brokerSessionId is currently not supported."");","```suggestion                throw new ModelException(""Dynamic database lookup for offline user-sessions by brokerSessionId is currently only supported for preloaded sessions."");```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7737,570361018,2021-02-04T16:24:46Z,model/jpa/src/main/java/org/keycloak/authorization/jpa/store/JPAPermissionTicketStore.java,"@@ -57,6 +57,63 @@ public JPAPermissionTicketStore(EntityManager entityManager, AuthorizationProvid         this.provider = provider;     } +    @Override+    public long count(Map<String, String> attributes, String resourceServerId) {+        CriteriaBuilder builder = entityManager.getCriteriaBuilder();+        CriteriaQuery<Long> querybuilder = builder.createQuery(Long.class);+        Root<PermissionTicketEntity> root = querybuilder.from(PermissionTicketEntity.class);++        querybuilder.select(root.get(""id""));++        List<Predicate> predicates = new ArrayList();++        if (resourceServerId != null) {+            predicates.add(builder.equal(root.get(""resourceServer"").get(""id""), resourceServerId));+        }++        attributes.forEach((name, value) -> {+            if (PermissionTicket.ID.equals(name)) {+                predicates.add(root.get(name).in(value));+            } else if (PermissionTicket.SCOPE.equals(name)) {+                predicates.add(root.join(""scope"").get(""id"").in(value));+            } else if (PermissionTicket.SCOPE_IS_NULL.equals(name)) {+                if (Boolean.valueOf(value)) {+                    predicates.add(builder.isNull(root.get(""scope"")));+                } else {+                    predicates.add(builder.isNotNull(root.get(""scope"")));+                }+            } else if (PermissionTicket.RESOURCE.equals(name)) {+                predicates.add(root.join(""resource"").get(""id"").in(value));+            } else if (PermissionTicket.RESOURCE_NAME.equals(name)) {+                predicates.add(root.join(""resource"").get(""name"").in(value));+            } else if (PermissionTicket.OWNER.equals(name)) {+                predicates.add(builder.equal(root.get(""owner""), value));+            } else if (PermissionTicket.REQUESTER.equals(name)) {+                predicates.add(builder.equal(root.get(""requester""), value));+            } else if (PermissionTicket.GRANTED.equals(name)) {+                if (Boolean.valueOf(value)) {+                    predicates.add(builder.isNotNull(root.get(""grantedTimestamp"")));+                } else {+                    predicates.add(builder.isNull(root.get(""grantedTimestamp"")));+                }+            } else if (PermissionTicket.REQUESTER_IS_NULL.equals(name)) {+                predicates.add(builder.isNull(root.get(""requester"")));+            } else if (PermissionTicket.POLICY_IS_NOT_NULL.equals(name)) {+                predicates.add(builder.isNotNull(root.get(""policy"")));+            } else if (PermissionTicket.POLICY.equals(name)) {+                predicates.add(root.join(""policy"").get(""id"").in(value));+            } else {+                throw new RuntimeException(""Unsupported filter ["" + name + ""]"");+            }+        });++        querybuilder.where(predicates.toArray(new Predicate[predicates.size()])).orderBy(builder.asc(root.get(""id"")));++        TypedQuery query = entityManager.createQuery(querybuilder);++        return query.getResultStream().count();",Did you check how much this perform when a large number of permissions exist? How much are you expecting in your deployment?,
592810,efge,https://api.github.com/repos/keycloak/keycloak/pulls/7720,571690464,2021-02-07T20:47:46Z,adapters/spi/tomcat-adapter-spi/src/main/java/org/keycloak/adapters/tomcat/GenericPrincipalFactory.java,"@@ -22,46 +22,58 @@  import javax.security.auth.Subject; import java.security.Principal;-import java.security.acl.Group; import java.util.ArrayList;-import java.util.Collection; import java.util.Enumeration;-import java.util.Iterator;+import java.util.Collection; import java.util.List; import java.util.Set;  /**  * @author <a href=""mailto:ungarida@gmail.com"">Davide Ungari</a>  * @version $Revision: 1 $  */-public abstract class GenericPrincipalFactory {+public abstract class GenericPrincipalFactory implements PrincipleFactory { +    @Override     public GenericPrincipal createPrincipal(Realm realm, final Principal identity, final Set<String> roleSet) {-        Subject subject = new Subject();-        Set<Principal> principals = subject.getPrincipals();+        final Subject subject = new Subject();+        final Set<Principal> principals = subject.getPrincipals();","Please don't change code unrelated to the fix at hand.Adding `final` everywhere possible is a controversial style issue, many people consider it useless noise in the source code.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7722,571713276,2021-02-07T22:50:58Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/PersistentUserSessionEntity.java,"@@ -32,16 +32,32 @@  * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>  */ @NamedQueries({-        @NamedQuery(name=""deleteUserSessionsByRealm"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId""),+        @NamedQuery(name=""deleteUserSessionsByRealm"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId and sess.offline = coalesce(:offline, sess.offline) ""),         @NamedQuery(name=""deleteUserSessionsByUser"", query=""delete from PersistentUserSessionEntity sess where sess.userId = :userId""),         @NamedQuery(name=""deleteExpiredUserSessions"", query=""delete from PersistentUserSessionEntity sess where sess.realmId = :realmId AND sess.offline = :offline AND sess.lastSessionRefresh < :lastSessionRefresh""),         @NamedQuery(name=""updateUserSessionLastSessionRefresh"", query=""update PersistentUserSessionEntity sess set lastSessionRefresh = :lastSessionRefresh where sess.realmId = :realmId"" +                 "" AND sess.offline = :offline AND sess.userSessionId IN (:userSessionIds)""),-        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline""),+        @NamedQuery(name=""findUserSessionsCount"", query=""select count(sess) from PersistentUserSessionEntity sess where sess.offline = :offline and sess.realmId = coalesce(:realmId, sess.realmId)""),         @NamedQuery(name=""findUserSessions"", query=""select sess from PersistentUserSessionEntity sess where sess.offline = :offline"" +                 "" AND (sess.createdOn > :lastCreatedOn OR (sess.createdOn = :lastCreatedOn AND sess.userSessionId > :lastSessionId))"" +-                "" order by sess.createdOn,sess.userSessionId"")-+                "" order by sess.createdOn,sess.userSessionId""),+        @NamedQuery(name=""findUserSession"", query=""select sess from PersistentUserSessionEntity sess where sess.offline = :offline"" ++                "" AND sess.userSessionId = :userSessionId AND sess.realmId = :realmId""),+        @NamedQuery(name=""findUserSessionsByUserId"", query=""select sess from PersistentUserSessionEntity sess where sess.offline = :offline"" ++                "" AND sess.realmId = :realmId AND sess.userId = :userId""),+        @NamedQuery(name=""findUserSessionsByClientId"", query=""SELECT sess FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" ++                "" ON sess.userSessionId = clientSess.userSessionId AND clientSess.clientId = :clientId WHERE sess.offline = :offline "" ++                "" AND sess.userSessionId = clientSess.userSessionId AND sess.realmId = :realmId AND clientSess.clientId = :clientId""),+        @NamedQuery(name=""findUserSessionsCountsByClientId"", query=""SELECT clientSess.clientId, count(clientSess) "" ++                "" FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" ++                "" ON sess.userSessionId = clientSess.userSessionId "" ++                // find all available offline user-session for all or specific clients in a realm+                "" AND clientSess.clientId = coalesce(:clientId, clientSess.clientId) "" ++                "" WHERE sess.offline = :offline "" ++                "" AND sess.userSessionId = clientSess.userSessionId AND sess.realmId = :realmId "" ++                // find all available offline user-session for all or specific clients in a realm+                "" AND clientSess.clientId = coalesce(:clientId, clientSess.clientId) "" ++                "" GROUP BY clientSess.clientId"")","The query `findUserSession` results in the following SQL:```sql--- PersistentUserSessionEntity.findUserSessionselect persistent0_.OFFLINE_FLAG         as OFFLINE_1_41_,       persistent0_.USER_SESSION_ID      as USER_SES2_41_,       persistent0_.CREATED_ON           as CREATED_3_41_,       persistent0_.DATA                 as DATA4_41_,       persistent0_.LAST_SESSION_REFRESH as LAST_SES5_41_,       persistent0_.REALM_ID             as REALM_ID6_41_,       persistent0_.USER_ID              as USER_ID7_41_from OFFLINE_USER_SESSION persistent0_where persistent0_.OFFLINE_FLAG='1'  and persistent0_.USER_SESSION_ID='400c53b3-1c21-40a5-8a40-727f1f772805'  and created_on >0  and persistent0_.REALM_ID='acme'limit 1```by default the primary key index  is used:![image](https://user-images.githubusercontent.com/314690/107161768-3aac0280-699f-11eb-94a5-cf8ea8a3d0f3.png)The query `findUserSessionsByUserId` generates the following SQL:```sql--- PersistentUserSessionEntity.findUserSessionsByUserIdselect persistent0_.OFFLINE_FLAG         as OFFLINE_1_41_,       persistent0_.USER_SESSION_ID      as USER_SES2_41_,       persistent0_.CREATED_ON           as CREATED_3_41_,       persistent0_.DATA                 as DATA4_41_,       persistent0_.LAST_SESSION_REFRESH as LAST_SES5_41_,       persistent0_.REALM_ID             as REALM_ID6_41_,       persistent0_.USER_ID              as USER_ID7_41_from OFFLINE_USER_SESSION persistent0_where persistent0_.OFFLINE_FLAG='1'  and persistent0_.REALM_ID='acme'  and persistent0_.USER_ID='87511de7-165c-4a34-891d-d0db60872644'```The uses a combined bitmap scan![image](https://user-images.githubusercontent.com/314690/107161605-0d128980-699e-11eb-9824-50577937fb56.png)If I create a more specific index:```sqlcreate index idx_offline_uss_by_user on offline_user_session (offline_flag, realm_id, user_id);```Then the query is much quicker:![image](https://user-images.githubusercontent.com/314690/107161624-2c111b80-699e-11eb-88a8-ee5f7e364a68.png)The query `findUserSessionsByClientId` generates the following SQL:```sql--- PersistentUserSessionEntity.findUserSessionsByClientIdselect persistent0_.OFFLINE_FLAG         as OFFLINE_1_41_,       persistent0_.USER_SESSION_ID      as USER_SES2_41_,       persistent0_.CREATED_ON           as CREATED_3_41_,       persistent0_.DATA                 as DATA4_41_,       persistent0_.LAST_SESSION_REFRESH as LAST_SES5_41_,       persistent0_.REALM_ID             as REALM_ID6_41_,       persistent0_.USER_ID              as USER_ID7_41_from OFFLINE_USER_SESSION persistent0_         inner join OFFLINE_CLIENT_SESSION persistent1_                    on (persistent0_.USER_SESSION_ID = persistent1_.USER_SESSION_ID and persistent1_.CLIENT_ID='dce1b319-cac8-41af-bf11-123b768060c1')where persistent0_.OFFLINE_FLAG='1'  and persistent0_.USER_SESSION_ID = persistent1_.USER_SESSION_ID  and persistent0_.REALM_ID='acme'limit 5```and benefits from the index `idx_offline_uss_by_user` created above.![image](https://user-images.githubusercontent.com/314690/107161982-932fcf80-69a0-11eb-8a27-c2d9e4c9f1ce.png)The query `findUserSessionsCountsByClientId` generates the following SQL:Note that I removed the redundant client_id filtering in the where clause since we already filter by client_id in the  condition of the inner join.```sql--- PersistentUserSessionEntity.findUserSessionsCountsByClientId select persistent1_.CLIENT_ID as col_0_0_, count(persistent1_.CLIENT_ID) as col_1_0_from OFFLINE_USER_SESSION persistent0_         inner join OFFLINE_CLIENT_SESSION persistent1_                    on (persistent0_.USER_SESSION_ID = persistent1_.USER_SESSION_ID and                        persistent1_.CLIENT_ID = coalesce(cast(null as text), persistent1_.CLIENT_ID))where persistent0_.OFFLINE_FLAG='1'  and persistent0_.USER_SESSION_ID = persistent1_.USER_SESSION_ID  and persistent0_.REALM_ID='acme'group by persistent1_.CLIENT_ID```This query also benefits from the index `idx_offline_uss_by_user` created above.![image](https://user-images.githubusercontent.com/314690/107162072-105b4480-69a1-11eb-98de-1db262c9abc2.png)Btw. the query also shows the correct session count in the admin-console:For all clients:![image](https://user-images.githubusercontent.com/314690/107162659-1eab5f80-69a5-11eb-854f-b227d02cc577.png)As well as for the individual clients with offline-sessions:popular-app:```sql--- PersistentUserSessionEntity.findUserSessionsCountsByClientId for concrete clientselect persistent1_.CLIENT_ID as col_0_0_, count(persistent1_.CLIENT_ID) as col_1_0_from OFFLINE_USER_SESSION persistent0_         inner join OFFLINE_CLIENT_SESSION persistent1_                    on (persistent0_.USER_SESSION_ID = persistent1_.USER_SESSION_ID and                        persistent1_.CLIENT_ID = coalesce(cast('dce1b319-cac8-41af-bf11-123b768060c1' as text), persistent1_.CLIENT_ID))where persistent0_.OFFLINE_FLAG='1'  and persistent0_.USER_SESSION_ID = persistent1_.USER_SESSION_ID  and persistent0_.REALM_ID='acme'group by persistent1_.CLIENT_ID```![image](https://user-images.githubusercontent.com/314690/107162681-3da9f180-69a5-11eb-9972-877374d71f04.png)other-app:![image](https://user-images.githubusercontent.com/314690/107162697-4ac6e080-69a5-11eb-9051-43d6bef1b0e2.png)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7764,571862581,2021-02-08T08:39:23Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionPersisterProviderTest.java,"@@ -43,21 +43,45 @@ import java.util.ArrayList; import java.util.Collections; import java.util.List;+import java.util.Set; import java.util.concurrent.atomic.AtomicReference; import java.util.stream.Collectors; import java.util.stream.Stream;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue;+ import org.keycloak.models.Constants; import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer;+import org.keycloak.testsuite.util.ClientBuilder;+import org.keycloak.testsuite.util.RealmBuilder;  /**  * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>  */ @AuthServerContainerExclude(AuthServer.REMOTE) public class UserSessionPersisterProviderTest extends AbstractTestRealmKeycloakTest { +    @Override+    public void addTestRealms(List<RealmRepresentation> testRealms) {+        super.addTestRealms(testRealms);++        // Add another realm ""test2""+        RealmRepresentation testRealm2 = RealmBuilder.create().name(""test2"").id(""test2"")","@hmlnarik Thanks for the feedback! In this case, I rather changed this test to use realm names instead of realmId, so that test work for both JPA and mapStorage. Also I removed the method ""id"" from the RealmBuilder class, which I introduced in this PR (in the first version of this PR before you spot this).",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7750,572056322,2021-02-08T13:43:58Z,server-spi/src/main/java/org/keycloak/storage/clientscope/ClientScopeStorageProvider.java,"@@ -0,0 +1,22 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.storage.clientscope;++import org.keycloak.provider.Provider;++public interface ClientScopeStorageProvider extends Provider, ClientScopeLookupProvider {",Could you please add some tests for this interface? Something simple like this: https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/storage/GroupStorageTest.java should be enough.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7674,573134520,2021-02-09T18:33:51Z,services/src/main/java/org/keycloak/authorization/authorization/AuthorizationTokenService.java,"@@ -174,29 +174,47 @@ public static AuthorizationTokenService instance() {     }      private static void fireErrorEvent(EventBuilder event, String error, Exception cause) {-        event.detail(Details.REASON, cause == null || cause.getMessage() == null ? ""<unknown>"" : cause.getMessage())-                .error(error);+        if (cause instanceof CorsErrorResponseException) {+            // cast the exception to populate the event with a more descriptive reason+            CorsErrorResponseException originalCause = (CorsErrorResponseException) cause;+            event.detail(Details.REASON, originalCause.getErrorDescription() == null ? ""<unknown>"" : originalCause.getErrorDescription())+                    .error(error);+        } else {+            event.detail(Details.REASON, cause == null || cause.getMessage() == null ? ""<unknown>"" : cause.getMessage())+                    .error(error);+        }+         logger.debug(event.getEvent().getType(), cause);     }-    -    public Response authorize(KeycloakAuthorizationRequest request) {++    public Response authorize(KeycloakAuthorizationRequest request, EventBuilder event) {         if (request == null) {-            throw new CorsErrorResponseException(request.getCors(), OAuthErrorException.INVALID_GRANT, ""Invalid authorization request."", Status.BAD_REQUEST);+            CorsErrorResponseException invalidAuthorizationRequestException = new CorsErrorResponseException(null, OAuthErrorException.INVALID_GRANT, ""Invalid authorization request."", Status.BAD_REQUEST);",Should create the exception using `reqest.getCors()`.We don't need `Errors.INVALID_AUTHORIZATION_REQUEST`. But just use `Errors.INVALID_REQUEST`.,
32644,jmrodriguez,https://api.github.com/repos/keycloak/keycloak/pulls/7674,573190659,2021-02-09T19:50:58Z,services/src/main/java/org/keycloak/authorization/authorization/AuthorizationTokenService.java,"@@ -174,29 +174,47 @@ public static AuthorizationTokenService instance() {     }      private static void fireErrorEvent(EventBuilder event, String error, Exception cause) {-        event.detail(Details.REASON, cause == null || cause.getMessage() == null ? ""<unknown>"" : cause.getMessage())-                .error(error);+        if (cause instanceof CorsErrorResponseException) {+            // cast the exception to populate the event with a more descriptive reason+            CorsErrorResponseException originalCause = (CorsErrorResponseException) cause;+            event.detail(Details.REASON, originalCause.getErrorDescription() == null ? ""<unknown>"" : originalCause.getErrorDescription())+                    .error(error);+        } else {+            event.detail(Details.REASON, cause == null || cause.getMessage() == null ? ""<unknown>"" : cause.getMessage())+                    .error(error);+        }+         logger.debug(event.getEvent().getType(), cause);     }-    -    public Response authorize(KeycloakAuthorizationRequest request) {++    public Response authorize(KeycloakAuthorizationRequest request, EventBuilder event) {         if (request == null) {-            throw new CorsErrorResponseException(request.getCors(), OAuthErrorException.INVALID_GRANT, ""Invalid authorization request."", Status.BAD_REQUEST);+            CorsErrorResponseException invalidAuthorizationRequestException = new CorsErrorResponseException(null, OAuthErrorException.INVALID_GRANT, ""Invalid authorization request."", Status.BAD_REQUEST);",using request.getCors() to create the exception would lead to a NullPointerException because this code section is executed only if request == null (line 191)Agreed on using Errors.INVALID_REQUEST,
32644,jmrodriguez,https://api.github.com/repos/keycloak/keycloak/pulls/7674,573190746,2021-02-09T19:51:07Z,services/src/main/java/org/keycloak/authorization/authorization/AuthorizationTokenService.java,"@@ -223,17 +241,23 @@ public Response authorize(KeycloakAuthorizationRequest request) {                     } else if (RESPONSE_MODE_PERMISSIONS.equals(metadata.getResponseMode())) {                         return createSuccessfulResponse(permissions, request);                     } else {-                        throw new CorsErrorResponseException(request.getCors(), OAuthErrorException.INVALID_REQUEST, ""Invalid response_mode"", Status.BAD_REQUEST);+                        CorsErrorResponseException invalidResponseModeException = new CorsErrorResponseException(request.getCors(), OAuthErrorException.INVALID_REQUEST, ""Invalid response_mode"", Status.BAD_REQUEST);+                        fireErrorEvent(event, Errors.INVALID_RESPONSE_MODE, invalidResponseModeException);","the intention was to cover all the code exceptions thrown, to generate the respective audit event error",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7723,574671301,2021-02-11T17:03:53Z,services/src/main/java/org/keycloak/services/clientpolicy/context/AbstractDynamicClientCRUDContext.java,"@@ -0,0 +1,58 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.context;++import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.representations.JsonWebToken;++abstract class AbstractDynamicClientCRUDContext implements ClientCRUDContext {++    private final JsonWebToken token;+    private ClientModel authenticatedClient;+    private UserModel authenticatedUser;++    public AbstractDynamicClientCRUDContext(KeycloakSession session, JsonWebToken token, RealmModel realm) {+        this.token = token;+        if (token != null) {","Can be refactored to ```if (token == null) {   return;}if (token.getIssuedFor() != null) {    this.authenticatedClient = realm.getClientByClientId(token.getIssuedFor());}if (token.getSubject() != null) {    this.authenticatedUser = session.users().getUserById(token.getSubject(), realm);}```to reduce cyclomatic complexity",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7723,574718404,2021-02-11T18:09:29Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/services/clientpolicy/executor/TestRaiseExeptionExecutorFactory.java,"@@ -0,0 +1,72 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.services.clientpolicy.executor;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.List;++import org.keycloak.Config.Scope;+import org.keycloak.component.ComponentModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;++public class TestRaiseExeptionExecutorFactory implements ClientPolicyExecutorProviderFactory {++    public static final String PROVIDER_ID = ""test-raise-exception-executor"";++    public static final String TARGET_CP_EVENTS = ""target-cp-events"";+    private static final ProviderConfigProperty TARGET_CP_EVENTS_PROPERTY = new ProviderConfigProperty(+            TARGET_CP_EVENTS, null, null, ProviderConfigProperty.MULTIVALUED_STRING_TYPE, null);++    @Override+    public ClientPolicyExecutorProvider create(KeycloakSession session, ComponentModel model) {+        return new TestRaiseExeptionExecutor(session, model);+    }++    @Override+    public void init(Scope config) {+    }++    @Override+    public void postInit(KeycloakSessionFactory factory) {+    }++    @Override+    public void close() {+    }++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    @Override+    public String getHelpText() {+        return null;+    }++    @Override+    public List<ProviderConfigProperty> getConfigProperties() {+        return new ArrayList<>(Arrays.asList(TARGET_CP_EVENTS_PROPERTY));","Do we really need to return the mutable list here? Can't we do just`return Arrays.asList(TARGET_CP_EVENTS_PROPERTY);`The returned list is not related to TARGET_CP_EVENTS_PROPERTY, so changes to return values will not propagate here. Also, typically configurationPropertes are semantically immutable. ",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7723,574724365,2021-02-11T18:18:19Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/AbstractClientPoliciesTest.java,"@@ -445,21 +454,53 @@ protected String createClientByAdmin(String clientId, Consumer<ClientRepresentat         return cId;     } -    protected ClientRepresentation getClientByAdmin(String cId) {+    protected ClientRepresentation getClientByAdmin(String cId) throws ClientPolicyException {         ClientResource clientResource = adminClient.realm(REALM_NAME).clients().get(cId);-        return clientResource.toRepresentation();+        try {+            return clientResource.toRepresentation();+        } catch (BadRequestException bre) {+            processClientPolicyExceptionByAdmin(bre);+        }+        return null;+    }++    protected ClientRepresentation getClientByAdminWithName(String clientName) {+        return adminClient.realm(REALM_NAME).clients().findByClientId(clientName).get(0);     } -    protected void updateClientByAdmin(String cId, Consumer<ClientRepresentation> op) {+    protected void updateClientByAdmin(String cId, Consumer<ClientRepresentation> op) throws ClientPolicyException {         ClientResource clientResource = adminClient.realm(REALM_NAME).clients().get(cId);         ClientRepresentation clientRep = clientResource.toRepresentation();         op.accept(clientRep);-        clientResource.update(clientRep);+        try {+            clientResource.update(clientRep);+        } catch (BadRequestException bre) {+            processClientPolicyExceptionByAdmin(bre);+        }     } -    protected void deleteClientByAdmin(String cId) {+    protected void deleteClientByAdmin(String cId) throws ClientPolicyException {         ClientResource clientResource = adminClient.realm(REALM_NAME).clients().get(cId);-        clientResource.remove();+        try {+            clientResource.remove();+        } catch (BadRequestException bre) {+            processClientPolicyExceptionByAdmin(bre);+        }+    }++    private void processClientPolicyExceptionByAdmin(BadRequestException bre) throws ClientPolicyException {+        Response resp = bre.getResponse();+        if (resp.getStatus() == Response.Status.BAD_REQUEST.getStatusCode()) {","Can be simplified to ```Response resp = bre.getResponse();if (resp.getStatus() != Response.Status.BAD_REQUEST.getStatusCode()) {  resp.close();  return;}String respBody = resp.readEntity(String.class);Map<String, String> responseJson = null;try {    responseJson = JsonSerialization.readValue(respBody, Map.class);} catch (IOException e) {    fail();}throw new ClientPolicyException(responseJson.get(OAuth2Constants.ERROR), responseJson.get(OAuth2Constants.ERROR_DESCRIPTION));```",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7723,574727147,2021-02-11T18:22:27Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -1279,6 +1281,80 @@ public void testHolderOfKeyEnforceExecutor() throws Exception {         }     } ++    @Test+    public void testExtendedClientPolicyIntefacesForClientRegistrationPolicyMigration() throws ClientRegistrationException, ClientPolicyException {+        String policyName = ""MyPolicy"";+        String clientName = ""ByAdmin-App"" + KeycloakModelUtils.generateId().substring(0, 7);+        String executorName = ""TestRaiseExeptionExecutor"";++        createPolicy(policyName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);+        logger.info(""... Created Policy : "" + policyName);++        createCondition(""AnyClientConditionFactory"", AnyClientConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+        });+        registerCondition(""AnyClientConditionFactory"", policyName);+        logger.info(""... Registered Condition : AnyClientConditionFactory"");++        createExecutor(executorName, TestRaiseExeptionExecutorFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.REGISTERED.toString())));",Do we need to convert to mutable list here?`new ArrayList<>(Arrays.asList(ClientPolicyEvent.REGISTERED.toString()))`could be simply`Arrays.asList(ClientPolicyEvent.REGISTERED.toString())`,
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7723,574727276,2021-02-11T18:22:40Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -1279,6 +1281,80 @@ public void testHolderOfKeyEnforceExecutor() throws Exception {         }     } ++    @Test+    public void testExtendedClientPolicyIntefacesForClientRegistrationPolicyMigration() throws ClientRegistrationException, ClientPolicyException {+        String policyName = ""MyPolicy"";+        String clientName = ""ByAdmin-App"" + KeycloakModelUtils.generateId().substring(0, 7);+        String executorName = ""TestRaiseExeptionExecutor"";++        createPolicy(policyName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);+        logger.info(""... Created Policy : "" + policyName);++        createCondition(""AnyClientConditionFactory"", AnyClientConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+        });+        registerCondition(""AnyClientConditionFactory"", policyName);+        logger.info(""... Registered Condition : AnyClientConditionFactory"");++        createExecutor(executorName, TestRaiseExeptionExecutorFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.REGISTERED.toString())));+        });+        registerExecutor(executorName, policyName);+        logger.info(""... Registered Executor : "" + executorName);++        String clientId = null;+        try {+            try {+                createClientByAdmin(clientName, (ClientRepresentation clientRep) -> {+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.REGISTERED.toString(), cpe.getError());+            }++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.UPDATED.toString())));",Do we need to convert to mutable list here?`new ArrayList<>(Arrays.asList(ClientPolicyEvent.UPDATED.toString()))`could be simply`Arrays.asList(ClientPolicyEvent.UPDATED.toString())`,
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7723,574727572,2021-02-11T18:23:08Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -1279,6 +1281,80 @@ public void testHolderOfKeyEnforceExecutor() throws Exception {         }     } ++    @Test+    public void testExtendedClientPolicyIntefacesForClientRegistrationPolicyMigration() throws ClientRegistrationException, ClientPolicyException {+        String policyName = ""MyPolicy"";+        String clientName = ""ByAdmin-App"" + KeycloakModelUtils.generateId().substring(0, 7);+        String executorName = ""TestRaiseExeptionExecutor"";++        createPolicy(policyName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);+        logger.info(""... Created Policy : "" + policyName);++        createCondition(""AnyClientConditionFactory"", AnyClientConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+        });+        registerCondition(""AnyClientConditionFactory"", policyName);+        logger.info(""... Registered Condition : AnyClientConditionFactory"");++        createExecutor(executorName, TestRaiseExeptionExecutorFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.REGISTERED.toString())));+        });+        registerExecutor(executorName, policyName);+        logger.info(""... Registered Executor : "" + executorName);++        String clientId = null;+        try {+            try {+                createClientByAdmin(clientName, (ClientRepresentation clientRep) -> {+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.REGISTERED.toString(), cpe.getError());+            }++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.UPDATED.toString())));+            });++            clientId = getClientByAdminWithName(clientName).getId();+            assertEquals(true, getClientByAdmin(clientId).isEnabled());+            try {+                updateClientByAdmin(clientId, (ClientRepresentation clientRep) -> {+                    clientRep.setEnabled(false);+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.UPDATED.toString(), cpe.getError());+            }+            assertEquals(false, getClientByAdmin(clientId).isEnabled());++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.VIEW.toString())));",Do we need to convert to mutable list here?`new ArrayList<>(Arrays.asList(ClientPolicyEvent.VIEW.toString()))`could be simply`Arrays.asList(ClientPolicyEvent.VIEW.toString())`,
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7723,574727921,2021-02-11T18:23:39Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -1279,6 +1281,80 @@ public void testHolderOfKeyEnforceExecutor() throws Exception {         }     } ++    @Test+    public void testExtendedClientPolicyIntefacesForClientRegistrationPolicyMigration() throws ClientRegistrationException, ClientPolicyException {+        String policyName = ""MyPolicy"";+        String clientName = ""ByAdmin-App"" + KeycloakModelUtils.generateId().substring(0, 7);+        String executorName = ""TestRaiseExeptionExecutor"";++        createPolicy(policyName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);+        logger.info(""... Created Policy : "" + policyName);++        createCondition(""AnyClientConditionFactory"", AnyClientConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+        });+        registerCondition(""AnyClientConditionFactory"", policyName);+        logger.info(""... Registered Condition : AnyClientConditionFactory"");++        createExecutor(executorName, TestRaiseExeptionExecutorFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.REGISTERED.toString())));+        });+        registerExecutor(executorName, policyName);+        logger.info(""... Registered Executor : "" + executorName);++        String clientId = null;+        try {+            try {+                createClientByAdmin(clientName, (ClientRepresentation clientRep) -> {+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.REGISTERED.toString(), cpe.getError());+            }++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.UPDATED.toString())));+            });++            clientId = getClientByAdminWithName(clientName).getId();+            assertEquals(true, getClientByAdmin(clientId).isEnabled());+            try {+                updateClientByAdmin(clientId, (ClientRepresentation clientRep) -> {+                    clientRep.setEnabled(false);+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.UPDATED.toString(), cpe.getError());+            }+            assertEquals(false, getClientByAdmin(clientId).isEnabled());++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.VIEW.toString())));+            });+            try {+                getClientByAdmin(clientId);+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.VIEW.toString(), cpe.getError());+            }++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.UNREGISTER.toString())));",Do we need to convert to mutable list here?`new ArrayList<>(Arrays.asList(ClientPolicyEvent.UNREGISTER.toString()))`could be simply`Arrays.asList(ClientPolicyEvent.UNREGISTER.toString())`,
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7723,574728262,2021-02-11T18:24:15Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -1279,6 +1281,80 @@ public void testHolderOfKeyEnforceExecutor() throws Exception {         }     } ++    @Test+    public void testExtendedClientPolicyIntefacesForClientRegistrationPolicyMigration() throws ClientRegistrationException, ClientPolicyException {+        String policyName = ""MyPolicy"";+        String clientName = ""ByAdmin-App"" + KeycloakModelUtils.generateId().substring(0, 7);+        String executorName = ""TestRaiseExeptionExecutor"";++        createPolicy(policyName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);+        logger.info(""... Created Policy : "" + policyName);++        createCondition(""AnyClientConditionFactory"", AnyClientConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+        });+        registerCondition(""AnyClientConditionFactory"", policyName);+        logger.info(""... Registered Condition : AnyClientConditionFactory"");++        createExecutor(executorName, TestRaiseExeptionExecutorFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.REGISTERED.toString())));+        });+        registerExecutor(executorName, policyName);+        logger.info(""... Registered Executor : "" + executorName);++        String clientId = null;+        try {+            try {+                createClientByAdmin(clientName, (ClientRepresentation clientRep) -> {+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.REGISTERED.toString(), cpe.getError());+            }++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.UPDATED.toString())));+            });++            clientId = getClientByAdminWithName(clientName).getId();+            assertEquals(true, getClientByAdmin(clientId).isEnabled());+            try {+                updateClientByAdmin(clientId, (ClientRepresentation clientRep) -> {+                    clientRep.setEnabled(false);+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.UPDATED.toString(), cpe.getError());+            }+            assertEquals(false, getClientByAdmin(clientId).isEnabled());++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.VIEW.toString())));+            });+            try {+                getClientByAdmin(clientId);+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.VIEW.toString(), cpe.getError());+            }++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.UNREGISTER.toString())));+            });+            try {+                deleteClientByAdmin(clientId);+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.UNREGISTER.toString(), cpe.getError());+            }+        } finally {+            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>());",new ArrayList<>()); could be replaced with immutable Collections.singletonList();,
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7679,575691813,2021-02-13T17:31:17Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -285,6 +286,28 @@ public static void importRealm(KeycloakSession session, RealmRepresentation rep,         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);         newRealm.setWebAuthnPolicyPasswordless(webAuthnPolicy); +        CIBAPolicy cibaPolicy = new CIBAPolicy();","The lines```CIBAPolicy cibaPolicy = new CIBAPolicy();        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);        Integer cibaExpiresIn = rep.getCibaExpiresIn();        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);        Integer cibaInterval = rep.getCibaInterval();        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())            cibaAuthRequestedUserHint = Constants.DEFAULT_CIBA_POLICY_AUTH_REQUESTED_USER_HINT;        cibaPolicy.setAuthRequestedUserHint(cibaAuthRequestedUserHint);        newRealm.setCIBAPolicy(cibaPolicy);```seem to be duplicated athttps://github.com/keycloak/keycloak/pull/7679/files#diff-bf084091e13d0b998262192910037c7cd2e5640fcd846da15299f1bdef7230c9R1176Can't we extract the following static private method:```    private static void applyCibaPolicyToRealm(RealmRepresentation rep, RealmModel realm) {        CIBAPolicy cibaPolicy = new CIBAPolicy();        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);        Integer cibaExpiresIn = rep.getCibaExpiresIn();        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);        Integer cibaInterval = rep.getCibaInterval();        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())            cibaAuthRequestedUserHint = Constants.DEFAULT_CIBA_POLICY_AUTH_REQUESTED_USER_HINT;        cibaPolicy.setAuthRequestedUserHint(cibaAuthRequestedUserHint);        realm.setCIBAPolicy(cibaPolicy);    }```and use it in both places?",
18463491,valb3r,https://api.github.com/repos/keycloak/keycloak/pulls/7679,575694614,2021-02-13T17:56:57Z,services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java,"@@ -0,0 +1,262 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.ciba.decoupledauthn;++import java.util.Map;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.jboss.resteasy.spi.HttpResponse;+import org.keycloak.OAuthErrorException;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.common.ClientConnection;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.AuthenticationFlowModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserConsentModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.utils.AuthenticationFlowResolver;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.resources.Cors;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.sessions.RootAuthenticationSessionModel;++public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {++    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);++    protected KeycloakSession session;+    protected EventBuilder event;++    protected MultivaluedMap<String, String> formParams;++    protected RealmModel realm;++    protected ClientModel client;+    protected Map<String, String> clientAuthAttributes;++    @Context+    protected HttpHeaders headers;+    @Context+    protected HttpRequest httpRequest;+    @Context+    protected HttpResponse httpResponse;+    @Context+    protected ClientConnection clientConnection;++    protected Cors cors;++    public DecoupledAuthenticationProviderBase(KeycloakSession session) {+        this.session = session;+        realm = session.getContext().getRealm();+    }++    @Override+    public void setEvent(EventBuilder event) {+        this.event = event;+    }++    @Override+    public void close() {+    }++    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processDecoupledAuthnResult() {+        event.event(EventType.LOGIN);+        headers = session.getContext().getContextObject(HttpHeaders.class);+        httpRequest = session.getContext().getContextObject(HttpRequest.class);+        httpResponse = session.getContext().getContextObject(HttpResponse.class);+        clientConnection = session.getContext().getContextObject(ClientConnection.class);++        cors = Cors.add(httpRequest).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);+        formParams = httpRequest.getDecodedFormParameters();++        checkSsl();+        checkRealm();+        // here Client Model of Decoupled Authentication Server is set to this class member ""client"".+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().+        checkClient();+        logger.info("" client_id = "" + client.getClientId());++        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();+        outputHeaders.putSingle(""Cache-Control"", ""no-store"");+        outputHeaders.putSingle(""Pragma"", ""no-cache"");++        Response response = verifyDecoupledAuthnResult();+        if (response != null) return response;++        setupSessions();++        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);++        return cors.builder(Response.ok("""", MediaType.APPLICATION_JSON_TYPE)).build();+    }++    private void setupSessions() {+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);++        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());+        logger.info("" specified scopes in backchannel authentication endpoint = "" + getScope());++        // authentication+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);+        String flowId = flow.getId();+        AuthenticationProcessor processor = new AuthenticationProcessor();+        processor.setAuthenticationSession(authSession)+                .setFlowId(flowId)+                .setConnection(clientConnection)+                .setEventBuilder(event)+                .setRealm(realm)+                .setSession(session)+                .setUriInfo(session.getContext().getUri())+                .setRequest(httpRequest);++        processor.authenticateOnly();+        processor.evaluateRequiredActionTriggers();+        UserModel user = authSession.getAuthenticatedUser();+        if (user.getRequiredActionsStream().count() > 0) {+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""Account is not fully set up"", Response.Status.BAD_REQUEST);+        }++        AuthenticationManager.setClientScopesInSession(authSession);++        processor.attachSession();+        UserSessionModel userSession = processor.getUserSession();+        if (userSession == null) {+            logger.info("" userSession is null."");",What is the purpose of this log statement? if `userSession` is null doesn't it makes sense to throw an exception immediately? as updateUserSessionFromClientAuth` will throw NPE if `userSession` is null,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7723,576476242,2021-02-16T00:02:14Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -1279,6 +1281,80 @@ public void testHolderOfKeyEnforceExecutor() throws Exception {         }     } ++    @Test+    public void testExtendedClientPolicyIntefacesForClientRegistrationPolicyMigration() throws ClientRegistrationException, ClientPolicyException {+        String policyName = ""MyPolicy"";+        String clientName = ""ByAdmin-App"" + KeycloakModelUtils.generateId().substring(0, 7);+        String executorName = ""TestRaiseExeptionExecutor"";++        createPolicy(policyName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);+        logger.info(""... Created Policy : "" + policyName);++        createCondition(""AnyClientConditionFactory"", AnyClientConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+        });+        registerCondition(""AnyClientConditionFactory"", policyName);+        logger.info(""... Registered Condition : AnyClientConditionFactory"");++        createExecutor(executorName, TestRaiseExeptionExecutorFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {+            provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.REGISTERED.toString())));+        });+        registerExecutor(executorName, policyName);+        logger.info(""... Registered Executor : "" + executorName);++        String clientId = null;+        try {+            try {+                createClientByAdmin(clientName, (ClientRepresentation clientRep) -> {+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.REGISTERED.toString(), cpe.getError());+            }++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.UPDATED.toString())));+            });++            clientId = getClientByAdminWithName(clientName).getId();+            assertEquals(true, getClientByAdmin(clientId).isEnabled());+            try {+                updateClientByAdmin(clientId, (ClientRepresentation clientRep) -> {+                    clientRep.setEnabled(false);+                });+                fail();+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.UPDATED.toString(), cpe.getError());+            }+            assertEquals(false, getClientByAdmin(clientId).isEnabled());++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.VIEW.toString())));+            });+            try {+                getClientByAdmin(clientId);+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.VIEW.toString(), cpe.getError());+            }++            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>(Arrays.asList(ClientPolicyEvent.UNREGISTER.toString())));+            });+            try {+                deleteClientByAdmin(clientId);+            } catch (ClientPolicyException cpe) {+                assertEquals(ClientPolicyEvent.UNREGISTER.toString(), cpe.getError());+            }+        } finally {+            updateExecutor(executorName, (ComponentRepresentation provider) -> {+                provider.getConfig().put(TestRaiseExeptionExecutorFactory.TARGET_CP_EVENTS, new ArrayList<>());",@valb3r Thank you. `Collections.singletonList((String)null)` might be ok.,
52280032,StefAtMentech,https://api.github.com/repos/keycloak/keycloak/pulls/7737,576617268,2021-02-16T08:04:03Z,services/src/main/java/org/keycloak/authorization/protection/permission/PermissionTicketService.java,"@@ -226,6 +226,52 @@ public Response find(@QueryParam(""scopeId"") String scopeId,                 .build();     } +    @Path(""/count"")+    @GET+    @Produces(""application/json"")+    public Response getResourceCount(@QueryParam(""scopeId"") String scopeId,+                                       @QueryParam(""resourceId"") String resourceId,+                                       @QueryParam(""owner"") String owner,+                                       @QueryParam(""requester"") String requester,+                                       @QueryParam(""granted"") Boolean granted,+                                       @QueryParam(""returnNames"") Boolean returnNames) {+        StoreFactory storeFactory = authorization.getStoreFactory();+        PermissionTicketStore permissionTicketStore = storeFactory.getPermissionTicketStore();+        Map<String, String> filters = new HashMap<>();++        if (resourceId != null) {+            filters.put(PermissionTicket.RESOURCE, resourceId);+        }++        if (scopeId != null) {+            ScopeStore scopeStore = storeFactory.getScopeStore();+            Scope scope = scopeStore.findById(scopeId, resourceServer.getId());++            if (scope == null) {+                scope = scopeStore.findByName(scopeId, resourceServer.getId());+            }++            filters.put(PermissionTicket.SCOPE, scope != null ? scope.getId() : scopeId);+        }++        if (owner != null) {+            filters.put(PermissionTicket.OWNER, getUserId(owner));+        }++        if (requester != null) {+            filters.put(PermissionTicket.REQUESTER, getUserId(requester));+        }++        if (granted != null) {+            filters.put(PermissionTicket.GRANTED, granted.toString());+        }+        long count = permissionTicketStore.count(filters, resourceServer.getId());++        Map<String, Long> map = new HashMap<>();",I was inspired by [the group count endpoint](https://github.com/keycloak/keycloak/blob/master/integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UserResource.java). Will change it to `Integer`.,
31417989,harture,https://api.github.com/repos/keycloak/keycloak/pulls/7756,577507523,2021-02-17T10:45:07Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -620,28 +785,37 @@ protected Response newBrowserAuthentication(AuthenticationSessionModel authSessi         return handleBrowserAuthenticationRequest(authSession, samlProtocol, isPassive, redirectToAuthentication);     } +    public RedirectBindingProtocol newRedirectBindingProtocol() {+        return new RedirectBindingProtocol();+    }++    public PostBindingProtocol newPostBindingProtocol() {+        return new PostBindingProtocol();+    }+     /**      */     @GET-    public Response redirectBinding(@QueryParam(GeneralConstants.SAML_REQUEST_KEY) String samlRequest, @QueryParam(GeneralConstants.SAML_RESPONSE_KEY) String samlResponse, @QueryParam(GeneralConstants.RELAY_STATE) String relayState) {+    public void redirectBinding(@Suspended AsyncResponse asyncResponse, @QueryParam(GeneralConstants.SAML_REQUEST_KEY) String samlRequest, @QueryParam(GeneralConstants.SAML_RESPONSE_KEY) String samlResponse, @QueryParam(GeneralConstants.RELAY_STATE) String relayState, @QueryParam(GeneralConstants.SAML_ARTIFACT_KEY) String artifact) {         logger.debug(""SAML GET"");         CacheControlUtil.noBackButtonCacheControlHeader();-        return new RedirectBindingProtocol().execute(samlRequest, samlResponse, relayState);++        new RedirectBindingProtocol().execute(asyncResponse, samlRequest, samlResponse, relayState, artifact);     }      /**      */     @POST     @NoCache     @Consumes(MediaType.APPLICATION_FORM_URLENCODED)-    public Response postBinding(@FormParam(GeneralConstants.SAML_REQUEST_KEY) String samlRequest, @FormParam(GeneralConstants.SAML_RESPONSE_KEY) String samlResponse, @FormParam(GeneralConstants.RELAY_STATE) String relayState) {+    public void postBinding(@Suspended AsyncResponse asyncResponse, @FormParam(GeneralConstants.SAML_REQUEST_KEY) String samlRequest, @FormParam(GeneralConstants.SAML_RESPONSE_KEY) String samlResponse, @FormParam(GeneralConstants.RELAY_STATE) String relayState, @FormParam(GeneralConstants.SAML_ARTIFACT_KEY) String artifact) {         logger.debug(""SAML POST"");         PostBindingProtocol postBindingProtocol = new PostBindingProtocol();         // this is to support back button on browser         // if true, we redirect to authenticate URL otherwise back button behavior has bad side effects         // and we want to turn it off.         postBindingProtocol.redirectToAuthentication = true;-        return postBindingProtocol.execute(samlRequest, samlResponse, relayState);+        postBindingProtocol.execute(asyncResponse, samlRequest, samlResponse, relayState, artifact);     }      @GET","Artifact related items are missing in the IDP Metadata description:```<SingleSignOnService Binding=""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Artifact"" Location=""XXXXX"" /><SingleLogoutService Binding=""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Artifact"" Location=""XXXXX"" /><ArtifactResolutionService Binding=""urn:oasis:names:tc:SAML:2.0:bindings:SOAP"" Location=""XXXXX""/>```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,577548204,2021-02-17T11:50:28Z,core/src/main/java/org/keycloak/representations/idm/RealmRepresentation.java,"@@ -180,6 +183,7 @@     protected String resetCredentialsFlow;     protected String clientAuthenticationFlow;     protected String dockerAuthenticationFlow;+    protected String cibaFlow;",I would also move this to the CIBA representation. All CIBA related data from a single place. Same for the model.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,577561189,2021-02-17T12:12:47Z,server-spi/src/main/java/org/keycloak/models/CIBAPolicy.java,"@@ -0,0 +1,63 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models;++import java.io.Serializable;++import org.jboss.logging.Logger;++public class CIBAPolicy implements Serializable {++    protected static final Logger logger = Logger.getLogger(CIBAPolicy.class);++    protected String backchannelTokenDeliveryMode = ""poll"";",Do you expect sub-types or types within the same package to extend this class? Could them be `private` instead?,
32644,jmrodriguez,https://api.github.com/repos/keycloak/keycloak/pulls/7674,577899961,2021-02-17T19:52:01Z,services/src/main/java/org/keycloak/authorization/authorization/AuthorizationTokenService.java,"@@ -174,29 +174,47 @@ public static AuthorizationTokenService instance() {     }      private static void fireErrorEvent(EventBuilder event, String error, Exception cause) {-        event.detail(Details.REASON, cause == null || cause.getMessage() == null ? ""<unknown>"" : cause.getMessage())-                .error(error);+        if (cause instanceof CorsErrorResponseException) {+            // cast the exception to populate the event with a more descriptive reason+            CorsErrorResponseException originalCause = (CorsErrorResponseException) cause;+            event.detail(Details.REASON, originalCause.getErrorDescription() == null ? ""<unknown>"" : originalCause.getErrorDescription())+                    .error(error);+        } else {+            event.detail(Details.REASON, cause == null || cause.getMessage() == null ? ""<unknown>"" : cause.getMessage())+                    .error(error);+        }+         logger.debug(event.getEvent().getType(), cause);     }-    -    public Response authorize(KeycloakAuthorizationRequest request) {++    public Response authorize(KeycloakAuthorizationRequest request, EventBuilder event) {","@pedroigor I cannot remove the EventBuilder event parameter as because fireErrorEvent function requires it as parameter, and we use that function multiple times in the authorize method.Could you please clarify how this should be resolved?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7791,577939806,2021-02-17T21:00:41Z,themes/src/main/resources-community/theme/base/account/messages/messages_pt_BR.properties,"@@ -4,15 +4,35 @@ doLogOutAllSessions=Sair de todas as sess\u00F5es doRemove=Remover doAdd=Adicionar doSignOut=Sair+doLogIn=Entrar+doLink=Vincular+noAccessMessage=Acesso n\u00e3o permitido",Does it belong here? Or it is a property for login messages?,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,578025220,2021-02-17T23:50:03Z,server-spi/src/main/java/org/keycloak/utils/StringUtil.java,"@@ -0,0 +1,29 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.utils;++public class StringUtil {++    public static boolean isBlank(String str) {+        return !(isNotBlank(str));+    }++    public static boolean  isNotBlank(String str) {+        return str != null && !str.isEmpty();","@pedroigor Yes, I will fix codes as https://github.com/keycloak/keycloak/blob/master/saml-core/src/main/java/org/keycloak/saml/common/util/StringUtil.java .",
3129194,EpicEric,https://api.github.com/repos/keycloak/keycloak/pulls/7791,578505347,2021-02-18T15:20:20Z,themes/src/main/resources-community/theme/base/login/messages/messages_pt_BR.properties,"@@ -151,53 +162,55 @@ role_manage-identity-providers=Gerenciar provedores de identidade role_manage-clients=Gerenciar clientes role_manage-events=Gerenciar eventos role_view-profile=Visualizar perfil-role_manage-account=Gerenciar contas-role_manage-account-links=Gerenciar v\00ED nculos de conta+role_manage-account=Gerenciar conta+role_manage-account-links=Gerenciar vincula\u00e7\u00f5es de conta role_read-token=Ler token role_offline-access=Acesso offline client_account=Conta client_account-console=Console da Conta client_security-admin-console=Console de Administra\u00E7\u00E3o de Seguran\u00E7a-client_admin-cli=Admin CLI+client_admin-cli=CLI de Administra\u00e7\u00e3o client_realm-management=Gerenciamento de Dom\u00EDnio client_broker=Provedor de Identidade  requiredFields=Campos obrigat\u00F3rios  invalidUserMessage=Nome de usu\u00E1rio ou senha inv\u00E1lida. invalidUsernameMessage=Nome de usu\u00E1rio inv\u00E1lido.-invalidUsernameOrEmailMessage=Nome de usu\u00E1rio ou e-mail inv\u00E1lido.+invalidUsernameOrEmailMessage=Nome de usu\u00E1rio ou endere\u00e7o de e-mail inv\u00E1lido. invalidPasswordMessage=Senha inv\u00E1lida.-invalidEmailMessage=E-mail inv\u00E1lido.-accountDisabledMessage=Conta desativada, contate o administrador.-accountTemporarilyDisabledMessage=Conta temporariamente indispon\u00EDvel, contate o administrador ou tente novamente mais tarde.+invalidEmailMessage=Endere\u00e7o de e-mail inv\u00E1lido.+accountDisabledMessage=Conta desativada, por favor, contate um administrador.+accountTemporarilyDisabledMessage=Conta temporariamente indispon\u00EDvel, por favor, contate um administrador ou tente novamente mais tarde. expiredCodeMessage=Tempo de login expirado. Por favor, fa\u00E7a login novamente. expiredActionMessage=A\u00E7\u00E3o expirada. Por favor, continue com o login agora. expiredActionTokenNoSessionMessage=A\u00E7\u00E3o expirada. expiredActionTokenSessionExistsMessage=A\u00E7\u00E3o expirada. Por favor, comece novamente.  missingFirstNameMessage=Por favor, informe o primeiro nome. missingLastNameMessage=Por favor, informe o sobrenome.-missingEmailMessage=Por favor, informe o e-mail.+missingEmailMessage=Por favor, informe o endere\u00e7o de e-mail. missingUsernameMessage=Por favor, informe o nome de usu\u00E1rio. missingPasswordMessage=Por favor, informe a senha.-missingTotpMessage=Por favor, informe o c\u00F3digo autenticador.+missingTotpMessage=Por favor, informe o c\u00F3digo de uso \u00fanico. missingTotpDeviceNameMessage=Por favor, informe o nome do dispositivo. notMatchPasswordMessage=As senhas n\u00E3o coincidem.  invalidPasswordExistingMessage=Senha atual inv\u00E1lida.-invalidPasswordBlacklistedMessage=Senha inv\u00E1lida de acordo com as pol\u00EDticas estabelecidas para o dom\u00EDnio.","It can lead to an ambiguous error message if we're trying to be consistent with the `account` strings for blacklisted and generic errors:```properties# account/messages_en.propertiesinvalidPasswordBlacklistedMessage=Invalid password: password is blacklisted.invalidPasswordGenericMessage=Invalid password: new password doesn''t match password policies.# account/messages_pt_BR.properties, un-escaped#   - Current translation:# invalidPasswordBlacklistedMessage=Senha invlida: esta senha est na lista de excluso.#   - Changing the translation to correspond with the login message:invalidPasswordBlacklistedMessage=Senha invlida: a nova senha no est de acordo com as polticas estabelecidas para o domnio.invalidPasswordGenericMessage=Senha invlida: a nova senha no cumpre as polticas de senha.```An alternative to ""lista de excluso"" could be ""lista negra"", or ""lista de restries""[[1]](https://pt.wikipedia.org/wiki/Lista_negra) to avoid potentially problematic language.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,578836507,2021-02-19T00:14:13Z,services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java,"@@ -0,0 +1,263 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.ciba.decoupledauthn;++import java.util.Map;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.jboss.resteasy.spi.HttpResponse;+import org.keycloak.OAuthErrorException;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.common.ClientConnection;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.AuthenticationFlowModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserConsentModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.utils.AuthenticationFlowResolver;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.resources.Cors;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.sessions.RootAuthenticationSessionModel;++public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {++    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);++    protected KeycloakSession session;+    protected EventBuilder event;++    protected MultivaluedMap<String, String> formParams;++    protected RealmModel realm;++    protected ClientModel client;+    protected Map<String, String> clientAuthAttributes;++    @Context+    protected HttpHeaders headers;+    @Context+    protected HttpRequest httpRequest;+    @Context+    protected HttpResponse httpResponse;+    @Context+    protected ClientConnection clientConnection;++    protected Cors cors;++    public DecoupledAuthenticationProviderBase(KeycloakSession session) {+        this.session = session;+        realm = session.getContext().getRealm();+    }++    @Override+    public void setEvent(EventBuilder event) {+        this.event = event;+    }++    @Override+    public void close() {+    }++    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processDecoupledAuthnResult() {+        event.event(EventType.LOGIN);+        headers = session.getContext().getContextObject(HttpHeaders.class);+        httpRequest = session.getContext().getContextObject(HttpRequest.class);",@pedroigor I've missed that this `@Context` does not work so that these should be removed.This class uses the endpoint extension and it does not inject context.https://github.com/keycloak/keycloak/blob/750f5fdb0a8e9a87ec14f256d42f81ece74748d4/services/src/main/java/org/keycloak/protocol/oidc/OIDCLoginProtocolService.java#L302-L310,
32644,jmrodriguez,https://api.github.com/repos/keycloak/keycloak/pulls/7674,580551566,2021-02-22T20:02:18Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java,"@@ -1318,6 +1325,7 @@ public Response permissionGrant() {         List<String> permissions = formParams.get(""permission"");          if (permissions != null) {+            event.detail(Details.PERMISSION, String.join(""|"", permissions));","The intention here is to have enough data in the audit records should a deep ""who is doing what and how"" audit takes place, to prove accountability of access to resources.Consider a company with (very) sensitive resources, where it is critical that only the right users with the right permissions can consume them.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7756,580586316,2021-02-22T20:59:27Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanSamlArtifactSessionMappingStoreProvider.java,"@@ -0,0 +1,137 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.sessions.infinispan;++import org.infinispan.client.hotrod.exceptions.HotRodClientException;+import org.infinispan.commons.api.BasicCache;+import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.SamlArtifactSessionMappingModel;+import org.keycloak.models.SamlArtifactSessionMappingStoreProvider;+import org.keycloak.models.sessions.infinispan.entities.ActionTokenValueEntity;+import org.keycloak.models.sessions.infinispan.util.InfinispanUtil;++import java.util.HashMap;+import java.util.Map;+import java.util.UUID;+import java.util.concurrent.TimeUnit;+import java.util.function.Supplier;+++/**+ * @author mhajas+ */+public class InfinispanSamlArtifactSessionMappingStoreProvider implements SamlArtifactSessionMappingStoreProvider {++    public static final Logger logger = Logger.getLogger(InfinispanSamlArtifactSessionMappingStoreProvider.class);++    private static final String USER_SESSION_ID = ""user.session.id"";+    private static final String CLIENT_SESSION_ID = ""client.session.id"";++    private final Supplier<BasicCache<UUID, ActionTokenValueEntity>> codeCache;++    public InfinispanSamlArtifactSessionMappingStoreProvider(Supplier<BasicCache<UUID, ActionTokenValueEntity>> actionKeyCache) {+        this.codeCache = actionKeyCache;+    }++    private Map<String, String> serializedMapping(AuthenticatedClientSessionModel clientSessionModel) {+        Map<String, String> serialized = new HashMap<>(2);+        serialized.put(USER_SESSION_ID, clientSessionModel.getUserSession().getId());+        serialized.put(CLIENT_SESSION_ID, clientSessionModel.getClient().getId());++        return serialized;+    }++    @Override+    public void put(String artifact, int lifespanSeconds, AuthenticatedClientSessionModel clientSessionModel) {+        ActionTokenValueEntity tokenValue = new ActionTokenValueEntity(serializedMapping(clientSessionModel));++        try {+            BasicCache<UUID, ActionTokenValueEntity> cache = codeCache.get();+            long lifespanMs = InfinispanUtil.toHotrodTimeMs(cache, Time.toMillis(lifespanSeconds));+            cache.put(UUID.nameUUIDFromBytes(artifact.getBytes()), tokenValue, lifespanMs, TimeUnit.MILLISECONDS);+        } catch (HotRodClientException re) {+            // No need to retry. The hotrod (remoteCache) has some retries in itself in case of some random network error happened.+            if (logger.isDebugEnabled()) {+                logger.debugf(re, ""Failed when adding artifact %s"", artifact);+            }++            throw re;+        }+    }+    +    private Map<String, String> getStoredData(String artifact) {+        try {+            BasicCache<UUID, ActionTokenValueEntity> cache = codeCache.get();+            ActionTokenValueEntity existing = cache.get(UUID.nameUUIDFromBytes(artifact.getBytes()));+            return existing == null ? null : existing.getNotes();+        } catch (HotRodClientException re) {+            // No need to retry. The hotrod (remoteCache) has some retries in itself in case of some random network error happened.+            // In case of lock conflict, we don't want to retry anyway as there was likely an attempt to remove the code from different place.+            if (logger.isDebugEnabled()) {+                logger.debugf(re, ""Failed when obtaining data for artifact %s"", artifact);+            }++            return null;+        }+    }++    @Override+    public SamlArtifactSessionMappingModel get(String artifact) {+        Map<String, String> serializedMapping = getStoredData(artifact);++        if (serializedMapping == null) {+            return null;+        }++        return new SamlArtifactSessionMappingModel() {",Why `SamlArtifactSessionMappingModel` need an interface? Looks like we can just make it a class.,
64939232,Yang-Xie-OSS,https://api.github.com/repos/keycloak/keycloak/pulls/7323,581544730,2021-02-24T01:47:11Z,services/src/main/java/org/keycloak/social/apple/AppleIdentityProvider.java,"@@ -0,0 +1,277 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.social.apple;++import com.fasterxml.jackson.core.JsonProcessingException;+import com.fasterxml.jackson.databind.JsonNode;+import com.fasterxml.jackson.databind.ObjectMapper;+import org.apache.commons.lang.StringUtils;+import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.broker.oidc.OIDCIdentityProvider;+import org.keycloak.broker.oidc.OIDCIdentityProviderConfig;+import org.keycloak.broker.oidc.mappers.AbstractJsonUserAttributeMapper;+import org.keycloak.broker.provider.BrokeredIdentityContext;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.broker.social.SocialIdentityProvider;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.crypto.KeyWrapper;+import org.keycloak.crypto.ServerECDSASignatureSignerContext;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.jose.jws.JWSBuilder;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.ErrorPage;+import org.keycloak.services.Urls;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.FormParam;+import javax.ws.rs.POST;+import javax.ws.rs.WebApplicationException;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.Response;+import java.security.KeyFactory;+import java.security.PrivateKey;+import java.security.spec.PKCS8EncodedKeySpec;+import java.util.Base64;++/**+ * @author Emilien Bondu+ */+public class AppleIdentityProvider extends OIDCIdentityProvider implements SocialIdentityProvider<OIDCIdentityProviderConfig> {++    private static final String OAUTH2_PARAMETER_CODE = ""code"";++    private static final String OAUTH2_PARAMETER_STATE = ""state"";++    private static final String OAUTH2_PARAMETER_USER = ""user"";++    public static final String ACCESS_DENIED = ""access_denied"";++    protected static ObjectMapper mapper = new ObjectMapper();++    public static final String AUTH_URL = ""https://appleid.apple.com/auth/authorize?response_mode=form_post"";++    public static final String TOKEN_URL = ""https://appleid.apple.com/auth/token"";++    public static final String ISSUER = ""https://appleid.apple.com"";++    public static final String JWKS_URL = ""https://appleid.apple.com/auth/keys"";++    public static final String EMAIL_SCOPE = ""email"";++    public static final String NAME_SCOPE = ""name"";++    protected static final Logger logger = Logger.getLogger(AppleIdentityProvider.class);++    public AppleIdentityProvider(KeycloakSession session, AppleIdentityProviderConfig config) {+        super(session, config);++        config.setAuthorizationUrl(AUTH_URL);+        config.setTokenUrl(TOKEN_URL);+        config.setClientAuthMethod(OIDCLoginProtocol.CLIENT_SECRET_POST);+        config.setIssuer(ISSUER);+        config.setUseJwksUrl(true);+        config.setValidateSignature(true);+        config.setJwksUrl(JWKS_URL);+        String defaultScope = config.getDefaultScope();++        if (!isValidSecret(config.getClientSecret())) {+            config.setClientSecret(generateJWS(+                    config.getP8Content(),+                    config.getKeyId(),+                    config.getTeamId())+            );+        }++        if (defaultScope ==  null || defaultScope.trim().equals("""")) {+            config.setDefaultScope(""openid""+ "" "" + NAME_SCOPE+ "" "" + EMAIL_SCOPE);+        }+    }++    @Override+    public Object callback(RealmModel realm, AuthenticationCallback callback, EventBuilder event) {+        return new Endpoint(realm, callback, event);+    }++    @Override+    protected String getDefaultScopes() {+        return ""openid""+ "" "" + NAME_SCOPE+ "" "" + EMAIL_SCOPE;+    }++    protected class Endpoint {+        protected RealmModel realm;++        protected AuthenticationCallback callback;++        protected EventBuilder event;++        @Context+        protected KeycloakSession session;++        @Context+        protected ClientConnection clientConnection;++        @Context+        protected HttpHeaders headers;++        public Endpoint(RealmModel realm, AuthenticationCallback callback, EventBuilder event) {+            this.realm = realm;+            this.callback = callback;+            this.event = event;+        }++        @POST+        public Response authResponse(@FormParam(AppleIdentityProvider.OAUTH2_PARAMETER_STATE) String state,+                                     @FormParam(AppleIdentityProvider.OAUTH2_PARAMETER_CODE) String authorizationCode,+                                     @FormParam(AppleIdentityProvider.OAUTH2_PARAMETER_USER) String user,+                                     @FormParam(OAuth2Constants.ERROR) String error) {+            if (error != null) {+                logger.error(error + "" for broker login "" + getConfig().getProviderId());+                if (error.equals(ACCESS_DENIED)) {+                    return callback.cancelled(state);+                } else if (error.equals(OAuthErrorException.LOGIN_REQUIRED) || error.equals(OAuthErrorException.INTERACTION_REQUIRED)) {+                    return callback.error(state, error);+                } else {+                    return callback.error(state, Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);+                }+            }++            try {+                if (authorizationCode != null) {++                    String response = generateTokenRequest(authorizationCode).asString();++                    BrokeredIdentityContext federatedIdentity = getFederatedIdentity(user, response);+                    federatedIdentity.setIdpConfig(getConfig());+                    federatedIdentity.setIdp(AppleIdentityProvider.this);+                    federatedIdentity.setCode(state);+                    return callback.authenticated(federatedIdentity);+                }+            } catch (WebApplicationException e) {+                return e.getResponse();+            } catch (Exception e) {+                logger.error(""Failed to make identity provider oauth callback"", e);+            }+            event.event(EventType.LOGIN);+            event.error(Errors.IDENTITY_PROVIDER_LOGIN_FAILURE);+            return ErrorPage.error(session, null, Response.Status.BAD_GATEWAY, Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);+        }++        public BrokeredIdentityContext getFederatedIdentity(String userData, String response) throws JsonProcessingException {+            BrokeredIdentityContext user = AppleIdentityProvider.this.getFederatedIdentity(response);++            if (userData != null) {+                JsonNode profile = mapper.readTree(userData);++                JsonNode email = profile.get(""email"");+                if(email != null) {+                    user.setEmail(email.asText());+                }++                JsonNode nameNode = profile.get(""name"");+                if (nameNode != null) {+                    JsonNode firstNameNode = nameNode.get(""firstName"");+                    if (firstNameNode != null) {+                        user.setFirstName(firstNameNode.asText());+                    }+                    JsonNode lastNameNode = nameNode.get(""lastName"");+                    if (lastNameNode != null) {+                        user.setLastName(lastNameNode.asText());+                    }+                    if (firstNameNode != null && lastNameNode != null) {+                        user.setUsername(firstNameNode.asText() + "" "" + lastNameNode.asText());+                    }+                }++                AbstractJsonUserAttributeMapper.storeUserProfileForMapper(user, profile, getConfig().getAlias());+            }++            return user;+        }++        public SimpleHttp generateTokenRequest(String authorizationCode) {+            KeycloakContext context = session.getContext();+            SimpleHttp tokenRequest = SimpleHttp.doPost(getConfig().getTokenUrl(), session)+                    .param(OAUTH2_PARAMETER_CODE, authorizationCode)+                    .param(OAUTH2_PARAMETER_REDIRECT_URI, Urls.identityProviderAuthnResponse(context.getUri().getBaseUri(),+                            getConfig().getAlias(), context.getRealm().getName()).toString())+                    .param(OAUTH2_PARAMETER_GRANT_TYPE, OAUTH2_GRANT_TYPE_AUTHORIZATION_CODE);+            return authenticateTokenRequest(tokenRequest);+        }+    }++    private String generateJWS(String p8Content, String keyId, String teamId) {+        try {+            KeyFactory kf = KeyFactory.getInstance(""ECDSA"");+            PKCS8EncodedKeySpec keySpecPKCS8 = new PKCS8EncodedKeySpec(+                    Base64.getDecoder().decode(+                            p8Content+                                    .replaceAll(""-----BEGIN PRIVATE KEY-----"", """")+                                    .replaceAll(""-----END PRIVATE KEY-----"", """")+                                    .replaceAll(""\\n"", """")+                                    .replaceAll("" "", """")+                    ));+            PrivateKey privateKey = kf.generatePrivate(keySpecPKCS8);+            KeyWrapper keyWrapper = new KeyWrapper();+            keyWrapper.setAlgorithm(""ES256"");+            keyWrapper.setPrivateKey(privateKey);++            return new JWSBuilder()+                    .kid(keyId)+                    .jsonContent(generateClientToken(teamId))+                    .sign(new ServerECDSASignatureSignerContext(keyWrapper));+        } catch (Exception e) {+            logger.error(""Unable to generate JWS"");+        }+        return null;+    }++    private boolean isValidSecret(String clientSecret) {+        if (clientSecret != null  && clientSecret.length() > 0) {+            try {+                JWSInput jws = new JWSInput(clientSecret);+                JsonWebToken token = jws.readJsonContent(JsonWebToken.class);+                return !token.isExpired();+            } catch (JWSInputException e) {+                logger.debug(""Secret is not a valid JWS"");+            }+        }+        return false;+    }++    private JsonWebToken generateClientToken(String teamId) {+        JsonWebToken jwt = new JsonWebToken();+        jwt.issuer(teamId);+        jwt.subject(getConfig().getClientId());+        jwt.audience(ISSUER);+        jwt.expiration(Time.currentTime() + 86400*180);+        jwt.issuedNow();",It's probably not that important but you should use Issued At instead of Time.currentTime() because they may not have the same value. In addition to JsonWebToken.expiration() is deprecated I think the code as shown below would be better.```        jwt.issuedNow();        jwt.exp(jwt.getIat() + 86400 * 1800);```,
31417989,harture,https://api.github.com/repos/keycloak/keycloak/pulls/7756,581738391,2021-02-24T08:09:10Z,saml-core-api/src/main/java/org/keycloak/saml/common/constants/GeneralConstants.java,"@@ -98,6 +98,8 @@      String SAML_RESPONSE_KEY = ""SAMLResponse""; +    String SAML_ARTIFACT_KEY = ""SAMLart"";","SAML specification defines the parameter as SAMLart. (http://docs.oasis-open.org/security/saml/v2.0/saml-bindings-2.0-os.pdf, Section 3.6.3.2)",
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/7694,582607500,2021-02-25T07:43:31Z,adapters/oidc/js/package.json,"@@ -0,0 +1,28 @@+{+  ""private"": true,+  ""workspaces"": [+    ""packages/keycloak-js"",+    ""packages/keycloak-authz""+  ],+  ""engines"": {+    ""node"": ""^14""+  },+  ""scripts"": {+    ""bundle"": ""rimraf target/classes && cross-env TS_NODE_PROJECT=\""tsconfig.webpack.json\"" webpack""","Wouldn't it be nice to add a build script here as well? So you can build all the packages from one place?```suggestion    ""build"": ""yarn workspaces run build"",    ""bundle"": ""rimraf target/classes && cross-env TS_NODE_PROJECT=\""tsconfig.webpack.json\"" webpack""```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7723,584750747,2021-03-01T14:24:31Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -33,8 +33,7 @@ import java.util.HashMap; import java.util.LinkedList; import java.util.List;--import javax.ws.rs.BadRequestException;+import java.util.stream.Collectors;","I wonder if there is a good time to possibly ""decompose"" ClientPoliciesTest into multiple test classes? For example one class, which will focus mostly on CRUD of clients and another with focus on stuff like signatures, token introspection etc? I have some impression that current class is quite big and already has 29 test methods.Just an idea for the future. I suggest to *not* do it in this PR, but rather have separate PR for this...",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7723,585215884,2021-03-02T03:12:11Z,services/src/main/java/org/keycloak/services/clientpolicy/context/ClientCRUDContext.java,"@@ -48,19 +51,39 @@ default ClientModel getClientToBeUpdated() {      *      * @return {@link UserModel}      */-    UserModel getAuthenticatedUser();+    default UserModel getAuthenticatedUser() {+        return null;+    }+     /**      * returns {@link UserModel} of the authenticated client.      *      * @return {@link UserModel}      */-    ClientModel getAuthenticatedClient();+    default ClientModel getAuthenticatedClient() {+        return null;+    }++    /**+     * @return the newly registered client {@link ClientModel}+     */+    default ClientModel getRegisteredClient() {","@mposolda As you pointed out, we need not provide these 2 method. It is sufficient to provide `getTargetClient()` to satisfy their purposes of each implementing concrete context classes. Also, on `REGISTER` event, `getTargetClient()` returns null. Therefore, I will add comments about it onto the header of `getTargetClient()`.- AbstractAdminClientCRUDContext  getTargetClient() = null  getRegisteredClient() = null  getUpdatedClient() = null- AdminClientRegisterContext   getTargetClient() = null   getRegisteredClient() = null   getUpdatedClient() = null- AdminClientRegisteredContext   getTargetClient() = null   getRegisteredClient() = registeredClient   getUpdatedClient() = null- AdminClientUnregisterContext   getTargetClient() = targetClient   getRegisteredClient() = null   getUpdatedClient() = null- AdminClientUpdateContext   getTargetClient() = targetClient   getRegisteredClient() = null   getUpdatedClient() = null- AdminClientUpdatedContext   getTargetClient() = null   getRegisteredClient() = null   getUpdatedClient() = targetClient-  AdminClientViewContext   getTargetClient() = targetClient   getRegisteredClient() = null   getUpdatedClient() = null- AbstractDynamicClientCRUDContext  getTargetClient() = null  getRegisteredClient() = null  getUpdatedClient() = null- DynamicClientRegisterContext   getTargetClient() = null   getRegisteredClient() = null   getUpdatedClient() = null- DynamicClientRegisteredContext   getTargetClient() = null   getRegisteredClient() = registeredClient   getUpdatedClient() = null- DynamicClientUnregisterContext   getTargetClient() = targetClient   getRegisteredClient() = null   getUpdatedClient() = null- DynamicClientUpdateContext   getTargetClient() = targetClient   getRegisteredClient() = null   getUpdatedClient() = null- DynamicClientUpdatedContext   getTargetClient() = null   getRegisteredClient() = null   getUpdatedClient() = targetClient- DynamicClientViewContext   getTargetClient() = targetClient   getRegisteredClient() = null   getUpdatedClient() = null",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7750,586817360,2021-03-03T21:47:28Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/JpaFederation.java,"@@ -22,29 +22,52 @@ import org.keycloak.storage.UserStorageProviderSpi; import org.keycloak.storage.federated.UserFederatedStorageProviderSpi; import org.keycloak.storage.jpa.JpaUserFederatedStorageProviderFactory;-import org.keycloak.testsuite.federation.BackwardsCompatibilityUserStorageFactory; import com.google.common.collect.ImmutableSet; import java.util.Set;+import java.util.concurrent.atomic.AtomicInteger;+import java.util.stream.Stream;+import org.keycloak.storage.clientscope.ClientScopeStorageProvider;+import org.keycloak.storage.clientscope.ClientScopeStorageProviderFactory;+import org.keycloak.storage.clientscope.ClientScopeStorageProviderModel;+import org.keycloak.storage.clientscope.ClientScopeStorageProviderSpi;+import org.keycloak.testsuite.federation.HardcodedClientScopeStorageProviderFactory;  /**  *  * @author hmlnarik  */ public class JpaFederation extends KeycloakModelParameters { +    private final AtomicInteger counter = new AtomicInteger();",I've followed the same pattern as it's used in other `KeycloakModelParameters` subclasses like [`LdapUserStorage`](https://github.com/keycloak/keycloak/blob/master/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/LdapUserStorage.java#L59) or [`BackwardsCompatibilityUserStorage`](https://github.com/keycloak/keycloak/blob/master/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/BackwardsCompatibilityUserStorage.java#L43),
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7756,589374406,2021-03-08T12:08:14Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanSamlArtifactSessionMappingStoreProviderFactory.java,"@@ -0,0 +1,77 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.sessions.infinispan;++import org.infinispan.commons.api.BasicCache;+import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.SamlArtifactSessionMappingStoreProvider;+import org.keycloak.models.SamlArtifactSessionMappingStoreProviderFactory;+import org.keycloak.models.sessions.infinispan.entities.ActionTokenValueEntity;++import java.util.UUID;+import java.util.function.Supplier;++/**+ * @author mhajas+ */+public class InfinispanSamlArtifactSessionMappingStoreProviderFactory implements SamlArtifactSessionMappingStoreProviderFactory {++    private static final Logger LOG = Logger.getLogger(InfinispanSamlArtifactSessionMappingStoreProviderFactory.class);++    // Reuse ""actionTokens"" infinispan cache for now+    private volatile Supplier<BasicCache<UUID, ActionTokenValueEntity>> codeCache;++    @Override+    public SamlArtifactSessionMappingStoreProvider create(KeycloakSession session) {+        lazyInit(session);+        return new InfinispanSamlArtifactSessionMappingStoreProvider(codeCache);+    }++    private void lazyInit(KeycloakSession session) {+        if (codeCache == null) {","This way it is used in many places. The `postInit` method would be used even when artifact binding is not used at all, however, when it is called as part of the `create` method it is initiated only when it is used. This class is basically copy & paste from `InfinispanCodeToTokenStoreProvider`.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7750,589663358,2021-03-08T18:47:27Z,services/src/main/java/org/keycloak/storage/ClientScopeStorageManager.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.storage;++import java.util.stream.Stream;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.ClientScopeProvider;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.storage.clientscope.ClientScopeLookupProvider;+import org.keycloak.storage.clientscope.ClientScopeStorageProvider;+import org.keycloak.storage.clientscope.ClientScopeStorageProviderFactory;+import org.keycloak.storage.clientscope.ClientScopeStorageProviderModel;++public class ClientScopeStorageManager extends AbstractStorageManager<ClientScopeStorageProvider, ClientScopeStorageProviderModel> implements ClientScopeProvider {++    public ClientScopeStorageManager(KeycloakSession session) {+        super(session, ClientScopeStorageProviderFactory.class, ClientScopeStorageProvider.class,+                ClientScopeStorageProviderModel::new, ""clientscope"");+    }++    /* CLIENT SCOPE PROVIDER LOOKUP METHODS - implemented by client scope storage providers */++    @Override+    public ClientScopeModel getClientScopeById(RealmModel realm, String id) {+        StorageId storageId = new StorageId(id);+        if (storageId.getProviderId() == null) {+            return session.clientScopeLocalStorage().getClientScopeById(realm, id);+        }++        ClientScopeLookupProvider provider = getStorageProviderInstance(realm, storageId.getProviderId(), ClientScopeLookupProvider.class);+        if (provider == null) return null;++        return provider.getClientScopeById(realm, id);+    }++    /* CLIENT SCOPE PROVIDER METHODS - provided only by local storage (e.g. not supported by storage providers) */","I see. As far as I understand it all those lookup providers declares methods which can be used for lookup exact object by some attribute or search objects by some attribute. For getting all objects there is non-lookup providers used, e.g. https://github.com/keycloak/keycloak/blob/master/server-spi/src/main/java/org/keycloak/models/ClientProvider.java#L54",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590184765,2021-03-09T10:23:02Z,services/src/main/java/org/keycloak/protocol/oidc/grants/device/endpoints/DeviceEndpoint.java,"@@ -0,0 +1,488 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.grants.device.endpoints;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.Time;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.OAuth2DeviceUserCodeProvider;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.SystemClientUtil;+import org.keycloak.protocol.AuthorizationEndpointBase;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequestParserProcessor;+import org.keycloak.protocol.oidc.grants.device.DeviceGrantType;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.OAuth2DeviceAuthorizationResponse;+import org.keycloak.saml.common.util.StringUtil;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.ErrorPageException;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resource.RealmResourceProvider;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.resources.SessionCodeChecks;+import org.keycloak.services.util.CacheControlUtil;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.util.JsonSerialization;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.Consumes;+import javax.ws.rs.GET;+import javax.ws.rs.HttpMethod;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import static org.keycloak.protocol.oidc.endpoints.AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX;+import static org.keycloak.protocol.oidc.grants.device.DeviceGrantType.OAUTH2_DEVICE_USER_CODE;+import static org.keycloak.protocol.oidc.grants.device.DeviceGrantType.OAUTH2_USER_CODE_VERIFY;+import static org.keycloak.services.resources.LoginActionsService.SESSION_CODE;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class DeviceEndpoint extends AuthorizationEndpointBase implements RealmResourceProvider {++    protected static final Logger logger = Logger.getLogger(DeviceEndpoint.class);++    protected Cors cors;++    public DeviceEndpoint(RealmModel realm, EventBuilder event) {+        super(realm, event);+    }++    /**+     * Handles device authorization requests.+     *+     * @return the device authorization response.+     */+    @Path(""/auth"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response handleDeviceRequest() {+        logger.trace(""Processing @POST request"");+        cors = Cors.add(httpRequest).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);+        event.event(EventType.OAUTH2_DEVICE_AUTH);++        checkSsl();+        checkRealm();++        ClientModel client = authenticateClient();++        AuthorizationEndpointRequest request = AuthorizationEndpointRequestParserProcessor.parseRequest(event, session, client,+            httpRequest.getDecodedFormParameters());++        if (!TokenUtil.isOIDCRequest(request.getScope())) {+            ServicesLogger.LOGGER.oidcScopeMissing();+        }++        createAuthenticationSession(client, request);++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();++        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT,+                ""Client not allowed for OAuth 2.0 Device Authorization Grant"", Response.Status.BAD_REQUEST);+        }++        int expiresIn = realm.getOAuth2DeviceConfig().getLifespan(client);+        int interval = realm.getOAuth2DeviceConfig().getPoolingInterval(client);++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+            Base64Url.encode(KeycloakModelUtils.generateSecret()), request.getScope(), request.getNonce(), expiresIn, interval,+            request.getAdditionalReqParams());+        OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+        String secret = userCodeProvider.generate();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(), secret);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + interval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        store.put(deviceCode, userCode, lifespanSeconds);++        try {+            String deviceUrl = DeviceGrantType.oauth2DeviceVerificationUrl(session.getContext().getUri()).build(realm.getName())+                .toString();++            OAuth2DeviceAuthorizationResponse response = new OAuth2DeviceAuthorizationResponse();+            response.setDeviceCode(deviceCode.getDeviceCode());+            response.setUserCode(userCodeProvider.display(secret));+            response.setExpiresIn(expiresIn);+            response.setInterval(interval);+            response.setVerificationUri(deviceUrl);+            response.setVerificationUriComplete(deviceUrl + ""?user_code="" + response.getUserCode());++            return Response.ok(JsonSerialization.writeValueAsBytes(response)).type(MediaType.APPLICATION_JSON_TYPE).build();","This method uses ""cors"" at the beginning, however this response doesn't have cors in it. I see cors is used in some error responses, however some others (EG. the one from checkSssl, or checkRealm) don't use cors.Question: Does the deviceRequest requires cors at all? If yes, then it should be handled properly and make sure that this response as well as all error responses use cors. If not, it will be better to skip ""cors"" entirely from this.It seems to me that ""cors"" is typically not needed in the deviceRequest, so it will be probably better to remove it entirely from this class (or at least from this request?)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590188204,2021-03-09T10:27:05Z,services/src/main/java/org/keycloak/protocol/oidc/grants/device/DeviceGrantType.java,"@@ -0,0 +1,327 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.grants.device;++import static org.keycloak.protocol.oidc.OIDCLoginProtocolService.tokenServiceBaseUrl;++import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.ClientSessionContext;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakUriInfo;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.protocol.LoginProtocol;+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.OIDCLoginProtocolService;+import org.keycloak.protocol.oidc.TokenManager;+import org.keycloak.protocol.oidc.endpoints.TokenEndpoint;+import org.keycloak.protocol.oidc.endpoints.AuthorizationEndpoint;+import org.keycloak.protocol.oidc.grants.device.endpoints.DeviceEndpoint;+import org.keycloak.representations.AccessToken;+import org.keycloak.representations.AccessTokenResponse;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.managers.UserSessionCrossDCManager;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.resources.LoginActionsService;+import org.keycloak.services.resources.RealmsResource;+import org.keycloak.services.util.DefaultClientSessionContext;+import org.keycloak.services.util.MtlsHoKTokenUtil;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import javax.ws.rs.core.UriBuilder;+import javax.ws.rs.core.UriInfo;++import java.net.URI;+import java.util.stream.Stream;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ * @author <a href=""mailto:michito.okai.zn@hitachi.com"">Michito Okai</a>+ */+public class DeviceGrantType {++    // OAuth 2.0 Device Authorization Grant+    public static final String OAUTH2_DEVICE_VERIFIED_USER_CODE = ""OAUTH2_DEVICE_VERIFIED_USER_CODE"";+    public static final String OAUTH2_DEVICE_USER_CODE = ""device_user_code"";+    public static final String OAUTH2_USER_CODE_VERIFY = ""device/verify"";++    public static UriBuilder oauth2DeviceVerificationUrl(UriInfo uriInfo) {+        UriBuilder baseUriBuilder = uriInfo.getBaseUriBuilder();+        return baseUriBuilder.path(RealmsResource.class).path(""{realm}"").path(""device"");+    }++    public static URI realmOAuth2DeviceVerificationAction(URI baseUri, String realmName) {+        return Urls.loginActionsBase(baseUri).path(LoginActionsService.class, ""processOAuth2DeviceVerification"").path(+                DeviceEndpoint.class, ""verifyUserCode"").build(realmName);+    }++    public static UriBuilder oauth2DeviceAuthUrl(UriBuilder baseUriBuilder) {+        UriBuilder uriBuilder = tokenServiceBaseUrl(baseUriBuilder);+        return uriBuilder.path(OIDCLoginProtocolService.class, ""auth"").path(AuthorizationEndpoint.class, ""authorizeDevice"")+            .path(DeviceEndpoint.class, ""handleDeviceRequest"");+    }++    public static UriBuilder oauth2DeviceVerificationCompletedUrl(UriInfo baseUri) {+        return Urls.loginActionsBase(baseUri.getBaseUri()).path(LoginActionsService.class, ""processOAuth2DeviceVerification"").path(+                DeviceEndpoint.class, ""status"");+    }++    public static Response denyOAuth2DeviceAuthorization(AuthenticationSessionModel authSession, LoginProtocol.Error error, KeycloakSession session) {+        KeycloakContext context = session.getContext();+        RealmModel realm = context.getRealm();+        KeycloakUriInfo uri = context.getUri();+        UriBuilder uriBuilder = DeviceGrantType.oauth2DeviceVerificationCompletedUrl(uri);+        String errorType = OAuthErrorException.SERVER_ERROR;+        if (error == LoginProtocol.Error.CONSENT_DENIED) {+            String verifiedUserCode = authSession.getClientNote(DeviceGrantType.OAUTH2_DEVICE_VERIFIED_USER_CODE);+            OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+            if (!store.deny(realm, verifiedUserCode)) {+                // Already expired and removed in the store+                errorType = OAuthErrorException.EXPIRED_TOKEN;+            } else {+                errorType = OAuthErrorException.ACCESS_DENIED;+            }+        }+        return Response.status(302).location(+                uriBuilder.queryParam(OAuth2Constants.ERROR, errorType)+                        .build(realm.getName())+        ).build();+    }++    public static Response approveOAuth2DeviceAuthorization(AuthenticationSessionModel authSession, AuthenticatedClientSessionModel clientSession, KeycloakSession session) {+        KeycloakContext context = session.getContext();+        RealmModel realm = context.getRealm();+        KeycloakUriInfo uriInfo = context.getUri();+        UriBuilder uriBuilder = DeviceGrantType.oauth2DeviceVerificationCompletedUrl(uriInfo);++        String verifiedUserCode = authSession.getClientNote(DeviceGrantType.OAUTH2_DEVICE_VERIFIED_USER_CODE);+        String userSessionId = clientSession.getUserSession().getId();+        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        if (!store.approve(realm, verifiedUserCode, userSessionId)) {+            // Already expired and removed in the store+            return Response.status(302).location(+                    uriBuilder.queryParam(OAuth2Constants.ERROR, OAuthErrorException.EXPIRED_TOKEN)+                            .build(realm.getName())+            ).build();+        }++        // Now, remove the verified user code+        store.removeUserCode(realm, verifiedUserCode);++        return Response.status(302).location(+                uriBuilder.build(realm.getName())+        ).build();+    }++    public static boolean isOAuth2DeviceVerificationFlow(final AuthenticationSessionModel authSession) {+        String flow = authSession.getClientNote(DeviceGrantType.OAUTH2_DEVICE_VERIFIED_USER_CODE);+        return flow != null;+    }++    private MultivaluedMap<String, String> formParams;+    private ClientModel client;+    private TokenEndpoint tokenEndpoint;++    private KeycloakSession session;++    private HttpRequest request;++    private final TokenManager tokenManager;+    private final RealmModel realm;+    private final EventBuilder event;++    private Cors cors;++    public DeviceGrantType(MultivaluedMap<String, String> formParams, ClientModel client, TokenEndpoint tokenEndpoint,+        KeycloakSession session, HttpRequest request, TokenManager tokenManager, RealmModel realm, EventBuilder event,+        Cors cors) {+        this.formParams = formParams;+        this.client = client;+        this.tokenEndpoint = tokenEndpoint;+        this.session = session;+        this.request = request;+        this.tokenManager = tokenManager;+        this.realm = realm;+        this.event = event;+        this.cors = cors;+    }++    public Response oauth2DeviceFlow() {+        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT,+                ""Client not allowed OAuth 2.0 Device Authorization Grant"", Response.Status.BAD_REQUEST);+        }++        String deviceCode = formParams.getFirst(OAuth2Constants.DEVICE_CODE);+        if (deviceCode == null) {+            event.error(Errors.INVALID_OAUTH2_DEVICE_CODE);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST,+                ""Missing parameter: "" + OAuth2Constants.DEVICE_CODE, Response.Status.BAD_REQUEST);+        }++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        OAuth2DeviceCodeModel deviceCodeModel = store.getByDeviceCode(realm, deviceCode);++        if (deviceCodeModel == null) {+            event.error(Errors.INVALID_OAUTH2_DEVICE_CODE);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""Device code not valid"",+                Response.Status.BAD_REQUEST);+        }++        if (deviceCodeModel.isExpired()) {+            event.error(Errors.EXPIRED_OAUTH2_DEVICE_CODE);+            throw new CorsErrorResponseException(cors, OAuthErrorException.EXPIRED_TOKEN, ""Device code is expired"",+                Response.Status.BAD_REQUEST);+        }++        if (!store.isPollingAllowed(deviceCodeModel)) {+            event.error(Errors.SLOW_DOWN);+            throw new CorsErrorResponseException(cors, OAuthErrorException.SLOW_DOWN, ""Slow down"", Response.Status.BAD_REQUEST);+        }++        if (deviceCodeModel.isDenied()) {+            event.error(Errors.ACCESS_DENIED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.ACCESS_DENIED,+                ""The end user denied the authorization request"", Response.Status.BAD_REQUEST);+        }++        if (deviceCodeModel.isPending()) {+            throw new CorsErrorResponseException(cors, OAuthErrorException.AUTHORIZATION_PENDING,+                ""The authorization request is still pending"", Response.Status.BAD_REQUEST);+        }++        // Approved++        String userSessionId = deviceCodeModel.getUserSessionId();+        event.detail(Details.CODE_ID, userSessionId);+        event.session(userSessionId);++        // Retrieve UserSession+        UserSessionModel userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm, userSessionId,+            client.getId());++        if (userSession == null) {+            userSession = session.sessions().getUserSession(realm, userSessionId);+            if (userSession == null) {+                throw new CorsErrorResponseException(cors, OAuthErrorException.AUTHORIZATION_PENDING,+                    ""The authorization request is verified but can not lookup the user session yet"",+                    Response.Status.BAD_REQUEST);+            }+        }++        // Now, remove the device code+        store.removeDeviceCode(realm, deviceCode);++        UserModel user = userSession.getUser();+        if (user == null) {+            event.error(Errors.USER_NOT_FOUND);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""User not found"",+                Response.Status.BAD_REQUEST);+        }++        event.user(userSession.getUser());++        if (!user.isEnabled()) {+            event.error(Errors.USER_DISABLED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""User disabled"",+                Response.Status.BAD_REQUEST);+        }++        AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());+        if (!client.getClientId().equals(clientSession.getClient().getClientId())) {+            event.error(Errors.INVALID_CODE);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""Auth error"",+                Response.Status.BAD_REQUEST);+        }++        if (!AuthenticationManager.isSessionValid(realm, userSession)) {+            event.error(Errors.USER_SESSION_NOT_FOUND);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, ""Session not active"",+                Response.Status.BAD_REQUEST);+        }++        tokenEndpoint.updateClientSession(clientSession);","From this line, the code is almost copy of the `TokenEndpoint.codeToToken()` method (starting from line 428 of that class in latest master). I believe it will be better to share this code between both places to avoid code duplications?In general, code duplications has some advantage that you can have 2 places with same/similar code independent on each other, however it has also quite a lots of disadvantages (EG. when later some bug happens, there is a risk that it will be addressed just on the single place in the code and the other place will miss this bugfix etc).",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590190116,2021-03-09T10:28:52Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/OAuth2DeviceAuthorizationGrantTest.java,"@@ -0,0 +1,533 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.oauth;++import static org.junit.Assert.assertNotNull;+import static org.keycloak.models.OAuth2DeviceConfig.DEFAULT_OAUTH2_DEVICE_CODE_LIFESPAN;+import static org.keycloak.models.OAuth2DeviceConfig.DEFAULT_OAUTH2_DEVICE_POLLING_INTERVAL;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.*;+import org.keycloak.admin.client.resource.ClientResource;+import org.keycloak.admin.client.resource.RealmResource;+import org.keycloak.events.Details;+import org.keycloak.models.OAuth2DeviceConfig;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.representations.AccessToken;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AbstractKeycloakTest;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.pages.ErrorPage;+import org.keycloak.testsuite.pages.OAuth2DeviceVerificationPage;+import org.keycloak.testsuite.pages.OAuthGrantPage;+import org.keycloak.testsuite.util.ClientBuilder;+import org.keycloak.testsuite.util.OAuthClient;+import org.keycloak.testsuite.util.RealmBuilder;+import org.keycloak.testsuite.util.UserBuilder;+import org.keycloak.testsuite.util.WaitUtils;++import java.util.List;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class OAuth2DeviceAuthorizationGrantTest extends AbstractKeycloakTest {++    private static String userId;++    public static final String REALM_NAME = ""test"";+    public static final String DEVICE_APP = ""test-device"";+    public static final String DEVICE_APP_PUBLIC = ""test-device-public"";++    @Rule+    public AssertEvents events = new AssertEvents(this);++    @Page+    protected OAuth2DeviceVerificationPage verificationPage;++    @Page+    protected OAuthGrantPage grantPage;++    @Page+    protected ErrorPage errorPage;++    @Override+    public void addTestRealms(List<RealmRepresentation> testRealms) {+        RealmBuilder realm = RealmBuilder.create().name(REALM_NAME)+                .privateKey(""MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y="")+                .publicKey(""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"")+                .testEventListener();+++        ClientRepresentation app = ClientBuilder.create()+                .id(KeycloakModelUtils.generateId())+                .clientId(""test-device"")+                .oauth2DeviceAuthorizationGrant()+                .secret(""secret"")+                .build();+        realm.client(app);++        userId = KeycloakModelUtils.generateId();+        UserRepresentation user = UserBuilder.create()+                .id(userId)+                .username(""device-login"")+                .email(""device-login@localhost"")+                .password(""password"")+                .build();+        realm.user(user);++        testRealms.add(realm.build());+    }++    @Before+    public void resetConfig() {+        RealmRepresentation realm = getAdminClient().realm(REALM_NAME).toRepresentation();+        realm.setOAuth2DeviceCodeLifespan(60);+        realm.setOAuth2DevicePollingInterval(5);+        getAdminClient().realm(REALM_NAME).update(realm);+    }++    @Test+    public void confidentialClientTest() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        // Verify user code from verification page using browser+        openVerificationPage(response.getVerificationUri());+        verificationPage.assertCurrent();+        verificationPage.submit(response.getUserCode());++        verificationPage.assertLoginPage();++        // Do Login+        oauth.fillLoginForm(""device-login"", ""password"");++        // Consent+        grantPage.assertCurrent();+        grantPage.assertGrants(OAuthGrantPage.PROFILE_CONSENT_TEXT, OAuthGrantPage.EMAIL_CONSENT_TEXT, OAuthGrantPage.ROLES_CONSENT_TEXT);+        grantPage.accept();++        verificationPage.assertApprovedPage();++        // Token request from device+        OAuthClient.AccessTokenResponse tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        Assert.assertEquals(200, tokenResponse.getStatusCode());++        String tokenString = tokenResponse.getAccessToken();+        assertNotNull(tokenString);+        AccessToken token = oauth.verifyToken(tokenString);++        assertNotNull(token);+    }++    @Test+    public void ConsentCancelTest() throws Exception {",Cosmetic: Name of this method starts with uppercase. Will be better to lowercase according to conventions. This applies for few more test methods in this class,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590191640,2021-03-09T10:30:12Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/OAuth2DeviceAuthorizationGrantTest.java,"@@ -0,0 +1,533 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.oauth;++import static org.junit.Assert.assertNotNull;+import static org.keycloak.models.OAuth2DeviceConfig.DEFAULT_OAUTH2_DEVICE_CODE_LIFESPAN;+import static org.keycloak.models.OAuth2DeviceConfig.DEFAULT_OAUTH2_DEVICE_POLLING_INTERVAL;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.*;+import org.keycloak.admin.client.resource.ClientResource;+import org.keycloak.admin.client.resource.RealmResource;+import org.keycloak.events.Details;+import org.keycloak.models.OAuth2DeviceConfig;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.representations.AccessToken;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AbstractKeycloakTest;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.pages.ErrorPage;+import org.keycloak.testsuite.pages.OAuth2DeviceVerificationPage;+import org.keycloak.testsuite.pages.OAuthGrantPage;+import org.keycloak.testsuite.util.ClientBuilder;+import org.keycloak.testsuite.util.OAuthClient;+import org.keycloak.testsuite.util.RealmBuilder;+import org.keycloak.testsuite.util.UserBuilder;+import org.keycloak.testsuite.util.WaitUtils;++import java.util.List;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class OAuth2DeviceAuthorizationGrantTest extends AbstractKeycloakTest {++    private static String userId;++    public static final String REALM_NAME = ""test"";+    public static final String DEVICE_APP = ""test-device"";+    public static final String DEVICE_APP_PUBLIC = ""test-device-public"";++    @Rule+    public AssertEvents events = new AssertEvents(this);++    @Page+    protected OAuth2DeviceVerificationPage verificationPage;++    @Page+    protected OAuthGrantPage grantPage;++    @Page+    protected ErrorPage errorPage;++    @Override+    public void addTestRealms(List<RealmRepresentation> testRealms) {+        RealmBuilder realm = RealmBuilder.create().name(REALM_NAME)+                .privateKey(""MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y="")+                .publicKey(""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"")+                .testEventListener();+++        ClientRepresentation app = ClientBuilder.create()+                .id(KeycloakModelUtils.generateId())+                .clientId(""test-device"")+                .oauth2DeviceAuthorizationGrant()+                .secret(""secret"")+                .build();+        realm.client(app);++        userId = KeycloakModelUtils.generateId();+        UserRepresentation user = UserBuilder.create()+                .id(userId)+                .username(""device-login"")+                .email(""device-login@localhost"")+                .password(""password"")+                .build();+        realm.user(user);++        testRealms.add(realm.build());+    }++    @Before+    public void resetConfig() {+        RealmRepresentation realm = getAdminClient().realm(REALM_NAME).toRepresentation();+        realm.setOAuth2DeviceCodeLifespan(60);+        realm.setOAuth2DevicePollingInterval(5);+        getAdminClient().realm(REALM_NAME).update(realm);+    }++    @Test+    public void confidentialClientTest() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        // Verify user code from verification page using browser+        openVerificationPage(response.getVerificationUri());+        verificationPage.assertCurrent();+        verificationPage.submit(response.getUserCode());++        verificationPage.assertLoginPage();++        // Do Login+        oauth.fillLoginForm(""device-login"", ""password"");++        // Consent+        grantPage.assertCurrent();+        grantPage.assertGrants(OAuthGrantPage.PROFILE_CONSENT_TEXT, OAuthGrantPage.EMAIL_CONSENT_TEXT, OAuthGrantPage.ROLES_CONSENT_TEXT);+        grantPage.accept();++        verificationPage.assertApprovedPage();++        // Token request from device+        OAuthClient.AccessTokenResponse tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        Assert.assertEquals(200, tokenResponse.getStatusCode());++        String tokenString = tokenResponse.getAccessToken();+        assertNotNull(tokenString);+        AccessToken token = oauth.verifyToken(tokenString);++        assertNotNull(token);+    }++    @Test+    public void ConsentCancelTest() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        openVerificationPage(response.getVerificationUriComplete());+        loginPage.assertCurrent();++        // Do Login+        oauth.fillLoginForm(""device-login"", ""password"");++        // Consent+        grantPage.assertCurrent();+        grantPage.assertGrants(OAuthGrantPage.PROFILE_CONSENT_TEXT, OAuthGrantPage.EMAIL_CONSENT_TEXT, OAuthGrantPage.ROLES_CONSENT_TEXT);+        grantPage.cancel();++        verificationPage.assertDeniedPage();+ +        OAuthClient.AccessTokenResponse tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        Assert.assertEquals(400, tokenResponse.getStatusCode());+        Assert.assertEquals(""access_denied"", tokenResponse.getError());+    }++    @Test+    public void InvalidUserCodeTest() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        openVerificationPage(response.getVerificationUri());+        verificationPage.submit(""x"");++        verificationPage.assertInvalidUserCodePage();+    }++    @Test+    public void ExpiredUserCodeTest() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        try {+            setTimeOffset(610);+            openVerificationPage(response.getVerificationUriComplete());+        } finally {+            resetTimeOffset();+        }++        verificationPage.assertInvalidUserCodePage();+    }++    @Test+    public void InvalidDeviceCodeTest() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        openVerificationPage(response.getVerificationUriComplete());+        loginPage.assertCurrent();++        // Do Login+        oauth.fillLoginForm(""device-login"", ""password"");++        // Consent+        grantPage.assertCurrent();+        grantPage.assertGrants(OAuthGrantPage.PROFILE_CONSENT_TEXT, OAuthGrantPage.EMAIL_CONSENT_TEXT, OAuthGrantPage.ROLES_CONSENT_TEXT);+        grantPage.accept();++        // Token request from device+        OAuthClient.AccessTokenResponse tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", ""x"");++        Assert.assertEquals(400, tokenResponse.getStatusCode());+        Assert.assertEquals(""invalid_grant"", tokenResponse.getError());+    }++    @Test+    public void testSuccessVerificationUriComplete() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        openVerificationPage(response.getVerificationUriComplete());+        loginPage.assertCurrent();++        // Do Login+        oauth.fillLoginForm(""device-login"", ""password"");++        // Consent+        grantPage.assertCurrent();+        grantPage.assertGrants(OAuthGrantPage.PROFILE_CONSENT_TEXT, OAuthGrantPage.EMAIL_CONSENT_TEXT, OAuthGrantPage.ROLES_CONSENT_TEXT);+        grantPage.accept();++        verificationPage.assertApprovedPage();++        // Token request from device+        OAuthClient.AccessTokenResponse tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        Assert.assertEquals(200, tokenResponse.getStatusCode());+    }++    @Test+    public void ExpiredDeviceCodeTest() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        try {+            setTimeOffset(610);+            // Token request from device+            OAuthClient.AccessTokenResponse tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"",+                response.getDeviceCode());++            Assert.assertEquals(400, tokenResponse.getStatusCode());+            Assert.assertEquals(""expired_token"", tokenResponse.getError());+        } finally {+            resetTimeOffset();+        }+    }++    @Test+    public void DeviceCodeLifespanPerClientTest() throws Exception {+        ClientResource client = ApiUtil.findClientByClientId(adminClient.realm(REALM_NAME), DEVICE_APP);+        ClientRepresentation clientRepresentation = client.toRepresentation();+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        clientRepresentation.getAttributes().put(OAuth2DeviceConfig.OAUTH2_DEVICE_CODE_LIFESPAN_PER_CLIENT, ""120"");+        clientRepresentation.getAttributes().put(OAuth2DeviceConfig.OAUTH2_DEVICE_POLLING_INTERVAL_PER_CLIENT, ""600000"");+        client.update(clientRepresentation);++        response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");+        Assert.assertEquals(120, response.getExpiresIn());+        OAuthClient.AccessTokenResponse tokenResponse;++        try {+            setTimeOffset(100);+            // Token request from device+            tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++            Assert.assertEquals(400, tokenResponse.getStatusCode());+            Assert.assertEquals(""authorization_pending"", tokenResponse.getError());++            setTimeOffset(125);+            // Token request from device+            tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++            Assert.assertEquals(400, tokenResponse.getStatusCode());+            Assert.assertEquals(""expired_token"", tokenResponse.getError());+        } finally {+            resetTimeOffset();+        }++        clientRepresentation.getAttributes().put(OAuth2DeviceConfig.OAUTH2_DEVICE_CODE_LIFESPAN_PER_CLIENT, """");+        clientRepresentation.getAttributes().put(OAuth2DeviceConfig.OAUTH2_DEVICE_POLLING_INTERVAL_PER_CLIENT, """");+        client.update(clientRepresentation);+    }++    @Test+    public void DevicePollingIntervalPerClientTest() throws Exception {+        ClientResource client = ApiUtil.findClientByClientId(adminClient.realm(REALM_NAME), DEVICE_APP);+        ClientRepresentation clientRepresentation = client.toRepresentation();+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        clientRepresentation.getAttributes().put(OAuth2DeviceConfig.OAUTH2_DEVICE_POLLING_INTERVAL_PER_CLIENT, ""10"");+        client.update(clientRepresentation);++        response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");+        Assert.assertEquals(10, response.getInterval());+      +        // Token request from device+        OAuthClient.AccessTokenResponse tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        Assert.assertEquals(400, tokenResponse.getStatusCode());+        Assert.assertEquals(""authorization_pending"", tokenResponse.getError());+        +        // Token request from device+        tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        Assert.assertEquals(400, tokenResponse.getStatusCode());+        Assert.assertEquals(""slow_down"", tokenResponse.getError());++        WaitUtils.pause(7000); ++        // Token request from device+        tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        Assert.assertEquals(400, tokenResponse.getStatusCode());+        Assert.assertEquals(""slow_down"", tokenResponse.getError());++        WaitUtils.pause(3000); ++        // Token request from device+        tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        Assert.assertEquals(400, tokenResponse.getStatusCode());+        Assert.assertEquals(""authorization_pending"", tokenResponse.getError());++        clientRepresentation.getAttributes().put(OAuth2DeviceConfig.OAUTH2_DEVICE_POLLING_INTERVAL_PER_CLIENT, """");+        client.update(clientRepresentation);+    }++    @Test+    public void pollingTest() throws Exception {+        RealmRepresentation realm = getAdminClient().realm(REALM_NAME).toRepresentation();+        realm.setOAuth2DeviceCodeLifespan(600);+        getAdminClient().realm(REALM_NAME).update(realm);+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(600, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        // Polling token request from device+        OAuthClient.AccessTokenResponse tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        // Not approved yet+        Assert.assertEquals(400, tokenResponse.getStatusCode());+        Assert.assertEquals(""authorization_pending"", tokenResponse.getError());++        // Polling again without waiting+        tokenResponse = oauth.doDeviceTokenRequest(DEVICE_APP, ""secret"", response.getDeviceCode());++        // Slow down+        Assert.assertEquals(400, tokenResponse.getStatusCode());+        Assert.assertEquals(""slow_down"", tokenResponse.getError());++        // Wait the interval+        WaitUtils.pause(5000);","Test takes a long time to run due the use of `WaitUtils.pause` . This is not necessary. I've recently added the utility into the codebase, which makes possible that infinispan uses our ""Time"" utility for detect it's own time and works as expected with usage of our `Time.setOffset` .In other words, you can start the test by inject our custom testing TimeService to infinispan and then just use `setTimeOffset` in the tests. This will make the OAuth2DeviceGrantTest to be around 30 seconds faster (when it avoids all the calls to WaitUtils.pause on all the places).See for example `LoginTest.loginExpiredCodeWithExplicitRemoveExpired()` for the inspiration. There is also `InfinispanTestTimeServiceRule`, which makes it automatically set infinispan timeService before each test method.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590196452,2021-03-09T10:34:27Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/OAuth2DeviceAuthorizationGrantTest.java,"@@ -0,0 +1,533 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.oauth;++import static org.junit.Assert.assertNotNull;+import static org.keycloak.models.OAuth2DeviceConfig.DEFAULT_OAUTH2_DEVICE_CODE_LIFESPAN;+import static org.keycloak.models.OAuth2DeviceConfig.DEFAULT_OAUTH2_DEVICE_POLLING_INTERVAL;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.*;+import org.keycloak.admin.client.resource.ClientResource;+import org.keycloak.admin.client.resource.RealmResource;+import org.keycloak.events.Details;+import org.keycloak.models.OAuth2DeviceConfig;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.representations.AccessToken;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AbstractKeycloakTest;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.pages.ErrorPage;+import org.keycloak.testsuite.pages.OAuth2DeviceVerificationPage;+import org.keycloak.testsuite.pages.OAuthGrantPage;+import org.keycloak.testsuite.util.ClientBuilder;+import org.keycloak.testsuite.util.OAuthClient;+import org.keycloak.testsuite.util.RealmBuilder;+import org.keycloak.testsuite.util.UserBuilder;+import org.keycloak.testsuite.util.WaitUtils;++import java.util.List;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class OAuth2DeviceAuthorizationGrantTest extends AbstractKeycloakTest {++    private static String userId;++    public static final String REALM_NAME = ""test"";+    public static final String DEVICE_APP = ""test-device"";+    public static final String DEVICE_APP_PUBLIC = ""test-device-public"";++    @Rule+    public AssertEvents events = new AssertEvents(this);++    @Page+    protected OAuth2DeviceVerificationPage verificationPage;++    @Page+    protected OAuthGrantPage grantPage;++    @Page+    protected ErrorPage errorPage;++    @Override+    public void addTestRealms(List<RealmRepresentation> testRealms) {+        RealmBuilder realm = RealmBuilder.create().name(REALM_NAME)+                .privateKey(""MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y="")+                .publicKey(""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB"")+                .testEventListener();+++        ClientRepresentation app = ClientBuilder.create()+                .id(KeycloakModelUtils.generateId())+                .clientId(""test-device"")+                .oauth2DeviceAuthorizationGrant()+                .secret(""secret"")+                .build();+        realm.client(app);++        userId = KeycloakModelUtils.generateId();+        UserRepresentation user = UserBuilder.create()+                .id(userId)+                .username(""device-login"")+                .email(""device-login@localhost"")+                .password(""password"")+                .build();+        realm.user(user);++        testRealms.add(realm.build());+    }++    @Before+    public void resetConfig() {+        RealmRepresentation realm = getAdminClient().realm(REALM_NAME).toRepresentation();+        realm.setOAuth2DeviceCodeLifespan(60);+        realm.setOAuth2DevicePollingInterval(5);+        getAdminClient().realm(REALM_NAME).update(realm);+    }++    @Test+    public void confidentialClientTest() throws Exception {+        // Device Authorization Request from device+        oauth.realm(REALM_NAME);+        oauth.clientId(DEVICE_APP);+        OAuthClient.DeviceAuthorizationResponse response = oauth.doDeviceAuthorizationRequest(DEVICE_APP, ""secret"");++        Assert.assertEquals(200, response.getStatusCode());+        assertNotNull(response.getDeviceCode());+        assertNotNull(response.getUserCode());+        assertNotNull(response.getVerificationUri());+        assertNotNull(response.getVerificationUriComplete());+        Assert.assertEquals(60, response.getExpiresIn());+        Assert.assertEquals(5, response.getInterval());++        // Verify user code from verification page using browser+        openVerificationPage(response.getVerificationUri());+        verificationPage.assertCurrent();+        verificationPage.submit(response.getUserCode());++        verificationPage.assertLoginPage();","I believe it is better to rather use ""loginPage.assertCurrent()"" instead of this? This makes it consistent with all our other tests when each ""Page"" object is responsible for checks related to that particular page.So based on this, I think that method ""assertLoginPage"" on VerificationPage class can be removed entirely.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590241625,2021-03-09T11:16:01Z,server-spi/src/main/java/org/keycloak/models/ClientModel.java,"@@ -199,6 +200,15 @@     boolean isServiceAccountsEnabled();     void setServiceAccountsEnabled(boolean serviceAccountsEnabled); +    default boolean isOAuth2DeviceAuthorizationGrantEnabled() {",I think it will be better to have this inside the OIDCAdvancedConfigWrapper class instead of ClientModel class. OIDCAdvancedConfigWrapper already contains all of OIDC related properties.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590266865,2021-03-09T11:38:08Z,services/src/main/java/org/keycloak/protocol/oidc/grants/device/endpoints/DeviceEndpoint.java,"@@ -0,0 +1,488 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.grants.device.endpoints;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.Time;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.OAuth2DeviceUserCodeProvider;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.SystemClientUtil;+import org.keycloak.protocol.AuthorizationEndpointBase;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequestParserProcessor;+import org.keycloak.protocol.oidc.grants.device.DeviceGrantType;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.OAuth2DeviceAuthorizationResponse;+import org.keycloak.saml.common.util.StringUtil;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.ErrorPageException;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resource.RealmResourceProvider;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.resources.SessionCodeChecks;+import org.keycloak.services.util.CacheControlUtil;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.util.JsonSerialization;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.Consumes;+import javax.ws.rs.GET;+import javax.ws.rs.HttpMethod;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import static org.keycloak.protocol.oidc.endpoints.AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX;+import static org.keycloak.protocol.oidc.grants.device.DeviceGrantType.OAUTH2_DEVICE_USER_CODE;+import static org.keycloak.protocol.oidc.grants.device.DeviceGrantType.OAUTH2_USER_CODE_VERIFY;+import static org.keycloak.services.resources.LoginActionsService.SESSION_CODE;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class DeviceEndpoint extends AuthorizationEndpointBase implements RealmResourceProvider {++    protected static final Logger logger = Logger.getLogger(DeviceEndpoint.class);++    protected Cors cors;++    public DeviceEndpoint(RealmModel realm, EventBuilder event) {+        super(realm, event);+    }++    /**+     * Handles device authorization requests.+     *+     * @return the device authorization response.+     */+    @Path(""/auth"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response handleDeviceRequest() {+        logger.trace(""Processing @POST request"");+        cors = Cors.add(httpRequest).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);+        event.event(EventType.OAUTH2_DEVICE_AUTH);++        checkSsl();+        checkRealm();++        ClientModel client = authenticateClient();++        AuthorizationEndpointRequest request = AuthorizationEndpointRequestParserProcessor.parseRequest(event, session, client,+            httpRequest.getDecodedFormParameters());++        if (!TokenUtil.isOIDCRequest(request.getScope())) {+            ServicesLogger.LOGGER.oidcScopeMissing();+        }++        createAuthenticationSession(client, request);++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();++        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT,+                ""Client not allowed for OAuth 2.0 Device Authorization Grant"", Response.Status.BAD_REQUEST);+        }++        int expiresIn = realm.getOAuth2DeviceConfig().getLifespan(client);+        int interval = realm.getOAuth2DeviceConfig().getPoolingInterval(client);++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+            Base64Url.encode(KeycloakModelUtils.generateSecret()), request.getScope(), request.getNonce(), expiresIn, interval,+            request.getAdditionalReqParams());+        OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+        String secret = userCodeProvider.generate();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(), secret);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + interval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        store.put(deviceCode, userCode, lifespanSeconds);++        try {+            String deviceUrl = DeviceGrantType.oauth2DeviceVerificationUrl(session.getContext().getUri()).build(realm.getName())+                .toString();++            OAuth2DeviceAuthorizationResponse response = new OAuth2DeviceAuthorizationResponse();+            response.setDeviceCode(deviceCode.getDeviceCode());+            response.setUserCode(userCodeProvider.display(secret));+            response.setExpiresIn(expiresIn);+            response.setInterval(interval);+            response.setVerificationUri(deviceUrl);+            response.setVerificationUriComplete(deviceUrl + ""?user_code="" + response.getUserCode());++            return Response.ok(JsonSerialization.writeValueAsBytes(response)).type(MediaType.APPLICATION_JSON_TYPE).build();+        } catch (Exception e) {+            throw new RuntimeException(""Error creating OAuth 2.0 Device Authorization Response."", e);+        }+    }++    /**+     * This endpoint is used by end-users to start the flow to authorize a device.+     *+     * @param userCode the user code to authorize+     * @return+     */+    @GET+    public Response verifyUserCode(@QueryParam(""user_code"") String userCode) {+        event.event(EventType.OAUTH2_DEVICE_VERIFY_USER_CODE);++        checkSsl();+        checkRealm();++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();++        AuthenticationSessionModel authenticationSession = null;++        // try to recover the authentication session in case the user is pushing the code+        if (HttpMethod.POST.equalsIgnoreCase(httpRequest.getHttpMethod())) {+            String code = httpRequest.getDecodedFormParameters().getFirst(SESSION_CODE);+            String tabId = session.getContext().getUri().getQueryParameters().getFirst(Constants.TAB_ID);++            String systemClientId = SystemClientUtil.getSystemClient(realm).getClientId();++            SessionCodeChecks checks = checksForCode(null, code, null, systemClientId, tabId, OAUTH2_USER_CODE_VERIFY);++            if (!checks.verifyActiveAndValidAction(AuthenticationSessionModel.Action.USER_CODE_VERIFICATION.name(),+                ClientSessionCode.ActionType.LOGIN)) {+                return checks.getResponse();+            }++            authenticationSession = checks.getAuthenticationSession();+        }++        // code is not known, we can infer the client neither. ask the user to provide the code.+        if (StringUtil.isNullOrEmpty(userCode)) {+            ClientModel client = SystemClientUtil.getSystemClient(realm);++            if (authenticationSession == null) {+                authenticationSession = createAuthenticationSession(client);+            }++            return createVerificationPage(null, authenticationSession);+        } else {+            // code exists, probably due to using a verification_uri_complete. Start the authentication considering the client+            // that started the flow.+            OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+            OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+            String formattedUserCode = userCodeProvider.format(userCode);+            OAuth2DeviceCodeModel deviceCode = store.getByUserCode(realm, formattedUserCode);++            if (deviceCode == null) {+                event.error(Errors.INVALID_OAUTH2_USER_CODE);+                return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+            }++            ClientModel client = realm.getClientByClientId(deviceCode.getClientId());++            authenticationSession = createAuthenticationSession(client);","This is wrong as it will sometimes creates the duplicated authenticationSession. For the case when you don't use `verification_uri_complete` and the screen is confirmed, this method is called from the `verifyUserCode` POST method. That checks the existing authenticationSession (lines 184-197), but then also creates the new authenticationSession here.If it is done the approach with `isActionRequest` parameter, you will create authenticationSession here just if this is not actionRequest. For the actionRequest, there should be a hard requirement that authenticationSession already exists (as done in the block 184-197).",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590271225,2021-03-09T11:42:05Z,services/src/main/java/org/keycloak/protocol/oidc/grants/device/endpoints/DeviceEndpoint.java,"@@ -0,0 +1,488 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.grants.device.endpoints;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.Time;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.OAuth2DeviceUserCodeProvider;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.SystemClientUtil;+import org.keycloak.protocol.AuthorizationEndpointBase;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequestParserProcessor;+import org.keycloak.protocol.oidc.grants.device.DeviceGrantType;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.OAuth2DeviceAuthorizationResponse;+import org.keycloak.saml.common.util.StringUtil;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.ErrorPageException;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resource.RealmResourceProvider;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.resources.SessionCodeChecks;+import org.keycloak.services.util.CacheControlUtil;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.util.JsonSerialization;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.Consumes;+import javax.ws.rs.GET;+import javax.ws.rs.HttpMethod;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import static org.keycloak.protocol.oidc.endpoints.AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX;+import static org.keycloak.protocol.oidc.grants.device.DeviceGrantType.OAUTH2_DEVICE_USER_CODE;+import static org.keycloak.protocol.oidc.grants.device.DeviceGrantType.OAUTH2_USER_CODE_VERIFY;+import static org.keycloak.services.resources.LoginActionsService.SESSION_CODE;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class DeviceEndpoint extends AuthorizationEndpointBase implements RealmResourceProvider {++    protected static final Logger logger = Logger.getLogger(DeviceEndpoint.class);++    protected Cors cors;++    public DeviceEndpoint(RealmModel realm, EventBuilder event) {+        super(realm, event);+    }++    /**+     * Handles device authorization requests.+     *+     * @return the device authorization response.+     */+    @Path(""/auth"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response handleDeviceRequest() {+        logger.trace(""Processing @POST request"");+        cors = Cors.add(httpRequest).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);+        event.event(EventType.OAUTH2_DEVICE_AUTH);++        checkSsl();+        checkRealm();++        ClientModel client = authenticateClient();++        AuthorizationEndpointRequest request = AuthorizationEndpointRequestParserProcessor.parseRequest(event, session, client,+            httpRequest.getDecodedFormParameters());++        if (!TokenUtil.isOIDCRequest(request.getScope())) {+            ServicesLogger.LOGGER.oidcScopeMissing();+        }++        createAuthenticationSession(client, request);++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();++        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT,+                ""Client not allowed for OAuth 2.0 Device Authorization Grant"", Response.Status.BAD_REQUEST);+        }++        int expiresIn = realm.getOAuth2DeviceConfig().getLifespan(client);+        int interval = realm.getOAuth2DeviceConfig().getPoolingInterval(client);++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+            Base64Url.encode(KeycloakModelUtils.generateSecret()), request.getScope(), request.getNonce(), expiresIn, interval,+            request.getAdditionalReqParams());+        OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+        String secret = userCodeProvider.generate();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(), secret);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + interval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        store.put(deviceCode, userCode, lifespanSeconds);++        try {+            String deviceUrl = DeviceGrantType.oauth2DeviceVerificationUrl(session.getContext().getUri()).build(realm.getName())+                .toString();++            OAuth2DeviceAuthorizationResponse response = new OAuth2DeviceAuthorizationResponse();+            response.setDeviceCode(deviceCode.getDeviceCode());+            response.setUserCode(userCodeProvider.display(secret));+            response.setExpiresIn(expiresIn);+            response.setInterval(interval);+            response.setVerificationUri(deviceUrl);+            response.setVerificationUriComplete(deviceUrl + ""?user_code="" + response.getUserCode());++            return Response.ok(JsonSerialization.writeValueAsBytes(response)).type(MediaType.APPLICATION_JSON_TYPE).build();+        } catch (Exception e) {+            throw new RuntimeException(""Error creating OAuth 2.0 Device Authorization Response."", e);+        }+    }++    /**+     * This endpoint is used by end-users to start the flow to authorize a device.+     *+     * @param userCode the user code to authorize+     * @return+     */+    @GET+    public Response verifyUserCode(@QueryParam(""user_code"") String userCode) {+        event.event(EventType.OAUTH2_DEVICE_VERIFY_USER_CODE);++        checkSsl();+        checkRealm();++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();++        AuthenticationSessionModel authenticationSession = null;++        // try to recover the authentication session in case the user is pushing the code+        if (HttpMethod.POST.equalsIgnoreCase(httpRequest.getHttpMethod())) {+            String code = httpRequest.getDecodedFormParameters().getFirst(SESSION_CODE);+            String tabId = session.getContext().getUri().getQueryParameters().getFirst(Constants.TAB_ID);++            String systemClientId = SystemClientUtil.getSystemClient(realm).getClientId();++            SessionCodeChecks checks = checksForCode(null, code, null, systemClientId, tabId, OAUTH2_USER_CODE_VERIFY);++            if (!checks.verifyActiveAndValidAction(AuthenticationSessionModel.Action.USER_CODE_VERIFICATION.name(),+                ClientSessionCode.ActionType.LOGIN)) {+                return checks.getResponse();+            }++            authenticationSession = checks.getAuthenticationSession();+        }++        // code is not known, we can infer the client neither. ask the user to provide the code.+        if (StringUtil.isNullOrEmpty(userCode)) {+            ClientModel client = SystemClientUtil.getSystemClient(realm);++            if (authenticationSession == null) {+                authenticationSession = createAuthenticationSession(client);+            }++            return createVerificationPage(null, authenticationSession);+        } else {+            // code exists, probably due to using a verification_uri_complete. Start the authentication considering the client+            // that started the flow.+            OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+            OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+            String formattedUserCode = userCodeProvider.format(userCode);+            OAuth2DeviceCodeModel deviceCode = store.getByUserCode(realm, formattedUserCode);++            if (deviceCode == null) {+                event.error(Errors.INVALID_OAUTH2_USER_CODE);+                return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+            }++            ClientModel client = realm.getClientByClientId(deviceCode.getClientId());++            authenticationSession = createAuthenticationSession(client);++            if (deviceCode.isExpired()) {+                event.error(Errors.INVALID_OAUTH2_USER_CODE);+                return createVerificationPage(Messages.OAUTH2_DEVICE_EXPIRED_USER_CODE, authenticationSession);+            }++            return processVerification(authenticationSession, userCode);+        }+    }++    /**+     * Verifies the code provided by the end-user and start the authentication.+     *+     * @return+     */+    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    public Response verifyUserCode() {+        MultivaluedMap<String, String> formData = httpRequest.getDecodedFormParameters();+        return verifyUserCode(formData.getFirst(OAUTH2_DEVICE_USER_CODE));+    }++    /**+     * Showing the result of verification process for OAuth 2.0 Device Authorization Grant. This outputs login success or+     * failure messages.+     *+     * @param error+     * @return+     */+    @Path(""status"")+    @GET+    public Response status(@QueryParam(""error"") String error) {+        if (!StringUtil.isNullOrEmpty(error)) {+            String message;+            switch (error) {+                case OAuthErrorException.ACCESS_DENIED:+                    // cased by CANCELLED_BY_USER or CONSENT_DENIED:+                    message = Messages.OAUTH2_DEVICE_CONSENT_DENIED;+                    break;+                case OAuthErrorException.EXPIRED_TOKEN:+                    message = Messages.OAUTH2_DEVICE_EXPIRED_USER_CODE;+                    break;+                default:+                    message = Messages.OAUTH2_DEVICE_VERIFICATION_FAILED;+            }+            LoginFormsProvider forms = session.getProvider(LoginFormsProvider.class);+            String restartUri = DeviceGrantType.oauth2DeviceVerificationUrl(session.getContext().getUri())+                .build(realm.getName()).toString();+            return forms.setAttribute(""messageHeader"", forms.getMessage(Messages.OAUTH2_DEVICE_VERIFICATION_FAILED_HEADER))+                .setAttribute(Constants.TEMPLATE_ATTR_ACTION_URI, restartUri).setError(message).createInfoPage();+        } else {+            LoginFormsProvider forms = session.getProvider(LoginFormsProvider.class);+            return forms.setAttribute(""messageHeader"", forms.getMessage(Messages.OAUTH2_DEVICE_VERIFICATION_COMPLETE_HEADER))+                .setAttribute(Constants.SKIP_LINK, true).setSuccess(Messages.OAUTH2_DEVICE_VERIFICATION_COMPLETE)+                .createInfoPage();+        }+    }++    private Response createVerificationPage(String errorMessage, AuthenticationSessionModel authenticationSession) {+        String execution = AuthenticatedClientSessionModel.Action.USER_CODE_VERIFICATION.name();++        ClientSessionCode<AuthenticationSessionModel> accessCode = new ClientSessionCode<>(session, realm,+            authenticationSession);+        authenticationSession.getParentSession().setTimestamp(Time.currentTime());++        accessCode.setAction(AuthenticationSessionModel.Action.USER_CODE_VERIFICATION.name());+        authenticationSession.setAuthNote(AuthenticationProcessor.CURRENT_AUTHENTICATION_EXECUTION, execution);++        LoginFormsProvider provider = session.getProvider(LoginFormsProvider.class)+            .setAuthenticationSession(authenticationSession).setExecution(execution)+            .setClientSessionCode(accessCode.getOrGenerateCode());++        if (errorMessage != null) {+            provider = provider.setError(errorMessage);+        }++        return provider.createOAuth2DeviceVerifyUserCodePage();+    }++    public Response processVerification(AuthenticationSessionModel authenticationSession, String userCode) {+        if (userCode == null) {+            event.error(Errors.INVALID_OAUTH2_USER_CODE);+            return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+        }++        // Format inputted user code+        OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+        String formattedUserCode = userCodeProvider.format(userCode);++        // Find the token from store+        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        OAuth2DeviceCodeModel deviceCodeModel = store.getByUserCode(realm, formattedUserCode);+        if (deviceCodeModel == null) {+            event.error(Errors.INVALID_OAUTH2_USER_CODE);+            return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+        }++        int expiresIn = deviceCodeModel.getExpiration() - Time.currentTime();+        if (expiresIn < 0) {+            event.error(Errors.EXPIRED_OAUTH2_USER_CODE);+            return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+        }++        // Verification OK+        authenticationSession.setClientNote(DeviceGrantType.OAUTH2_DEVICE_VERIFIED_USER_CODE, formattedUserCode);++        // Event logging for the verification+        event.client(deviceCodeModel.getClientId()).detail(Details.SCOPE, deviceCodeModel.getScope()).success();++        OIDCLoginProtocol protocol = new OIDCLoginProtocol(session, realm, session.getContext().getUri(), headers, event);+        return handleBrowserAuthenticationRequest(authenticationSession, protocol, false, true);+    }++    @Override+    public Object getResource() {+        return this;+    }++    @Override+    public void close() {++    }++    private ClientModel authenticateClient() {+        // https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15#section-3.1+        // The spec says ""The client authentication requirements of Section 3.2.1 of [RFC6749]+        // apply to requests on this endpoint"".+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);+        ClientModel client = clientAuth.getClient();++        if (client == null) {+            event.error(Errors.INVALID_REQUEST);+            throw new ErrorPageException(session, null, Response.Status.BAD_REQUEST, Messages.MISSING_PARAMETER,+                OIDCLoginProtocol.CLIENT_ID_PARAM);+        }++        checkClient(client.getClientId(), null);++        return client;+    }++    private ClientModel checkClient(String clientId, AuthenticationSessionModel authenticationSession) {","There is big amount of duplicated code needed to handle client verification. Isn't it possible to re-use some basic checks (EG. call to client authentication, checking if client enabled, if OIDC login protocol, if bearer-only etc)? For example `AuthorizationEndpoint.checkClient` already uses lots of same verifications . Will it be better if DeviceEndpoint inherits from AuthorizationEndpoint and calls `super.checkClient` with possibly some more checks added specific to device flow? Like for example call to `client.isOAuth2DeviceAuthorizationGrantEnabled()` , which (if I am not missing something) is the only check specific to deviceFlow.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590278879,2021-03-09T11:49:24Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanOAuth2DeviceTokenStoreProvider.java,"@@ -0,0 +1,241 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.sessions.infinispan;++import org.infinispan.client.hotrod.exceptions.HotRodClientException;+import org.infinispan.commons.api.BasicCache;+import org.jboss.logging.Logger;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.sessions.infinispan.entities.ActionTokenValueEntity;++import java.util.concurrent.TimeUnit;+import java.util.function.Supplier;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class InfinispanOAuth2DeviceTokenStoreProvider implements OAuth2DeviceTokenStoreProvider {++    public static final Logger logger = Logger.getLogger(InfinispanOAuth2DeviceTokenStoreProvider.class);++    private final Supplier<BasicCache<String, ActionTokenValueEntity>> codeCache;+    private final KeycloakSession session;++    public InfinispanOAuth2DeviceTokenStoreProvider(KeycloakSession session, Supplier<BasicCache<String, ActionTokenValueEntity>> actionKeyCache) {+        this.session = session;+        this.codeCache = actionKeyCache;+    }++    @Override+    public OAuth2DeviceCodeModel getByDeviceCode(RealmModel realm, String deviceCode) {+        try {+            BasicCache<String, ActionTokenValueEntity> cache = codeCache.get();+            ActionTokenValueEntity existing = cache.get(OAuth2DeviceCodeModel.createKey(realm, deviceCode));","There are some side-effects of having long keys for infinispan caches.I wonder that one possible improvement to this is, that the realm UUID is not added to the key of the infinispan entries. Instead of this, realmId would be added as the field in the entity classes and all the lookup methods will programatically check if the realmId matches with the ""realm"" given as an argument to this method. This applies probably to all entities used by this class (not just deviceEntity, but also to userEntity and ""polling"" entity).",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7839,590386407,2021-03-09T13:52:47Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/PermissionsTest.java,"@@ -48,12 +53,17 @@      @Test     public void manageAccountRoleRequired() {-        // remove the default role from test user+        // remove the default role from test user ACCOUNT_MANAGEMENT_CLIENT_ID+        List<RoleRepresentation> rolesToRemove = new ArrayList<>();         String accountClientId = testRealmResource().clients().findByClientId(ACCOUNT_MANAGEMENT_CLIENT_ID).get(0).getId();-        RoleScopeResource roleScopes = testUserResource().roles().clientLevel(accountClientId);-        roleScopes.remove(roleScopes.listAll().stream()-                .filter(r -> MANAGE_ACCOUNT.equals(r.getName()))-                .collect(Collectors.toList()));++        testRealmResource().roles()+                .get(""default-roles-test"")+                .getClientRoleComposites(accountClientId)+                .forEach((role) -> {if(role.getName().equals(MANAGE_ACCOUNT)) { rolesToRemove.add(role);}});++        testRealmResource().roles()+                .get(""default-roles-test"").deleteComposites(rolesToRemove);","Currently this is no problem, but in case this class contains more tests in the future, we would need to cleanup all changes we did in this test. There is a mechanism accessible by `getCleanup()`. It is also possible to little bit refactor working with the stream of roles. We could have something like this:```java        private static final String DEFAULT_ROLE_NAME = ""default-roles-"" + TEST;...        // remove the default role from test user ACCOUNT_MANAGEMENT_CLIENT_ID        String accountClientId = testRealmResource().clients().findByClientId(ACCOUNT_MANAGEMENT_CLIENT_ID).get(0).getId();        List<RoleRepresentation> rolesToRemove = testRealmResource().roles()                .get(DEFAULT_ROLE_NAME)                .getClientRoleComposites(accountClientId).stream()                .filter(role -> role.getName().equals(MANAGE_ACCOUNT))                .collect(Collectors.toList());                testRealmResource().roles().get(DEFAULT_ROLE_NAME).deleteComposites(rolesToRemove);                // Revert changes after test        getCleanup().addCleanup((Runnable) () -> testRealmResource().roles().get(DEFAULT_ROLE_NAME).addComposites(rolesToRemove));```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7731,590397398,2021-03-09T14:06:05Z,services/src/main/java/org/keycloak/protocol/oidc/grants/device/endpoints/DeviceEndpoint.java,"@@ -0,0 +1,488 @@+/*+ * Copyright 2019 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.grants.device.endpoints;++import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.authentication.AuthenticationProcessor;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.Time;+import org.keycloak.constants.AdapterConstants;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.OAuth2DeviceUserCodeProvider;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.SystemClientUtil;+import org.keycloak.protocol.AuthorizationEndpointBase;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequestParserProcessor;+import org.keycloak.protocol.oidc.grants.device.DeviceGrantType;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.representations.OAuth2DeviceAuthorizationResponse;+import org.keycloak.saml.common.util.StringUtil;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.ErrorPageException;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.Urls;+import org.keycloak.services.managers.AuthenticationManager;+import org.keycloak.services.managers.ClientSessionCode;+import org.keycloak.services.messages.Messages;+import org.keycloak.services.resource.RealmResourceProvider;+import org.keycloak.services.resources.Cors;+import org.keycloak.services.resources.SessionCodeChecks;+import org.keycloak.services.util.CacheControlUtil;+import org.keycloak.sessions.AuthenticationSessionModel;+import org.keycloak.util.JsonSerialization;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.Consumes;+import javax.ws.rs.GET;+import javax.ws.rs.HttpMethod;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.QueryParam;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import static org.keycloak.protocol.oidc.endpoints.AuthorizationEndpoint.LOGIN_SESSION_NOTE_ADDITIONAL_REQ_PARAMS_PREFIX;+import static org.keycloak.protocol.oidc.grants.device.DeviceGrantType.OAUTH2_DEVICE_USER_CODE;+import static org.keycloak.protocol.oidc.grants.device.DeviceGrantType.OAUTH2_USER_CODE_VERIFY;+import static org.keycloak.services.resources.LoginActionsService.SESSION_CODE;++/**+ * @author <a href=""mailto:h2-wada@nri.co.jp"">Hiroyuki Wada</a>+ */+public class DeviceEndpoint extends AuthorizationEndpointBase implements RealmResourceProvider {++    protected static final Logger logger = Logger.getLogger(DeviceEndpoint.class);++    protected Cors cors;++    public DeviceEndpoint(RealmModel realm, EventBuilder event) {+        super(realm, event);+    }++    /**+     * Handles device authorization requests.+     *+     * @return the device authorization response.+     */+    @Path(""/auth"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response handleDeviceRequest() {+        logger.trace(""Processing @POST request"");+        cors = Cors.add(httpRequest).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);+        event.event(EventType.OAUTH2_DEVICE_AUTH);++        checkSsl();+        checkRealm();++        ClientModel client = authenticateClient();++        AuthorizationEndpointRequest request = AuthorizationEndpointRequestParserProcessor.parseRequest(event, session, client,+            httpRequest.getDecodedFormParameters());++        if (!TokenUtil.isOIDCRequest(request.getScope())) {+            ServicesLogger.LOGGER.oidcScopeMissing();+        }++        createAuthenticationSession(client, request);++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();++        if (!client.isOAuth2DeviceAuthorizationGrantEnabled()) {+            event.error(Errors.NOT_ALLOWED);+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT,+                ""Client not allowed for OAuth 2.0 Device Authorization Grant"", Response.Status.BAD_REQUEST);+        }++        int expiresIn = realm.getOAuth2DeviceConfig().getLifespan(client);+        int interval = realm.getOAuth2DeviceConfig().getPoolingInterval(client);++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+            Base64Url.encode(KeycloakModelUtils.generateSecret()), request.getScope(), request.getNonce(), expiresIn, interval,+            request.getAdditionalReqParams());+        OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+        String secret = userCodeProvider.generate();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(), secret);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + interval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        store.put(deviceCode, userCode, lifespanSeconds);++        try {+            String deviceUrl = DeviceGrantType.oauth2DeviceVerificationUrl(session.getContext().getUri()).build(realm.getName())+                .toString();++            OAuth2DeviceAuthorizationResponse response = new OAuth2DeviceAuthorizationResponse();+            response.setDeviceCode(deviceCode.getDeviceCode());+            response.setUserCode(userCodeProvider.display(secret));+            response.setExpiresIn(expiresIn);+            response.setInterval(interval);+            response.setVerificationUri(deviceUrl);+            response.setVerificationUriComplete(deviceUrl + ""?user_code="" + response.getUserCode());++            return Response.ok(JsonSerialization.writeValueAsBytes(response)).type(MediaType.APPLICATION_JSON_TYPE).build();+        } catch (Exception e) {+            throw new RuntimeException(""Error creating OAuth 2.0 Device Authorization Response."", e);+        }+    }++    /**+     * This endpoint is used by end-users to start the flow to authorize a device.+     *+     * @param userCode the user code to authorize+     * @return+     */+    @GET+    public Response verifyUserCode(@QueryParam(""user_code"") String userCode) {+        event.event(EventType.OAUTH2_DEVICE_VERIFY_USER_CODE);++        checkSsl();+        checkRealm();++        // So back button doesn't work+        CacheControlUtil.noBackButtonCacheControlHeader();++        AuthenticationSessionModel authenticationSession = null;++        // try to recover the authentication session in case the user is pushing the code+        if (HttpMethod.POST.equalsIgnoreCase(httpRequest.getHttpMethod())) {+            String code = httpRequest.getDecodedFormParameters().getFirst(SESSION_CODE);+            String tabId = session.getContext().getUri().getQueryParameters().getFirst(Constants.TAB_ID);++            String systemClientId = SystemClientUtil.getSystemClient(realm).getClientId();++            SessionCodeChecks checks = checksForCode(null, code, null, systemClientId, tabId, OAUTH2_USER_CODE_VERIFY);++            if (!checks.verifyActiveAndValidAction(AuthenticationSessionModel.Action.USER_CODE_VERIFICATION.name(),+                ClientSessionCode.ActionType.LOGIN)) {+                return checks.getResponse();+            }++            authenticationSession = checks.getAuthenticationSession();+        }++        // code is not known, we can infer the client neither. ask the user to provide the code.+        if (StringUtil.isNullOrEmpty(userCode)) {+            ClientModel client = SystemClientUtil.getSystemClient(realm);++            if (authenticationSession == null) {+                authenticationSession = createAuthenticationSession(client);+            }++            return createVerificationPage(null, authenticationSession);+        } else {+            // code exists, probably due to using a verification_uri_complete. Start the authentication considering the client+            // that started the flow.+            OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+            OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+            String formattedUserCode = userCodeProvider.format(userCode);+            OAuth2DeviceCodeModel deviceCode = store.getByUserCode(realm, formattedUserCode);++            if (deviceCode == null) {+                event.error(Errors.INVALID_OAUTH2_USER_CODE);+                return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+            }++            ClientModel client = realm.getClientByClientId(deviceCode.getClientId());++            authenticationSession = createAuthenticationSession(client);++            if (deviceCode.isExpired()) {+                event.error(Errors.INVALID_OAUTH2_USER_CODE);+                return createVerificationPage(Messages.OAUTH2_DEVICE_EXPIRED_USER_CODE, authenticationSession);+            }++            return processVerification(authenticationSession, userCode);+        }+    }++    /**+     * Verifies the code provided by the end-user and start the authentication.+     *+     * @return+     */+    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    public Response verifyUserCode() {+        MultivaluedMap<String, String> formData = httpRequest.getDecodedFormParameters();+        return verifyUserCode(formData.getFirst(OAUTH2_DEVICE_USER_CODE));+    }++    /**+     * Showing the result of verification process for OAuth 2.0 Device Authorization Grant. This outputs login success or+     * failure messages.+     *+     * @param error+     * @return+     */+    @Path(""status"")+    @GET+    public Response status(@QueryParam(""error"") String error) {+        if (!StringUtil.isNullOrEmpty(error)) {+            String message;+            switch (error) {+                case OAuthErrorException.ACCESS_DENIED:+                    // cased by CANCELLED_BY_USER or CONSENT_DENIED:+                    message = Messages.OAUTH2_DEVICE_CONSENT_DENIED;+                    break;+                case OAuthErrorException.EXPIRED_TOKEN:+                    message = Messages.OAUTH2_DEVICE_EXPIRED_USER_CODE;+                    break;+                default:+                    message = Messages.OAUTH2_DEVICE_VERIFICATION_FAILED;+            }+            LoginFormsProvider forms = session.getProvider(LoginFormsProvider.class);+            String restartUri = DeviceGrantType.oauth2DeviceVerificationUrl(session.getContext().getUri())+                .build(realm.getName()).toString();+            return forms.setAttribute(""messageHeader"", forms.getMessage(Messages.OAUTH2_DEVICE_VERIFICATION_FAILED_HEADER))+                .setAttribute(Constants.TEMPLATE_ATTR_ACTION_URI, restartUri).setError(message).createInfoPage();+        } else {+            LoginFormsProvider forms = session.getProvider(LoginFormsProvider.class);+            return forms.setAttribute(""messageHeader"", forms.getMessage(Messages.OAUTH2_DEVICE_VERIFICATION_COMPLETE_HEADER))+                .setAttribute(Constants.SKIP_LINK, true).setSuccess(Messages.OAUTH2_DEVICE_VERIFICATION_COMPLETE)+                .createInfoPage();+        }+    }++    private Response createVerificationPage(String errorMessage, AuthenticationSessionModel authenticationSession) {+        String execution = AuthenticatedClientSessionModel.Action.USER_CODE_VERIFICATION.name();++        ClientSessionCode<AuthenticationSessionModel> accessCode = new ClientSessionCode<>(session, realm,+            authenticationSession);+        authenticationSession.getParentSession().setTimestamp(Time.currentTime());++        accessCode.setAction(AuthenticationSessionModel.Action.USER_CODE_VERIFICATION.name());+        authenticationSession.setAuthNote(AuthenticationProcessor.CURRENT_AUTHENTICATION_EXECUTION, execution);++        LoginFormsProvider provider = session.getProvider(LoginFormsProvider.class)+            .setAuthenticationSession(authenticationSession).setExecution(execution)+            .setClientSessionCode(accessCode.getOrGenerateCode());++        if (errorMessage != null) {+            provider = provider.setError(errorMessage);+        }++        return provider.createOAuth2DeviceVerifyUserCodePage();+    }++    public Response processVerification(AuthenticationSessionModel authenticationSession, String userCode) {+        if (userCode == null) {+            event.error(Errors.INVALID_OAUTH2_USER_CODE);+            return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+        }++        // Format inputted user code+        OAuth2DeviceUserCodeProvider userCodeProvider = session.getProvider(OAuth2DeviceUserCodeProvider.class);+        String formattedUserCode = userCodeProvider.format(userCode);++        // Find the token from store+        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);+        OAuth2DeviceCodeModel deviceCodeModel = store.getByUserCode(realm, formattedUserCode);+        if (deviceCodeModel == null) {+            event.error(Errors.INVALID_OAUTH2_USER_CODE);+            return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+        }++        int expiresIn = deviceCodeModel.getExpiration() - Time.currentTime();+        if (expiresIn < 0) {+            event.error(Errors.EXPIRED_OAUTH2_USER_CODE);+            return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE, authenticationSession);+        }++        // Verification OK+        authenticationSession.setClientNote(DeviceGrantType.OAUTH2_DEVICE_VERIFIED_USER_CODE, formattedUserCode);++        // Event logging for the verification+        event.client(deviceCodeModel.getClientId()).detail(Details.SCOPE, deviceCodeModel.getScope()).success();++        OIDCLoginProtocol protocol = new OIDCLoginProtocol(session, realm, session.getContext().getUri(), headers, event);+        return handleBrowserAuthenticationRequest(authenticationSession, protocol, false, true);+    }++    @Override+    public Object getResource() {+        return this;+    }++    @Override+    public void close() {++    }++    private ClientModel authenticateClient() {+        // https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15#section-3.1+        // The spec says ""The client authentication requirements of Section 3.2.1 of [RFC6749]+        // apply to requests on this endpoint"".+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);+        ClientModel client = clientAuth.getClient();++        if (client == null) {+            event.error(Errors.INVALID_REQUEST);+            throw new ErrorPageException(session, null, Response.Status.BAD_REQUEST, Messages.MISSING_PARAMETER,+                OIDCLoginProtocol.CLIENT_ID_PARAM);+        }++        checkClient(client.getClientId(), null);++        return client;+    }++    private ClientModel checkClient(String clientId, AuthenticationSessionModel authenticationSession) {","Makes sense. As we have similar duplication in other places, refactoring should probably consider them too.I don't see a problem in re-using some validations from there, but I won't push for this in this PR too.We are trying to keep device flow-related code as much as possible in a single place. The idea is to look at the changes here to find gaps and improve how people can create extensions without having to touch different parts and duplicate code. For instance, from this PR you have that:* We need a GrantType SPI (there are some initial discussions around it)* We need to provide an SPI for extending the protocol API* We need to provide ways to extend/re-use code from authorization and token endpointsMy point being, that we should think about this more carefully instead of extending what was not carefully thought for being extended.I think the way we are doing changes here will help a lot to discuss how we should be dealing with custom grant types and flows.",
16761934,lscorcia,https://api.github.com/repos/keycloak/keycloak/pulls/7838,591862489,2021-03-10T20:52:00Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/IdentityProviderAuthenticator.java,"@@ -58,6 +59,16 @@ public void authenticate(AuthenticationFlowContext context) {                 redirect(context, providerId);             }         } else if (context.getAuthenticatorConfig() != null && context.getAuthenticatorConfig().getConfig().containsKey(IdentityProviderAuthenticatorFactory.DEFAULT_PROVIDER)) {+            if (context.getForwardedErrorMessage() != null)+            {+                LOG.infof(""Should redirect to remote IdP but forwardedError has value '%s', redirecting to error page"", context.getForwardedErrorMessage());++                LoginFormsProvider forms = context.getSession().getProvider(LoginFormsProvider.class).setAuthenticationSession(context.getAuthenticationSession());+                forms.addError(context.getForwardedErrorMessage());+                context.forceChallenge(forms.createErrorPage(Response.Status.BAD_REQUEST));","I agree your proposal is better, however after trying it seems that the `context.challenge` call the control is immediately passed to the challenge (error) page and it never gets a chance to reach the forms authenticator.I have also tried replacing this code with a simple `context.attempted()`, when ALTERNATIVE this actually redirects to the forms authenticator and shows the error message, but when REQUIRED it goes directly to the ""Invalid username or password"" screen and does not show the forwarded error. Maybe the issue is that forwarded messages are lost when the flow ends without any successful execution? Do you know why or if that's by design?EDIT: I've been able to get the desired behavior with the following code but it feels a bit clunky:```if (context.getForwardedErrorMessage() != null){  LOG.infof(""Should redirect to remote IdP but forwardedError has value '%s', skipping this authenticator..."", context.getForwardedErrorMessage());  if (context.getExecution().getRequirement() == Requirement.REQUIRED) {    LoginFormsProvider forms = context.getSession().getProvider(LoginFormsProvider.class).setAuthenticationSession(context.getAuthenticationSession());    forms.addError(context.getForwardedErrorMessage());    context.challenge(forms.createErrorPage(Response.Status.BAD_REQUEST));  }  else    context.attempted();  return;}```",
16761934,lscorcia,https://api.github.com/repos/keycloak/keycloak/pulls/7838,592308855,2021-03-11T12:10:59Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/IdentityProviderAuthenticator.java,"@@ -58,6 +59,16 @@ public void authenticate(AuthenticationFlowContext context) {                 redirect(context, providerId);             }         } else if (context.getAuthenticatorConfig() != null && context.getAuthenticatorConfig().getConfig().containsKey(IdentityProviderAuthenticatorFactory.DEFAULT_PROVIDER)) {+            if (context.getForwardedErrorMessage() != null)+            {+                LOG.infof(""Should redirect to remote IdP but forwardedError has value '%s', redirecting to error page"", context.getForwardedErrorMessage());++                LoginFormsProvider forms = context.getSession().getProvider(LoginFormsProvider.class).setAuthenticationSession(context.getAuthenticationSession());+                forms.addError(context.getForwardedErrorMessage());+                context.forceChallenge(forms.createErrorPage(Response.Status.BAD_REQUEST));","Yep, the tests are always the hardest part. I still have no idea how to setup the realms and config, usually I just go look for some test similar to the one I need and start to tweak, but it takes ages. Will try anyway! :)Regarding the .challenge issue, I think it's because the flow executes the challenge with the same priority of the authenticator, and the IdP auth has a greater priority than the forms auth. I'll check if I can change the challenge priority. Any suggestions welcome, and thanks for reviewing this!",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,592980028,2021-03-12T08:08:15Z,core/src/main/java/org/keycloak/representations/idm/UserRepresentation.java,"@@ -287,4 +288,34 @@ public void setDisableableCredentialTypes(Set<String> disableableCredentialTypes     public void setAccess(Map<String, Boolean> access) {         this.access = access;     }++    public Map<String, List<String>> toAttributes() {+        Map<String, List<String>> attrs = new HashMap<>();++        if (getAttributes() != null) attrs.putAll(getAttributes());++        if (getUsername() != null)+            attrs.put(""username"", Collections.singletonList(getUsername()));+        else+            attrs.remove(""username"");++        if (getEmail() != null)+            attrs.put(""email"", Collections.singletonList(getEmail()));+        else+            attrs.remove(""email"");++        if (getUsername() != null)","This looks duplicate, username is filled into attrs at line 297 already",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,592980322,2021-03-12T08:08:49Z,core/src/main/java/org/keycloak/representations/idm/UserRepresentation.java,"@@ -287,4 +288,34 @@ public void setDisableableCredentialTypes(Set<String> disableableCredentialTypes     public void setAccess(Map<String, Boolean> access) {         this.access = access;     }++    public Map<String, List<String>> toAttributes() {+        Map<String, List<String>> attrs = new HashMap<>();++        if (getAttributes() != null) attrs.putAll(getAttributes());++        if (getUsername() != null)+            attrs.put(""username"", Collections.singletonList(getUsername()));+        else+            attrs.remove(""username"");++        if (getEmail() != null)+            attrs.put(""email"", Collections.singletonList(getEmail()));+        else+            attrs.remove(""email"");++        if (getUsername() != null)+            attrs.put(""username"", Collections.singletonList(getUsername()));++        if (getLastName() != null)+            attrs.put(""lastName"", Collections.singletonList(getLastName()));++        if (getFirstName() != null)+            attrs.put(""firstName"", Collections.singletonList(getFirstName()));++        if (getEmail() != null)","This looks duplicate, email is filled into attrs at line 302 already",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593011774,2021-03-12T09:02:01Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfile.java,"@@ -17,16 +17,72 @@  package org.keycloak.userprofile; +import java.util.function.BiConsumer;++import org.keycloak.models.UserModel;+ /**- * Abstraction, which allows to update the user in various contexts (Required action of already existing user, or first identity provider- * login when user doesn't yet exists in Keycloak DB)+ * <p>An interface providing as an entry point for managing users.+ *+ * <p>A {@code UserProfile} provides a manageable view for user information that also takes into account the context where it is being used.+ * The context represents the different places in Keycloak where users are created, updated, or validated.+ * Examples of contexts are: managing users through the Admin API, or through the Account API.+ *+ * <p>By taking the context into account, the state and behavior of {@link UserProfile} instances depend on the context they+ * are associated with, where validating, updating, creating, or obtaining representations of users is based on the configuration+ * and constraints associated with a context.  *+ * <p>A {@code UserProfile} instance can be obtained through the {@link UserProfileProvider}.+ *+ * @see UserProfileContext+ * @see UserProfileProvider  * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>  */ public interface UserProfile { -    String getId();+    /**+     * Validates the attributes associated with this instance.+     *+     * @throws ValidationException in case+     */+    void validate() throws ValidationException;++    /**+     * Creates a new {@link UserModel} based on the attributes associated with this instance.+     *+     * @throws ValidationException in case validation fails+     *+     * @return the {@link UserModel} instance created from this profile+     */+    UserModel create() throws ValidationException;++    /**+     * <p>Updates the {@link UserModel} associated with this instance. If no {@link UserModel} is associated with this instance, this operation has no effect.+     *+     * <p>Before updating the {@link UserModel}, this method first checks whether the {@link #validate()} method was previously+     * invoked. If not, the validation step is performed prior to updating the model.+     *+     * @param removeAttributes if attributes should be removed from the {@link UserModel} if they are not among the attributes associated with this instance.",boolean removeAttributes' parameter should not be here as UserProfile itself should encapsulate logic/decision for the attribute update. Caller context should be passed here so internal impl can decide what to do. We can probably change this later once we start to implement processing based on the configuration,
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593014522,2021-03-12T09:06:20Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfile.java,"@@ -17,16 +17,72 @@  package org.keycloak.userprofile; +import java.util.function.BiConsumer;++import org.keycloak.models.UserModel;+ /**- * Abstraction, which allows to update the user in various contexts (Required action of already existing user, or first identity provider- * login when user doesn't yet exists in Keycloak DB)+ * <p>An interface providing as an entry point for managing users.+ *+ * <p>A {@code UserProfile} provides a manageable view for user information that also takes into account the context where it is being used.+ * The context represents the different places in Keycloak where users are created, updated, or validated.+ * Examples of contexts are: managing users through the Admin API, or through the Account API.+ *+ * <p>By taking the context into account, the state and behavior of {@link UserProfile} instances depend on the context they+ * are associated with, where validating, updating, creating, or obtaining representations of users is based on the configuration+ * and constraints associated with a context.  *+ * <p>A {@code UserProfile} instance can be obtained through the {@link UserProfileProvider}.+ *+ * @see UserProfileContext+ * @see UserProfileProvider  * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>  */ public interface UserProfile { -    String getId();+    /**+     * Validates the attributes associated with this instance.+     *+     * @throws ValidationException in case+     */+    void validate() throws ValidationException;++    /**+     * Creates a new {@link UserModel} based on the attributes associated with this instance.+     *+     * @throws ValidationException in case validation fails+     *+     * @return the {@link UserModel} instance created from this profile+     */+    UserModel create() throws ValidationException;++    /**+     * <p>Updates the {@link UserModel} associated with this instance. If no {@link UserModel} is associated with this instance, this operation has no effect.+     *+     * <p>Before updating the {@link UserModel}, this method first checks whether the {@link #validate()} method was previously+     * invoked. If not, the validation step is performed prior to updating the model.+     *+     * @param removeAttributes if attributes should be removed from the {@link UserModel} if they are not among the attributes associated with this instance.+     * @param changeListener a set of one or more listeners to listen for attribute changes",It should be clearly documented what are these String and UserModel arguments passed into the listener and when exactly are they called. Documented either here or proper interface should be defined. Without the proper doc it is hard to use this feature.,
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593038735,2021-03-12T09:42:50Z,services/src/main/java/org/keycloak/authentication/forms/RegistrationProfile.java,"@@ -67,33 +64,37 @@ public void validate(org.keycloak.authentication.ValidationContext context) {          context.getEvent().detail(Details.REGISTER_METHOD, ""form""); -        UserProfileValidationResult result = forRegistrationProfile(context.getSession(), formData).validate();-        List<FormMessage> errors = Validation.getFormErrorsFromValidation(result);+        UserProfileProvider profileProvider = context.getSession().getProvider(UserProfileProvider.class);+        UserProfile profile = profileProvider.forValidation(UserProfileContext.REGISTRATION_PROFILE, formData);++        try {+            profile.validate();","In default flow this runs just after `RegistrationUserCreation` action is executed, so I believe this validation is duplicate and only loads server and complicates stuff without real reason. But I can investigate this and patch it once this PR is accepted.",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593044189,2021-03-12T09:50:55Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfile.java,"@@ -17,16 +17,72 @@  package org.keycloak.userprofile; +import java.util.function.BiConsumer;++import org.keycloak.models.UserModel;+ /**- * Abstraction, which allows to update the user in various contexts (Required action of already existing user, or first identity provider- * login when user doesn't yet exists in Keycloak DB)+ * <p>An interface providing as an entry point for managing users.+ *+ * <p>A {@code UserProfile} provides a manageable view for user information that also takes into account the context where it is being used.+ * The context represents the different places in Keycloak where users are created, updated, or validated.+ * Examples of contexts are: managing users through the Admin API, or through the Account API.+ *+ * <p>By taking the context into account, the state and behavior of {@link UserProfile} instances depend on the context they+ * are associated with, where validating, updating, creating, or obtaining representations of users is based on the configuration+ * and constraints associated with a context.  *+ * <p>A {@code UserProfile} instance can be obtained through the {@link UserProfileProvider}.+ *+ * @see UserProfileContext+ * @see UserProfileProvider  * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>  */ public interface UserProfile { -    String getId();+    /**+     * Validates the attributes associated with this instance.+     *+     * @throws ValidationException in case+     */+    void validate() throws ValidationException;++    /**+     * Creates a new {@link UserModel} based on the attributes associated with this instance.+     *+     * @throws ValidationException in case validation fails+     *+     * @return the {@link UserModel} instance created from this profile+     */+    UserModel create() throws ValidationException;++    /**+     * <p>Updates the {@link UserModel} associated with this instance. If no {@link UserModel} is associated with this instance, this operation has no effect.+     *+     * <p>Before updating the {@link UserModel}, this method first checks whether the {@link #validate()} method was previously+     * invoked. If not, the validation step is performed prior to updating the model.+     *+     * @param removeAttributes if attributes should be removed from the {@link UserModel} if they are not among the attributes associated with this instance.+     * @param changeListener a set of one or more listeners to listen for attribute changes","Looking at client code, this version of listeners leads to a bit horrible code there where you have to remember some old values before you call UserProfile methods to use them in listener if necessary. Listener should directly receive old and new values of the attribute to simply use them (UserModel can be pushed here also as listener can have some good use of it)",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593045633,2021-03-12T09:53:10Z,services/src/main/java/org/keycloak/authentication/requiredactions/UpdateProfile.java,"@@ -73,36 +72,34 @@ public void processAction(RequiredActionContext context) {         String oldFirstName = user.getFirstName();         String oldLastName = user.getLastName();         String oldEmail = user.getEmail();","As I commented in UserProfile already, these old values should be propagated into update listener by profile.update() not to be handled this way",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7731,593051016,2021-03-12T10:01:07Z,server-spi/src/main/java/org/keycloak/models/ClientModel.java,"@@ -199,6 +200,15 @@     boolean isServiceAccountsEnabled();     void setServiceAccountsEnabled(boolean serviceAccountsEnabled); +    default boolean isOAuth2DeviceAuthorizationGrantEnabled() {","I see there is still constant OAUTH2_DEVICE_AUTHORIZATION_GRANT_ENABLED on the ClientModel. Can this be removed from ClientModel?Actually, I figured that there is separate class OAuth2DeviceConfig added for all the properties related to device-grant. So probably it will be even better to remove the configuration from OIDCAdvancedConfigWrapper and move the configuration option into the OAuth2DeviceConfig class. That will be the cleanest approach IMO. WDYT?",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593051747,2021-03-12T10:02:20Z,services/src/main/java/org/keycloak/authentication/requiredactions/UpdateProfile.java,"@@ -73,36 +72,34 @@ public void processAction(RequiredActionContext context) {         String oldFirstName = user.getFirstName();         String oldLastName = user.getLastName();         String oldEmail = user.getEmail();-        UserProfileValidationResult result = forUpdateProfile(user, formData, context.getSession()).validate();-        final UserProfile updatedProfile = result.getProfile();-        List<FormMessage> errors = Validation.getFormErrorsFromValidation(result);+        UserProfileProvider provider = context.getSession().getProvider(UserProfileProvider.class);+        UserProfile profile = provider.forUpdate(UserProfileContext.UPDATE_PROFILE, formData, user);++        try {+            // backward compatibility with old account console where attributes are not removed if missing+            profile.update(false, (attributeName, userModel) -> {+                if (attributeName.equals(UserModel.FIRST_NAME)) {+                    event.detail(Details.PREVIOUS_FIRST_NAME, oldFirstName).detail(Details.UPDATED_FIRST_NAME, user.getFirstName());+                }+                if (attributeName.equals(UserModel.LAST_NAME)) {+                    event.detail(Details.PREVIOUS_LAST_NAME, oldLastName).detail(Details.UPDATED_LAST_NAME, user.getLastName());+                }+                if (attributeName.equals(UserModel.EMAIL)) {+                    user.setEmailVerified(false);",Maybe emailVerified shoudl be automatically set to false in UserProfile when email is changed to have this business logic at one place (calling context may be used to decide when to apply it and when not)? It is easy to forgot to implement this listener and then you can easily bring security problem (trusting email which was not verified in reality).,
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593056639,2021-03-12T10:10:16Z,services/src/main/java/org/keycloak/services/resources/admin/UserResource.java,"@@ -169,11 +167,13 @@ public Response updateUser(final UserRepresentation rep) {                 }             } -            Response response = validateUserProfile(user, rep, session);+            UserProfile profile = session.getProvider(UserProfileProvider.class).forUpdate(USER_RESOURCE, rep.toAttributes(), user);++            Response response = validateUserProfile(profile);             if (response != null) {                 return response;             }-            updateUserFromRep(user, rep, session, true);+            updateUserFromRep(profile, user, rep, session, true);","Do we really need separate validate and update methods here both calling UserProfile? I believe profile.update() performs validation first and throws validation exception, so one call should be enough",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593101802,2021-03-12T11:24:43Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfile.java,"@@ -17,16 +17,72 @@  package org.keycloak.userprofile; +import java.util.function.BiConsumer;++import org.keycloak.models.UserModel;+ /**- * Abstraction, which allows to update the user in various contexts (Required action of already existing user, or first identity provider- * login when user doesn't yet exists in Keycloak DB)+ * <p>An interface providing as an entry point for managing users.+ *+ * <p>A {@code UserProfile} provides a manageable view for user information that also takes into account the context where it is being used.+ * The context represents the different places in Keycloak where users are created, updated, or validated.+ * Examples of contexts are: managing users through the Admin API, or through the Account API.+ *+ * <p>By taking the context into account, the state and behavior of {@link UserProfile} instances depend on the context they+ * are associated with, where validating, updating, creating, or obtaining representations of users is based on the configuration+ * and constraints associated with a context.  *+ * <p>A {@code UserProfile} instance can be obtained through the {@link UserProfileProvider}.+ *+ * @see UserProfileContext+ * @see UserProfileProvider  * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>  */ public interface UserProfile { -    String getId();+    /**+     * Validates the attributes associated with this instance.+     *+     * @throws ValidationException in case+     */+    void validate() throws ValidationException;++    /**+     * Creates a new {@link UserModel} based on the attributes associated with this instance.+     *+     * @throws ValidationException in case validation fails+     *+     * @return the {@link UserModel} instance created from this profile+     */+    UserModel create() throws ValidationException;++    /**+     * <p>Updates the {@link UserModel} associated with this instance. If no {@link UserModel} is associated with this instance, this operation has no effect.+     *+     * <p>Before updating the {@link UserModel}, this method first checks whether the {@link #validate()} method was previously+     * invoked. If not, the validation step is performed prior to updating the model.+     *+     * @param removeAttributes if attributes should be removed from the {@link UserModel} if they are not among the attributes associated with this instance.","I agree. The only reason why I have that there is because of how our REST API works and for backward compatibility with the old console.Wr.t. to the Admin REST API, attributes are only removed if the attribute map was sent (either empty or not). In case it is null, we don't remove attributes at all. We can't make this decision without relying on this condition from the caller.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7846,593110792,2021-03-12T11:41:26Z,server-spi-private/src/main/java/org/keycloak/userprofile/UserProfile.java,"@@ -17,16 +17,72 @@  package org.keycloak.userprofile; +import java.util.function.BiConsumer;++import org.keycloak.models.UserModel;+ /**- * Abstraction, which allows to update the user in various contexts (Required action of already existing user, or first identity provider- * login when user doesn't yet exists in Keycloak DB)+ * <p>An interface providing as an entry point for managing users.+ *+ * <p>A {@code UserProfile} provides a manageable view for user information that also takes into account the context where it is being used.+ * The context represents the different places in Keycloak where users are created, updated, or validated.+ * Examples of contexts are: managing users through the Admin API, or through the Account API.+ *+ * <p>By taking the context into account, the state and behavior of {@link UserProfile} instances depend on the context they+ * are associated with, where validating, updating, creating, or obtaining representations of users is based on the configuration+ * and constraints associated with a context.  *+ * <p>A {@code UserProfile} instance can be obtained through the {@link UserProfileProvider}.+ *+ * @see UserProfileContext+ * @see UserProfileProvider  * @author <a href=""mailto:markus.till@bosch.io"">Markus Till</a>  */ public interface UserProfile { -    String getId();+    /**+     * Validates the attributes associated with this instance.+     *+     * @throws ValidationException in case+     */+    void validate() throws ValidationException;++    /**+     * Creates a new {@link UserModel} based on the attributes associated with this instance.+     *+     * @throws ValidationException in case validation fails+     *+     * @return the {@link UserModel} instance created from this profile+     */+    UserModel create() throws ValidationException;++    /**+     * <p>Updates the {@link UserModel} associated with this instance. If no {@link UserModel} is associated with this instance, this operation has no effect.+     *+     * <p>Before updating the {@link UserModel}, this method first checks whether the {@link #validate()} method was previously+     * invoked. If not, the validation step is performed prior to updating the model.+     *+     * @param removeAttributes if attributes should be removed from the {@link UserModel} if they are not among the attributes associated with this instance.+     * @param changeListener a set of one or more listeners to listen for attribute changes","The only reason why I've added those listeners was to keep the current code as is when callers are creating events based on changes.Ideally, I think we should manage events within the user profile. That is why I kept the same code as before but using this to listen for changes.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7842,594466708,2021-03-15T16:00:52Z,model/map/src/main/java/org/keycloak/models/map/realm/MapRealmProvider.java,"@@ -0,0 +1,469 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.realm;++import java.util.HashMap;+import java.util.Map;+import java.util.Objects;+import java.util.function.Function;+import java.util.stream.Stream;+import org.jboss.logging.Logger;+import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.GroupModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RealmModel.SearchableFields;+import org.keycloak.models.RealmProvider;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.common.StreamUtils;+import org.keycloak.models.map.common.StreamUtils.Pair;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.models.utils.KeycloakModelUtils;++public class MapRealmProvider implements RealmProvider {++    private static final Logger LOG = Logger.getLogger(MapRealmProvider.class);+    private final KeycloakSession session;+    final MapKeycloakTransaction<String, MapRealmEntity, RealmModel> tx;+    private final MapStorage<String, MapRealmEntity, RealmModel> realmStore;++    public MapRealmProvider(KeycloakSession session, MapStorage<String, MapRealmEntity, RealmModel> realmStore) {+        this.session = session;+        this.realmStore = realmStore;+        this.tx = new MapKeycloakTransaction<>(realmStore);+        session.getTransactionManager().enlist(tx);+    }++    private Function<MapRealmEntity, RealmModel> entityToAdapterFunc() {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller++        return origEntity -> new MapRealmAdapter(session, registerEntityForChanges(origEntity));","This doesn't need to be lambda since there is not realmId as the parameter. This method can be changed to `entityToAdapter`, that takes MapRealmEntity and returns RealmModel. Then we would have method reference instead of calling method that creates function.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,596010728,2021-03-17T13:22:57Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java,"@@ -0,0 +1,849 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserLoginFailureModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.utils.SessionTimeoutHelper;++import java.util.Collection;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.UUID;+import java.util.concurrent.ConcurrentHashMap;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import static org.keycloak.models.UserSessionModel.SessionPersistenceState.TRANSIENT;+import static org.keycloak.utils.StreamsUtil.paginatedStream;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProvider implements UserSessionProvider {++    private static final Logger LOG = Logger.getLogger(MapUserSessionProvider.class);+    private final KeycloakSession session;+    protected final MapKeycloakTransaction<UUID, MapUserSessionEntity, UserSessionModel> userSessionTx;+    protected final MapKeycloakTransaction<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionTx;+    protected final MapKeycloakTransaction<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureTx;+    private final MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private final MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;+    private final MapStorage<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureStore;++    /**+     * Storage for transient user sessions which lifespan is limited to one request.+     */+    private Map<UUID, MapUserSessionEntity> transientUserSessions = new HashMap<>();++    public MapUserSessionProvider(KeycloakSession session, MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore,+                                  MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore,+                                  MapStorage<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureStore) {+        this.session = session;+        this.userSessionStore = userSessionStore;+        this.clientSessionStore = clientSessionStore;+        this.userLoginFailureStore = userLoginFailureStore;+        userSessionTx = userSessionStore.createTransaction();+        clientSessionTx = clientSessionStore.createTransaction();+        userLoginFailureTx = userLoginFailureStore.createTransaction();++        session.getTransactionManager().enlistAfterCompletion(userSessionTx);+        session.getTransactionManager().enlistAfterCompletion(clientSessionTx);+        session.getTransactionManager().enlistAfterCompletion(userLoginFailureTx);+    }++    private Function<MapUserSessionEntity, UserSessionModel> userEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return (origEntity) -> new MapUserSessionAdapter(session, realm,+                Objects.equals(origEntity.getPersistenceState(), TRANSIENT) ? origEntity : registerEntityForChanges(origEntity)) {++            @Override+            public void removeAuthenticatedClientSessions(Collection<String> removedClientUUIDS) {+                removedClientUUIDS.stream().map(UUID::fromString).forEach(clientSessionTx::delete);++                removedClientUUIDS.forEach(entity::removeAuthenticatedClientSession);+            }+        };+    }++    private Function<MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientEntityToAdapterFunc(RealmModel realm,+                                                                                                                     ClientModel client,+                                                                                                                     UserSessionModel userSession) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapAuthenticatedClientSessionAdapter(session, realm, client, userSession, registerEntityForChanges(origEntity)) {+            @Override+            public void detachFromUserSession() {+                //userSession.removeAuthenticatedClientSessions(Collections.singleton(client.getId()));++                this.userSession = null;++                clientSessionTx.delete(entity.getId());+            }+        };+    }++    private Function<MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapUserLoginFailureAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapUserSessionEntity registerEntityForChanges(MapUserSessionEntity origEntity) {+        MapUserSessionEntity res = userSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userSessionTx.updateIfChanged(origEntity.getId(), res, MapUserSessionEntity::isUpdated);+        return res;+    }++    private MapAuthenticatedClientSessionEntity registerEntityForChanges(MapAuthenticatedClientSessionEntity origEntity) {+        MapAuthenticatedClientSessionEntity res = clientSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        clientSessionTx.updateIfChanged(origEntity.getId(), res, MapAuthenticatedClientSessionEntity::isUpdated);+        return res;+    }++    private MapUserLoginFailureEntity registerEntityForChanges(MapUserLoginFailureEntity origEntity) {+        MapUserLoginFailureEntity res = userLoginFailureTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userLoginFailureTx.updateIfChanged(origEntity.getId(), res, MapUserLoginFailureEntity::isUpdated);+        return res;+    }++    @Override+    public AuthenticatedClientSessionModel createClientSession(RealmModel realm, ClientModel client, UserSessionModel userSession) {+        MapAuthenticatedClientSessionEntity entity =+                new MapAuthenticatedClientSessionEntity(UUID.randomUUID(), realm.getId(), client.getId(), false);++        if (clientSessionTx.read(entity.getId()) != null) {+            throw new ModelDuplicateException(""Client session exists: "" + entity.getId());+        }++        LOG.tracef(""createClientSession(%s, %s, %s)%s"", realm, client, userSession, getShortStackTrace());++        clientSessionTx.create(entity.getId(), entity);++        MapUserSessionEntity userSessionEntity = getUserSessionById(UUID.fromString(userSession.getId()));+        userSessionEntity.addAuthenticatedClientSession(client.getId(), entity.getId());++        return clientEntityToAdapterFunc(realm, client, userSession).apply(entity);+    }++    @Override+    public AuthenticatedClientSessionModel getClientSession(UserSessionModel userSession, ClientModel client,+                                                            UUID clientSessionId, boolean offline) {+        Objects.requireNonNull(userSession, ""The provided user session cannot be null!"");+        Objects.requireNonNull(client, ""The provided client cannot be null!"");+        if (clientSessionId == null) {+            return null;+        }++        LOG.tracef(""getClientSession(%s, %s, %s, %s)%s"", userSession, client,+                clientSessionId, offline, getShortStackTrace());++        ModelCriteriaBuilder<AuthenticatedClientSessionModel> mcb = clientSessionStore.createCriteriaBuilder()+                .compare(AuthenticatedClientSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, clientSessionId)+                .compare(AuthenticatedClientSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.IS_OFFLINE, ModelCriteriaBuilder.Operator.EQ, offline);++        return clientSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> clientEntityToAdapterFunc(client.getRealm(), client, userSession).apply(entity))+                .findFirst()+                .orElse(null);+    }++    @Override+    public UserSessionModel createUserSession(RealmModel realm, UserModel user, String loginUsername, String ipAddress,+                                              String authMethod, boolean rememberMe, String brokerSessionId, String brokerUserId) {+        return createUserSession(null, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId,+                brokerUserId, UserSessionModel.SessionPersistenceState.PERSISTENT);+    }++    @Override+    public UserSessionModel createUserSession(String id, RealmModel realm, UserModel user, String loginUsername,+                                              String ipAddress, String authMethod, boolean rememberMe, String brokerSessionId,+                                              String brokerUserId, UserSessionModel.SessionPersistenceState persistenceState) {+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""createUserSession(%s, %s, %s, %s)%s"", id, realm, loginUsername, persistenceState, getShortStackTrace());++        MapUserSessionEntity entity = new MapUserSessionEntity(entityId, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId, brokerUserId, false);+        entity.setPersistenceState(persistenceState);++        if (Objects.equals(persistenceState, TRANSIENT)) {+            transientUserSessions.put(entityId, entity);+        } else {+            if (userSessionTx.read(entity.getId()) != null) {+                throw new ModelDuplicateException(""User session exists: "" + entity.getId());+            }++            userSessionTx.create(entity.getId(), entity);+        }++        UserSessionModel userSession = userEntityToAdapterFunc(realm).apply(entity);++        DeviceActivityManager.attachDevice(userSession, session);++        return userSession;+    }++    @Override+    public UserSessionModel getUserSession(RealmModel realm, String id) {+        Objects.requireNonNull(realm, ""The provided realm can't be null!"");++        UUID uuid = toUUID(id);+        if (uuid == null) {+            return null;+        }++        LOG.tracef(""getUserSession(%s, %s)%s"", realm, id, getShortStackTrace());++        MapUserSessionEntity userSessionEntity = transientUserSessions.get(uuid);+        if (userSessionEntity != null) {+            return userEntityToAdapterFunc(realm).apply(userSessionEntity);+        }++        // TODO examine why this is not working+        /*ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .or(+                    userSessionStore.createCriteriaBuilder().compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, UUID.fromString(id)),+                    userSessionStore.createCriteriaBuilder().compare(UserSessionModel.SearchableFields.CORRESPONDING_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, UUID.fromString(id))+                );*/+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, uuid);++        UserSessionModel userSessionModel = userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity))+                .findFirst()+                .orElse(null);++        if (userSessionModel == null) {+            mcb = realmAndOfflineCriteriaBuilder(realm, false)+                    .compare(UserSessionModel.SearchableFields.CORRESPONDING_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, uuid);+            return userSessionTx.getUpdatedNotRemoved(mcb)+                    .map(entity -> userEntityToAdapterFunc(realm).apply(entity))+                    .findFirst()+                    .orElse(null);+        }++        return userSessionModel;+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""getUserSessionsStream(%s, %s)%s"", realm, user, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity));+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getUserSessionsStream(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity));+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, ClientModel client,+                                                          Integer firstResult, Integer maxResults) {+        return paginatedStream(getUserSessionsStream(realm, client), firstResult, maxResults);+    }++    @Override+    public Stream<UserSessionModel> getUserSessionByBrokerUserIdStream(RealmModel realm, String brokerUserId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.BROKER_USER_ID, ModelCriteriaBuilder.Operator.EQ, brokerUserId);++        LOG.tracef(""getUserSessionByBrokerUserIdStream(%s, %s)%s"", realm, brokerUserId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity));+    }++    @Override+    public UserSessionModel getUserSessionByBrokerSessionId(RealmModel realm, String brokerSessionId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.BROKER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, brokerSessionId);++        LOG.tracef(""getUserSessionByBrokerSessionId(%s, %s)%s"", realm, brokerSessionId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity))+                .findFirst()+                .orElse(null);+    }++    @Override+    public UserSessionModel getUserSessionWithPredicate(RealmModel realm, String id, boolean offline,+                                                        Predicate<UserSessionModel> predicate) {+        LOG.tracef(""getUserSessionWithPredicate(%s, %s, %s)%s"", realm, id, offline, getShortStackTrace());++        Stream<UserSessionModel> userSessionEntityStream;+        if (offline) {+            userSessionEntityStream = getOfflineUserSessionEntityStream(realm, id)+                    .map(entity -> userEntityToAdapterFunc(realm).apply(entity));+        } else {+            UserSessionModel userSession = getUserSession(realm, id);+            userSessionEntityStream = userSession != null ? Stream.of(userSession) : Stream.empty();+        }++        return userSessionEntityStream+                .filter(predicate)+                .findFirst()+                .orElse(null);+    }++    @Override+    public long getActiveUserSessions(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getActiveUserSessions(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb).count();+    }++    @Override+    public Map<String, Long> getActiveClientSessionStats(RealmModel realm, boolean offline) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, offline);++        LOG.tracef(""getActiveClientSessionStats(%s, %s)%s"", realm, offline, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(MapUserSessionEntity::getAuthenticatedClientSessions)+                .map(Map::keySet)+                .flatMap(Collection::stream)+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));+    }++    @Override+    public void removeUserSession(RealmModel realm, UserSessionModel session) {+        Objects.requireNonNull(session, ""The provided user session can't be null!"");++        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, UUID.fromString(session.getId()));++        LOG.tracef(""removeUserSession(%s, %s)%s"", realm, session, getShortStackTrace());++        userSessionTx.getUpdatedNotRemoved(mcb).forEach(userSession -> {+            userSession.getAuthenticatedClientSessions().values().stream().forEach(clientSessionTx::delete);+            userSessionTx.delete(userSession.getId());+        });++    }++    @Override+    public void removeUserSessions(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = userSessionStore.createCriteriaBuilder()+                .compare(UserSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""removeUserSessions(%s, %s)%s"", realm, user, getShortStackTrace());++        userSessionTx.getUpdatedNotRemoved(mcb).forEach(userSession -> {+            userSession.getAuthenticatedClientSessions().values().stream().forEach(clientSessionTx::delete);+            userSessionTx.delete(userSession.getId());+        });+    }++    @Override+    public void removeAllExpired() {+        session.realms().getRealmsStream().forEach(this::removeExpired);+    }++    @Override+    public void removeExpired(RealmModel realm) {+        int currentTime = Time.currentTime();+        int expired = currentTime - realm.getSsoSessionMaxLifespan();+        int expiredRefresh = currentTime - realm.getSsoSessionIdleTimeout() - SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;+        int expiredRememberMe = currentTime - (realm.getSsoSessionMaxLifespanRememberMe() > 0 ?+                realm.getSsoSessionMaxLifespanRememberMe() : realm.getSsoSessionMaxLifespan());+        int expiredRefreshRememberMe = currentTime - (realm.getSsoSessionIdleTimeoutRememberMe() > 0 ?+                realm.getSsoSessionIdleTimeoutRememberMe() : realm.getSsoSessionIdleTimeout()) -+                SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;+        int expiredOffline = currentTime - realm.getOfflineSessionIdleTimeout() - SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;+        int clientExpired = Math.min(expired, expiredRememberMe);++        Predicate<MapUserSessionEntity> filterExpired = (entity) -> {+            if (entity.isRememberMe()) {+                if (entity.getStarted() > expiredRememberMe && entity.getLastSessionRefresh() > expiredRefreshRememberMe) {+                    return false;+                }+            }+            else {+                if (entity.getStarted() > expired && entity.getLastSessionRefresh() > expiredRefresh) {+                    return false;+                }+            }++            if (entity.getLastSessionRefresh() > expiredRefresh) {+                return false;+            }+            return true;+        };++        Predicate<MapUserSessionEntity> filterExpiredOffline = (entity) -> !(entity.getLastSessionRefresh() > expiredOffline);+        Predicate<MapAuthenticatedClientSessionEntity> filterClientExpired = (entity) -> !(entity.getTimestamp() > clientExpired);+        Predicate<MapAuthenticatedClientSessionEntity> filterClientExpiredOffline = (entity) -> !(entity.getTimestamp() > expiredOffline);++        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false);+        userSessionTx.getUpdatedNotRemoved(mcb)+            .filter(filterExpired)+            .forEach(userEntity -> {+                userEntity.getAuthenticatedClientSessions().values()+                        .forEach(clientSessionId -> {+                            LOG.debugf(""Deleting client session %s from expired user sessions %s"", clientSessionId, userEntity.getId());+                            clientSessionTx.delete(clientSessionId);+                        });+                userEntity.clearAuthenticatedClientSessions();+                LOG.debugf(""Deleting expired user sessions %s"", userEntity.getId());+                userSessionTx.delete(userEntity.getId());+            });++        mcb = realmAndOfflineCriteriaBuilder(realm, true);+        userSessionTx.getUpdatedNotRemoved(mcb)+            .filter(filterExpiredOffline)+            .forEach(userEntity -> {+                userEntity.getAuthenticatedClientSessions().values()+                        .forEach(clientSessionId -> clientSessionTx.delete(clientSessionId));+                userEntity.clearAuthenticatedClientSessions();+                LOG.debugf(""Deleting expired offline user sessions %s"", userEntity.getId());+                userSessionTx.delete(userEntity.getId());+            });++        mcb = realmAndOfflineCriteriaBuilder(realm, false);+        List<MapUserSessionEntity> userSessions = userSessionTx.getUpdatedNotRemoved(mcb).collect(Collectors.toList());+        List<MapAuthenticatedClientSessionEntity> clients = userSessions.stream()+                .map(MapUserSessionEntity::getAuthenticatedClientSessions)+                .flatMap(map -> map.values().stream())+                .map(clientSessionTx::read)+                .filter(Objects::nonNull)+                .filter(filterClientExpired)+                .collect(Collectors.toList());++        List<String> clientUUIDs = clients.stream().map(MapAuthenticatedClientSessionEntity::getClientId).collect(Collectors.toList());+        if (!clientUUIDs.isEmpty()) {+            userSessions.stream().forEach(userSessionEntity ->+                    clientUUIDs.forEach(clientUUID -> userSessionEntity.removeAuthenticatedClientSession(clientUUID)));+        }+        clients.stream().forEach(clientEntity -> {+            LOG.debugf(""Deleting expired client session %s"", clientEntity.getId());+            clientSessionTx.delete(clientEntity.getId());+        });++        mcb = realmAndOfflineCriteriaBuilder(realm, true);+        userSessions = userSessionTx.getUpdatedNotRemoved(mcb).collect(Collectors.toList());+        List<MapAuthenticatedClientSessionEntity> offlineClients = userSessions.stream()+                .map(MapUserSessionEntity::getAuthenticatedClientSessions)+                .flatMap(map -> map.values().stream())+                .map(clientSessionTx::read)+                .filter(Objects::nonNull)+                .filter(filterClientExpiredOffline)+                .collect(Collectors.toList());++        List<String> offlineClientUUIDs = offlineClients.stream().map(MapAuthenticatedClientSessionEntity::getClientId).collect(Collectors.toList());+        if (!offlineClientUUIDs.isEmpty()) {+            userSessions.stream().forEach(userSessionEntity ->+                    offlineClientUUIDs.forEach(clientUUID -> userSessionEntity.removeAuthenticatedClientSession(clientUUID)));+        }+        offlineClients.stream().forEach(clientEntity -> {+            LOG.debugf(""Deleting expired offline client session %s"", clientEntity.getId());+            clientSessionTx.delete(clientEntity.getId());+        });+    }++    @Override+    public void removeUserSessions(RealmModel realm) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false);++        LOG.tracef(""removeUserSessions(%s)%s"", realm, getShortStackTrace());++        userSessionTx.getUpdatedNotRemoved(mcb).forEach(userSession -> {+            userSession.getAuthenticatedClientSessions().values().stream().forEach(clientSessionTx::delete);+            userSessionTx.delete(userSession.getId());+        });+    }++    @Override+    public UserLoginFailureModel getUserLoginFailure(RealmModel realm, String userId) {+        ModelCriteriaBuilder<UserLoginFailureModel> mcb = userLoginFailureStore.createCriteriaBuilder()+                .compare(UserLoginFailureModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserLoginFailureModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, userId);++        LOG.tracef(""getUserLoginFailure(%s, %s)%s"", realm, userId, getShortStackTrace());++        return userLoginFailureTx.getUpdatedNotRemoved(mcb)+                .map(userLoginFailureEntityToAdapterFunc(realm))+                .findFirst()+                .orElse(null);+    }++    @Override+    public UserLoginFailureModel addUserLoginFailure(RealmModel realm, String userId) {+        ModelCriteriaBuilder<UserLoginFailureModel> mcb = userLoginFailureStore.createCriteriaBuilder()+                .compare(UserLoginFailureModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserLoginFailureModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, userId);++        LOG.tracef(""addUserLoginFailure(%s, %s)%s"", realm, userId, getShortStackTrace());++        MapUserLoginFailureEntity userLoginFailureEntity = userLoginFailureTx.getUpdatedNotRemoved(mcb).findFirst().orElse(null);++        if (userLoginFailureEntity == null) {+            userLoginFailureEntity = new MapUserLoginFailureEntity(UUID.randomUUID(), realm.getId(), userId);++            userLoginFailureTx.create(userLoginFailureEntity.getId(), userLoginFailureEntity);+        }++        return userLoginFailureEntityToAdapterFunc(realm).apply(userLoginFailureEntity);+    }++    @Override+    public void removeUserLoginFailure(RealmModel realm, String userId) {+        ModelCriteriaBuilder<UserLoginFailureModel> mcb = userLoginFailureStore.createCriteriaBuilder()+                .compare(UserLoginFailureModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserLoginFailureModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, userId);++        LOG.tracef(""removeUserLoginFailure(%s, %s)%s"", realm, userId, getShortStackTrace());++        userLoginFailureTx.delete(UUID.randomUUID(), mcb);+    }++    @Override+    public void removeAllUserLoginFailures(RealmModel realm) {+        ModelCriteriaBuilder<UserLoginFailureModel> mcb = userLoginFailureStore.createCriteriaBuilder()+                .compare(UserLoginFailureModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId());++        LOG.tracef(""removeAllUserLoginFailures(%s)%s"", realm, getShortStackTrace());++        userLoginFailureTx.delete(UUID.randomUUID(), mcb);+    }++    @Override+    public void onRealmRemoved(RealmModel realm) {+        removeUserSessions(realm);+        removeAllUserLoginFailures(realm);+    }++    @Override+    public void onClientRemoved(RealmModel realm, ClientModel client) {++    }++    protected void onUserRemoved(RealmModel realm, UserModel user) {+        removeUserSessions(realm, user);++        removeUserLoginFailure(realm, user.getId());+    }++    @Override+    public UserSessionModel createOfflineUserSession(UserSessionModel userSession) {+        LOG.tracef(""createOfflineUserSession(%s)%s"", userSession, getShortStackTrace());++        MapUserSessionEntity userSessionEntity = createUserSessionEntityInstance(userSession, true);++        // set a reference to the online user session+        ((MapUserSessionAdapter) userSession).setCorrespondingSessionId(userSessionEntity.getId());+        int currentTime = Time.currentTime();+        userSessionEntity.setStarted(currentTime);+        userSessionEntity.setLastSessionRefresh(currentTime);++        userSessionTx.create(userSessionEntity.getId(), userSessionEntity);++        return userEntityToAdapterFunc(userSession.getRealm()).apply(userSessionEntity);+    }++    @Override+    public UserSessionModel getOfflineUserSession(RealmModel realm, String userSessionId) {+        LOG.tracef(""getOfflineUserSession(%s, %s)%s"", realm, userSessionId, getShortStackTrace());++        return getOfflineUserSessionEntityStream(realm, userSessionId)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity))+                .findFirst()+                .orElse(null);+    }++    @Override+    public void removeOfflineUserSession(RealmModel realm, UserSessionModel userSession) {+        Objects.requireNonNull(userSession, ""The provided user session can't be null!"");++        LOG.tracef(""removeOfflineUserSession(%s, %s)%s"", realm, userSession, getShortStackTrace());++        ModelCriteriaBuilder<UserSessionModel> mcb;+        if (userSession.isOffline()) {+            mcb = realmAndOfflineCriteriaBuilder(realm, true)+                    .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, UUID.fromString(userSession.getId()));+            userSessionTx.getUpdatedNotRemoved(mcb).map(MapUserSessionEntity::getId).forEach(userSessionTx::delete);+        } else {+            MapUserSessionAdapter onlineUserSession = (MapUserSessionAdapter) userSession;++            if (onlineUserSession.getCorrespondingSessionId() != null) {+                mcb = realmAndOfflineCriteriaBuilder(realm, true)+                        .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, onlineUserSession.getCorrespondingSessionId());+                userSessionTx.getUpdatedNotRemoved(mcb).map(MapUserSessionEntity::getId).forEach(userSessionTx::delete);+                onlineUserSession.setCorrespondingSessionId(null);+            }+        }+    }++    @Override+    public AuthenticatedClientSessionModel createOfflineClientSession(AuthenticatedClientSessionModel clientSession,+                                                                      UserSessionModel offlineUserSession) {+        LOG.tracef(""createOfflineClientSession(%s, %s)%s"", clientSession, offlineUserSession, getShortStackTrace());++        MapAuthenticatedClientSessionEntity clientSessionEntity = createAuthenticatedClientSessionInstance(clientSession, true);+        clientSessionEntity.setTimestamp(Time.currentTime());++        MapUserSessionEntity userSessionEntity = getOfflineUserSessionEntityStream(clientSession.getRealm(), offlineUserSession.getId()).findFirst().orElse(null);+        if (userSessionEntity != null) {+            userSessionEntity.addAuthenticatedClientSession(clientSession.getClient().getId(), clientSessionEntity.getId());+        }++        clientSessionTx.create(clientSessionEntity.getId(), clientSessionEntity);++        AuthenticatedClientSessionModel clientSessionModel = clientEntityToAdapterFunc(clientSession.getRealm(),+                clientSession.getClient(), offlineUserSession).apply(clientSessionEntity);++        return clientSessionModel;+    }++    @Override+    public Stream<UserSessionModel> getOfflineUserSessionsStream(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, true)+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""getOfflineUserSessionsStream(%s, %s)%s"", realm, user, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity));+    }++    @Override+    public UserSessionModel getOfflineUserSessionByBrokerSessionId(RealmModel realm, String brokerSessionId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, true)+                .compare(UserSessionModel.SearchableFields.BROKER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, brokerSessionId);++        LOG.tracef(""getOfflineUserSessionByBrokerSessionId(%s, %s)%s"", realm, brokerSessionId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity))+                .findFirst()+                .orElse(null);+    }++    @Override+    public Stream<UserSessionModel> getOfflineUserSessionByBrokerUserIdStream(RealmModel realm, String brokerUserId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, true)+                .compare(UserSessionModel.SearchableFields.BROKER_USER_ID, ModelCriteriaBuilder.Operator.EQ, brokerUserId);++        LOG.tracef(""getOfflineUserSessionByBrokerUserIdStream(%s, %s)%s"", realm, brokerUserId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity));+    }++    @Override+    public long getOfflineSessionsCount(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, true)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getOfflineSessionsCount(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb).count();+    }++    @Override+    public Stream<UserSessionModel> getOfflineUserSessionsStream(RealmModel realm, ClientModel client,+                                                                 Integer firstResult, Integer maxResults) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, true)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getOfflineUserSessionsStream(%s, %s, %s, %s)%s"", realm, client, firstResult, maxResults, getShortStackTrace());++        return paginatedStream(userSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> userEntityToAdapterFunc(realm).apply(entity)), firstResult, maxResults);+    }++    @Override+    public void importUserSessions(Collection<UserSessionModel> persistentUserSessions, boolean offline) {+        if (persistentUserSessions == null || persistentUserSessions.isEmpty()) {+            return;+        }++        persistentUserSessions.stream()+            .map(pus -> {+                MapUserSessionEntity userSessionEntity = new MapUserSessionEntity(UUID.randomUUID(), pus.getRealm(), pus.getUser(),+                        pus.getLoginUsername(), pus.getIpAddress(), pus.getAuthMethod(),+                        pus.isRememberMe(), pus.getBrokerSessionId(), pus.getBrokerUserId(), offline);++                for (Map.Entry<String, AuthenticatedClientSessionModel> entry : pus.getAuthenticatedClientSessions().entrySet()) {+                    MapAuthenticatedClientSessionEntity clientSession = toAuthenticatedClientSessionEntity(entry.getValue(), offline);++                    // Update timestamp to same value as userSession. LastSessionRefresh of userSession from DB will have correct value+                    clientSession.setTimestamp(userSessionEntity.getLastSessionRefresh());++                    userSessionEntity.addAuthenticatedClientSession(entry.getKey(), clientSession.getId());++                    clientSessionTx.create(clientSession.getId(), clientSession);+                }++                return userSessionEntity;+            })+            .forEach(use -> userSessionTx.create(use.getId(), use));+    }++    @Override+    public void close() {++    }++    public void removeLocalOfflineUserSessions(RealmModel realm) {","The difference is that one is dealing with online sessions and the other one with offline session.Exactly, it's used just in tests and I followed the same pattern as was used for Infinispan provider.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7756,596156806,2021-03-17T15:55:37Z,services/src/main/java/org/keycloak/protocol/saml/SamlService.java,"@@ -813,4 +1078,372 @@ public Response soapBinding(InputStream inputStream) {          return bindingService.authenticate(inputStream);     }++    private ClientModel getAndCheckClientModel(String clientSessionId, String clientId) throws ProcessingException {+        ClientModel client = session.clients().getClientById(realm, clientSessionId);++        if (client == null) {+            throw new ProcessingException(Errors.CLIENT_NOT_FOUND);+        }+        if (!client.isEnabled()) {+            throw new ProcessingException(Errors.CLIENT_DISABLED);+        }+        if (client.isBearerOnly()) {+            throw new ProcessingException(Errors.NOT_ALLOWED);+        }+        if (!client.isStandardFlowEnabled()) {+            throw new ProcessingException(Errors.NOT_ALLOWED);+        }+        if (!client.getClientId().equals(clientId)) {+            logger.errorf(""Resolve message with wrong issuer. Artifact was issued for client %s, "" ++                            ""however ArtifactResolveMessage came from client %s."", client.getClientId(), clientId);+            throw new ProcessingException(Errors.INVALID_SAML_ARTIFACT);+        }++        return client;+    }+++    private SamlArtifactSessionMappingStoreProvider getArtifactSessionMappingStore() {+        return session.getProvider(SamlArtifactSessionMappingStoreProvider.class);+    }++    /**+     * Takes an artifact resolve message and returns the artifact response, if the artifact is found belonging to a session+     * of the issuer.+     * @param artifactResolveMessage The artifact resolve message sent by the client+     * @param artifactResolveHolder the document containing the artifact resolve message sent by the client+     * @return a Response containing the SOAP message with the ArifactResponse+     * @throws ParsingException+     * @throws ConfigurationException+     * @throws ProcessingException+     */+    public Response artifactResolve(ArtifactResolveType artifactResolveMessage, SAMLDocumentHolder artifactResolveHolder) throws ParsingException, ConfigurationException, ProcessingException {+        logger.debug(""Received artifactResolve message for artifact "" + artifactResolveMessage.getArtifact() + ""\n"" ++                ""Message: \n"" + DocumentUtil.getDocumentAsString(artifactResolveHolder.getSamlDocument()));++        String artifact = artifactResolveMessage.getArtifact(); // Artifact from resolve request+        if (artifact == null) {+            logger.errorf(""Artifact to resolve was null"");+            return emptyArtifactResponseMessage(artifactResolveMessage, null, JBossSAMLURIConstants.STATUS_REQUEST_DENIED.getUri());+        }+        +        ArtifactResolver artifactResolver = getArtifactResolver(artifact);++        if (artifactResolver == null) {+            logger.errorf(""Cannot find ArtifactResolver for artifact %s"", artifact);+            return emptyArtifactResponseMessage(artifactResolveMessage, null, JBossSAMLURIConstants.STATUS_REQUEST_DENIED.getUri());+        }++        // Obtain details of session that issued artifact and check if it corresponds to issuer of Resolve message+        SamlArtifactSessionMappingModel sessionMapping = getArtifactSessionMappingStore().get(artifact);++        if (sessionMapping == null) {+            logger.errorf(""No data stored for artifact %s"", artifact);+            return emptyArtifactResponseMessage(artifactResolveMessage, null);+        }++        UserSessionModel userSessionModel = session.sessions().getUserSession(realm, sessionMapping.getUserSessionId());+        if (userSessionModel == null) {+            logger.errorf(""UserSession with id: %s, that corresponds to artifact: %s does not exist."", sessionMapping.getUserSessionId(), artifact);+            return emptyArtifactResponseMessage(artifactResolveMessage, null);+        }++        AuthenticatedClientSessionModel clientSessionModel = userSessionModel.getAuthenticatedClientSessions().get(sessionMapping.getClientSessionId());+        if (clientSessionModel == null) {+            logger.errorf(""ClientSession with id: %s, that corresponds to artifact: %s and UserSession: %s does not exist."", sessionMapping.getClientSessionId(), artifact, sessionMapping.getUserSessionId());+            return emptyArtifactResponseMessage(artifactResolveMessage, null);+        }++        ClientModel clientModel = getAndCheckClientModel(sessionMapping.getClientSessionId(), artifactResolveMessage.getIssuer().getValue());+        SamlClient samlClient = new SamlClient(clientModel);++        // Check signature within ArtifactResolve request if client requires it+        if (samlClient.requiresClientSignature()) {+            try {+                SamlProtocolUtils.verifyDocumentSignature(clientModel, artifactResolveHolder.getSamlDocument());+            } catch (VerificationException e) {+                SamlService.logger.error(""request validation failed"", e);+                return emptyArtifactResponseMessage(artifactResolveMessage, clientModel);+            }+        }++        // Obtain artifactResponse from clientSessionModel+        String artifactResponseString;+        try {+            artifactResponseString = artifactResolver.resolveArtifact(clientSessionModel, artifact);+        } catch (ArtifactResolverProcessingException e) {+            logger.errorf(e, ""Failed to resolve artifact: %s."", artifact);+            return emptyArtifactResponseMessage(artifactResolveMessage, clientModel);+        }++        // Artifact is successfully resolved, we can remove session mapping from storage+        getArtifactSessionMappingStore().remove(artifact);++        Document artifactResponseDocument = null;+        ArtifactResponseType artifactResponseType = null;+        try {+            SAMLDataMarshaller marshaller = new SAMLDataMarshaller();+            artifactResponseType = marshaller.deserialize(artifactResponseString, ArtifactResponseType.class);+            artifactResponseDocument = SamlProtocolUtils.convert(artifactResponseType);+        }  catch (ParsingException | ConfigurationException | ProcessingException e) {+            logger.errorf(e,""Failed to obtain document from ArtifactResponseString: %s."", artifactResponseString);+            return emptyArtifactResponseMessage(artifactResolveMessage, clientModel);+        }++        // If clientSession is in LOGGING_OUT action, now we can move it to LOGGED_OUT+        if (CommonClientSessionModel.Action.LOGGING_OUT.name().equals(clientSessionModel.getAction())) {+            clientSessionModel.setAction(CommonClientSessionModel.Action.LOGGED_OUT.name());++            // If Keycloak sent LogoutResponse we need to also remove UserSession+            if (artifactResponseType.getAny() instanceof StatusResponseType+                    && artifactResponseString.contains(JBossSAMLConstants.LOGOUT_RESPONSE.get())) {+                if (!UserSessionModel.State.LOGGED_OUT_UNCONFIRMED.equals(userSessionModel.getState())) {+                    logger.warnf(""Keycloak issued LogoutResponse for clientSession %s, however user session %s was not in LOGGED_OUT_UNCONFIRMED state."",+                            clientSessionModel.getId(), userSessionModel.getId());+                }+                AuthenticationManager.finishUnconfirmedUserSession(session, realm, userSessionModel);+            }+        }++        return artifactResponseMessage(artifactResolveMessage, artifactResponseDocument, clientModel);+    }+    +    private Response emptyArtifactResponseMessage(ArtifactResolveType artifactResolveMessage, ClientModel clientModel) throws ProcessingException, ConfigurationException {+        return emptyArtifactResponseMessage(artifactResolveMessage, clientModel, JBossSAMLURIConstants.STATUS_SUCCESS.getUri());+    }++    private Response emptyArtifactResponseMessage(ArtifactResolveType artifactResolveMessage, ClientModel clientModel, URI responseStatusCode) throws ProcessingException, ConfigurationException {+        ArtifactResponseType artifactResponse = SamlProtocolUtils.buildArtifactResponse(null, SAML2NameIDBuilder.value(+                RealmsResource.realmBaseUrl(session.getContext().getUri()).build(realm.getName()).toString()).build(), responseStatusCode);++        Document artifactResponseDocument;+        try {+            artifactResponseDocument = SamlProtocolUtils.convert(artifactResponse);+        }  catch (ParsingException | ConfigurationException | ProcessingException e) {+            logger.errorf(""Failed to obtain document from ArtifactResponse: %s."", artifactResponse);+            throw new ProcessingException(Errors.INVALID_SAML_ARTIFACT_RESPONSE, e);+        }++        return artifactResponseMessage(artifactResolveMessage, artifactResponseDocument, clientModel);+    }+    +    private Response artifactResponseMessage(ArtifactResolveType artifactResolveMessage, Document artifactResponseDocument, ClientModel clientModel) throws ProcessingException, ConfigurationException {+        // Add ""inResponseTo"" to artifactResponse+        if (artifactResolveMessage.getID() != null && !artifactResolveMessage.getID().trim().isEmpty()){+            Element artifactResponseElement = artifactResponseDocument.getDocumentElement();+            artifactResponseElement.setAttribute(""InResponseTo"", artifactResolveMessage.getID());+        }+        JaxrsSAML2BindingBuilder bindingBuilder = new JaxrsSAML2BindingBuilder(session);+        +        if (clientModel != null) {+            SamlClient samlClient = new SamlClient(clientModel);++            // Sign document/assertion if necessary, necessary to do this here, as the ""inResponseTo"" can only be set at this point+            if (samlClient.requiresRealmSignature() || samlClient.requiresAssertionSignature()) {+                KeyManager keyManager = session.keys();+                KeyManager.ActiveRsaKey keys = keyManager.getActiveRsaKey(realm);+                String keyName = samlClient.getXmlSigKeyInfoKeyNameTransformer().getKeyName(keys.getKid(), keys.getCertificate());+                String canonicalization = samlClient.getCanonicalizationMethod();+                if (canonicalization != null) {+                    bindingBuilder.canonicalizationMethod(canonicalization);+                }+                bindingBuilder.signatureAlgorithm(samlClient.getSignatureAlgorithm()).signWith(keyName, keys.getPrivateKey(), keys.getPublicKey(), keys.getCertificate());++                if (samlClient.requiresRealmSignature()) bindingBuilder.signDocument();+                if (samlClient.requiresAssertionSignature()) bindingBuilder.signAssertions();+            }++            // Encrypt assertion if client requires it+            if (samlClient.requiresEncryption()) {+                PublicKey publicKey = null;+                try {+                    publicKey = SamlProtocolUtils.getEncryptionKey(clientModel);+                } catch (Exception e) {+                    logger.error(""Failed to obtain encryption key for client"", e);+                    return emptyArtifactResponseMessage(artifactResolveMessage, null);+                }+                bindingBuilder.encrypt(publicKey);+            }+        }++        bindingBuilder.postBinding(artifactResponseDocument);++        Soap.SoapMessageBuilder messageBuilder = Soap.createMessage();+        messageBuilder.addToBody(artifactResponseDocument);++        if (logger.isDebugEnabled()) {+            String artifactResponse = DocumentUtil.asString(artifactResponseDocument);+            logger.debugf(""Sending artifactResponse message for artifact %s. Message: \n %s"", artifactResolveMessage.getArtifact(), artifactResponse);+        }++        return messageBuilder.build();+    }++    /**+     * Creates an ArtifactResolve document with the given issuer and artifact+     * @param issuer the value to set as ""issuer""+     * @param artifact the value to set as ""artifact""+     * @return the Document of the created ArtifactResolve message+     * @throws ProcessingException+     * @throws ParsingException+     * @throws ConfigurationException+     */+    private Document createArtifactResolve(String issuer, String artifact) throws ProcessingException, ParsingException, ConfigurationException {+        ArtifactResolveType artifactResolve = new ArtifactResolveType(IDGenerator.create(""ID_""),+                XMLTimeUtil.getIssueInstant());+        NameIDType nameIDType = new NameIDType();+        nameIDType.setValue(issuer);+        artifactResolve.setIssuer(nameIDType);+        artifactResolve.setArtifact(artifact);++        ByteArrayOutputStream bos = new ByteArrayOutputStream();+        XMLStreamWriter xmlStreamWriter = StaxUtil.getXMLStreamWriter(bos);+        new SAMLRequestWriter(xmlStreamWriter).write(artifactResolve);+        return DocumentUtil.getDocument(new ByteArrayInputStream(bos.toByteArray()));+    }++    private ArtifactResolver getArtifactResolver(String artifact) {+        return session.getProvider(ArtifactResolver.class, ArtifactBindingUtils.artifactToResolverProviderId(artifact));",Can a default `session.getProvider(ArtifactResolver.class);` be returned if the specific provider for the artifact cannot be found?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7856,596807421,2021-03-18T12:07:00Z,model/infinispan/src/main/java/org/keycloak/connections/infinispan/DefaultInfinispanConnectionProviderFactory.java,"@@ -495,4 +510,23 @@ protected void configureTransport(GlobalConfigurationBuilder gcb, String nodeNam         }     } +    private void registerSystemWideListeners(KeycloakSession session) {+        KeycloakSessionFactory sessionFactory = session.getKeycloakSessionFactory();+        ClusterProvider cluster = session.getProvider(ClusterProvider.class);+        cluster.registerListener(REALM_CLEAR_CACHE_EVENTS, (ClusterEvent event) -> {+            if (event instanceof ClearCacheEvent) {+                sessionFactory.invalidate(ObjectType._ALL_);+            }+        });+        cluster.registerListener(REALM_INVALIDATION_EVENTS, (ClusterEvent event) -> {","Few points:- The REALM_INVALIDATION_EVENTS is currently sent from RealmCacheSession.runInvalidations() and it is sent with ""ignoreSender"" true. This means that listener is not called on the sender node itself (It is sent on all other cluster nodes and on all other nodes on all datacenters, but not on sender itself). It looks that this is not correct as ""sessionFactory.invalidate"" needs to be called on the caller node as well?- I think that in the case of disabled realm cache, the REALM_INVALIDATION_EVENTS won't be sent at all. Hence listener also won't be probably called. For this one, it won't be called on any cluster/cross-dc nodes",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7856,596817184,2021-03-18T12:22:02Z,services/src/main/java/org/keycloak/services/DefaultComponentFactoryProviderFactory.java,"@@ -0,0 +1,191 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.services;++import org.keycloak.Config;+import org.keycloak.Config.Scope;+import org.keycloak.cluster.ClusterProvider;+import org.keycloak.common.util.StackUtil;+import org.keycloak.component.ComponentFactoryProviderFactory;+import org.keycloak.component.ComponentModel;+import org.keycloak.component.ComponentModelScope;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.provider.InvalidationHandler;+import org.keycloak.provider.InvalidationHandler.InvalidableObjectType;+import org.keycloak.provider.InvalidationHandler.ObjectType;+import org.keycloak.provider.Provider;+import org.keycloak.provider.ProviderFactory;+import java.util.Arrays;+import java.util.Collection;+import java.util.Objects;+import java.util.Set;+import java.util.concurrent.ConcurrentHashMap;+import java.util.concurrent.ConcurrentMap;+import java.util.concurrent.atomic.AtomicReference;+import java.util.function.Function;+import java.util.stream.Stream;+import org.jboss.logging.Logger;++/**+ * @author hmlnarik+ */+public class DefaultComponentFactoryProviderFactory implements ComponentFactoryProviderFactory {++    private static final Logger LOG = Logger.getLogger(DefaultComponentFactoryProviderFactory.class);+    public static final String PROVIDER_ID = ""default"";++    private final AtomicReference<ConcurrentMap<String, ProviderFactory>> componentsMap = new AtomicReference<>(new ConcurrentHashMap<>());++    /**+     * Should an ID in the key be invalidated, it would invalidate also all the IDs in the values+     */+    private final ConcurrentMap<Object, Set<String>> dependentInvalidations = new ConcurrentHashMap<>();++    private KeycloakSessionFactory factory;+    private boolean componentCachingAvailable;++    @Override+    public void init(Scope config) {+    }++    @Override+    public void postInit(KeycloakSessionFactory factory) {+        this.factory = factory;+        this.componentCachingAvailable = this.factory.getProviderFactory(ClusterProvider.class) != null;+        if (! componentCachingAvailable) {+            LOG.warn(""No system-wide ClusterProviderFactory found. Cannot send messages across cluster, thus disabling caching of components."");+        }+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public <T extends Provider> ProviderFactory<T> getProviderFactory(Class<T> clazz, String realmId, String componentId, Function<KeycloakSessionFactory, ComponentModel> modelGetter) {+        ProviderFactory res = componentsMap.get().get(componentId);+        if (res != null) {+            LOG.tracef(""Found cached ProviderFactory for %s in (%s, %s)"", clazz, realmId, componentId);+            return res;+        }++        // Apply the expensive operation before putting it into the cache+        final ComponentModel cm;+        if (modelGetter == null) {+            LOG.debugf(""Getting component configuration for component (%s, %s) from realm configuration"", clazz, realmId, componentId);+            AtomicReference<ComponentModel> cmr = new AtomicReference<>();",This can be probably simplified a bit to call `KeycloakModelUtils.componentModelGetter` as this code is in fact duplicate of it.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7856,596979308,2021-03-18T15:28:13Z,model/infinispan/src/main/java/org/keycloak/connections/infinispan/DefaultInfinispanConnectionProviderFactory.java,"@@ -495,4 +510,23 @@ protected void configureTransport(GlobalConfigurationBuilder gcb, String nodeNam         }     } +    private void registerSystemWideListeners(KeycloakSession session) {+        KeycloakSessionFactory sessionFactory = session.getKeycloakSessionFactory();+        ClusterProvider cluster = session.getProvider(ClusterProvider.class);+        cluster.registerListener(REALM_CLEAR_CACHE_EVENTS, (ClusterEvent event) -> {+            if (event instanceof ClearCacheEvent) {+                sessionFactory.invalidate(ObjectType._ALL_);+            }+        });+        cluster.registerListener(REALM_INVALIDATION_EVENTS, (ClusterEvent event) -> {","> The REALM_INVALIDATION_EVENTS is currently sent from RealmCacheSession.runInvalidations() and it is sent with ""ignoreSender"" true. This means that listener is not called on the sender node itself (It is sent on all other cluster nodes and on all other nodes on all datacenters, but not on sender itself). It looks that this is not correct as ""sessionFactory.invalidate"" needs to be called on the caller node as well?This is a great spot and valid observation. You're right that the `REALM_INVALIDATION_EVENTS` is not received on the sender node, and that is intentional. The `REALM_INVALIDATION_EVENTS` is specific to `DefaultInfinispanConnectionProviderFactory` or in general to `infinispan` model. The invalidations for the local node are expected to be triggered by the appropriate operation, and be sufficiently fine-grained. In this PR, this is covered only by a detailed `COMPONENT` invalidation upon component config change / removal in https://github.com/keycloak/keycloak/blob/3cac606746cdcc8e1c1a91073f4ca402f143ac62/server-spi-private/src/main/java/org/keycloak/component/AmphibianProviderFactory.java#L66-L87However I can see that this can be improved since there should be an invalidation repeated at the end of the session, after all the changes are committed. I'll update the code accordingly.> I think that in the case of disabled realm cache, the REALM_INVALIDATION_EVENTS won't be sent at all. Hence listener also won't be probably called. For this one, it won't be called on any cluster/cross-dc nodesThis is a valid concern, thank you for that. The cluster events will only work with some cluster provider available. Thus the `DefaultComponentFactoryProviderFactory` only performs caching if the messages are available:https://github.com/keycloak/keycloak/blob/3cac606746cdcc8e1c1a91073f4ca402f143ac62/services/src/main/java/org/keycloak/services/DefaultComponentFactoryProviderFactory.java#L70-L73 and https://github.com/keycloak/keycloak/blob/3cac606746cdcc8e1c1a91073f4ca402f143ac62/services/src/main/java/org/keycloak/services/DefaultComponentFactoryProviderFactory.java#L127-L129But now I can see that this is insufficient since availability of the `InfinispanClusterProvider` would not be sufficient. At the same time, binding the caching availability to `CachedRealmProvider` would not be correct as well as in the new store there would be no `CachedRealmProvider`. I'll introduce a property of the `DefaultComponentFactoryProviderFactory` that would disable caching explicitly then, effectively reverting the functionality back to current behaviour. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7856,597204806,2021-03-18T20:04:12Z,server-spi-private/src/main/java/org/keycloak/component/AmphibianProviderFactory.java,"@@ -0,0 +1,92 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.component;++import org.keycloak.Config.Scope;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.provider.InvalidationHandler.ObjectType;+import java.util.Collections;+import java.util.List;+import org.keycloak.provider.Provider;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.provider.ProviderFactory;+import java.util.Objects;++/**+ * Ancestor for a provider factory for both a standalone {@link ProviderFactory} and a {@link ComponentFactory}. It+ * behaves as usual for a standalone provider, and for a component creates a factory customized according to+ * configuration of this component. The component creation then behaves in the same way as if it was+ * a standalone component, i.e.:+ * <ul>+ * <li>The component-specific factory is initialized via {@link #init} method where the configuration+ *     is taken from the component configuration, converted into a {@link Scope}. The+ *     component configuration takes precedence over configuration of the provider factory.</li>+ * <li>Creation of the instances is done via standard {@link #create(KeycloakSession)} method even for components,+ *     since there is now a specific factory per component.</li>+ * <li>Component-specific factories are cached inside the provider factory+ *     similarly to how provider factories are cached in the session factory.</li>+ * </ul>+ *+ * @see ComponentFactoryProviderFactory+ *+ * @author hmlnarik+ */+public interface AmphibianProviderFactory<ProviderType extends Provider> extends ProviderFactory<ProviderType>, ComponentFactory<ProviderType, ProviderType> {","Thanks for the suggestions! I like those, though I feel that those with `Component` in their name seem not to manifest clearly that this factory is not only a factory for a component but also for a standalone provider.This leaves out the `CombinedProviderFactory` where I'd also still incline more to the current name if no better-fitting name could be found. It is in server-spi-private anyway, so renaming could happen in the future.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7815,597645354,2021-03-19T12:39:55Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -338,7 +338,8 @@ public boolean removeRole(RoleModel role) {         }         String compositeRoleTable = JpaUtils.getTableNameForNativeQuery(""COMPOSITE_ROLE"", em);         em.createNativeQuery(""delete from "" + compositeRoleTable + "" where CHILD_ROLE = :role"").setParameter(""role"", roleEntity).executeUpdate();-        realm.getClientsStream().forEach(c -> c.deleteScopeMapping(role));+        String clientScopeMapping = JpaUtils.getTableNameForNativeQuery(""SCOPE_MAPPING"", em);","Actually, looking a bit further into the code, this should be introduced as a method `preRemove` in a `ClientProvider` that would take a parameter `realm` and `role`, similarly to what's done on L 344 for groups.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7722,597964778,2021-03-19T20:45:14Z,model/jpa/src/main/resources/META-INF/jpa-changelog-13.0.0.xml,"@@ -38,4 +38,23 @@         </createIndex>     </changeSet> +    <changeSet author=""keycloak"" id=""13.0.0-KEYCLOAK-11019"">+        <createIndex tableName=""OFFLINE_CLIENT_SESSION"" indexName=""IDX_OFFLINE_CSS_PRELOAD"">+            <column name=""OFFLINE_FLAG"" type=""VARCHAR(4)""/>+            <column name=""CLIENT_ID"" type=""VARCHAR(36)""/>","Reversing the two fields, ie. index on `(CLIENT_ID, OFFLINE_FLAG)` would be more helpful. `OFFLINE_FLAG` selectivity is rather bad, so it roughly corresponds to seq scan, while `client_id` is rather very specific. Sole `CLIENT_ID` is used in `deleteClientSessionsByClient` query.",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/7815,598485438,2021-03-22T07:49:00Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -338,7 +338,8 @@ public boolean removeRole(RoleModel role) {         }         String compositeRoleTable = JpaUtils.getTableNameForNativeQuery(""COMPOSITE_ROLE"", em);         em.createNativeQuery(""delete from "" + compositeRoleTable + "" where CHILD_ROLE = :role"").setParameter(""role"", roleEntity).executeUpdate();-        realm.getClientsStream().forEach(c -> c.deleteScopeMapping(role));+        String clientScopeMapping = JpaUtils.getTableNameForNativeQuery(""SCOPE_MAPPING"", em);","OK, it's done. There are two things to comment:1. The method cannot be named `preRemove` because there are two classes that implements Group and Client provider and if the methods have the same signature, the same method is executed several times (x4, x2 in `JpaRealmProvider` and another x2 in `RealmCacheSession`). So I have used the name `preRemoveClientProvider` for the client provider.2. In the `MapClientProvider` no new searchable field was created, all the clients in the realm are iterated to update them. I think this part is WIP so I prefer to modify it as little as possible.Just let me know if you want more modifications. Thanks!",
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7852,598614376,2021-03-22T10:58:43Z,testsuite/integration-arquillian/tests/pom.xml,"@@ -659,7 +659,7 @@                               ~ Used for Wildfly Elytron 1.13.0.CR3+ RESTEasy client SSL truststore configuration.                               ~ See KEYCLOAK-15692, ELY-1891 issues & PRs of EAP7-1219 issue for details.                               -->-                            <wildfly.config.url>${project.build.directory}/dependency/wildfly-config.xml</wildfly.config.url>+                            <path.to.wildfly.config>${project.build.directory}${file.separator}dependency${file.separator}wildfly-config.xml</path.to.wildfly.config>","Hi @hmlnarik, Jan explained it in the [comment](https://github.com/keycloak/keycloak/pull/7852#issuecomment-798887126) above. The reason was to avoid a naming collision with wildfly-config-client, which uses a property with the same name but it parses it differently.I guess we could use something like `<wildfly.config.path>` instead.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7756,598719306,2021-03-22T13:35:27Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanSamlArtifactSessionMappingStoreProvider.java,"@@ -0,0 +1,126 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.sessions.infinispan;++import org.infinispan.client.hotrod.exceptions.HotRodClientException;+import org.infinispan.commons.api.BasicCache;+import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.SamlArtifactSessionMappingModel;+import org.keycloak.models.SamlArtifactSessionMappingStoreProvider;+import org.keycloak.models.sessions.infinispan.entities.ActionTokenValueEntity;+import org.keycloak.models.sessions.infinispan.util.InfinispanUtil;++import java.util.HashMap;+import java.util.Map;+import java.util.UUID;+import java.util.concurrent.TimeUnit;+import java.util.function.Supplier;+++/**+ * @author mhajas+ */+public class InfinispanSamlArtifactSessionMappingStoreProvider implements SamlArtifactSessionMappingStoreProvider {++    public static final Logger logger = Logger.getLogger(InfinispanSamlArtifactSessionMappingStoreProvider.class);++    private static final String USER_SESSION_ID = ""user.session.id"";+    private static final String CLIENT_SESSION_ID = ""client.session.id"";++    private final Supplier<BasicCache<UUID, ActionTokenValueEntity>> codeCache;++    public InfinispanSamlArtifactSessionMappingStoreProvider(Supplier<BasicCache<UUID, ActionTokenValueEntity>> actionKeyCache) {+        this.codeCache = actionKeyCache;+    }++    private Map<String, String> serializedMapping(AuthenticatedClientSessionModel clientSessionModel) {+        Map<String, String> serialized = new HashMap<>(2);+        serialized.put(USER_SESSION_ID, clientSessionModel.getUserSession().getId());+        serialized.put(CLIENT_SESSION_ID, clientSessionModel.getClient().getId());++        return serialized;+    }++    @Override+    public void put(String artifact, int lifespanSeconds, AuthenticatedClientSessionModel clientSessionModel) {+        ActionTokenValueEntity tokenValue = new ActionTokenValueEntity(serializedMapping(clientSessionModel));++        try {+            BasicCache<UUID, ActionTokenValueEntity> cache = codeCache.get();+            long lifespanMs = InfinispanUtil.toHotrodTimeMs(cache, Time.toMillis(lifespanSeconds));+            cache.put(UUID.nameUUIDFromBytes(artifact.getBytes()), tokenValue, lifespanMs, TimeUnit.MILLISECONDS);","`Artifact` doesn't need to conform to UUID format because `nameUUIDFromBytes` is doing `md5` in the background which hash it to the correct format. I didn't know that we can actually change parameters of BasicCache just like that, but I changed it to `String, String[]` and it works. Do you think it would be a good idea to stick with `nameUUIDFromBytes` so that we save some space in the cache? Currently, each default artifact has 44 Bytes. Using `nameUUIDFromBytes` we can shrink it to 8 Bytes. ",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7756,598723907,2021-03-22T13:40:51Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanSamlArtifactSessionMappingStoreProvider.java,"@@ -0,0 +1,126 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.sessions.infinispan;++import org.infinispan.client.hotrod.exceptions.HotRodClientException;+import org.infinispan.commons.api.BasicCache;+import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.SamlArtifactSessionMappingModel;+import org.keycloak.models.SamlArtifactSessionMappingStoreProvider;+import org.keycloak.models.sessions.infinispan.entities.ActionTokenValueEntity;+import org.keycloak.models.sessions.infinispan.util.InfinispanUtil;++import java.util.HashMap;+import java.util.Map;+import java.util.UUID;+import java.util.concurrent.TimeUnit;+import java.util.function.Supplier;+++/**+ * @author mhajas+ */+public class InfinispanSamlArtifactSessionMappingStoreProvider implements SamlArtifactSessionMappingStoreProvider {++    public static final Logger logger = Logger.getLogger(InfinispanSamlArtifactSessionMappingStoreProvider.class);++    private static final String USER_SESSION_ID = ""user.session.id"";+    private static final String CLIENT_SESSION_ID = ""client.session.id"";++    private final Supplier<BasicCache<UUID, ActionTokenValueEntity>> codeCache;","This is a good question. I just used the same thing as was used for CodeToToken cache. @mposolda is the Supplier necessary there? See the same part for CodeToToken provider: https://github.com/keycloak/keycloak/blob/master/model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanCodeToTokenStoreProvider.java#L41 I tried to call `get()` method when  `InfinispanSamlArtifactSessionMappingStoreProvider` is created and it works, but I didn't test it in clustered/crossDc environment.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,598795906,2021-03-22T15:01:00Z,server-spi/src/main/java/org/keycloak/models/ClientPolicyModel.java,"@@ -0,0 +1,79 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models;++import java.io.Serializable;+import java.util.List;++public class ClientPolicyModel implements Serializable {","This class (and also ClientProfileModel class) don't need to be here in the ""keycloak-server-spi"" module. Also those model classes are not typical ""model"" classes (they are not supposed to be CRUD from DB directly).So to be able to change them in the future, I vote for move them into ""keycloak-server-spi-private"" module possibly to the package ""org.keycloak.services.clientpolicy"" to have most of the client policies stuff in the single package. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,598799848,2021-03-22T15:05:31Z,quarkus/runtime/src/main/resources/keycloak-default-client-policies.json,"@@ -0,0 +1,18 @@+{+  ""policies"": [","It will be good to avoid a need to have the builtin JSON files for policies and profiles on multiple places. I hope there is no need to have the files inside `quarkus/runtime` module, but is sufficient to keep in keycloak-services? The duplication adds the potential for various bugs and inconsistencies IMO...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,598804109,2021-03-22T15:10:11Z,services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java,"@@ -158,4 +176,262 @@ private void execute(         void run(ClientPolicyExecutorProvider executor) throws ClientPolicyException;     } ++    // Client Polices Realm Attributes Keys+    public static final String CLIENT_PROFILES = ""client-policies.profiles"";+    public static final String CLIENT_POLICIES = ""client-policies.policies"";++    // builtin profiles and policies are loaded on booting keycloak at once.+    // therefore, their representations are kept and remain unchanged.+    // these are shared among all realms.++    // those can be null to show that no profile/policy exist+    private static String builtinClientProfilesJson;+    private static String builtinClientPoliciesJson;++    @Override+    public void setupClientPoliciesOnKeycloakApp(String profilesFilePath, String policiesFilePath) {+        ClientPolicyLogger.logv(logger, ""{0} :: LOAD BUILTIN PROFILE POLICIES ON KEYCLOAK"", logMsgPrefix());++        // client profile can be referred from client policy so that client profile needs to be loaded at first.+        // load builtin profiles on keycloak app+        ClientProfilesRepresentation validatedProfilesRep = null;+        try {+            validatedProfilesRep = ClientPoliciesUtil.getValidatedBuiltinClientProfilesRepresentation(session, getClass().getResourceAsStream(profilesFilePath));+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: LOAD BUILTIN PROFILES ON KEYCLOAK FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            return;+        }++        String validatedJson = null;+        try {+            validatedJson = ClientPoliciesUtil.convertClientProfilesRepresentationToJson(validatedProfilesRep);+        } catch (ClientPolicyException cpe) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE BUILTIN PROFILES ON KEYCLOAK FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, cpe.getError(), cpe.getErrorDetail());+            return;+        }++        builtinClientProfilesJson = validatedJson;++        // load builtin policies on keycloak app+        ClientPoliciesRepresentation validatedPoliciesRep = null;+        try {+            validatedPoliciesRep = ClientPoliciesUtil.getValidatedBuiltinClientPoliciesRepresentation(session, getClass().getResourceAsStream(policiesFilePath));+        } catch (ClientPolicyException cpe) {+            logger.warnv(""{0} :: LOAD BUILTIN POLICIES ON KEYCLOAK FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, cpe.getError(), cpe.getErrorDetail());+            builtinClientProfilesJson = null;+            return;+        }++        validatedJson = null;+        try {+            validatedJson = ClientPoliciesUtil.convertClientPoliciesRepresentationToJson(validatedPoliciesRep);+        } catch (ClientPolicyException cpe) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE BUILTIN POLICIES ON KEYCLOAK FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, cpe.getError(), cpe.getErrorDetail());+            builtinClientProfilesJson = null;+            return;+        }++        builtinClientPoliciesJson = validatedJson;+    }++    @Override+    public void setupClientPoliciesOnCreatedRealm(RealmModel realm) {+        ClientPolicyLogger.logv(logger, ""{0} :: LOAD BUILTIN PROFILE POLICIES ON CREATED REALM :: realm = {1}"", logMsgPrefix(), realm.getName());++        // put already loaded builtin profiles/policies on keycloak app to newly created realm+        setClientProfilesJsonString(realm, builtinClientProfilesJson);+        setClientPoliciesJsonString(realm, builtinClientPoliciesJson);+    }++    @Override+    public void setupClientPoliciesOnImportedRealm(RealmModel realm, RealmRepresentation rep) {+        ClientPolicyLogger.logv(logger, ""{0} :: LOAD PROFILE POLICIES ON IMPORTED REALM :: realm = {1}"", logMsgPrefix(), realm.getName());++        // put already loaded builtin profiles/policies on keycloak app to newly created realm+        setClientProfilesJsonString(realm, builtinClientProfilesJson);+        setClientPoliciesJsonString(realm, builtinClientPoliciesJson);++        // merge imported polices/profiles with builtin policies/profiles+        String validatedJson = null;+        try {+            validatedJson = ClientPoliciesUtil.getValidatedClientProfilesJson(session, realm, rep.getClientProfiles());+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE IMPORTED REALM PROFILES FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            // revert to builtin profiles+            validatedJson = builtinClientProfilesJson;+        }+        setClientProfilesJsonString(realm, validatedJson);++        try {+            validatedJson = ClientPoliciesUtil.getValidatedClientPoliciesJson(session, realm, rep.getClientPolicies());+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE IMPORTED REALM POLICIES FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            // revert to builtin profiles+            validatedJson = builtinClientPoliciesJson;+        }+        setClientPoliciesJsonString(realm, validatedJson);+    }++    @Override+    public void updateClientProfiles(RealmModel realm, String json) throws ClientPolicyException {+        ClientPolicyLogger.logv(logger, ""{0} :: UPDATE PROFILES :: realm = {1}, PUT = {2}"", logMsgPrefix(), realm.getName(), json);+        String validatedJsonString = null;+        try {+            validatedJsonString = getValidatedClientProfilesJson(realm, json);+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE PROFILES FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            throw e;+        }+        setClientProfilesJsonString(realm, validatedJsonString);+        ClientPolicyLogger.logv(logger, ""{0} :: UPDATE PROFILES :: realm = {1}, validated and modified PUT = {2}"", logMsgPrefix(), realm.getName(), validatedJsonString);+    }++    @Override+    public String getClientProfiles(RealmModel realm) {+        String json = getClientProfilesJsonString(realm);+        ClientPolicyLogger.logv(logger, ""{0} :: GET PROFILES :: realm = {1}, GET = {2}"", logMsgPrefix(), realm.getName(), json);+        return json;+    }++    @Override+    public void updateClientPolicies(RealmModel realm, String json) throws ClientPolicyException {+        ClientPolicyLogger.logv(logger, ""{0} :: UPDATE POLICIES :: realm = {1}, PUT = {2}"", logMsgPrefix(), realm.getName(), json);+        String validatedJsonString = null;+        try {+            validatedJsonString = getValidatedClientPoliciesJson(realm, json);+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE POLICIES FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            throw e;+        }+        setClientPoliciesJsonString(realm, validatedJsonString);+        ClientPolicyLogger.logv(logger, ""{0} :: UPDATE POLICIES :: realm = {1}, validated and modified PUT = {2}"", logMsgPrefix(), realm.getName(), validatedJsonString);+    }++    @Override+    public void setupClientPoliciesOnExportingRealm(RealmModel realm, RealmRepresentation rep) {+        // client profiles  that filter out builtin profiles..+        ClientProfilesRepresentation filteredOutProfiles = null;+        try {+            filteredOutProfiles = getClientProfilesForExport(realm);+        } catch (ClientPolicyException e) {+            // set as null+        }+        rep.setClientProfiles(filteredOutProfiles);++        // client policies that filter out builtin and policies.+        ClientPoliciesRepresentation filteredOutPolicies = null;+        try {+            filteredOutPolicies = getClientPoliciesForExport(realm);+        } catch (ClientPolicyException e) {+            // set as null+        }+        rep.setClientPolicies(filteredOutPolicies);+    }++    @Override+    public String getClientPolicies(RealmModel realm) {+        String json = getClientPoliciesJsonString(realm);+        ClientPolicyLogger.logv(logger, ""{0} :: GET POLICIES :: realm = {1}, GET = {2}"", logMsgPrefix(), realm.getName(), json);+        return json;+    }++    @Override+    public String getClientProfilesOnKeycloakApp() {+        return builtinClientProfilesJson;+    }++    @Override+    public String getClientPoliciesOnKeycloakApp() {+        return builtinClientPoliciesJson;+    }++    @Override+    public String getClientProfilesJsonString(RealmModel realm) {+        return realm.getAttribute(CLIENT_PROFILES);+    }++    @Override+    public String getClientPoliciesJsonString(RealmModel realm) {+        return realm.getAttribute(CLIENT_POLICIES);+    }++    private void setClientProfilesJsonString(RealmModel realm, String json) {+        realm.setAttribute(CLIENT_PROFILES, json);+    }++    private void setClientPoliciesJsonString(RealmModel realm, String json) {+        realm.setAttribute(CLIENT_POLICIES, json);+    }++    private String getValidatedClientProfilesJson(RealmModel realm, String profilesJson) throws ClientPolicyException {+        ClientProfilesRepresentation validatedProfilesRep = null;+        try {+            validatedProfilesRep = ClientPoliciesUtil.getValidatedClientProfilesRepresentation(session, realm, profilesJson);+        } catch (ClientPolicyException e) {","I am not sure what is the point in catch ClientPolicyException and then just throw again ClientPolicyException with exactly same error and errorDetails? Since the method getValidatedClientProfilesJson is declared to throw ClientPolicyException, maybe this try/catch block can be removed entirely? This applies for lots of other places inside this class.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,598805303,2021-03-22T15:11:34Z,model/jpa/src/main/resources/META-INF/jpa-changelog-13.0.0.xml,"@@ -42,4 +42,9 @@         <dropForeignKeyConstraint baseTableName=""DEFAULT_CLIENT_SCOPE"" constraintName=""FK_R_DEF_CLI_SCOPE_SCOPE""/>         <dropForeignKeyConstraint baseTableName=""CLIENT_SCOPE_CLIENT"" constraintName=""FK_C_CLI_SCOPE_SCOPE""/>     </changeSet>++    <changeSet author=""keycloak"" id=""json-string-accomodation"">","Is it possible to change this to use `newDataType=""NCLOB""` ? I've actually added this change to my branch https://github.com/mposolda/keycloak/tree/KEYCLOAK-16805-client-policies-db-change (See the last commit). I've tested that updated change with all our supported databases nad it is fine.The reason for that change is, that NVARCHAR(65535) doesn't work on some databases (At least Oracle has limit 4000 characters for the VARCHAR and NVARCHAR). Also we use CLOB or NCLOB for some similar columns in the DB where is JSON supposed to be saved.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,598808037,2021-03-22T15:14:40Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRedirectUriEnforceExecutor.java,"@@ -34,26 +33,34 @@ import org.keycloak.services.clientpolicy.context.DynamicClientRegisterContext; import org.keycloak.services.clientpolicy.context.DynamicClientUpdateContext; +import com.fasterxml.jackson.annotation.JsonIgnoreProperties;+ public class SecureRedirectUriEnforceExecutor implements ClientPolicyExecutorProvider {      private static final Logger logger = Logger.getLogger(SecureRedirectUriEnforceExecutor.class);+    private static final String LOGMSG_PREFIX = ""CLIENT-POLICY"";","LOGMSG_PREFIX constant is defined individually on almost every class (SecureRedirectUriEnforceExecutor, SecureSessionEnforceExecutor etc). If it should be used by multiple classes, then maybe will be better to just have a constant for it?Another more generic point is, that there is some flexibility how can be logging configured in the standalone.xml in logging subsystem. You can configure logging format for various classes to use the thread name, method name etc. I am not 100% sure if ClientPolicyLogger is not duplicating things, which can be handled/configured by the logging framework itself. But I am fine with the current approach in this PR. Maybe logging is something to revisit in the future...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,598814725,2021-03-22T15:21:52Z,server-spi-private/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorProvider.java,"@@ -34,6 +34,14 @@     default void close() {     } +    /**+     * setup this executor's configuration.+     *+     * @param config+     */+    default void setupConfiguration(Object config) {","I've tried to do some simplification in my branch https://github.com/mposolda/keycloak/tree/KEYCLOAK-16805-client-policies-db-change (See the commit https://github.com/mposolda/keycloak/commit/783e9c3a2d130eb6e1a3bd92c2b1679982af02f2 ) . I've tried to add some common configuration class, which will be common to all the ClientPolicyExecutorProvider. At the same time, I've tried to add some type-safety and also wanted to avoid some boilerplate code with parsing the JSON configuration to be in each executor. After I did this, I figured that for ClientPolicyConditionProvider, the situation is better than for the executors and you already added some common class (AbstractClientCondition and the common configuration class AbstractClientCondition.Configuration).I suggest that both ClientPolicyExecutorProvider and ClientPolicyConditionProvider use some approach with the ""common"" configuration class and type-safety. And that both ClientPolicyExecutorProvider and ClientPolicyConditionProvider are aligned and use similar approach. I suggest to either:1) Cherry-pick my commit https://github.com/mposolda/keycloak/commit/783e9c3a2d130eb6e1a3bd92c2b1679982af02f2 to this PR and refactor the ClientPolicyConditionProvider to use same approach aligned with the ClientPolicyExecutorProvider I introduced.2) Change executors a bit to align with the approach you used for the conditions (AbstractClientCondition and AbstractClientCondition.Configuration class)Do you prefer (1) or (2) or something else? WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,598815759,2021-03-22T15:23:04Z,server-spi-private/src/main/java/org/keycloak/services/clientpolicy/ClientPoliciesUtil.java,"@@ -0,0 +1,747 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy;++import java.io.IOException;+import java.io.InputStream;+import java.util.ArrayList;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.List;+import java.util.Map;+import java.util.Map.Entry;+import java.util.Set;+import java.util.function.Predicate;+import java.util.stream.Collectors;++import org.jboss.logging.Logger;++import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ClientPolicyModel;+import org.keycloak.models.ClientProfileModel;+import org.keycloak.models.RealmModel;+import org.keycloak.representations.idm.ClientPoliciesRepresentation;+import org.keycloak.representations.idm.ClientPolicyRepresentation;+import org.keycloak.representations.idm.ClientProfileRepresentation;+import org.keycloak.representations.idm.ClientProfilesRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;+import org.keycloak.util.JsonSerialization;++import com.fasterxml.jackson.core.JsonProcessingException;+import com.fasterxml.jackson.databind.JsonNode;+import com.fasterxml.jackson.databind.ObjectMapper;++public class ClientPoliciesUtil {++    private static final Logger logger = Logger.getLogger(ClientPoliciesUtil.class);++    private static final String LOGMSG_PREFIX = ""CLIENT-POLICIES"";++    /**+     * gets existing client profiles in a realm as representation.+     * not return null.+     */+    public static ClientProfilesRepresentation getClientProfilesRepresentation(KeycloakSession session, RealmModel realm) throws ClientPolicyException {+        ClientProfilesRepresentation profilesRep = null;+        String profilesJson = null;++        // get existing profiles json+        if (realm != null) {+            profilesJson = session.clientPolicy().getClientProfilesJsonString(realm);+        } else {+            // if realm not specified, use builtin profiles set in keycloak's binary.+            profilesJson = session.clientPolicy().getClientProfilesOnKeycloakApp();+        }++        // deserialize existing profiles (json -> representation)+        if (profilesJson == null) {+            return new ClientProfilesRepresentation();+        }+        try {+            profilesRep = convertClientProfilesJsonToRepresentation(profilesJson);+        } catch (ClientPolicyException e) {+            throw new ClientPolicyException(e.getError(), e.getErrorDetail());+        }+        if (profilesRep == null) {+            return new ClientProfilesRepresentation();+        }++        return profilesRep;+    }++    /**+     * gets existing client profiles in a realm as model.+     * not return null.+     */+    public static Map<String, ClientProfileModel> getClientProfilesModel(KeycloakSession session, RealmModel realm) {+        // get existing profiles as json+        String profilesJson = session.clientPolicy().getClientProfilesJsonString(realm);+        if (profilesJson == null) {+            return Collections.emptyMap();+        }++        // deserialize existing profiles (json -> representation)+        ClientProfilesRepresentation profilesRep = null;+        try {+            profilesRep = convertClientProfilesJsonToRepresentation(profilesJson);+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} Failed to serialize client profiles json string. err={1}, errDetail={2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            return Collections.emptyMap();+        }+        if (profilesRep == null || profilesRep.getProfiles() == null) {+            return Collections.emptyMap();+        }++        // constructing existing profiles (representation -> model)+        Map<String, ClientProfileModel> profileMap = new HashMap<>();+        for (ClientProfileRepresentation profileRep : profilesRep.getProfiles()) {+            // ignore profile without name+            if (profileRep.getName() == null) {+                continue;+            }++            ClientProfileModel profileModel = new ClientProfileModel();+            profileModel.setName(profileRep.getName());+            profileModel.setDescription(profileRep.getDescription());+            if (profileRep.isBuiltin() != null) {+                profileModel.setBuiltin(profileRep.isBuiltin().booleanValue());+            } else {+                profileModel.setBuiltin(false);+            }++            if (profileRep.getExecutors() == null) {+                profileModel.setExecutors(new ArrayList<>());+                profileMap.put(profileRep.getName(), profileModel);+                continue;+            }++            List<Object> executors = new ArrayList<>();+            if (profileRep.getExecutors() != null) {+                profileRep.getExecutors().stream().forEach(obj->{+                    ObjectMapper mp = new ObjectMapper();","Is it possible to re-use some existing ObjectMapper? Ideally for example `JsonSerialization.mapper`? The instantiation of ObjectMapper has some performance costs as it is instantiating lots of other fasterxml common objects/factories under the covers.I see you used `new ObjectMapper()` in many places in this PR, so I suggest to fix all of them",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,598817852,2021-03-22T15:25:28Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/AbstractClientPoliciesTest.java,"@@ -558,195 +803,843 @@ protected void deleteClientDynamically(String clientId) throws ClientRegistratio         reg.oidc().delete(clientId);     } -    // Policy CRUD operation primitives+    // Client Profiles CRUD Operations++    protected static class ClientProfilesBuilder {+        private final ClientProfilesRepresentation profilesRep;++        public ClientProfilesBuilder() {+            profilesRep = new ClientProfilesRepresentation();+            profilesRep.setProfiles(new ArrayList<>());+        }++        public ClientProfilesBuilder addProfile(ClientProfileRepresentation rep) {+            profilesRep.getProfiles().add(rep);+            return this;+        }++        public ClientProfilesRepresentation toRepresentation() {+            return profilesRep;+        }++        public String toString() {+            ObjectMapper mapper = new ObjectMapper();+            String profilesJson = null;+            try {+                profilesJson = mapper.writeValueAsString(profilesRep);+            } catch (JsonProcessingException e) {+                e.printStackTrace();+                fail();+            }+            return profilesJson;+        }+    }++    protected static class ClientProfileBuilder {++        private final ClientProfileRepresentation profileRep;++        public ClientProfileBuilder() {+            profileRep = new ClientProfileRepresentation();+        }++        public ClientProfileBuilder createProfile(String name, String description, Boolean isBuiltin, List<Object> executors) {+            if (name != null) {+                profileRep.setName(name);+            }+            if (description != null) {+                profileRep.setDescription(description);+            }+            if (isBuiltin != null) {+                profileRep.setBuiltin(isBuiltin);+            } else {+                profileRep.setBuiltin(Boolean.FALSE);+            }+            if (executors != null) {+                profileRep.setExecutors(executors);+            } else {+                profileRep.setExecutors(new ArrayList<>());+            }+            return this;+        }++        public ClientProfileBuilder addExecutor(String providerId, Object config) {+            ObjectMapper mapper = new ObjectMapper();+            String configString = null;+            if (config == null) {+                configString = ""{}"";+            } else {+                try {+                    configString = mapper.writeValueAsString(config);+                } catch (JsonProcessingException e) {+                    fail();+                }+            }+            String executorJson = (new StringBuilder())+                    .append(""{\"""")+                    .append(providerId)+                    .append(""\"":"")+                    .append(configString)+                    .append(""}"")+                    .toString();+            JsonNode node = null;+            try {+                node = mapper.readTree(executorJson);+            } catch (JsonProcessingException e) {+                fail();+            }+            profileRep.getExecutors().add(node);+            return this;+        }++        public ClientProfileRepresentation toRepresentation() {+            return profileRep;+        }++        public String toString() {+            ObjectMapper mapper = new ObjectMapper();+            String profileJson = null;+            try {+                profileJson = mapper.writeValueAsString(profileRep);+            } catch (JsonProcessingException e) {+                e.printStackTrace();+                fail();+            }+            return profileJson;+        }+    }++    // Client Profiles - Executor CRUD Operations -    protected String createPolicy(String name, String providerId, String subType, List<String> conditions, List<String> executors) {-        ComponentRepresentation component = createComponentInstance(name, providerId, ClientPolicyProvider.class.getName(), subType);-        component.getConfig().put(DefaultClientPolicyProviderFactory.CONDITION_IDS, conditions);-        component.getConfig().put(DefaultClientPolicyProviderFactory.EXECUTOR_IDS, executors);-        return createComponent(component);+    protected Object createHolderOfKeyEnforceExecutorConfig(Boolean isArgument) {",Typo: should be `isAugment` . This applies to few other places on this class,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7815,599045734,2021-03-22T20:19:13Z,server-spi/src/main/java/org/keycloak/models/ClientProvider.java,"@@ -146,4 +146,12 @@ default ClientModel addClient(RealmModel realm, String clientId) {      * @param realm Realm.      */     void removeClients(RealmModel realm);++    /**+     * This function is called when a role is removed; this serves for removing references from clients to roles.+     *+     * @param realm Realm.+     * @param role Role which will be removed.+     */+    void preRemoveClientProvider(RealmModel realm, RoleModel role);",Can this be plain `preRemove` similarly to other `preRemove` methods?,
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/7815,599339107,2021-03-23T07:54:27Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -587,6 +587,12 @@ public void preRemove(RealmModel realm, RoleModel role) {         // GroupProvider method implementation ends here     } +    @Override+    public void preRemoveClientProvider(RealmModel realm, RoleModel role) {+        String clientScopeMapping = JpaUtils.getTableNameForNativeQuery(""SCOPE_MAPPING"", em);+        em.createNativeQuery(""delete from "" + clientScopeMapping + "" where ROLE_ID = :role"").setParameter(""role"", role.getId()).executeUpdate();",I think it's not possible using a delete. The reason is that this table is a [collection table](https://github.com/keycloak/keycloak/blob/12.0.4/model/jpa/src/main/java/org/keycloak/models/jpa/entities/ClientEntity.java#L161-L164). It's the same that happens [with CHILD_ROLE a few lines above](https://github.com/keycloak/keycloak/blob/12.0.4/model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java#L350). I can use a named query to obtain the list of clients that have the scope mapping (that is done using an inner join) and perform the deletion (`deleteScopeMapping` method) one by one. I decided to do it this way because it is much better (one query instead of N+1) and because it was already done with the CHILD_ROLE. But if you prefer this I can change to that approach.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7842,599364662,2021-03-23T08:36:44Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -85,14 +85,16 @@ private void testConcurrency(BiConsumer<ExecutorService, Integer> taskCreator) t     public void testConcurrencyWithoutChildren() throws InterruptedException {         testConcurrency((s, i) -> s.submit(new CreateAndDeleteComponent(s, i))); -        assertThat(realm.components().query(realm.toRepresentation().getId(), TestProvider.class.getName()), Matchers.hasSize(0));+//        the purpose of this test is to test whether it finishes in time, consistency should be resolved by KEYCLOAK-XXXXX+//        assertThat(realm.components().query(realm.toRepresentation().getId(), TestProvider.class.getName()), Matchers.hasSize(0));","The comment will need improvement, there is not guaranteed that concurrent approach to components (and also to other entities, but we do not test other entities) in map store. The reason is that when we start several keycloak transactions at the same time there is race condition. In JPA database is taking care of it. I've consulted this test with @hmlnarik as he was the original author. The test was added mainly because there was slowness when components was added back then. We've agreed that the test should stay there to have test that the component creation finishes in certain amount of time. The data consistency should not be tested atm and the work needed to make it consistent should be tracked by jira (I have create it and put the link there). ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599408710,2021-03-23T09:38:13Z,services/src/main/java/org/keycloak/services/clientregistration/oidc/DescriptionConverter.java,"@@ -165,6 +165,10 @@ public static ClientRepresentation toInternal(KeycloakSession session, OIDCClien             configWrapper.setBackchannelLogoutRevokeOfflineTokens(clientOIDC.getBackchannelLogoutRevokeOfflineTokens());         } +        if (clientOIDC.getBackchannelTokenDeliveryMode() != null) {+            configWrapper.setBackchannelTokenDeliveryMode(clientOIDC.getBackchannelTokenDeliveryMode());","Shouldn't we throw an exception in case that unsupported token delivery mode is used? Accepting for example ""ping"" may indicate that Keycloak supports that, even if not.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599412656,2021-03-23T09:43:47Z,services/src/main/java/org/keycloak/services/clientregistration/oidc/DescriptionConverter.java,"@@ -270,6 +274,10 @@ public static OIDCClientRepresentation toExternalResponse(KeycloakSession sessio         response.setBackchannelLogoutSessionRequired(config.isBackchannelLogoutSessionRequired());         response.setBackchannelLogoutSessionRequired(config.getBackchannelLogoutRevokeOfflineTokens()); +        if (config.getBackchannelTokenDeliveryMode() != null) {+            response.setBackchannelTokenDeliveryMode(config.getBackchannelTokenDeliveryMode());+        }+         List<ProtocolMapperRepresentation> foundPairwiseMappers = PairwiseSubMapperUtils.getPairwiseSubMappers(client);         SubjectType subjectType = foundPairwiseMappers.isEmpty() ? SubjectType.PUBLIC : SubjectType.PAIRWISE;         response.setSubjectType(subjectType.toString().toLowerCase());","@tnorimat @pedroigor Comment to DescriptionConverter.getOIDCGrantTypes: According to the specification https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#registration, there is this: `When using the ping or poll mode, the Client MUST include the CIBA grant type in the ""grant_types"" field.` . However we don't include it here. For example for Device Grant, we correctly include the device grant type based on whether the device grant is enabled for client or not.Related question: For CIBA, we don't have switch for the client to specify if CIBA grant type is enabled for the client or not. Shouldn't we have this switch similarly like we have it for the Device Grant? It seems to me that yes. For example see the example from the end of the section https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#registration . This registration request specifies that CIBA is required (and only supported) grant type for this client. IMO we should allow to convert such registration request to the Keycloak client, which will have only CIBA grant allowed and not any other grant types. Hence I suggest, we should also change the DescriptionConverter.toInternal to propagate the OIDC ""grant_types"" field to enable CIBA for the client in case that CIBA grant type is enabled.Related note for device grant: I've just noticed that in DescriptionConverter.toInternal, for some reason we missed to convert OIDC device grant type to the switch for enabling device grant for the client. I suggest we fix this as well when we're at this (or maybe we can create separate JIRA for it?)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599414290,2021-03-23T09:45:58Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCAdvancedConfigWrapper.java,"@@ -220,6 +220,14 @@ public void setBackchannelLogoutRevokeOfflineTokens(boolean backchannelLogoutRev         setAttribute(OIDCConfigAttributes.BACKCHANNEL_LOGOUT_REVOKE_OFFLINE_TOKENS, val);     } +    public String getBackchannelTokenDeliveryMode() {","@pedroigor Should this switch be moved to the CibaConfig? Not a big deal, but I've noticed that you added client-specific switches to the OAuth2DeviceConfig class. Hence I wonder if CIBA client-specific switches should be also moved there to align with device grant?Same might apply to the client switch for ""CIBA Enabled"" if we add it (See my comment in the DescriptionConverter class)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599414854,2021-03-23T09:46:47Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/CibaEndpoint.java,"@@ -0,0 +1,96 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import javax.ws.rs.Path;++import org.jboss.resteasy.spi.ResteasyProviderFactory;+import org.keycloak.events.EventBuilder;+import org.keycloak.models.KeycloakSession;+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;+import org.keycloak.protocol.oidc.ext.OIDCExtProviderFactory;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class CibaEndpoint implements OIDCExtProvider, OIDCExtProviderFactory {","My vote is to rename this class to something like ""CibaRootEndpoint"" or ""CibaExtEndpoint"" . CibaEndpoint implies to me that it inherits from ""AbstractCibaEndpoint"", which is not the case. But maybe it is just me.. I don't have strong opinion in regards to this one...:)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599419016,2021-03-23T09:52:13Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java,"@@ -0,0 +1,243 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.Collections;+import java.util.Optional;++import com.fasterxml.jackson.databind.node.ObjectNode;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.Profile;+import org.keycloak.common.util.Time;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.CibaConfig;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;+import org.keycloak.util.JsonSerialization;+import org.keycloak.utils.ProfileHelper;++public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {++    private final RealmModel realm;++    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+        this.realm = session.getContext().getRealm();+        event.event(EventType.LOGIN);+    }++    @POST+    @NoCache+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processGrantRequest(@Context HttpRequest httpRequest) {+        ProfileHelper.requireFeature(Profile.Feature.CIBA);+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());++        try {+            String authReqId = request.serialize(session);+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);++            if (provider == null) {+                throw new RuntimeException(""Authentication Channel Provider not found."");+            }++            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);++            if (resolver == null) {+                throw new RuntimeException(""CIBA Login User Resolver not setup properly."");+            }++            UserModel user = request.getUser();++            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);++            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {+                CibaConfig cibaPolicy = realm.getCibaPolicy();+                int poolingInterval = cibaPolicy.getPoolingInterval();++                storeAuthenticationRequest(request, cibaPolicy);++                ObjectNode response = JsonSerialization.createObjectNode();++                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());++                if (poolingInterval > 0) {+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);+                }++                return Response.ok(JsonSerialization.writeValueAsBytes(response))+                        .build();+            }+        } catch (Exception e) {+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Failed to send authentication request"", Response.Status.SERVICE_UNAVAILABLE);+        }++        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Unexpected response from authentication device"", Response.Status.SERVICE_UNAVAILABLE);+    }++    /**+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case+     * that relies on cross-references for unsolicited user authentication requests from devices.+     */+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {+        ClientModel client = request.getClient();+        int expiresIn = cibaConfig.getExpiresIn();+        int poolingInterval = cibaConfig.getPoolingInterval();++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,+                Collections.emptyMap());+        String authResultId = request.getAuthResultId();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),+                authResultId);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + poolingInterval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);++        store.put(deviceCode, userCode, lifespanSeconds);+    }++    private AuthenticationRequest authorizeClient(MultivaluedMap<String, String> params) {+        ClientModel client = authenticateClient();+        UserModel user = resolveUser(params, realm.getCibaPolicy().getAuthRequestedUserHint());++        AuthenticationRequest request = new AuthenticationRequest(session, user, client);++        request.setClient(client);++        String scope = params.getFirst(OAuth2Constants.SCOPE);++        if (scope == null)+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, ""missing parameter : scope"",+                    Response.Status.BAD_REQUEST);++        request.setScope(scope);++        request.setBindingMessage(params.getFirst(CibaGrantType.BINDING_MESSAGE));++        CibaConfig policy = realm.getCibaPolicy();++        // create JWE encoded auth_req_id from Auth Req ID.+        Integer expiresIn = policy.getExpiresIn();+        String requestedExpiry = params.getFirst(CibaGrantType.REQUESTED_EXPIRY);++        if (requestedExpiry != null) {+            expiresIn = Integer.valueOf(requestedExpiry);+        }++        request.exp(Time.currentTime() + expiresIn.longValue());++        StringBuilder scopes = new StringBuilder(Optional.ofNullable(request.getScope()).orElse(""""));+        client.getClientScopes(true, true)+                .forEach((key, value) -> {+                    if (value.isDisplayOnConsentScreen())+                        scopes.append("" "").append(value.getName());+                });+        request.setScope(scopes.toString());++        String clientNotificationToken = params.getFirst(CibaGrantType.CLIENT_NOTIFICATION_TOKEN);++        if (clientNotificationToken != null) {+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST,+                    ""Ping and push modes not supported. Use poll mode instead."", Response.Status.BAD_REQUEST);+        }++        String userCode = params.getFirst(OAuth2Constants.USER_CODE);++        if (userCode != null) {+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, ""User code not supported"",+                    Response.Status.BAD_REQUEST);+        }++        String acrValues = params.getFirst(OAuth2Constants.ACR_VALUES);++        if (acrValues != null) {","@tnorimat @pedroigor I have one minor concern regarding ""acr_values"" . Keycloak currently doesn't properly support this parameter inside Keycloak authentication flows. However in the case of CIBA, Keycloak delegates authentication to the authentication channel to happen outside of Keycloak. Hence I wonder if we should allow this ""acr_parameter"" and include it via the HttpAuthenticationChannelProvider.requestAuthentication for the case that authentication channel supports it?Alternatively to sending acr_values to the channel provider, I think we can also support to have more AuthenticationChannelProvider implementations and Keycloak can decide which AuthenticationChannelProvider to use based on the ""acr_values"" parameter. At least, that is my understanding how it could work based on the specification https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_server_obtains_consent . See especially this comment in the specs `After the OP has validated the Authentication Request, the OP identifies the user and chooses a channel to best authenticate the user and authorize the request, in line with the Client's requests regarding acr_values.` .This support for `acr_values` is not a blocker for this PR IMO, just something to consider...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599421026,2021-03-23T09:55:03Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java,"@@ -0,0 +1,172 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.jboss.resteasy.util.HttpHeaderNames;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;++public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {++    public static final String SUCCEEDED = ""succeeded"";+    public static final String UNAUTHORIZED = ""unauthorized"";+    public static final String CANCELLED = ""cancelled"";++    @Context+    private HttpRequest httpRequest;++    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+    }++    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processAuthenticationChannelResult() {","@tnorimat @pedroigor AFAIK this endpoint contains lots of proprietary non-standard CIBA parameters specific to the particular authentication channel. For example parameters like `authentication_channel_id` or `auth_result` . In this regards, I am not sure if it rather makes sense to move some parts regarding to parsing this request to the HttpAuthenticationChannelProvider?My understanding is, that it might be ideal if implemetation of the AuthenticationChannelProvider contains all the stuff related to the ""proprietary"" part of the CIBA protocol for the communication between Keycloak server and Authentication Channel. In this regards, I vote for add the ""callback"" method to AuthenticationChannelProvider interface and implement the processing of the callback request inside AuthenticationChannelPRovider. So that if someone wants to introduce the custom protocol for the communication between Keycloak and Authentication Channel, he just needs to implement his own AuthenticationChannelProvider. Not also the callback endpoint, which is currently implemented in the BackchannelAuthenticationCallbackEndpoint. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599424323,2021-03-23T09:59:26Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java,"@@ -0,0 +1,172 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.jboss.resteasy.util.HttpHeaderNames;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;++public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {++    public static final String SUCCEEDED = ""succeeded"";+    public static final String UNAUTHORIZED = ""unauthorized"";+    public static final String CANCELLED = ""cancelled"";++    @Context+    private HttpRequest httpRequest;++    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+    }++    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processAuthenticationChannelResult() {+        event.event(EventType.LOGIN);++        authenticateClient();","@tnorimat @pedroigor Sorry for the dummy question (as maybe it is my lack of understanding protocol), but does BackchannelAuthenticationCallbackEndpoint really needs client authentication? My understanding is, that this endpoint is usually invoked by the ""Authentication Channel"" once it completes the authentication of the user with the authentication device. And the ""Authentication Channel"" won't have access to client credentials?If it is the client, which is supposed to send the request to callback endpoint, then there won't be a need for the polling mechanism described in the CIBA specification. IMO the whole point of polling mechanism is, that client doesn't know when exactly is authentication between user and authentication channel finished.My understanding is, that this Keycloak endpoint is able to parse the JWE sent in the `authentication_channel_id` parameter and IMO this is the verification that HTTP request to this endpoint was sent from the real authentication channel (the one implemented by the HttpAuthenticationChannelProvider). Hence no point for client authentication in this endpoint. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599426081,2021-03-23T10:01:55Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/AuthenticationRequest.java,"@@ -0,0 +1,181 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import javax.crypto.SecretKey;+import java.io.UnsupportedEncodingException;++import com.fasterxml.jackson.annotation.JsonIgnore;+import org.keycloak.OAuth2Constants;+import org.keycloak.crypto.Algorithm;+import org.keycloak.crypto.KeyUse;+import org.keycloak.crypto.SignatureProvider;+import org.keycloak.crypto.SignatureSignerContext;+import org.keycloak.jose.jwe.JWEException;+import org.keycloak.jose.jws.JWSBuilder;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.representations.IDToken;+import org.keycloak.representations.JsonWebToken;++import com.fasterxml.jackson.annotation.JsonProperty;+import org.keycloak.services.Urls;+import org.keycloak.util.TokenUtil;++/**+ * <p>Represents an authentication request sent by a consumption device.+ *+ * <p>A authentication request can be serialized to a JWE so that they can be exchanged with authentication devices to communicate+ * and authorize the authentication request made by consumption devices.+ */+public class AuthenticationRequest extends JsonWebToken {","Minor: I vote to rename this class to CIBAAuthenticationRequest. We already have class ""AuthenticationRequest"" used by brokering, so it may help to avoid some confusions. In theory package name differentiation should be sufficient, but still sometimes the confusion can easily happen for the duplicated class names. But maybe it is just me... :-)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599426312,2021-03-23T10:02:12Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/AuthenticationRequest.java,"@@ -0,0 +1,181 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import javax.crypto.SecretKey;+import java.io.UnsupportedEncodingException;++import com.fasterxml.jackson.annotation.JsonIgnore;+import org.keycloak.OAuth2Constants;+import org.keycloak.crypto.Algorithm;+import org.keycloak.crypto.KeyUse;+import org.keycloak.crypto.SignatureProvider;+import org.keycloak.crypto.SignatureSignerContext;+import org.keycloak.jose.jwe.JWEException;+import org.keycloak.jose.jws.JWSBuilder;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.representations.IDToken;+import org.keycloak.representations.JsonWebToken;++import com.fasterxml.jackson.annotation.JsonProperty;+import org.keycloak.services.Urls;+import org.keycloak.util.TokenUtil;++/**+ * <p>Represents an authentication request sent by a consumption device.+ *+ * <p>A authentication request can be serialized to a JWE so that they can be exchanged with authentication devices to communicate+ * and authorize the authentication request made by consumption devices.+ */+public class AuthenticationRequest extends JsonWebToken {++    /**+     * Deserialize the given {@code jwe} to a {@link AuthenticationRequest} instance.+     *+     * @param session the session+     * @param jwe the authentication request in JWE format.+     * @return the authentication request instance+     * @throws Exception+     */+    public static AuthenticationRequest deserialize(KeycloakSession session, String jwe) {+        SecretKey aesKey = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.ENC, Algorithm.AES).getSecretKey();+        SecretKey hmacKey = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.SIG, Algorithm.HS256).getSecretKey();++        try {+            byte[] contentBytes = TokenUtil.jweDirectVerifyAndDecode(aesKey, hmacKey, jwe);+            jwe = new String(contentBytes, ""UTF-8"");+        } catch (JWEException | UnsupportedEncodingException e) {+            throw new RuntimeException(""Error decoding auth_req_id."", e);+        }++        return session.tokens().decode(jwe, AuthenticationRequest.class);+    }++    public static final String SESSION_STATE = IDToken.SESSION_STATE;+    public static final String AUTH_RESULT_ID = ""auth_result_id"";++    @JsonProperty(OAuth2Constants.SCOPE)+    protected String scope;++    @JsonProperty(SESSION_STATE)+    protected String sessionState;","The ""sessionState"" is not used at all in the AuthenticationRequest. It is always null. Should we remove this parameter?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7780,599427942,2021-03-23T10:04:31Z,services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java,"@@ -158,4 +176,262 @@ private void execute(         void run(ClientPolicyExecutorProvider executor) throws ClientPolicyException;     } ++    // Client Polices Realm Attributes Keys+    public static final String CLIENT_PROFILES = ""client-policies.profiles"";+    public static final String CLIENT_POLICIES = ""client-policies.policies"";++    // builtin profiles and policies are loaded on booting keycloak at once.+    // therefore, their representations are kept and remain unchanged.+    // these are shared among all realms.++    // those can be null to show that no profile/policy exist+    private static String builtinClientProfilesJson;+    private static String builtinClientPoliciesJson;++    @Override+    public void setupClientPoliciesOnKeycloakApp(String profilesFilePath, String policiesFilePath) {+        ClientPolicyLogger.logv(logger, ""{0} :: LOAD BUILTIN PROFILE POLICIES ON KEYCLOAK"", logMsgPrefix());++        // client profile can be referred from client policy so that client profile needs to be loaded at first.+        // load builtin profiles on keycloak app+        ClientProfilesRepresentation validatedProfilesRep = null;+        try {+            validatedProfilesRep = ClientPoliciesUtil.getValidatedBuiltinClientProfilesRepresentation(session, getClass().getResourceAsStream(profilesFilePath));+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: LOAD BUILTIN PROFILES ON KEYCLOAK FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            return;+        }++        String validatedJson = null;+        try {+            validatedJson = ClientPoliciesUtil.convertClientProfilesRepresentationToJson(validatedProfilesRep);+        } catch (ClientPolicyException cpe) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE BUILTIN PROFILES ON KEYCLOAK FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, cpe.getError(), cpe.getErrorDetail());+            return;+        }++        builtinClientProfilesJson = validatedJson;++        // load builtin policies on keycloak app+        ClientPoliciesRepresentation validatedPoliciesRep = null;+        try {+            validatedPoliciesRep = ClientPoliciesUtil.getValidatedBuiltinClientPoliciesRepresentation(session, getClass().getResourceAsStream(policiesFilePath));+        } catch (ClientPolicyException cpe) {+            logger.warnv(""{0} :: LOAD BUILTIN POLICIES ON KEYCLOAK FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, cpe.getError(), cpe.getErrorDetail());+            builtinClientProfilesJson = null;+            return;+        }++        validatedJson = null;+        try {+            validatedJson = ClientPoliciesUtil.convertClientPoliciesRepresentationToJson(validatedPoliciesRep);+        } catch (ClientPolicyException cpe) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE BUILTIN POLICIES ON KEYCLOAK FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, cpe.getError(), cpe.getErrorDetail());+            builtinClientProfilesJson = null;+            return;+        }++        builtinClientPoliciesJson = validatedJson;+    }++    @Override+    public void setupClientPoliciesOnCreatedRealm(RealmModel realm) {+        ClientPolicyLogger.logv(logger, ""{0} :: LOAD BUILTIN PROFILE POLICIES ON CREATED REALM :: realm = {1}"", logMsgPrefix(), realm.getName());++        // put already loaded builtin profiles/policies on keycloak app to newly created realm+        setClientProfilesJsonString(realm, builtinClientProfilesJson);+        setClientPoliciesJsonString(realm, builtinClientPoliciesJson);+    }++    @Override+    public void setupClientPoliciesOnImportedRealm(RealmModel realm, RealmRepresentation rep) {+        ClientPolicyLogger.logv(logger, ""{0} :: LOAD PROFILE POLICIES ON IMPORTED REALM :: realm = {1}"", logMsgPrefix(), realm.getName());++        // put already loaded builtin profiles/policies on keycloak app to newly created realm+        setClientProfilesJsonString(realm, builtinClientProfilesJson);+        setClientPoliciesJsonString(realm, builtinClientPoliciesJson);++        // merge imported polices/profiles with builtin policies/profiles+        String validatedJson = null;+        try {+            validatedJson = ClientPoliciesUtil.getValidatedClientProfilesJson(session, realm, rep.getClientProfiles());+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE IMPORTED REALM PROFILES FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            // revert to builtin profiles+            validatedJson = builtinClientProfilesJson;+        }+        setClientProfilesJsonString(realm, validatedJson);++        try {+            validatedJson = ClientPoliciesUtil.getValidatedClientPoliciesJson(session, realm, rep.getClientPolicies());+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE IMPORTED REALM POLICIES FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            // revert to builtin profiles+            validatedJson = builtinClientPoliciesJson;+        }+        setClientPoliciesJsonString(realm, validatedJson);+    }++    @Override+    public void updateClientProfiles(RealmModel realm, String json) throws ClientPolicyException {+        ClientPolicyLogger.logv(logger, ""{0} :: UPDATE PROFILES :: realm = {1}, PUT = {2}"", logMsgPrefix(), realm.getName(), json);+        String validatedJsonString = null;+        try {+            validatedJsonString = getValidatedClientProfilesJson(realm, json);+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE PROFILES FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            throw e;+        }+        setClientProfilesJsonString(realm, validatedJsonString);+        ClientPolicyLogger.logv(logger, ""{0} :: UPDATE PROFILES :: realm = {1}, validated and modified PUT = {2}"", logMsgPrefix(), realm.getName(), validatedJsonString);+    }++    @Override+    public String getClientProfiles(RealmModel realm) {+        String json = getClientProfilesJsonString(realm);+        ClientPolicyLogger.logv(logger, ""{0} :: GET PROFILES :: realm = {1}, GET = {2}"", logMsgPrefix(), realm.getName(), json);+        return json;+    }++    @Override+    public void updateClientPolicies(RealmModel realm, String json) throws ClientPolicyException {+        ClientPolicyLogger.logv(logger, ""{0} :: UPDATE POLICIES :: realm = {1}, PUT = {2}"", logMsgPrefix(), realm.getName(), json);+        String validatedJsonString = null;+        try {+            validatedJsonString = getValidatedClientPoliciesJson(realm, json);+        } catch (ClientPolicyException e) {+            logger.warnv(""{0} :: VALIDATE SERIALIZE POLICIES FAILED :: error = {1}, error detail = {2}"", LOGMSG_PREFIX, e.getError(), e.getErrorDetail());+            throw e;+        }+        setClientPoliciesJsonString(realm, validatedJsonString);+        ClientPolicyLogger.logv(logger, ""{0} :: UPDATE POLICIES :: realm = {1}, validated and modified PUT = {2}"", logMsgPrefix(), realm.getName(), validatedJsonString);+    }++    @Override+    public void setupClientPoliciesOnExportingRealm(RealmModel realm, RealmRepresentation rep) {+        // client profiles  that filter out builtin profiles..+        ClientProfilesRepresentation filteredOutProfiles = null;+        try {+            filteredOutProfiles = getClientProfilesForExport(realm);+        } catch (ClientPolicyException e) {+            // set as null+        }+        rep.setClientProfiles(filteredOutProfiles);++        // client policies that filter out builtin and policies.+        ClientPoliciesRepresentation filteredOutPolicies = null;+        try {+            filteredOutPolicies = getClientPoliciesForExport(realm);+        } catch (ClientPolicyException e) {+            // set as null+        }+        rep.setClientPolicies(filteredOutPolicies);+    }++    @Override+    public String getClientPolicies(RealmModel realm) {+        String json = getClientPoliciesJsonString(realm);+        ClientPolicyLogger.logv(logger, ""{0} :: GET POLICIES :: realm = {1}, GET = {2}"", logMsgPrefix(), realm.getName(), json);+        return json;+    }++    @Override+    public String getClientProfilesOnKeycloakApp() {+        return builtinClientProfilesJson;+    }++    @Override+    public String getClientPoliciesOnKeycloakApp() {+        return builtinClientPoliciesJson;+    }++    @Override+    public String getClientProfilesJsonString(RealmModel realm) {+        return realm.getAttribute(CLIENT_PROFILES);+    }++    @Override+    public String getClientPoliciesJsonString(RealmModel realm) {+        return realm.getAttribute(CLIENT_POLICIES);+    }++    private void setClientProfilesJsonString(RealmModel realm, String json) {+        realm.setAttribute(CLIENT_PROFILES, json);+    }++    private void setClientPoliciesJsonString(RealmModel realm, String json) {+        realm.setAttribute(CLIENT_POLICIES, json);+    }++    private String getValidatedClientProfilesJson(RealmModel realm, String profilesJson) throws ClientPolicyException {+        ClientProfilesRepresentation validatedProfilesRep = null;+        try {+            validatedProfilesRep = ClientPoliciesUtil.getValidatedClientProfilesRepresentation(session, realm, profilesJson);+        } catch (ClientPolicyException e) {","@mposolda I think what you pointed out is doing the same thing twice semantically, namely constructing `ClientPolicyException` in `ClientPoliciesUtil.getValidatedClientProfilesRepresentation` and re-constructing this exception as the same contents by the caller of this method.I agree with your suggestion. I will remove this try/catch block.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599430868,2021-03-23T10:08:09Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/CIBATest.java,"@@ -0,0 +1,1196 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.client;++import static org.hamcrest.Matchers.equalTo;+import static org.hamcrest.Matchers.is;+import static org.hamcrest.Matchers.containsString;++import javax.ws.rs.core.Response.Status;++import org.apache.http.client.methods.CloseableHttpResponse;++import static org.junit.Assert.assertThat;+import static org.keycloak.OAuthErrorException.INVALID_REQUEST;+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.CANCELLED;+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.SUCCEEDED;+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.UNAUTHORIZED;+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.QUARKUS;+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.REMOTE;++import java.io.IOException;+import java.util.Collections;+import java.util.HashMap;+import java.util.Map;+import java.util.Optional;++import org.hamcrest.CoreMatchers;+import org.junit.Assert;+import org.junit.BeforeClass;+import org.junit.Ignore;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.admin.client.resource.ClientResource;+import org.keycloak.common.Profile;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventType;+import org.keycloak.models.CibaConfig;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProviderFactory;+import org.keycloak.representations.AccessToken;+import org.keycloak.representations.IDToken;+import org.keycloak.representations.RefreshToken;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.representations.oidc.TokenMetadataRepresentation;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;+import org.keycloak.testsuite.arquillian.annotation.EnableCiba;+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;+import org.keycloak.testsuite.ciba.AuthenticationChannelRequest;+import org.keycloak.testsuite.client.resources.TestApplicationResourceUrls;+import org.keycloak.testsuite.client.resources.TestOIDCEndpointsApplicationResource;+import org.keycloak.testsuite.util.KeycloakModelUtils;+import org.keycloak.testsuite.util.Matchers;+import org.keycloak.testsuite.util.OAuthClient;+import org.keycloak.testsuite.util.UserBuilder;+import org.keycloak.testsuite.util.OAuthClient.AuthenticationRequestAcknowledgement;++import com.fasterxml.jackson.databind.JsonNode;+import com.fasterxml.jackson.databind.ObjectMapper;+import org.keycloak.testsuite.util.WaitUtils;++@EnableCiba+@EnableFeature(value = Profile.Feature.CIBA, skipRestart = true)+@AuthServerContainerExclude({REMOTE, QUARKUS})+public class CIBATest extends AbstractTestRealmKeycloakTest {++    private final String AUTHENTICATION_CHANNEL_SERVER_NAME = ""authentication-channel-server"";+    private final String AUTHENTICATION_CHANNEL_SERVER_PASSWORD = ""passwort-authentication-channel-server"";++    @Rule+    public AssertEvents events = new AssertEvents(this);++    @Override+    public void configureTestRealm(RealmRepresentation testRealm) {++        UserRepresentation user = UserBuilder.create()+                .username(""nutzername-schwarz"")+                .email(""schwarz@test.example.com"")+                .enabled(true)+                .password(""passwort-schwarz"")+                .addRoles(""user"", ""offline_access"")+                .build();+        testRealm.getUsers().add(user);++        user = UserBuilder.create()+                .username(""nutzername-rot"")+                .email(""rot@test.example.com"")+                .enabled(true)+                .password(""passwort-rot"")+                .addRoles(""user"", ""offline_access"")+                .build();+        testRealm.getUsers().add(user);++        user = UserBuilder.create()+                .username(""nutzername-gelb"")+                .email(""gelb@test.example.com"")+                .enabled(true)+                .password(""passwort-gelb"")+                .addRoles(""user"", ""offline_access"")+                .build();+        testRealm.getUsers().add(user);++        user = UserBuilder.create()+                .username(""nutzername-deaktiviert"")+                .email(""deaktiviert@test.example.com"")+                .enabled(false)+                .password(""passwort-deaktiviert"")+                .addRoles(""user"", ""offline_access"")+                .build();+        testRealm.getUsers().add(user);++        ClientRepresentation confApp = KeycloakModelUtils.createClient(testRealm, AUTHENTICATION_CHANNEL_SERVER_NAME);+        confApp.setSecret(AUTHENTICATION_CHANNEL_SERVER_PASSWORD);+        confApp.setServiceAccountsEnabled(Boolean.TRUE);++    }++    @BeforeClass+    public static void setAuthenticationChannelRequestUri() {+        System.setProperty(""keycloak.ciba.auth.channel.provider"", HttpAuthenticationChannelProviderFactory.PROVIDER_ID);+        System.setProperty(""keycloak.ciba.http.auth.channel.uri"", TestApplicationResourceUrls.clientAuthenticationChannelRequestUri());+    }++    private String cibaBackchannelTokenDeliveryMode;+    private Integer cibaExpiresIn;+    private Integer cibaInterval;+    private String cibaAuthRequestedUserHint;++    private final String TEST_REALM_NAME = ""test"";+    private final String TEST_CLIENT_NAME = ""test-app"";+    private final String TEST_CLIENT_PASSWORD = ""password"";++    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String username) throws Exception {+        return doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, null);+    }++    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String clientId, String clientSecret, String username, String bindingMessage) throws Exception {+        AuthenticationRequestAcknowledgement response = oauth.doBackchannelAuthenticationRequest(clientId, clientSecret, username, bindingMessage);+        Assert.assertThat(response.getStatusCode(), is(equalTo(200)));+        Assert.assertNotNull(response.getAuthReqId());+        return response;+    }++    private AuthenticationChannelRequest doAuthenticationChannelRequest() {+        // get Authentication Channel Request keycloak has done on Backchannel Authentication Endpoint from the FIFO queue of testing Authentication Channel Request API+        TestOIDCEndpointsApplicationResource oidcClientEndpointsResource = testingClient.testApp().oidcClientEndpoints();+        AuthenticationChannelRequest authenticationChannelReq = oidcClientEndpointsResource.getAuthenticationChannel();+        return authenticationChannelReq;+    }++    private EventRepresentation doAuthenticationChannelCallback(AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {+        return doAuthenticationChannelCallback(TEST_CLIENT_NAME, authenticationChannelReq, authenticationChannelStatus, username);+    }++    private EventRepresentation doAuthenticationChannelCallback(String clientIdAsConsumerDevice, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);+        Assert.assertThat(statusCode, is(equalTo(200)));+        // check login event : ignore user id and other details except for username+        EventRepresentation representation = new EventRepresentation();++        representation.setDetails(Collections.emptyMap());++        return representation;+    }++    private EventRepresentation doAuthenticationChannelCallback(String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);+        Assert.assertThat(statusCode, is(equalTo(200)));+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();+    }++    private EventRepresentation doAuthenticationChannelCallbackError(Status status, String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);+        Assert.assertThat(statusCode, is(equalTo(status.getStatusCode())));+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();+    }++    private OAuthClient.AccessTokenResponse doBackchannelAuthenticationTokenRequest(String codeId, String sessionId, String username, String authReqId, boolean isOfflineAccess) throws Exception {+        return doBackchannelAuthenticationTokenRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, codeId, sessionId, username, authReqId, isOfflineAccess);+    }++    private OAuthClient.AccessTokenResponse doBackchannelAuthenticationTokenRequest(String clientId, String clientSecret, String codeId, String sessionId, String username, String authReqId, boolean isOfflineAccess) throws Exception {+        OAuthClient.AccessTokenResponse tokenRes = oauth.doBackchannelAuthenticationTokenRequest(clientId, clientSecret, authReqId);+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(200)));+        EventRepresentation event = events.expectAuthReqIdToToken(codeId, sessionId).clearDetails().user(AssertEvents.isUUID()).client(clientId).assertEvent();++        AccessToken accessToken = oauth.verifyToken(tokenRes.getAccessToken());+        Assert.assertThat(accessToken.getIssuedFor(), is(equalTo(clientId)));++        RefreshToken refreshToken = oauth.parseRefreshToken(tokenRes.getRefreshToken());+        Assert.assertThat(refreshToken.getIssuedFor(), is(equalTo(clientId)));+        Assert.assertThat(refreshToken.getAudience()[0], is(equalTo(refreshToken.getIssuer())));++        IDToken idToken = oauth.verifyIDToken(tokenRes.getIdToken());+        Assert.assertThat(idToken.getPreferredUsername(), is(equalTo(username)));+        Assert.assertThat(idToken.getIssuedFor(), is(equalTo(clientId)));+        Assert.assertThat(idToken.getAudience()[0], is(equalTo(idToken.getIssuedFor())));++        return tokenRes;+    }++    private String doIntrospectAccessTokenWithClientCredential(OAuthClient.AccessTokenResponse tokenRes, String username) throws IOException {+        String tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getAccessToken());+        ObjectMapper objectMapper = new ObjectMapper();+        JsonNode jsonNode = objectMapper.readTree(tokenResponse);+        Assert.assertThat(jsonNode.get(""active"").asBoolean(), is(equalTo(true)));+        Assert.assertThat(jsonNode.get(""username"").asText(), is(equalTo(username)));+        Assert.assertThat(jsonNode.get(""client_id"").asText(), is(equalTo(TEST_CLIENT_NAME)));+        TokenMetadataRepresentation rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);+        Assert.assertThat(rep.isActive(), is(equalTo(true)));+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();++        tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getRefreshToken());+        jsonNode = objectMapper.readTree(tokenResponse);+        Assert.assertThat(jsonNode.get(""active"").asBoolean(), is(equalTo(true)));+        Assert.assertThat(jsonNode.get(""client_id"").asText(), is(equalTo(TEST_CLIENT_NAME)));+        rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);+        Assert.assertThat(rep.isActive(), is(equalTo(true)));+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));+        Assert.assertThat(rep.getAudience()[0], is(equalTo(rep.getIssuer())));+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();++        tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getIdToken());+        jsonNode = objectMapper.readTree(tokenResponse);+        Assert.assertThat(jsonNode.get(""active"").asBoolean(), is(equalTo(true)));+        Assert.assertThat(jsonNode.get(""client_id"").asText(), is(equalTo(TEST_CLIENT_NAME)));+        rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);+        Assert.assertThat(rep.isActive(), is(equalTo(true)));+        Assert.assertThat(rep.getUserName(), is(equalTo(username)));+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));+        Assert.assertThat(rep.getPreferredUsername(), is(equalTo(username)));+        Assert.assertThat(rep.getAudience()[0], is(equalTo(rep.getIssuedFor())));+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();++        return tokenResponse;+    }++    private OAuthClient.AccessTokenResponse doRefreshTokenRequest(String oldRefreshToken, String username, String sessionId, boolean isOfflineAccess) {+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(oldRefreshToken, TEST_CLIENT_PASSWORD);+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(200)));++        AccessToken accessToken = oauth.verifyToken(tokenRes.getAccessToken());+        Assert.assertThat(accessToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));+        Assert.assertThat(accessToken.getExp().longValue(), is(equalTo(accessToken.getIat().longValue() + tokenRes.getExpiresIn())));++        RefreshToken refreshToken = oauth.parseRefreshToken(tokenRes.getRefreshToken());+        Assert.assertThat(refreshToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));+        Assert.assertThat(refreshToken.getAudience()[0], is(equalTo(refreshToken.getIssuer())));+        if(!isOfflineAccess) Assert.assertThat(refreshToken.getExp().longValue(), is(equalTo(refreshToken.getIat().longValue() + tokenRes.getRefreshExpiresIn())));++        IDToken idToken = oauth.verifyIDToken(tokenRes.getIdToken());+        Assert.assertThat(idToken.getPreferredUsername(), is(equalTo(username)));+        Assert.assertThat(idToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));+        Assert.assertThat(idToken.getAudience()[0], is(equalTo(idToken.getIssuedFor())));+        Assert.assertThat(idToken.getExp().longValue(), is(equalTo(idToken.getIat().longValue() + tokenRes.getExpiresIn())));++        events.expectRefresh(tokenRes.getRefreshToken(), sessionId).session(CoreMatchers.notNullValue(String.class)).user(AssertEvents.isUUID()).clearDetails().assertEvent();++        return tokenRes;+    }++    private EventRepresentation doLogoutByRefreshToken(String refreshToken, String sessionId, String userId, boolean isOfflineAccess) throws IOException{+        try (CloseableHttpResponse res = oauth.doLogout(refreshToken, TEST_CLIENT_PASSWORD)) {+            assertThat(res, Matchers.statusCodeIsHC(Status.NO_CONTENT));+        }++        // confirm logged out+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(refreshToken, TEST_CLIENT_PASSWORD);+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(400)));+        Assert.assertThat(tokenRes.getError(), is(equalTo(OAuthErrorException.INVALID_GRANT)));+        if (isOfflineAccess) Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(""Offline user session not found"")));+        else Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(""Session not active"")));++        return events.expectLogout(sessionId).client(TEST_CLIENT_NAME).user(AssertEvents.isUUID()).session(AssertEvents.isUUID()).clearDetails().assertEvent();+    }++    private EventRepresentation doTokenRevokeByRefreshToken(String refreshToken, String sessionId, String userId, boolean isOfflineAccess) throws IOException{+        try (CloseableHttpResponse res = oauth.doTokenRevoke(refreshToken, ""refresh_token"", TEST_CLIENT_PASSWORD)) {+            assertThat(res, Matchers.statusCodeIsHC(Status.OK));+        }++        // confirm revocation+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(refreshToken, TEST_CLIENT_PASSWORD);+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(400)));+        Assert.assertThat(tokenRes.getError(), is(equalTo(OAuthErrorException.INVALID_GRANT)));+        if (isOfflineAccess) Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(""Offline user session not found"")));+        else Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(""Session not active"")));++        return events.expect(EventType.REVOKE_GRANT).clearDetails().client(TEST_CLIENT_NAME).user(AssertEvents.isUUID()).assertEvent();+    }++    private void testBackchannelAuthenticationFlow(boolean isOfflineAccess) throws Exception {+        ClientResource clientResource = null;+        ClientRepresentation clientRep = null;+        try {+            final String username = ""nutzername-rot"";+            final String bindingMessage = ""BASTION"";++            // prepare CIBA settings+            clientResource = ApiUtil.findClientByClientId(adminClient.realm(TEST_REALM_NAME), TEST_CLIENT_NAME);+            clientRep = clientResource.toRepresentation();+            prepareCIBASettings(clientResource, clientRep);+            if(isOfflineAccess) oauth.scope(OAuth2Constants.OFFLINE_ACCESS);++            // user Backchannel Authentication Request+            AuthenticationRequestAcknowledgement response = doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, bindingMessage);++            // user Authentication Channel Request+            AuthenticationChannelRequest authenticationChannelReq = doAuthenticationChannelRequest();","@tnorimat  @pedroigor This is only testsuite related concern, but my vote is that method ""doAuthenticationChannelRequest()"" accepts the bindingMessage as an argument and that the bindingMessage is sent to the testing endpoint. And also that the testing endpoint checks the ""bindingMessage"" equals to the previously saved request. This is minor testsuite related concern, but IMO it may help the ""newbie"" to understand CIBA protocols a bit better.In general, the CIBA protocol is quite hard to understand for the newbies IMO as there is big amount of various HTTP requests sent among various parties. And hence it helps a bit if the testsuite related requests are also a bit ""logical"" and represents the reality, which will be used by the CIBA protocol in production. And IMO in reality, the request from the user to AuthenticationChannel will need to contain the ""bindingMessage"" as in reality AuthenticationChannel can contain many different requests from different users and bindingMessage would be used to bind the request with the actual user. For same reason, I vote to change the BlockingQueue in the TestingOIDCEndpointsApplicationResource to be the Map where the key is the ""bindingMessage"" and the value the actual request. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7780,599451879,2021-03-23T10:37:55Z,quarkus/runtime/src/main/resources/keycloak-default-client-policies.json,"@@ -0,0 +1,18 @@+{+  ""policies"": [","Thanks for looking at this! Please let me know If you don't manage to figure this, I will try to help you more actively for this.Just as a hint, I would start with build quarkus keycloak distribution and debug it manually if it is possible to find the classes or not. It can be done by:```mvn clean install -DskipTests=true -Pdistribution,quarkus```Then in the `distribution/server-x-dist/target/keycloak.x-13.0.0-SNAPSHOT.zip` you have the built server. When you unpack it and run with the `./kc.sh --debug` you can attach remote debugger to it. Hope it helps a bit...",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7780,599460906,2021-03-23T10:51:17Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRedirectUriEnforceExecutor.java,"@@ -34,26 +33,34 @@ import org.keycloak.services.clientpolicy.context.DynamicClientRegisterContext; import org.keycloak.services.clientpolicy.context.DynamicClientUpdateContext; +import com.fasterxml.jackson.annotation.JsonIgnoreProperties;+ public class SecureRedirectUriEnforceExecutor implements ClientPolicyExecutorProvider {      private static final Logger logger = Logger.getLogger(SecureRedirectUriEnforceExecutor.class);+    private static final String LOGMSG_PREFIX = ""CLIENT-POLICY"";","@mposolda As for `LOGMSG_PREFIX`, I will find out where it is used and replace static fields with one constant defined in some appropriate class.As for this PR's custom logging configuration (add class name, method name, etc...), if the underlying logging framework can do that, it might appropriate for this framework to do that. However, as you mentioned, this task will be treated in the future.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,599501914,2021-03-23T11:56:44Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","I've been thinking about this one.Perhaps, but I'm not pushing for it now, we could make the payload simpler by:* Use a JWS holding all these parameters. Including the serialized `auth_req_id`. The JWS would be sent in the body where the AD should support `application/json` media type. By using a JWS, we would avoid the payload from being tampered and allow ADs to perform a more secure validation by checking signatures, consider expiration of the request, audience, etc.One possible exploit I can think about here is in case an attacker intercepts the request and is able to change the scope parameter, potentially causing the device to ask users for scopes that are not really those originally asked by the CD.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7842,599515203,2021-03-23T12:17:25Z,model/map/src/main/java/org/keycloak/models/map/realm/entity/MapAuthenticationExecutionEntity.java,"@@ -0,0 +1,143 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.realm.entity;++import java.util.Objects;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.utils.KeycloakModelUtils;++public class MapAuthenticationExecutionEntity {++    private String id;+    private String authenticator;+    private String authenticatorConfig;+    private String flowId;+    private String parentFlowId;+    private AuthenticationExecutionModel.Requirement requirement;+    private boolean autheticatorFlow;+    private int priority;++    private MapAuthenticationExecutionEntity() {}++    public static MapAuthenticationExecutionEntity fromModel(AuthenticationExecutionModel model) {+        if (model == null) return null;+        MapAuthenticationExecutionEntity entity = new MapAuthenticationExecutionEntity();+        String id = model.getId() == null ? KeycloakModelUtils.generateId() : model.getId();+        entity.setId(id);+        entity.setAuthenticator(model.getAuthenticator());+        entity.setAuthenticatorConfig(model.getAuthenticatorConfig());+        entity.setFlowId(model.getFlowId());+        entity.setParentFlowId(model.getParentFlow());+        entity.setRequirement(model.getRequirement());+        entity.setAutheticatorFlow(model.isAuthenticatorFlow());+        entity.setPriority(model.getPriority());+        return entity;+    }++    public static AuthenticationExecutionModel toModel(MapAuthenticationExecutionEntity entity) {+        if (entity == null) return null;+        AuthenticationExecutionModel model = new AuthenticationExecutionModel();+        model.setId(entity.getId());+        model.setAuthenticator(entity.getAuthenticator());+        model.setAuthenticatorConfig(entity.getAuthenticatorConfig());+        model.setFlowId(entity.getFlowId());+        model.setParentFlow(entity.getParentFlowId());+        model.setRequirement(entity.getRequirement());+        model.setAuthenticatorFlow(entity.isAutheticatorFlow());+        model.setPriority(entity.getPriority());+        return model;+    }++    public String getId() {+        return id;+    }++    public void setId(String id) {+        this.id = id;+    }++    public String getAuthenticator() {+        return authenticator;+    }++    public void setAuthenticator(String authenticator) {+        this.authenticator = authenticator;+    }++    public String getAuthenticatorConfig() {+        return authenticatorConfig;+    }++    public void setAuthenticatorConfig(String authenticatorConfig) {+        this.authenticatorConfig = authenticatorConfig;+    }++    public AuthenticationExecutionModel.Requirement getRequirement() {+        return requirement;+    }++    public void setRequirement(AuthenticationExecutionModel.Requirement requirement) {+        this.requirement = requirement;+    }++    public boolean isAutheticatorFlow() {+        return autheticatorFlow;+    }++    public void setAutheticatorFlow(boolean autheticatorFlow) {+        this.autheticatorFlow = autheticatorFlow;+    }++    public String getFlowId() {+        return flowId;+    }++    public void setFlowId(String flowId) {+        this.flowId = flowId;+    }++    public String getParentFlowId() {+        return parentFlowId;+    }++    public void setParentFlowId(String parentFlowId) {+        this.parentFlowId = parentFlowId;+    }++    public int getPriority() {+        return priority;+    }++    public void setPriority(int priority) {+        this.priority = priority;+    }++    @Override+    public int hashCode() {+        return getId().hashCode();+    }++    @Override+    public boolean equals(Object obj) {+        if (this == obj) return true;+        if (!(obj instanceof MapAuthenticationExecutionEntity)) return false;+        final MapAuthenticationExecutionEntity other = (MapAuthenticationExecutionEntity) obj;+        return Objects.equals(other.getId(), getId());","I believe two things are here: `updated` flag should be in each of the entities. And then what the `equals` is really used for.This implementation is on par with similar implementations in e.g. `RealmAdapter`: https://github.com/keycloak/keycloak/blob/ca81e6ae8c5036581c21bbe5c4923d1af8fed55e/model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java#L1056-L1063It captures the fact that the same entity can come from two sources, once e.g. from Infinispan, another time from JPA. Still, when maintaining set of the executions via e.g. a `HashSet`, this set should contain only one of the instances, regardless of the source, since the object identified is still the same.",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,599525402,2021-03-23T12:33:20Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultAttributes.java,"@@ -0,0 +1,349 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.userprofile;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import java.util.function.Consumer;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.regex.Pattern;+import java.util.stream.Collectors;++import org.jboss.logging.Logger;+import org.keycloak.common.util.ObjectUtil;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.userprofile.validation.AttributeValidator;+import org.keycloak.userprofile.validation.Validator;++/**+ * <p>The default implementation for {@link Attributes}. Should be reused as much as possible by the different implementations+ * of {@link UserProfileProvider}.+ *+ * <p>This implementation is not specific to any user profile implementation.+ *+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DefaultAttributes extends HashMap<String, List<String>> implements Attributes {++    private static final Logger logger = Logger.getLogger(DefaultAttributes.class);++    /**+     * There are the declarations for creating the built-in validations for read-only attributes. Regardless of the context where+     * user profiles are used. They are related to internal attributes with hard conditions on them in terms of management.+     */+    private static String UPDATE_READ_ONLY_ATTRIBUTES_REJECTED = ""updateReadOnlyAttributesRejectedMessage"";",I still believe that this hardcoded list of readonly aattributes should stay in Legacy provider only. New provider should work based on the user profile configuration - it should look at the configuration of the user profile used for actual action and treat all attributes which are NOT configured in it as readonly. And allow to modify only these which are configured for current user profile. This way you get much more predictable and configurable user profile handling.,
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,599545891,2021-03-23T13:01:38Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultUserProfile.java,"@@ -0,0 +1,134 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.userprofile;++import java.util.AbstractMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.function.BiConsumer;+import java.util.function.Consumer;+import java.util.function.Function;+import java.util.stream.Collectors;++import org.keycloak.models.UserModel;++/**+ * <p>The default implementation for {@link UserProfile}. Should be reused as much as possible by the different implementations+ * of {@link UserProfileProvider}.+ *+ * <p>This implementation is not specific to any user profile implementation.+ *+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DefaultUserProfile implements UserProfile {++    private final Function<DefaultAttributes, UserModel> userSupplier;+    private final DefaultAttributes attributes;","Any reason why Attributes interface is not used here, but DefaultAttributes class?",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,599608844,2021-03-23T14:16:38Z,services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpReviewProfileAuthenticator.java,"@@ -102,23 +101,13 @@ protected void actionImpl(AuthenticationFlowContext context, SerializedBrokeredI         EventBuilder event = context.getEvent();         event.event(EventType.UPDATE_PROFILE);         MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();-        UserProfileValidationResult result = forIdpReview(userCtx, formData, context.getSession()).validate();--        List<FormMessage> errors = Validation.getFormErrorsFromValidation(result);--        if (errors != null && !errors.isEmpty()) {-            Response challenge = context.form()-                    .setErrors(errors)-                    .setAttribute(LoginFormsProvider.UPDATE_PROFILE_CONTEXT_ATTR, userCtx)-                    .setFormData(formData)-                    .createUpdateProfilePage();-            context.challenge(challenge);-            return;-        }+        UserModelDelegate updatedProfile = new UserModelDelegate(null) {","Line 96 of this class calls `!Validation.validateUserMandatoryFields(realm, userCtx)` still. UserProfileSPI should be called instead to validate profile.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7846,599740629,2021-03-23T16:37:12Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultAttributes.java,"@@ -0,0 +1,384 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.userprofile;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import java.util.function.BiConsumer;+import java.util.function.Consumer;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.regex.Pattern;+import java.util.stream.Collectors;++import org.jboss.logging.Logger;+import org.keycloak.common.util.ObjectUtil;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.userprofile.validation.AttributeValidator;+import org.keycloak.userprofile.validation.Validator;++/**+ * <p>The default implementation for {@link Attributes}. Should be reused as much as possible by the different implementations+ * of {@link UserProfileProvider}.+ *+ * <p>This implementation is not specific to any user profile implementation.+ *+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DefaultAttributes extends HashMap<String, List<String>> implements Attributes {++    private static final Logger logger = Logger.getLogger(DefaultAttributes.class);++    public static Pattern getRegexPatternString(String[] builtinReadOnlyAttributes) {+        if (builtinReadOnlyAttributes != null) {+            List<String> readOnlyAttributes = new ArrayList<>(Arrays.asList(builtinReadOnlyAttributes));++            String regexStr = readOnlyAttributes.stream()+                    .map(configAttrName -> configAttrName.endsWith(""*"")+                            ? ""^"" + Pattern.quote(configAttrName.substring(0, configAttrName.length() - 1)) + "".*$""+                            : ""^"" + Pattern.quote(configAttrName) + ""$"")+                    .collect(Collectors.joining(""|""));+            regexStr = ""(?i:"" + regexStr + "")"";++            return Pattern.compile(regexStr);+        }++        return null;+    }++    public static Validator isReadOnlyAttributeUnchanged(Pattern pattern) {+        return (attribute, user) -> {+            String key = attribute.getKey();++            if (!pattern.matcher(key).find()) {+                return true;+            }++            List<String> values = attribute.getValue();++            if (values == null) {+                return true;+            }++            List<String> existingAttrValues = user == null ? null : user.getAttribute(key);+            String existingValue = null;++            if (existingAttrValues != null && !existingAttrValues.isEmpty()) {+                existingValue = existingAttrValues.get(0);+            }++            if (values.isEmpty() && existingValue != null) {+                return false;+            }++            String value = null;++            if (!values.isEmpty()) {+                value = values.get(0);+            }++            boolean result = ObjectUtil.isEqualOrBothNull(value, existingValue);++            if (!result) {+                logger.warnf(""Attempt to edit denied attribute '%s' of user '%s'"", pattern, user == null ? ""new user"" : user.getFirstAttribute(UserModel.USERNAME));+            }++            return result;+        };+    }++    /**+     * There are the declarations for creating the built-in validations for read-only attributes. Regardless of the context where+     * user profiles are used. They are related to internal attributes with hard conditions on them in terms of management.+     */+    private static String UPDATE_READ_ONLY_ATTRIBUTES_REJECTED = ""updateReadOnlyAttributesRejectedMessage"";+    private static String[] DEFAULT_READ_ONLY_ATTRIBUTES = { ""KERBEROS_PRINCIPAL"", ""LDAP_ID"", ""LDAP_ENTRY_DN"", ""CREATED_TIMESTAMP"", ""createTimestamp"", ""modifyTimestamp"", ""userCertificate"", ""saml.persistent.name.id.for.*"", ""ENABLED"", ""EMAIL_VERIFIED"" };+    private static String[] DEFAULT_ADMIN_READ_ONLY_ATTRIBUTES = { ""KERBEROS_PRINCIPAL"", ""LDAP_ID"", ""LDAP_ENTRY_DN"", ""CREATED_TIMESTAMP"", ""createTimestamp"", ""modifyTimestamp"" };+    private static Pattern readOnlyAttributesPattern = getRegexPatternString(DEFAULT_READ_ONLY_ATTRIBUTES);+    private static Pattern adminReadOnlyAttributesPattern = getRegexPatternString(DEFAULT_ADMIN_READ_ONLY_ATTRIBUTES);+    private static Predicate<String> readOnlyInternalPredicate = attributeName -> adminReadOnlyAttributesPattern.matcher(attributeName).find()+                || readOnlyAttributesPattern.matcher(attributeName).find();++    /**+     * To reference dynamic attributes that can be configured as read-only when setting up the provider.+     * We should probably remove that once we remove the legacy provider, because this will come from the configuration.+     */+    public static final String READ_ONLY_ATTRIBUTE_KEY = ""kc.read.only"";++    /**+     * Default value for attributes with no value set.+     */+    public static final List<String> EMPTY_VALUE = Collections.emptyList();++    private final UserProfileContext context;+    private final KeycloakSession session;+    private final Map<String, List<AttributeValidator>> validators = new HashMap<>();+    private UserModel user;++    public DefaultAttributes(UserProfileContext context, Map<String, ?> attributes, UserModel user, Map<UserProfileContext, Function<KeycloakSession,+            List<AttributeValidator>>> validatorByContext, KeycloakSession session) {+        this.context = context;+        this.user = user;+        this.session = session;+        configureValidators(context, validatorByContext, session);+        putAll(transformAttributes(attributes));+    }++    @Override+    public String getFirstValue(String name) {+        List<String> values = getOrDefault(name, EMPTY_VALUE);++        if (values.isEmpty()) {+            return null;+        }++        return values.get(0);+    }++    @Override+    public boolean isReadOnlyAttribute(String key) {+        if (readOnlyInternalPredicate.test(key)) {+            return true;+        }++        List<AttributeValidator> validators = this.validators.getOrDefault(key, Collections.emptyList());++        if (validators.isEmpty()) {+            // the attribute is configurable so we try to validate global validations+            validators = this.validators.getOrDefault(READ_ONLY_ATTRIBUTE_KEY, Collections.emptyList());++            for (AttributeValidator validator : validators) {+                if (!validator.getValidator().validate(new Entry<String, List<String>>() {+                    @Override+                    public String getKey() {+                        return key;+                    }++                    @Override+                    public List<String> getValue() {+                        return Collections.emptyList();+                    }++                    @Override+                    public List<String> setValue(List<String> value) {+                        return Collections.emptyList();+                    }+                }, user)) {+                    return true;+                }+            }+        }++        return false;+    }++    @Override+    public boolean validate(String name, BiConsumer<Entry<String, List<String>>, String>... listeners) {+        Entry<String, List<String>> attribute = new SimpleEntry<String, List<String>>(name, null) {+            @Override+            public List<String> getValue() {+                List<String> values = get(name);++                if (values == null) {+                    return EMPTY_VALUE;+                }++                return values;+            }+        };++        // firstly, validate core attributes like username+        // TODO: we should be able to move most of the validation from legacy validators to this method+        if (!validateCoreAttributes(attribute, listeners)) {+            return false;+        }++        List<AttributeValidator> validators = this.validators.getOrDefault(attribute.getKey(), new ArrayList<>());++        validators.addAll(this.validators.getOrDefault(READ_ONLY_ATTRIBUTE_KEY, Collections.emptyList()));++        boolean success = true;++        for (AttributeValidator validator : validators) {+            if (!validator.getValidator().validate(attribute, user)) {+                success = false;+                if (listeners != null) {+                    triggerValidationListeners(attribute, validator.getMessage(), listeners);+                }+            }+        }++        return success;+    }++    private boolean validateCoreAttributes(Entry<String, List<String>> attribute, BiConsumer<Entry<String, List<String>>, String>[] listeners) {",This method no longer exists. This class should rely on whatever validations were set by the provider (including for core attributes).,
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,600267299,2021-03-24T08:32:07Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultUserProfile.java,"@@ -0,0 +1,134 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.userprofile;++import java.util.AbstractMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.function.BiConsumer;+import java.util.function.Consumer;+import java.util.function.Function;+import java.util.stream.Collectors;++import org.keycloak.models.UserModel;++/**+ * <p>The default implementation for {@link UserProfile}. Should be reused as much as possible by the different implementations+ * of {@link UserProfileProvider}.+ *+ * <p>This implementation is not specific to any user profile implementation.+ *+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DefaultUserProfile implements UserProfile {++    private final Function<DefaultAttributes, UserModel> userSupplier;+    private final DefaultAttributes attributes;+    private boolean validated;+    private UserModel user;++    public DefaultUserProfile(DefaultAttributes attributes, Function<DefaultAttributes, UserModel> userSupplier, UserModel user) {+        this.userSupplier = userSupplier;+        this.attributes = attributes;+        this.user = user;+    }++    @Override+    public void validate() {+        ValidationException validationException = new ValidationException();++        for (String attributeName : attributes.keySet()) {+            this.attributes.validate(attributeName,+                    (attribute, message) -> validationException.addError(new ValidationException.Error(attribute, message)));+        }++        if (validationException.hasError()) {+            throw validationException;+        }++        validated = true;+    }++    @Override+    public UserModel create() throws ValidationException {+        if (user != null) {+            throw new RuntimeException(""User already created"");+        }++        user = userSupplier.apply(this.attributes);++        return updateInternal(false);+    }++    @Override+    public void update(boolean removeAttributes, BiConsumer<String, UserModel>... changeListener) {+        updateInternal(removeAttributes, changeListener);+    }++    private UserModel updateInternal(boolean removeAttributes, BiConsumer<String, UserModel>... changeListener) {","I expect UserProfile is SPI, so I expect it will be used for customizations/extensions, and extending current code is easiest way for customizations. private methods make extensions much harder and push you to copy whole code to your extension, which is not good for long term maintenance and upgrades to newer keycloak versions (which we need).Our use case is that we have some attributes which need to be configured into user profiles in JSON config, shown in registration and user update forms, validated to decide that user matches user profile level, but they are not persisted in UserModel but in another external system (REST API). Communication with the external system should be performed when really necessary (when current user profile requires given attributes). So for me it seems that simplest way is to customize UserProfileProvider to handle these attributes, but I do not want to rewrite too much code",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7877,600290764,2021-03-24T09:06:40Z,server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java,"@@ -92,4 +94,14 @@      * @return Stream of ClientModel or an empty stream if no client is found. Never returns {@code null}.      */     Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults);++    /**+     * Return all default scopes (if 'defaultScope' is true) or all optional scopes (if 'defaultScope' is false) linked with the client+     *+     * @param client Client+     * @param defaultScopes if true default scopes, if false optional scopes, are returned+     * @param filterByProtocol if true, then just client scopes of same protocol like current client will be returned+     * @return map where key is the name of the clientScope, value is particular clientScope. Returns empty map if no scopes linked (never returns null).+     */+    Map<String, ClientScopeModel> getClientScopes(ClientModel client, boolean defaultScopes, boolean filterByProtocol);","When I search usages of original `ClientModel.getClientScopes(boolean, boolean)` there are some which use the option without filtering by protocol. e.g. here https://github.com/keycloak/keycloak/blob/master/server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java#L595-L596We can discuss this with @mposolda as he was the original author of client scopes, wdyt?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,600372236,2021-03-24T10:57:44Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)",@pedroigor Not 100% sure what you mean? Do you mean that `auth_req_id` parameter returned to the client from initial Backchannel endpoint will be simple ID and not anything like JWE/JWS? That can probably work though as long as Ciba Grant endpoint is able to use this ID for lookup OAuth2DeviceCodeModel from the cache - which it is AFAIK.So are we going with:- `auth_req_id` to be just simple UUID- `authentication_channel_id` to be JWS signed by the Keycloak server private key. Authentication channel 3rd party can download key from JWKS_URL (if it wants) and verify signature and retrieve all the data from it.WDYT?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7877,600382839,2021-03-24T11:13:31Z,server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java,"@@ -92,4 +94,14 @@      * @return Stream of ClientModel or an empty stream if no client is found. Never returns {@code null}.      */     Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults);++    /**+     * Return all default scopes (if 'defaultScope' is true) or all optional scopes (if 'defaultScope' is false) linked with the client+     *+     * @param client Client+     * @param defaultScopes if true default scopes, if false optional scopes, are returned+     * @param filterByProtocol if true, then just client scopes of same protocol like current client will be returned+     * @return map where key is the name of the clientScope, value is particular clientScope. Returns empty map if no scopes linked (never returns null).+     */+    Map<String, ClientScopeModel> getClientScopes(ClientModel client, boolean defaultScopes, boolean filterByProtocol);","Maybe ""filterByProtocol"" is not needed. But currently I am not 100% sure if removing ""filterByProtocol"" can have some side-effects during export/import for clients with changed protocol.AFAIR there is one bad thing, that Keycloak currently allows to change the protocol of the client. We discussed with Stian and Pedro that it will be ideal to remove this possibility. Instead of changing protocol of the client from OIDC to SAML, you would need to remove the original client and add new client instead of directly changing protocol (as it doesn't makes sense to allow changing protocol as there is small common things to OIDC and SAML clients). JIRA is here https://issues.redhat.com/browse/KEYCLOAK-16559Fix KEYCLOAK-16559 will simplify things, but since KEYCLOAK-16559 is still open, Keycloak currently allows that same client can contains both OIDC and SAML client scopes. If we remove this possibility and address KEYCLOAK-16559, then support for filtering by protocol won't be needed at all.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7846,600394319,2021-03-24T11:30:46Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultAttributes.java,"@@ -0,0 +1,349 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.userprofile;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import java.util.function.Consumer;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.regex.Pattern;+import java.util.stream.Collectors;++import org.jboss.logging.Logger;+import org.keycloak.common.util.ObjectUtil;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.userprofile.validation.AttributeValidator;+import org.keycloak.userprofile.validation.Validator;++/**+ * <p>The default implementation for {@link Attributes}. Should be reused as much as possible by the different implementations+ * of {@link UserProfileProvider}.+ *+ * <p>This implementation is not specific to any user profile implementation.+ *+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DefaultAttributes extends HashMap<String, List<String>> implements Attributes {++    private static final Logger logger = Logger.getLogger(DefaultAttributes.class);++    /**+     * There are the declarations for creating the built-in validations for read-only attributes. Regardless of the context where+     * user profiles are used. They are related to internal attributes with hard conditions on them in terms of management.+     */+    private static String UPDATE_READ_ONLY_ATTRIBUTES_REJECTED = ""updateReadOnlyAttributesRejectedMessage"";","Sure, and that is how it works. Where only attributes defined in the profile are considered.But again, this is something we should not remove now because it is related to existing behavior. It is expected that you can even set for instance a config to the provider for specifying addition read-only properties, with tests and etc relying on it.Don't worry about that now as it is a implementation detail that would not impact at all user profile use cases. Which we can remove as soon as we deprecate everything related to legacy behavior.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7846,600423887,2021-03-24T12:17:34Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultUserProfile.java,"@@ -0,0 +1,134 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.userprofile;++import java.util.AbstractMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.function.BiConsumer;+import java.util.function.Consumer;+import java.util.function.Function;+import java.util.stream.Collectors;++import org.keycloak.models.UserModel;++/**+ * <p>The default implementation for {@link UserProfile}. Should be reused as much as possible by the different implementations+ * of {@link UserProfileProvider}.+ *+ * <p>This implementation is not specific to any user profile implementation.+ *+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DefaultUserProfile implements UserProfile {++    private final Function<DefaultAttributes, UserModel> userSupplier;+    private final DefaultAttributes attributes;+    private boolean validated;+    private UserModel user;++    public DefaultUserProfile(DefaultAttributes attributes, Function<DefaultAttributes, UserModel> userSupplier, UserModel user) {+        this.userSupplier = userSupplier;+        this.attributes = attributes;+        this.user = user;+    }++    @Override+    public void validate() {+        ValidationException validationException = new ValidationException();++        for (String attributeName : attributes.keySet()) {+            this.attributes.validate(attributeName,+                    (attribute, message) -> validationException.addError(new ValidationException.Error(attribute, message)));+        }++        if (validationException.hasError()) {+            throw validationException;+        }++        validated = true;+    }++    @Override+    public UserModel create() throws ValidationException {+        if (user != null) {+            throw new RuntimeException(""User already created"");+        }++        user = userSupplier.apply(this.attributes);++        return updateInternal(false);+    }++    @Override+    public void update(boolean removeAttributes, BiConsumer<String, UserModel>... changeListener) {+        updateInternal(removeAttributes, changeListener);+    }++    private UserModel updateInternal(boolean removeAttributes, BiConsumer<String, UserModel>... changeListener) {","Sorry @velias, but it is just a matter of changing private to protected and not copy/paste. Nobody is proposing copy/paste, but to think about the best way to allow customizations with real use cases and a proper solution.Overriding that method is definitely not the best way of extending and solving your use case. If you want less code we could provide specific hooks or event listeners for deciding whether an attribute should be persisted based on some logic.By overriding this method you are going against your goal of not having to write too much code as you are going to need to similar code as in this method.Again, we should have proper hooks. We can either consider this requirement now or perhaps work on it later once we have the core changes in. It should just be a matter of making this part easier to customize.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7844,600578204,2021-03-24T15:13:20Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java,"@@ -0,0 +1,849 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserLoginFailureModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.utils.SessionTimeoutHelper;++import java.util.Collection;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.UUID;+import java.util.concurrent.ConcurrentHashMap;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import static org.keycloak.models.UserSessionModel.SessionPersistenceState.TRANSIENT;+import static org.keycloak.utils.StreamsUtil.paginatedStream;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProvider implements UserSessionProvider {++    private static final Logger LOG = Logger.getLogger(MapUserSessionProvider.class);+    private final KeycloakSession session;+    protected final MapKeycloakTransaction<UUID, MapUserSessionEntity, UserSessionModel> userSessionTx;+    protected final MapKeycloakTransaction<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionTx;+    protected final MapKeycloakTransaction<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureTx;+    private final MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private final MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;+    private final MapStorage<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureStore;++    /**+     * Storage for transient user sessions which lifespan is limited to one request.+     */+    private Map<UUID, MapUserSessionEntity> transientUserSessions = new HashMap<>();++    public MapUserSessionProvider(KeycloakSession session, MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore,+                                  MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore,+                                  MapStorage<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureStore) {+        this.session = session;+        this.userSessionStore = userSessionStore;+        this.clientSessionStore = clientSessionStore;+        this.userLoginFailureStore = userLoginFailureStore;+        userSessionTx = userSessionStore.createTransaction();+        clientSessionTx = clientSessionStore.createTransaction();+        userLoginFailureTx = userLoginFailureStore.createTransaction();++        session.getTransactionManager().enlistAfterCompletion(userSessionTx);+        session.getTransactionManager().enlistAfterCompletion(clientSessionTx);+        session.getTransactionManager().enlistAfterCompletion(userLoginFailureTx);+    }++    private Function<MapUserSessionEntity, UserSessionModel> userEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return (origEntity) -> new MapUserSessionAdapter(session, realm,+                Objects.equals(origEntity.getPersistenceState(), TRANSIENT) ? origEntity : registerEntityForChanges(origEntity)) {++            @Override+            public void removeAuthenticatedClientSessions(Collection<String> removedClientUUIDS) {+                removedClientUUIDS.stream().map(UUID::fromString).forEach(clientSessionTx::delete);++                removedClientUUIDS.forEach(entity::removeAuthenticatedClientSession);+            }+        };+    }++    private Function<MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientEntityToAdapterFunc(RealmModel realm,+                                                                                                                     ClientModel client,+                                                                                                                     UserSessionModel userSession) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapAuthenticatedClientSessionAdapter(session, realm, client, userSession, registerEntityForChanges(origEntity)) {+            @Override+            public void detachFromUserSession() {+                //userSession.removeAuthenticatedClientSessions(Collections.singleton(client.getId()));++                this.userSession = null;++                clientSessionTx.delete(entity.getId());+            }+        };+    }++    private Function<MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapUserLoginFailureAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapUserSessionEntity registerEntityForChanges(MapUserSessionEntity origEntity) {+        MapUserSessionEntity res = userSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userSessionTx.updateIfChanged(origEntity.getId(), res, MapUserSessionEntity::isUpdated);+        return res;+    }++    private MapAuthenticatedClientSessionEntity registerEntityForChanges(MapAuthenticatedClientSessionEntity origEntity) {+        MapAuthenticatedClientSessionEntity res = clientSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        clientSessionTx.updateIfChanged(origEntity.getId(), res, MapAuthenticatedClientSessionEntity::isUpdated);+        return res;+    }++    private MapUserLoginFailureEntity registerEntityForChanges(MapUserLoginFailureEntity origEntity) {+        MapUserLoginFailureEntity res = userLoginFailureTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userLoginFailureTx.updateIfChanged(origEntity.getId(), res, MapUserLoginFailureEntity::isUpdated);+        return res;+    }++    @Override+    public AuthenticatedClientSessionModel createClientSession(RealmModel realm, ClientModel client, UserSessionModel userSession) {+        MapAuthenticatedClientSessionEntity entity =+                new MapAuthenticatedClientSessionEntity(UUID.randomUUID(), realm.getId(), client.getId(), false);++        if (clientSessionTx.read(entity.getId()) != null) {+            throw new ModelDuplicateException(""Client session exists: "" + entity.getId());+        }++        LOG.tracef(""createClientSession(%s, %s, %s)%s"", realm, client, userSession, getShortStackTrace());++        clientSessionTx.create(entity.getId(), entity);++        MapUserSessionEntity userSessionEntity = getUserSessionById(UUID.fromString(userSession.getId()));+        userSessionEntity.addAuthenticatedClientSession(client.getId(), entity.getId());++        return clientEntityToAdapterFunc(realm, client, userSession).apply(entity);+    }++    @Override+    public AuthenticatedClientSessionModel getClientSession(UserSessionModel userSession, ClientModel client,+                                                            UUID clientSessionId, boolean offline) {+        Objects.requireNonNull(userSession, ""The provided user session cannot be null!"");+        Objects.requireNonNull(client, ""The provided client cannot be null!"");+        if (clientSessionId == null) {+            return null;+        }++        LOG.tracef(""getClientSession(%s, %s, %s, %s)%s"", userSession, client,+                clientSessionId, offline, getShortStackTrace());++        ModelCriteriaBuilder<AuthenticatedClientSessionModel> mcb = clientSessionStore.createCriteriaBuilder()+                .compare(AuthenticatedClientSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, clientSessionId)+                .compare(AuthenticatedClientSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.IS_OFFLINE, ModelCriteriaBuilder.Operator.EQ, offline);++        return clientSessionTx.getUpdatedNotRemoved(mcb)+                .map(entity -> clientEntityToAdapterFunc(client.getRealm(), client, userSession).apply(entity))+                .findFirst()+                .orElse(null);+    }++    @Override+    public UserSessionModel createUserSession(RealmModel realm, UserModel user, String loginUsername, String ipAddress,+                                              String authMethod, boolean rememberMe, String brokerSessionId, String brokerUserId) {+        return createUserSession(null, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId,+                brokerUserId, UserSessionModel.SessionPersistenceState.PERSISTENT);+    }++    @Override+    public UserSessionModel createUserSession(String id, RealmModel realm, UserModel user, String loginUsername,+                                              String ipAddress, String authMethod, boolean rememberMe, String brokerSessionId,+                                              String brokerUserId, UserSessionModel.SessionPersistenceState persistenceState) {+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""createUserSession(%s, %s, %s, %s)%s"", id, realm, loginUsername, persistenceState, getShortStackTrace());++        MapUserSessionEntity entity = new MapUserSessionEntity(entityId, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId, brokerUserId, false);+        entity.setPersistenceState(persistenceState);++        if (Objects.equals(persistenceState, TRANSIENT)) {+            transientUserSessions.put(entityId, entity);+        } else {+            if (userSessionTx.read(entity.getId()) != null) {+                throw new ModelDuplicateException(""User session exists: "" + entity.getId());+            }++            userSessionTx.create(entity.getId(), entity);+        }++        UserSessionModel userSession = userEntityToAdapterFunc(realm).apply(entity);++        DeviceActivityManager.attachDevice(userSession, session);++        return userSession;+    }++    @Override+    public UserSessionModel getUserSession(RealmModel realm, String id) {+        Objects.requireNonNull(realm, ""The provided realm can't be null!"");++        UUID uuid = toUUID(id);+        if (uuid == null) {+            return null;+        }++        LOG.tracef(""getUserSession(%s, %s)%s"", realm, id, getShortStackTrace());++        MapUserSessionEntity userSessionEntity = transientUserSessions.get(uuid);+        if (userSessionEntity != null) {+            return userEntityToAdapterFunc(realm).apply(userSessionEntity);+        }++        // TODO examine why this is not working+        /*ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .or(","Weird, I tried this: https://github.com/mhajas/keycloak/commit/7abb2a4172d5d2d2716ce8539a510bfdd84ee970#diff-c3cc4e31fdbf284cce9c3dcce3cd78ef82d1634230e61d4b3b36f439b625a008R137 and it works for me. I little bit worked around model tests to use MapUserSessionProvider with Inifinispan parameters, I was not sure how to configure it with Map parameter. To run the test you need to run it with: `-Dkeycloak.model.parameters=Jpa,Infinispan,ConcurrentHashMapStorage`",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7842,600656779,2021-03-24T16:33:39Z,model/map/src/main/java/org/keycloak/models/map/realm/MapRealmAdapter.java,"@@ -0,0 +1,1547 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.realm;++import java.util.Collections;+import java.util.Map;+import java.util.Objects;+import static java.util.Objects.nonNull;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.Config;+import org.keycloak.common.enums.SslRequired;+import org.keycloak.component.ComponentFactory;+import org.keycloak.component.ComponentModel;+import org.keycloak.component.ComponentValidationException;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.AuthenticationFlowModel;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.ClientInitialAccessModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.GroupModel;+import org.keycloak.models.IdentityProviderMapperModel;+import org.keycloak.models.IdentityProviderModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OTPPolicy;+import org.keycloak.models.PasswordPolicy;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RequiredActionProviderModel;+import org.keycloak.models.RequiredCredentialModel;+import org.keycloak.models.RoleModel;+import org.keycloak.models.WebAuthnPolicy;+import org.keycloak.models.map.realm.entity.MapAuthenticationExecutionEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationFlowEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticatorConfigEntity;+import org.keycloak.models.map.realm.entity.MapClientInitialAccessEntity;+import org.keycloak.models.map.realm.entity.MapComponentEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderMapperEntity;+import org.keycloak.models.map.realm.entity.MapOTPPolicyEntity;+import org.keycloak.models.map.realm.entity.MapRequiredActionProviderEntity;+import org.keycloak.models.map.realm.entity.MapRequiredCredentialEntity;+import org.keycloak.models.map.realm.entity.MapWebAuthnPolicyEntity;+import org.keycloak.models.utils.ComponentUtil;++public class MapRealmAdapter extends AbstractRealmModel<MapRealmEntity> implements RealmModel {++    private static final String ACTION_TOKEN_GENERATED_BY_USER_LIFESPAN = ""actionTokenGeneratedByUserLifespan."";+    private static final String DEFAULT_SIGNATURE_ALGORITHM = ""defaultSignatureAlgorithm"";+    private static final String BRUTE_FORCE_PROTECTED = ""bruteForceProtected"";+    private static final String PERMANENT_LOCKOUT = ""permanentLockout"";+    private static final String MAX_FAILURE_WAIT_SECONDS = ""maxFailureWaitSeconds"";+    private static final String WAIT_INCREMENT_SECONDS = ""waitIncrementSeconds"";+    private static final String QUICK_LOGIN_CHECK_MILLISECONDS = ""quickLoginCheckMilliSeconds"";+    private static final String MINIMUM_QUICK_LOGIN_WAIT_SECONDS = ""minimumQuickLoginWaitSeconds"";+    private static final String MAX_DELTA_SECONDS = ""maxDeltaTimeSeconds"";+    private static final String FAILURE_FACTOR = ""failureFactor"";++    private PasswordPolicy passwordPolicy;++    public MapRealmAdapter(KeycloakSession session, MapRealmEntity entity) {+        super(session, entity);+    }++    @Override+    public String getId() {+        return entity.getId();+    }++    @Override+    public String getName() {+        return entity.getName();+    }++    @Override+    public void setName(String name) {+        entity.setName(name);+    }++    @Override+    public String getDisplayName() {+        return entity.getDisplayName();+    }++    @Override+    public void setDisplayName(String displayName) {+        entity.setDisplayName(displayName);+    }++    @Override+    public String getDisplayNameHtml() {+        return entity.getDisplayNameHtml();+    }++    @Override+    public void setDisplayNameHtml(String displayNameHtml) {+        entity.setDisplayNameHtml(displayNameHtml);+    }++    @Override+    public boolean isEnabled() {+        return entity.isEnabled();+    }++    @Override+    public void setEnabled(boolean enabled) {+        entity.setEnabled(enabled);+    }++    @Override+    public SslRequired getSslRequired() {+        return entity.getSslRequired() == null ? null : SslRequired.valueOf(entity.getSslRequired());+    }++    @Override+    public void setSslRequired(SslRequired sslRequired) {+        entity.setSslRequired(sslRequired.name());+    }++    @Override+    public boolean isRegistrationAllowed() {+        return entity.isRegistrationAllowed();+    }++    @Override+    public void setRegistrationAllowed(boolean registrationAllowed) {+        entity.setRegistrationAllowed(registrationAllowed);+    }++    @Override+    public boolean isRegistrationEmailAsUsername() {+        return entity.isRegistrationEmailAsUsername();+    }++    @Override+    public void setRegistrationEmailAsUsername(boolean registrationEmailAsUsername) {+        entity.setRegistrationEmailAsUsername(registrationEmailAsUsername);+    }++    @Override+    public boolean isRememberMe() {+        return entity.isRememberMe();+    }++    @Override+    public void setRememberMe(boolean rememberMe) {+        entity.setRememberMe(rememberMe);+    }++    @Override+    public boolean isEditUsernameAllowed() {+        return entity.isEditUsernameAllowed();+    }++    @Override+    public void setEditUsernameAllowed(boolean editUsernameAllowed) {+        entity.setEditUsernameAllowed(editUsernameAllowed);+    }++    @Override+    public boolean isUserManagedAccessAllowed() {+        return entity.isAllowUserManagedAccess();+    }++    @Override+    public void setUserManagedAccessAllowed(boolean userManagedAccessAllowed) {+        entity.setAllowUserManagedAccess(userManagedAccessAllowed);+    }++    @Override+    public void setAttribute(String name, String value) {+        entity.setAttribute(name, value);+    }++    @Override+    public void removeAttribute(String name) {+        entity.removeAttribute(name);+    }++    @Override+    public String getAttribute(String name) {+        return entity.getAttribute(name);+    }++    @Override+    public Map<String, String> getAttributes() {+        return entity.getAttributes();+    }++    @Override+    public boolean isVerifyEmail() {+        return entity.isVerifyEmail();+    }++    @Override+    public void setVerifyEmail(boolean verifyEmail) {+        entity.setVerifyEmail(verifyEmail);+    }++    @Override+    public boolean isLoginWithEmailAllowed() {+        return entity.isLoginWithEmailAllowed();+    }++    @Override+    public void setLoginWithEmailAllowed(boolean loginWithEmailAllowed) {+        entity.setLoginWithEmailAllowed(loginWithEmailAllowed);+    }++    @Override+    public boolean isDuplicateEmailsAllowed() {+        return entity.isDuplicateEmailsAllowed();+    }++    @Override+    public void setDuplicateEmailsAllowed(boolean duplicateEmailsAllowed) {+        entity.setDuplicateEmailsAllowed(duplicateEmailsAllowed);+    }++    @Override+    public boolean isResetPasswordAllowed() {+        return entity.isResetPasswordAllowed();+    }++    @Override+    public void setResetPasswordAllowed(boolean resetPasswordAllowed) {+        entity.setResetPasswordAllowed(resetPasswordAllowed);+    }++    @Override+    public boolean isRevokeRefreshToken() {+        return entity.isRevokeRefreshToken();+    }++    @Override+    public void setRevokeRefreshToken(boolean revokeRefreshToken) {+        entity.setRevokeRefreshToken(revokeRefreshToken);+    }++    @Override+    public int getRefreshTokenMaxReuse() {+        return entity.getRefreshTokenMaxReuse();+    }++    @Override+    public void setRefreshTokenMaxReuse(int revokeRefreshTokenCount) {+        entity.setRefreshTokenMaxReuse(revokeRefreshTokenCount);+    }++    @Override+    public int getSsoSessionIdleTimeout() {+        return entity.getSsoSessionIdleTimeout();+    }++    @Override+    public void setSsoSessionIdleTimeout(int seconds) {+        entity.setSsoSessionIdleTimeout(seconds);+    }++    @Override+    public int getSsoSessionMaxLifespan() {+        return entity.getSsoSessionMaxLifespan();+    }++    @Override+    public void setSsoSessionMaxLifespan(int seconds) {+        entity.setSsoSessionMaxLifespan(seconds);+    }++    @Override+    public int getSsoSessionIdleTimeoutRememberMe() {+        return entity.getSsoSessionIdleTimeoutRememberMe();+    }++    @Override+    public void setSsoSessionIdleTimeoutRememberMe(int seconds) {+        entity.setSsoSessionIdleTimeoutRememberMe(seconds);+    }++    @Override+    public int getSsoSessionMaxLifespanRememberMe() {+        return entity.getSsoSessionMaxLifespanRememberMe();+    }++    @Override+    public void setSsoSessionMaxLifespanRememberMe(int seconds) {+        entity.setSsoSessionMaxLifespanRememberMe(seconds);+    }++    @Override+    public int getOfflineSessionIdleTimeout() {+        return entity.getOfflineSessionIdleTimeout();+    }++    @Override+    public void setOfflineSessionIdleTimeout(int seconds) {+        entity.setOfflineSessionIdleTimeout(seconds);+    }++    @Override+    public int getAccessTokenLifespan() {+        return entity.getAccessTokenLifespan();+    }++    @Override+    public int getClientSessionIdleTimeout() {+        return entity.getClientSessionIdleTimeout();+    }++    @Override+    public void setClientSessionIdleTimeout(int seconds) {+        entity.setClientSessionIdleTimeout(seconds);+    }++    @Override+    public int getClientSessionMaxLifespan() {+        return entity.getClientSessionMaxLifespan();+    }++    @Override+    public void setClientSessionMaxLifespan(int seconds) {+        entity.setClientSessionMaxLifespan(seconds);+    }++    @Override+    public int getClientOfflineSessionIdleTimeout() {+        return entity.getClientOfflineSessionIdleTimeout();+    }++    @Override+    public void setClientOfflineSessionIdleTimeout(int seconds) {+        entity.setClientOfflineSessionIdleTimeout(seconds);+    }++    @Override+    public int getClientOfflineSessionMaxLifespan() {+        return entity.getClientOfflineSessionMaxLifespan();+    }++    @Override+    public void setClientOfflineSessionMaxLifespan(int seconds) {+        entity.setClientOfflineSessionMaxLifespan(seconds);+    }++    @Override+    public void setAccessTokenLifespan(int seconds) {+        entity.setAccessTokenLifespan(seconds);+    }++    @Override+    public int getAccessTokenLifespanForImplicitFlow() {+        return entity.getAccessTokenLifespanForImplicitFlow();+    }++    @Override+    public void setAccessTokenLifespanForImplicitFlow(int seconds) {+        entity.setAccessTokenLifespanForImplicitFlow(seconds);+    }++    @Override+    public int getAccessCodeLifespan() {+        return entity.getAccessCodeLifespan();+    }++    @Override+    public void setAccessCodeLifespan(int seconds) {+        entity.setAccessCodeLifespan(seconds);+    }++    @Override+    public int getAccessCodeLifespanUserAction() {+        return entity.getAccessCodeLifespanUserAction();+    }++    @Override+    public void setAccessCodeLifespanUserAction(int seconds) {+        entity.setAccessCodeLifespanUserAction(seconds);+    }++    @Override+    public int getAccessCodeLifespanLogin() {+        return entity.getAccessCodeLifespanLogin();+    }++    @Override+    public void setAccessCodeLifespanLogin(int seconds) {+        entity.setAccessCodeLifespanLogin(seconds);+    }++    @Override+    public int getActionTokenGeneratedByAdminLifespan() {+        return entity.getActionTokenGeneratedByAdminLifespan();+    }++    @Override+    public void setActionTokenGeneratedByAdminLifespan(int seconds) {+        entity.setActionTokenGeneratedByAdminLifespan(seconds);+    }++    @Override+    public int getActionTokenGeneratedByUserLifespan() {+        return entity.getActionTokenGeneratedByUserLifespan();+    }++    @Override+    public void setActionTokenGeneratedByUserLifespan(int seconds) {+        entity.setActionTokenGeneratedByUserLifespan(seconds);+    }++    @Override+    public int getActionTokenGeneratedByUserLifespan(String actionTokenType) {+        return getAttribute(ACTION_TOKEN_GENERATED_BY_USER_LIFESPAN + actionTokenType, getAccessCodeLifespanUserAction());+    }++    @Override+    public void setActionTokenGeneratedByUserLifespan(String actionTokenType, Integer seconds) {+        if (actionTokenType != null && ! actionTokenType.isEmpty() && seconds != null) {+            setAttribute(ACTION_TOKEN_GENERATED_BY_USER_LIFESPAN + actionTokenType, seconds);+        }+    }++    @Override+    public Map<String, Integer> getUserActionTokenLifespans() {+        Map<String, Integer> tokenLifespans = entity.getAttributes().entrySet().stream()+                .filter(Objects::nonNull)+                .filter(entry -> nonNull(entry.getValue()))+                .filter(entry -> entry.getKey().startsWith(ACTION_TOKEN_GENERATED_BY_USER_LIFESPAN))+                .collect(Collectors.toMap(+                        entry -> entry.getKey().replace(ACTION_TOKEN_GENERATED_BY_USER_LIFESPAN, """"),+                        entry -> Integer.valueOf(entry.getValue())));++        tokenLifespans.put("""", getActionTokenGeneratedByUserLifespan());","There are `RealmModel.setActionTokenGeneratedByUserLifespan(int)` and `RealmModel.getActionTokenGeneratedByUserLifespan()` methods for setting and getting ""default"" actionTokenGeneratedByUserLifespan. The ""default"" value is JPA is stored in attributes with key `RealmAttributes.ACTION_TOKEN_GENERATED_BY_USER_LIFESPAN`. Here it's stored as: https://github.com/vramik/keycloak/blob/KEYCLOAK-14552-realm-map-store/model/map/src/main/java/org/keycloak/models/map/realm/AbstractRealmEntity.java#L64The `getUserActionTokenLifespans()` should return map where key is the actionTokenId string. The ""default"" value is represented by empty string (it's the same as JPA). That's why it needs to be called here like this. But when I wrote this I had also other things stored directly as variables, not in attributes, then I has to change it back. It might be needed to edit this one as well, but I'm not sure tbh.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7842,600672073,2021-03-24T16:50:02Z,model/map/src/main/java/org/keycloak/models/map/realm/AbstractRealmEntity.java,"@@ -0,0 +1,1032 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.realm;++import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.common.util.Time;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.OTPPolicy;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationExecutionEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationFlowEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticatorConfigEntity;+import org.keycloak.models.map.realm.entity.MapClientInitialAccessEntity;+import org.keycloak.models.map.realm.entity.MapComponentEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderMapperEntity;+import org.keycloak.models.map.realm.entity.MapOTPPolicyEntity;+import org.keycloak.models.map.realm.entity.MapRequiredActionProviderEntity;+import org.keycloak.models.map.realm.entity.MapRequiredCredentialEntity;+import org.keycloak.models.map.realm.entity.MapWebAuthnPolicyEntity;++public abstract class AbstractRealmEntity<K> implements AbstractEntity<K> {++    private final K id;+    private String name;++    private Boolean enabled;+    private Boolean registrationAllowed;+    private Boolean registrationEmailAsUsername;+    private Boolean verifyEmail;+    private Boolean resetPasswordAllowed;+    private Boolean loginWithEmailAllowed;+    private Boolean duplicateEmailsAllowed;+    private Boolean rememberMe;+    private Boolean editUsernameAllowed;+    private Boolean revokeRefreshToken;+    private Boolean adminEventsEnabled;+    private Boolean adminEventsDetailsEnabled;+    private Boolean internationalizationEnabled;+    private Boolean allowUserManagedAccess;+    private Boolean offlineSessionMaxLifespanEnabled;+    private Boolean eventsEnabled;+    private Integer actionTokenGeneratedByUserLifespan = 12 * 60 * 60;+    private Integer refreshTokenMaxReuse;+    private Integer ssoSessionIdleTimeout;+    private Integer ssoSessionMaxLifespan;+    private Integer ssoSessionIdleTimeoutRememberMe;+    private Integer ssoSessionMaxLifespanRememberMe;+    private Integer offlineSessionIdleTimeout;+    private Integer accessTokenLifespan;+    private Integer accessTokenLifespanForImplicitFlow;+    private Integer accessCodeLifespan;+    private Integer accessCodeLifespanUserAction;+    private Integer accessCodeLifespanLogin;+    private Integer notBefore;+    private Integer clientSessionIdleTimeout;+    private Integer clientSessionMaxLifespan;+    private Integer clientOfflineSessionIdleTimeout;+    private Integer clientOfflineSessionMaxLifespan;+    private Integer actionTokenGeneratedByAdminLifespan;+    private Integer offlineSessionMaxLifespan;+    private Long eventsExpiration;+    private String displayName;+    private String displayNameHtml;+    private String passwordPolicy;+    private String sslRequired;+    private String loginTheme;+    private String accountTheme;+    private String adminTheme;+    private String emailTheme;+    private String masterAdminClient;+    private String defaultRoleId;+    private String defaultLocale;+    private String browserFlow;+    private String registrationFlow;+    private String directGrantFlow;+    private String resetCredentialsFlow;+    private String clientAuthenticationFlow;+    private String dockerAuthenticationFlow;+    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);;+    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;+    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;++    private final Set<String> defaultGroupIds = new HashSet<>();+    private final Set<String> eventsListeners = new HashSet<>();+    private final Set<String> enabledEventTypes = new HashSet<>();+    private final Set<String> supportedLocales = new HashSet<>();+    private final Set<String> defaultClientScopes = new HashSet<>();+    private final Set<String> optionalClientScopes = new HashSet<>();+    private final Map<String, String> browserSecurityHeaders = new HashMap<>();+    private final Map<String, String> smtpConfig = new HashMap<>();+    private final Map<String, String> attributes = new HashMap<>();+    private final Map<String, Map<String, String>> localizationTexts = new HashMap<>();+    private final Map<String, MapClientInitialAccessEntity> clientInitialAccesses = new HashMap<>();+    private final Map<String, MapComponentEntity> components = new HashMap<>();+    private final Map<String, MapAuthenticationFlowEntity> authenticationFlows = new HashMap<>();+    private final Map<String, MapAuthenticationExecutionEntity> authenticationExecutions = new HashMap<>();+    private final Map<String, MapRequiredCredentialEntity> requiredCredentials = new HashMap<>();+    private final Map<String, MapAuthenticatorConfigEntity> authenticatorConfigs = new HashMap<>();+    private final Map<String, MapIdentityProviderEntity> identityProviders = new HashMap<>();+    private final Map<String, MapIdentityProviderMapperEntity> identityProviderMappers = new HashMap<>();+    private final Map<String, MapRequiredActionProviderEntity> requiredActionProviders = new HashMap<>();++    /**+     * Flag signalizing that any of the setters has been meaningfully used.+     */+    protected boolean updated;++    protected AbstractRealmEntity() {+        this.id = null;+    }++    public AbstractRealmEntity(K id) {+        Objects.requireNonNull(id, ""id"");++        this.id = id;+    }++    @Override+    public K getId() {+        return this.id;+    }++    @Override+    public boolean isUpdated() {+        return this.updated;+    }++    public String getName() {+        return name;+    }++    public void setName(String name) {+        this.updated |= ! Objects.equals(this.name, name);+        this.name = name;+    }++    public String getDisplayName() {+        return displayName;+    }++    public void setDisplayName(String displayName) {+        this.updated |= ! Objects.equals(this.displayName, displayName);+        this.displayName = displayName;+    }++    public String getDisplayNameHtml() {+        return displayNameHtml;+    }++    public void setDisplayNameHtml(String displayNameHtml) {+        this.updated |= ! Objects.equals(this.displayNameHtml, displayNameHtml);+        this.displayNameHtml = displayNameHtml;+    }++    public Boolean isEnabled() {+        return enabled;+    }++    public void setEnabled(Boolean enabled) {+        this.updated |= ! Objects.equals(this.enabled, enabled);+        this.enabled = enabled;+    }++    public Boolean isRegistrationAllowed() {+        return registrationAllowed;+    }++    public void setRegistrationAllowed(Boolean registrationAllowed) {+        this.updated |= ! Objects.equals(this.registrationAllowed, registrationAllowed);+        this.registrationAllowed = registrationAllowed;+    }++    public Boolean isRegistrationEmailAsUsername() {+        return registrationEmailAsUsername;+    }++    public void setRegistrationEmailAsUsername(Boolean registrationEmailAsUsername) {+        this.updated |= ! Objects.equals(this.registrationEmailAsUsername, registrationEmailAsUsername);+        this.registrationEmailAsUsername = registrationEmailAsUsername;+    }++    public Boolean isVerifyEmail() {+        return verifyEmail;+    }++    public void setVerifyEmail(Boolean verifyEmail) {+        this.updated |= ! Objects.equals(this.verifyEmail, verifyEmail);+        this.verifyEmail = verifyEmail;+    }+    ++    public Boolean isResetPasswordAllowed() {+        return resetPasswordAllowed;+    }++    public void setResetPasswordAllowed(Boolean resetPasswordAllowed) {+        this.updated |= ! Objects.equals(this.resetPasswordAllowed, resetPasswordAllowed);+        this.resetPasswordAllowed = resetPasswordAllowed;+    }++    public Boolean isLoginWithEmailAllowed() {+        return loginWithEmailAllowed;+    }++    public void setLoginWithEmailAllowed(Boolean loginWithEmailAllowed) {+        this.updated |= ! Objects.equals(this.loginWithEmailAllowed, loginWithEmailAllowed);+        this.loginWithEmailAllowed = loginWithEmailAllowed;+    }++    public Boolean isDuplicateEmailsAllowed() {+        return duplicateEmailsAllowed;+    }++    public void setDuplicateEmailsAllowed(Boolean duplicateEmailsAllowed) {+        this.updated |= ! Objects.equals(this.duplicateEmailsAllowed, duplicateEmailsAllowed);+        this.duplicateEmailsAllowed = duplicateEmailsAllowed;+    }++    public Boolean isRememberMe() {+        return rememberMe;+    }++    public void setRememberMe(Boolean rememberMe) {+        this.updated |= ! Objects.equals(this.rememberMe, rememberMe);+        this.rememberMe = rememberMe;+    }++    public Boolean isEditUsernameAllowed() {+        return editUsernameAllowed;+    }++    public void setEditUsernameAllowed(Boolean editUsernameAllowed) {+        this.updated |= ! Objects.equals(this.editUsernameAllowed, editUsernameAllowed);+        this.editUsernameAllowed = editUsernameAllowed;+    }++    public Boolean isRevokeRefreshToken() {+        return revokeRefreshToken;+    }++    public void setRevokeRefreshToken(Boolean revokeRefreshToken) {+        this.updated |= ! Objects.equals(this.revokeRefreshToken, revokeRefreshToken);+        this.revokeRefreshToken = revokeRefreshToken;+    }++    public Boolean isAdminEventsEnabled() {+        return adminEventsEnabled;+    }++    public void setAdminEventsEnabled(Boolean adminEventsEnabled) {+        this.updated |= ! Objects.equals(this.adminEventsEnabled, adminEventsEnabled);+        this.adminEventsEnabled = adminEventsEnabled;+    }++    public Boolean isAdminEventsDetailsEnabled() {+        return adminEventsDetailsEnabled;+    }++    public void setAdminEventsDetailsEnabled(Boolean adminEventsDetailsEnabled) {+        this.updated |= ! Objects.equals(this.adminEventsDetailsEnabled, adminEventsDetailsEnabled);+        this.adminEventsDetailsEnabled = adminEventsDetailsEnabled;+    }++    public Boolean isInternationalizationEnabled() {+        return internationalizationEnabled;+    }++    public void setInternationalizationEnabled(Boolean internationalizationEnabled) {+        this.updated |= ! Objects.equals(this.internationalizationEnabled, internationalizationEnabled);+        this.internationalizationEnabled = internationalizationEnabled;+    }++    public Boolean isAllowUserManagedAccess() {+        return allowUserManagedAccess;+    }++    public void setAllowUserManagedAccess(Boolean allowUserManagedAccess) {+        this.updated |= ! Objects.equals(this.allowUserManagedAccess, allowUserManagedAccess);+        this.allowUserManagedAccess = allowUserManagedAccess;+    }++    public Boolean isOfflineSessionMaxLifespanEnabled() {+        return offlineSessionMaxLifespanEnabled;+    }++    public void setOfflineSessionMaxLifespanEnabled(Boolean offlineSessionMaxLifespanEnabled) {+        this.updated |= ! Objects.equals(this.offlineSessionMaxLifespanEnabled, offlineSessionMaxLifespanEnabled);+        this.offlineSessionMaxLifespanEnabled = offlineSessionMaxLifespanEnabled;+    }++    public Boolean isEventsEnabled() {+        return eventsEnabled;+    }++    public void setEventsEnabled(Boolean eventsEnabled) {+        this.updated |= ! Objects.equals(this.eventsEnabled, eventsEnabled);+        this.eventsEnabled = eventsEnabled;+    }++    public Integer getRefreshTokenMaxReuse() {+        return refreshTokenMaxReuse;+    }++    public void setRefreshTokenMaxReuse(Integer refreshTokenMaxReuse) {+        this.updated |= ! Objects.equals(this.refreshTokenMaxReuse, refreshTokenMaxReuse);+        this.refreshTokenMaxReuse = refreshTokenMaxReuse;+    }++    public Integer getSsoSessionIdleTimeout() {+        return ssoSessionIdleTimeout;+    }++    public void setSsoSessionIdleTimeout(Integer ssoSessionIdleTimeout) {+        this.updated |= ! Objects.equals(this.ssoSessionIdleTimeout, ssoSessionIdleTimeout);+        this.ssoSessionIdleTimeout = ssoSessionIdleTimeout;+    }++    public Integer getSsoSessionMaxLifespan() {+        return ssoSessionMaxLifespan;+    }++    public void setSsoSessionMaxLifespan(Integer ssoSessionMaxLifespan) {+        this.updated |= ! Objects.equals(this.ssoSessionMaxLifespan, ssoSessionMaxLifespan);+        this.ssoSessionMaxLifespan = ssoSessionMaxLifespan;+    }++    public Integer getSsoSessionIdleTimeoutRememberMe() {+        return ssoSessionIdleTimeoutRememberMe;+    }++    public void setSsoSessionIdleTimeoutRememberMe(Integer ssoSessionIdleTimeoutRememberMe) {+        this.updated |= ! Objects.equals(this.ssoSessionIdleTimeoutRememberMe, ssoSessionIdleTimeoutRememberMe);+        this.ssoSessionIdleTimeoutRememberMe = ssoSessionIdleTimeoutRememberMe;+    }++    public Integer getSsoSessionMaxLifespanRememberMe() {+        return ssoSessionMaxLifespanRememberMe;+    }++    public void setSsoSessionMaxLifespanRememberMe(Integer ssoSessionMaxLifespanRememberMe) {+        this.updated |= ! Objects.equals(this.ssoSessionMaxLifespanRememberMe, ssoSessionMaxLifespanRememberMe);+        this.ssoSessionMaxLifespanRememberMe = ssoSessionMaxLifespanRememberMe;+    }++    public Integer getOfflineSessionIdleTimeout() {+        return offlineSessionIdleTimeout;+    }++    public void setOfflineSessionIdleTimeout(Integer offlineSessionIdleTimeout) {+        this.updated |= ! Objects.equals(this.offlineSessionIdleTimeout, offlineSessionIdleTimeout);+        this.offlineSessionIdleTimeout = offlineSessionIdleTimeout;+    }++    public Integer getAccessTokenLifespan() {+        return accessTokenLifespan;+    }++    public void setAccessTokenLifespan(Integer accessTokenLifespan) {+        this.updated |= ! Objects.equals(this.accessTokenLifespan, accessTokenLifespan);+        this.accessTokenLifespan = accessTokenLifespan;+    }++    public Integer getAccessTokenLifespanForImplicitFlow() {+        return accessTokenLifespanForImplicitFlow;+    }++    public void setAccessTokenLifespanForImplicitFlow(Integer accessTokenLifespanForImplicitFlow) {+        this.updated |= ! Objects.equals(this.accessTokenLifespanForImplicitFlow, accessTokenLifespanForImplicitFlow);+        this.accessTokenLifespanForImplicitFlow = accessTokenLifespanForImplicitFlow;+    }++    public Integer getAccessCodeLifespan() {+        return accessCodeLifespan;+    }++    public void setAccessCodeLifespan(Integer accessCodeLifespan) {+        this.updated |= ! Objects.equals(this.accessCodeLifespan, accessCodeLifespan);+        this.accessCodeLifespan = accessCodeLifespan;+    }++    public Integer getAccessCodeLifespanUserAction() {+        return accessCodeLifespanUserAction;+    }++    public void setAccessCodeLifespanUserAction(Integer accessCodeLifespanUserAction) {+        this.updated |= ! Objects.equals(this.accessCodeLifespanUserAction, accessCodeLifespanUserAction);+        this.accessCodeLifespanUserAction = accessCodeLifespanUserAction;+    }++    public Integer getAccessCodeLifespanLogin() {+        return accessCodeLifespanLogin;+    }++    public void setAccessCodeLifespanLogin(Integer accessCodeLifespanLogin) {+        this.updated |= ! Objects.equals(this.accessCodeLifespanLogin, accessCodeLifespanLogin);+        this.accessCodeLifespanLogin = accessCodeLifespanLogin;+    }++    public Integer getNotBefore() {+        return notBefore;+    }++    public void setNotBefore(Integer notBefore) {+        this.updated |= ! Objects.equals(this.notBefore, notBefore);+        this.notBefore = notBefore;+    }++    public Integer getClientSessionIdleTimeout() {+        return clientSessionIdleTimeout;+    }++    public void setClientSessionIdleTimeout(Integer clientSessionIdleTimeout) {+        this.updated |= ! Objects.equals(this.clientSessionIdleTimeout, clientSessionIdleTimeout);+        this.clientSessionIdleTimeout = clientSessionIdleTimeout;+    }++    public Integer getClientSessionMaxLifespan() {+        return clientSessionMaxLifespan;+    }++    public void setClientSessionMaxLifespan(Integer clientSessionMaxLifespan) {+        this.updated |= ! Objects.equals(this.clientSessionMaxLifespan, clientSessionMaxLifespan);+        this.clientSessionMaxLifespan = clientSessionMaxLifespan;+    }++    public Integer getClientOfflineSessionIdleTimeout() {+        return clientOfflineSessionIdleTimeout;+    }++    public void setClientOfflineSessionIdleTimeout(Integer clientOfflineSessionIdleTimeout) {+        this.updated |= ! Objects.equals(this.clientOfflineSessionIdleTimeout, clientOfflineSessionIdleTimeout);+        this.clientOfflineSessionIdleTimeout = clientOfflineSessionIdleTimeout;+    }++    public Integer getClientOfflineSessionMaxLifespan() {+        return clientOfflineSessionMaxLifespan;+    }++    public void setClientOfflineSessionMaxLifespan(Integer clientOfflineSessionMaxLifespan) {+        this.updated |= ! Objects.equals(this.clientOfflineSessionMaxLifespan, clientOfflineSessionMaxLifespan);+        this.clientOfflineSessionMaxLifespan = clientOfflineSessionMaxLifespan;+    }++    public Integer getActionTokenGeneratedByAdminLifespan() {+        return actionTokenGeneratedByAdminLifespan;+    }++    public void setActionTokenGeneratedByAdminLifespan(Integer actionTokenGeneratedByAdminLifespan) {+        this.updated |= ! Objects.equals(this.actionTokenGeneratedByAdminLifespan, actionTokenGeneratedByAdminLifespan);+        this.actionTokenGeneratedByAdminLifespan = actionTokenGeneratedByAdminLifespan;+    }++    public Integer getActionTokenGeneratedByUserLifespan() {+        return actionTokenGeneratedByUserLifespan;+    }++    public void setActionTokenGeneratedByUserLifespan(Integer actionTokenGeneratedByUserLifespan) {+        this.updated |= ! Objects.equals(this.actionTokenGeneratedByUserLifespan, actionTokenGeneratedByUserLifespan);+        this.actionTokenGeneratedByUserLifespan = actionTokenGeneratedByUserLifespan;+    }++    public Integer getOfflineSessionMaxLifespan() {+        return offlineSessionMaxLifespan;+    }++    public void setOfflineSessionMaxLifespan(Integer offlineSessionMaxLifespan) {+        this.updated |= ! Objects.equals(this.offlineSessionMaxLifespan, offlineSessionMaxLifespan);+        this.offlineSessionMaxLifespan = offlineSessionMaxLifespan;+    }++    public Long getEventsExpiration() {+        return eventsExpiration;+    }++    public void setEventsExpiration(Long eventsExpiration) {+        this.updated |= ! Objects.equals(this.eventsExpiration, eventsExpiration);+        this.eventsExpiration = eventsExpiration;+    }++    public String getPasswordPolicy() {+        return passwordPolicy;+    }++    public void setPasswordPolicy(String passwordPolicy) {+        this.updated |= ! Objects.equals(this.passwordPolicy, passwordPolicy);+        this.passwordPolicy = passwordPolicy;+    }++    public String getSslRequired() {+        return sslRequired;+    }++    public void setSslRequired(String sslRequired) {+        this.updated |= ! Objects.equals(this.sslRequired, sslRequired);+        this.sslRequired = sslRequired;+    }++    public String getLoginTheme() {+        return loginTheme;+    }++    public void setLoginTheme(String loginTheme) {+        this.updated |= ! Objects.equals(this.loginTheme, loginTheme);+        this.loginTheme = loginTheme;+    }++    public String getAccountTheme() {+        return accountTheme;+    }++    public void setAccountTheme(String accountTheme) {+        this.updated |= ! Objects.equals(this.accountTheme, accountTheme);+        this.accountTheme = accountTheme;+    }++    public String getAdminTheme() {+        return adminTheme;+    }++    public void setAdminTheme(String adminTheme) {+        this.updated |= ! Objects.equals(this.adminTheme, adminTheme);+        this.adminTheme = adminTheme;+    }++    public String getEmailTheme() {+        return emailTheme;+    }++    public void setEmailTheme(String emailTheme) {+        this.updated |= ! Objects.equals(this.emailTheme, emailTheme);+        this.emailTheme = emailTheme;+    }++    public String getMasterAdminClient() {+        return masterAdminClient;+    }++    public void setMasterAdminClient(String masterAdminClient) {+        this.updated |= ! Objects.equals(this.masterAdminClient, masterAdminClient);+        this.masterAdminClient = masterAdminClient;+    }++    public String getDefaultRoleId() {+        return defaultRoleId;+    }++    public void setDefaultRoleId(String defaultRoleId) {+        this.updated |= ! Objects.equals(this.defaultRoleId, defaultRoleId);+        this.defaultRoleId = defaultRoleId;+    }++    public String getDefaultLocale() {+        return defaultLocale;+    }++    public void setDefaultLocale(String defaultLocale) {+        this.updated |= ! Objects.equals(this.defaultLocale, defaultLocale);+        this.defaultLocale = defaultLocale;+    }++    public String getBrowserFlow() {+        return browserFlow;+    }++    public void setBrowserFlow(String browserFlow) {+        this.updated |= ! Objects.equals(this.browserFlow, browserFlow);+        this.browserFlow = browserFlow;+    }++    public String getRegistrationFlow() {+        return registrationFlow;+    }++    public void setRegistrationFlow(String registrationFlow) {+        this.updated |= ! Objects.equals(this.registrationFlow, registrationFlow);+        this.registrationFlow = registrationFlow;+    }++    public String getDirectGrantFlow() {+        return directGrantFlow;+    }++    public void setDirectGrantFlow(String directGrantFlow) {+        this.updated |= ! Objects.equals(this.directGrantFlow, directGrantFlow);+        this.directGrantFlow = directGrantFlow;+    }++    public String getResetCredentialsFlow() {+        return resetCredentialsFlow;+    }++    public void setResetCredentialsFlow(String resetCredentialsFlow) {+        this.updated |= ! Objects.equals(this.resetCredentialsFlow, resetCredentialsFlow);+        this.resetCredentialsFlow = resetCredentialsFlow;+    }++    public String getClientAuthenticationFlow() {+        return clientAuthenticationFlow;+    }++    public void setClientAuthenticationFlow(String clientAuthenticationFlow) {+        this.updated |= ! Objects.equals(this.clientAuthenticationFlow, clientAuthenticationFlow);+        this.clientAuthenticationFlow = clientAuthenticationFlow;+    }++    public String getDockerAuthenticationFlow() {+        return dockerAuthenticationFlow;+    }++    public void setDockerAuthenticationFlow(String dockerAuthenticationFlow) {+        this.updated |= ! Objects.equals(this.dockerAuthenticationFlow, dockerAuthenticationFlow);+        this.dockerAuthenticationFlow = dockerAuthenticationFlow;+    }++    public MapOTPPolicyEntity getOTPPolicy() {+        return otpPolicy;+    }++    public void setOTPPolicy(MapOTPPolicyEntity otpPolicy) {+        this.updated |= ! Objects.equals(this.otpPolicy, otpPolicy);+        this.otpPolicy = otpPolicy;+    }++    public MapWebAuthnPolicyEntity getWebAuthnPolicy() {+        return webAuthnPolicy;+    }++    public void setWebAuthnPolicy(MapWebAuthnPolicyEntity webAuthnPolicy) {+        this.updated |= ! Objects.equals(this.webAuthnPolicy, webAuthnPolicy);+        this.webAuthnPolicy = webAuthnPolicy;+    }++    public MapWebAuthnPolicyEntity getWebAuthnPolicyPasswordless() {+        return webAuthnPolicyPasswordless;+    }++    public void setWebAuthnPolicyPasswordless(MapWebAuthnPolicyEntity webAuthnPolicyPasswordless) {+        this.updated |= ! Objects.equals(this.webAuthnPolicyPasswordless, webAuthnPolicyPasswordless);+        this.webAuthnPolicyPasswordless = webAuthnPolicyPasswordless;+    }++    public void setAttribute(String name, String value) {+        this.updated |= !Objects.equals(this.attributes.put(name, value), value);+    }++    public void removeAttribute(String name) {+        this.updated |= attributes.remove(name) != null;+    }++    public String getAttribute(String name) {+        return attributes.get(name);+    }++    public Map<String, String> getAttributes() {+        return attributes;+    }++    public void addDefaultClientScope(String scopeId) {+        this.updated |= this.defaultClientScopes.add(scopeId);+    }++    public Stream<String> getDefaultClientScopeIds() {+        return defaultClientScopes.stream();+    }++    public void addOptionalClientScope(String scopeId) {+        this.updated |= this.optionalClientScopes.add(scopeId);+    }++    public Stream<String> getOptionalClientScopeIds() {+        return optionalClientScopes.stream();+    }++    public void removeDefaultOrOptionalClientScope(String scopeId) {+        if (this.defaultClientScopes.remove(scopeId)) {+            this.updated = true;+            return ;+        }+        this.updated |= this.optionalClientScopes.remove(scopeId);+    }++    public Stream<String> getDefaultGroupIds() {+        return defaultGroupIds.stream();+    }++    public void addDefaultGroup(String groupId) {+        this.updated |= this.defaultGroupIds.add(groupId);+    }++    public void removeDefaultGroup(String groupId) {+        this.updated |= this.defaultGroupIds.remove(groupId);+    }++    public Set<String> getEventsListeners() {+        return eventsListeners;+    }++    public void setEventsListeners(Set<String> eventsListeners) {+        if (eventsListeners == null) return;+        this.updated |= ! Objects.equals(eventsListeners, this.eventsListeners);+        this.eventsListeners.clear();+        this.eventsListeners.addAll(eventsListeners);+    }++    public Set<String> getEnabledEventTypes() {+        return enabledEventTypes;+    }++    public void setEnabledEventTypes(Set<String> enabledEventTypes) {+        if (enabledEventTypes == null) return;+        this.updated |= ! Objects.equals(enabledEventTypes, this.enabledEventTypes);+        this.enabledEventTypes.clear();+        this.enabledEventTypes.addAll(enabledEventTypes);+    }++    public Set<String> getSupportedLocales() {+        return supportedLocales;+    }++    public void setSupportedLocales(Set<String> supportedLocales) {+        if (supportedLocales == null) return;+        this.updated |= ! Objects.equals(supportedLocales, this.supportedLocales);+        this.supportedLocales.clear();+        this.supportedLocales.addAll(supportedLocales);+    }++    public Map<String, Map<String, String>> getLocalizationTexts() {+        return localizationTexts;+    }++    public Map<String, String> getLocalizationText(String locale) {+        if (localizationTexts.containsKey(locale)) {+            return localizationTexts.get(locale);+        }+        return Collections.emptyMap();+    }++    public void addLocalizationTexts(String locale, Map<String, String> texts) {+        if (! localizationTexts.containsKey(locale)) {+            updated = true;+            localizationTexts.put(locale, texts);+        }+    }++    public void updateLocalizationTexts(String locale, Map<String, String> texts) {+        this.updated |= localizationTexts.replace(locale, texts) != null;+    }++    public boolean removeLocalizationTexts(String locale) {+        boolean removed = localizationTexts.remove(locale) != null;+        updated |= removed;+        return removed;+    }++    public Map<String, String> getBrowserSecurityHeaders() {+        return browserSecurityHeaders;+    }++    public void setBrowserSecurityHeaders(Map<String, String> headers) {+        if (headers == null) return;+        this.updated |= ! Objects.equals(this.smtpConfig, headers);+        this.browserSecurityHeaders.clear();+        this.browserSecurityHeaders.putAll(headers);+    }++    public Map<String, String> getSmtpConfig() {+        return smtpConfig;+    }++    public void setSmtpConfig(Map<String, String> smtpConfig) {+        if (smtpConfig == null) return;+        this.updated |= ! Objects.equals(this.smtpConfig, smtpConfig);+        this.smtpConfig.clear();+        this.smtpConfig.putAll(smtpConfig);+    }++    public Stream<MapRequiredCredentialEntity> getRequiredCredentials() {+        return requiredCredentials.values().stream();+    }++    public void addRequiredCredential(MapRequiredCredentialEntity requiredCredential) {+        if (requiredCredentials.containsKey(requiredCredential.getType())) {+            throw new ModelDuplicateException(""An RequiredCredential with given type already exists"");+        }+        this.updated = true;+        requiredCredentials.put(requiredCredential.getType(), requiredCredential);+    }++    public void updateRequiredCredential(MapRequiredCredentialEntity requiredCredential) {+        this.updated |= requiredCredentials.replace(requiredCredential.getType(), requiredCredential) != null;+    }++    public Stream<MapComponentEntity> getComponents() {+        return components.values().stream();+    }++    public MapComponentEntity getComponent(String id) {+        return components.get(id);+    }++    public void addComponent(MapComponentEntity component) {+        if (components.containsKey(component.getId())) {+            throw new ModelDuplicateException(""A Component with given id already exists"");+        }+        this.updated = true;+        components.put(component.getId(), component);+    }++    public void updateComponent(MapComponentEntity component) {+        this.updated |= components.replace(component.getId(), component) != null;+    }++    public boolean removeComponent(String id) {+        boolean removed = this.components.remove(id) != null;+        this.updated |= removed;+        return removed;+    }++    public Stream<MapAuthenticationFlowEntity> getAuthenticationFlows() {+        return authenticationFlows.values().stream();+    }++    public MapAuthenticationFlowEntity getAuthenticationFlow(String flowId) {+        return authenticationFlows.get(flowId);+    }++    public void addAuthenticationFlow(MapAuthenticationFlowEntity authenticationFlow) {+        if (authenticationFlows.containsKey(authenticationFlow.getId())) {+            throw new ModelDuplicateException(""An AuthenticationFlow with given id already exists"");+        }+        this.updated = true;+        authenticationFlows.put(authenticationFlow.getId(), authenticationFlow);+    }++    public boolean removeAuthenticationFlow(String flowId) {+        boolean removed = this.authenticationFlows.remove(flowId) != null;+        updated |= removed;+        return removed;+    }++    public void updateAuthenticationFlow(MapAuthenticationFlowEntity authenticationFlow) {+        this.updated |= authenticationFlows.replace(authenticationFlow.getId(), authenticationFlow) != null;+    }++    public void addAuthenticatonExecution(MapAuthenticationExecutionEntity authenticationExecution) {+        if (authenticationExecutions.containsKey(authenticationExecution.getId())) {+            throw new ModelDuplicateException(""An RequiredActionProvider with given id already exists"");+        }++        this.updated = true;+        authenticationExecutions.put(authenticationExecution.getId(), authenticationExecution);+    }++    public void updateAuthenticatonExecution(MapAuthenticationExecutionEntity authenticationExecution) {+        this.updated |= authenticationExecutions.replace(authenticationExecution.getId(), authenticationExecution) != null;+    }++    public boolean removeAuthenticatonExecution(String id) {+        boolean removed = this.authenticationExecutions.remove(id) != null;+        updated |= removed;+        return removed;+    }++    public MapAuthenticationExecutionEntity getAuthenticationExecution(String id) {+        return authenticationExecutions.get(id);+    }++    public Stream<MapAuthenticationExecutionEntity> getAuthenticationExecutions() {+        return authenticationExecutions.values().stream();+    }++    public Stream<MapAuthenticatorConfigEntity> getAuthenticatorConfigs() {+        return authenticatorConfigs.values().stream();+    }++    public void addAuthenticatorConfig(MapAuthenticatorConfigEntity authenticatorConfig) {+        this.updated |= ! Objects.equals(authenticatorConfigs.put(authenticatorConfig.getId(), authenticatorConfig), authenticatorConfig);+    }++    public void updateAuthenticatorConfig(MapAuthenticatorConfigEntity authenticatorConfig) {+        this.updated |= authenticatorConfigs.replace(authenticatorConfig.getId(), authenticatorConfig) != null;+    }++    public boolean removeAuthenticatorConfig(String id) {+        boolean removed = this.authenticatorConfigs.remove(id) != null;+        updated |= removed;+        return removed;+    }++    public MapAuthenticatorConfigEntity getAuthenticatorConfig(String id) {+        return authenticatorConfigs.get(id);+    }++    public Stream<MapRequiredActionProviderEntity> getRequiredActionProviders() {+        return requiredActionProviders.values().stream();+    }++    public void addRequiredActionProvider(MapRequiredActionProviderEntity requiredActionProvider) {+        if (requiredActionProviders.containsKey(requiredActionProvider.getId())) {+            throw new ModelDuplicateException(""An RequiredActionProvider with given id already exists"");","I believe it's what we want, when we try to store something to database which is already there we also got an exception. If I recall correctly we also handle `ModelDuplicateException`s on higher levels such as rest enpoints.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7842,600673836,2021-03-24T16:51:47Z,model/map/src/main/java/org/keycloak/models/map/realm/AbstractRealmEntity.java,"@@ -0,0 +1,1032 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.realm;++import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import org.keycloak.common.util.Time;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.OTPPolicy;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationExecutionEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationFlowEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticatorConfigEntity;+import org.keycloak.models.map.realm.entity.MapClientInitialAccessEntity;+import org.keycloak.models.map.realm.entity.MapComponentEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderMapperEntity;+import org.keycloak.models.map.realm.entity.MapOTPPolicyEntity;+import org.keycloak.models.map.realm.entity.MapRequiredActionProviderEntity;+import org.keycloak.models.map.realm.entity.MapRequiredCredentialEntity;+import org.keycloak.models.map.realm.entity.MapWebAuthnPolicyEntity;++public abstract class AbstractRealmEntity<K> implements AbstractEntity<K> {++    private final K id;+    private String name;++    private Boolean enabled;+    private Boolean registrationAllowed;+    private Boolean registrationEmailAsUsername;+    private Boolean verifyEmail;+    private Boolean resetPasswordAllowed;+    private Boolean loginWithEmailAllowed;+    private Boolean duplicateEmailsAllowed;+    private Boolean rememberMe;+    private Boolean editUsernameAllowed;+    private Boolean revokeRefreshToken;+    private Boolean adminEventsEnabled;+    private Boolean adminEventsDetailsEnabled;+    private Boolean internationalizationEnabled;+    private Boolean allowUserManagedAccess;+    private Boolean offlineSessionMaxLifespanEnabled;+    private Boolean eventsEnabled;+    private Integer actionTokenGeneratedByUserLifespan = 12 * 60 * 60;+    private Integer refreshTokenMaxReuse;+    private Integer ssoSessionIdleTimeout;+    private Integer ssoSessionMaxLifespan;+    private Integer ssoSessionIdleTimeoutRememberMe;+    private Integer ssoSessionMaxLifespanRememberMe;+    private Integer offlineSessionIdleTimeout;+    private Integer accessTokenLifespan;+    private Integer accessTokenLifespanForImplicitFlow;+    private Integer accessCodeLifespan;+    private Integer accessCodeLifespanUserAction;+    private Integer accessCodeLifespanLogin;+    private Integer notBefore;+    private Integer clientSessionIdleTimeout;+    private Integer clientSessionMaxLifespan;+    private Integer clientOfflineSessionIdleTimeout;+    private Integer clientOfflineSessionMaxLifespan;+    private Integer actionTokenGeneratedByAdminLifespan;+    private Integer offlineSessionMaxLifespan;+    private Long eventsExpiration;+    private String displayName;+    private String displayNameHtml;+    private String passwordPolicy;+    private String sslRequired;+    private String loginTheme;+    private String accountTheme;+    private String adminTheme;+    private String emailTheme;+    private String masterAdminClient;+    private String defaultRoleId;+    private String defaultLocale;+    private String browserFlow;+    private String registrationFlow;+    private String directGrantFlow;+    private String resetCredentialsFlow;+    private String clientAuthenticationFlow;+    private String dockerAuthenticationFlow;+    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);;+    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;+    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;++    private final Set<String> defaultGroupIds = new HashSet<>();+    private final Set<String> eventsListeners = new HashSet<>();+    private final Set<String> enabledEventTypes = new HashSet<>();+    private final Set<String> supportedLocales = new HashSet<>();+    private final Set<String> defaultClientScopes = new HashSet<>();+    private final Set<String> optionalClientScopes = new HashSet<>();+    private final Map<String, String> browserSecurityHeaders = new HashMap<>();+    private final Map<String, String> smtpConfig = new HashMap<>();+    private final Map<String, String> attributes = new HashMap<>();+    private final Map<String, Map<String, String>> localizationTexts = new HashMap<>();+    private final Map<String, MapClientInitialAccessEntity> clientInitialAccesses = new HashMap<>();+    private final Map<String, MapComponentEntity> components = new HashMap<>();+    private final Map<String, MapAuthenticationFlowEntity> authenticationFlows = new HashMap<>();+    private final Map<String, MapAuthenticationExecutionEntity> authenticationExecutions = new HashMap<>();+    private final Map<String, MapRequiredCredentialEntity> requiredCredentials = new HashMap<>();+    private final Map<String, MapAuthenticatorConfigEntity> authenticatorConfigs = new HashMap<>();+    private final Map<String, MapIdentityProviderEntity> identityProviders = new HashMap<>();+    private final Map<String, MapIdentityProviderMapperEntity> identityProviderMappers = new HashMap<>();+    private final Map<String, MapRequiredActionProviderEntity> requiredActionProviders = new HashMap<>();++    /**+     * Flag signalizing that any of the setters has been meaningfully used.+     */+    protected boolean updated;++    protected AbstractRealmEntity() {+        this.id = null;+    }++    public AbstractRealmEntity(K id) {+        Objects.requireNonNull(id, ""id"");++        this.id = id;+    }++    @Override+    public K getId() {+        return this.id;+    }++    @Override+    public boolean isUpdated() {+        return this.updated;+    }++    public String getName() {+        return name;+    }++    public void setName(String name) {+        this.updated |= ! Objects.equals(this.name, name);+        this.name = name;+    }++    public String getDisplayName() {+        return displayName;+    }++    public void setDisplayName(String displayName) {+        this.updated |= ! Objects.equals(this.displayName, displayName);+        this.displayName = displayName;+    }++    public String getDisplayNameHtml() {+        return displayNameHtml;+    }++    public void setDisplayNameHtml(String displayNameHtml) {+        this.updated |= ! Objects.equals(this.displayNameHtml, displayNameHtml);+        this.displayNameHtml = displayNameHtml;+    }++    public Boolean isEnabled() {+        return enabled;+    }++    public void setEnabled(Boolean enabled) {+        this.updated |= ! Objects.equals(this.enabled, enabled);+        this.enabled = enabled;+    }++    public Boolean isRegistrationAllowed() {+        return registrationAllowed;+    }++    public void setRegistrationAllowed(Boolean registrationAllowed) {+        this.updated |= ! Objects.equals(this.registrationAllowed, registrationAllowed);+        this.registrationAllowed = registrationAllowed;+    }++    public Boolean isRegistrationEmailAsUsername() {+        return registrationEmailAsUsername;+    }++    public void setRegistrationEmailAsUsername(Boolean registrationEmailAsUsername) {+        this.updated |= ! Objects.equals(this.registrationEmailAsUsername, registrationEmailAsUsername);+        this.registrationEmailAsUsername = registrationEmailAsUsername;+    }++    public Boolean isVerifyEmail() {+        return verifyEmail;+    }++    public void setVerifyEmail(Boolean verifyEmail) {+        this.updated |= ! Objects.equals(this.verifyEmail, verifyEmail);+        this.verifyEmail = verifyEmail;+    }+    ++    public Boolean isResetPasswordAllowed() {+        return resetPasswordAllowed;+    }++    public void setResetPasswordAllowed(Boolean resetPasswordAllowed) {+        this.updated |= ! Objects.equals(this.resetPasswordAllowed, resetPasswordAllowed);+        this.resetPasswordAllowed = resetPasswordAllowed;+    }++    public Boolean isLoginWithEmailAllowed() {+        return loginWithEmailAllowed;+    }++    public void setLoginWithEmailAllowed(Boolean loginWithEmailAllowed) {+        this.updated |= ! Objects.equals(this.loginWithEmailAllowed, loginWithEmailAllowed);+        this.loginWithEmailAllowed = loginWithEmailAllowed;+    }++    public Boolean isDuplicateEmailsAllowed() {+        return duplicateEmailsAllowed;+    }++    public void setDuplicateEmailsAllowed(Boolean duplicateEmailsAllowed) {+        this.updated |= ! Objects.equals(this.duplicateEmailsAllowed, duplicateEmailsAllowed);+        this.duplicateEmailsAllowed = duplicateEmailsAllowed;+    }++    public Boolean isRememberMe() {+        return rememberMe;+    }++    public void setRememberMe(Boolean rememberMe) {+        this.updated |= ! Objects.equals(this.rememberMe, rememberMe);+        this.rememberMe = rememberMe;+    }++    public Boolean isEditUsernameAllowed() {+        return editUsernameAllowed;+    }++    public void setEditUsernameAllowed(Boolean editUsernameAllowed) {+        this.updated |= ! Objects.equals(this.editUsernameAllowed, editUsernameAllowed);+        this.editUsernameAllowed = editUsernameAllowed;+    }++    public Boolean isRevokeRefreshToken() {+        return revokeRefreshToken;+    }++    public void setRevokeRefreshToken(Boolean revokeRefreshToken) {+        this.updated |= ! Objects.equals(this.revokeRefreshToken, revokeRefreshToken);+        this.revokeRefreshToken = revokeRefreshToken;+    }++    public Boolean isAdminEventsEnabled() {+        return adminEventsEnabled;+    }++    public void setAdminEventsEnabled(Boolean adminEventsEnabled) {+        this.updated |= ! Objects.equals(this.adminEventsEnabled, adminEventsEnabled);+        this.adminEventsEnabled = adminEventsEnabled;+    }++    public Boolean isAdminEventsDetailsEnabled() {+        return adminEventsDetailsEnabled;+    }++    public void setAdminEventsDetailsEnabled(Boolean adminEventsDetailsEnabled) {+        this.updated |= ! Objects.equals(this.adminEventsDetailsEnabled, adminEventsDetailsEnabled);+        this.adminEventsDetailsEnabled = adminEventsDetailsEnabled;+    }++    public Boolean isInternationalizationEnabled() {+        return internationalizationEnabled;+    }++    public void setInternationalizationEnabled(Boolean internationalizationEnabled) {+        this.updated |= ! Objects.equals(this.internationalizationEnabled, internationalizationEnabled);+        this.internationalizationEnabled = internationalizationEnabled;+    }++    public Boolean isAllowUserManagedAccess() {+        return allowUserManagedAccess;+    }++    public void setAllowUserManagedAccess(Boolean allowUserManagedAccess) {+        this.updated |= ! Objects.equals(this.allowUserManagedAccess, allowUserManagedAccess);+        this.allowUserManagedAccess = allowUserManagedAccess;+    }++    public Boolean isOfflineSessionMaxLifespanEnabled() {+        return offlineSessionMaxLifespanEnabled;+    }++    public void setOfflineSessionMaxLifespanEnabled(Boolean offlineSessionMaxLifespanEnabled) {+        this.updated |= ! Objects.equals(this.offlineSessionMaxLifespanEnabled, offlineSessionMaxLifespanEnabled);+        this.offlineSessionMaxLifespanEnabled = offlineSessionMaxLifespanEnabled;+    }++    public Boolean isEventsEnabled() {+        return eventsEnabled;+    }++    public void setEventsEnabled(Boolean eventsEnabled) {+        this.updated |= ! Objects.equals(this.eventsEnabled, eventsEnabled);+        this.eventsEnabled = eventsEnabled;+    }++    public Integer getRefreshTokenMaxReuse() {+        return refreshTokenMaxReuse;+    }++    public void setRefreshTokenMaxReuse(Integer refreshTokenMaxReuse) {+        this.updated |= ! Objects.equals(this.refreshTokenMaxReuse, refreshTokenMaxReuse);+        this.refreshTokenMaxReuse = refreshTokenMaxReuse;+    }++    public Integer getSsoSessionIdleTimeout() {+        return ssoSessionIdleTimeout;+    }++    public void setSsoSessionIdleTimeout(Integer ssoSessionIdleTimeout) {+        this.updated |= ! Objects.equals(this.ssoSessionIdleTimeout, ssoSessionIdleTimeout);+        this.ssoSessionIdleTimeout = ssoSessionIdleTimeout;+    }++    public Integer getSsoSessionMaxLifespan() {+        return ssoSessionMaxLifespan;+    }++    public void setSsoSessionMaxLifespan(Integer ssoSessionMaxLifespan) {+        this.updated |= ! Objects.equals(this.ssoSessionMaxLifespan, ssoSessionMaxLifespan);+        this.ssoSessionMaxLifespan = ssoSessionMaxLifespan;+    }++    public Integer getSsoSessionIdleTimeoutRememberMe() {+        return ssoSessionIdleTimeoutRememberMe;+    }++    public void setSsoSessionIdleTimeoutRememberMe(Integer ssoSessionIdleTimeoutRememberMe) {+        this.updated |= ! Objects.equals(this.ssoSessionIdleTimeoutRememberMe, ssoSessionIdleTimeoutRememberMe);+        this.ssoSessionIdleTimeoutRememberMe = ssoSessionIdleTimeoutRememberMe;+    }++    public Integer getSsoSessionMaxLifespanRememberMe() {+        return ssoSessionMaxLifespanRememberMe;+    }++    public void setSsoSessionMaxLifespanRememberMe(Integer ssoSessionMaxLifespanRememberMe) {+        this.updated |= ! Objects.equals(this.ssoSessionMaxLifespanRememberMe, ssoSessionMaxLifespanRememberMe);+        this.ssoSessionMaxLifespanRememberMe = ssoSessionMaxLifespanRememberMe;+    }++    public Integer getOfflineSessionIdleTimeout() {+        return offlineSessionIdleTimeout;+    }++    public void setOfflineSessionIdleTimeout(Integer offlineSessionIdleTimeout) {+        this.updated |= ! Objects.equals(this.offlineSessionIdleTimeout, offlineSessionIdleTimeout);+        this.offlineSessionIdleTimeout = offlineSessionIdleTimeout;+    }++    public Integer getAccessTokenLifespan() {+        return accessTokenLifespan;+    }++    public void setAccessTokenLifespan(Integer accessTokenLifespan) {+        this.updated |= ! Objects.equals(this.accessTokenLifespan, accessTokenLifespan);+        this.accessTokenLifespan = accessTokenLifespan;+    }++    public Integer getAccessTokenLifespanForImplicitFlow() {+        return accessTokenLifespanForImplicitFlow;+    }++    public void setAccessTokenLifespanForImplicitFlow(Integer accessTokenLifespanForImplicitFlow) {+        this.updated |= ! Objects.equals(this.accessTokenLifespanForImplicitFlow, accessTokenLifespanForImplicitFlow);+        this.accessTokenLifespanForImplicitFlow = accessTokenLifespanForImplicitFlow;+    }++    public Integer getAccessCodeLifespan() {+        return accessCodeLifespan;+    }++    public void setAccessCodeLifespan(Integer accessCodeLifespan) {+        this.updated |= ! Objects.equals(this.accessCodeLifespan, accessCodeLifespan);+        this.accessCodeLifespan = accessCodeLifespan;+    }++    public Integer getAccessCodeLifespanUserAction() {+        return accessCodeLifespanUserAction;+    }++    public void setAccessCodeLifespanUserAction(Integer accessCodeLifespanUserAction) {+        this.updated |= ! Objects.equals(this.accessCodeLifespanUserAction, accessCodeLifespanUserAction);+        this.accessCodeLifespanUserAction = accessCodeLifespanUserAction;+    }++    public Integer getAccessCodeLifespanLogin() {+        return accessCodeLifespanLogin;+    }++    public void setAccessCodeLifespanLogin(Integer accessCodeLifespanLogin) {+        this.updated |= ! Objects.equals(this.accessCodeLifespanLogin, accessCodeLifespanLogin);+        this.accessCodeLifespanLogin = accessCodeLifespanLogin;+    }++    public Integer getNotBefore() {+        return notBefore;+    }++    public void setNotBefore(Integer notBefore) {+        this.updated |= ! Objects.equals(this.notBefore, notBefore);+        this.notBefore = notBefore;+    }++    public Integer getClientSessionIdleTimeout() {+        return clientSessionIdleTimeout;+    }++    public void setClientSessionIdleTimeout(Integer clientSessionIdleTimeout) {+        this.updated |= ! Objects.equals(this.clientSessionIdleTimeout, clientSessionIdleTimeout);+        this.clientSessionIdleTimeout = clientSessionIdleTimeout;+    }++    public Integer getClientSessionMaxLifespan() {+        return clientSessionMaxLifespan;+    }++    public void setClientSessionMaxLifespan(Integer clientSessionMaxLifespan) {+        this.updated |= ! Objects.equals(this.clientSessionMaxLifespan, clientSessionMaxLifespan);+        this.clientSessionMaxLifespan = clientSessionMaxLifespan;+    }++    public Integer getClientOfflineSessionIdleTimeout() {+        return clientOfflineSessionIdleTimeout;+    }++    public void setClientOfflineSessionIdleTimeout(Integer clientOfflineSessionIdleTimeout) {+        this.updated |= ! Objects.equals(this.clientOfflineSessionIdleTimeout, clientOfflineSessionIdleTimeout);+        this.clientOfflineSessionIdleTimeout = clientOfflineSessionIdleTimeout;+    }++    public Integer getClientOfflineSessionMaxLifespan() {+        return clientOfflineSessionMaxLifespan;+    }++    public void setClientOfflineSessionMaxLifespan(Integer clientOfflineSessionMaxLifespan) {+        this.updated |= ! Objects.equals(this.clientOfflineSessionMaxLifespan, clientOfflineSessionMaxLifespan);+        this.clientOfflineSessionMaxLifespan = clientOfflineSessionMaxLifespan;+    }++    public Integer getActionTokenGeneratedByAdminLifespan() {+        return actionTokenGeneratedByAdminLifespan;+    }++    public void setActionTokenGeneratedByAdminLifespan(Integer actionTokenGeneratedByAdminLifespan) {+        this.updated |= ! Objects.equals(this.actionTokenGeneratedByAdminLifespan, actionTokenGeneratedByAdminLifespan);+        this.actionTokenGeneratedByAdminLifespan = actionTokenGeneratedByAdminLifespan;+    }++    public Integer getActionTokenGeneratedByUserLifespan() {+        return actionTokenGeneratedByUserLifespan;+    }++    public void setActionTokenGeneratedByUserLifespan(Integer actionTokenGeneratedByUserLifespan) {+        this.updated |= ! Objects.equals(this.actionTokenGeneratedByUserLifespan, actionTokenGeneratedByUserLifespan);+        this.actionTokenGeneratedByUserLifespan = actionTokenGeneratedByUserLifespan;+    }++    public Integer getOfflineSessionMaxLifespan() {+        return offlineSessionMaxLifespan;+    }++    public void setOfflineSessionMaxLifespan(Integer offlineSessionMaxLifespan) {+        this.updated |= ! Objects.equals(this.offlineSessionMaxLifespan, offlineSessionMaxLifespan);+        this.offlineSessionMaxLifespan = offlineSessionMaxLifespan;+    }++    public Long getEventsExpiration() {+        return eventsExpiration;+    }++    public void setEventsExpiration(Long eventsExpiration) {+        this.updated |= ! Objects.equals(this.eventsExpiration, eventsExpiration);+        this.eventsExpiration = eventsExpiration;+    }++    public String getPasswordPolicy() {+        return passwordPolicy;+    }++    public void setPasswordPolicy(String passwordPolicy) {+        this.updated |= ! Objects.equals(this.passwordPolicy, passwordPolicy);+        this.passwordPolicy = passwordPolicy;+    }++    public String getSslRequired() {+        return sslRequired;+    }++    public void setSslRequired(String sslRequired) {+        this.updated |= ! Objects.equals(this.sslRequired, sslRequired);+        this.sslRequired = sslRequired;+    }++    public String getLoginTheme() {+        return loginTheme;+    }++    public void setLoginTheme(String loginTheme) {+        this.updated |= ! Objects.equals(this.loginTheme, loginTheme);+        this.loginTheme = loginTheme;+    }++    public String getAccountTheme() {+        return accountTheme;+    }++    public void setAccountTheme(String accountTheme) {+        this.updated |= ! Objects.equals(this.accountTheme, accountTheme);+        this.accountTheme = accountTheme;+    }++    public String getAdminTheme() {+        return adminTheme;+    }++    public void setAdminTheme(String adminTheme) {+        this.updated |= ! Objects.equals(this.adminTheme, adminTheme);+        this.adminTheme = adminTheme;+    }++    public String getEmailTheme() {+        return emailTheme;+    }++    public void setEmailTheme(String emailTheme) {+        this.updated |= ! Objects.equals(this.emailTheme, emailTheme);+        this.emailTheme = emailTheme;+    }++    public String getMasterAdminClient() {+        return masterAdminClient;+    }++    public void setMasterAdminClient(String masterAdminClient) {+        this.updated |= ! Objects.equals(this.masterAdminClient, masterAdminClient);+        this.masterAdminClient = masterAdminClient;+    }++    public String getDefaultRoleId() {+        return defaultRoleId;+    }++    public void setDefaultRoleId(String defaultRoleId) {+        this.updated |= ! Objects.equals(this.defaultRoleId, defaultRoleId);+        this.defaultRoleId = defaultRoleId;+    }++    public String getDefaultLocale() {+        return defaultLocale;+    }++    public void setDefaultLocale(String defaultLocale) {+        this.updated |= ! Objects.equals(this.defaultLocale, defaultLocale);+        this.defaultLocale = defaultLocale;+    }++    public String getBrowserFlow() {+        return browserFlow;+    }++    public void setBrowserFlow(String browserFlow) {+        this.updated |= ! Objects.equals(this.browserFlow, browserFlow);+        this.browserFlow = browserFlow;+    }++    public String getRegistrationFlow() {+        return registrationFlow;+    }++    public void setRegistrationFlow(String registrationFlow) {+        this.updated |= ! Objects.equals(this.registrationFlow, registrationFlow);+        this.registrationFlow = registrationFlow;+    }++    public String getDirectGrantFlow() {+        return directGrantFlow;+    }++    public void setDirectGrantFlow(String directGrantFlow) {+        this.updated |= ! Objects.equals(this.directGrantFlow, directGrantFlow);+        this.directGrantFlow = directGrantFlow;+    }++    public String getResetCredentialsFlow() {+        return resetCredentialsFlow;+    }++    public void setResetCredentialsFlow(String resetCredentialsFlow) {+        this.updated |= ! Objects.equals(this.resetCredentialsFlow, resetCredentialsFlow);+        this.resetCredentialsFlow = resetCredentialsFlow;+    }++    public String getClientAuthenticationFlow() {+        return clientAuthenticationFlow;+    }++    public void setClientAuthenticationFlow(String clientAuthenticationFlow) {+        this.updated |= ! Objects.equals(this.clientAuthenticationFlow, clientAuthenticationFlow);+        this.clientAuthenticationFlow = clientAuthenticationFlow;+    }++    public String getDockerAuthenticationFlow() {+        return dockerAuthenticationFlow;+    }++    public void setDockerAuthenticationFlow(String dockerAuthenticationFlow) {+        this.updated |= ! Objects.equals(this.dockerAuthenticationFlow, dockerAuthenticationFlow);+        this.dockerAuthenticationFlow = dockerAuthenticationFlow;+    }++    public MapOTPPolicyEntity getOTPPolicy() {+        return otpPolicy;+    }++    public void setOTPPolicy(MapOTPPolicyEntity otpPolicy) {+        this.updated |= ! Objects.equals(this.otpPolicy, otpPolicy);+        this.otpPolicy = otpPolicy;+    }++    public MapWebAuthnPolicyEntity getWebAuthnPolicy() {+        return webAuthnPolicy;+    }++    public void setWebAuthnPolicy(MapWebAuthnPolicyEntity webAuthnPolicy) {+        this.updated |= ! Objects.equals(this.webAuthnPolicy, webAuthnPolicy);+        this.webAuthnPolicy = webAuthnPolicy;+    }++    public MapWebAuthnPolicyEntity getWebAuthnPolicyPasswordless() {+        return webAuthnPolicyPasswordless;+    }++    public void setWebAuthnPolicyPasswordless(MapWebAuthnPolicyEntity webAuthnPolicyPasswordless) {+        this.updated |= ! Objects.equals(this.webAuthnPolicyPasswordless, webAuthnPolicyPasswordless);+        this.webAuthnPolicyPasswordless = webAuthnPolicyPasswordless;+    }++    public void setAttribute(String name, String value) {+        this.updated |= !Objects.equals(this.attributes.put(name, value), value);+    }++    public void removeAttribute(String name) {+        this.updated |= attributes.remove(name) != null;+    }++    public String getAttribute(String name) {+        return attributes.get(name);+    }++    public Map<String, String> getAttributes() {+        return attributes;+    }++    public void addDefaultClientScope(String scopeId) {+        this.updated |= this.defaultClientScopes.add(scopeId);+    }++    public Stream<String> getDefaultClientScopeIds() {+        return defaultClientScopes.stream();+    }++    public void addOptionalClientScope(String scopeId) {+        this.updated |= this.optionalClientScopes.add(scopeId);+    }++    public Stream<String> getOptionalClientScopeIds() {+        return optionalClientScopes.stream();+    }++    public void removeDefaultOrOptionalClientScope(String scopeId) {+        if (this.defaultClientScopes.remove(scopeId)) {+            this.updated = true;+            return ;+        }+        this.updated |= this.optionalClientScopes.remove(scopeId);+    }++    public Stream<String> getDefaultGroupIds() {+        return defaultGroupIds.stream();+    }++    public void addDefaultGroup(String groupId) {+        this.updated |= this.defaultGroupIds.add(groupId);+    }++    public void removeDefaultGroup(String groupId) {+        this.updated |= this.defaultGroupIds.remove(groupId);+    }++    public Set<String> getEventsListeners() {+        return eventsListeners;+    }++    public void setEventsListeners(Set<String> eventsListeners) {+        if (eventsListeners == null) return;+        this.updated |= ! Objects.equals(eventsListeners, this.eventsListeners);+        this.eventsListeners.clear();+        this.eventsListeners.addAll(eventsListeners);+    }++    public Set<String> getEnabledEventTypes() {+        return enabledEventTypes;+    }++    public void setEnabledEventTypes(Set<String> enabledEventTypes) {+        if (enabledEventTypes == null) return;+        this.updated |= ! Objects.equals(enabledEventTypes, this.enabledEventTypes);+        this.enabledEventTypes.clear();+        this.enabledEventTypes.addAll(enabledEventTypes);+    }++    public Set<String> getSupportedLocales() {+        return supportedLocales;+    }++    public void setSupportedLocales(Set<String> supportedLocales) {+        if (supportedLocales == null) return;+        this.updated |= ! Objects.equals(supportedLocales, this.supportedLocales);+        this.supportedLocales.clear();+        this.supportedLocales.addAll(supportedLocales);+    }++    public Map<String, Map<String, String>> getLocalizationTexts() {+        return localizationTexts;+    }++    public Map<String, String> getLocalizationText(String locale) {+        if (localizationTexts.containsKey(locale)) {+            return localizationTexts.get(locale);+        }+        return Collections.emptyMap();+    }++    public void addLocalizationTexts(String locale, Map<String, String> texts) {+        if (! localizationTexts.containsKey(locale)) {",Doesn't the suggestion change the semantic a little bit?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7877,601121016,2021-03-25T07:01:22Z,server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java,"@@ -92,4 +94,14 @@      * @return Stream of ClientModel or an empty stream if no client is found. Never returns {@code null}.      */     Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults);++    /**+     * Return all default scopes (if 'defaultScope' is true) or all optional scopes (if 'defaultScope' is false) linked with the client+     *+     * @param client Client+     * @param defaultScopes if true default scopes, if false optional scopes, are returned+     * @param filterByProtocol if true, then just client scopes of same protocol like current client will be returned+     * @return map where key is the name of the clientScope, value is particular clientScope. Returns empty map if no scopes linked (never returns null).+     */+    Map<String, ClientScopeModel> getClientScopes(ClientModel client, boolean defaultScopes, boolean filterByProtocol);","I would agree that KEYCLOAK-16559 is a bug. The fact is though that there might be some scopes assigned to existing clients in existing installations that do not respect the client protocol. Hence the proposal is to perform the filtering by default in the provider (as if `filterByProtocol` was `true`) but do not expose this as a parameter to limit space for mistakes. Similarly, adding a scope that does not respect the protocol would be silently ignored in `addClientScopes` provider.Would that work for you @mposolda, @vramik?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7842,601181180,2021-03-25T08:16:48Z,model/map/src/main/java/org/keycloak/models/map/realm/MapRealmProvider.java,"@@ -0,0 +1,469 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.realm;++import java.util.HashMap;+import java.util.Map;+import java.util.Objects;+import java.util.function.Function;+import java.util.stream.Stream;+import org.jboss.logging.Logger;+import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientScopeModel;+import org.keycloak.models.GroupModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.RealmModel.SearchableFields;+import org.keycloak.models.RealmProvider;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.common.StreamUtils;+import org.keycloak.models.map.common.StreamUtils.Pair;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.models.utils.KeycloakModelUtils;++public class MapRealmProvider implements RealmProvider {++    private static final Logger LOG = Logger.getLogger(MapRealmProvider.class);+    private final KeycloakSession session;+    final MapKeycloakTransaction<String, MapRealmEntity, RealmModel> tx;+    private final MapStorage<String, MapRealmEntity, RealmModel> realmStore;++    public MapRealmProvider(KeycloakSession session, MapStorage<String, MapRealmEntity, RealmModel> realmStore) {+        this.session = session;+        this.realmStore = realmStore;+        this.tx = new MapKeycloakTransaction<>(realmStore);+        session.getTransactionManager().enlist(tx);+    }++    private Function<MapRealmEntity, RealmModel> entityToAdapterFunc() {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller++        return origEntity -> new MapRealmAdapter(session, registerEntityForChanges(origEntity));+    }++    private MapRealmEntity registerEntityForChanges(MapRealmEntity origEntity) {+        final MapRealmEntity res = Serialization.from(origEntity);+        tx.updateIfChanged(origEntity.getId(), res, MapRealmEntity::isUpdated);+        return res;+    }++    @Override+    public RealmModel createRealm(String name) {+        return createRealm(KeycloakModelUtils.generateId(), name);+    }++    @Override+    public RealmModel createRealm(String id, String name) {+        if (getRealmByName(name) != null) {+            throw new ModelDuplicateException(""Realm with given name exists: "" + name);+        }++        final String entityId = id == null ? KeycloakModelUtils.generateId() : id;++        LOG.tracef(""createRealm(%s, %s)%s"", id, name, getShortStackTrace());++        MapRealmEntity entity = new MapRealmEntity(entityId);+        entity.setName(name);+        if (tx.read(entity.getId()) != null) {+            throw new ModelDuplicateException(""Realm exists: "" + entityId);+        }+        tx.create(entityId, entity);+        return entityToAdapterFunc().apply(entity);+    }++    @Override+    public RealmModel getRealm(String id) {+        if (id == null) {+            return null;+        }++        LOG.tracef(""getRealm(%s)%s"", id, getShortStackTrace());++        MapRealmEntity entity = tx.read(id);+        return entity == null ? null : entityToAdapterFunc().apply(entity);+    }++    @Override+    public RealmModel getRealmByName(String name) {+        if (name == null) return null;++        LOG.tracef(""getRealmByName(%s)%s"", name, getShortStackTrace());++        ModelCriteriaBuilder<RealmModel> mcb = realmStore.createCriteriaBuilder()+                .compare(SearchableFields.NAME, Operator.EQ, name);++        String realmId = tx.getUpdatedNotRemoved(mcb)+                .findFirst()+                .map(MapRealmEntity::getId)+                .orElse(null);+        //we need to go via session.realms() not to bypass cache+        return realmId == null ? null : session.realms().getRealm(realmId);+    }++    @Override+    public Stream<RealmModel> getRealmsStream() {+        return tx.getUpdatedNotRemoved(realmStore.createCriteriaBuilder())+                .map(entityToAdapterFunc())+                .sorted(RealmModel.COMPARE_BY_NAME);+    }++    @Override+    public Stream<RealmModel> getRealmsWithProviderTypeStream(Class<?> type) {+        return StreamUtils.leftInnerJoinStream(tx.getUpdatedNotRemoved(realmStore.createCriteriaBuilder()), MapRealmEntity::getComponents) // create pair of realm and its components","The advantage is, that currently, you need to download all data from storage and filter it in the stream. However, with MCB, you can filter it on storage level. This means that in case the storage is a database, you will download only entities that fulfill the MCB condition.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7842,601367702,2021-03-25T11:05:27Z,model/map/src/main/java/org/keycloak/models/map/realm/MapRealmEntity.java,"@@ -0,0 +1,29 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.realm;++public class MapRealmEntity extends AbstractRealmEntity<String> {","There are used non-uuid strings (names) as realm ids across current codebase, especially for `master` realm. https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/services/managers/RealmManager.java#L95There are several places which uses this behaviour: https://github.com/keycloak/keycloak/blob/master/core/src/main/java/org/keycloak/Config.java#L32Also current installations can have non-uuid string id. The issue was discussed a while ago and the conclusion was (if I recall correctly) that we should stop using realmName as id, but we don't have a capacity for such change right now. We'd also need to provide migration path for current installations and take into an account old exported realm.json files.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7877,601630532,2021-03-25T16:07:30Z,server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java,"@@ -92,4 +94,14 @@      * @return Stream of ClientModel or an empty stream if no client is found. Never returns {@code null}.      */     Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults);++    /**+     * Return all default scopes (if 'defaultScope' is true) or all optional scopes (if 'defaultScope' is false) linked with the client+     *+     * @param client Client+     * @param defaultScopes if true default scopes, if false optional scopes, are returned+     * @param filterByProtocol if true, then just client scopes of same protocol like current client will be returned+     * @return map where key is the name of the clientScope, value is particular clientScope. Returns empty map if no scopes linked (never returns null).+     */+    Map<String, ClientScopeModel> getClientScopes(ClientModel client, boolean defaultScopes, boolean filterByProtocol);","As for the current usages, the `filterByProtocol == false` cases do not make sense. According to the code, they are used in these places:- `ModelToRepresentation` and `RepresentationToModel` conversions - only stores / restores data but does not use it- `ClientScopesClientRegistrationPolicy.beforeUpdate` - there is the check what client scopes to add but only those for the correct protocol would be added anyway if the proposal above was followed, effectively behaving like if `filterByProtocol == true`- `KeycloakModelUtils.isClientScopeUsed` is only used by classes from that would be updated in this PRAll the rest is either tests or use `filterByProtocol == true` Hence by removing `filterByProtocol`, there is no functional change.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,601875437,2021-03-25T22:18:53Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java,"@@ -0,0 +1,243 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.Collections;+import java.util.Optional;++import com.fasterxml.jackson.databind.node.ObjectNode;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.Profile;+import org.keycloak.common.util.Time;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.CibaConfig;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;+import org.keycloak.util.JsonSerialization;+import org.keycloak.utils.ProfileHelper;++public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {++    private final RealmModel realm;++    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+        this.realm = session.getContext().getRealm();+        event.event(EventType.LOGIN);+    }++    @POST+    @NoCache+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processGrantRequest(@Context HttpRequest httpRequest) {+        ProfileHelper.requireFeature(Profile.Feature.CIBA);+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());++        try {+            String authReqId = request.serialize(session);+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);++            if (provider == null) {+                throw new RuntimeException(""Authentication Channel Provider not found."");+            }++            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);++            if (resolver == null) {+                throw new RuntimeException(""CIBA Login User Resolver not setup properly."");+            }++            UserModel user = request.getUser();++            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);++            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {+                CibaConfig cibaPolicy = realm.getCibaPolicy();+                int poolingInterval = cibaPolicy.getPoolingInterval();++                storeAuthenticationRequest(request, cibaPolicy);++                ObjectNode response = JsonSerialization.createObjectNode();++                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());++                if (poolingInterval > 0) {+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);+                }++                return Response.ok(JsonSerialization.writeValueAsBytes(response))+                        .build();+            }+        } catch (Exception e) {+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Failed to send authentication request"", Response.Status.SERVICE_UNAVAILABLE);+        }++        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Unexpected response from authentication device"", Response.Status.SERVICE_UNAVAILABLE);+    }++    /**+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case+     * that relies on cross-references for unsolicited user authentication requests from devices.+     */+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {+        ClientModel client = request.getClient();+        int expiresIn = cibaConfig.getExpiresIn();+        int poolingInterval = cibaConfig.getPoolingInterval();++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,+                Collections.emptyMap());+        String authResultId = request.getAuthResultId();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),+                authResultId);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + poolingInterval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);++        store.put(deviceCode, userCode, lifespanSeconds);+    }++    private AuthenticationRequest authorizeClient(MultivaluedMap<String, String> params) {+        ClientModel client = authenticateClient();+        UserModel user = resolveUser(params, realm.getCibaPolicy().getAuthRequestedUserHint());++        AuthenticationRequest request = new AuthenticationRequest(session, user, client);++        request.setClient(client);++        String scope = params.getFirst(OAuth2Constants.SCOPE);++        if (scope == null)+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, ""missing parameter : scope"",+                    Response.Status.BAD_REQUEST);++        request.setScope(scope);++        request.setBindingMessage(params.getFirst(CibaGrantType.BINDING_MESSAGE));++        CibaConfig policy = realm.getCibaPolicy();++        // create JWE encoded auth_req_id from Auth Req ID.+        Integer expiresIn = policy.getExpiresIn();+        String requestedExpiry = params.getFirst(CibaGrantType.REQUESTED_EXPIRY);++        if (requestedExpiry != null) {+            expiresIn = Integer.valueOf(requestedExpiry);+        }++        request.exp(Time.currentTime() + expiresIn.longValue());++        StringBuilder scopes = new StringBuilder(Optional.ofNullable(request.getScope()).orElse(""""));+        client.getClientScopes(true, true)+                .forEach((key, value) -> {+                    if (value.isDisplayOnConsentScreen())+                        scopes.append("" "").append(value.getName());+                });+        request.setScope(scopes.toString());++        String clientNotificationToken = params.getFirst(CibaGrantType.CLIENT_NOTIFICATION_TOKEN);++        if (clientNotificationToken != null) {+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST,+                    ""Ping and push modes not supported. Use poll mode instead."", Response.Status.BAD_REQUEST);+        }++        String userCode = params.getFirst(OAuth2Constants.USER_CODE);++        if (userCode != null) {+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, ""User code not supported"",+                    Response.Status.BAD_REQUEST);+        }++        String acrValues = params.getFirst(OAuth2Constants.ACR_VALUES);++        if (acrValues != null) {","@mposolda @pedroigor IMO, this point might be treated afterwards as some follow-up PR by considering the following points.- `acr` has not yet been supported completely (mentioned in [KEYCLOAK-3314](https://issues.redhat.com/browse/KEYCLOAK-3314)) .- this PR's [design document](https://github.com/keycloak/keycloak-community/blob/master/design/client-initiated-backchannel-authentication-flow.md) does not treat `acr_values` of CIBA's parameter.At first, we may have to support `acr` completely. IMO, we need to make keycloak assign `acr` value onto each an authentication flow. Also, considering the point that keycloak's user may choose their preferable [LoA profile](https://www.iana.org/assignments/loa-profiles/loa-profiles.xhtml) (e.g. [NIST's SP 800-63-3](https://pages.nist.gov/800-63-3/), [InCommon](https://www.incommon.org/federation/incommon-assurance-program/), [eIDAS](https://ec.europa.eu/cefdigital/wiki/display/CEFDIGITAL/eIDAS+Levels+of+assurance)), keycloak's administrator can assign `acr` value onto each the authentication flow by themselves.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,601883359,2021-03-25T22:37:42Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java,"@@ -0,0 +1,172 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.jboss.resteasy.util.HttpHeaderNames;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;++public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {++    public static final String SUCCEEDED = ""succeeded"";+    public static final String UNAUTHORIZED = ""unauthorized"";+    public static final String CANCELLED = ""cancelled"";++    @Context+    private HttpRequest httpRequest;++    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+    }++    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processAuthenticationChannelResult() {","@mposolda @pedroigor +1 . It might be preferable if we could separate ""proprietary"" part and realize it as an individual class. `AuthenticationChannelProvider` and its implementation classes are ideal for it.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,602069550,2021-03-26T07:37:12Z,services/src/main/java/org/keycloak/services/clientregistration/oidc/DescriptionConverter.java,"@@ -270,6 +274,10 @@ public static OIDCClientRepresentation toExternalResponse(KeycloakSession sessio         response.setBackchannelLogoutSessionRequired(config.isBackchannelLogoutSessionRequired());         response.setBackchannelLogoutSessionRequired(config.getBackchannelLogoutRevokeOfflineTokens()); +        if (config.getBackchannelTokenDeliveryMode() != null) {+            response.setBackchannelTokenDeliveryMode(config.getBackchannelTokenDeliveryMode());+        }+         List<ProtocolMapperRepresentation> foundPairwiseMappers = PairwiseSubMapperUtils.getPairwiseSubMappers(client);         SubjectType subjectType = foundPairwiseMappers.isEmpty() ? SubjectType.PUBLIC : SubjectType.PAIRWISE;         response.setSubjectType(subjectType.toString().toLowerCase());","+1. The OIDC client registration specification ( https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata ) mentions this: `The following table lists the correspondence between response_type values that the Client will use and grant_type values that MUST be included in the registered grant_types list .`So in theory, we may throw the exception during client registration in case that `grant_types` and `response_types` are incompatible? For example if `response_types` is just `authorization_code`, but the `grant_types` has also grants for implicit/hybrid flow like `code id_token` etc.But that is maybe something for the future? For CIBA, there is no corresponding response type AFAIK (Similarly like for example for Resource Owner Password Credentials or Client Credentials Grant). Hence in this PR, I would just convert grant type for CIBA to the corresponding switch of client as you suggested.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,602076324,2021-03-26T07:51:27Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java,"@@ -0,0 +1,172 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.jboss.resteasy.util.HttpHeaderNames;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;++public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {++    public static final String SUCCEEDED = ""succeeded"";+    public static final String UNAUTHORIZED = ""unauthorized"";+    public static final String CANCELLED = ""cancelled"";++    @Context+    private HttpRequest httpRequest;++    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+    }++    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processAuthenticationChannelResult() {",Yeah. I suppose that this may not be so big change as we will just need to:- introduce new method on AuthenticationChannelProvider. Maybe like `handleCallback` or something like that?- move most of the logic from BackchannelAuthenticationCallbackEndpoint to that new method on AuthenticationChannelProvider . BackchannelAuthenticationCallbackEndpoint might just need to call this AuthenticationChannelPRovider.handleCallback and that's it mostly?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,602092714,2021-03-26T08:23:05Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","@tnorimat +1 to include the identity in the `authentication_channel_id` as you proposed.Another related thing is, if we want to change `authentication_channel_id` request to be JWS instead of JWE as @pedroigor proposed? This will have the advantage that all the info can be wrapped into the JWS token and the AD can read the data directly from it instead of including many other parameters in the request sent from `HttpAuthenticationChannelProvider.sendRequest` (In case of JWE, the `authentication_channel_id` is opaque string to the AD).For the last point for `auth_req_id`, to me whatever works, which will make sure that `auth_req_id` and `authentication_channel_id` are not inter-changeable with each other. As the fact they are inter-changeable means the security whole when client is able to do whole CIBA flow without any interaction needed from the user. In other words, we need to somehow make sure that the test testAttackerClientUseAuthReqIdInCallbackEndpoint  I sent in the commit https://github.com/mposolda/keycloak/tree/KEYCLOAK-12137 will pass.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,602093242,2021-03-26T08:24:04Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java,"@@ -0,0 +1,172 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Path;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;++import org.jboss.logging.Logger;+import org.jboss.resteasy.spi.HttpRequest;+import org.jboss.resteasy.util.HttpHeaderNames;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;++public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {++    public static final String SUCCEEDED = ""succeeded"";+    public static final String UNAUTHORIZED = ""unauthorized"";+    public static final String CANCELLED = ""cancelled"";++    @Context+    private HttpRequest httpRequest;++    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+    }++    @Path(""/"")+    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processAuthenticationChannelResult() {+        event.event(EventType.LOGIN);++        authenticateClient();","@tnorimat I've replied to this in the other comment https://github.com/keycloak/keycloak/pull/7679#discussion_r602092714 , so we not discuss same/similar thing on two places.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7877,602104268,2021-03-26T08:43:20Z,server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java,"@@ -92,4 +94,14 @@      * @return Stream of ClientModel or an empty stream if no client is found. Never returns {@code null}.      */     Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults);++    /**+     * Return all default scopes (if 'defaultScope' is true) or all optional scopes (if 'defaultScope' is false) linked with the client+     *+     * @param client Client+     * @param defaultScopes if true default scopes, if false optional scopes, are returned+     * @param filterByProtocol if true, then just client scopes of same protocol like current client will be returned+     * @return map where key is the name of the clientScope, value is particular clientScope. Returns empty map if no scopes linked (never returns null).+     */+    Map<String, ClientScopeModel> getClientScopes(ClientModel client, boolean defaultScopes, boolean filterByProtocol);","I agree with remove `filterByProtocol` parameter. As long as existing tests are passing, we should be fine. From the long-term, it will be good to address KEYCLOAK-16559, which will make sure that client can't never have clientScopes of different protocols.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7756,602108301,2021-03-26T08:49:56Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanSamlArtifactSessionMappingStoreProvider.java,"@@ -0,0 +1,126 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.sessions.infinispan;++import org.infinispan.client.hotrod.exceptions.HotRodClientException;+import org.infinispan.commons.api.BasicCache;+import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.SamlArtifactSessionMappingModel;+import org.keycloak.models.SamlArtifactSessionMappingStoreProvider;+import org.keycloak.models.sessions.infinispan.entities.ActionTokenValueEntity;+import org.keycloak.models.sessions.infinispan.util.InfinispanUtil;++import java.util.HashMap;+import java.util.Map;+import java.util.UUID;+import java.util.concurrent.TimeUnit;+import java.util.function.Supplier;+++/**+ * @author mhajas+ */+public class InfinispanSamlArtifactSessionMappingStoreProvider implements SamlArtifactSessionMappingStoreProvider {++    public static final Logger logger = Logger.getLogger(InfinispanSamlArtifactSessionMappingStoreProvider.class);++    private static final String USER_SESSION_ID = ""user.session.id"";+    private static final String CLIENT_SESSION_ID = ""client.session.id"";++    private final Supplier<BasicCache<UUID, ActionTokenValueEntity>> codeCache;","AFAIK The reason is this https://github.com/keycloak/keycloak/blob/master/model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanSingleUseTokenStoreProviderFactory.java#L71 as this is the per-invocation flag in remoteCache to FORCE_RETURN_VALUE. At least at the time when we worked on this it was per-invocation flag (but it is a chance that this is changed in latest infinispan version). This might be needed for the cache operations, which are supposed to return something. Like for example `putIfAbsent` or `remove`.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7877,602153021,2021-03-26T09:59:20Z,server-spi/src/main/java/org/keycloak/models/ClientProvider.java,"@@ -146,4 +147,22 @@ default ClientModel addClient(RealmModel realm, String clientId) {      * @param realm Realm.      */     void removeClients(RealmModel realm);++    /**+     * Assign clientScopes to the client. Add as default scopes (if parameter 'defaultScope' is true) +     * or optional scopes (if parameter 'defaultScope' is false)+     * +     * @param client Client.+     * @param clientScopes to be assigned+     * @param defaultScope if true the scopes are assigned as default, or optional in case of false +     */+    void addClientScopes(ClientModel client, Set<ClientScopeModel> clientScopes, boolean defaultScope);",Add `RealmModel realm` parameter as well.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7877,602153070,2021-03-26T09:59:23Z,server-spi/src/main/java/org/keycloak/models/ClientProvider.java,"@@ -146,4 +147,22 @@ default ClientModel addClient(RealmModel realm, String clientId) {      * @param realm Realm.      */     void removeClients(RealmModel realm);++    /**+     * Assign clientScopes to the client. Add as default scopes (if parameter 'defaultScope' is true) +     * or optional scopes (if parameter 'defaultScope' is false)+     * +     * @param client Client.+     * @param clientScopes to be assigned+     * @param defaultScope if true the scopes are assigned as default, or optional in case of false +     */+    void addClientScopes(ClientModel client, Set<ClientScopeModel> clientScopes, boolean defaultScope);++    /**+     * Unassign clientScope from the client. +     * +     * @param client Client.+     * @param clientScope to be unassigned+     */+    void removeClientScope(ClientModel client, ClientScopeModel clientScope);",Add `RealmModel realm` parameter as well.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7877,602153138,2021-03-26T09:59:29Z,server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java,"@@ -92,4 +94,14 @@      * @return Stream of ClientModel or an empty stream if no client is found. Never returns {@code null}.      */     Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults);++    /**+     * Return all default scopes (if {@code defaultScope} is {@code true}) or all optional scopes (if {@code defaultScope} is {@code false}) linked with the client+     *+     * @param client Client+     * @param defaultScopes if true default scopes, if false optional scopes, are returned+     * @param filterByProtocol if true, then just client scopes of same protocol like current client will be returned+     * @return map where key is the name of the clientScope, value is particular clientScope. Returns empty map if no scopes linked (never returns null).+     */+    Map<String, ClientScopeModel> getClientScopes(ClientModel client, boolean defaultScopes, boolean filterByProtocol);",Add `RealmModel realm` parameter as well.,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7793,602347670,2021-03-26T14:40:42Z,themes/src/main/resources/theme/keycloak/login/theme.properties,"@@ -104,6 +104,7 @@ kcAuthenticatorWebAuthnPasswordlessClass=fa fa-key list-view-pf-icon-lg  ##### css classes for the OTP Login Form kcLoginOTPListClass=pf-c-tile otp-tile+kcLoginOTPListInputClass=pf-c-tile__input kcLoginOTPListItemHeaderClass=pf-c-tile__header kcLoginOTPListItemIconBodyClass=pf-c-tile__icon otp-tile-icon",Could you please remove the unused `otp-tile-icon` class in line 109?,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7793,602352954,2021-03-26T14:47:18Z,themes/src/main/resources/theme/keycloak/login/theme.properties,"@@ -104,6 +104,7 @@ kcAuthenticatorWebAuthnPasswordlessClass=fa fa-key list-view-pf-icon-lg  ##### css classes for the OTP Login Form kcLoginOTPListClass=pf-c-tile otp-tile",Is it possible to remove the `otp-tile` class?,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7793,602355003,2021-03-26T14:49:42Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/LoginTotpPage.java,"@@ -114,20 +114,20 @@ public String getSelectedOtpCredential() {     }      private By getXPathForLookupAllCards() {-        return By.xpath(""//div[contains(@class, 'pf-c-tile otp-tile')]"");+        return By.xpath(""//span[contains(@class, 'pf-c-tile__title')]"");     } -    private By getXPathForLookupActiveCard() {-        return By.xpath(""//div[contains(@class, 'otp-tile pf-m-selected')]"");+    private By getCssSelectorForLookupActiveCard() {+        return By.cssSelector("".pf-c-tile__input:checked + .pf-c-tile .pf-c-tile__title"");     }      private By getXPathForLookupCardWithName(String credentialName) {-        return By.xpath(""//div[contains(@class, 'otp-tile')][normalize-space() = '""+ credentialName +""']"");+        return By.xpath(""//label[contains(@class, 'otp-tile')][normalize-space() = '""+ credentialName +""']"");",Is it possible to map the element by `pf-c-tile` class and remove the `otp-tile` class? And the same in the `assertOtpCredentialSelectorAvailability` method? WDYT?,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7793,602372755,2021-03-26T15:13:15Z,themes/src/main/resources/theme/keycloak/login/resources/css/tile.css,"@@ -166,6 +166,10 @@     --pf-c-tile__icon--FontSize: var(--pf-c-tile--m-display-lg__header--m-stacked__icon--FontSize); } ",There's an issue with overflow context when the title is too long. Is it possible to add `overflow:hidden` property to `.pf-c-tile` class? UI is broken on mobile devices then.![long](https://user-images.githubusercontent.com/38039883/112652599-dc9f8580-8e4d-11eb-9bcb-5ce8ecb60305.png),
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,602809973,2021-03-28T00:32:52Z,services/src/main/java/org/keycloak/services/clientregistration/oidc/DescriptionConverter.java,"@@ -270,6 +274,10 @@ public static OIDCClientRepresentation toExternalResponse(KeycloakSession sessio         response.setBackchannelLogoutSessionRequired(config.isBackchannelLogoutSessionRequired());         response.setBackchannelLogoutSessionRequired(config.getBackchannelLogoutRevokeOfflineTokens()); +        if (config.getBackchannelTokenDeliveryMode() != null) {+            response.setBackchannelTokenDeliveryMode(config.getBackchannelTokenDeliveryMode());+        }+         List<ProtocolMapperRepresentation> foundPairwiseMappers = PairwiseSubMapperUtils.getPairwiseSubMappers(client);         SubjectType subjectType = foundPairwiseMappers.isEmpty() ? SubjectType.PUBLIC : SubjectType.PAIRWISE;         response.setSubjectType(subjectType.toString().toLowerCase());","@mposolda > So in theory, we may throw the exception during client registration in case that grant_types and response_types are incompatible? For example if response_types is just authorization_code, but the grant_types has also grants for implicit/hybrid flow like code id_token etc.Yes, in theory, we thrown an exception in this case.For CIBA, it is not relevant to `response_type` as you mentioned. Therefore, I would like to convert `grant_type` and the switch setting. ",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,602812569,2021-03-28T01:06:24Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java,"@@ -0,0 +1,243 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.Collections;+import java.util.Optional;++import com.fasterxml.jackson.databind.node.ObjectNode;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.Profile;+import org.keycloak.common.util.Time;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.CibaConfig;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;+import org.keycloak.util.JsonSerialization;+import org.keycloak.utils.ProfileHelper;++public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {++    private final RealmModel realm;++    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+        this.realm = session.getContext().getRealm();+        event.event(EventType.LOGIN);+    }++    @POST+    @NoCache+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processGrantRequest(@Context HttpRequest httpRequest) {+        ProfileHelper.requireFeature(Profile.Feature.CIBA);+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());++        try {+            String authReqId = request.serialize(session);+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);++            if (provider == null) {+                throw new RuntimeException(""Authentication Channel Provider not found."");+            }++            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);++            if (resolver == null) {+                throw new RuntimeException(""CIBA Login User Resolver not setup properly."");+            }++            UserModel user = request.getUser();++            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);++            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {+                CibaConfig cibaPolicy = realm.getCibaPolicy();+                int poolingInterval = cibaPolicy.getPoolingInterval();++                storeAuthenticationRequest(request, cibaPolicy);++                ObjectNode response = JsonSerialization.createObjectNode();++                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());++                if (poolingInterval > 0) {+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);+                }++                return Response.ok(JsonSerialization.writeValueAsBytes(response))+                        .build();+            }+        } catch (Exception e) {+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Failed to send authentication request"", Response.Status.SERVICE_UNAVAILABLE);+        }++        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Unexpected response from authentication device"", Response.Status.SERVICE_UNAVAILABLE);+    }++    /**+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case+     * that relies on cross-references for unsolicited user authentication requests from devices.+     */+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {+        ClientModel client = request.getClient();+        int expiresIn = cibaConfig.getExpiresIn();+        int poolingInterval = cibaConfig.getPoolingInterval();++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,+                Collections.emptyMap());+        String authResultId = request.getAuthResultId();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),+                authResultId);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + poolingInterval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);++        store.put(deviceCode, userCode, lifespanSeconds);+    }++    private AuthenticationRequest authorizeClient(MultivaluedMap<String, String> params) {+        ClientModel client = authenticateClient();+        UserModel user = resolveUser(params, realm.getCibaPolicy().getAuthRequestedUserHint());++        AuthenticationRequest request = new AuthenticationRequest(session, user, client);++        request.setClient(client);++        String scope = params.getFirst(OAuth2Constants.SCOPE);++        if (scope == null)+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, ""missing parameter : scope"",+                    Response.Status.BAD_REQUEST);++        request.setScope(scope);++        request.setBindingMessage(params.getFirst(CibaGrantType.BINDING_MESSAGE));++        CibaConfig policy = realm.getCibaPolicy();++        // create JWE encoded auth_req_id from Auth Req ID.+        Integer expiresIn = policy.getExpiresIn();+        String requestedExpiry = params.getFirst(CibaGrantType.REQUESTED_EXPIRY);++        if (requestedExpiry != null) {+            expiresIn = Integer.valueOf(requestedExpiry);+        }++        request.exp(Time.currentTime() + expiresIn.longValue());++        StringBuilder scopes = new StringBuilder(Optional.ofNullable(request.getScope()).orElse(""""));+        client.getClientScopes(true, true)+                .forEach((key, value) -> {+                    if (value.isDisplayOnConsentScreen())+                        scopes.append("" "").append(value.getName());+                });+        request.setScope(scopes.toString());++        String clientNotificationToken = params.getFirst(CibaGrantType.CLIENT_NOTIFICATION_TOKEN);++        if (clientNotificationToken != null) {+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST,+                    ""Ping and push modes not supported. Use poll mode instead."", Response.Status.BAD_REQUEST);+        }++        String userCode = params.getFirst(OAuth2Constants.USER_CODE);++        if (userCode != null) {+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, ""User code not supported"",+                    Response.Status.BAD_REQUEST);+        }++        String acrValues = params.getFirst(OAuth2Constants.ACR_VALUES);++        if (acrValues != null) {","@mposolda I see, on this PR, I would like to add the following feature to prepare the complete support for `acr_values` in the future.- If `acr_values` parameter is sent to `BackchannelAuthenticationEndpoint`, it is re-sent to `AuthenticationChannel`- The treatment of this `acr_values` is up to the actual implementation of `AuthenticationChannel`. The current default implementation `HttpAuthenticationChannel` just ignore it.- It is RECOMMENDED in [CIBA](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_request) that the resulting `acr` value that corresponding to the actually conducted authentication method is included into ID Token's `acr`, but this PR does not support it.WDYT?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,602838922,2021-03-28T06:29:36Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","@mposolda @pedroigor Yes, we can change opaque JWE `authentication_channel_id` to semantic tamper-resistant JWS. Only relatively sensitive data included in the current JWE `authentication_channel_id` and will be revealed in JWS is```    @JsonProperty(AUTH_RESULT_ID)    protected String authResultId;```But it is needed to bind the HTTP request/response conducted between CD and keycloak as one logical CIBA flow. Therefore it cannot be removed.As mentioned earlier, to prevent the attacker from impersonating the entity via `AuthenticationChannel` the followings are needed.- include this entity's identity in JWS or JWE `authentication_channel_id` (the current `authentication_channel_id` does not incude it.)- when receiving the result of authentication by AD, keycloak needs to do client authentication and confirm that the identity determined by this client authentication is the client identified in `authentication_channel_id`.To do so, keycloak needs to treat this entity as OAuth2's client. One idea just hit on me is as follows:- Add the CIBA setting specifying this entity.- the keycloak admin registers this entity as OAuth2's client (confidential) in advance- the keycloak admin set this client as the entity via `AuthenticationChannel` on CIBA settingsIt might be better if there is the other way that can authenticate and identify such the entity in not introducing OAuth2's client concept.BTW, this `authentication_channel_id` is similar to Refresh Token because the issuer is also the audience.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7793,603162426,2021-03-29T09:56:23Z,themes/src/main/resources/theme/keycloak/login/resources/css/tile.css,"@@ -188,6 +192,7 @@  .pf-c-tile__title {     color: var(--pf-c-tile__title--Color);+    overflow: hidden;","@bodograumann Just one minor thing. Could you please add the `overflow` property directly to `.pf-c-tile` class? ```.pf-c-tile{   ...   overflow:hidden}```For testing purposes we use test Keycloak Server [(Docs)](https://github.com/keycloak/keycloak/blob/master/docs/tests.md#live-edit-of-html-and-styles) with hot-reload of CSS and HTML, where you can test it. Even test the mobile versions basically through the browser JS console.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7890,603188127,2021-03-29T10:39:31Z,server-spi-private/src/main/java/org/keycloak/broker/provider/util/SimpleHttp.java,"@@ -129,6 +126,14 @@ public static SimpleHttp doPatch(String url, HttpClient client) {         return new SimpleHttp(url, ""PATCH"", client);     } +    public String method() {","`SimpleHttp` is a builder class, so IMHO this should be removed. ",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7793,603221415,2021-03-29T11:38:00Z,themes/src/main/resources/theme/keycloak/login/resources/css/tile.css,"@@ -188,6 +192,7 @@  .pf-c-tile__title {     color: var(--pf-c-tile__title--Color);+    overflow: hidden;","@bodograumann Width of an element with class `pf-c-tile__title` is changing regarding the input length, so there's never overflow for the element. In parent element with class `pf-c-tile` we can manage the text overflow inside. I know it's not an ideal approach as well, but much better than the context overflow. You can compare the figures below with and without the overflow. WDYT? ![compare](https://user-images.githubusercontent.com/38039883/112831529-5c1e9600-9094-11eb-92c7-6dbc0b4cc7ad.png)",
2865080,aelgn,https://api.github.com/repos/keycloak/keycloak/pulls/7890,603384268,2021-03-29T15:19:12Z,services/src/main/java/org/keycloak/broker/oidc/AbstractOAuth2IdentityProvider.java,"@@ -497,9 +498,20 @@ public Response authResponse(@QueryParam(AbstractOAuth2IdentityProvider.OAUTH2_P                 }                  if (authorizationCode != null) {-                    String response = generateTokenRequest(authorizationCode).asString();--                    BrokeredIdentityContext federatedIdentity = getFederatedIdentity(response);+                    final SimpleHttp request = generateTokenRequest(authorizationCode);+                    String response = null;+                    BrokeredIdentityContext federatedIdentity;+                    try {+                        response = request.asString();+                        federatedIdentity = getFederatedIdentity(response);+                    } catch (Exception ex) {+                        logger.debug(String.format(""Token request failed to yield an authenticated identity. Request{%s %s [%s]} -> Response{%s}"",+                            request.method(), request.url(),","I was thinking that it was more robust to use the actual url and method of the actual request. Currently `getConfig().getTokenUrl()` would return what all subclasses are currently using, but there is no guarantee that any overrides of generateTokenRequest will actually use this url, so using `getConfig().getTokenUrl()` for the debug logging would potentially log incorrect information.",
2865080,aelgn,https://api.github.com/repos/keycloak/keycloak/pulls/7890,603391551,2021-03-29T15:27:39Z,server-spi-private/src/main/java/org/keycloak/broker/provider/util/SimpleHttp.java,"@@ -129,6 +126,14 @@ public static SimpleHttp doPatch(String url, HttpClient client) {         return new SimpleHttp(url, ""PATCH"", client);     } +    public String method() {","I'd say that SimpleHttp is kind of a ResponseBuilder, but it also encapsulates the request info, which is not included in the ""builder result class"" `SimpleHttp.Response` or in any intermediary Request dto - making SimpleHttp effectively the Request representation itself.Since SimpleHttp is passed around in the class hierarchy the site of construction/building of SimpleHttp is not under control of the `AbstractOAuth2IdentityProvider` operating on the instance, does it not make sense to be able to inspect, fully immutably, the request at the execution site?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7842,604199070,2021-03-30T15:22:03Z,model/map/src/main/java/org/keycloak/models/map/realm/entity/MapAuthenticationExecutionEntity.java,"@@ -0,0 +1,143 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.realm.entity;++import java.util.Objects;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.utils.KeycloakModelUtils;++public class MapAuthenticationExecutionEntity {++    private String id;+    private String authenticator;+    private String authenticatorConfig;+    private String flowId;+    private String parentFlowId;+    private AuthenticationExecutionModel.Requirement requirement;+    private boolean autheticatorFlow;+    private int priority;++    private MapAuthenticationExecutionEntity() {}++    public static MapAuthenticationExecutionEntity fromModel(AuthenticationExecutionModel model) {+        if (model == null) return null;+        MapAuthenticationExecutionEntity entity = new MapAuthenticationExecutionEntity();+        String id = model.getId() == null ? KeycloakModelUtils.generateId() : model.getId();+        entity.setId(id);+        entity.setAuthenticator(model.getAuthenticator());+        entity.setAuthenticatorConfig(model.getAuthenticatorConfig());+        entity.setFlowId(model.getFlowId());+        entity.setParentFlowId(model.getParentFlow());+        entity.setRequirement(model.getRequirement());+        entity.setAutheticatorFlow(model.isAuthenticatorFlow());+        entity.setPriority(model.getPriority());+        return entity;+    }++    public static AuthenticationExecutionModel toModel(MapAuthenticationExecutionEntity entity) {+        if (entity == null) return null;+        AuthenticationExecutionModel model = new AuthenticationExecutionModel();+        model.setId(entity.getId());+        model.setAuthenticator(entity.getAuthenticator());+        model.setAuthenticatorConfig(entity.getAuthenticatorConfig());+        model.setFlowId(entity.getFlowId());+        model.setParentFlow(entity.getParentFlowId());+        model.setRequirement(entity.getRequirement());+        model.setAuthenticatorFlow(entity.isAutheticatorFlow());+        model.setPriority(entity.getPriority());+        return model;+    }++    public String getId() {+        return id;+    }++    public void setId(String id) {+        this.id = id;+    }++    public String getAuthenticator() {+        return authenticator;+    }++    public void setAuthenticator(String authenticator) {+        this.authenticator = authenticator;+    }++    public String getAuthenticatorConfig() {+        return authenticatorConfig;+    }++    public void setAuthenticatorConfig(String authenticatorConfig) {+        this.authenticatorConfig = authenticatorConfig;+    }++    public AuthenticationExecutionModel.Requirement getRequirement() {+        return requirement;+    }++    public void setRequirement(AuthenticationExecutionModel.Requirement requirement) {+        this.requirement = requirement;+    }++    public boolean isAutheticatorFlow() {+        return autheticatorFlow;+    }++    public void setAutheticatorFlow(boolean autheticatorFlow) {+        this.autheticatorFlow = autheticatorFlow;+    }++    public String getFlowId() {+        return flowId;+    }++    public void setFlowId(String flowId) {+        this.flowId = flowId;+    }++    public String getParentFlowId() {+        return parentFlowId;+    }++    public void setParentFlowId(String parentFlowId) {+        this.parentFlowId = parentFlowId;+    }++    public int getPriority() {+        return priority;+    }++    public void setPriority(int priority) {+        this.priority = priority;+    }++    @Override+    public int hashCode() {+        return getId().hashCode();+    }++    @Override+    public boolean equals(Object obj) {+        if (this == obj) return true;+        if (!(obj instanceof MapAuthenticationExecutionEntity)) return false;+        final MapAuthenticationExecutionEntity other = (MapAuthenticationExecutionEntity) obj;+        return Objects.equals(other.getId(), getId());","Currently, I am not sure the updated flag makes sense on this entity. To me it seems we should use it only in case we take the nested entity and call some setter on it in adapter/provider. I haven't found anything like this for current entities. The way we introduced users nested entities is a little bit weird. We are combining two approaches (manually updating using an update method or using updated flag and update automatically) together and I think we should choose only one. The biggest advantage of the updated flag is that the code that works with users/clients/roles/etc. can just take model and call `setAnyProperty()` and it is projected in the storage on commit. However, with current nested entities this is somewhere in the middle. Entities support this, but models don't which is why we have all those `update*` methods. For example, this code: https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java#L1235-L1242Currently:1. When we reach the code, we have RealmModel that contains entity that is registered in MapTransaction.2. We call [this method](https://github.com/keycloak/keycloak/blob/da4c4c05e3009f4a699a9a3d1c989ddba34295f4/model/map/src/main/java/org/keycloak/models/map/realm/MapRealmAdapter.java#L735-L737) which calls `MapAuthenticatorConfigEntity.fromModel`  --> an instance of `MapAuthenticatorConfigEntity` is created with updated flag true3. Then we call [updateAuthenticatorConfig](https://github.com/keycloak/keycloak/blob/da4c4c05e3009f4a699a9a3d1c989ddba34295f4/model/map/src/main/java/org/keycloak/models/map/realm/AbstractRealmEntity.java#L900-L902) that replaces the entity and always set updated flag to true if a config with the same id existed.If we refactor it so that `AuthenticatorConfigModel` makes changes in the corresponding entity, we would change only one updated flag, update user in the storage only when `AuthenticatorConfigModel` is really changed, remove update methods from User/Realm adapters. If we decide to incorporate this, we should probably not do it in this PR as it would be huge then. Otherwise I would probably vote for removing the updated flag from entities where it is not necessary and leave the responsibility for setting updated flag on methods in AbstractUserEntity. This brings us back to the equals method above. Currently, using this method we cannot say whether the entity was updated or not because it checks only id. So we cannot do something like this when updating ExcutionEntity (but maybe we are ok with always updating):```MapAuthenticationExecutionEntity originalValue = authenticationExecutions.replace(authenticationExecution.getId(), authenticationExecution);this.updated |= originalValue != null && !Objects.equals(originalValue, authenticationExecution);```  ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7842,604300798,2021-03-30T17:36:15Z,model/map/src/main/java/org/keycloak/models/map/realm/entity/MapAuthenticationExecutionEntity.java,"@@ -0,0 +1,143 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.realm.entity;++import java.util.Objects;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.utils.KeycloakModelUtils;++public class MapAuthenticationExecutionEntity {++    private String id;+    private String authenticator;+    private String authenticatorConfig;+    private String flowId;+    private String parentFlowId;+    private AuthenticationExecutionModel.Requirement requirement;+    private boolean autheticatorFlow;+    private int priority;++    private MapAuthenticationExecutionEntity() {}++    public static MapAuthenticationExecutionEntity fromModel(AuthenticationExecutionModel model) {+        if (model == null) return null;+        MapAuthenticationExecutionEntity entity = new MapAuthenticationExecutionEntity();+        String id = model.getId() == null ? KeycloakModelUtils.generateId() : model.getId();+        entity.setId(id);+        entity.setAuthenticator(model.getAuthenticator());+        entity.setAuthenticatorConfig(model.getAuthenticatorConfig());+        entity.setFlowId(model.getFlowId());+        entity.setParentFlowId(model.getParentFlow());+        entity.setRequirement(model.getRequirement());+        entity.setAutheticatorFlow(model.isAuthenticatorFlow());+        entity.setPriority(model.getPriority());+        return entity;+    }++    public static AuthenticationExecutionModel toModel(MapAuthenticationExecutionEntity entity) {+        if (entity == null) return null;+        AuthenticationExecutionModel model = new AuthenticationExecutionModel();+        model.setId(entity.getId());+        model.setAuthenticator(entity.getAuthenticator());+        model.setAuthenticatorConfig(entity.getAuthenticatorConfig());+        model.setFlowId(entity.getFlowId());+        model.setParentFlow(entity.getParentFlowId());+        model.setRequirement(entity.getRequirement());+        model.setAuthenticatorFlow(entity.isAutheticatorFlow());+        model.setPriority(entity.getPriority());+        return model;+    }++    public String getId() {+        return id;+    }++    public void setId(String id) {+        this.id = id;+    }++    public String getAuthenticator() {+        return authenticator;+    }++    public void setAuthenticator(String authenticator) {+        this.authenticator = authenticator;+    }++    public String getAuthenticatorConfig() {+        return authenticatorConfig;+    }++    public void setAuthenticatorConfig(String authenticatorConfig) {+        this.authenticatorConfig = authenticatorConfig;+    }++    public AuthenticationExecutionModel.Requirement getRequirement() {+        return requirement;+    }++    public void setRequirement(AuthenticationExecutionModel.Requirement requirement) {+        this.requirement = requirement;+    }++    public boolean isAutheticatorFlow() {+        return autheticatorFlow;+    }++    public void setAutheticatorFlow(boolean autheticatorFlow) {+        this.autheticatorFlow = autheticatorFlow;+    }++    public String getFlowId() {+        return flowId;+    }++    public void setFlowId(String flowId) {+        this.flowId = flowId;+    }++    public String getParentFlowId() {+        return parentFlowId;+    }++    public void setParentFlowId(String parentFlowId) {+        this.parentFlowId = parentFlowId;+    }++    public int getPriority() {+        return priority;+    }++    public void setPriority(int priority) {+        this.priority = priority;+    }++    @Override+    public int hashCode() {+        return getId().hashCode();+    }++    @Override+    public boolean equals(Object obj) {+        if (this == obj) return true;+        if (!(obj instanceof MapAuthenticationExecutionEntity)) return false;+        final MapAuthenticationExecutionEntity other = (MapAuthenticationExecutionEntity) obj;+        return Objects.equals(other.getId(), getId());","> Currently, I am not sure the updated flag makes sense on this entity. To me it seems we should use it only in case we take the nested entity and call some setter on it in adapter/provider. I haven't found anything like this for current entities.The reason for having fine-grained updated flag is that then a provider which e.g. stores dependent entites in separate tables can optimize what really needs to be updated in the database.> The way we introduced users nested entities is a little bit weird. We are combining two approaches (manually updating using an update method or using updated flag and update automatically) together and I think we should choose only one. The biggest advantage of the updated flag is that the code that works with users/clients/roles/etc. can just take model and call `setAnyProperty()` and it is projected in the storage on commit. However, with current nested entities this is somewhere in the middle. Entities support this, but models don't which is why we have all those `update*` methods.This is a good catch. We should eventually get rid of the `update*` methods on models. As you write, this is something that could inflate the PR a lot if done here. I wonder though whether this removal is needed functionally? It seems to me that the more coarse-grained approach in this PR prepares ground for removal of the methods, and allows pushing removal of these methods and the need for them once map storage is implemented. This PR already proposes enough changes in my opinion.> For example, this code: https://github.com/keycloak/keycloak/blob/c3b9c669418f7f4a55b5645ea0f3aa8321369345/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java#L1235-L1242> > Currently:> > 1. When we reach the code, we have RealmModel that contains entity that is registered in MapTransaction.> 2. We call [this method](https://github.com/keycloak/keycloak/blob/da4c4c05e3009f4a699a9a3d1c989ddba34295f4/model/map/src/main/java/org/keycloak/models/map/realm/MapRealmAdapter.java#L735-L737) which calls `MapAuthenticatorConfigEntity.fromModel`  --> an instance of `MapAuthenticatorConfigEntity` is created with updated flag true> 3. Then we call [updateAuthenticatorConfig](https://github.com/keycloak/keycloak/blob/da4c4c05e3009f4a699a9a3d1c989ddba34295f4/model/map/src/main/java/org/keycloak/models/map/realm/AbstractRealmEntity.java#L900-L902) that replaces the entity and always set updated flag to true if a config with the same id existed.> > If we refactor it so that `AuthenticatorConfigModel` makes changes in the corresponding entity, we would change only one updated flag, update user in the storage only when `AuthenticatorConfigModel` is really changed, remove update methods from User/Realm adapters.You are right, the `updated` is changed based on ""the authenticator config has been touched"" rather than it's been really different. An optimization for the future would be to go to refine `updated` flag to grasp that level of detail.> If we decide to incorporate this, we should probably not do it in this PR as it would be huge then.I 100% agree with this.> Otherwise I would probably vote for removing the updated flag from entities where it is not necessary and leave the responsibility for setting updated flag on methods in AbstractUserEntity. This brings us back to the equals method above. Currently, using this method we cannot say whether the entity was updated or not because it checks only id. So we cannot do something like this when updating ExcutionEntity (but maybe we are ok with always updating):> > ```> MapAuthenticationExecutionEntity originalValue = authenticationExecutions.replace(authenticationExecution.getId(), authenticationExecution);> this.updated |= originalValue != null && !Objects.equals(originalValue, authenticationExecution);> ```That is right. At this moment we're ok with always updating whenever there was any change (i.e. as coarse as calling of of the `update*` methods). It would allow getting the working realm map storage into the community to try and test, with ability to do the optimizations of the updates later.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,604345681,2021-03-30T18:41:58Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java,"@@ -0,0 +1,777 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserLoginFailureModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.utils.SessionTimeoutHelper;++import java.util.Collection;+import java.util.Comparator;+import java.util.HashMap;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;+import java.util.UUID;+import java.util.concurrent.ConcurrentHashMap;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import static org.keycloak.models.UserSessionModel.SessionPersistenceState.TRANSIENT;+import static org.keycloak.utils.StreamsUtil.paginatedStream;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProvider implements UserSessionProvider {++    private static final Logger LOG = Logger.getLogger(MapUserSessionProvider.class);+    private final KeycloakSession session;+    protected final MapKeycloakTransaction<UUID, MapUserSessionEntity, UserSessionModel> userSessionTx;+    protected final MapKeycloakTransaction<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionTx;+    protected final MapKeycloakTransaction<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureTx;+    private final MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private final MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;+    private final MapStorage<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureStore;++    /**+     * Storage for transient user sessions which lifespan is limited to one request.+     */+    private Map<UUID, MapUserSessionEntity> transientUserSessions = new HashMap<>();++    public MapUserSessionProvider(KeycloakSession session, MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore,+                                  MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore,+                                  MapStorage<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureStore) {+        this.session = session;+        this.userSessionStore = userSessionStore;+        this.clientSessionStore = clientSessionStore;+        this.userLoginFailureStore = userLoginFailureStore;+        userSessionTx = userSessionStore.createTransaction();+        clientSessionTx = clientSessionStore.createTransaction();+        userLoginFailureTx = userLoginFailureStore.createTransaction();++        session.getTransactionManager().enlistAfterCompletion(userSessionTx);+        session.getTransactionManager().enlistAfterCompletion(clientSessionTx);+        session.getTransactionManager().enlistAfterCompletion(userLoginFailureTx);+    }++    private Function<MapUserSessionEntity, UserSessionModel> userEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return (origEntity) -> new MapUserSessionAdapter(session, realm,+                Objects.equals(origEntity.getPersistenceState(), TRANSIENT) ? origEntity : registerEntityForChanges(origEntity)) {++            @Override+            public void removeAuthenticatedClientSessions(Collection<String> removedClientUUIDS) {+                removedClientUUIDS.forEach(clientId -> {+                    clientSessionTx.delete(UUID.fromString(clientId));+                    entity.removeAuthenticatedClientSession(clientId);+                });+            }+        };+    }++    private Function<MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientEntityToAdapterFunc(RealmModel realm,+                                                                                                                     ClientModel client,+                                                                                                                     UserSessionModel userSession) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapAuthenticatedClientSessionAdapter(session, realm, client, userSession, registerEntityForChanges(origEntity)) {+            @Override+            public void detachFromUserSession() {+                this.userSession = null;++                clientSessionTx.delete(entity.getId());+            }+        };+    }++    private Function<MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapUserLoginFailureAdapter(session, realm, registerEntityForChanges(origEntity));+    }++    private MapUserSessionEntity registerEntityForChanges(MapUserSessionEntity origEntity) {+        MapUserSessionEntity res = userSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userSessionTx.updateIfChanged(origEntity.getId(), res, MapUserSessionEntity::isUpdated);+        return res;+    }++    private MapAuthenticatedClientSessionEntity registerEntityForChanges(MapAuthenticatedClientSessionEntity origEntity) {+        MapAuthenticatedClientSessionEntity res = clientSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        clientSessionTx.updateIfChanged(origEntity.getId(), res, MapAuthenticatedClientSessionEntity::isUpdated);+        return res;+    }++    private MapUserLoginFailureEntity registerEntityForChanges(MapUserLoginFailureEntity origEntity) {+        MapUserLoginFailureEntity res = userLoginFailureTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userLoginFailureTx.updateIfChanged(origEntity.getId(), res, MapUserLoginFailureEntity::isUpdated);+        return res;+    }++    @Override+    public AuthenticatedClientSessionModel createClientSession(RealmModel realm, ClientModel client, UserSessionModel userSession) {+        MapAuthenticatedClientSessionEntity entity =+                new MapAuthenticatedClientSessionEntity(UUID.randomUUID(), realm.getId(), client.getId(), false);++        LOG.tracef(""createClientSession(%s, %s, %s)%s"", realm, client, userSession, getShortStackTrace());++        clientSessionTx.create(entity.getId(), entity);++        MapUserSessionEntity userSessionEntity = getUserSessionById(UUID.fromString(userSession.getId()));++        if (userSessionEntity == null) {+            throw new IllegalStateException(""User session entity does not exist: "" + userSession.getId());+        }++        userSessionEntity.addAuthenticatedClientSession(client.getId(), entity.getId());++        return clientEntityToAdapterFunc(realm, client, userSession).apply(entity);+    }++    @Override+    public AuthenticatedClientSessionModel getClientSession(UserSessionModel userSession, ClientModel client,+                                                            UUID clientSessionId, boolean offline) {+        LOG.tracef(""getClientSession(%s, %s, %s, %s)%s"", userSession, client,+                clientSessionId, offline, getShortStackTrace());++        Objects.requireNonNull(userSession, ""The provided user session cannot be null!"");+        Objects.requireNonNull(client, ""The provided client cannot be null!"");+        if (clientSessionId == null) {+            return null;+        }++        ModelCriteriaBuilder<AuthenticatedClientSessionModel> mcb = clientSessionStore.createCriteriaBuilder()+                .compare(AuthenticatedClientSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, clientSessionId)+                .compare(AuthenticatedClientSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.IS_OFFLINE, ModelCriteriaBuilder.Operator.EQ, offline);++        return clientSessionTx.getUpdatedNotRemoved(mcb)+                .map(clientEntityToAdapterFunc(client.getRealm(), client, userSession))+                .findFirst()+                .orElse(null);+    }++    @Override+    public UserSessionModel createUserSession(RealmModel realm, UserModel user, String loginUsername, String ipAddress,+                                              String authMethod, boolean rememberMe, String brokerSessionId, String brokerUserId) {+        return createUserSession(null, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId,+                brokerUserId, UserSessionModel.SessionPersistenceState.PERSISTENT);+    }++    @Override+    public UserSessionModel createUserSession(String id, RealmModel realm, UserModel user, String loginUsername,+                                              String ipAddress, String authMethod, boolean rememberMe, String brokerSessionId,+                                              String brokerUserId, UserSessionModel.SessionPersistenceState persistenceState) {+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""createUserSession(%s, %s, %s, %s)%s"", id, realm, loginUsername, persistenceState, getShortStackTrace());++        MapUserSessionEntity entity = new MapUserSessionEntity(entityId, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId, brokerUserId, false);+        entity.setPersistenceState(persistenceState);++        if (Objects.equals(persistenceState, TRANSIENT)) {+            transientUserSessions.put(entityId, entity);+        } else {+            if (userSessionTx.read(entity.getId()) != null) {+                throw new ModelDuplicateException(""User session exists: "" + entity.getId());+            }++            userSessionTx.create(entity.getId(), entity);+        }++        UserSessionModel userSession = userEntityToAdapterFunc(realm).apply(entity);++        DeviceActivityManager.attachDevice(userSession, session);++        return userSession;+    }++    @Override+    public UserSessionModel getUserSession(RealmModel realm, String id) {+        Objects.requireNonNull(realm, ""The provided realm can't be null!"");++        LOG.tracef(""getUserSession(%s, %s)%s"", realm, id, getShortStackTrace());++        UUID uuid = toUUID(id);+        if (uuid == null) {+            return null;+        }++        MapUserSessionEntity userSessionEntity = transientUserSessions.get(uuid);+        if (userSessionEntity != null) {+            return userEntityToAdapterFunc(realm).apply(userSessionEntity);+        }++        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, uuid);++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm))+                .findFirst()+                .orElse(null);+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""getUserSessionsStream(%s, %s)%s"", realm, user, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getUserSessionsStream(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, ClientModel client,+                                                          Integer firstResult, Integer maxResults) {+        return paginatedStream(getUserSessionsStream(realm, client)+                .sorted(Comparator.comparing(UserSessionModel::getLastSessionRefresh)), firstResult, maxResults);+    }++    @Override+    public Stream<UserSessionModel> getUserSessionByBrokerUserIdStream(RealmModel realm, String brokerUserId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.BROKER_USER_ID, ModelCriteriaBuilder.Operator.EQ, brokerUserId);++        LOG.tracef(""getUserSessionByBrokerUserIdStream(%s, %s)%s"", realm, brokerUserId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public UserSessionModel getUserSessionByBrokerSessionId(RealmModel realm, String brokerSessionId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.BROKER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, brokerSessionId);++        LOG.tracef(""getUserSessionByBrokerSessionId(%s, %s)%s"", realm, brokerSessionId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm))+                .findFirst()+                .orElse(null);+    }++    @Override+    public UserSessionModel getUserSessionWithPredicate(RealmModel realm, String id, boolean offline,+                                                        Predicate<UserSessionModel> predicate) {+        LOG.tracef(""getUserSessionWithPredicate(%s, %s, %s)%s"", realm, id, offline, getShortStackTrace());++        Stream<UserSessionModel> userSessionEntityStream;+        if (offline) {+            userSessionEntityStream = getOfflineUserSessionEntityStream(realm, id)+                    .map(userEntityToAdapterFunc(realm));+        } else {+            UserSessionModel userSession = getUserSession(realm, id);+            userSessionEntityStream = userSession != null ? Stream.of(userSession) : Stream.empty();+        }++        return userSessionEntityStream+                .filter(predicate)+                .findFirst()+                .orElse(null);+    }++    @Override+    public long getActiveUserSessions(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getActiveUserSessions(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getCount(mcb);+    }++    @Override+    public Map<String, Long> getActiveClientSessionStats(RealmModel realm, boolean offline) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, offline);++        LOG.tracef(""getActiveClientSessionStats(%s, %s)%s"", realm, offline, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(MapUserSessionEntity::getAuthenticatedClientSessions)+                .map(Map::keySet)+                .flatMap(Collection::stream)+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));+    }++    @Override+    public void removeUserSession(RealmModel realm, UserSessionModel session) {+        Objects.requireNonNull(session, ""The provided user session can't be null!"");++        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, UUID.fromString(session.getId()));++        LOG.tracef(""removeUserSession(%s, %s)%s"", realm, session, getShortStackTrace());++        userSessionTx.getUpdatedNotRemoved(mcb).forEach(userSession -> {+            userSession.getAuthenticatedClientSessions().values().stream().forEach(clientSessionTx::delete);+            userSessionTx.delete(userSession.getId());+        });++    }++    @Override+    public void removeUserSessions(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = userSessionStore.createCriteriaBuilder()+                .compare(UserSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""removeUserSessions(%s, %s)%s"", realm, user, getShortStackTrace());++        userSessionTx.getUpdatedNotRemoved(mcb).forEach(userSession -> {+            userSession.getAuthenticatedClientSessions().values().stream().forEach(clientSessionTx::delete);+            userSessionTx.delete(userSession.getId());+        });","Can this be optimized to leverage `tx.delete(mcb)`? e.g. by obtaining list of user sessions `lus` first, then performing two removals:- deletion of client sessions where user_session_id in `lus`- then performing `userSessionTx.delete(mcb)`",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7806,604777538,2021-03-31T10:23:27Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -935,17 +935,17 @@ module.controller('RealmIdentityProviderCtrl', function($scope, $filter, $upload      $scope.initSamlProvider = function() {         $scope.nameIdFormats = [-            /*-            {-                format: ""urn:oasis:names:tc:SAML:2.0:nameid-format:transient"",-                name: ""Transient""-            },-            */+         +           ","You are indeed right about the specification. The reason for defaulting to `true` is to stay conformant to the current behaviour. In the future, the default might be changed, and that would impact also the default that is set here:https://github.com/keycloak/keycloak/blob/809ab5bf002f0f34781e27be7cbfb29bcef793bd/services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java#L134-L135",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7806,604795884,2021-03-31T10:54:21Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -1039,6 +1037,7 @@ module.controller('RealmIdentityProviderCtrl', function($scope, $filter, $upload         $scope.identityProvider.firstBrokerLoginFlowAlias = 'first broker login';         $scope.identityProvider.config.useJwksUrl = 'true';         $scope.identityProvider.config.syncMode = 'IMPORT';+        $scope.identityProvider.config.allowCreate = 'true';","I have one question based on this change. I put default value only for create. When IdP was updated, we do not want to change allowCreate value. However, when upgrading from older version allowCreate  will not be in databse. So, when admin user try to update SAML Identity Provider value will be set to false. Is this a problem?We do not have problem, when user is trying to login ( default to true).",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605128628,2021-03-31T18:29:59Z,server-spi-private/src/main/java/org/keycloak/validate/Validator.java,"@@ -0,0 +1,114 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate;++import org.keycloak.provider.Provider;++import java.util.Map;++/**+ * Validates given input in a {@link ValidationContext}.+ * <p>+ * Validations can be supported with an optional {@code inputHint}, which could denote a reference to a potentially+ * nested attribute of an object to validate.+ * <p>+ * Validations can be configured with an optional {@code config} {@link Map}.+ */+public interface Validator extends Provider {++    /**+     * Validates the given {@code input}.+     *+     * @param input the value to validate+     * @return the validation context with the outcome of the validation+     */+    default ValidationContext validate(Object input) {+        return validate(input, ""input"", new ValidationContext(), ValidatorConfig.EMPTY);+    }++    /**+     * Validates the given {@code input} with an additional {@code config}.+     *+     * @param input  the value to validate+     * @param config parameterization for the current validation+     * @return the validation context with the outcome of the validation+     */+    default ValidationContext validate(Object input, ValidatorConfig config) {","1. Yes it was, I had this (via simple `Map<String,Object> attributes`) in my initial API design: https://github.com/keycloak/keycloak/pull/7324/files#diff-a30ff7afb40dfeee146a59e5e46fbd15598d5d36a2dbd616095d049e5181613dR36We want to support simple and complex validations. Simple validations (just one call to validate(...)) don't require an initial `ValidationConfig` but might want to fine tune the `Validator`.Complex validations might invoke `validate(...)` consecutively for different `Validator`s with a shared `ValidationContext`. Since the `ValidationContext` is shared across multiple `Validator` invocations, it would require additional context management to maintain the proper `ValidationConfig`. Explicitly passing the `ValidationConfig` makes the API easier for simple and complex validations.2. A `Validator` which needs the `KeycloakSession` needs to be invoked with a properly configured `ValidationContext` with a session. `#validate(object)` allows simple validations like```Assert.assertTrue(Validators.email().validate(""admin@example.org"").isValid());```while still sharing the common `Validator` interface.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605552023,2021-04-01T10:35:21Z,server-spi-private/src/main/java/org/keycloak/validate/Validator.java,"@@ -0,0 +1,114 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate;++import org.keycloak.provider.Provider;++import java.util.Map;++/**+ * Validates given input in a {@link ValidationContext}.+ * <p>+ * Validations can be supported with an optional {@code inputHint}, which could denote a reference to a potentially+ * nested attribute of an object to validate.+ * <p>+ * Validations can be configured with an optional {@code config} {@link Map}.+ */+public interface Validator extends Provider {","Just wondering, why not to use an abstract class instead of interface with mostly `default` methods?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605565332,2021-04-01T10:59:41Z,server-spi-private/src/main/java/org/keycloak/validate/builtin/NotEmptyValidator.java,"@@ -0,0 +1,74 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate.builtin;++import org.keycloak.validate.CompactValidator;+import org.keycloak.validate.ValidationContext;+import org.keycloak.validate.ValidationError;+import org.keycloak.validate.ValidatorConfig;++import java.util.Collection;+import java.util.Map;++public class NotEmptyValidator implements CompactValidator {++    public static final NotEmptyValidator INSTANCE = new NotEmptyValidator();++    public static final String ID = ""not-empty"";++    public static final String MESSAGE_ERROR_EMPTY = ""error-empty"";++    private NotEmptyValidator() {+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    public ValidationContext validate(Object input, String inputHint, ValidationContext context, ValidatorConfig config) {++        if (input == null) {+            context.addError(new ValidationError(ID, inputHint, MESSAGE_ERROR_EMPTY, input));+            return context;+        }++        if (input instanceof String) {+            if (((String) input).length() == 0) {+                context.addError(new ValidationError(ID, inputHint, MESSAGE_ERROR_EMPTY, input));+            }+            return context;+        }++        if (input instanceof Collection) {+            if (((Collection<?>) input).isEmpty()) {+                context.addError(new ValidationError(ID, inputHint, MESSAGE_ERROR_EMPTY, input));+            }+            return context;+        }++        if (input instanceof Map) {+            if (((Map<?, ?>) input).isEmpty()) {+                context.addError(new ValidationError(ID, inputHint, MESSAGE_ERROR_EMPTY, input));+            }+            return context;+        }++        return context;",Should we return some error/throw exception if validation was not performed due to incompatible input type? This way it just silently successfully validates the input.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605566343,2021-04-01T11:01:31Z,server-spi-private/src/main/java/org/keycloak/validate/builtin/EmailValidator.java,"@@ -0,0 +1,60 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate.builtin;++import org.keycloak.validate.CompactValidator;+import org.keycloak.validate.ValidationContext;+import org.keycloak.validate.ValidationError;+import org.keycloak.validate.ValidatorConfig;++import java.util.regex.Pattern;++public class EmailValidator implements CompactValidator {++    public static final String ID = ""email"";++    public static final EmailValidator INSTANCE = new EmailValidator();++    public static final String MESSAGE_INVALID_EMAIL = ""error-invalid-email"";++    // Actually allow same emails like angular. See ValidationTest.testEmailValidation()+    private static final Pattern EMAIL_PATTERN = Pattern.compile(+            ""[a-zA-Z0-9!#$%&'*+/=?^_`{|}~.-]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*"");++    private EmailValidator() {+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    public ValidationContext validate(Object input, String inputHint, ValidationContext context, ValidatorConfig config) {++        if (!(input instanceof String)) {+            context.addError(new ValidationError(ID, inputHint, MESSAGE_INVALID_EMAIL, input));","Should we rather throw some exception?  It's not exactly a validation error, the user providing the input is not responsible for this.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605566815,2021-04-01T11:02:32Z,server-spi-private/src/main/java/org/keycloak/validate/builtin/LengthValidator.java,"@@ -0,0 +1,120 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate.builtin;++import org.keycloak.validate.CompactValidator;+import org.keycloak.validate.ValidationContext;+import org.keycloak.validate.ValidationError;+import org.keycloak.validate.ValidationResult;+import org.keycloak.validate.ValidatorConfig;++import java.util.HashMap;+import java.util.LinkedHashSet;+import java.util.Map;+import java.util.Set;++public class LengthValidator implements CompactValidator {++    public static final LengthValidator INSTANCE = new LengthValidator();++    public static final String ID = ""length"";++    public static final String MESSAGE_INVALID_LENGTH = ""error-invalid-length"";+    public static final String KEY_MIN = ""min"";+    public static final String KEY_MAX = ""max"";++    private static final ValidatorConfig DEFAULT_CONFIG;++    static {+        Map<String, Object> config = new HashMap<>();+        config.put(KEY_MIN, 0);+        config.put(KEY_MAX, 255);++        DEFAULT_CONFIG = ValidatorConfig.configFromMap(config);+    }++    private LengthValidator() {+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    public ValidationContext validate(Object input, String inputHint, ValidationContext context, ValidatorConfig config) {++        if (input == null) {+            context.addError(new ValidationError(ID, inputHint, MESSAGE_INVALID_LENGTH, input));+            return context;+        }++        if (!(input instanceof String)) {+            return context;+        }",Should we rather throw some exception?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605567747,2021-04-01T11:04:31Z,server-spi-private/src/main/java/org/keycloak/validate/builtin/NotBlankValidator.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate.builtin;++import org.keycloak.validate.CompactValidator;+import org.keycloak.validate.ValidationContext;+import org.keycloak.validate.ValidationError;+import org.keycloak.validate.ValidatorConfig;++public class NotBlankValidator implements CompactValidator {++    public static final String ID = ""blank"";++    public static final String MESSAGE_BLANK = ""error-invalid-blank"";++    public static final NotBlankValidator INSTANCE = new NotBlankValidator();++    private NotBlankValidator() {+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    public ValidationContext validate(Object input, String inputHint, ValidationContext context, ValidatorConfig config) {++        if (!(input instanceof String)) {+            context.addError(new ValidationError(ID, inputHint, MESSAGE_INVALID_VALUE, input));+            return context;+        }",Should we rather throw some exception?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605572564,2021-04-01T11:13:56Z,server-spi-private/src/main/java/org/keycloak/validate/ValidatorConfig.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate;++import java.util.Collections;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.regex.Pattern;++/**+ * A typed wrapper around a {@link Map} based {@link Validator} configuration.+ */+public class ValidatorConfig {++    /**+     * An empty {@link ValidatorConfig}.+     */+    public static final ValidatorConfig EMPTY = new ValidatorConfig(Collections.emptyMap());++    /**+     * Holds the backing map for the {@link Validator} config.+     */+    private final Map<String, Object> config;++    /**+     * Creates a new {@link ValidatorConfig} from the given {@code map}.+     *+     * @param config+     */+    public ValidatorConfig(Map<String, Object> config) {+        this.config = config;+    }++    /**+     * Static helper to create a {@link ValidatorConfig} from the given {@code map}.+     *+     * @param map+     * @return+     */+    public static ValidatorConfig configFromMap(Map<String, Object> map) {+        if (map == null || map.isEmpty()) {+            return EMPTY;+        }+        return new ValidatorConfig(map);+    }++    public boolean containsKey(String key) {+        return config.containsKey(key);+    }++    public int size() {+        return config.size();+    }++    public boolean isEmpty() {+        return config.isEmpty();+    }++    public Object get(String key) {+        return config.get(key);+    }++    public Object getOrDefault(String key, Object defaultValue) {+        return config.getOrDefault(key, defaultValue);+    }++    public String getString(String key) {+        return getStringOrDefault(key, null);+    }++    public String getStringOrDefault(String key, String defaultValue) {+        Object value = config.get(key);+        if (value instanceof String) {+            return (String) value;+        }+        return defaultValue;+    }++    public Integer getIntOrDefault(String key) {+        return getIntOrDefault(key, null);+    }++    public Integer getIntOrDefault(String key, Integer defaultValue) {+        Object value = config.get(key);+        if (value instanceof Integer) {+            return (Integer) value;+        } else if (value instanceof Number) {+            return ((Number) value).intValue();+        } else if (value instanceof String) {+            return Integer.parseInt((String) value);+        }+        return defaultValue;+    }++    public Double getDoubleOrDefault(String key) {+        return getDoubleOrDefault(key, null);+    }++    public Double getDoubleOrDefault(String key, Double defaultValue) {+        Object value = config.get(key);+        if (value instanceof Double) {+            return (Double) value;+        } else if (value instanceof Number) {+            return ((Number) value).doubleValue();+        } else if (value instanceof String) {+            return Double.parseDouble((String) value);+        }+        return defaultValue;+    }++    public Boolean getBooleanOrDefault(String key) {+        return getBooleanOrDefault(key, null);+    }++    public Boolean getBooleanOrDefault(String key, Boolean defaultValue) {+        Object value = config.get(key);+        if (value instanceof Boolean) {+            return (Boolean) value;+        } else if (value instanceof String) {+            return Boolean.parseBoolean((String) value);+        }+        return defaultValue;+    }++    public Set<String> getStringSetOrDefault(String key) {+        return getStringSetOrDefault(key, null);+    }++    public Set<String> getStringSetOrDefault(String key, Set<String> defaultValue) {+        Object value = config.get(key);+        if (value instanceof Set) {+            return (Set<String>) value;+        }+        return defaultValue;+    }++    public List<String> getStringListOrDefault(String key) {+        return getStringListOrDefault(key, null);+    }++    public List<String> getStringListOrDefault(String key, List<String> defaultValue) {+        Object value = config.get(key);+        if (value instanceof List) {+            return (List<String>) value;+        }+        return defaultValue;+    }++    public Pattern getPattern(String key) {+        return getPatternOrDefault(key, null);+    }++    public Pattern getPatternOrDefault(String key, Pattern defaultValue) {+        Object value = config.get(key);+        if (value instanceof Pattern) {+            return (Pattern) value;+        } else if (value instanceof String) {+            return Pattern.compile((String) value);",Should we store the compiled pattern for the next time?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605575309,2021-04-01T11:18:58Z,server-spi-private/src/main/java/org/keycloak/validate/builtin/PatternValidator.java,"@@ -0,0 +1,82 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate.builtin;++import org.keycloak.validate.CompactValidator;+import org.keycloak.validate.ValidationContext;+import org.keycloak.validate.ValidationError;+import org.keycloak.validate.ValidationResult;+import org.keycloak.validate.ValidatorConfig;++import java.util.LinkedHashSet;+import java.util.Set;+import java.util.regex.Pattern;+import java.util.regex.PatternSyntaxException;++public class PatternValidator implements CompactValidator {++    public static final String ID = ""pattern"";++    public static final PatternValidator INSTANCE = new PatternValidator();++    public static final String KEY_PATTERN = ""pattern"";++    public static final String MESSAGE_NO_MATCH = ""error-no-match"";++    private PatternValidator() {+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    public ValidationContext validate(Object input, String inputHint, ValidationContext context, ValidatorConfig config) {++        if (!(input instanceof String)) {+            context.addError(new ValidationError(ID, inputHint, MESSAGE_INVALID_VALUE, input));+            return context;+        }",Should we rather throw some exception?,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605616074,2021-04-01T12:28:25Z,server-spi-private/src/main/java/org/keycloak/validate/builtin/EmailValidator.java,"@@ -0,0 +1,60 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate.builtin;++import org.keycloak.validate.CompactValidator;+import org.keycloak.validate.ValidationContext;+import org.keycloak.validate.ValidationError;+import org.keycloak.validate.ValidatorConfig;++import java.util.regex.Pattern;++public class EmailValidator implements CompactValidator {++    public static final String ID = ""email"";++    public static final EmailValidator INSTANCE = new EmailValidator();++    public static final String MESSAGE_INVALID_EMAIL = ""error-invalid-email"";++    // Actually allow same emails like angular. See ValidationTest.testEmailValidation()+    private static final Pattern EMAIL_PATTERN = Pattern.compile(+            ""[a-zA-Z0-9!#$%&'*+/=?^_`{|}~.-]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*"");++    private EmailValidator() {+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    public ValidationContext validate(Object input, String inputHint, ValidationContext context, ValidatorConfig config) {++        if (!(input instanceof String)) {+            context.addError(new ValidationError(ID, inputHint, MESSAGE_INVALID_EMAIL, input));","I'd rather not throw an exception by default in that case, but we could configure the ValidationContext to throw an exception when a ValidationError is reported.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605619844,2021-04-01T12:32:07Z,server-spi-private/src/main/java/org/keycloak/validate/ValidatorConfig.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate;++import java.util.Collections;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.regex.Pattern;++/**+ * A typed wrapper around a {@link Map} based {@link Validator} configuration.+ */+public class ValidatorConfig {++    /**+     * An empty {@link ValidatorConfig}.+     */+    public static final ValidatorConfig EMPTY = new ValidatorConfig(Collections.emptyMap());++    /**+     * Holds the backing map for the {@link Validator} config.+     */+    private final Map<String, Object> config;++    /**+     * Creates a new {@link ValidatorConfig} from the given {@code map}.+     *+     * @param config+     */+    public ValidatorConfig(Map<String, Object> config) {+        this.config = config;+    }++    /**+     * Static helper to create a {@link ValidatorConfig} from the given {@code map}.+     *+     * @param map+     * @return+     */+    public static ValidatorConfig configFromMap(Map<String, Object> map) {+        if (map == null || map.isEmpty()) {+            return EMPTY;+        }+        return new ValidatorConfig(map);+    }++    public boolean containsKey(String key) {+        return config.containsKey(key);+    }++    public int size() {+        return config.size();+    }++    public boolean isEmpty() {+        return config.isEmpty();+    }++    public Object get(String key) {+        return config.get(key);+    }++    public Object getOrDefault(String key, Object defaultValue) {+        return config.getOrDefault(key, defaultValue);+    }++    public String getString(String key) {+        return getStringOrDefault(key, null);+    }++    public String getStringOrDefault(String key, String defaultValue) {+        Object value = config.get(key);+        if (value instanceof String) {+            return (String) value;+        }+        return defaultValue;+    }++    public Integer getIntOrDefault(String key) {+        return getIntOrDefault(key, null);+    }++    public Integer getIntOrDefault(String key, Integer defaultValue) {+        Object value = config.get(key);+        if (value instanceof Integer) {+            return (Integer) value;+        } else if (value instanceof Number) {+            return ((Number) value).intValue();+        } else if (value instanceof String) {+            return Integer.parseInt((String) value);+        }+        return defaultValue;+    }++    public Double getDoubleOrDefault(String key) {+        return getDoubleOrDefault(key, null);+    }++    public Double getDoubleOrDefault(String key, Double defaultValue) {+        Object value = config.get(key);+        if (value instanceof Double) {+            return (Double) value;+        } else if (value instanceof Number) {+            return ((Number) value).doubleValue();+        } else if (value instanceof String) {+            return Double.parseDouble((String) value);+        }+        return defaultValue;+    }++    public Boolean getBooleanOrDefault(String key) {+        return getBooleanOrDefault(key, null);+    }++    public Boolean getBooleanOrDefault(String key, Boolean defaultValue) {+        Object value = config.get(key);+        if (value instanceof Boolean) {+            return (Boolean) value;+        } else if (value instanceof String) {+            return Boolean.parseBoolean((String) value);+        }+        return defaultValue;+    }++    public Set<String> getStringSetOrDefault(String key) {+        return getStringSetOrDefault(key, null);+    }++    public Set<String> getStringSetOrDefault(String key, Set<String> defaultValue) {+        Object value = config.get(key);+        if (value instanceof Set) {+            return (Set<String>) value;+        }+        return defaultValue;+    }++    public List<String> getStringListOrDefault(String key) {+        return getStringListOrDefault(key, null);+    }++    public List<String> getStringListOrDefault(String key, List<String> defaultValue) {+        Object value = config.get(key);+        if (value instanceof List) {+            return (List<String>) value;+        }+        return defaultValue;+    }++    public Pattern getPattern(String key) {+        return getPatternOrDefault(key, null);+    }++    public Pattern getPatternOrDefault(String key, Pattern defaultValue) {+        Object value = config.get(key);+        if (value instanceof Pattern) {+            return (Pattern) value;+        } else if (value instanceof String) {+            return Pattern.compile((String) value);","I'd delegate that to the ValidatorConfig. But yes, the pattern could be cached.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7894,605818759,2021-04-01T17:14:03Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/clients/ClientClientScopesTest.java,"@@ -35,6 +34,8 @@ import org.keycloak.testsuite.console.page.clients.clientscopes.ClientScopesSetupForm; import org.keycloak.util.JsonSerialization; import org.keycloak.util.TokenUtil;+import org.hamcrest.MatcherAssert;+import static org.hamcrest.core.IsCollectionContaining.hasItems;",Prefer import from `Matchers` rather than individual hamcrest classes that can change in the future:```suggestionimport static org.hamcrest.Matchers.hasItems;```,
789496,jbman,https://api.github.com/repos/keycloak/keycloak/pulls/7887,605843851,2021-04-01T17:55:37Z,server-spi-private/src/main/java/org/keycloak/validate/Validator.java,"@@ -0,0 +1,114 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate;++import org.keycloak.provider.Provider;++import java.util.Map;++/**+ * Validates given input in a {@link ValidationContext}.+ * <p>+ * Validations can be supported with an optional {@code inputHint}, which could denote a reference to a potentially+ * nested attribute of an object to validate.+ * <p>+ * Validations can be configured with an optional {@code config} {@link Map}.+ */+public interface Validator extends Provider {++    /**+     * Validates the given {@code input}.+     *+     * @param input the value to validate+     * @return the validation context with the outcome of the validation+     */+    default ValidationContext validate(Object input) {+        return validate(input, ""input"", new ValidationContext(), ValidatorConfig.EMPTY);+    }++    /**+     * Validates the given {@code input} with an additional {@code config}.+     *+     * @param input  the value to validate+     * @param config parameterization for the current validation+     * @return the validation context with the outcome of the validation+     */+    default ValidationContext validate(Object input, ValidatorConfig config) {","1. Thanks, shared context but not shared config is a good reason to separate the parameters2. Ok, got the different cases. The main drawback is the difficulty for the validator implementation to state that that  a `ValidationContext` instance is required and must not be null.  Would be nice to know that just by the interface. ```public interface Validator {    ValidationContext validate(Object input, ValidatorConfig config)) ...public interface ValidatorWithContext {    ValidationContext validate(Object input, ValidationContext context, ValidatorConfig config)) ...```Unfortunately this can't be done for 'ValidatorConfig' parameter at the same time. Get's a bit unhandy to have a `ValidatorWithContextAndConfig` and a `ValidatorWithConfig` interface on top.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,606639483,2021-04-03T08:54:30Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java,"@@ -0,0 +1,699 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.utils.SessionTimeoutHelper;++import java.util.Collection;+import java.util.Comparator;+import java.util.HashMap;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;+import java.util.UUID;+import java.util.concurrent.ConcurrentHashMap;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import static org.keycloak.models.UserSessionModel.SessionPersistenceState.TRANSIENT;+import static org.keycloak.utils.StreamsUtil.paginatedStream;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProvider implements UserSessionProvider {++    private static final Logger LOG = Logger.getLogger(MapUserSessionProvider.class);+    private final KeycloakSession session;+    protected final MapKeycloakTransaction<UUID, MapUserSessionEntity, UserSessionModel> userSessionTx;+    protected final MapKeycloakTransaction<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionTx;+    private final MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private final MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;++    /**+     * Storage for transient user sessions which lifespan is limited to one request.+     */+    private Map<UUID, MapUserSessionEntity> transientUserSessions = new HashMap<>();++    public MapUserSessionProvider(KeycloakSession session, MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore,+                                  MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore) {+        this.session = session;+        this.userSessionStore = userSessionStore;+        this.clientSessionStore = clientSessionStore;+        userSessionTx = userSessionStore.createTransaction(session);+        clientSessionTx = clientSessionStore.createTransaction(session);++        session.getTransactionManager().enlistAfterCompletion(userSessionTx);+        session.getTransactionManager().enlistAfterCompletion(clientSessionTx);+    }++    private Function<MapUserSessionEntity, UserSessionModel> userEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return (origEntity) -> new MapUserSessionAdapter(session, realm,+                Objects.equals(origEntity.getPersistenceState(), TRANSIENT) ? origEntity : registerEntityForChanges(origEntity)) {++            @Override+            public void removeAuthenticatedClientSessions(Collection<String> removedClientUUIDS) {+                removedClientUUIDS.forEach(clientId -> {+                    clientSessionTx.delete(UUID.fromString(clientId));+                    entity.removeAuthenticatedClientSession(clientId);+                });+            }+        };+    }++    private Function<MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientEntityToAdapterFunc(RealmModel realm,+                                                                                                                     ClientModel client,+                                                                                                                     UserSessionModel userSession) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapAuthenticatedClientSessionAdapter(session, realm, client, userSession, registerEntityForChanges(origEntity)) {+            @Override+            public void detachFromUserSession() {+                this.userSession = null;++                clientSessionTx.delete(entity.getId());+            }+        };+    }++    private MapUserSessionEntity registerEntityForChanges(MapUserSessionEntity origEntity) {+        MapUserSessionEntity res = userSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userSessionTx.updateIfChanged(origEntity.getId(), res, MapUserSessionEntity::isUpdated);+        return res;+    }++    private MapAuthenticatedClientSessionEntity registerEntityForChanges(MapAuthenticatedClientSessionEntity origEntity) {+        MapAuthenticatedClientSessionEntity res = clientSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        clientSessionTx.updateIfChanged(origEntity.getId(), res, MapAuthenticatedClientSessionEntity::isUpdated);+        return res;+    }++    @Override+    public AuthenticatedClientSessionModel createClientSession(RealmModel realm, ClientModel client, UserSessionModel userSession) {+        MapAuthenticatedClientSessionEntity entity =+                new MapAuthenticatedClientSessionEntity(UUID.randomUUID(), userSession.getId(), realm.getId(), client.getId(), false);++        LOG.tracef(""createClientSession(%s, %s, %s)%s"", realm, client, userSession, getShortStackTrace());++        clientSessionTx.create(entity.getId(), entity);++        MapUserSessionEntity userSessionEntity = getUserSessionById(UUID.fromString(userSession.getId()));++        if (userSessionEntity == null) {+            throw new IllegalStateException(""User session entity does not exist: "" + userSession.getId());+        }++        userSessionEntity.addAuthenticatedClientSession(client.getId(), entity.getId());++        return clientEntityToAdapterFunc(realm, client, userSession).apply(entity);+    }++    @Override+    public AuthenticatedClientSessionModel getClientSession(UserSessionModel userSession, ClientModel client,+                                                            UUID clientSessionId, boolean offline) {+        LOG.tracef(""getClientSession(%s, %s, %s, %s)%s"", userSession, client,+                clientSessionId, offline, getShortStackTrace());++        Objects.requireNonNull(userSession, ""The provided user session cannot be null!"");+        Objects.requireNonNull(client, ""The provided client cannot be null!"");+        if (clientSessionId == null) {+            return null;+        }++        ModelCriteriaBuilder<AuthenticatedClientSessionModel> mcb = clientSessionStore.createCriteriaBuilder()+                .compare(AuthenticatedClientSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, clientSessionId)+                .compare(AuthenticatedClientSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, userSession.getRealm().getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.IS_OFFLINE, ModelCriteriaBuilder.Operator.EQ, offline);++        if (offline) {+            mcb = mcb.compare(AuthenticatedClientSessionModel.SearchableFields.USER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, ((MapUserSessionAdapter) userSession).getCorrespondingSessionId());+        } else {+            mcb = mcb.compare(AuthenticatedClientSessionModel.SearchableFields.USER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, userSession.getId());+        }++        return clientSessionTx.getUpdatedNotRemoved(mcb)+                .map(clientEntityToAdapterFunc(client.getRealm(), client, userSession))+                .findFirst()+                .orElse(null);","```suggestion                .findFirst()                .map(clientEntityToAdapterFunc(client.getRealm(), client, userSession))                .orElse(null);```if you decide to change it, there are other places in this class with `findFirst` after creating adapter from entity.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7878,606644297,2021-04-03T09:47:04Z,model/map/src/main/java/org/keycloak/models/map/authorization/entity/AbstractResourceEntity.java,"@@ -0,0 +1,182 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.authorization.entity;++import org.keycloak.models.map.common.AbstractEntity;++import java.util.Collections;+import java.util.Comparator;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;++public abstract class AbstractResourceEntity<K> implements AbstractEntity<K> {+    +    public static final Comparator<AbstractResourceEntity<?>> COMPARE_BY_NAME = Comparator.comparing(AbstractResourceEntity::getName);++    private final K id;+    private String name;+    private String displayName;+    private final Set<String> uris = new HashSet<>();+    private String type;+    private String iconUri;+    private String owner;+    private boolean ownerManagedAccess;+    private String resourceServerId;+    private final Set<K> scopeIds = new HashSet<>();+    private final Set<K> policyIds = new HashSet<>();+    private final Map<String, List<String>> attributes = new HashMap<>();+    private boolean updated = false;++    protected AbstractResourceEntity(K id) {+        this.id = id;+    }++    public AbstractResourceEntity() {+        this.id = null;+    }++    @Override+    public K getId() {+        return id;+    }++    public String getName() {+        return name;+    }++    public void setName(String name) {+        this.updated |= !Objects.equals(this.name, name);+        this.name = name;+    }++    public String getDisplayName() {+        return displayName;+    }++    public void setDisplayName(String displayName) {+        this.updated |= !Objects.equals(this.displayName, displayName);+        this.displayName = displayName;+    }++    public Set<String> getUris() {+        return uris;+    }++    public void setUris(Set<String> uris) {+        if (Objects.equals(this.uris, uris)) return;++        this.updated = true;+        this.uris.clear();++        if (uris != null) {+            this.uris.addAll(uris);+        }+    }++    public String getType() {+        return type;+    }++    public void setType(String type) {+        this.updated |= !Objects.equals(this.type, type);+        this.type = type;+    }++    public String getIconUri() {+        return iconUri;+    }++    public void setIconUri(String iconUri) {+        this.updated |= !Objects.equals(this.iconUri, iconUri);+        this.iconUri = iconUri;+    }++    public String getOwner() {+        return owner;+    }++    public void setOwner(String owner) {+        this.updated |= !Objects.equals(this.owner, owner);+        this.owner = owner;+    }++    public boolean isOwnerManagedAccess() {+        return ownerManagedAccess;+    }++    public void setOwnerManagedAccess(boolean ownerManagedAccess) {+        this.updated |= this.ownerManagedAccess != ownerManagedAccess;+        this.ownerManagedAccess = ownerManagedAccess;+    }++    public String getResourceServerId() {+        return resourceServerId;+    }++    public void setResourceServerId(String resourceServerId) {+        this.updated |= !Objects.equals(this.resourceServerId, resourceServerId);+        this.resourceServerId = resourceServerId;+    }++    public Set<K> getScopeIds() {+        return scopeIds;+    }++    public void setScopeIds(Set<K> scopeIds) {+        if (Objects.equals(this.scopeIds, scopeIds)) return;++        this.updated = true;+        this.scopeIds.clear();+        if (scopeIds != null) {+            this.scopeIds.addAll(scopeIds);+        }+    }++    public Set<K> getPolicyIds() {+        return policyIds;+    }++    public Map<String, List<String>> getAttributes() {+        return attributes;+    }++    public List<String> getAttribute(String name) {+        return attributes.get(name);+    }++    public String getSingleAttribute(String name) {+        return attributes.getOrDefault(name, Collections.emptyList()).get(0);",I believe this could throw `IndexOutOfBoundsException` when there is no key `name` and the default `Collections.emptyList()` is returned. Then `.get(0)` is called on empty list which should throw the exception.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7878,606790534,2021-04-04T11:50:21Z,model/map/src/main/java/org/keycloak/models/map/authorization/MapPermissionTicketStore.java,"@@ -0,0 +1,322 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.authorization;++import org.jboss.logging.Logger;+import org.keycloak.authorization.AuthorizationProvider;+import org.keycloak.authorization.model.PermissionTicket;+import org.keycloak.authorization.model.PermissionTicket.SearchableFields;+import org.keycloak.authorization.model.Resource;+import org.keycloak.authorization.model.ResourceServer;+import org.keycloak.authorization.store.PermissionTicketStore;+import org.keycloak.authorization.store.ResourceStore;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.map.authorization.adapter.MapPermissionTicketAdapter;+import org.keycloak.models.map.authorization.entity.AbstractPermissionTicketEntity;+import org.keycloak.models.map.authorization.entity.MapPermissionTicketEntity;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;++import java.util.Collections;+import java.util.EnumMap;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.UUID;+import java.util.function.Function;+import java.util.stream.Collectors;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import static org.keycloak.utils.StreamsUtil.distinctByKey;+import static org.keycloak.utils.StreamsUtil.paginatedStream;++public class MapPermissionTicketStore implements PermissionTicketStore {++    private static final Logger LOG = Logger.getLogger(MapPermissionTicketStore.class);+    private final KeycloakSession session;",Do we need the session in this class?The same applies to other `Map*Store`s,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,607314284,2021-04-05T20:28:41Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","@mposolda @tnorimat Could you guys check https://github.com/pedroigor/keycloak/tree/KEYCLOAK-12137 ?Basically, I've decoupled the authentication bits from the payload sent to AD. Keycloak sends now a JWS with only the necessary bits to authenticate requests from the AD at the callback endpoint. A payload is also sent with only the information needed by the AD.We don't expose the auth_req_id to the AD. In fact, I think we can remove the `subject`  too.By using JSON as a payload, I think the contract is much more simple and well structured than using form parameters.There is no client authentication, but bearer authorization at both sides: the AD and the callback endpoint.There is one thing though that I think we might consider:* The bearer token sent to AD uses the client associated with the CD. IMO, we should have the AD as a client as well. Ideally, we should build the JWS where `azp` is the AD client. That should also enable to pass the CD client id to the AD so that additional validations and logic can be applied by the AD when authorizing a user for a particular CD. One drawback of this is that it would make CIBA config a bit more complicated.* By having a specific client for AD, we can in the future perform other forms of authentication.I've also changed tests but I did only three of them. Please, let me know if the changes make sense so we can continue.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7878,607751221,2021-04-06T11:03:07Z,model/map/src/main/java/org/keycloak/models/map/authorization/adapter/MapPolicyAdapter.java,"@@ -0,0 +1,200 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.authorization.adapter;++import org.keycloak.authorization.model.Policy;+import org.keycloak.authorization.model.Resource;+import org.keycloak.authorization.model.ResourceServer;+import org.keycloak.authorization.model.Scope;+import org.keycloak.authorization.store.StoreFactory;+import org.keycloak.models.map.authorization.entity.MapPolicyEntity;+import org.keycloak.representations.idm.authorization.DecisionStrategy;+import org.keycloak.representations.idm.authorization.Logic;++import java.util.Map;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;++public class MapPolicyAdapter extends AbstractPolicyModel<MapPolicyEntity> {+    +    public MapPolicyAdapter(MapPolicyEntity entity, StoreFactory storeFactory) {+        super(entity, storeFactory);+    }++    @Override+    public String getId() {+        return entity.getId().toString();+    }++    @Override+    public String getType() {+        return entity.getType();+    }++    @Override+    public DecisionStrategy getDecisionStrategy() {+        return entity.getDecisionStrategy();+    }++    @Override+    public void setDecisionStrategy(DecisionStrategy decisionStrategy) {+        throwExceptionIfReadonly();+        entity.setDecisionStrategy(decisionStrategy);+    }++    @Override+    public Logic getLogic() {+        return entity.getLogic();+    }++    @Override+    public void setLogic(Logic logic) {+        throwExceptionIfReadonly();+        entity.setLogic(logic);+    }++    @Override+    public Map<String, String> getConfig() {+        return entity.getConfig();+    }++    @Override+    public void setConfig(Map<String, String> config) {+        throwExceptionIfReadonly();+        entity.setConfig(config);+    }++    @Override+    public void removeConfig(String name) {+        throwExceptionIfReadonly();+        entity.removeConfig(name);+    }++    @Override+    public void putConfig(String name, String value) {+        throwExceptionIfReadonly();+        entity.putConfig(name, value);+    }++    @Override+    public String getName() {+        return entity.getName();+    }++    @Override+    public void setName(String name) {+        throwExceptionIfReadonly();+        entity.setName(name);+    }++    @Override+    public String getDescription() {+        return entity.getDescription();+    }++    @Override+    public void setDescription(String description) {+        throwExceptionIfReadonly();+        entity.setDescription(description);+    }++    @Override+    public ResourceServer getResourceServer() {+        return storeFactory.getResourceServerStore().findById(entity.getResourceServerId());+    }++    @Override+    public Set<Policy> getAssociatedPolicies() {+        String resourceServerId = entity.getResourceServerId();+        return entity.getAssociatedPoliciesIds().stream()+                .map(policyId -> storeFactory.getPolicyStore().findById(policyId.toString(), resourceServerId))+                .collect(Collectors.toSet());+    }++    @Override+    public Set<Resource> getResources() {+        String resourceServerId = entity.getResourceServerId();+        return entity.getResourceIds().stream()+                .map(resourceId -> storeFactory.getResourceStore().findById(resourceId.toString(), resourceServerId))+                .collect(Collectors.toSet());+    }++    @Override+    public Set<Scope> getScopes() {+        String resourceServerId = entity.getResourceServerId();+        return entity.getScopeIds().stream()+                .map(scopeId -> storeFactory.getScopeStore().findById(scopeId.toString(), resourceServerId))+                .collect(Collectors.toSet());+    }++    @Override+    public String getOwner() {+        return entity.getOwner();+    }++    @Override+    public void setOwner(String owner) {+        throwExceptionIfReadonly();+        entity.setOwner(owner);+    }++    @Override+    public void addScope(Scope scope) {+        throwExceptionIfReadonly();+        entity.addScope(UUID.fromString(scope.getId()));+    }++    @Override+    public void removeScope(Scope scope) {+        throwExceptionIfReadonly();+        entity.removeScope(UUID.fromString(scope.getId()));+    }++    @Override+    public void addAssociatedPolicy(Policy associatedPolicy) {+        throwExceptionIfReadonly();+        entity.addAssociatedPolicy(UUID.fromString(associatedPolicy.getId()));+    }++    @Override+    public void removeAssociatedPolicy(Policy associatedPolicy) {+        throwExceptionIfReadonly();+        entity.removeAssociatedPolicy(UUID.fromString(associatedPolicy.getId()));+    }++    @Override+    public void addResource(Resource resource) {+        throwExceptionIfReadonly();+        entity.addResource(UUID.fromString(resource.getId()));+    }++    @Override+    public void removeResource(Resource resource) {+        throwExceptionIfReadonly();+        entity.removeResource(UUID.fromString(resource.getId()));+    }++    /**+     * TODO: I am not sure what is the purpose of this method, seems it is not called at all, maybe we can remove?+     */+    @Override+    public boolean isFetched(String association) {",We can. Its purpose was related to caching but not associations are lazy loaded.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,607767799,2021-04-06T11:31:12Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","@mposolda @tnorimat I was thinking more about how we authenticate the AD when at the callback endpoint. I think we should keep client authentication and have the AD as a client registered to the server.When at the callback endpoint, we are going to allow only the AD client.I'm not sure if we should blindly trust requests from AD based on bearer authorization only. This is a critical part of the CIBA flow and if the token is somehow leaked/stolen, bad things can happen.Bearer authorization helps to authorize Keycloak when pushing authentication requests to AD. But not the other way around.So, I propose we either:* Change CIBA policy to define a client as an AD* Define a built-in role for CIBA that should be granted to clients actings as a ADWDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7878,607829199,2021-04-06T13:03:41Z,model/jpa/src/main/java/org/keycloak/authorization/jpa/entities/PermissionTicketEntity.java,"@@ -35,7 +35,7 @@  */ @Entity @Table(name = ""RESOURCE_SERVER_PERM_TICKET"", uniqueConstraints = {-        @UniqueConstraint(columnNames = {""OWNER"", ""RESOURCE_SERVER_ID"", ""RESOURCE_ID"", ""SCOPE_ID""})+        @UniqueConstraint(columnNames = {""OWNER"", ""REQUESTER"", ""RESOURCE_SERVER_ID"", ""RESOURCE_ID"", ""SCOPE_ID""})",This is not related to map store. I believe this is a bug here and the `REQUESTER` is missing. I created the constraint for map storage based on this line and some test failed because the database contains also `REQUESTER` in uniqueConstraint. See: https://github.com/keycloak/keycloak/blob/master/model/jpa/src/main/resources/META-INF/jpa-changelog-authz-4.0.0.CR1.xml#L52,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,607995860,2021-04-06T16:20:11Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","@pedroigor +1 to your last comment. I believe that this is also aligned with what we discussed earlier with @tnorimat in the comment https://github.com/keycloak/keycloak/pull/7679#discussion_r603109945 and earlier.Also if I understand correctly, it means that AuthenticationChannelRequest will need to contain the client_id of CD client, so that callback endpoint will verify this client_id and compare it with the ID from the cache (similarly like is currently done in your branch here https://github.com/pedroigor/keycloak/blob/KEYCLOAK-12137/services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java#L127 ). This will be good to avoid scenarios mentioned by @tnorimat in this comment https://github.com/keycloak/keycloak/pull/7679#discussion_r605329635 .From the proposed alternatives, I am not 100% sure if it is better to have client as an AD defined on the CIBA policy, or the built-in role for CIBA granted to clients? Any of those are fine for me for this PR.@pedroigor @tnorimat For the future, I guess we may need something even more powerful though. It is possible that various CD clients will want to authenticate against specified AD. The AD can be possibly either configured for the client OR the target AD can be chosen from multiple ADs inside BackchannelAuthenticationEndpoint based on the `acr_values` claim. At least, it is my understanding of the specification when it mentions this here https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_server_obtains_consent:```After the OP has validated the Authentication Request, the OP identifies the user and chooses a channel to best authenticate the user and authorize the request, in line with the Client's requests regarding acr_values. ```Which means that single CD client might want to use:- AD client ""ad1"" in case that `acr_values` contains claims `level1`- AD client ""ad2"" in case that `acr_values` contains claims `level2`But this is just some brainstorming for the future. Not something for this PR IMO...",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,608085069,2021-04-06T18:26:39Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","> Also if I understand correctly, it means that AuthenticationChannelRequest will need to contain the client_id of CD client, so that callback endpoint will verify this client_id and compare it with the ID from the cache (similarly like is currently done in your branch here https://github.com/pedroigor/keycloak/blob/KEYCLOAK-12137/services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java#L127 ). This will be good to avoid scenarios mentioned by @tnorimat in this comment [#7679 (comment)](https://github.com/keycloak/keycloak/pull/7679#discussion_r605329635) .What I have in mind is:* We still need to pass some reference token so that we don't complicate the life of AD when invoking the callback endpoint. Without this token, we are in the same situation as before, where the AD should be aware of multiple fields to return back. One important aspect of this token is the `azp`, marking this token as primarily issued for the AD. (not the CD as it stands now)* The reference token is pretty much what I have in that branch. It should be enough to authenticate a request from Keycloak (signature mainly) and hold what is needed to validate requests from AD to the callback endpoint. The AD does not need to introspect this token but only use it to authenticate requests and replay it when calling the callback endpoint.* The payload, the `AuthenticationChannelRequest` is only used for passing data that might be useful for the AD when authenticating a user. One example is passing the client id of the CD so that the AD could do some sort of customization depending on the CD asking for authentication. Perhaps, also acr_values, etc.* When making requests to the callback endpoint, the AD is going to authenticate using its client credentials (and any authentication method) and we are going to compare if the `azp` in the reference token is the same as the client authenticating (the AD) to the callback endpoint. If not, that means another client is trying to act as the AD.> > From the proposed alternatives, I am not 100% sure if it is better to have client as an AD defined on the CIBA policy, or the built-in role for CIBA granted to clients? Any of those are fine for me for this PR.Same here. I would also highlight that introducing either of these options is going to complicate CIBA config. And I'm also OK to leave that for now and only rely on the bearer-token authorization. Just like it is implemented in my branch. It is not the ideal, but it works as long as:* AD must make sure the bearer token is secure in transit (TLS) and at rest (if they need to store it).* AD should have a high level of trustIf these requirements can be fulfilled then I think it is OK to rely on bearer token authorization between callback endpoint and AD.WDYT?> > @pedroigor @tnorimat For the future, I guess we may need something even more powerful though. It is possible that various CD clients will want to authenticate against specified AD. The AD can be possibly either configured for the client OR the target AD can be chosen from multiple ADs inside BackchannelAuthenticationEndpoint based on the `acr_values` claim. At least, it is my understanding of the specification when it mentions this here https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_server_obtains_consent:> > ```> After the OP has validated the Authentication Request, the OP identifies the user and chooses a channel to best > authenticate the user and authorize the request, in line with the Client's requests regarding acr_values. > ```> > Which means that single CD client might want to use:> > * AD client ""ad1"" in case that `acr_values` contains claims `level1`> * AD client ""ad2"" in case that `acr_values` contains claims `level2`>   But this is just some brainstorming for the future. Not something for this PR IMO...Definitely. But easily solved as you can implement an authentication channel provider.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,608142754,2021-04-06T20:01:37Z,model/map/src/main/java/org/keycloak/models/map/loginFailure/AbstractUserLoginFailureEntity.java,"@@ -0,0 +1,124 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.loginFailure;++import org.keycloak.models.map.common.AbstractEntity;++import java.util.Objects;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public abstract class AbstractUserLoginFailureEntity<K> implements AbstractEntity<K> {+    private K id;+    private String realmId;+    private String userId;++    /**+     * Flag signalizing that any of the setters has been meaningfully used.+     */+    protected boolean updated;++    private int failedLoginNotBefore;+    private int numFailures;+    private long lastFailure;","In case of #7842, the transition to non-primitive types is motivated by expectation of a hierarchy on realms. Would there be a benefit of having a similar hierarchical structure for login failures?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,608144110,2021-04-06T20:04:03Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","Btw, w.r.t to the callback endpoint contract. So far we are relying on request data (either as form params or as a JSON, as per in my branch) to check whether the user was authenticated by the AD, or if the authentication request was denied or canceled.Another thing we could improve here is:* Rely on HTTP verbs for approval and deny. For instance, a `POST` to the callback endpoint is a OK from AD. A `DELETE` a deny/cancel. Not sure if we need to cancel.* By relying on HTTP verbs, we could still allow AD to pass ""details"" about the operation and potentially return that either to the CD or just for audit purposes.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,608149138,2021-04-06T20:12:40Z,server-spi/src/main/java/org/keycloak/models/UserSessionProvider.java,"@@ -154,11 +154,6 @@ UserSessionModel createUserSession(String id, RealmModel realm, UserModel user,      void removeUserSessions(RealmModel realm); -    UserLoginFailureModel getUserLoginFailure(RealmModel realm, String userId);-    UserLoginFailureModel addUserLoginFailure(RealmModel realm, String userId);-    void removeUserLoginFailure(RealmModel realm, String userId);-    void removeAllUserLoginFailures(RealmModel realm);",Good point. Please mark the method as deprecated in favor of `LoginFailureProvider`,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,608372036,2021-04-07T06:26:34Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","@pedroigor I am also fine with the fact that callback endpoint won't be authenticated by the AD for now. I originally though that you wanted to enforce the client authentication of AD client based on your comment https://github.com/keycloak/keycloak/pull/7679#discussion_r607767799 . But agree that it would be another complexity, so +1 for adding it later and just go with bearer authentication for now.When you pointed `acr_values` inside AuthenticationChannelRequest, this is exactly something, which we discussed with @tnorimat on the other place https://github.com/keycloak/keycloak/pull/7679#discussion_r599419016 . My vote would be to allow `acr_values` parameter inside the initial BackchannelAuthenticationEndpoint and forward it to the AD as it is, so that AD can eventually choose from various authentication possibilities for the case it supports `acr_values`. But not a blocker for this PR IMO.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7910,608637738,2021-04-07T13:10:04Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/ConfidentialClientAcceptExecutor.java,"@@ -0,0 +1,72 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;++import org.keycloak.OAuthErrorException;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;++import com.fasterxml.jackson.annotation.JsonIgnoreProperties;++/**+ * @author <a href=""mailto:takashi.norimatsu.ws@hitachi.com"">Takashi Norimatsu</a>+ */+public class ConfidentialClientAcceptExecutor implements ClientPolicyExecutorProvider<ClientPolicyExecutorConfiguration> {++    protected final KeycloakSession session;++    public ConfidentialClientAcceptExecutor(KeycloakSession session) {+        this.session = session;+    }++    @JsonIgnoreProperties(ignoreUnknown = true)+    public static class Configuration {","It seems that this class is not needed at all - we can probably stick with the ClientPolicyExecutorConfiguration?Just noticed that the same approach can be done on few other executor implementations (like for example SecureSessionEnforceExecutor) where the inner ""Configuration"" class can also be removed. It should also help to simplify some stuff in AbstractClientPoliciesTest, which can just use the generic ClientPolicyExecutorConfiguration for executors, which don't have any configuration options. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7910,608638812,2021-04-07T13:11:23Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/AbstractClientPoliciesTest.java,"@@ -889,6 +890,10 @@ protected Object createSecureSigningAlgorithmForSignedJwtEnforceExecutorConfig()         return new SecureSigningAlgorithmForSignedJwtEnforceExecutor.Configuration();     } +    protected Object createConfidentialClientAcceptExecutorConfig() {","As mentioned above, this method can be probably removed (similar methods for other executors as well) and just use ClientPolicyExecutorConfiguration. WDYT?",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,608655802,2021-04-07T13:30:54Z,server-spi/src/main/java/org/keycloak/models/LoginFailureProvider.java,"@@ -0,0 +1,54 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models;++import org.keycloak.provider.Provider;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public interface LoginFailureProvider extends Provider {","Login failures can be separated from user sessions because they don't have much in common. They each use a separate storage. MapUserSessionProvider can be then cleaner. Regarding the moving to `server-spi-private`, I am not sure. The new `LoginFailureProvider` is added to keycloak session which is in `server-spi`. I would need to add the `server-spi-private` as a dependency to `server-spi`. ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,608694217,2021-04-07T14:14:07Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","> @pedroigor If you do not have any plan to change your branch further drastically, I would like to pick up it and continue my work based on it. WDYT?I don't :) Sounds good to me, please continue your work on it.I've also updated tests.One thing though that I think we should do is to make sure CIBA is marked as a tech preview feature. For that, I've updated that branch to avoid registering CIBA-related providers.@mposolda I found an issue when providers are being deployed where the list of default providers is not updated. Please, see the `DefaultKeycloakSessionFactory` changes.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,608695283,2021-04-07T14:15:19Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","> @pedroigor I am also fine with the fact that callback endpoint won't be authenticated by the AD for now. I originally though that you wanted to enforce the client authentication of AD client based on your comment [#7679 (comment)](https://github.com/keycloak/keycloak/pull/7679#discussion_r607767799) . But agree that it would be another complexity, so +1 for adding it later and just go with bearer authentication for now.I still think it is important. But right now it would complicate the CIBA config a bit and we can always add client authentication, as you guys mentioned.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,608753315,2021-04-07T15:19:22Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserLoginFailureProviderFactory.java,"@@ -0,0 +1,300 @@+package org.keycloak.models.sessions.infinispan;++import org.infinispan.Cache;+import org.infinispan.client.hotrod.RemoteCache;+import org.infinispan.persistence.remote.RemoteStore;+import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.cluster.ClusterProvider;+import org.keycloak.common.util.Environment;+import org.keycloak.common.util.Time;+import org.keycloak.connections.infinispan.InfinispanConnectionProvider;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.KeycloakSessionTask;+import org.keycloak.models.LoginFailureProvider;+import org.keycloak.models.LoginFailureProviderFactory;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.sessions.infinispan.changes.SessionEntityWrapper;+import org.keycloak.models.sessions.infinispan.changes.sessions.CrossDCLastSessionRefreshStore;+import org.keycloak.models.sessions.infinispan.changes.sessions.CrossDCLastSessionRefreshStoreFactory;+import org.keycloak.models.sessions.infinispan.changes.sessions.PersisterLastSessionRefreshStore;+import org.keycloak.models.sessions.infinispan.changes.sessions.PersisterLastSessionRefreshStoreFactory;+import org.keycloak.models.sessions.infinispan.entities.AuthenticatedClientSessionEntity;+import org.keycloak.models.sessions.infinispan.entities.LoginFailureEntity;+import org.keycloak.models.sessions.infinispan.entities.LoginFailureKey;+import org.keycloak.models.sessions.infinispan.entities.SessionEntity;+import org.keycloak.models.sessions.infinispan.entities.UserSessionEntity;+import org.keycloak.models.sessions.infinispan.events.AbstractUserSessionClusterListener;+import org.keycloak.models.sessions.infinispan.events.ClientRemovedSessionEvent;+import org.keycloak.models.sessions.infinispan.events.RealmRemovedSessionEvent;+import org.keycloak.models.sessions.infinispan.events.RemoveAllUserLoginFailuresEvent;+import org.keycloak.models.sessions.infinispan.events.RemoveUserSessionsEvent;+import org.keycloak.models.sessions.infinispan.initializer.InfinispanCacheInitializer;+import org.keycloak.models.sessions.infinispan.remotestore.RemoteCacheInvoker;+import org.keycloak.models.sessions.infinispan.remotestore.RemoteCacheSessionListener;+import org.keycloak.models.sessions.infinispan.remotestore.RemoteCacheSessionsLoader;+import org.keycloak.models.sessions.infinispan.util.InfinispanKeyGenerator;+import org.keycloak.models.sessions.infinispan.util.InfinispanUtil;+import org.keycloak.models.sessions.infinispan.util.SessionTimeouts;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.models.utils.PostMigrationEvent;+import org.keycloak.models.utils.ResetTimeOffsetEvent;+import org.keycloak.provider.ProviderEvent;+import org.keycloak.provider.ProviderEventListener;++import java.io.Serializable;+import java.util.Set;+import java.util.UUID;+import java.util.function.BiFunction;++public class InfinispanUserLoginFailureProviderFactory implements LoginFailureProviderFactory {++    private static final Logger log = Logger.getLogger(InfinispanUserSessionProviderFactory.class);++    public static final String PROVIDER_ID = ""infinispan"";++    public static final String REALM_REMOVED_SESSION_EVENT = ""REALM_REMOVED_EVENT_SESSIONS"";++    public static final String CLIENT_REMOVED_SESSION_EVENT = ""CLIENT_REMOVED_SESSION_SESSIONS"";++    public static final String REMOVE_USER_SESSIONS_EVENT = ""REMOVE_USER_SESSIONS_EVENT"";++    public static final String REMOVE_ALL_LOGIN_FAILURES_EVENT = ""REMOVE_ALL_LOGIN_FAILURES_EVENT"";++    private Config.Scope config;++    private RemoteCacheInvoker remoteCacheInvoker;+    private CrossDCLastSessionRefreshStore lastSessionRefreshStore;+    private CrossDCLastSessionRefreshStore offlineLastSessionRefreshStore;+    private PersisterLastSessionRefreshStore persisterLastSessionRefreshStore;+    private InfinispanKeyGenerator keyGenerator;++    @Override+    public LoginFailureProvider create(KeycloakSession session) {+        InfinispanConnectionProvider connections = session.getProvider(InfinispanConnectionProvider.class);",Note after discussion with @martin-kanis:```java        return session.getProvider(InfinispanUserSessionProvider.class);```would return `null`,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7859,609521107,2021-04-08T09:50:22Z,quarkus/runtime/src/main/java/org/keycloak/provider/quarkus/QuarkusPlatform.java,"@@ -108,4 +114,29 @@ private void addDeferredException(Throwable t) {         return deferredExceptions;     } +    @Override+    public File getTmpDirectory() {+        if (tmpDir == null) {+            String homeDir = Environment.getHomeDir();++            File tmpDir;+            if (homeDir == null) {+                // Should happen just in the unit tests+                homeDir = System.getProperty(""java.io.tmpdir"");+                tmpDir = new File(homeDir, ""keycloak-quarkus-tmp"");+                tmpDir.mkdir();","@JLLeitschuh So far, this is rather theoretic vulnerability IMO. The directory used in the unit tests does not contain any sensitive data or anything, which could somehow break the system. However I agree that will be better to make sure that directory is always created exclusively by the user triggering the test.I've created JIRA and sent the PR https://github.com/keycloak/keycloak/pull/7916. Do you have a chance to take a look please?",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,609532061,2021-04-08T10:03:41Z,server-spi/src/main/java/org/keycloak/models/UserSessionProvider.java,"@@ -154,11 +154,6 @@ UserSessionModel createUserSession(String id, RealmModel realm, UserModel user,      void removeUserSessions(RealmModel realm); -    UserLoginFailureModel getUserLoginFailure(RealmModel realm, String userId);-    UserLoginFailureModel addUserLoginFailure(RealmModel realm, String userId);-    void removeUserLoginFailure(RealmModel realm, String userId);-    void removeAllUserLoginFailures(RealmModel realm);",Done. Marked as deprecated and default. I introduced a new method `getKeycloakSession()` to be able to implement defaults.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,609873359,2021-04-08T16:19:43Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProviderFactory.java,"@@ -0,0 +1,66 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.UserSessionProviderFactory;+import org.keycloak.models.map.common.AbstractMapProviderFactory;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;++import java.util.UUID;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProviderFactory extends AbstractMapProviderFactory<UserSessionProvider>+        implements UserSessionProviderFactory {++    private MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;++    @Override+    public void postInit(KeycloakSessionFactory factory) {+        MapStorageProvider sp = (MapStorageProvider) factory.getProviderFactory(MapStorageProvider.class);+        userSessionStore = sp.getStorage(""userSessions"", UUID.class, MapUserSessionEntity.class, UserSessionModel.class);+        clientSessionStore = sp.getStorage(""clientSessions"", UUID.class, MapAuthenticatedClientSessionEntity.class, AuthenticatedClientSessionModel.class);++        factory.register(event -> {+            if (event instanceof UserModel.UserRemovedEvent) {+                UserModel.UserRemovedEvent userRemovedEvent = (UserModel.UserRemovedEvent) event;++                MapUserSessionProvider provider = (MapUserSessionProvider) userRemovedEvent.getKeycloakSession().getProvider(UserSessionProvider.class, getId());+                provider.onUserRemoved(userRemovedEvent.getRealm(), userRemovedEvent.getUser());+            }+        });+    }++    @Override+    public void loadPersistentSessions(KeycloakSessionFactory sessionFactory, int maxErrors, int sessionsPerSegment) {","No, `MapUserSessionProvider` doesn't use user sessions preloading nor storing sessions in a database using the `UserSessionPersister`. Sessions are always available in the map storage and persisted to a file if needed. ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7640,610408839,2021-04-09T07:30:18Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/BrowserFlowTest.java,"@@ -1238,6 +1253,259 @@ public void testLoginWithAlternativeOTPAndConditionalPassword(){         }     } +    @Test+    @AuthServerContainerExclude(REMOTE)","My vote would be to move new stuff to separate class like ""AllowDenyAuthenticatorConditionsTest"" or something like this? It seems to me that BrowserFlowTest is already quite big and contains lots of stuff. WDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7901,610746031,2021-04-09T16:06:09Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -1301,6 +1304,29 @@             return promise.promise;         } +        function checkIfRealmAvailable() {+            return new Promise(function (resolve, reject) {",Please use `createPromise()` function similarly as in other functions.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,611531289,2021-04-12T11:02:06Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","@tnorimat Now we are binding the token to the authentication request, I would say this check is no longer relevant?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,611536658,2021-04-12T11:10:40Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java,"@@ -0,0 +1,105 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.channel;++import static org.keycloak.OAuth2Constants.SCOPE;+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;++import java.io.IOException;+import java.util.Map;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response.Status;++import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.services.resources.Cors;++public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{++    public static final String AUTHENTICATION_CHANNEL_ID = ""authentication_channel_id"";+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = ""user_info"";+    public static final String AUTHENTICATION_STATUS = ""auth_result"";+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = ""is_consent_required"";++    protected KeycloakSession session;+    protected MultivaluedMap<String, String> formParams;+    protected RealmModel realm;+    protected Map<String, String> clientAuthAttributes;+    protected Cors cors;+    protected final String httpAuthenticationChannelUri;++    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {+        this.session = session;+        this.realm = session.getContext().getRealm();+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;+    }++    @Override+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,+        // which can bind authId with Authentication Channel Result of Authentication by AD.+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.++        // The following scopes should be displayed on AD(Authentication Device):+        // 1. scopes specified explicitly as query parameter in the authorization request+        // 2. scopes specified implicitly as default client scope in keycloak++        checkAuthenticationChannel();++        ClientModel client = request.getClient();++        try {+            // TODO: we should probably just pass the serialized authentication request+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)","@pedroigor  I'm afraid that honest AD may mistakenly authenticate the different user. However, I've reconsider this matter and found that we need not to send back the authenticated user by AD to keycloak because we've already assumed the following conditions when the keycloak user uses CIBA.> AD must make sure the bearer token is secure in transit (TLS) and at rest (if they need to store it).> AD should have a high level of trustTherefore, I would like to remove the corresponding test method in `CIBATest`. WDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7844,611659648,2021-04-12T14:05:40Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/UserSessionConcurrentHashMapStorage.java,"@@ -0,0 +1,79 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.chm;++import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.models.map.userSession.AbstractAuthenticatedClientSessionEntity;+import org.keycloak.models.map.userSession.AbstractUserSessionEntity;+import java.util.Set;+import java.util.stream.Collectors;++/**+ * User session storage with a naive implementation of referential integrity in client to user session relation, restricted to+ * ON DELETE CASCADE functionality.+ *+ * @author hmlnarik+ */+public class UserSessionConcurrentHashMapStorage<K> extends ConcurrentHashMapStorage<K, AbstractUserSessionEntity<K>, UserSessionModel> {",Have you considered using some listener of `UserSessionRemoved` events in `MapUserSessionProviderFactory`? Maybe we can avoid sub-storages like this if we publish events automatically as part of MapKeycloakTransaction methods. WDYT? Is there something I am missing?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,611750240,2021-04-12T15:50:38Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/UserSessionConcurrentHashMapStorage.java,"@@ -0,0 +1,79 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.chm;++import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.models.map.userSession.AbstractAuthenticatedClientSessionEntity;+import org.keycloak.models.map.userSession.AbstractUserSessionEntity;+import java.util.Set;+import java.util.stream.Collectors;++/**+ * User session storage with a naive implementation of referential integrity in client to user session relation, restricted to+ * ON DELETE CASCADE functionality.+ *+ * @author hmlnarik+ */+public class UserSessionConcurrentHashMapStorage<K> extends ConcurrentHashMapStorage<K, AbstractUserSessionEntity<K>, UserSessionModel> {",Yup. The primary aim is to avoid roundtrip to Java and use referential integrity constraints known e.g. from relational databases. Hence the referential integrity implementation here - no high-level Java code intervention is desired here.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,611772528,2021-04-12T16:18:33Z,model/map/src/main/java/org/keycloak/models/map/storage/MapFieldPredicates.java,"@@ -264,6 +298,71 @@ private static String ensureEqSingleValue(SearchableModelField<?> field, String     private static MapModelCriteriaBuilder<Object, AbstractRealmEntity<Object>, RealmModel> checkRealmsWithComponentType(MapModelCriteriaBuilder<Object, AbstractRealmEntity<Object>, RealmModel> mcb, Operator op, Object[] values) {         String providerType = ensureEqSingleValue(RealmModel.SearchableFields.COMPONENT_PROVIDER_TYPE, ""component_provider_type"", op, values);         Function<AbstractRealmEntity<Object>, ?> getter = realmEntity -> realmEntity.getComponents().anyMatch(component -> component.getProviderType().equals(providerType));+        return mcb.fieldCompare(Boolean.TRUE::equals, getter);+    }++    private static MapModelCriteriaBuilder<Object, AbstractUserSessionEntity<Object>, UserSessionModel> checkUserSessionContainsAuthenticatedClientSession(MapModelCriteriaBuilder<Object, AbstractUserSessionEntity<Object>, UserSessionModel> mcb, Operator op, Object[] values) {+        String clientId = ensureEqSingleValue(UserSessionModel.SearchableFields.CLIENT_ID, ""client_id"", op, values);+        Function<AbstractUserSessionEntity<Object>, ?> getter;+        getter = use -> (use.getAuthenticatedClientSessions().containsKey(clientId));++        return mcb.fieldCompare(Boolean.TRUE::equals, getter);+    }++    private static MapModelCriteriaBuilder<Object, AbstractUserSessionEntity<Object>, UserSessionModel> isUserSessionExpired(MapModelCriteriaBuilder<Object, AbstractUserSessionEntity<Object>, UserSessionModel> mcb, Operator op, Object[] values) {+        if (op != Operator.EQ) {+            throw new CriterionNotSupportedException(UserSessionModel.SearchableFields.IS_EXPIRED, op);+        }+        if (values == null || values.length != 5) {+            throw new CriterionNotSupportedException(UserSessionModel.SearchableFields.IS_EXPIRED, op, ""Invalid arguments, expected (expiredRememberMe, expiredRefreshRememberMe, expired, expiredRefresh, expiredOffline), got: "" + Arrays.toString(values));+        }++        int expiredRememberMe = (int) values[0];+        int expiredRefreshRememberMe = (int) values[1];+        int expired = (int) values[2];+        int expiredRefresh = (int) values[3];+        int expiredOffline = (int) values[4];++        Function<AbstractUserSessionEntity<Object>, ?> getter;+        getter = use -> {","Good catch.Yes, and actually rather straightforward. There should be no expiration calculation, user and client session should bear expiration time in the record directly rather than creation / last refresh time which is then calculated for expiry. Then none of the parameters will be needed; but this is for a follow-up PR.The broader context is that this way of dealing with expiration which stems from the current way of dealing with session expiry fails to clean sessions if there is a client-specific expiration anyways.Hence in the future, there is a need to fix this behaviour, and thanks to your comment I finally filed a JIRA for that: https://issues.redhat.com/browse/KEYCLOAK-17737",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7844,612196179,2021-04-13T07:27:40Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/UserSessionConcurrentHashMapStorage.java,"@@ -0,0 +1,79 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.chm;++import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;+import org.keycloak.models.map.userSession.AbstractAuthenticatedClientSessionEntity;+import org.keycloak.models.map.userSession.AbstractUserSessionEntity;+import java.util.Set;+import java.util.stream.Collectors;++/**+ * User session storage with a naive implementation of referential integrity in client to user session relation, restricted to+ * ON DELETE CASCADE functionality.+ *+ * @author hmlnarik+ */+public class UserSessionConcurrentHashMapStorage<K> extends ConcurrentHashMapStorage<K, AbstractUserSessionEntity<K>, UserSessionModel> {","I see. However, I still can't see the advantage of this approach. Will there be any roundtrip to Java if there is no listener registered in MapJpaUserSessionFactory? The advantage of using events is, that it is easily extendible for other storages, when they want to react upon RemovedUserSession event.Also, there will be some refactoring of events that are currently published from providers. We plan to publish them from underlying storage, if I remember correctly. Does it mean it will be published from MapKeycloakTransaction? If yes how we will decide when to publish event and when not to? I am asking because if we will be publishing events for each storage in the future, we may end up with what I described in the first comment anyway.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7887,612361386,2021-04-13T11:29:26Z,server-spi-private/src/main/java/org/keycloak/validate/ValidatorConfig.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate;++import java.util.Collections;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.regex.Pattern;++/**+ * A typed wrapper around a {@link Map} based {@link Validator} configuration.+ */+public class ValidatorConfig {++    /**+     * An empty {@link ValidatorConfig}.+     */+    public static final ValidatorConfig EMPTY = new ValidatorConfig(Collections.emptyMap());++    /**+     * Holds the backing map for the {@link Validator} config.+     */+    private final Map<String, Object> config;++    /**+     * Creates a new {@link ValidatorConfig} from the given {@code map}.+     *+     * @param config+     */+    public ValidatorConfig(Map<String, Object> config) {+        this.config = config;+    }++    /**+     * Static helper to create a {@link ValidatorConfig} from the given {@code map}.+     *+     * @param map+     * @return+     */+    public static ValidatorConfig configFromMap(Map<String, Object> map) {+        if (map == null || map.isEmpty()) {+            return EMPTY;+        }+        return new ValidatorConfig(map);+    }++    public boolean containsKey(String key) {+        return config.containsKey(key);+    }++    public int size() {+        return config.size();+    }++    public boolean isEmpty() {+        return config.isEmpty();+    }++    public Object get(String key) {+        return config.get(key);+    }++    public Object getOrDefault(String key, Object defaultValue) {+        return config.getOrDefault(key, defaultValue);+    }++    public String getString(String key) {+        return getStringOrDefault(key, null);+    }++    public String getStringOrDefault(String key, String defaultValue) {+        Object value = config.get(key);+        if (value instanceof String) {+            return (String) value;+        }+        return defaultValue;+    }++    public Integer getIntOrDefault(String key) {+        return getIntOrDefault(key, null);+    }++    public Integer getIntOrDefault(String key, Integer defaultValue) {+        Object value = config.get(key);+        if (value instanceof Integer) {+            return (Integer) value;+        } else if (value instanceof Number) {+            return ((Number) value).intValue();+        } else if (value instanceof String) {+            return Integer.parseInt((String) value);+        }+        return defaultValue;+    }++    public Double getDoubleOrDefault(String key) {+        return getDoubleOrDefault(key, null);+    }++    public Double getDoubleOrDefault(String key, Double defaultValue) {+        Object value = config.get(key);+        if (value instanceof Double) {+            return (Double) value;+        } else if (value instanceof Number) {+            return ((Number) value).doubleValue();+        } else if (value instanceof String) {+            return Double.parseDouble((String) value);+        }+        return defaultValue;+    }++    public Boolean getBooleanOrDefault(String key) {+        return getBooleanOrDefault(key, null);+    }++    public Boolean getBooleanOrDefault(String key, Boolean defaultValue) {+        Object value = config.get(key);+        if (value instanceof Boolean) {+            return (Boolean) value;+        } else if (value instanceof String) {+            return Boolean.parseBoolean((String) value);+        }+        return defaultValue;+    }++    public Set<String> getStringSetOrDefault(String key) {+        return getStringSetOrDefault(key, null);+    }++    public Set<String> getStringSetOrDefault(String key, Set<String> defaultValue) {+        Object value = config.get(key);+        if (value instanceof Set) {+            return (Set<String>) value;+        }+        return defaultValue;+    }++    public List<String> getStringListOrDefault(String key) {+        return getStringListOrDefault(key, null);+    }++    public List<String> getStringListOrDefault(String key, List<String> defaultValue) {+        Object value = config.get(key);+        if (value instanceof List) {+            return (List<String>) value;+        }+        return defaultValue;+    }++    public Pattern getPattern(String key) {+        return getPatternOrDefault(key, null);+    }++    public Pattern getPatternOrDefault(String key, Pattern defaultValue) {+        Object value = config.get(key);+        if (value instanceof Pattern) {+            return (Pattern) value;+        } else if (value instanceof String) {+            return Pattern.compile((String) value);","IMO, this should be discouraged so that you always have a pre-compiled pattern.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,612579278,2021-04-13T15:59:41Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -610,7 +537,7 @@ public void onRealmRemoved(RealmModel realm) {     protected void onRealmRemovedEvent(String realmId) {         removeLocalUserSessions(realmId, true);         removeLocalUserSessions(realmId, false);-        removeAllLocalUserLoginFailuresEvent(realmId);+        session.loginFailures().removeAllUserLoginFailures(realmId);","Is this preserving the semantics? Seems that originally only *local* login failures were removed and now *all* login failures are removed. Is this intentional?Also, should this be called from *user session* provider?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,612588742,2021-04-13T16:11:17Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProviderFactory.java,"@@ -0,0 +1,66 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.UserSessionProviderFactory;+import org.keycloak.models.map.common.AbstractMapProviderFactory;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;++import java.util.UUID;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProviderFactory extends AbstractMapProviderFactory<UserSessionProvider>+        implements UserSessionProviderFactory {++    private MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;++    @Override+    public void postInit(KeycloakSessionFactory factory) {+        MapStorageProvider sp = (MapStorageProvider) factory.getProviderFactory(MapStorageProvider.class);+        userSessionStore = sp.getStorage(""userSessions"", UUID.class, MapUserSessionEntity.class, UserSessionModel.class);+        clientSessionStore = sp.getStorage(""clientSessions"", UUID.class, MapAuthenticatedClientSessionEntity.class, AuthenticatedClientSessionModel.class);++        factory.register(event -> {+            if (event instanceof UserModel.UserRemovedEvent) {+                UserModel.UserRemovedEvent userRemovedEvent = (UserModel.UserRemovedEvent) event;++                MapUserSessionProvider provider = (MapUserSessionProvider) userRemovedEvent.getKeycloakSession().getProvider(UserSessionProvider.class, getId());",Should this be ```suggestion                MapUserSessionProvider provider = MapUserSessionProviderFactory.this.create(userRemovedEvent.getKeycloakSession());```or similar?,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7887,612598272,2021-04-13T16:24:02Z,server-spi-private/src/main/java/org/keycloak/validate/ValidationResult.java,"@@ -0,0 +1,149 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate;++import java.util.Collections;+import java.util.Set;+import java.util.function.Consumer;+import java.util.stream.Collectors;++/**+ * Denotes the result of a validation.+ */+public class ValidationResult implements Consumer<Consumer<ValidationResult>> {",The rational was to make it easier to use `ValidationResult` in fluent API call chains. I just updated `ValidationResult` to no longer inherit from `Consumer<Consumer<ValidationResult>>`.,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7887,612603010,2021-04-13T16:30:18Z,server-spi-private/src/main/java/org/keycloak/validate/ValidatorConfig.java,"@@ -0,0 +1,184 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.validate;++import java.util.Collections;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.regex.Pattern;++/**+ * A typed wrapper around a {@link Map} based {@link Validator} configuration.+ */+public class ValidatorConfig {++    /**+     * An empty {@link ValidatorConfig}.+     */+    public static final ValidatorConfig EMPTY = new ValidatorConfig(Collections.emptyMap());++    /**+     * Holds the backing map for the {@link Validator} config.+     */+    private final Map<String, Object> config;++    /**+     * Creates a new {@link ValidatorConfig} from the given {@code map}.+     *+     * @param config+     */+    public ValidatorConfig(Map<String, Object> config) {+        this.config = config;+    }++    /**+     * Static helper to create a {@link ValidatorConfig} from the given {@code map}.+     *+     * @param map+     * @return+     */+    public static ValidatorConfig configFromMap(Map<String, Object> map) {+        if (map == null || map.isEmpty()) {+            return EMPTY;+        }+        return new ValidatorConfig(map);+    }++    public boolean containsKey(String key) {+        return config.containsKey(key);+    }++    public int size() {+        return config.size();+    }++    public boolean isEmpty() {+        return config.isEmpty();+    }++    public Object get(String key) {+        return config.get(key);+    }++    public Object getOrDefault(String key, Object defaultValue) {+        return config.getOrDefault(key, defaultValue);+    }++    public String getString(String key) {+        return getStringOrDefault(key, null);+    }++    public String getStringOrDefault(String key, String defaultValue) {+        Object value = config.get(key);+        if (value instanceof String) {+            return (String) value;+        }+        return defaultValue;+    }++    public Integer getIntOrDefault(String key) {+        return getIntOrDefault(key, null);+    }++    public Integer getIntOrDefault(String key, Integer defaultValue) {+        Object value = config.get(key);+        if (value instanceof Integer) {+            return (Integer) value;+        } else if (value instanceof Number) {+            return ((Number) value).intValue();+        } else if (value instanceof String) {+            return Integer.parseInt((String) value);+        }+        return defaultValue;+    }++    public Double getDoubleOrDefault(String key) {+        return getDoubleOrDefault(key, null);+    }++    public Double getDoubleOrDefault(String key, Double defaultValue) {+        Object value = config.get(key);+        if (value instanceof Double) {+            return (Double) value;+        } else if (value instanceof Number) {+            return ((Number) value).doubleValue();+        } else if (value instanceof String) {+            return Double.parseDouble((String) value);+        }+        return defaultValue;+    }++    public Boolean getBooleanOrDefault(String key) {+        return getBooleanOrDefault(key, null);+    }++    public Boolean getBooleanOrDefault(String key, Boolean defaultValue) {+        Object value = config.get(key);+        if (value instanceof Boolean) {+            return (Boolean) value;+        } else if (value instanceof String) {+            return Boolean.parseBoolean((String) value);+        }+        return defaultValue;+    }++    public Set<String> getStringSetOrDefault(String key) {+        return getStringSetOrDefault(key, null);+    }++    public Set<String> getStringSetOrDefault(String key, Set<String> defaultValue) {+        Object value = config.get(key);+        if (value instanceof Set) {+            return (Set<String>) value;+        }+        return defaultValue;+    }++    public List<String> getStringListOrDefault(String key) {+        return getStringListOrDefault(key, null);+    }++    public List<String> getStringListOrDefault(String key, List<String> defaultValue) {+        Object value = config.get(key);+        if (value instanceof List) {+            return (List<String>) value;+        }+        return defaultValue;+    }++    public Pattern getPattern(String key) {+        return getPatternOrDefault(key, null);+    }++    public Pattern getPatternOrDefault(String key, Pattern defaultValue) {+        Object value = config.get(key);+        if (value instanceof Pattern) {+            return (Pattern) value;+        } else if (value instanceof String) {+            return Pattern.compile((String) value);","I agree, that a pre-compiled pattern is preferred here. The rational for the string based pattern here is the support for profile validation config from a JSON string.But, of course we could also compile the pattern during the conversion of the json based profile validation config into a `ValidatorConfig`.I'll remove the support for a string based pattern.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,613036583,2021-04-14T08:17:44Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -610,7 +537,7 @@ public void onRealmRemoved(RealmModel realm) {     protected void onRealmRemovedEvent(String realmId) {         removeLocalUserSessions(realmId, true);         removeLocalUserSessions(realmId, false);-        removeAllLocalUserLoginFailuresEvent(realmId);+        session.loginFailures().removeAllUserLoginFailures(realmId);",`removeAllUserLoginFailures(String)` was just wrapper method introduced in the `UserLoginFailureProvider` interface which called `removeAllLocalUserLoginFailuresEvent`. Sorry for confusion. Anyway I was able to get rid of this method by calling the `removeAllLocalUserLoginFailuresEvent` from the event listener in `UserLoginFailureProviderFactory`.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,613036678,2021-04-14T08:17:50Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -633,7 +560,7 @@ protected void onUserRemoved(RealmModel realm, UserModel user) {         removeUserSessions(realm, user, true);         removeUserSessions(realm, user, false); -        removeUserLoginFailure(realm, user.getId());+        session.loginFailures().removeUserLoginFailure(realm, user.getId());",Same here. I was able to remove this method call by calling it the corresponding listener in the `UserLoginFailureProviderFactory`.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,613037048,2021-04-14T08:18:23Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java,"@@ -0,0 +1,657 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.utils.SessionTimeoutHelper;++import java.util.Collection;+import java.util.Comparator;+import java.util.HashMap;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;+import java.util.UUID;+import java.util.concurrent.ConcurrentHashMap;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import static org.keycloak.models.UserSessionModel.CORRESPONDING_SESSION_ID;+import static org.keycloak.models.UserSessionModel.SessionPersistenceState.TRANSIENT;+import static org.keycloak.utils.StreamsUtil.paginatedStream;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProvider implements UserSessionProvider {++    private static final Logger LOG = Logger.getLogger(MapUserSessionProvider.class);+    private final KeycloakSession session;+    protected final MapKeycloakTransaction<UUID, MapUserSessionEntity, UserSessionModel> userSessionTx;+    protected final MapKeycloakTransaction<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionTx;+    private final MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private final MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;++    /**+     * Storage for transient user sessions which lifespan is limited to one request.+     */+    private final Map<UUID, MapUserSessionEntity> transientUserSessions = new HashMap<>();++    public MapUserSessionProvider(KeycloakSession session, MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore,+                                  MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore) {+        this.session = session;+        this.userSessionStore = userSessionStore;+        this.clientSessionStore = clientSessionStore;+        userSessionTx = userSessionStore.createTransaction(session);+        clientSessionTx = clientSessionStore.createTransaction(session);++        session.getTransactionManager().enlistAfterCompletion(userSessionTx);+        session.getTransactionManager().enlistAfterCompletion(clientSessionTx);+    }++    private Function<MapUserSessionEntity, UserSessionModel> userEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return (origEntity) -> new MapUserSessionAdapter(session, realm,+                Objects.equals(origEntity.getPersistenceState(), TRANSIENT) ? origEntity : registerEntityForChanges(origEntity)) {++            @Override+            public void removeAuthenticatedClientSessions(Collection<String> removedClientUUIDS) {+                removedClientUUIDS.forEach(clientId -> {+                    clientSessionTx.delete(UUID.fromString(clientId));+                    entity.removeAuthenticatedClientSession(clientId);+                });+            }+        };+    }++    private Function<MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientEntityToAdapterFunc(RealmModel realm,+                                                                                                                     ClientModel client,+                                                                                                                     UserSessionModel userSession) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapAuthenticatedClientSessionAdapter(session, realm, client, userSession, registerEntityForChanges(origEntity)) {+            @Override+            public void detachFromUserSession() {+                this.userSession = null;++                clientSessionTx.delete(entity.getId());+            }+        };+    }++    private MapUserSessionEntity registerEntityForChanges(MapUserSessionEntity origEntity) {+        MapUserSessionEntity res = userSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userSessionTx.updateIfChanged(origEntity.getId(), res, MapUserSessionEntity::isUpdated);+        return res;+    }++    private MapAuthenticatedClientSessionEntity registerEntityForChanges(MapAuthenticatedClientSessionEntity origEntity) {+        MapAuthenticatedClientSessionEntity res = clientSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        clientSessionTx.updateIfChanged(origEntity.getId(), res, MapAuthenticatedClientSessionEntity::isUpdated);+        return res;+    }++    @Override+    public KeycloakSession getKeycloakSession() {+        return session;+    }++    @Override+    public AuthenticatedClientSessionModel createClientSession(RealmModel realm, ClientModel client, UserSessionModel userSession) {+        MapAuthenticatedClientSessionEntity entity =+                new MapAuthenticatedClientSessionEntity(UUID.randomUUID(), userSession.getId(), realm.getId(), client.getId(), false);++        LOG.tracef(""createClientSession(%s, %s, %s)%s"", realm, client, userSession, getShortStackTrace());++        clientSessionTx.create(entity.getId(), entity);++        MapUserSessionEntity userSessionEntity = getUserSessionById(UUID.fromString(userSession.getId()));++        if (userSessionEntity == null) {+            throw new IllegalStateException(""User session entity does not exist: "" + userSession.getId());+        }++        userSessionEntity.addAuthenticatedClientSession(client.getId(), entity.getId());++        return clientEntityToAdapterFunc(realm, client, userSession).apply(entity);+    }++    @Override+    public AuthenticatedClientSessionModel getClientSession(UserSessionModel userSession, ClientModel client,+                                                            UUID clientSessionId, boolean offline) {+        LOG.tracef(""getClientSession(%s, %s, %s, %s)%s"", userSession, client,+                clientSessionId, offline, getShortStackTrace());++        Objects.requireNonNull(userSession, ""The provided user session cannot be null!"");+        Objects.requireNonNull(client, ""The provided client cannot be null!"");+        if (clientSessionId == null) {+            return null;+        }++        ModelCriteriaBuilder<AuthenticatedClientSessionModel> mcb = clientSessionStore.createCriteriaBuilder()+                .compare(AuthenticatedClientSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, clientSessionId)+                .compare(AuthenticatedClientSessionModel.SearchableFields.USER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, userSession.getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, userSession.getRealm().getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.IS_OFFLINE, ModelCriteriaBuilder.Operator.EQ, offline);++        return clientSessionTx.getUpdatedNotRemoved(mcb)+                .findFirst()+                .map(clientEntityToAdapterFunc(client.getRealm(), client, userSession))+                .orElse(null);+    }++    @Override+    public UserSessionModel createUserSession(RealmModel realm, UserModel user, String loginUsername, String ipAddress,+                                              String authMethod, boolean rememberMe, String brokerSessionId, String brokerUserId) {+        return createUserSession(null, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId,+                brokerUserId, UserSessionModel.SessionPersistenceState.PERSISTENT);+    }++    @Override+    public UserSessionModel createUserSession(String id, RealmModel realm, UserModel user, String loginUsername,+                                              String ipAddress, String authMethod, boolean rememberMe, String brokerSessionId,+                                              String brokerUserId, UserSessionModel.SessionPersistenceState persistenceState) {+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""createUserSession(%s, %s, %s, %s)%s"", id, realm, loginUsername, persistenceState, getShortStackTrace());++        MapUserSessionEntity entity = new MapUserSessionEntity(entityId, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId, brokerUserId, false);+        entity.setPersistenceState(persistenceState);++        if (Objects.equals(persistenceState, TRANSIENT)) {+            transientUserSessions.put(entityId, entity);+        } else {+            if (userSessionTx.read(entity.getId()) != null) {+                throw new ModelDuplicateException(""User session exists: "" + entity.getId());+            }++            userSessionTx.create(entity.getId(), entity);+        }++        UserSessionModel userSession = userEntityToAdapterFunc(realm).apply(entity);++        DeviceActivityManager.attachDevice(userSession, session);++        return userSession;+    }++    @Override+    public UserSessionModel getUserSession(RealmModel realm, String id) {+        Objects.requireNonNull(realm, ""The provided realm can't be null!"");++        LOG.tracef(""getUserSession(%s, %s)%s"", realm, id, getShortStackTrace());++        UUID uuid = toUUID(id);+        if (uuid == null) {+            return null;+        }++        MapUserSessionEntity userSessionEntity = transientUserSessions.get(uuid);+        if (userSessionEntity != null) {+            return userEntityToAdapterFunc(realm).apply(userSessionEntity);+        }++        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, uuid);++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .findFirst()+                .map(userEntityToAdapterFunc(realm))+                .orElse(null);+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""getUserSessionsStream(%s, %s)%s"", realm, user, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getUserSessionsStream(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, ClientModel client,+                                                          Integer firstResult, Integer maxResults) {+        return paginatedStream(getUserSessionsStream(realm, client)+                .sorted(Comparator.comparing(UserSessionModel::getLastSessionRefresh)), firstResult, maxResults);+    }++    @Override+    public Stream<UserSessionModel> getUserSessionByBrokerUserIdStream(RealmModel realm, String brokerUserId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.BROKER_USER_ID, ModelCriteriaBuilder.Operator.EQ, brokerUserId);++        LOG.tracef(""getUserSessionByBrokerUserIdStream(%s, %s)%s"", realm, brokerUserId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public UserSessionModel getUserSessionByBrokerSessionId(RealmModel realm, String brokerSessionId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.BROKER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, brokerSessionId);++        LOG.tracef(""getUserSessionByBrokerSessionId(%s, %s)%s"", realm, brokerSessionId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .findFirst()+                .map(userEntityToAdapterFunc(realm))+                .orElse(null);+    }++    @Override+    public UserSessionModel getUserSessionWithPredicate(RealmModel realm, String id, boolean offline,+                                                        Predicate<UserSessionModel> predicate) {+        LOG.tracef(""getUserSessionWithPredicate(%s, %s, %s)%s"", realm, id, offline, getShortStackTrace());++        Stream<UserSessionModel> userSessionEntityStream;+        if (offline) {+            userSessionEntityStream = getOfflineUserSessionEntityStream(realm, id)+                    .map(userEntityToAdapterFunc(realm));+        } else {+            UserSessionModel userSession = getUserSession(realm, id);+            userSessionEntityStream = userSession != null ? Stream.of(userSession) : Stream.empty();+        }++        return userSessionEntityStream+                .filter(predicate)+                .findFirst()+                .orElse(null);+    }++    @Override+    public long getActiveUserSessions(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getActiveUserSessions(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getCount(mcb);+    }++    @Override+    public Map<String, Long> getActiveClientSessionStats(RealmModel realm, boolean offline) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, offline);++        LOG.tracef(""getActiveClientSessionStats(%s, %s)%s"", realm, offline, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm))+                .map(UserSessionModel::getAuthenticatedClientSessions)+                .map(Map::keySet)+                .flatMap(Collection::stream)+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));+    }++    @Override+    public void removeUserSession(RealmModel realm, UserSessionModel session) {+        Objects.requireNonNull(session, ""The provided user session can't be null!"");++        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, UUID.fromString(session.getId()));++        LOG.tracef(""removeUserSession(%s, %s)%s"", realm, session, getShortStackTrace());++        userSessionTx.delete(UUID.randomUUID(), mcb);+    }++    @Override+    public void removeUserSessions(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = userSessionStore.createCriteriaBuilder()+                .compare(UserSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""removeUserSessions(%s, %s)%s"", realm, user, getShortStackTrace());++        userSessionTx.delete(UUID.randomUUID(), mcb);+    }++    @Override+    public void removeAllExpired() {+        session.realms().getRealmsStream().forEach(this::removeExpired);+    }++    @Override+    public void removeExpired(RealmModel realm) {+        int currentTime = Time.currentTime();+        int expired = currentTime - realm.getSsoSessionMaxLifespan();+        int expiredRefresh = currentTime - realm.getSsoSessionIdleTimeout() - SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;+        int expiredRememberMe = currentTime - (realm.getSsoSessionMaxLifespanRememberMe() > 0 ?+                realm.getSsoSessionMaxLifespanRememberMe() : realm.getSsoSessionMaxLifespan());+        int expiredRefreshRememberMe = currentTime - (realm.getSsoSessionIdleTimeoutRememberMe() > 0 ?+                realm.getSsoSessionIdleTimeoutRememberMe() : realm.getSsoSessionIdleTimeout()) -+                SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;+        int expiredOffline = currentTime - realm.getOfflineSessionIdleTimeout() - SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;++        // remove expired user sessions and its client sessions+        ModelCriteriaBuilder<UserSessionModel> userSessionMcb = userSessionStore.createCriteriaBuilder()+                .compare(UserSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserSessionModel.SearchableFields.IS_EXPIRED, ModelCriteriaBuilder.Operator.EQ,+                        expiredRememberMe, expiredRefreshRememberMe, expired, expiredRefresh, expiredOffline);++        userSessionTx.delete(UUID.randomUUID(), userSessionMcb);+    }++    @Override+    public void removeUserSessions(RealmModel realm) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false);++        LOG.tracef(""removeUserSessions(%s)%s"", realm, getShortStackTrace());++        userSessionTx.delete(UUID.randomUUID(), mcb);+    }++    @Override+    public void onRealmRemoved(RealmModel realm) {+        removeUserSessions(realm);+        session.loginFailures().removeAllUserLoginFailures(realm);",Moved to the equivalent event listener in the `MapUserLoginFailureProviderFactory`.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,613037171,2021-04-14T08:18:33Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java,"@@ -0,0 +1,657 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.utils.SessionTimeoutHelper;++import java.util.Collection;+import java.util.Comparator;+import java.util.HashMap;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;+import java.util.UUID;+import java.util.concurrent.ConcurrentHashMap;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import static org.keycloak.models.UserSessionModel.CORRESPONDING_SESSION_ID;+import static org.keycloak.models.UserSessionModel.SessionPersistenceState.TRANSIENT;+import static org.keycloak.utils.StreamsUtil.paginatedStream;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProvider implements UserSessionProvider {++    private static final Logger LOG = Logger.getLogger(MapUserSessionProvider.class);+    private final KeycloakSession session;+    protected final MapKeycloakTransaction<UUID, MapUserSessionEntity, UserSessionModel> userSessionTx;+    protected final MapKeycloakTransaction<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionTx;+    private final MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private final MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;++    /**+     * Storage for transient user sessions which lifespan is limited to one request.+     */+    private final Map<UUID, MapUserSessionEntity> transientUserSessions = new HashMap<>();++    public MapUserSessionProvider(KeycloakSession session, MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore,+                                  MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore) {+        this.session = session;+        this.userSessionStore = userSessionStore;+        this.clientSessionStore = clientSessionStore;+        userSessionTx = userSessionStore.createTransaction(session);+        clientSessionTx = clientSessionStore.createTransaction(session);++        session.getTransactionManager().enlistAfterCompletion(userSessionTx);+        session.getTransactionManager().enlistAfterCompletion(clientSessionTx);+    }++    private Function<MapUserSessionEntity, UserSessionModel> userEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return (origEntity) -> new MapUserSessionAdapter(session, realm,+                Objects.equals(origEntity.getPersistenceState(), TRANSIENT) ? origEntity : registerEntityForChanges(origEntity)) {++            @Override+            public void removeAuthenticatedClientSessions(Collection<String> removedClientUUIDS) {+                removedClientUUIDS.forEach(clientId -> {+                    clientSessionTx.delete(UUID.fromString(clientId));+                    entity.removeAuthenticatedClientSession(clientId);+                });+            }+        };+    }++    private Function<MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientEntityToAdapterFunc(RealmModel realm,+                                                                                                                     ClientModel client,+                                                                                                                     UserSessionModel userSession) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return origEntity -> new MapAuthenticatedClientSessionAdapter(session, realm, client, userSession, registerEntityForChanges(origEntity)) {+            @Override+            public void detachFromUserSession() {+                this.userSession = null;++                clientSessionTx.delete(entity.getId());+            }+        };+    }++    private MapUserSessionEntity registerEntityForChanges(MapUserSessionEntity origEntity) {+        MapUserSessionEntity res = userSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        userSessionTx.updateIfChanged(origEntity.getId(), res, MapUserSessionEntity::isUpdated);+        return res;+    }++    private MapAuthenticatedClientSessionEntity registerEntityForChanges(MapAuthenticatedClientSessionEntity origEntity) {+        MapAuthenticatedClientSessionEntity res = clientSessionTx.read(origEntity.getId(), id -> Serialization.from(origEntity));+        clientSessionTx.updateIfChanged(origEntity.getId(), res, MapAuthenticatedClientSessionEntity::isUpdated);+        return res;+    }++    @Override+    public KeycloakSession getKeycloakSession() {+        return session;+    }++    @Override+    public AuthenticatedClientSessionModel createClientSession(RealmModel realm, ClientModel client, UserSessionModel userSession) {+        MapAuthenticatedClientSessionEntity entity =+                new MapAuthenticatedClientSessionEntity(UUID.randomUUID(), userSession.getId(), realm.getId(), client.getId(), false);++        LOG.tracef(""createClientSession(%s, %s, %s)%s"", realm, client, userSession, getShortStackTrace());++        clientSessionTx.create(entity.getId(), entity);++        MapUserSessionEntity userSessionEntity = getUserSessionById(UUID.fromString(userSession.getId()));++        if (userSessionEntity == null) {+            throw new IllegalStateException(""User session entity does not exist: "" + userSession.getId());+        }++        userSessionEntity.addAuthenticatedClientSession(client.getId(), entity.getId());++        return clientEntityToAdapterFunc(realm, client, userSession).apply(entity);+    }++    @Override+    public AuthenticatedClientSessionModel getClientSession(UserSessionModel userSession, ClientModel client,+                                                            UUID clientSessionId, boolean offline) {+        LOG.tracef(""getClientSession(%s, %s, %s, %s)%s"", userSession, client,+                clientSessionId, offline, getShortStackTrace());++        Objects.requireNonNull(userSession, ""The provided user session cannot be null!"");+        Objects.requireNonNull(client, ""The provided client cannot be null!"");+        if (clientSessionId == null) {+            return null;+        }++        ModelCriteriaBuilder<AuthenticatedClientSessionModel> mcb = clientSessionStore.createCriteriaBuilder()+                .compare(AuthenticatedClientSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, clientSessionId)+                .compare(AuthenticatedClientSessionModel.SearchableFields.USER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, userSession.getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, userSession.getRealm().getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId())+                .compare(AuthenticatedClientSessionModel.SearchableFields.IS_OFFLINE, ModelCriteriaBuilder.Operator.EQ, offline);++        return clientSessionTx.getUpdatedNotRemoved(mcb)+                .findFirst()+                .map(clientEntityToAdapterFunc(client.getRealm(), client, userSession))+                .orElse(null);+    }++    @Override+    public UserSessionModel createUserSession(RealmModel realm, UserModel user, String loginUsername, String ipAddress,+                                              String authMethod, boolean rememberMe, String brokerSessionId, String brokerUserId) {+        return createUserSession(null, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId,+                brokerUserId, UserSessionModel.SessionPersistenceState.PERSISTENT);+    }++    @Override+    public UserSessionModel createUserSession(String id, RealmModel realm, UserModel user, String loginUsername,+                                              String ipAddress, String authMethod, boolean rememberMe, String brokerSessionId,+                                              String brokerUserId, UserSessionModel.SessionPersistenceState persistenceState) {+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);++        LOG.tracef(""createUserSession(%s, %s, %s, %s)%s"", id, realm, loginUsername, persistenceState, getShortStackTrace());++        MapUserSessionEntity entity = new MapUserSessionEntity(entityId, realm, user, loginUsername, ipAddress, authMethod, rememberMe, brokerSessionId, brokerUserId, false);+        entity.setPersistenceState(persistenceState);++        if (Objects.equals(persistenceState, TRANSIENT)) {+            transientUserSessions.put(entityId, entity);+        } else {+            if (userSessionTx.read(entity.getId()) != null) {+                throw new ModelDuplicateException(""User session exists: "" + entity.getId());+            }++            userSessionTx.create(entity.getId(), entity);+        }++        UserSessionModel userSession = userEntityToAdapterFunc(realm).apply(entity);++        DeviceActivityManager.attachDevice(userSession, session);++        return userSession;+    }++    @Override+    public UserSessionModel getUserSession(RealmModel realm, String id) {+        Objects.requireNonNull(realm, ""The provided realm can't be null!"");++        LOG.tracef(""getUserSession(%s, %s)%s"", realm, id, getShortStackTrace());++        UUID uuid = toUUID(id);+        if (uuid == null) {+            return null;+        }++        MapUserSessionEntity userSessionEntity = transientUserSessions.get(uuid);+        if (userSessionEntity != null) {+            return userEntityToAdapterFunc(realm).apply(userSessionEntity);+        }++        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, uuid);++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .findFirst()+                .map(userEntityToAdapterFunc(realm))+                .orElse(null);+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""getUserSessionsStream(%s, %s)%s"", realm, user, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getUserSessionsStream(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, ClientModel client,+                                                          Integer firstResult, Integer maxResults) {+        return paginatedStream(getUserSessionsStream(realm, client)+                .sorted(Comparator.comparing(UserSessionModel::getLastSessionRefresh)), firstResult, maxResults);+    }++    @Override+    public Stream<UserSessionModel> getUserSessionByBrokerUserIdStream(RealmModel realm, String brokerUserId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.BROKER_USER_ID, ModelCriteriaBuilder.Operator.EQ, brokerUserId);++        LOG.tracef(""getUserSessionByBrokerUserIdStream(%s, %s)%s"", realm, brokerUserId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm));+    }++    @Override+    public UserSessionModel getUserSessionByBrokerSessionId(RealmModel realm, String brokerSessionId) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.BROKER_SESSION_ID, ModelCriteriaBuilder.Operator.EQ, brokerSessionId);++        LOG.tracef(""getUserSessionByBrokerSessionId(%s, %s)%s"", realm, brokerSessionId, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .findFirst()+                .map(userEntityToAdapterFunc(realm))+                .orElse(null);+    }++    @Override+    public UserSessionModel getUserSessionWithPredicate(RealmModel realm, String id, boolean offline,+                                                        Predicate<UserSessionModel> predicate) {+        LOG.tracef(""getUserSessionWithPredicate(%s, %s, %s)%s"", realm, id, offline, getShortStackTrace());++        Stream<UserSessionModel> userSessionEntityStream;+        if (offline) {+            userSessionEntityStream = getOfflineUserSessionEntityStream(realm, id)+                    .map(userEntityToAdapterFunc(realm));+        } else {+            UserSessionModel userSession = getUserSession(realm, id);+            userSessionEntityStream = userSession != null ? Stream.of(userSession) : Stream.empty();+        }++        return userSessionEntityStream+                .filter(predicate)+                .findFirst()+                .orElse(null);+    }++    @Override+    public long getActiveUserSessions(RealmModel realm, ClientModel client) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.CLIENT_ID, ModelCriteriaBuilder.Operator.EQ, client.getId());++        LOG.tracef(""getActiveUserSessions(%s, %s)%s"", realm, client, getShortStackTrace());++        return userSessionTx.getCount(mcb);+    }++    @Override+    public Map<String, Long> getActiveClientSessionStats(RealmModel realm, boolean offline) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, offline);++        LOG.tracef(""getActiveClientSessionStats(%s, %s)%s"", realm, offline, getShortStackTrace());++        return userSessionTx.getUpdatedNotRemoved(mcb)+                .map(userEntityToAdapterFunc(realm))+                .map(UserSessionModel::getAuthenticatedClientSessions)+                .map(Map::keySet)+                .flatMap(Collection::stream)+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));+    }++    @Override+    public void removeUserSession(RealmModel realm, UserSessionModel session) {+        Objects.requireNonNull(session, ""The provided user session can't be null!"");++        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false)+                .compare(UserSessionModel.SearchableFields.ID, ModelCriteriaBuilder.Operator.EQ, UUID.fromString(session.getId()));++        LOG.tracef(""removeUserSession(%s, %s)%s"", realm, session, getShortStackTrace());++        userSessionTx.delete(UUID.randomUUID(), mcb);+    }++    @Override+    public void removeUserSessions(RealmModel realm, UserModel user) {+        ModelCriteriaBuilder<UserSessionModel> mcb = userSessionStore.createCriteriaBuilder()+                .compare(UserSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserSessionModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, user.getId());++        LOG.tracef(""removeUserSessions(%s, %s)%s"", realm, user, getShortStackTrace());++        userSessionTx.delete(UUID.randomUUID(), mcb);+    }++    @Override+    public void removeAllExpired() {+        session.realms().getRealmsStream().forEach(this::removeExpired);+    }++    @Override+    public void removeExpired(RealmModel realm) {+        int currentTime = Time.currentTime();+        int expired = currentTime - realm.getSsoSessionMaxLifespan();+        int expiredRefresh = currentTime - realm.getSsoSessionIdleTimeout() - SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;+        int expiredRememberMe = currentTime - (realm.getSsoSessionMaxLifespanRememberMe() > 0 ?+                realm.getSsoSessionMaxLifespanRememberMe() : realm.getSsoSessionMaxLifespan());+        int expiredRefreshRememberMe = currentTime - (realm.getSsoSessionIdleTimeoutRememberMe() > 0 ?+                realm.getSsoSessionIdleTimeoutRememberMe() : realm.getSsoSessionIdleTimeout()) -+                SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;+        int expiredOffline = currentTime - realm.getOfflineSessionIdleTimeout() - SessionTimeoutHelper.PERIODIC_CLEANER_IDLE_TIMEOUT_WINDOW_SECONDS;++        // remove expired user sessions and its client sessions+        ModelCriteriaBuilder<UserSessionModel> userSessionMcb = userSessionStore.createCriteriaBuilder()+                .compare(UserSessionModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())+                .compare(UserSessionModel.SearchableFields.IS_EXPIRED, ModelCriteriaBuilder.Operator.EQ,+                        expiredRememberMe, expiredRefreshRememberMe, expired, expiredRefresh, expiredOffline);++        userSessionTx.delete(UUID.randomUUID(), userSessionMcb);+    }++    @Override+    public void removeUserSessions(RealmModel realm) {+        ModelCriteriaBuilder<UserSessionModel> mcb = realmAndOfflineCriteriaBuilder(realm, false);++        LOG.tracef(""removeUserSessions(%s)%s"", realm, getShortStackTrace());++        userSessionTx.delete(UUID.randomUUID(), mcb);+    }++    @Override+    public void onRealmRemoved(RealmModel realm) {+        removeUserSessions(realm);+        session.loginFailures().removeAllUserLoginFailures(realm);+    }++    @Override+    public void onClientRemoved(RealmModel realm, ClientModel client) {++    }++    protected void onUserRemoved(RealmModel realm, UserModel user) {+        removeUserSessions(realm, user);++        session.loginFailures().removeUserLoginFailure(realm, user.getId());",Moved to the equivalent event listener in the `MapUserLoginFailureProviderFactory`.,
4266693,afedotov,https://api.github.com/repos/keycloak/keycloak/pulls/7901,613101262,2021-04-14T09:46:40Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -1301,6 +1304,29 @@             return promise.promise;         } +        function checkIfRealmAvailable() {+            return new Promise(function (resolve, reject) {","Ok, let it be, no problem. As stated in source code, KeycloakPromise is deprecated in favor to native Promise, so this abstraction looks useless for me and I used native.BTW, I am surprised why there is no universal XHR function, and XHR is inlined in every place, so it's hard to introduce some common behavior for XHR, for example it is very necessary option to configure network connection timeouts for XHR.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7901,613235276,2021-04-14T13:14:07Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -1301,6 +1304,29 @@             return promise.promise;         } +        function checkIfRealmAvailable() {+            return new Promise(function (resolve, reject) {","Yes you are right KeycloakPromise is deprecated, but deprecated doesn't mean removed yet. This way we can switch to native promises with a change just in one place in the future.I agree with you. What you described sounds pretty good, I would be really happy to see this in the JS adapter in the future. If you would like to contribute this, feel free to create an enhancement Jira and provide a PR.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,613824570,2021-04-15T07:32:15Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -610,7 +537,7 @@ public void onRealmRemoved(RealmModel realm) {     protected void onRealmRemovedEvent(String realmId) {         removeLocalUserSessions(realmId, true);         removeLocalUserSessions(realmId, false);-        removeAllLocalUserLoginFailuresEvent(realmId);+        session.loginFailures().removeAllUserLoginFailures(realmId);","Thanks, now it is correct. The call to cleanup of login failures belongs to `LoginFailureProviderFactory`",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,613994077,2021-04-15T11:40:27Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/user/profile/DynamicUserProfileProvider.java,"@@ -0,0 +1,213 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.testsuite.user.profile;++import java.io.IOException;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.LinkedHashMap;+import java.util.List;+import java.util.Map;++import com.fasterxml.jackson.databind.JsonNode;+import org.keycloak.Config;+import org.keycloak.component.AmphibianProviderFactory;+import org.keycloak.component.ComponentModel;+import org.keycloak.component.ComponentValidationException;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.userprofile.UserProfileContext;+import org.keycloak.userprofile.UserProfileMetadata;+import org.keycloak.userprofile.AttributeMetadata;+import org.keycloak.userprofile.UserProfileProvider;+import org.keycloak.userprofile.legacy.AbstractUserProfileProvider;+import org.keycloak.userprofile.AttributeValidatorMetadata;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DynamicUserProfileProvider extends AbstractUserProfileProvider<DynamicUserProfileProvider>+        implements AmphibianProviderFactory<DynamicUserProfileProvider> {++    public static final String ID = ""dynamic-userprofile-provider"";+    private static Map<String, Map<UserProfileContext, UserProfileMetadata>> METADATA_CACHE;++    public DynamicUserProfileProvider() {+        // for reflection+    }++    public DynamicUserProfileProvider(KeycloakSession session, Map<UserProfileContext, UserProfileMetadata> metadataRegistry) {+        super(session, metadataRegistry);+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    protected DynamicUserProfileProvider create(KeycloakSession session, Map<UserProfileContext, UserProfileMetadata> metadataRegistry) {+        return new DynamicUserProfileProvider(session, metadataRegistry);+    }++    @Override+    protected UserProfileMetadata configureUserProfile(UserProfileMetadata metadata) {+        // adds an attribute config for any context+        metadata.addAttribute(""address"", createStaticValueValidator(""invalidAddress"", ""fixed-address""));++        // adds an attribute config where the config only takes effect when a scope is requested+        // this only works when performing actions during authentication+        metadata.addAttribute(""business.address"", Arrays.asList(""customer""),+                createStaticValueValidator(""invalidBusinessAddress"", ""fixed-business-address""));++        if (UserProfileContext.ACCOUNT.equals(metadata.getContext())) {+            // department not mandatory when in account and only readonly+            metadata.addAttribute(""department"", createRequiredValidator(""departmentRequired""), true, true);+        }++        if (UserProfileContext.USER_API.equals(metadata.getContext())) {+            // department is set by admin and mandatory+            metadata.addAttribute(""department"", createRequiredValidator(""departmentRequired""));+        }++        return metadata;+    }++    @Override+    protected UserProfileMetadata configureUserProfile(UserProfileMetadata metadata, KeycloakSession session) {+        return getRealmUserProfile(session).computeIfAbsent(metadata.getContext(), context -> decorateUserProfile(metadata, session));+    }++    private Map<UserProfileContext, UserProfileMetadata> getRealmUserProfile(KeycloakSession session) {+        return METADATA_CACHE.computeIfAbsent(session.getContext().getRealm().getId(), id -> new HashMap<>());+    }++    @Override+    public String getHelpText() {+        return null;+    }++    @Override+    public void validateConfiguration(KeycloakSession session, RealmModel realm, ComponentModel model)+            throws ComponentValidationException {++    }++    @Override+    public List<ProviderConfigProperty> getConfigProperties() {+        return Collections.emptyList();+    }++    @Override+    public void onCreate(KeycloakSession session, RealmModel realm, ComponentModel model) {+        AmphibianProviderFactory.super.onCreate(session, realm, model);+    }++    @Override+    public void onUpdate(KeycloakSession session, RealmModel realm, ComponentModel oldModel, ComponentModel newModel) {+        AmphibianProviderFactory.super.onUpdate(session, realm, oldModel, newModel);+        removeMetadataFromCache(realm);+    }++    @Override+    public void preRemove(KeycloakSession session, RealmModel realm, ComponentModel model) {+        AmphibianProviderFactory.super.preRemove(session, realm, model);+        removeMetadataFromCache(realm);+    }++    @Override+    public void init(Config.Scope config) {+        super.init(config);+        METADATA_CACHE = Collections.synchronizedMap(new LinkedHashMap<String, Map<UserProfileContext, UserProfileMetadata>>(100, 0.75f, true) {+            @Override+            protected boolean removeEldestEntry(Map.Entry eldest) {+                return METADATA_CACHE.size() > 100; // make this configurable+            }+        });+    }++    private UserProfileMetadata decorateUserProfile(UserProfileMetadata metadata, KeycloakSession session) {+        ComponentModel model = getComponentModel(session);++        if (model == null) {+            return metadata;+        }++        // need to clone otherwise changes to profile config are going to be reflected in the default config+        UserProfileMetadata decoratedMetadata = metadata.clone();++        String config = model.getConfig().getFirst(""config"");++        try {+            Object attribute = JsonSerialization.readValue(config, Map.class).get(""validateConfigAttribute"");++            if (attribute != null && Boolean.parseBoolean(attribute.toString())) {+                decoratedMetadata.addAttribute(""validateConfigAttribute"", createRequiredValidator(""required_dynamic_attribute""));+            }+        } catch (IOException e) {+            throw new RuntimeException(""Failed to parse config"", e);+        }++        return decoratedMetadata;+    }++    private void removeMetadataFromCache(RealmModel realm) {+        synchronized (METADATA_CACHE) {+            METADATA_CACHE.remove(realm.getId());+        }+    }++    private ComponentModel getComponentModel(KeycloakSession session) {+        RealmModel realm = session.getContext().getRealm();+        return realm.getComponentsStream(null, UserProfileProvider.class.getName())+                .findAny()+                .orElse(null);+    }++    private AttributeValidatorMetadata createRequiredValidator(String message) {+        return new AttributeValidatorMetadata(message, context -> {+            Map.Entry<String, List<String>> attribute = context.getAttribute();+            List<String> values = attribute.getValue();+            AttributeMetadata metadata = context.getMetadata();++            if (!metadata.isOptional() && values.isEmpty()) {",Is this validation enough? How are values with blank strings handled? Blank string should be treated as required validation violation.,
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,614012142,2021-04-15T12:10:11Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/user/profile/DynamicUserProfileProvider.java,"@@ -0,0 +1,213 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.testsuite.user.profile;++import java.io.IOException;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.LinkedHashMap;+import java.util.List;+import java.util.Map;++import com.fasterxml.jackson.databind.JsonNode;+import org.keycloak.Config;+import org.keycloak.component.AmphibianProviderFactory;+import org.keycloak.component.ComponentModel;+import org.keycloak.component.ComponentValidationException;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.userprofile.UserProfileContext;+import org.keycloak.userprofile.UserProfileMetadata;+import org.keycloak.userprofile.AttributeMetadata;+import org.keycloak.userprofile.UserProfileProvider;+import org.keycloak.userprofile.legacy.AbstractUserProfileProvider;+import org.keycloak.userprofile.AttributeValidatorMetadata;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DynamicUserProfileProvider extends AbstractUserProfileProvider<DynamicUserProfileProvider>+        implements AmphibianProviderFactory<DynamicUserProfileProvider> {++    public static final String ID = ""dynamic-userprofile-provider"";+    private static Map<String, Map<UserProfileContext, UserProfileMetadata>> METADATA_CACHE;++    public DynamicUserProfileProvider() {+        // for reflection+    }++    public DynamicUserProfileProvider(KeycloakSession session, Map<UserProfileContext, UserProfileMetadata> metadataRegistry) {+        super(session, metadataRegistry);+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    protected DynamicUserProfileProvider create(KeycloakSession session, Map<UserProfileContext, UserProfileMetadata> metadataRegistry) {+        return new DynamicUserProfileProvider(session, metadataRegistry);+    }++    @Override+    protected UserProfileMetadata configureUserProfile(UserProfileMetadata metadata) {+        // adds an attribute config for any context+        metadata.addAttribute(""address"", createStaticValueValidator(""invalidAddress"", ""fixed-address""));++        // adds an attribute config where the config only takes effect when a scope is requested+        // this only works when performing actions during authentication+        metadata.addAttribute(""business.address"", Arrays.asList(""customer""),+                createStaticValueValidator(""invalidBusinessAddress"", ""fixed-business-address""));++        if (UserProfileContext.ACCOUNT.equals(metadata.getContext())) {+            // department not mandatory when in account and only readonly+            metadata.addAttribute(""department"", createRequiredValidator(""departmentRequired""), true, true);+        }++        if (UserProfileContext.USER_API.equals(metadata.getContext())) {+            // department is set by admin and mandatory+            metadata.addAttribute(""department"", createRequiredValidator(""departmentRequired""));+        }++        return metadata;+    }++    @Override+    protected UserProfileMetadata configureUserProfile(UserProfileMetadata metadata, KeycloakSession session) {+        return getRealmUserProfile(session).computeIfAbsent(metadata.getContext(), context -> decorateUserProfile(metadata, session));","If I understand this correctly, there are separate UserProfileMetadata instances for each context in each realm - they are cached so they are loaded only once and then reused until realm is reconfigured. Inside of the UserProfileMetadata instance I can  setup attributes per scopes. But I'm not sure if this mechanism has enough expresivity to support our configurations per client - where/how are we going to select user profile based on calling client with evaluation of the defaults chain?I'm also probably missing when is `protected UserProfileMetadata configureUserProfile(UserProfileMetadata metadata)` method called and what is its difference from this method (which should be used for what)",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7846,614032492,2021-04-15T12:39:56Z,testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/user/profile/DynamicUserProfileProvider.java,"@@ -0,0 +1,213 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.testsuite.user.profile;++import java.io.IOException;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.LinkedHashMap;+import java.util.List;+import java.util.Map;++import com.fasterxml.jackson.databind.JsonNode;+import org.keycloak.Config;+import org.keycloak.component.AmphibianProviderFactory;+import org.keycloak.component.ComponentModel;+import org.keycloak.component.ComponentValidationException;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.userprofile.UserProfileContext;+import org.keycloak.userprofile.UserProfileMetadata;+import org.keycloak.userprofile.AttributeMetadata;+import org.keycloak.userprofile.UserProfileProvider;+import org.keycloak.userprofile.legacy.AbstractUserProfileProvider;+import org.keycloak.userprofile.AttributeValidatorMetadata;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public class DynamicUserProfileProvider extends AbstractUserProfileProvider<DynamicUserProfileProvider>+        implements AmphibianProviderFactory<DynamicUserProfileProvider> {++    public static final String ID = ""dynamic-userprofile-provider"";+    private static Map<String, Map<UserProfileContext, UserProfileMetadata>> METADATA_CACHE;++    public DynamicUserProfileProvider() {+        // for reflection+    }++    public DynamicUserProfileProvider(KeycloakSession session, Map<UserProfileContext, UserProfileMetadata> metadataRegistry) {+        super(session, metadataRegistry);+    }++    @Override+    public String getId() {+        return ID;+    }++    @Override+    protected DynamicUserProfileProvider create(KeycloakSession session, Map<UserProfileContext, UserProfileMetadata> metadataRegistry) {+        return new DynamicUserProfileProvider(session, metadataRegistry);+    }++    @Override+    protected UserProfileMetadata configureUserProfile(UserProfileMetadata metadata) {+        // adds an attribute config for any context+        metadata.addAttribute(""address"", createStaticValueValidator(""invalidAddress"", ""fixed-address""));++        // adds an attribute config where the config only takes effect when a scope is requested+        // this only works when performing actions during authentication+        metadata.addAttribute(""business.address"", Arrays.asList(""customer""),+                createStaticValueValidator(""invalidBusinessAddress"", ""fixed-business-address""));++        if (UserProfileContext.ACCOUNT.equals(metadata.getContext())) {+            // department not mandatory when in account and only readonly+            metadata.addAttribute(""department"", createRequiredValidator(""departmentRequired""), true, true);+        }++        if (UserProfileContext.USER_API.equals(metadata.getContext())) {+            // department is set by admin and mandatory+            metadata.addAttribute(""department"", createRequiredValidator(""departmentRequired""));+        }++        return metadata;+    }++    @Override+    protected UserProfileMetadata configureUserProfile(UserProfileMetadata metadata, KeycloakSession session) {+        return getRealmUserProfile(session).computeIfAbsent(metadata.getContext(), context -> decorateUserProfile(metadata, session));","Attributes have a selection mechanism based on a `Predicate`. So you should be able to have any check for that.The two versions of a `configureUserProfile` are for `init` and `runtime`. As per doc as well as the additional `KeycloakSession` parameter that is only used when at runtime, processing requests.",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/7846,614047768,2021-04-15T13:00:47Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultUserProfile.java,"@@ -0,0 +1,147 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.userprofile;++import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.function.BiConsumer;+import java.util.function.Function;+import java.util.stream.Collectors;++import org.keycloak.models.ModelException;+import org.keycloak.models.UserModel;++/**+ * <p>The default implementation for {@link UserProfile}. Should be reused as much as possible by the different implementations+ * of {@link UserProfileProvider}.+ *+ * <p>This implementation is not specific to any user profile implementation.+ *+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public final class DefaultUserProfile implements UserProfile {++    private final Function<Attributes, UserModel> userSupplier;+    private final Attributes attributes;+    private boolean validated;+    private UserModel user;++    public DefaultUserProfile(Attributes attributes, Function<Attributes, UserModel> userCreator, UserModel user) {+        this.userSupplier = userCreator;+        this.attributes = attributes;+        this.user = user;+    }++    @Override+    public void validate() {+        ValidationException validationException = new ValidationException();++        for (String attributeName : attributes.nameSet()) {+            this.attributes.validate(attributeName,+                    (attribute, message) -> validationException.addError(new ValidationException.Error(attribute, message)));+        }++        if (validationException.hasError()) {+            throw validationException;+        }++        validated = true;+    }++    @Override+    public UserModel create() throws ValidationException {+        if (user != null) {+            throw new RuntimeException(""User already created"");+        }++        if (!validated) {+            validate();+        }++        user = userSupplier.apply(this.attributes);++        return updateInternal(user, false);+    }++    @Override+    public void update(boolean removeAttributes, BiConsumer<String, UserModel>... changeListener) {+        if (!validated) {+            validate();+        }++        updateInternal(user, removeAttributes, changeListener);+    }++    private UserModel updateInternal(UserModel user, boolean removeAttributes, BiConsumer<String, UserModel>... changeListener) {+        if (user == null) {+            throw new RuntimeException(""No user model provided for persisting changes"");+        }++        try {+            for (Map.Entry<String, List<String>> attribute : attributes.attributeSet()) {+                String name = attribute.getKey();++                if (attributes.isReadOnly(name)) {+                    continue;+                }++                List<String> currentValue = user.getAttributeStream(name).filter(Objects::nonNull).collect(Collectors.toList());+                List<String> updatedValue = attribute.getValue().stream().filter(Objects::nonNull).collect(Collectors.toList());++                if (currentValue.size() != updatedValue.size() || !currentValue.containsAll(updatedValue)) {+                    user.setAttribute(name, updatedValue);+                    for (BiConsumer<String, UserModel> listener : changeListener) {+                        listener.accept(name, user);+                    }+                }+            }++            // this is a workaround for supporting contexts where the decision to whether attributes should be removed depends on+            // specific aspect. For instance, old account should never remove attributes, the admin rest api should only remove if+            // the attribute map was sent.+            if (removeAttributes) {","I know we discussed `removeAttributes` parameter already, why it exists, and I hope I understand why it is here :-D But still I'm not sure if it is used correctly, why are all attributes which do not have new value in `attributes` instance removed based on it. For me it looks like UserProfile configuration selected for the current action is not reflected here, as we should remove only attributes which are part of the user profile and do not have new value, but we should never touch others. Maybe I misunderstand something, I'll try to do some tests once your PR is merged to see how exactly this code works",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7846,614115447,2021-04-15T14:22:58Z,server-spi-private/src/main/java/org/keycloak/userprofile/validation/Validator.java,"@@ -0,0 +1,31 @@+/*+ *+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates+ *  * and other contributors as indicated by the @author tags.+ *  *+ *  * Licensed under the Apache License, Version 2.0 (the ""License"");+ *  * you may not use this file except in compliance with the License.+ *  * You may obtain a copy of the License at+ *  *+ *  * http://www.apache.org/licenses/LICENSE-2.0+ *  *+ *  * Unless required by applicable law or agreed to in writing, software+ *  * distributed under the License is distributed on an ""AS IS"" BASIS,+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *  * See the License for the specific language governing permissions and+ *  * limitations under the License.+ *+ */++package org.keycloak.userprofile.validation;++import org.keycloak.userprofile.AttributeContext;++/**+ * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>+ */+public interface Validator {++    Boolean validate(AttributeContext context);",Can this return `null`? What's the semantics?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,614148162,2021-04-15T15:00:03Z,model/map/src/main/java/org/keycloak/models/map/loginFailure/MapUserLoginFailureProviderFactory.java,"@@ -0,0 +1,58 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.loginFailure;++import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.UserLoginFailureProvider;+import org.keycloak.models.UserLoginFailureProviderFactory;+import org.keycloak.models.UserLoginFailureModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.map.common.AbstractMapProviderFactory;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;++import java.util.UUID;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserLoginFailureProviderFactory extends AbstractMapProviderFactory<UserLoginFailureProvider>+        implements UserLoginFailureProviderFactory {++    private MapStorage<UUID, MapUserLoginFailureEntity, UserLoginFailureModel> userLoginFailureStore;++    @Override+    public void postInit(KeycloakSessionFactory factory) {+        MapStorageProvider sp = (MapStorageProvider) factory.getProviderFactory(MapStorageProvider.class);+        userLoginFailureStore = sp.getStorage(""userLoginFailures"", UUID.class, MapUserLoginFailureEntity.class, UserLoginFailureModel.class);++        factory.register(event -> {+            if (event instanceof UserModel.UserRemovedEvent) {+                UserModel.UserRemovedEvent userRemovedEvent = (UserModel.UserRemovedEvent) event;++                MapUserLoginFailureProvider provider = MapUserLoginFailureProviderFactory.this.create(userRemovedEvent.getKeycloakSession());+                provider.removeUserLoginFailure(userRemovedEvent.getRealm(), userRemovedEvent.getUser().getId());+            }","My bad, you're right.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7870,614725187,2021-04-16T10:11:47Z,services/src/main/java/org/keycloak/storage/ClientStorageManager.java,"@@ -151,18 +151,32 @@ public ClientModel getClientByClientId(RealmModel realm, String clientId) {      @Override     public Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByClientIdStream(realm, clientId, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByClientIdStream(realm, clientId, f, m), realm, firstResult, maxResults);     }      @Override     public Stream<ClientModel> searchClientsByAttributes(RealmModel realm, Map<String, String> attributes, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByAttributes(realm, attributes, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByAttributes(realm, attributes, f, m), realm, firstResult, maxResults);+    }++    @FunctionalInterface+    interface PaginatedQuery {+        Stream<ClientModel> query(ClientLookupProvider provider, Integer firstResult, Integer maxResults);     } -    protected Stream<ClientModel> query(Function<ClientLookupProvider, Stream<ClientModel>> performQuery, RealmModel realm, Integer firstResult, Integer maxResults) {+    protected Stream<ClientModel> query(PaginatedQuery paginatedQuery, RealmModel realm, Integer firstResult, Integer maxResults) {         if (maxResults != null && maxResults == 0) return Stream.empty(); -        Stream<ClientLookupProvider> providersStream = Stream.concat(Stream.of(session.clientLocalStorage()), getEnabledStorageProviders(session, realm, ClientLookupProvider.class));+        Set<ClientLookupProvider> extStorageProviders = getEnabledStorageProviders(session, realm, ClientLookupProvider.class).collect(Collectors.toSet());+        boolean hasExtStorageProviders = !extStorageProviders.isEmpty();++        // when there are external providers involved, we can't do pagination at the lower data layer as we don't know+        // how many results there will be; i.e. we need to fetch all the clients that match the criteria specified by the query+        // and perform the pagination later at this layer+        Integer firstResultLocal = hasExtStorageProviders ? null : firstResult;","This seems unnecessary. Do you know what was the problem that was causing the failures? Because we are using very similar approach in UserStorageManager, and I believe it works correctly.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7870,614734791,2021-04-16T10:28:45Z,services/src/main/java/org/keycloak/storage/ClientStorageManager.java,"@@ -151,18 +151,32 @@ public ClientModel getClientByClientId(RealmModel realm, String clientId) {      @Override     public Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByClientIdStream(realm, clientId, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByClientIdStream(realm, clientId, f, m), realm, firstResult, maxResults);     }      @Override     public Stream<ClientModel> searchClientsByAttributes(RealmModel realm, Map<String, String> attributes, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByAttributes(realm, attributes, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByAttributes(realm, attributes, f, m), realm, firstResult, maxResults);+    }++    @FunctionalInterface+    interface PaginatedQuery {+        Stream<ClientModel> query(ClientLookupProvider provider, Integer firstResult, Integer maxResults);     } -    protected Stream<ClientModel> query(Function<ClientLookupProvider, Stream<ClientModel>> performQuery, RealmModel realm, Integer firstResult, Integer maxResults) {+    protected Stream<ClientModel> query(PaginatedQuery paginatedQuery, RealmModel realm, Integer firstResult, Integer maxResults) {         if (maxResults != null && maxResults == 0) return Stream.empty(); -        Stream<ClientLookupProvider> providersStream = Stream.concat(Stream.of(session.clientLocalStorage()), getEnabledStorageProviders(session, realm, ClientLookupProvider.class));+        Set<ClientLookupProvider> extStorageProviders = getEnabledStorageProviders(session, realm, ClientLookupProvider.class).collect(Collectors.toSet());+        boolean hasExtStorageProviders = !extStorageProviders.isEmpty();++        // when there are external providers involved, we can't do pagination at the lower data layer as we don't know+        // how many results there will be; i.e. we need to fetch all the clients that match the criteria specified by the query+        // and perform the pagination later at this layer+        Integer firstResultLocal = hasExtStorageProviders ? null : firstResult;",The problem was that we did the pagination twice  at the data layer and then here. It works for users because we don't do the pagination at the data layer.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7870,614745723,2021-04-16T10:49:14Z,services/src/main/java/org/keycloak/storage/ClientStorageManager.java,"@@ -151,18 +151,32 @@ public ClientModel getClientByClientId(RealmModel realm, String clientId) {      @Override     public Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByClientIdStream(realm, clientId, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByClientIdStream(realm, clientId, f, m), realm, firstResult, maxResults);     }      @Override     public Stream<ClientModel> searchClientsByAttributes(RealmModel realm, Map<String, String> attributes, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByAttributes(realm, attributes, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByAttributes(realm, attributes, f, m), realm, firstResult, maxResults);+    }++    @FunctionalInterface+    interface PaginatedQuery {+        Stream<ClientModel> query(ClientLookupProvider provider, Integer firstResult, Integer maxResults);     } -    protected Stream<ClientModel> query(Function<ClientLookupProvider, Stream<ClientModel>> performQuery, RealmModel realm, Integer firstResult, Integer maxResults) {+    protected Stream<ClientModel> query(PaginatedQuery paginatedQuery, RealmModel realm, Integer firstResult, Integer maxResults) {         if (maxResults != null && maxResults == 0) return Stream.empty(); -        Stream<ClientLookupProvider> providersStream = Stream.concat(Stream.of(session.clientLocalStorage()), getEnabledStorageProviders(session, realm, ClientLookupProvider.class));+        Set<ClientLookupProvider> extStorageProviders = getEnabledStorageProviders(session, realm, ClientLookupProvider.class).collect(Collectors.toSet());+        boolean hasExtStorageProviders = !extStorageProviders.isEmpty();++        // when there are external providers involved, we can't do pagination at the lower data layer as we don't know+        // how many results there will be; i.e. we need to fetch all the clients that match the criteria specified by the query+        // and perform the pagination later at this layer+        Integer firstResultLocal = hasExtStorageProviders ? null : firstResult;",You can avoid pagination on data layer also here. You just need to put null to first and max parameters.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7870,614747022,2021-04-16T10:51:46Z,services/src/main/java/org/keycloak/storage/ClientStorageManager.java,"@@ -151,18 +151,32 @@ public ClientModel getClientByClientId(RealmModel realm, String clientId) {      @Override     public Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByClientIdStream(realm, clientId, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByClientIdStream(realm, clientId, f, m), realm, firstResult, maxResults);     }      @Override     public Stream<ClientModel> searchClientsByAttributes(RealmModel realm, Map<String, String> attributes, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByAttributes(realm, attributes, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByAttributes(realm, attributes, f, m), realm, firstResult, maxResults);+    }++    @FunctionalInterface+    interface PaginatedQuery {+        Stream<ClientModel> query(ClientLookupProvider provider, Integer firstResult, Integer maxResults);     } -    protected Stream<ClientModel> query(Function<ClientLookupProvider, Stream<ClientModel>> performQuery, RealmModel realm, Integer firstResult, Integer maxResults) {+    protected Stream<ClientModel> query(PaginatedQuery paginatedQuery, RealmModel realm, Integer firstResult, Integer maxResults) {         if (maxResults != null && maxResults == 0) return Stream.empty(); -        Stream<ClientLookupProvider> providersStream = Stream.concat(Stream.of(session.clientLocalStorage()), getEnabledStorageProviders(session, realm, ClientLookupProvider.class));+        Set<ClientLookupProvider> extStorageProviders = getEnabledStorageProviders(session, realm, ClientLookupProvider.class).collect(Collectors.toSet());+        boolean hasExtStorageProviders = !extStorageProviders.isEmpty();++        // when there are external providers involved, we can't do pagination at the lower data layer as we don't know+        // how many results there will be; i.e. we need to fetch all the clients that match the criteria specified by the query","Yes, and therefore we don't know if we need the external storage, if there were enough results in the local storage.I take it we try to do a best effort solution. When there's only local storage involved, we can do a (potentially) more optimized pagination at the lower data layer. If there are external storages involved, we need to do the pagination at this layer (similarly to users).",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7937,614784367,2021-04-16T12:03:21Z,model/map/src/main/java/org/keycloak/models/map/storage/ModelCriteriaBuilder.java,"@@ -61,10 +61,10 @@      * is now.      */     public enum Operator {-        /** Equals to */-        EQ,-        /** Not equals to */-        NE,+        /** Equals to for single value objects and contains the value for list objects */","```suggestion        /**         * This single-parameter operator checks that the property has the given value: <ul>         * <li>In case of single values, this corresponds to equality check to the operand</li>         * <li>In case of lists, this corresponds to checking that this list contains an object equivalent to the operand</li>         * </ul>         */         ```",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7870,614794565,2021-04-16T12:21:46Z,services/src/main/java/org/keycloak/storage/ClientStorageManager.java,"@@ -151,18 +151,32 @@ public ClientModel getClientByClientId(RealmModel realm, String clientId) {      @Override     public Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByClientIdStream(realm, clientId, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByClientIdStream(realm, clientId, f, m), realm, firstResult, maxResults);     }      @Override     public Stream<ClientModel> searchClientsByAttributes(RealmModel realm, Map<String, String> attributes, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByAttributes(realm, attributes, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByAttributes(realm, attributes, f, m), realm, firstResult, maxResults);+    }++    @FunctionalInterface+    interface PaginatedQuery {+        Stream<ClientModel> query(ClientLookupProvider provider, Integer firstResult, Integer maxResults);     } -    protected Stream<ClientModel> query(Function<ClientLookupProvider, Stream<ClientModel>> performQuery, RealmModel realm, Integer firstResult, Integer maxResults) {+    protected Stream<ClientModel> query(PaginatedQuery paginatedQuery, RealmModel realm, Integer firstResult, Integer maxResults) {         if (maxResults != null && maxResults == 0) return Stream.empty(); -        Stream<ClientLookupProvider> providersStream = Stream.concat(Stream.of(session.clientLocalStorage()), getEnabledStorageProviders(session, realm, ClientLookupProvider.class));+        Set<ClientLookupProvider> extStorageProviders = getEnabledStorageProviders(session, realm, ClientLookupProvider.class).collect(Collectors.toSet());+        boolean hasExtStorageProviders = !extStorageProviders.isEmpty();++        // when there are external providers involved, we can't do pagination at the lower data layer as we don't know+        // how many results there will be; i.e. we need to fetch all the clients that match the criteria specified by the query","> Also I am not sure whether collecting all storage providers from storage is the best way to check if there is any, maybe we can optimize this as well, but this is just a nit as there probably won't thousands of providers.Apparently, we probably need to [iterate over all providers](https://github.com/keycloak/keycloak/blob/375a9219d6573a244cc05446616e4d2d715ee097/services/src/main/java/org/keycloak/storage/ClientStorageManager.java#L116-L118) in any case, so I think it's better to fetch them only once.> On the other hand I am not sure we will be able to use this optimization in the future as Tree storage won't have local storage anymore.I think with all the current pressure around clients performance it's better to use any optimization possible. But I'll leave it up to you and @hmlnarik what you agree on. ;)",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7870,614802794,2021-04-16T12:36:12Z,services/src/main/java/org/keycloak/storage/ClientStorageManager.java,"@@ -151,18 +151,32 @@ public ClientModel getClientByClientId(RealmModel realm, String clientId) {      @Override     public Stream<ClientModel> searchClientsByClientIdStream(RealmModel realm, String clientId, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByClientIdStream(realm, clientId, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByClientIdStream(realm, clientId, f, m), realm, firstResult, maxResults);     }      @Override     public Stream<ClientModel> searchClientsByAttributes(RealmModel realm, Map<String, String> attributes, Integer firstResult, Integer maxResults) {-        return query(p -> p.searchClientsByAttributes(realm, attributes, firstResult, maxResults), realm, firstResult, maxResults);+        return query((p, f, m) -> p.searchClientsByAttributes(realm, attributes, f, m), realm, firstResult, maxResults);+    }++    @FunctionalInterface+    interface PaginatedQuery {+        Stream<ClientModel> query(ClientLookupProvider provider, Integer firstResult, Integer maxResults);     } -    protected Stream<ClientModel> query(Function<ClientLookupProvider, Stream<ClientModel>> performQuery, RealmModel realm, Integer firstResult, Integer maxResults) {+    protected Stream<ClientModel> query(PaginatedQuery paginatedQuery, RealmModel realm, Integer firstResult, Integer maxResults) {         if (maxResults != null && maxResults == 0) return Stream.empty(); -        Stream<ClientLookupProvider> providersStream = Stream.concat(Stream.of(session.clientLocalStorage()), getEnabledStorageProviders(session, realm, ClientLookupProvider.class));+        Set<ClientLookupProvider> extStorageProviders = getEnabledStorageProviders(session, realm, ClientLookupProvider.class).collect(Collectors.toSet());+        boolean hasExtStorageProviders = !extStorageProviders.isEmpty();++        // when there are external providers involved, we can't do pagination at the lower data layer as we don't know+        // how many results there will be; i.e. we need to fetch all the clients that match the criteria specified by the query","> > Also I am not sure whether collecting all storage providers from storage is the best way to check if there is any, maybe we can optimize this as well, but this is just a nit as there probably won't thousands of providers.> > Apparently, we probably need to [iterate over all providers](https://github.com/keycloak/keycloak/blob/375a9219d6573a244cc05446616e4d2d715ee097/services/src/main/java/org/keycloak/storage/ClientStorageManager.java#L116-L118) in any case, so I think it's better to fetch them only once.Currently yes, because you are collecting the whole stream. When you not collect the stream, the code you sent is done only on those that are queried for clients at the end. If you find enough clients in local storage, non of the code you sent would be executed regardless the number of external provider configured.> > > On the other hand I am not sure we will be able to use this optimization in the future as Tree storage won't have local storage anymore.> > I think with all the current pressure around clients performance it's better to use any optimization possible. But I'll leave it up to you and @hmlnarik what you agree on. ;)The issue with storage providers is probably not so important. I think we can leave it as is. However, I would add something like this:```javaif (!hasExtStorageProviders) {    return paginatedQuery.query(session.clientLocalStorage(), firstResult, maxResult);}```and remove usage of `firstResultLocal` as it makes the code more intuitive. WDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7906,616548169,2021-04-20T10:17:08Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/authentication/KeycloakAuthenticationEntryPoint.java,"@@ -105,7 +106,13 @@ protected void commenceLoginRedirect(HttpServletRequest request, HttpServletResp             // stored in a session. We'll store it in a cookie instead.             response.addCookie(KeycloakCookieBasedRedirect.createCookieFromRedirectUrl(request.getRequestURI()));         }-        String contextAwareLoginUri = request.getContextPath() + loginUri;++        String queryParameters = """";+        if (!StringUtils.isEmpty(request.getQueryString())) {+            queryParameters = ""?"" + request.getQueryString();",I am not sure we want to add all parameters. Maybe we should use only those that can be consumed by Keycloak. WDYT?,
1021324,dweber019,https://api.github.com/repos/keycloak/keycloak/pulls/7906,617464371,2021-04-21T11:53:04Z,adapters/oidc/spring-security/src/main/java/org/keycloak/adapters/springsecurity/authentication/KeycloakAuthenticationEntryPoint.java,"@@ -105,7 +106,13 @@ protected void commenceLoginRedirect(HttpServletRequest request, HttpServletResp             // stored in a session. We'll store it in a cookie instead.             response.addCookie(KeycloakCookieBasedRedirect.createCookieFromRedirectUrl(request.getRequestURI()));         }-        String contextAwareLoginUri = request.getContextPath() + loginUri;++        String queryParameters = """";+        if (!StringUtils.isEmpty(request.getQueryString())) {+            queryParameters = ""?"" + request.getQueryString();","Currently the https://github.com/keycloak/keycloak/blob/cd342ad5714f15db1cc8b0cd55b788e6543c6dc8/adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/OAuthRequestAuthenticator.java will check which query parameters are moved up to top url (not redirect uri, forwarding parameters), e.g. prompt=login. All other parameters are passed as is in the redirect uri.For us (my company) we define the language for application which should be used by setting the query param ""lang=en"" on the application url. If we don't strip this parameter we can check this in our Keycloak authenticators too.In addition now it's the same behavior as in the JBoss adapter.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,618107245,2021-04-22T06:13:18Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -265,7 +263,9 @@ public boolean checkTokenValidForIntrospection(KeycloakSession session, RealmMod             }              if (valid) {-                userSession.setLastSessionRefresh(Time.currentTime());+                int currentTime = Time.currentTime();+                userSession.setLastSessionRefresh(currentTime);+                userSession.getAuthenticatedClientSessions().values().forEach(c -> c.setTimestamp(currentTime));",This needs to be limited to `client`. Clients unrelated to this token should not be updated here.Then the proposed behaviour would seem correct to me as it is consistent with refreshing tokens: https://github.com/keycloak/keycloak/blob/e94017f258dbdb8224704818d033c21fa7d44112/services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java#L332-L334WDYT @mposolda?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7934,619073487,2021-04-23T09:21:46Z,model/map/src/main/java/org/keycloak/models/map/serverinfo/MapServerInfoProviderFactory.java,"@@ -0,0 +1,93 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.serverinfo;++import java.security.MessageDigest;+import java.security.NoSuchAlgorithmException;+import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.common.Version;+import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.RandomString;+import org.keycloak.migration.MigrationModel;+import org.keycloak.migration.ModelVersion;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.ServerInfoProvider;+import org.keycloak.models.ServerInfoProviderFactory;++public class MapServerInfoProviderFactory implements ServerInfoProviderFactory {++    @Override+    public void init(Config.Scope config) {+        String seed = config.get(""resourcesVersionSeed"");+        if (seed == null) {+            Logger.getLogger(ServerInfoProviderFactory.class).warn(""It is recommended to set 'resourcesVersionSeed' property in the config especially in clustered environment. For more details see the documentation."");","```suggestion            Logger.getLogger(ServerInfoProviderFactory.class).warn(""It is recommended to set 'resourcesVersionSeed' property in the "" + PROVIDER_ID + "" provider config of serverInfo SPI"");```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7844,619074085,2021-04-23T09:22:43Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -265,7 +263,9 @@ public boolean checkTokenValidForIntrospection(KeycloakSession session, RealmMod             }              if (valid) {-                userSession.setLastSessionRefresh(Time.currentTime());+                int currentTime = Time.currentTime();+                userSession.setLastSessionRefresh(currentTime);+                userSession.getAuthenticatedClientSessions().values().forEach(c -> c.setTimestamp(currentTime));","@hmlnarik @martin-kanis +1 to the fact that clientSession timestamp should be updated here and that it should be just timestamp of the clientSession, which is related to this particular client for whom token is issued. It seems that the code referenced in this comment is outdated, but latest code in this PR in class TokenManager https://github.com/keycloak/keycloak/pull/7844/files#diff-fd8b1c47da5ec7ee42d5450d3f7b73cdeef9c08af26b825c9245e3e6052c5cdf  looks correct to me . ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7679,619430991,2021-04-23T18:48:47Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java,"@@ -0,0 +1,243 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.Collections;+import java.util.Optional;++import com.fasterxml.jackson.databind.node.ObjectNode;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.Profile;+import org.keycloak.common.util.Time;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.CibaConfig;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;+import org.keycloak.util.JsonSerialization;+import org.keycloak.utils.ProfileHelper;++public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {++    private final RealmModel realm;++    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+        this.realm = session.getContext().getRealm();+        event.event(EventType.LOGIN);+    }++    @POST+    @NoCache+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processGrantRequest(@Context HttpRequest httpRequest) {+        ProfileHelper.requireFeature(Profile.Feature.CIBA);+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());++        try {+            String authReqId = request.serialize(session);+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);++            if (provider == null) {+                throw new RuntimeException(""Authentication Channel Provider not found."");+            }++            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);++            if (resolver == null) {+                throw new RuntimeException(""CIBA Login User Resolver not setup properly."");+            }++            UserModel user = request.getUser();++            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);++            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {+                CibaConfig cibaPolicy = realm.getCibaPolicy();+                int poolingInterval = cibaPolicy.getPoolingInterval();++                storeAuthenticationRequest(request, cibaPolicy);++                ObjectNode response = JsonSerialization.createObjectNode();++                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());++                if (poolingInterval > 0) {+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);+                }++                return Response.ok(JsonSerialization.writeValueAsBytes(response))+                        .build();+            }+        } catch (Exception e) {+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Failed to send authentication request"", Response.Status.SERVICE_UNAVAILABLE);+        }++        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Unexpected response from authentication device"", Response.Status.SERVICE_UNAVAILABLE);+    }++    /**+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case+     * that relies on cross-references for unsolicited user authentication requests from devices.+     */+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {+        ClientModel client = request.getClient();+        int expiresIn = cibaConfig.getExpiresIn();+        int poolingInterval = cibaConfig.getPoolingInterval();++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,+                Collections.emptyMap());+        String authResultId = request.getAuthResultId();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),+                authResultId);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + poolingInterval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);++        store.put(deviceCode, userCode, lifespanSeconds);","We use it at the callback endpoint. The usage is similar to device code, where the user code is the so-called `auth_result_id`.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7679,619776369,2021-04-25T08:39:45Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java,"@@ -0,0 +1,243 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.Collections;+import java.util.Optional;++import com.fasterxml.jackson.databind.node.ObjectNode;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.Profile;+import org.keycloak.common.util.Time;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.CibaConfig;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;+import org.keycloak.util.JsonSerialization;+import org.keycloak.utils.ProfileHelper;++public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {++    private final RealmModel realm;++    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+        this.realm = session.getContext().getRealm();+        event.event(EventType.LOGIN);+    }++    @POST+    @NoCache+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processGrantRequest(@Context HttpRequest httpRequest) {+        ProfileHelper.requireFeature(Profile.Feature.CIBA);+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());++        try {+            String authReqId = request.serialize(session);+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);++            if (provider == null) {+                throw new RuntimeException(""Authentication Channel Provider not found."");+            }++            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);++            if (resolver == null) {+                throw new RuntimeException(""CIBA Login User Resolver not setup properly."");+            }++            UserModel user = request.getUser();++            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);++            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {+                CibaConfig cibaPolicy = realm.getCibaPolicy();+                int poolingInterval = cibaPolicy.getPoolingInterval();++                storeAuthenticationRequest(request, cibaPolicy);++                ObjectNode response = JsonSerialization.createObjectNode();++                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());++                if (poolingInterval > 0) {+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);+                }++                return Response.ok(JsonSerialization.writeValueAsBytes(response))+                        .build();+            }+        } catch (Exception e) {+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Failed to send authentication request"", Response.Status.SERVICE_UNAVAILABLE);+        }++        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Unexpected response from authentication device"", Response.Status.SERVICE_UNAVAILABLE);+    }++    /**+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case+     * that relies on cross-references for unsolicited user authentication requests from devices.+     */+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {+        ClientModel client = request.getClient();+        int expiresIn = cibaConfig.getExpiresIn();+        int poolingInterval = cibaConfig.getPoolingInterval();++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,+                Collections.emptyMap());+        String authResultId = request.getAuthResultId();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),+                authResultId);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + poolingInterval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);++        store.put(deviceCode, userCode, lifespanSeconds);","@mposolda As @pedroigor stated, I also think that `OAuth2DeviceUserCodeModel` is needed. In this context, `auth_result_id` included in this model takes the same role of `user_code`, namely being used as the key to retrieve the context data from the cache on `BackchannelAuthenticationCallbackEndpoint`.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7934,619801936,2021-04-25T11:44:11Z,model/map/src/main/java/org/keycloak/models/map/serverinfo/MapServerInfoProviderFactory.java,"@@ -26,18 +26,19 @@ import org.keycloak.common.util.RandomString; import org.keycloak.migration.MigrationModel; import org.keycloak.migration.ModelVersion;+import org.keycloak.models.Constants; import org.keycloak.models.KeycloakSession;-import org.keycloak.models.KeycloakSessionFactory; import org.keycloak.models.ServerInfoProvider; import org.keycloak.models.ServerInfoProviderFactory;+import org.keycloak.models.map.common.AbstractMapProviderFactory; -public class MapServerInfoProviderFactory implements ServerInfoProviderFactory {+public class MapServerInfoProviderFactory extends AbstractMapProviderFactory<ServerInfoProvider> implements ServerInfoProviderFactory {      @Override     public void init(Config.Scope config) {-        String seed = config.get(""resourcesVersionSeed"");+        String seed = config.get(Constants.RESOURCES_VERSION_SEED);",Please have this constant local to `MapServerInfoProviderFactory` class.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7679,620060378,2021-04-26T08:01:18Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java,"@@ -0,0 +1,243 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.grants.ciba.endpoints;++import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.Collections;+import java.util.Optional;++import com.fasterxml.jackson.databind.node.ObjectNode;+import org.jboss.resteasy.annotations.cache.NoCache;+import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.Profile;+import org.keycloak.common.util.Time;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.models.CibaConfig;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.OAuth2DeviceCodeModel;+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;+import org.keycloak.models.OAuth2DeviceUserCodeModel;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;+import org.keycloak.services.ErrorResponseException;+import org.keycloak.util.JsonSerialization;+import org.keycloak.utils.ProfileHelper;++public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {++    private final RealmModel realm;++    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {+        super(session, event);+        this.realm = session.getContext().getRealm();+        event.event(EventType.LOGIN);+    }++    @POST+    @NoCache+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response processGrantRequest(@Context HttpRequest httpRequest) {+        ProfileHelper.requireFeature(Profile.Feature.CIBA);+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());++        try {+            String authReqId = request.serialize(session);+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);++            if (provider == null) {+                throw new RuntimeException(""Authentication Channel Provider not found."");+            }++            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);++            if (resolver == null) {+                throw new RuntimeException(""CIBA Login User Resolver not setup properly."");+            }++            UserModel user = request.getUser();++            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);++            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {+                CibaConfig cibaPolicy = realm.getCibaPolicy();+                int poolingInterval = cibaPolicy.getPoolingInterval();++                storeAuthenticationRequest(request, cibaPolicy);++                ObjectNode response = JsonSerialization.createObjectNode();++                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());++                if (poolingInterval > 0) {+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);+                }++                return Response.ok(JsonSerialization.writeValueAsBytes(response))+                        .build();+            }+        } catch (Exception e) {+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Failed to send authentication request"", Response.Status.SERVICE_UNAVAILABLE);+        }++        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, ""Unexpected response from authentication device"", Response.Status.SERVICE_UNAVAILABLE);+    }++    /**+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case+     * that relies on cross-references for unsolicited user authentication requests from devices.+     */+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {+        ClientModel client = request.getClient();+        int expiresIn = cibaConfig.getExpiresIn();+        int poolingInterval = cibaConfig.getPoolingInterval();++        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,+                Collections.emptyMap());+        String authResultId = request.getAuthResultId();+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),+                authResultId);++        // To inform ""expired_token"" to the client, the lifespan of the cache provider is longer than device code+        int lifespanSeconds = expiresIn + poolingInterval + 10;++        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);++        store.put(deviceCode, userCode, lifespanSeconds);","I am not 100% sure, but this is not big issue regardless as entry from the cache should be removed after very short time anyway. We can eventually doublecheck in the future... I am resolving this comment for now.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7844,620106464,2021-04-26T09:01:54Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java,"@@ -0,0 +1,668 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.jboss.logging.Logger;+import org.keycloak.common.util.Time;+import org.keycloak.device.DeviceActivityManager;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelDuplicateException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.models.UserSessionProvider;+import org.keycloak.models.map.common.Serialization;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;++import java.util.Arrays;+import java.util.Collection;+import java.util.Comparator;+import java.util.HashMap;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;+import java.util.UUID;+import java.util.concurrent.ConcurrentHashMap;+import java.util.function.Function;+import java.util.function.Predicate;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import static org.keycloak.common.util.StackUtil.getShortStackTrace;+import static org.keycloak.models.UserSessionModel.CORRESPONDING_SESSION_ID;+import static org.keycloak.models.UserSessionModel.SessionPersistenceState.TRANSIENT;+import static org.keycloak.models.map.userSession.SessionExpiration.setClientSessionExpiration;+import static org.keycloak.models.map.userSession.SessionExpiration.setUserSessionExpiration;+import static org.keycloak.utils.StreamsUtil.paginatedStream;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class MapUserSessionProvider implements UserSessionProvider {++    private static final Logger LOG = Logger.getLogger(MapUserSessionProvider.class);+    private final KeycloakSession session;+    protected final MapKeycloakTransaction<UUID, MapUserSessionEntity, UserSessionModel> userSessionTx;+    protected final MapKeycloakTransaction<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionTx;+    private final MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore;+    private final MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore;++    /**+     * Storage for transient user sessions which lifespan is limited to one request.+     */+    private final Map<UUID, MapUserSessionEntity> transientUserSessions = new HashMap<>();++    public MapUserSessionProvider(KeycloakSession session, MapStorage<UUID, MapUserSessionEntity, UserSessionModel> userSessionStore,+                                  MapStorage<UUID, MapAuthenticatedClientSessionEntity, AuthenticatedClientSessionModel> clientSessionStore) {+        this.session = session;+        this.userSessionStore = userSessionStore;+        this.clientSessionStore = clientSessionStore;+        userSessionTx = userSessionStore.createTransaction(session);+        clientSessionTx = clientSessionStore.createTransaction(session);++        session.getTransactionManager().enlistAfterCompletion(userSessionTx);+        session.getTransactionManager().enlistAfterCompletion(clientSessionTx);+    }++    private Function<MapUserSessionEntity, UserSessionModel> userEntityToAdapterFunc(RealmModel realm) {+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller+        return (origEntity) -> {+            if (origEntity.getExpiration() <= Time.currentTime()) {","I was thinking whether it would be possible to check this in MapKeycloakTransaction in a similar way as removing clientSessions automatically. On the other hand, I am not sure something similar can be done in database. WDYT?What I am afraid of here, is that we will use an obtained entity for something that wouldn't be done if it was removed with `removeExpired` method. In other words this can be too late for checking expiration time in some cases? WDYT? Does this concern make sense?For example, look at these lines:https://github.com/keycloak/keycloak/blob/472e9937cf288ff9f4d289d56ff8183a81235572/model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java#L470-L478`getOfflineUserSessionEntityStream` is not checking whether the userSession is expired or not, this means that line 472 is executed even though with the previous implementation (`removeExpired` was removing all expired sessions) was not. ",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7940,620147134,2021-04-26T09:55:54Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/BasicConsoleTest.java,"@@ -37,4 +44,29 @@ public void testPostWindowMessage() throws InterruptedException {         assertEquals(""Expected window not to have reloaded"", ""check"", result);     } +    @Test+    // KEYCLOAK-17387+    public void testUserWithViewUsersRoleCanOpenConsole() {+        UserRepresentation userRepresentation = createTestUserWithViewUsersRole();+        try {+            loginToTestRealmConsoleAs(userRepresentation);","Thanks for the update!I think we should do this in a more robust way. If some AJAX is still processing and we fetch the current URL, it might be unchanged. We should use the helper methods we have for this and ideally also create a Forbidden Page Object. Something like this:https://github.com/keycloak/keycloak/blob/005801126570d857338e23198c65069a1ab2455e/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/OfflineServletsAdapterTest.java#L106Sorry to bother you with this. :) UI tests can be sometimes tricky.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7844,620173137,2021-04-26T10:33:10Z,model/map/src/main/java/org/keycloak/models/map/userSession/SessionExpiration.java,"@@ -0,0 +1,153 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.keycloak.common.util.Time;+import org.keycloak.models.ClientModel;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.OIDCConfigAttributes;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class SessionExpiration {",This seems similar to what we are doing here: https://github.com/keycloak/keycloak/blob/8255cba930196a53d0274be3a1f22b7e39df9c4f/services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java#L701 should we reuse? Maybe in a follow-up task?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7844,620194714,2021-04-26T11:06:09Z,model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java,"@@ -388,7 +388,7 @@ public void execute() {                          Predicate<? super V> entityFilter = mmcb.getEntityFilter();             Predicate<? super K> keyFilter = ((MapModelCriteriaBuilder) mcb).getKeyFilter();-            return v -> v != null && ! (keyFilter.test(v.getId()) && entityFilter.test(v));+            return v -> v == null || ! (keyFilter.test(v.getId()) && entityFilter.test(v));","This method returns a filter for objects that are not deleted by this `BulkDeleteOperation`. This is used to filter out pending tasks in the transaction that are not affected by this `BulkDeleteOperation`, and remove those that are (optimization on deletes).`v` in this case is the entity after performing a pending operation, and in case of _delete_ operation this is `null`.Hence bulk deletes were ""optimized"", i.e. replaced, by a subsequent `BulkDeleteOperation`, effectively ignoring the fact that the deleted objects could have been disjoint.This is softening the condition: if the object has been removed by a previous operation, i.e. is `null`, do not remove the task. This fixes functional bug at a little cost of performance.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7844,620375706,2021-04-26T14:54:22Z,model/map/src/main/java/org/keycloak/models/map/userSession/SessionExpiration.java,"@@ -0,0 +1,153 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.userSession;++import org.keycloak.common.util.Time;+import org.keycloak.models.ClientModel;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.OIDCConfigAttributes;++/**+ * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>+ */+public class SessionExpiration {",yeah it's quite similar but not exactly the same. After some refactoring it could be probably re-used. But I vote to do it as follow up :),
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7972,623688303,2021-04-30T07:56:59Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -71,28 +73,39 @@     UserModel getServiceAccount(ClientModel client);      /**-     * @deprecated Use {@link #getUsersStream(RealmModel, boolean) getUsersStream} instead.+     * @deprecated Use {@link UserQueryProvider#searchForUserStream(RealmModel, Map)} with+     * {@link UserModel#INCLUDE_SERVICE_ACCOUNT} within params instead.      */     @Deprecated-    List<UserModel> getUsers(RealmModel realm, boolean includeServiceAccounts);+    default List<UserModel> getUsers(RealmModel realm, boolean includeServiceAccounts) {+        return this.getUsersStream(realm, includeServiceAccounts).collect(Collectors.toList());+    }      /**      * Obtains the users associated with the specified realm.      *      * @param realm a reference to the realm being used for the search.      * @param includeServiceAccounts {@code true} if service accounts should be included in the result; {@code false} otherwise.      * @return a non-null {@link Stream} of users associated withe the realm.+     *+     * @deprecated Use {@link UserQueryProvider#searchForUserStream(RealmModel, Map, Integer, Integer)} with","```suggestion     * @deprecated Use {@link UserQueryProvider#searchForUserStream(RealmModel, Map)} with```",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/7972,623704060,2021-04-30T08:24:41Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -408,23 +426,5 @@ default UserModel getUserByFederatedIdentity(FederatedIdentityModel socialLink,          @Override         Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId);--        @Override-        default List<UserModel> getUsers(RealmModel realm, boolean includeServiceAccounts) {-            return this.getUsersStream(realm, includeServiceAccounts).collect(Collectors.toList());-        }--        @Override-        default Stream<UserModel> getUsersStream(RealmModel realm, boolean includeServiceAccounts) {-            return getUsersStream(realm, null, null, includeServiceAccounts);-        }--        @Override-        default List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {-            return this.getUsersStream(realm, firstResult, maxResults, includeServiceAccounts).collect(Collectors.toList());-        }--        @Override-        Stream<UserModel> getUsersStream(RealmModel realm, Integer firstResult, Integer maxResults, boolean includeServiceAccounts);",Can we just delete these methods? Shouldn't they be deprecated first?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7883,624937170,2021-05-03T08:08:15Z,distribution/server-dist/src/main/docs/examples/map-storage-concurrenthashmap.cli,"@@ -0,0 +1,14 @@+embed-server++/subsystem=keycloak-server/spi=authenticationSessions:add(default-provider=map)+/subsystem=keycloak-server/spi=client:add(default-provider=map)+/subsystem=keycloak-server/spi=clientScope:add(default-provider=map)+/subsystem=keycloak-server/spi=group:add(default-provider=map)+# /subsystem=keycloak-server/spi=realm:add(default-provider=map)+/subsystem=keycloak-server/spi=role:add(default-provider=map)+/subsystem=keycloak-server/spi=user:add(default-provider=map)++/subsystem=keycloak-server/spi=mapStorage:add(default-provider=concurrenthashmap)+/subsystem=keycloak-server/spi=mapStorage/provider=concurrenthashmap:add(properties={dir=""${jboss.server.data.dir}/map""},enabled=true)","Looking through the code, it's not that easy. Disabling `jpa` provider leads to an exception on startup, so I'd rather keep it as is - map storage it is a preview feature and the user federation will be updated to tree store soon anyway.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7986,624952423,2021-05-03T08:40:25Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/events/ClientRemovedEvent.java,"@@ -45,8 +47,11 @@     private String realmId;     // roleId -> roleName     private Map<String, String> clientRoles;+    private static final Logger log = Logger.getLogger(ClientRemovedEvent.class);","I'd rather keep this as limited as possible to keep the event objects as small as possible in memory, and in doing so I prefer the approach chosen in https://github.com/stianst/keycloak/blob/ec09ebac93c9e2491845ad4b26888bb558069b89/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/events/ClientRemovedEvent.java - to pick a single event. I only lowered the level from info to trace.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7883,625081595,2021-05-03T13:22:49Z,distribution/server-dist/src/main/docs/examples/map-storage-concurrenthashmap.cli,"@@ -0,0 +1,35 @@+##+## CLI script to set Keycloak to use map storage rather than the standard JPA.+## The backend database is at this moment a ConcurrentHashMap-based storage+## which is suitable for dev and testing in standalone node. It does not+## support clustered deployments.+##+## Apply this file using the following command from the Keycloak root directory:+##+##   bin/jboss-cli.sh --file=docs/examples/map-storage-concurrenthashmap.cli+##+## This will modify standalone/configuration/standalone.xml+##++embed-server++/subsystem=keycloak-server/spi=authorizationPersister:add(default-provider=map)",Should we add a possibility to configure default-provider using env variable similarly as we have for undertow?Something like:```suggestion/subsystem=keycloak-server/spi=authorizationPersister:add(default-provider=${keycloak.authorization.provider:map})```This way it is easier to use map storage only for `userSessions` for example.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7817,625602180,2021-05-04T08:33:15Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -362,9 +385,62 @@ public Response export(UriInfo uriInfo, RealmModel realm, String format) {                         }                     }); -            String descriptor = SPMetadataDescriptor.getSPDescriptor(authnBinding, endpoint, endpoint,-              wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,-              entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);+            // Prepare the metadata descriptor model+            StringWriter sw = new StringWriter();+            XMLStreamWriter writer = StaxUtil.getXMLStreamWriter(sw);+            SAMLMetadataWriter metadataWriter = new SAMLMetadataWriter(writer);++            EntityDescriptorType entityDescriptor = SPMetadataDescriptor.buildSPdescriptor(+                authnBinding, authnBinding, endpoint, endpoint,+                wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,+                entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);++            // Create the AttributeConsumingService+            AttributeConsumingServiceType attributeConsumingService = new AttributeConsumingServiceType(attributeConsumingServiceIndex);+            attributeConsumingService.setIsDefault(true);++            if (attributeConsumingServiceName != null && attributeConsumingServiceName.length() > 0)+            {+                String currentLocale = realm.getDefaultLocale() == null ? ""en"": realm.getDefaultLocale();+                LocalizedNameType attributeConsumingServiceNameElement = new LocalizedNameType(currentLocale);+                attributeConsumingServiceNameElement.setValue(attributeConsumingServiceName);+                attributeConsumingService.addServiceName(attributeConsumingServiceNameElement);+            }++            // Add the attribute mappers+            for (IdentityProviderMapperModel attributeMapper: lstAttributeMappers) {+                // Skip attributes with no name+                String attributeName = attributeMapper.getConfig().get(UserAttributeMapper.ATTRIBUTE_NAME);","This is specific code only for UserAttributeMapper. Maybe it should be part of mapper code itself. I have an idea but I am not sure this makes sense @hmlnarik could you confirm, whether it makes sense?We could have some interface like `SamlMapperWithRequestedAttribute` with only method:```RequestedAttributeType getRequestedAttribute();```Then we could have something like this in the code to generate `attributeConsumingService`.```realm.getIdentityProviderMappersByAlias(getConfig().getAlias())                    .stream()                    .filter(mapper -> mapper instanceof ProtocolMapper)                    .map(SamlMapperWithRequestedAttribute.class::cast)                    .map(SamlMapperWithRequestedAttribute::getRequestedAttribute)                    .forEach(attributeConsumingService::addRequestedAttribute);```WDYT?",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/7901,625780217,2021-05-04T13:27:28Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -1739,6 +1767,22 @@                 }             };         }++        function parseJSON(json_string, default_val) {+            try {+                return JSON.parse(json_string);+            } catch (error) {+                return default_val;+            }+        }++        function createError(error, error_description) {","Instead of making the error that is returned here a Object I'd much rather see specific instances of the `Error` class. I know that in some other places in the code this is already done with Objects, but I would consider it a bad practice.For example:```tspromise.setError(new Error('Keycloak server is not reachable, most likely due to network problems.'));```",
4266693,afedotov,https://api.github.com/repos/keycloak/keycloak/pulls/7901,626503473,2021-05-05T12:02:25Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -1739,6 +1767,22 @@                 }             };         }++        function parseJSON(json_string, default_val) {+            try {+                return JSON.parse(json_string);+            } catch (error) {+                return default_val;+            }+        }++        function createError(error, error_description) {","Hi, @jonkoops !We can't use canonical JS Error objects now in JS Adapter because of:- It will break contract specified in [keycloak.d.ts](https://github.com/keycloak/keycloak/blob/master/adapters/oidc/js/src/main/resources/keycloak.d.ts) TypeScript API, that states that in case of error KeycloakError should be returned- @mhajas told that there is no place for now in JS Adapter where native Error objects used, and feared about compatibility issues.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7952,627174555,2021-05-06T08:02:54Z,model/map/src/main/java/org/keycloak/models/map/authorization/MapAuthorizationStoreFactory.java,"@@ -26,32 +26,51 @@ import org.keycloak.authorization.model.Scope; import org.keycloak.authorization.store.AuthorizationStoreFactory; import org.keycloak.authorization.store.StoreFactory;+import org.keycloak.common.Profile;+import org.keycloak.component.AmphibianProviderFactory; import org.keycloak.models.KeycloakSession;-import org.keycloak.models.KeycloakSessionFactory; import org.keycloak.models.map.authorization.entity.MapPermissionTicketEntity; import org.keycloak.models.map.authorization.entity.MapPolicyEntity; import org.keycloak.models.map.authorization.entity.MapResourceEntity; import org.keycloak.models.map.authorization.entity.MapResourceServerEntity; import org.keycloak.models.map.authorization.entity.MapScopeEntity;+import org.keycloak.models.map.common.AbstractMapProviderFactory; import org.keycloak.models.map.storage.MapStorage; import org.keycloak.models.map.storage.MapStorageProvider;--import java.util.UUID;+import org.keycloak.models.map.storage.MapStorageProviderFactory;+import org.keycloak.models.map.storage.MapStorageSpi;+import org.keycloak.provider.EnvironmentDependentProviderFactory;+import static org.keycloak.models.utils.KeycloakModelUtils.getComponentFactory;  /**  * @author mhajas  */-public class MapAuthorizationStoreFactory implements AuthorizationStoreFactory {+public class MapAuthorizationStoreFactory<K> implements AmphibianProviderFactory<StoreFactory>, AuthorizationStoreFactory, EnvironmentDependentProviderFactory {",Unused parameter K?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7952,627234566,2021-05-06T09:12:54Z,distribution/server-dist/src/main/docs/examples/map-storage-concurrenthashmap.cli,"@@ -30,6 +32,6 @@ embed-server /subsystem=keycloak-server/spi=userSessions:add(default-provider=map)  /subsystem=keycloak-server/spi=mapStorage:add(default-provider=concurrenthashmap)-/subsystem=keycloak-server/spi=mapStorage/provider=concurrenthashmap:add(properties={dir=""${jboss.server.data.dir}/map""},enabled=true)+/subsystem=keycloak-server/spi=mapStorage/provider=concurrenthashmap:add(properties={dir=""${jboss.server.data.dir}/map"",keyType.realms=string,keyType.authz-resource-servers=string},enabled=true)",there is this settings here https://github.com/keycloak/keycloak/blob/d80891637ca223635748dce4202880e860de209d/testsuite/integration-arquillian/tests/base/src/test/resources/META-INF/keycloak-server.json#L86-L87,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8010,627961404,2021-05-07T06:31:59Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureSigningAlgorithmForSignedJwtEnforceExecutor.java,"@@ -84,7 +83,12 @@ public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyExcep             case TOKEN_INTROSPECT:             case LOGOUT_REQUEST:                 boolean isRequireClientAssertion = Optional.ofNullable(configuration.isRequireClientAssertion()).orElse(Boolean.FALSE).booleanValue();-                if (!isRequireClientAssertion) break;+                String authenticatorType = session.getContext().getClient().getClientAuthenticatorType();+                if (!isRequireClientAssertion && !JWTClientAuthenticator.PROVIDER_ID.equals(authenticatorType)) {","One small nitpick: Is it possible to check if `client_assertion` parameter is present instead of enforcing `!JWTClientAuthenticator` type? Something like: ```if (!isRequireClientAssertion && ObjectUtil.isBlank(clientAssertion))```In theory, if someone wants to create his own subclass of JWTClientAuthenticator (with slightly modified behaviour for some better security etc), he won't be able to use this executor if we directly enforce type of authenticator. ",
16761934,lscorcia,https://api.github.com/repos/keycloak/keycloak/pulls/7817,628778158,2021-05-08T17:56:00Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcSamlSpDescriptorTest.java,"@@ -0,0 +1,99 @@+package org.keycloak.testsuite.broker;++import com.google.common.collect.ImmutableMap;++import org.apache.tools.ant.filters.StringInputStream;+import org.junit.Test;+import org.keycloak.broker.saml.SAMLIdentityProviderConfig;+import org.keycloak.broker.saml.mappers.UserAttributeMapper;+import org.keycloak.dom.saml.v2.metadata.EntityDescriptorType;+import org.keycloak.dom.saml.v2.metadata.SPSSODescriptorType;+import org.keycloak.models.IdentityProviderMapperModel;+import org.keycloak.models.IdentityProviderMapperSyncMode;+import org.keycloak.representations.idm.IdentityProviderMapperRepresentation;+import org.keycloak.saml.common.exceptions.ParsingException;+import org.keycloak.saml.processing.core.parsers.saml.SAMLParser;+import org.keycloak.testsuite.updaters.IdentityProviderAttributeUpdater;++import java.io.Closeable;+import java.io.IOException;+import java.net.URISyntaxException;++import static org.hamcrest.MatcherAssert.assertThat;+import static org.hamcrest.Matchers.is;++public class KcSamlSpDescriptorTest extends AbstractBrokerTest {++    @Override+    protected BrokerConfiguration getBrokerConfiguration() {+        return KcSamlBrokerConfiguration.INSTANCE;+    }++    @Test+    public void testAttributeConsumingServiceIndexInSpMetadata() throws IOException, ParsingException, URISyntaxException {+        try (Closeable idpUpdater = new IdentityProviderAttributeUpdater(identityProviderResource)+            .setAttribute(SAMLIdentityProviderConfig.ATTRIBUTE_CONSUMING_SERVICE_INDEX, ""15"")+            .update())+        {++            String spDescriptorString = identityProviderResource.export(null).readEntity(String.class);+            SAMLParser parser = SAMLParser.getInstance();+            EntityDescriptorType o = (EntityDescriptorType) parser.parse(new StringInputStream(spDescriptorString));+            SPSSODescriptorType spDescriptor = o.getChoiceType().get(0).getDescriptors().get(0).getSpDescriptor();++            assertThat(spDescriptor.getAttributeConsumingService().isEmpty(), is(false));+            assertThat(spDescriptor.getAttributeConsumingService().get(0).getIndex(), is(15));+        }+    }++    @Test+    public void testAttributeConsumingServiceNameInSpMetadata() throws IOException, ParsingException, URISyntaxException {+        try (Closeable idpUpdater = new IdentityProviderAttributeUpdater(identityProviderResource)+            .setAttribute(SAMLIdentityProviderConfig.ATTRIBUTE_CONSUMING_SERVICE_NAME, ""My Attribute Set"")+            .update())+        {++            String spDescriptorString = identityProviderResource.export(null).readEntity(String.class);+            SAMLParser parser = SAMLParser.getInstance();+            EntityDescriptorType o = (EntityDescriptorType) parser.parse(new StringInputStream(spDescriptorString));+            SPSSODescriptorType spDescriptor = o.getChoiceType().get(0).getDescriptors().get(0).getSpDescriptor();++            assertThat(spDescriptor.getAttributeConsumingService().isEmpty(), is(false));+            assertThat(spDescriptor.getAttributeConsumingService().get(0).getServiceName().get(0).getValue(), is(""My Attribute Set""));+        }+    }++    @Test+    public void testAttributeConsumingServiceMappersInSpMetadata() throws IOException, ParsingException, URISyntaxException {+        try (Closeable idpUpdater = new IdentityProviderAttributeUpdater(identityProviderResource)+            .setAttribute(SAMLIdentityProviderConfig.ATTRIBUTE_CONSUMING_SERVICE_INDEX, ""12"")+            .update())+        {+            IdentityProviderMapperRepresentation attrMapperEmail = new IdentityProviderMapperRepresentation();+            attrMapperEmail.setName(""attribute-mapper-email"");+            attrMapperEmail.setIdentityProviderMapper(UserAttributeMapper.PROVIDER_ID);+            attrMapperEmail.setConfig(ImmutableMap.<String,String>builder()+              .put(IdentityProviderMapperModel.SYNC_MODE, IdentityProviderMapperSyncMode.INHERIT.toString())+              .put(UserAttributeMapper.ATTRIBUTE_NAME, ""email_attr_name"")+              .put(UserAttributeMapper.ATTRIBUTE_FRIENDLY_NAME, ""email_attr_friendlyname"")+              .put(UserAttributeMapper.USER_ATTRIBUTE, ""email"")+              .build());+            attrMapperEmail.setIdentityProviderAlias(bc.getIDPAlias());++            identityProviderResource.addMapper(attrMapperEmail);","Uhm, I tried adding the code you suggested, but I get a 404 Not Found while running the cleanup routine:```12:59:04,570 INFO  [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] [KcSamlSpDescriptorTest] testAttributeConsumingServiceMappersInSpMetadata() STARTED12:59:04,783 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] loading test realms12:59:04,785 INFO  [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] importing test realms12:59:04,786 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] --importing realm: consumer12:59:05,423 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] --importing realm: provider12:59:05,692 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] creating user for realm provider12:59:05,909 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] adding identity provider to realm consumer12:59:05,999 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] adding client https://localhost:8543/auth/realms/consumer to realm provider12:59:06,022 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] adding client http://localhost:8280/sales-post/ to realm consumer12:59:06,062 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] adding client http://localhost:8280/sales-post/.dot/ted to realm consumer12:59:06,086 DEBUG [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] adding client broker-app to realm consumer12:59:06,851 INFO  [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] calling all TestCleanup12:59:06,863 ERROR [org.keycloak.testsuite.broker.KcSamlSpDescriptorTest] failed cleanup!javax.ws.rs.NotFoundException: HTTP 404 Not Found	at org.jboss.resteasy.client.jaxrs.internal.ClientInvocation.handleErrorStatus(ClientInvocation.java:247)	at org.jboss.resteasy.client.jaxrs.internal.proxy.extractors.DefaultEntityExtractorFactory$3.extractEntity(DefaultEntityExtractorFactory.java:50)	at org.jboss.resteasy.client.jaxrs.internal.proxy.ClientInvoker.invokeSync(ClientInvoker.java:154)	at org.jboss.resteasy.client.jaxrs.internal.proxy.ClientInvoker.invoke(ClientInvoker.java:115)	at org.jboss.resteasy.client.jaxrs.internal.proxy.ClientProxy.invoke(ClientProxy.java:76)	at com.sun.proxy.$Proxy149.delete(Unknown Source)	at org.keycloak.testsuite.broker.KcSamlSpDescriptorTest.lambda$testAttributeConsumingServiceMappersInSpMetadata$1(KcSamlSpDescriptorTest.java:91)	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658)	at org.keycloak.testsuite.util.TestCleanup.executeCleanup(TestCleanup.java:130)	at org.keycloak.testsuite.AbstractKeycloakTest.afterAbstractKeycloakTest(AbstractKeycloakTest.java:218)...```I also tried to move the call to retrieve the mapperId inside the cleanup routine, but I get the same 404 when retrieving the mapper ID:```javax.ws.rs.NotFoundException: HTTP 404 Not Found	at org.jboss.resteasy.client.jaxrs.internal.ClientInvocation.handleErrorStatus(ClientInvocation.java:247)	at org.jboss.resteasy.client.jaxrs.internal.ClientInvocation.extractResult(ClientInvocation.java:217)	at org.jboss.resteasy.client.jaxrs.internal.proxy.extractors.BodyEntityExtractor.extractEntity(BodyEntityExtractor.java:64)	at org.jboss.resteasy.client.jaxrs.internal.proxy.ClientInvoker.invokeSync(ClientInvoker.java:154)	at org.jboss.resteasy.client.jaxrs.internal.proxy.ClientInvoker.invoke(ClientInvoker.java:115)	at org.jboss.resteasy.client.jaxrs.internal.proxy.ClientProxy.invoke(ClientProxy.java:76)	at com.sun.proxy.$Proxy149.getMappers(Unknown Source)	at org.keycloak.testsuite.broker.KcSamlSpDescriptorTest.lambda$testAttributeConsumingServiceMappersInSpMetadata$1(KcSamlSpDescriptorTest.java:86)```Any idea why?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7817,629248638,2021-05-10T10:31:19Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -362,9 +385,62 @@ public Response export(UriInfo uriInfo, RealmModel realm, String format) {                         }                     }); -            String descriptor = SPMetadataDescriptor.getSPDescriptor(authnBinding, endpoint, endpoint,-              wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,-              entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);+            // Prepare the metadata descriptor model+            StringWriter sw = new StringWriter();+            XMLStreamWriter writer = StaxUtil.getXMLStreamWriter(sw);+            SAMLMetadataWriter metadataWriter = new SAMLMetadataWriter(writer);++            EntityDescriptorType entityDescriptor = SPMetadataDescriptor.buildSPdescriptor(+                authnBinding, authnBinding, endpoint, endpoint,+                wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,+                entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);++            // Create the AttributeConsumingService+            AttributeConsumingServiceType attributeConsumingService = new AttributeConsumingServiceType(attributeConsumingServiceIndex);+            attributeConsumingService.setIsDefault(true);++            if (attributeConsumingServiceName != null && attributeConsumingServiceName.length() > 0)+            {+                String currentLocale = realm.getDefaultLocale() == null ? ""en"": realm.getDefaultLocale();+                LocalizedNameType attributeConsumingServiceNameElement = new LocalizedNameType(currentLocale);+                attributeConsumingServiceNameElement.setValue(attributeConsumingServiceName);+                attributeConsumingService.addServiceName(attributeConsumingServiceNameElement);+            }++            // Add the attribute mappers+            for (IdentityProviderMapperModel attributeMapper: lstAttributeMappers) {+                // Skip attributes with no name+                String attributeName = attributeMapper.getConfig().get(UserAttributeMapper.ATTRIBUTE_NAME);","Having this interface extensible to other mappers would be great. In that case though, would it be useful to keep the descriptor alteration local to the mappers? This would require allowing mappers to directly alter the `entityDescriptor` rather than supporting a single use case with adding a requested attribute while in the descriptor generation. In code terms, that would roughly mean replacing the lines 399-438 with a loop over all `IdentityProviderMapperModel`s that are instances of a (say) `SamlMetadataDescriptorUpdater` interface. This interface would contain method `updateMetadata(EntityDescriptorType descriptor)` called from this place.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7817,629889211,2021-05-11T06:46:05Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -362,9 +385,62 @@ public Response export(UriInfo uriInfo, RealmModel realm, String format) {                         }                     }); -            String descriptor = SPMetadataDescriptor.getSPDescriptor(authnBinding, endpoint, endpoint,-              wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,-              entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);+            // Prepare the metadata descriptor model+            StringWriter sw = new StringWriter();+            XMLStreamWriter writer = StaxUtil.getXMLStreamWriter(sw);+            SAMLMetadataWriter metadataWriter = new SAMLMetadataWriter(writer);++            EntityDescriptorType entityDescriptor = SPMetadataDescriptor.buildSPdescriptor(+                authnBinding, authnBinding, endpoint, endpoint,+                wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,+                entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);++            // Create the AttributeConsumingService+            AttributeConsumingServiceType attributeConsumingService = new AttributeConsumingServiceType(attributeConsumingServiceIndex);+            attributeConsumingService.setIsDefault(true);++            if (attributeConsumingServiceName != null && attributeConsumingServiceName.length() > 0)+            {+                String currentLocale = realm.getDefaultLocale() == null ? ""en"": realm.getDefaultLocale();+                LocalizedNameType attributeConsumingServiceNameElement = new LocalizedNameType(currentLocale);+                attributeConsumingServiceNameElement.setValue(attributeConsumingServiceName);+                attributeConsumingService.addServiceName(attributeConsumingServiceNameElement);+            }++            // Add the attribute mappers+            for (IdentityProviderMapperModel attributeMapper: lstAttributeMappers) {+                // Skip attributes with no name+                String attributeName = attributeMapper.getConfig().get(UserAttributeMapper.ATTRIBUTE_NAME);","Yes, it is possible to provide a custom IdP mapper. Could you elaborate why it would be problematic if it used `services` as a dependency and module import rather than e.g. `server-spi-private`? `server-spi-private` and `services` have the same level of support, and there this interface would not be part of `server-spi` as it would be a non-established feature",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7972,630865131,2021-05-12T09:08:55Z,server-spi/src/main/java/org/keycloak/models/UserProvider.java,"@@ -408,23 +426,5 @@ default UserModel getUserByFederatedIdentity(FederatedIdentityModel socialLink,          @Override         Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId);--        @Override-        default List<UserModel> getUsers(RealmModel realm, boolean includeServiceAccounts) {-            return this.getUsersStream(realm, includeServiceAccounts).collect(Collectors.toList());-        }--        @Override-        default Stream<UserModel> getUsersStream(RealmModel realm, boolean includeServiceAccounts) {-            return getUsersStream(realm, null, null, includeServiceAccounts);-        }--        @Override-        default List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {-            return this.getUsersStream(realm, firstResult, maxResults, includeServiceAccounts).collect(Collectors.toList());-        }--        @Override-        Stream<UserModel> getUsersStream(RealmModel realm, Integer firstResult, Integer maxResults, boolean includeServiceAccounts);","The last one (`Stream<UserModel> getUsersStream(RealmModel realm, Integer firstResult, Integer maxResults, boolean includeServiceAccounts);`) should remain and become deprecated, others are inherited.",
1867605,tkyjovsk,https://api.github.com/repos/keycloak/keycloak/pulls/8034,631286252,2021-05-12T18:08:46Z,quarkus/pom.xml,"@@ -36,8 +36,8 @@         <jackson.version>2.12.1</jackson.version>         <jackson.databind.version>${jackson.version}</jackson.databind.version>         <hibernate.version>5.4.29.Final</hibernate.version>-        <mysql-connector-java.version>8.0.24</mysql-connector-java.version>-        <postgresql.version>42.2.20</postgresql.version>+        <mysql-connector-java.version>8.0.23</mysql-connector-java.version>+        <postgresql.driver.version>42.2.19</postgresql.driver.version>","I thought these versions were supposed to be independent on the versions in the root POM. If not, we can remove these 2 properties from `quarkus/pom.xml` altogether.The question is should we keep the latest driver versions or the versions aligned with EAP 7.4?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8034,631630133,2021-05-13T07:46:44Z,quarkus/pom.xml,"@@ -36,8 +36,8 @@         <jackson.version>2.12.1</jackson.version>         <jackson.databind.version>${jackson.version}</jackson.databind.version>         <hibernate.version>5.4.29.Final</hibernate.version>-        <mysql-connector-java.version>8.0.24</mysql-connector-java.version>-        <postgresql.version>42.2.20</postgresql.version>+        <mysql-connector-java.version>8.0.23</mysql-connector-java.version>+        <postgresql.driver.version>42.2.19</postgresql.driver.version>","@tkyjovsk Please keep the versions independent for the time being, and do not change those.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8039,632330904,2021-05-14T07:09:29Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/TokenIntrospectionTest.java,"@@ -471,6 +471,57 @@ public void testIntrospectionRequestParamsMoreThanOnce() throws Exception {         assertEquals(OAuthErrorException.INVALID_REQUEST, errorRep.getError());     } +    @Test+    public void testIntrospectRevokeRefreshToken() throws Exception {",Both structures of `testIntrospectRevokeRefreshToken` and `testIntrospectRevokeOfflineToken` are similar. It might be good if duplicated codes are removed.,
18209180,Abhishek-Govula,https://api.github.com/repos/keycloak/keycloak/pulls/8044,632996263,2021-05-15T19:20:06Z,adapters/oidc/js/src/main/resources/keycloak.js,"@@ -1036,28 +1036,41 @@             }         } -        function decodeToken(str) {-            str = str.split('.')[1];--            str = str.replace(/-/g, '+');-            str = str.replace(/_/g, '/');-            switch (str.length % 4) {-                case 0:-                    break;-                case 2:-                    str += '==';-                    break;-                case 3:-                    str += '=';-                    break;-                default:-                    throw 'Invalid token';+        function decodeToken(token) {+            var base64TokenPayload = token.split('.')[1];+            if (!base64TokenPayload) throw new Error('Invalid Token');+            try {+                var base64Corrected = base64TokenPayload.replace(/-/g, ""+"").replace(/_/g, ""/"");+                switch (base64Corrected.length % 4) {+                    case 0:+                        break;+                    case 2:+                        base64Corrected += ""=="";+                        break;+                    case 3:+                        base64Corrected += ""="";+                        break;+                    default:+                        throw ""Illegal base64url string!"";+                }+                return JSON.parse(+                    decodeURIComponent(+                        atob(base64Corrected)+                        .replace(/(.)/g, function(m, p) {",Changed the deprecated escape() method,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8040,633285806,2021-05-17T07:29:25Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/membership/MembershipType.java,"@@ -96,23 +99,19 @@                     usernames.add(username);                 }             } else {-                LDAPQuery query = LDAPUtils.createQueryForUserSearch(ldapProvider, realm);-                LDAPQueryConditionsBuilder conditionsBuilder = new LDAPQueryConditionsBuilder();-                List<Condition> orSubconditions = new ArrayList<>();                 for (LDAPDn userDn : dns) {-                    String firstRdnAttrValue = userDn.getFirstRdn().getAttrValue(ldapConfig.getRdnLdapAttribute());-                    if (firstRdnAttrValue != null) {-                        Condition condition = conditionsBuilder.equal(ldapConfig.getRdnLdapAttribute(), firstRdnAttrValue, EscapeStrategy.DEFAULT);-                        orSubconditions.add(condition);+                    try {+                        // the userDn is below the configured usersDn for sure, getLDAPMembersWithParent ensures that+                        LDAPQuery query = LDAPUtils.createQueryForUserSearchUsingBaseDN(ldapProvider, realm, userDn.toString());","@rmartinc I am not 100% sure about the performance of this as it seems that for group with 500 members, we will have 500 separate queries to LDAP if I understand correctly? By default, admin console uses 5, so performance is likely not so big concern, but admin REST api itself can be always used with much bigger value like 500 or so...Maybe too naive approach, but won't it be sufficient to keep the original approach and just filter the duplicates as something like this?```    List<Integer> usernamesWithoutDuplicates = usernames.stream()     .distinct()     .collect(Collectors.toList());```This can make sure that search will return 5 users instead of 6 (In case of limit 5) and hence maybe should be fine? WDYT?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7887,633606394,2021-05-17T14:57:07Z,services/src/main/java/org/keycloak/services/DefaultKeycloakSession.java,"@@ -389,8 +388,8 @@ public UserCredentialManager userCredentialManager() {     @Override     public <T extends Provider> Set<T> getAllProviders(Class<T> clazz) {",Can we revert changes to this class?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7887,633606630,2021-05-17T14:57:24Z,server-spi/src/main/java/org/keycloak/models/KeycloakSession.java,"@@ -20,7 +20,6 @@ import org.keycloak.component.ComponentModel; import org.keycloak.models.cache.UserCache; import org.keycloak.provider.InvalidationHandler;-import org.keycloak.provider.InvalidationHandler.InvalidableObjectType;",Can we revert changes to this class?,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8041,634232669,2021-05-18T10:01:58Z,services/src/main/java/org/keycloak/services/DefaultKeycloakSession.java,"@@ -337,8 +338,19 @@ public UserCredentialManager userCredentialManager() {     }      @Override-    @SuppressWarnings(""unchecked"")     public <T extends Provider> T getComponentProvider(Class<T> clazz, String componentId) {+        final RealmModel realm = getContext().getRealm();+        if (realm == null) {+            throw new IllegalArgumentException(""Realm not set in the context."");+        }++        // Loads componentModel from the realm+        return this.getComponentProvider(clazz, componentId, KeycloakModelUtils.componentModelGetter(realm.getId(), componentId));+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public <T extends Provider> T getComponentProvider(Class<T> clazz, String componentId, Function<KeycloakSessionFactory, ComponentModel> modelGetter) {         Integer hash = clazz.hashCode() + componentId.hashCode();","@mposolda I've re-considered this comment and concluded there is no problem.Consider``` H = hash(A) + hash(B)```I was afraid that accidentally A' and B' are created that satisfy the following and such several pairs of A' and B' exist. ```H = hash(A') + hash(B')```However, consider``` H' := H - hash(A')  H' = hash(B')```which means that the probability of arising this situation is equal to that of colliding a single integer's hash value with other integer's hash value.If H consists of sum of N hash values of an integer (N >=2),  it follows the statement just above.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/8054,634958119,2021-05-19T06:50:28Z,.github/workflows/codeql-analysis.yml,"@@ -32,6 +36,10 @@ jobs:     - name: Checkout repository       uses: actions/checkout@v2 +    - uses: whelk-io/maven-settings-xml-action@v15","I haven't done a line-by-line review, but the action seems pretty simple and straightforward. First, it [prepares in-memory maven xml](https://github.com/whelk-io/maven-settings-xml-action/blob/v15/src/settings.js) based on a [predefined template](https://github.com/whelk-io/maven-settings-xml-action/blob/v15/template/settings.xml), and then it [writes it to the .m2 dir](https://github.com/whelk-io/maven-settings-xml-action/blob/v15/src/index.js). Doesn't seem dangerous.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/8052,636008543,2021-05-20T11:19:12Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaClientProviderFactory.java,"@@ -36,19 +37,22 @@      private Set<String> clientSearchableAttributes = null; +    private static final List<String> REQUIRED_SEARCHABLE_ATTRIBUTES = Arrays.asList(+      ""saml_idp_initiated_sso_url_name""+    );","I wonder whether we should extract the default searchable attributes and make it independent from the JPA provider. I know JPA is currently the only one currently using the searchable attributes option, but that might change...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8039,637792275,2021-05-24T08:53:21Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -276,6 +283,25 @@ public boolean checkTokenValidForIntrospection(KeycloakSession session, RealmMod         return valid;     } +    private boolean checkRevokedToken(KeycloakSession session, RealmModel realm, AccessToken token) {+        UserSessionModel userSession = null;+        if (token.getType().equals(TokenUtil.TOKEN_TYPE_REFRESH)) {+            userSession = session.sessions().getUserSession(realm, token.getSessionState());+        } else {+            UserSessionManager sessionManager = new UserSessionManager(session);+            userSession = sessionManager.findOfflineUserSession(realm, token.getSessionState());+        }++        ClientModel client = realm.getClientByClientId(token.getIssuedFor());+        AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());","Few points:- It will be good to check if `clientSession.getCurrentRefreshToken()` matches with the current refresh token? As otherwise it may be still possible to have the scenario when incorrect refreshToken return `active: true` even if it should not.- Another example: I am not sure if it can happen that the correct refresh token returns `active: false` even if it should be considered active.Some example scenario to demonstrate these possible issues:- Max Reuse is set to 2- Refresh token A is issued from the authentication- Refresh with Refresh Token A happens. So `clientSession.currentRefreshToken` is set to A and `clientSession.currentRefreshTokenMaxReuse` is set to 1. New refresh token B is issued- Another refresh with refresh token A happens. So `clientSession.currentRefreshToken` is still A and `clientSession.currentRefreshTokenMaxReuse` is set to 0. New refresh token C is issued- Introspection with C is called. I think it should be successful as token refresh would be successful as well. But it looks to me, that introspection won't be successful with your changes?- Now refresh with token C is called. `clientSession.currentRefreshToken` will be updated to C and `lientSession.currentRefreshTokenMaxReuse` will be updated to 1.- Introspection with token A is called. I think it should not be successful anymore, however I think that with your changes it will be successful (due the fact that clientSession.currentRefreshTokenMaxReuse is set to 1.I think it will be good to cover the test scenario I added above.Also I think that it will be good if the code for check of valid refresh token during introspection is not duplicated, but it re-uses same method, which is also used by the refresh token. Which is method `TokenManager.validateTokenReuse` . This will make sure that token refresh and token introspection will really use same algorithm and will be in sync with each other. Does it makes sense to you?",
69030207,Michito-Okai,https://api.github.com/repos/keycloak/keycloak/pulls/8039,638653442,2021-05-25T10:16:20Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -276,6 +283,25 @@ public boolean checkTokenValidForIntrospection(KeycloakSession session, RealmMod         return valid;     } +    private boolean checkRevokedToken(KeycloakSession session, RealmModel realm, AccessToken token) {+        UserSessionModel userSession = null;+        if (token.getType().equals(TokenUtil.TOKEN_TYPE_REFRESH)) {+            userSession = session.sessions().getUserSession(realm, token.getSessionState());+        } else {+            UserSessionManager sessionManager = new UserSessionManager(session);+            userSession = sessionManager.findOfflineUserSession(realm, token.getSessionState());+        }++        ClientModel client = realm.getClientByClientId(token.getIssuedFor());+        AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());","@mposolda > Few points:> > * It will be good to check if `clientSession.getCurrentRefreshToken()` matches with the current refresh token? As otherwise it may be still possible to have the scenario when incorrect refreshToken return `active: true` even if it should not.> * Another example: I am not sure if it can happen that the correct refresh token returns `active: false` even if it should be considered active.> > Some example scenario to demonstrate these possible issues:> > * Max Reuse is set to 2> * Refresh token A is issued from the authentication> * Refresh with Refresh Token A happens. So `clientSession.currentRefreshToken` is set to A and `clientSession.currentRefreshTokenMaxReuse` is set to 1. New refresh token B is issued> * Another refresh with refresh token A happens. So `clientSession.currentRefreshToken` is still A and `clientSession.currentRefreshTokenMaxReuse` is set to 0. New refresh token C is issued> * Introspection with C is called. I think it should be successful as token refresh would be successful as well. But it looks to me, that introspection won't be successful with your changes?> * Now refresh with token C is called. `clientSession.currentRefreshToken` will be updated to C and `lientSession.currentRefreshTokenMaxReuse` will be updated to 1.> * Introspection with token A is called. I think it should not be successful anymore, however I think that with your changes it will be successful (due the fact that clientSession.currentRefreshTokenMaxReuse is set to 1.> > I think it will be good to cover the test scenario I added above.I see. Thank you for your explaination. > Also I think that it will be good if the code for check of valid refresh token during introspection is not duplicated, but it re-uses same method, which is also used by the refresh token. Which is method `TokenManager.validateTokenReuse` . This will make sure that token refresh and token introspection will really use same algorithm and will be in sync with each other. Does it makes sense to you?I see. I want to modify as the following.- Create a new method- The common process that token refresh and token introspection should share move from `TokenManager.validateTokenReuse()` to the new method.- The new method is called from `TokenManager.validateTokenReuse()` and `TokenManager.checkRevokedToken()`.What do you think?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8097,640059108,2021-05-26T19:24:59Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -1406,6 +1408,11 @@ private static ClientModel createClient(KeycloakSession session, RealmModel real             }         } +        if (""saml"".equals(resourceRep.getProtocol())","`SamlProtocol` is part of services and `RepresentationToModel` is in `server-spi-private` so it is not available there. I can create some constants class in `server-spi-private` and then reuse it everywhere, but I am not sure this is what we want.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8097,640321043,2021-05-27T06:25:15Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/clients/AbstractClientTest.java,"@@ -87,6 +89,7 @@ public static ClientRepresentation createClientRep(String clientId, String proto         attributes.put(SAML_SIGNATURE_ALGORITHM, ""RSA_SHA256"");         attributes.put(SAML_FORCE_NAME_ID_FORMAT, ""false"");         attributes.put(SAML_NAME_ID_FORMAT, ""username"");+        attributes.put(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(""saml""));","From `newClient` `ClientRepresentation` only `clientId` and `protocol` is used for creation, see [this](https://github.com/keycloak/keycloak/blob/master/testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/clients/CreateClientForm.java#L27-L31).",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8095,640585309,2021-05-27T12:42:35Z,server-spi-private/src/main/java/org/keycloak/authorization/store/syncronization/RealmSynchronizer.java,"@@ -34,17 +35,11 @@ public void synchronize(RealmRemovedEvent event, KeycloakSessionFactory factory)         ProviderFactory<AuthorizationProvider> providerFactory = factory.getProviderFactory(AuthorizationProvider.class);         AuthorizationProvider authorizationProvider = providerFactory.create(event.getKeycloakSession());         StoreFactory storeFactory = authorizationProvider.getStoreFactory();+        ResourceServerStore resourceServerStore = storeFactory.getResourceServerStore();          event.getRealm().getClientsStream().forEach(clientModel -> {-            ResourceServer resourceServer = storeFactory.getResourceServerStore().findById(clientModel.getId());--            if (resourceServer != null) {-                String id = resourceServer.getId();-                //storeFactory.getResourceStore().findByResourceServer(id).forEach(resource -> storeFactory.getResourceStore().delete(resource.getId()));-                //storeFactory.getScopeStore().findByResourceServer(id).forEach(scope -> storeFactory.getScopeStore().delete(scope.getId()));-                //storeFactory.getPolicyStore().findByResourceServer(id).forEach(scope -> storeFactory.getPolicyStore().delete(scope.getId()));-                storeFactory.getResourceServerStore().delete(id);-            }+            String id = clientModel.getId();","I want to make sure I understand this correctly. When we use `ClientModelLazyDelegate` we load only ids from the database, not all clients because we don't call the `getDelegate` method at all, right? ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8095,640638156,2021-05-27T13:44:37Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -106,11 +106,10 @@ public static RealmRepresentation exportRealm(KeycloakSession session, RealmMode          if (options.isClientsIncluded()) {             clients = realm.getClientsStream().collect(Collectors.toList());-            List<ClientRepresentation> clientReps = new ArrayList<>();-            for (ClientModel app : clients) {-                ClientRepresentation clientRep = exportClient(session, app);-                clientReps.add(clientRep);-            }+            List<ClientRepresentation> clientReps = realm.getClientsStream()","Thanks, my bad :) ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8107,642295698,2021-05-31T08:04:18Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/realm/ClientPoliciesTest.java,"@@ -0,0 +1,396 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.console.realm;++import com.fasterxml.jackson.databind.JsonNode;+import org.jboss.arquillian.graphene.page.Page;+import org.junit.After;+import org.junit.Test;+import org.keycloak.authentication.authenticators.client.ClientIdAndSecretAuthenticator;+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;+import org.keycloak.common.Profile;+import org.keycloak.representations.idm.ClientPoliciesRepresentation;+import org.keycloak.representations.idm.ClientProfilesRepresentation;+import org.keycloak.services.clientpolicy.condition.ClientAccessTypeConditionFactory;+import org.keycloak.services.clientpolicy.executor.HolderOfKeyEnforcerExecutorFactory;+import org.keycloak.services.clientpolicy.executor.SecureClientAuthenticatorExecutorFactory;+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;+import org.keycloak.testsuite.console.page.realm.clientpolicies.ClientPolicies;+import org.keycloak.testsuite.console.page.realm.clientpolicies.ClientPoliciesJson;+import org.keycloak.testsuite.console.page.realm.clientpolicies.ClientPolicy;+import org.keycloak.testsuite.console.page.realm.clientpolicies.ClientProfile;+import org.keycloak.testsuite.console.page.realm.clientpolicies.ClientProfiles;+import org.keycloak.testsuite.console.page.realm.clientpolicies.ClientProfilesJson;+import org.keycloak.testsuite.console.page.realm.clientpolicies.Condition;+import org.keycloak.testsuite.console.page.realm.clientpolicies.CreateClientPolicy;+import org.keycloak.testsuite.console.page.realm.clientpolicies.CreateClientProfile;+import org.keycloak.testsuite.console.page.realm.clientpolicies.CreateCondition;+import org.keycloak.testsuite.console.page.realm.clientpolicies.CreateExecutor;+import org.keycloak.testsuite.console.page.realm.clientpolicies.Executor;+import org.keycloak.testsuite.util.ClientPoliciesUtil.ClientPoliciesBuilder;+import org.keycloak.testsuite.util.ClientPoliciesUtil.ClientPolicyBuilder;+import org.keycloak.testsuite.util.ClientPoliciesUtil.ClientProfileBuilder;+import org.keycloak.testsuite.util.ClientPoliciesUtil.ClientProfilesBuilder;+import org.keycloak.util.JsonSerialization;++import java.util.Arrays;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import static org.junit.Assert.assertEquals;+import static org.junit.Assert.assertFalse;+import static org.junit.Assert.assertTrue;+import static org.keycloak.testsuite.util.ClientPoliciesUtil.createClientAccessTypeConditionConfig;+import static org.keycloak.testsuite.util.ClientPoliciesUtil.createHolderOfKeyEnforceExecutorConfig;+import static org.keycloak.testsuite.util.ClientPoliciesUtil.createSecureClientAuthenticatorExecutorConfig;+import static org.keycloak.testsuite.util.UIUtils.refreshPageAndWaitForLoad;++/**+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+@EnableFeature(Profile.Feature.CLIENT_POLICIES)+public class ClientPoliciesTest extends AbstractRealmTest {+    private static final String GLOBAL_PROFILE = ""global-default-profile"";","This profile was a placeholder for default profile, which was removed in https://github.com/keycloak/keycloak/pull/8093 and replaced with the proper FAPI profiles. So it seems this will need some changes to not be dependent on ""global-default-profile""",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7958,643846167,2021-06-02T10:54:17Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/idp/IdentityProviderTest.java,"@@ -128,6 +132,53 @@ public void settingAndSavingSyncMode() {         assertMapperSyncModeIsSetToImport();     } +    @Test+    public void createIdentityProviderCustomMapper() {+        createIdentityProviderPage.setProviderId(""google"");+        identityProviderPage.setIds(""google"", ""google"");++        identityProvidersPage.addProvider(""google"");+        assertCurrentUrlEquals(createIdentityProviderPage);++        createIdentityProviderPage.form().setClientId(""test-google"");+        createIdentityProviderPage.form().setClientSecret(""secret"");++        createIdentityProviderPage.form().save();+        assertAlertSuccess();+        refreshPageAndWaitForLoad();+        assertCurrentUrlEquals(identityProviderPage);++        identityProviderPage.form().createMapper();+        createIdentityProviderMapperPage.setIdp(""google"");+        assertCurrentUrlEquals(createIdentityProviderMapperPage);+        createIdentityProviderMapperPage.form().setName(""Multivalued Map"");+        createIdentityProviderMapperPage.form().setSyncMode(""import"");+        createIdentityProviderMapperPage.form().setMapperType(""Test MultiValued Mapper"");++        List<WebElement> inputs = driver.findElements(By.xpath(""//input[@ng-model='config[option.name][i]']""));+        assertEquals(1, inputs.size());++        WebElement inputMultiValue = inputs.get(0);+        assertNotNull(inputMultiValue);+        inputMultiValue.sendKeys(""firstValue"");",Please use [`setTextInputValue`](https://github.com/keycloak/keycloak/blob/316f9f46e2b542b09d67929a60922d981bb8fbd5/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/UIUtils.java#L130-L146).,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7958,643846368,2021-06-02T10:54:35Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/idp/IdentityProviderTest.java,"@@ -128,6 +132,53 @@ public void settingAndSavingSyncMode() {         assertMapperSyncModeIsSetToImport();     } +    @Test+    public void createIdentityProviderCustomMapper() {+        createIdentityProviderPage.setProviderId(""google"");+        identityProviderPage.setIds(""google"", ""google"");++        identityProvidersPage.addProvider(""google"");+        assertCurrentUrlEquals(createIdentityProviderPage);++        createIdentityProviderPage.form().setClientId(""test-google"");+        createIdentityProviderPage.form().setClientSecret(""secret"");++        createIdentityProviderPage.form().save();+        assertAlertSuccess();+        refreshPageAndWaitForLoad();+        assertCurrentUrlEquals(identityProviderPage);++        identityProviderPage.form().createMapper();+        createIdentityProviderMapperPage.setIdp(""google"");+        assertCurrentUrlEquals(createIdentityProviderMapperPage);+        createIdentityProviderMapperPage.form().setName(""Multivalued Map"");+        createIdentityProviderMapperPage.form().setSyncMode(""import"");+        createIdentityProviderMapperPage.form().setMapperType(""Test MultiValued Mapper"");++        List<WebElement> inputs = driver.findElements(By.xpath(""//input[@ng-model='config[option.name][i]']""));+        assertEquals(1, inputs.size());++        WebElement inputMultiValue = inputs.get(0);+        assertNotNull(inputMultiValue);+        inputMultiValue.sendKeys(""firstValue"");++        List<WebElement> plusButtons = driver.findElements(By.xpath(""//button[@data-ng-click='addValueToMultivalued(option.name)']""));+        assertEquals(1, plusButtons.size());++        WebElement firstPlusButton = plusButtons.get(0);+        firstPlusButton.click();++        inputs = driver.findElements(By.xpath(""//input[@ng-model='config[option.name][i]']""));+        assertEquals(2, inputs.size());++        inputMultiValue = inputs.get(1);+        inputMultiValue.sendKeys(""secondValue"");",Please use [`setTextInputValue`](https://github.com/keycloak/keycloak/blob/316f9f46e2b542b09d67929a60922d981bb8fbd5/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/UIUtils.java#L130-L146).,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7958,643976095,2021-06-02T13:43:09Z,themes/src/main/resources/theme/base/admin/resources/js/services.js,"@@ -312,7 +312,7 @@ module.factory('ComponentUtils', function() {                     config[prop.name] = configProperty;                 } -                if (configProperty.length == 0 || configProperty[configProperty.length - 1].length > 0) {+                if (configProperty.length === 0) {","TBH, I'm not sure about this change. I think it was intentional to add the extra empty line, which is now not happening in some cases. I'd leave it as it was before. (We'd just need to figure out why the extra line is not displayed after clicking ""Save"" btn.)In any case, if we made this change, we'd need to run all UI tests as it has a bigger impact, not just on IdPs.",
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/7958,644062454,2021-06-02T15:11:48Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -2817,12 +2817,7 @@ public static void createFederatedClientRoleMappings(UserFederatedStorageProvide         }          Map<String, String> m = new HashMap<>(map);-        for (Iterator<Map.Entry<String, String>> itr = m.entrySet().iterator(); itr.hasNext(); ) {-            Map.Entry<String, String> e = itr.next();-            if (e.getValue() == null || e.getValue().equals("""")) {-                itr.remove();-            }-        }+        m.entrySet().removeIf(e -> e.getValue() == null || e.getValue().equals(""""));","@vmuzikar if I'm not mistaken, by default, `removeIf` uses an iterator internally to remove the elements so the performance should be exactly the same. I specifically checked this information in the docs during my review yesterday.Moreover, some sources say that `removeIf` is more optimized and faster as it first evaluates the predicate for all items before making any alterations to the list. [1][1] https://dzone.com/articles/the-way-of-the-lambda-and-removeif",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/7958,644096107,2021-06-02T15:48:41Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -2817,12 +2817,7 @@ public static void createFederatedClientRoleMappings(UserFederatedStorageProvide         }          Map<String, String> m = new HashMap<>(map);-        for (Iterator<Map.Entry<String, String>> itr = m.entrySet().iterator(); itr.hasNext(); ) {-            Map.Entry<String, String> e = itr.next();-            if (e.getValue() == null || e.getValue().equals("""")) {-                itr.remove();-            }-        }+        m.entrySet().removeIf(e -> e.getValue() == null || e.getValue().equals(""""));","@Pepo48 I don't doubt it's much more elegant solution and maybe a little bit more optimized. :) But in general it seems to me like a bad smell that we make a change into a core code that is not actually related to the object of this PR: fixing a UI bug. I.e. it seems to me like out of scope for this PR, moreover when it can potentially affect other areas, not just IdPs.",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8117,644702976,2021-06-03T11:10:49Z,services/src/main/java/org/keycloak/userprofile/config/DeclarativeUserProfileProvider.java,"@@ -227,53 +236,77 @@ protected UserProfileMetadata decorateUserProfileForCache(UserProfileMetadata me             if (rc != null && !(UserModel.USERNAME.equals(attributeName) || UserModel.EMAIL.equals(attributeName))) {                 // do not take requirements from config for username and email as they are                 // driven by business logic from parent!--                if (rc.isAlways() || UPConfigUtils.isRoleForContext(context, rc.getRoles())) {+                required = AttributeMetadata.ALWAYS_TRUE;+                if (rc.isAlways()) {                     validators.add(createRequiredValidator(attrConfig));-                    required = AttributeMetadata.ALWAYS_TRUE;+                } else if (rc.getRoles() != null) {+                    validators.add(new AttributeValidatorMetadata(AttributeRequiredByMetadataValidator.ID,","`required` predicate is not set correctly here, so metadata used in forms are incorrect, they always mark attribute as required",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8117,644703091,2021-06-03T11:11:01Z,services/src/main/java/org/keycloak/userprofile/config/DeclarativeUserProfileProvider.java,"@@ -227,53 +236,77 @@ protected UserProfileMetadata decorateUserProfileForCache(UserProfileMetadata me             if (rc != null && !(UserModel.USERNAME.equals(attributeName) || UserModel.EMAIL.equals(attributeName))) {                 // do not take requirements from config for username and email as they are                 // driven by business logic from parent!--                if (rc.isAlways() || UPConfigUtils.isRoleForContext(context, rc.getRoles())) {+                required = AttributeMetadata.ALWAYS_TRUE;+                if (rc.isAlways()) {                     validators.add(createRequiredValidator(attrConfig));-                    required = AttributeMetadata.ALWAYS_TRUE;+                } else if (rc.getRoles() != null) {+                    validators.add(new AttributeValidatorMetadata(AttributeRequiredByMetadataValidator.ID,+                            ValidatorConfig.builder()+                                    .config(""roles"", rc.getRoles())+                                    .build()));                 } else if (UPConfigUtils.canBeAuthFlowContext(context) && rc.getScopes() != null && !rc.getScopes().isEmpty()) {                     // for contexts executed from auth flow and with configured scopes requirement                     // we have to create required validation with scopes based selector-                    required = (c) -> attributePredicateAuthFlowRequestedScope(rc.getScopes());-                    validators.add(createRequiredValidator(attrConfig));+                    validators.add(new AttributeValidatorMetadata(AttributeRequiredByMetadataValidator.ID,","`required` predicate is not set correctly here, so metadata used in forms are incorrect, they always mark attribute as required",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8130,647339425,2021-06-08T11:13:14Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -174,6 +175,11 @@ public TokenValidation validateToken(KeycloakSession session, UriInfo uriInfo, C             }         } +        if (oldToken.getIssuedAt() + 1 < clientSession.getStarted()) {",This condition seems duplicated at different places. Does it make sense to overload `AccessToken.isActive` or another method to keep this logic in a single place?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8130,648043932,2021-06-09T07:35:00Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -174,6 +175,11 @@ public TokenValidation validateToken(KeycloakSession session, UriInfo uriInfo, C             }         } +        if (oldToken.getIssuedAt() + 1 < clientSession.getStarted()) {","True. I've added method ""isIssuedBeforeSessionStart"" with the time as an argument. Also used this for few other places inside the codebase as there are similar existing checks for the userSession already existing.",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7897,648115339,2021-06-09T09:08:32Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java,"@@ -479,6 +482,25 @@ private void updateAuthenticationSession() {         if (request.getCodeChallenge() != null) authenticationSession.setClientNote(OIDCLoginProtocol.CODE_CHALLENGE_PARAM, request.getCodeChallenge());         if (request.getCodeChallengeMethod() != null) authenticationSession.setClientNote(OIDCLoginProtocol.CODE_CHALLENGE_METHOD_PARAM, request.getCodeChallengeMethod()); +        Map<String, Integer> acrLoaMap = AcrUtils.getAcrLoaMap(authenticationSession.getClient());+        List<String> acrValues = AcrUtils.getRequiredAcrValues(request.getClaims());++        if (acrValues.isEmpty()) {+            acrValues = AcrUtils.getAcrValues(request.getClaims(), request.getAcr());+        } else {+            authenticationSession.setClientNote(Constants.FORCE_LEVEL_OF_AUTHENTICATION, ""true"");+        }++        acrValues.stream().mapToInt(acr -> {+            try {+                Integer loa = acrLoaMap.get(acr);+                return loa == null ? Integer.parseInt(acr) : loa;+            } catch (NumberFormatException e) {+                // this is an unknown acr, we assume it is very high+                return Constants.MAXIMUM_LOA;","This is false based on the paragraph '5.5.1.1.  Requesting the ""acr"" Claim' of the [OpenID Connect Core Specification](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter). Keycloak implementation should follow OIDC specification.For claims with essential='true' we must do what specification says exactly. Keycloak should return an error if all essentials acrs are unknown. From specification :> If the acr Claim is requested as an Essential Claim for the ID Token with a values parameter requesting specific Authentication Context Class Reference values and the implementation supports the claims parameter, the Authorization Server MUST return an acr Claim Value that matches one of the requested values. If this is an Essential Claim and the requirement cannot be met, then the Authorization Server MUST treat that outcome as a failed authentication attempt.For other cases documentation says : >  If the Claim is not Essential and a requested value cannot be provided, the Authorization Server SHOULD return the session's current acr as the value of the acr Claim. So, I believe that for other cases Keycloak should omit  unknown acr and return as REQUESTED_LEVEL_OF_AUTHENTICATION the minimum of known acr - if any exists. ",
16761934,lscorcia,https://api.github.com/repos/keycloak/keycloak/pulls/8110,649210121,2021-06-10T13:58:19Z,services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java,"@@ -782,4 +792,62 @@ private NameIDType getSubjectNameID(final AssertionType assertion) {         SubjectType.STSubType subType = subject.getSubType();         return subType != null ? (NameIDType) subType.getBaseID() : null;     }++    private boolean validateInResponseToAttribute(Element documentElement, Element assertionElement, String expectedRequestId) {+        // If we are not expecting a request ID, don't bother+        if (expectedRequestId == null || expectedRequestId.isEmpty())+            return true; ++        // We are expecting a request ID so we are in SP-initiated login, attribute InResponseTo must be present+        if (!documentElement.hasAttribute(""InResponseTo"")) {","Replaced in tests, no longer needed in main code as it's abstracted by using `responseType`. Thanks!",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7897,649974784,2021-06-11T13:24:00Z,services/src/main/java/org/keycloak/authentication/AuthenticationSelectionResolver.java,"@@ -193,7 +193,7 @@ private static boolean addAllExecutionsFromSubflow(AuthenticationProcessor proce                  // For conditional execution, we must check if condition is true. Otherwise return false, which means trying next                 // requiredExecution in the list-                return !flow.isConditionalSubflowDisabled(ex);+                return !flow.isConditionalSubflowDisabled(ex, false);",Could you please elaborate on why not track the matching result when evaluating conditional authenticators?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7897,651208527,2021-06-14T19:13:24Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -693,6 +694,29 @@ protected AccessToken initToken(RealmModel realm, ClientModel client, UserModel         return token;     } +    private String getAcr(AuthenticatedClientSessionModel clientSession) {+        int loa = Integer.parseInt(clientSession.getNote(Constants.LEVEL_OF_AUTHENTICATION));+        if (loa < Constants.MINIMUM_LOA) {+            loa = AuthenticationManager.isSSOAuthentication(clientSession) ? 0 : 1;+        }++        Map<String, Integer> acrLoaMap = AcrUtils.getAcrLoaMap(clientSession.getClient());+        String acr = AcrUtils.mapLoaToAcr(loa, acrLoaMap, AcrUtils.getRequiredAcrValues(+            clientSession.getNote(OIDCLoginProtocol.CLAIMS_PARAM)));+        if (acr == null) {+            acr = AcrUtils.mapLoaToAcr(loa, acrLoaMap, AcrUtils.getAcrValues(+                clientSession.getNote(OIDCLoginProtocol.CLAIMS_PARAM),+                clientSession.getNote(OIDCLoginProtocol.ACR_PARAM)));+            if (acr == null) {+                acr = AcrUtils.mapLoaToAcr(loa, acrLoaMap, acrLoaMap.keySet());+                if (acr == null) {+                    acr = String.valueOf(loa);","Implementation-wise, the logic here should be enough to support that as long as the admin has bound a LoA with a value, right?W.r.t to the recommendation, we could make this more explicit in docs.The logic here is also considering setting `0` in case the user is re-authenticating (cookie-based auth).",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7970,652911354,2021-06-16T17:43:46Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java,"@@ -2133,6 +2133,103 @@ public void roleMappings() {         assertNames(roles.clientLevel(clientUuid).listAll(), ""client-composite"");     } +    /**+     * Test for KEYCLOAK-10603.+     */+    @Test+    public void rolesCanBeAssignedEvenWhenTheyAreAlreadyIndirectlyAssigned() {+        RealmResource realm = adminClient.realms().realm(""test"");++        RoleRepresentation realmCompositeRole = RoleBuilder.create().name(""realm-composite"").build();+        realm.roles().create(realmCompositeRole);+        realm.roles().create(RoleBuilder.create().name(""realm-child"").build());+        realm.roles().get(""realm-composite"")+                .addComposites(Collections.singletonList(realm.roles().get(""realm-child"").toRepresentation()));+        realm.roles().create(RoleBuilder.create().name(""realm-role-in-group"").build());++        Response response = realm.clients().create(ClientBuilder.create().clientId(""myclient"").build());+        String clientUuid = ApiUtil.getCreatedId(response);+        response.close();++        RoleRepresentation clientCompositeRole = RoleBuilder.create().name(""client-composite"").build();+        realm.clients().get(clientUuid).roles().create(clientCompositeRole);+        realm.clients().get(clientUuid).roles().create(RoleBuilder.create().name(""client-child"").build());+        realm.clients().get(clientUuid).roles().get(""client-composite"").addComposites(Collections+                .singletonList(realm.clients().get(clientUuid).roles().get(""client-child"").toRepresentation()));+        realm.clients().get(clientUuid).roles().create(RoleBuilder.create().name(""client-role-in-group"").build());++        GroupRepresentation group = GroupBuilder.create().name(""mygroup"").build();+        response = realm.groups().add(group);+        String groupId = ApiUtil.getCreatedId(response);+        response.close();++        response = realm.users().create(UserBuilder.create().username(""myuser"").build());+        String userId = ApiUtil.getCreatedId(response);+        response.close();++        // Make indirect assignments+        // .. add roles to the group and add it to the user+        realm.groups().group(groupId).roles().realmLevel()+                .add(Collections.singletonList(realm.roles().get(""realm-role-in-group"").toRepresentation()));+        realm.groups().group(groupId).roles().clientLevel(clientUuid).add(Collections+                .singletonList(realm.clients().get(clientUuid).roles().get(""client-role-in-group"").toRepresentation()));+        realm.users().get(userId).joinGroup(groupId);+        // .. assign composite roles+        RoleMappingResource userRoles = realm.users().get(userId).roles();+        userRoles.realmLevel().add(Collections.singletonList(realm.roles().get(""realm-composite"").toRepresentation()));+        userRoles.clientLevel(clientUuid).add(Collections+                .singletonList(realm.clients().get(clientUuid).roles().get(""client-composite"").toRepresentation()));++        // check state before making the direct assignments+        assertNames(userRoles.realmLevel().listAll(), ""realm-composite"", Constants.DEFAULT_ROLES_ROLE_PREFIX + ""-test"");+        assertNames(userRoles.realmLevel().listAvailable(), ""realm-child"", ""realm-role-in-group"",","Don't you think that `realm-child` here is a bit confusing and susceptible to mistakes? Admins now see that role as available, but it was granted by the composite. Although indirectly.I'm not 100% if we should deal with composite roles differently in this case. So that they are not listed as available.",
11198630,danielFesenmeyer,https://api.github.com/repos/keycloak/keycloak/pulls/7970,653287143,2021-06-17T07:09:47Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java,"@@ -2133,6 +2133,103 @@ public void roleMappings() {         assertNames(roles.clientLevel(clientUuid).listAll(), ""client-composite"");     } +    /**+     * Test for KEYCLOAK-10603.+     */+    @Test+    public void rolesCanBeAssignedEvenWhenTheyAreAlreadyIndirectlyAssigned() {+        RealmResource realm = adminClient.realms().realm(""test"");++        RoleRepresentation realmCompositeRole = RoleBuilder.create().name(""realm-composite"").build();+        realm.roles().create(realmCompositeRole);+        realm.roles().create(RoleBuilder.create().name(""realm-child"").build());+        realm.roles().get(""realm-composite"")+                .addComposites(Collections.singletonList(realm.roles().get(""realm-child"").toRepresentation()));+        realm.roles().create(RoleBuilder.create().name(""realm-role-in-group"").build());++        Response response = realm.clients().create(ClientBuilder.create().clientId(""myclient"").build());+        String clientUuid = ApiUtil.getCreatedId(response);+        response.close();++        RoleRepresentation clientCompositeRole = RoleBuilder.create().name(""client-composite"").build();+        realm.clients().get(clientUuid).roles().create(clientCompositeRole);+        realm.clients().get(clientUuid).roles().create(RoleBuilder.create().name(""client-child"").build());+        realm.clients().get(clientUuid).roles().get(""client-composite"").addComposites(Collections+                .singletonList(realm.clients().get(clientUuid).roles().get(""client-child"").toRepresentation()));+        realm.clients().get(clientUuid).roles().create(RoleBuilder.create().name(""client-role-in-group"").build());++        GroupRepresentation group = GroupBuilder.create().name(""mygroup"").build();+        response = realm.groups().add(group);+        String groupId = ApiUtil.getCreatedId(response);+        response.close();++        response = realm.users().create(UserBuilder.create().username(""myuser"").build());+        String userId = ApiUtil.getCreatedId(response);+        response.close();++        // Make indirect assignments+        // .. add roles to the group and add it to the user+        realm.groups().group(groupId).roles().realmLevel()+                .add(Collections.singletonList(realm.roles().get(""realm-role-in-group"").toRepresentation()));+        realm.groups().group(groupId).roles().clientLevel(clientUuid).add(Collections+                .singletonList(realm.clients().get(clientUuid).roles().get(""client-role-in-group"").toRepresentation()));+        realm.users().get(userId).joinGroup(groupId);+        // .. assign composite roles+        RoleMappingResource userRoles = realm.users().get(userId).roles();+        userRoles.realmLevel().add(Collections.singletonList(realm.roles().get(""realm-composite"").toRepresentation()));+        userRoles.clientLevel(clientUuid).add(Collections+                .singletonList(realm.clients().get(clientUuid).roles().get(""client-composite"").toRepresentation()));++        // check state before making the direct assignments+        assertNames(userRoles.realmLevel().listAll(), ""realm-composite"", Constants.DEFAULT_ROLES_ROLE_PREFIX + ""-test"");+        assertNames(userRoles.realmLevel().listAvailable(), ""realm-child"", ""realm-role-in-group"",","@pedroigor I agree that this might be a bit confusing, at least for users who are used to the old behaviour. But otherwise it would not be possible to assign ""realm-child"" via the UI (at least without bigger changes to the UI).Furthermore, there are other parts of the UI, where it is possible to assign indirectly assigned roles which are not directly assigned. There, similar mistakes might happen:- assigning default roles to a realm- assigning a child to a composite role",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8158,654718853,2021-06-18T23:56:13Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java,"@@ -289,6 +291,14 @@ private Response checkResponseType() {             return redirectErrorToClient(OIDCResponseMode.QUERY, OAuthErrorException.INVALID_REQUEST, ""Response_mode 'query' not allowed for implicit or hybrid flow"");         } +        if(parsedResponseType.isImplicitOrHybridFlow() && parsedResponseMode == OIDCResponseMode.QUERY_JWT &&+                (Strings.isNullOrEmpty(client.getAttribute(OIDCConfigAttributes.AUTHORIZATION_ENCRYPTED_RESPONSE_ALG)) ||","keycloak has similar string utility. It was introduced by the commit after you've created the branch for this PR. https://github.com/keycloak/keycloak/blob/master/server-spi/src/main/java/org/keycloak/utils/StringUtil.javaIMO, It might be better to use keycloak internal utility class rather than using new external dependent package's one.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8175,655173884,2021-06-21T08:24:58Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/HttpClientBuilder.java,"@@ -299,11 +305,22 @@ public HttpClient build() {              if (socketTimeout > -1) {                 HttpConnectionParams.setSoTimeout(params, (int) socketTimeoutUnits.toMillis(socketTimeout));-+            } else {+                Long socketTimeoutProperty = getLongSystemProperty(SOCKET_TIMEOUT_PROPERTY);",Why we are parsing `long` when it is then narrowed to `int` later?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8165,655364248,2021-06-21T13:13:07Z,adapters/saml/core/src/main/resources/schema/keycloak_saml_adapter_1_13.xsd,"@@ -0,0 +1,550 @@+<?xml version=""1.0"" encoding=""UTF-8""?>++<!--+  ~ Copyright 2019 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<xs:schema version=""1.0""+           xmlns:xs=""http://www.w3.org/2001/XMLSchema""+           xmlns=""urn:keycloak:saml:adapter""+           targetNamespace=""urn:keycloak:saml:adapter""+           elementFormDefault=""qualified""+           attributeFormDefault=""unqualified"">++    <xs:element name=""keycloak-saml-adapter"" type=""adapter-type""/>+    <xs:complexType name=""adapter-type"">+        <xs:annotation>+            <xs:documentation>Keycloak SAML Adapter configuration file.</xs:documentation>+        </xs:annotation>+        <xs:all>+            <xs:element name=""SP"" maxOccurs=""1"" minOccurs=""0"" type=""sp-type"">+                <xs:annotation>+                    <xs:documentation>Describes SAML service provider configuration.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:all>+    </xs:complexType>++    <xs:complexType name=""sp-type"">+        <xs:all>+            <xs:element name=""Keys"" type=""keys-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>+                        List of service provider encryption and validation keys.++                        If the IDP requires that the client application (SP) sign all of its requests and/or if the IDP will encrypt assertions, you must define the keys used to do this. For client signed documents you must define both the private and public key or certificate that will be used to sign documents. For encryption, you only have to define the private key that will be used to decrypt.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""PrincipalNameMapping"" type=""principal-name-mapping-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>When creating a Java Principal object that you obtain from methods like HttpServletRequest.getUserPrincipal(), you can define what name that is returned by the Principal.getName() method.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""RoleIdentifiers"" type=""role-identifiers-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Defines what SAML attributes within the assertion received from the user should be used as role identifiers within the Java EE Security Context for the user.+                        By default Role attribute values are converted to Java EE roles. Some IDPs send roles via a member or memberOf attribute assertion. You can define one or more Attribute elements to specify which SAML attributes must be converted into roles.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""RoleMappingsProvider"" type=""role-mappings-provider-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Specifies the role mappings provider implementation that will be used to map the roles extracted from the SAML assertion into the final set of roles+                        that will be assigned to the principal. A provider is typically used to map roles retrieved from third party IDPs into roles that exist in the JEE application environment. It can also+                        assign extra roles to the assertion principal (for example, by connecting to an LDAP server to obtain more roles) or remove some of the roles that were set by the IDP.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""IDP"" type=""idp-type"" minOccurs=""1"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Describes configuration of SAML identity provider for this service provider.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:all>+        <xs:attribute name=""entityID"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>This is the identifier for this client. The IDP needs this value to determine who the client is that is communicating with it.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""sslPolicy"" type=""ssl-policy-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SSL policy the adapter will enforce.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""nameIDPolicyFormat"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML clients can request a specific NameID Subject format. Fill in this value if you want a specific format. It must be a standard SAML format identifier, i.e. urn:oasis:names:tc:SAML:2.0:nameid-format:transient. By default, no special format is requested.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""logoutPage"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>URL of the logout page.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""forceAuthentication"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML clients can request that a user is re-authenticated even if they are already logged in at the IDP. Default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""keepDOMAssertion"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Attribute to inject the DOM representation of the assertion into the SamlPrincipal (respecting the original syntax). Default value is false</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""isPassive"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML clients can request that a user is never asked to authenticate even if they are not logged in at the IDP. Set this to true if you want this. Do not use together with forceAuthentication as they are opposite. Default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""turnOffChangeSessionIdOnLogin"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>The session id is changed by default on a successful login on some platforms to plug a security attack vector. Change this to true to disable this. It is recommended you do not turn it off. Default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""autodetectBearerOnly"" type=""xs:boolean"" use=""optional"" default=""false"">+            <xs:annotation>+                <xs:documentation>This should be set to true if your application serves both a web application and web services (e.g. SOAP or REST). It allows you to redirect unauthenticated users of the web application to the Keycloak login page, but send an HTTP 401 status code to unauthenticated SOAP or REST clients instead as they would not understand a redirect to the login page. Keycloak auto-detects SOAP or REST clients based on typical headers like X-Requested-With, SOAPAction or Accept. The default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>++    <xs:complexType name=""keys-type"">+        <xs:sequence>+            <xs:element name=""Key"" type=""key-type"" minOccurs=""1"" maxOccurs=""unbounded"">+                <xs:annotation>+                    <xs:documentation>Describes a single key used for signing or encryption.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:sequence>+    </xs:complexType>+    <xs:complexType name=""key-type"">+        <xs:all>+            <xs:element name=""KeyStore"" maxOccurs=""1"" minOccurs=""0"" type=""key-store-type"">+                <xs:annotation>+                    <xs:documentation>Java keystore to load keys and certificates from.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""PrivateKeyPem"" type=""xs:string"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Private key (PEM format)</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""PublicKeyPem"" type=""xs:string"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Public key (PEM format)</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""CertificatePem"" type=""xs:string"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Certificate key (PEM format)</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:all>+        <xs:attribute name=""signing"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Flag defining whether the key should be used for signing.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""encryption"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Flag defining whether the key should be used for encryption</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""key-store-type"">+        <xs:all>+            <xs:element name=""PrivateKey"" maxOccurs=""1"" minOccurs=""0"" type=""private-key-type"">+                <xs:annotation>+                    <xs:documentation>Private key declaration</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""Certificate"" type=""certificate-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Certificate declaration</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:all>+        <xs:attribute name=""file"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>File path to the key store.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""resource"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>WAR resource path to the key store. This is a path used in method call to ServletContext.getResourceAsStream().</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""password"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>The password of the key store.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""type"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Key store format</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""alias"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Key alias</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""private-key-type"">+        <xs:attribute name=""alias"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>Alias that points to the key or cert within the keystore.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""password"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>Keystores require an additional password to access private keys. In the PrivateKey element you must define this password within a password attribute.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""certificate-type"">+        <xs:attribute name=""alias"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>Alias that points to the key or cert within the keystore.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""principal-name-mapping-type"">+        <xs:attribute name=""policy"" type=""principal-name-mapping-policy-type"" use=""required"">+            <xs:annotation>+                <xs:documentation>Policy used to populate value of Java Principal object obtained from methods like HttpServletRequest.getUserPrincipal().</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""attribute"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Name of the SAML assertion attribute to use within.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:simpleType name=""principal-name-mapping-policy-type"">+        <xs:restriction base=""xs:string"">+            <xs:enumeration value=""FROM_NAME_ID"">+                <xs:annotation>+                    <xs:documentation>This policy just uses whatever the SAML subject value is. This is the default setting</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+            <xs:enumeration value=""FROM_ATTRIBUTE"">+                <xs:annotation>+                    <xs:documentation>This will pull the value from one of the attributes declared in the SAML assertion received from the server. You'll need to specify the name of the SAML assertion attribute to use within the attribute XML attribute.</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+        </xs:restriction>+    </xs:simpleType>+    <xs:simpleType name=""ssl-policy-type"">+        <xs:restriction base=""xs:string"">+            <xs:enumeration value=""ALL"">+                <xs:annotation>+                    <xs:documentation>All requests must come in via HTTPS.</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+            <xs:enumeration value=""EXTERNAL"">+                <xs:annotation>+                    <xs:documentation>Only non-private IP addresses must come over the wire via HTTPS.</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+            <xs:enumeration value=""NONE"">+                <xs:annotation>+                    <xs:documentation>no requests are required to come over via HTTPS.</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+        </xs:restriction>+    </xs:simpleType>+    <xs:simpleType name=""signature-algorithm-type"">+        <xs:restriction base=""xs:string"">+            <xs:enumeration value=""RSA_SHA1""/>+            <xs:enumeration value=""RSA_SHA256""/>+            <xs:enumeration value=""RSA_SHA512""/>+            <xs:enumeration value=""DSA_SHA1""/>+        </xs:restriction>+    </xs:simpleType>+    <xs:simpleType name=""binding-type"">+        <xs:restriction base=""xs:string"">+            <xs:enumeration value=""POST""/>+            <xs:enumeration value=""REDIRECT""/>+        </xs:restriction>+    </xs:simpleType>+    <xs:complexType name=""role-identifiers-type"">+        <xs:choice minOccurs=""0"" maxOccurs=""unbounded"">+            <xs:element name=""Attribute"" maxOccurs=""unbounded"" minOccurs=""0"" type=""attribute-type"">+                <xs:annotation>+                    <xs:documentation>Specifies SAML attribute to be converted into roles.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:choice>+    </xs:complexType>+    <xs:complexType name=""attribute-type"">+        <xs:attribute name=""name"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>Specifies name of the SAML attribute to be converted into roles.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""role-mappings-provider-type"">+        <xs:sequence>+            <xs:element name=""Property"" type=""property-type"" minOccurs=""0"" maxOccurs=""unbounded"">+                <xs:annotation>+                    <xs:documentation>Specifies a configuration property for the provider.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:sequence>+        <xs:attribute name=""id"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>The id of the role mappings provider that is to be used. Example: properties-based-provider.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""property-type"">+        <xs:attribute name=""name"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>The name (key) of the configuration property.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""value"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>The value of the configuration property.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""idp-type"">+        <xs:sequence minOccurs=""0"" maxOccurs=""unbounded"">+            <xs:element name=""SingleSignOnService"" maxOccurs=""1"" minOccurs=""1"" type=""sign-on-type"">+                <xs:annotation>+                    <xs:documentation>Configuration of the login SAML endpoint of the IDP.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""SingleLogoutService"" type=""logout-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Configuration of the logout SAML endpoint of the IDP</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""Keys"" type=""keys-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>The Keys sub element of IDP is only used to define the certificate or public key to use to verify documents signed by the IDP.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""HttpClient"" type=""http-client-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Configuration of HTTP client used for automatic obtaining of certificates containing public keys for IDP signature verification via SAML descriptor of the IDP.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""AllowedClockSkew"" type=""allowed-clock-skew-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>This defines the allowed clock skew between IDP and SP in milliseconds. The default value is 0.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:sequence>+        <xs:attribute name=""entityID"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>issuer ID of the IDP.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""signaturesRequired"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>If set to true, the client adapter will sign every document it sends to the IDP. Also, the client will expect that the IDP will be signing any documents sent to it. This switch sets the default for all request and response types.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""signatureAlgorithm"" type=""signature-algorithm-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Signature algorithm that the IDP expects signed documents to use. Defaults to RSA_SHA256</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""signatureCanonicalizationMethod"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the signature canonicalization method that the IDP expects signed documents to use. The default value is https://www.w3.org/2001/10/xml-exc-c14n# and should be good for most IDPs.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""encryption"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation></xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""metadataUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>The URL used to retrieve the IDP metadata, currently this is only used to pick up signing and encryption keys periodically which allow cycling of these keys on the IDP without manual changes on the SP side.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""sign-on-type"">+        <xs:attribute name=""signRequest"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client sign authn requests? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""validateResponseSignature"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client expect the IDP to sign the assertion response document sent back from an auhtn request? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""validateAssertionSignature"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client expect the IDP to sign the individual assertions sent back from an auhtn request? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""requestBinding"" type=""binding-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML binding type used for communicating with the IDP. The default value is POST, but you can set it to REDIRECT as well.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""responseBinding"" type=""binding-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML allows the client to request what binding type it wants authn responses to use. This value maps to ProtocolBinding attribute in SAML AuthnRequest. The default is that the client will not request a specific binding type for responses.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""bindingUrl"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>This is the URL for the IDP login service that the client will send requests to.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""assertionConsumerServiceUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>URL of the assertion consumer service (ACS) where the IDP login service should send responses to. By default it is unset, relying on the IdP settings. When set, it must end in ""/saml"". This property is typically accompanied by the responseBinding attribute.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>++    <xs:complexType name=""logout-type"">+        <xs:attribute name=""signRequest"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client sign authn requests? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""signResponse"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client sign logout responses it sends to the IDP requests? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""validateRequestSignature"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client expect signed logout request documents from the IDP? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""validateResponseSignature"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client expect signed logout response documents from the IDP? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""requestBinding"" type=""binding-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the SAML binding type used for communicating SAML requests to the IDP. The default value is POST.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""responseBinding"" type=""binding-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the SAML binding type used for communicating SAML responses to the IDP. The default value is POST.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""postBindingUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the URL for the IDP's logout service when using the POST binding. This setting is REQUIRED if using the POST binding.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""redirectBindingUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the URL for the IDP's logout service when using the REDIRECT binding. This setting is REQUIRED if using the REDIRECT binding.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>++    <xs:complexType name=""http-client-type"">+        <xs:attribute name=""allowAnyHostname"" type=""xs:boolean"" use=""optional"" default=""false"">+            <xs:annotation>+                <xs:documentation>If the the IDP server requires HTTPS and this config option is set to true the IDP's certificate+                    is validated via the truststore, but host name validation is not done. This setting should only be used during+                    development and never in production as it will partly disable verification of SSL certificates.+                    This seting may be useful in test environments. The default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""clientKeystore"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the file path to a keystore file. This keystore contains client certificate+                    for two-way SSL when the adapter makes HTTPS requests to the IDP server.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""clientKeystorePassword"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Password for the client keystore and for the client's key.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""connectionPoolSize"" type=""xs:int"" use=""optional"" default=""10"">+            <xs:annotation>+                <xs:documentation>Defines number of pooled connections.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""disableTrustManager"" type=""xs:boolean"" use=""optional"" default=""false"">+            <xs:annotation>+                <xs:documentation>If the the IDP server requires HTTPS and this config option is set to true you do not have to specify a truststore.+                    This setting should only be used during development and never in production as it will disable verification of SSL certificates.+                    The default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""proxyUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>URL to HTTP proxy to use for HTTP connections.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""truststore"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>The value is the file path to a keystore file. If you prefix the path with classpath:,+                    then the truststore will be obtained from the deployment's classpath instead. Used for outgoing+                    HTTPS communications to the IDP server. Client making HTTPS requests need+                    a way to verify the host of the server they are talking to. This is what the trustore does.+                    The keystore contains one or more trusted host certificates or certificate authorities.+                    You can create this truststore by extracting the public certificate of the IDP's SSL keystore.+                </xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""truststorePassword"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Password for the truststore keystore.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""socketTimeout"" type=""xs:long"" default=""-1"">","Do we need `long` here? 9223372036854775807 sounds like an overkill for the socket timeout. Maybe, we should follow the [API of httpclient](https://hc.apache.org/httpclient-legacy/apidocs/org/apache/commons/httpclient/params/HttpConnectionParams.html#setSoTimeout(int)) and use int?",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8165,656050873,2021-06-22T09:37:48Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/HttpClientBuilder.java,"@@ -376,6 +376,14 @@ public HttpClient build(AdapterHttpClientConfig adapterConfig) {          configureProxyForAuthServerIfProvided(adapterConfig); +        if (socketTimeout == -1 && adapterConfig.getSocketTimeout() != -1) {","Probably it's better condition. I assume, nobody wants to set socket timeout to 0; therefore in this case, the default value should be used.",
789496,jbman,https://api.github.com/repos/keycloak/keycloak/pulls/8082,656182376,2021-06-22T12:43:30Z,services/src/main/java/org/keycloak/validation/DefaultClientValidationProvider.java,"@@ -180,6 +199,24 @@ private void checkUri(FieldMessages field, String url, ValidationContext<ClientM         }     } +    private void checkUriLogo(FieldMessages field, String url, ValidationContext<ClientModel> context) {+        if (url == null || url.isEmpty()) {+            return;+        }++        try {+            URI uri = new URI(url);++            if (uri.getScheme() != null &&  uri.getScheme().equals(""javascript"")) {","This should be more strict: ""Schemes other than https, http, or data SHOULD NOT be used.""according to https://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-metadata-ui/v1.0/os/sstc-saml-metadata-ui-v1.0-os.html#__RefHeading__10407_1021935550",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8165,657733790,2021-06-24T08:22:09Z,adapters/saml/core/src/main/resources/schema/keycloak_saml_adapter_1_13.xsd,"@@ -0,0 +1,550 @@+<?xml version=""1.0"" encoding=""UTF-8""?>++<!--+  ~ Copyright 2019 Red Hat, Inc. and/or its affiliates+  ~ and other contributors as indicated by the @author tags.+  ~+  ~ Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ you may not use this file except in compliance with the License.+  ~ You may obtain a copy of the License at+  ~+  ~ http://www.apache.org/licenses/LICENSE-2.0+  ~+  ~ Unless required by applicable law or agreed to in writing, software+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ See the License for the specific language governing permissions and+  ~ limitations under the License.+  -->++<xs:schema version=""1.0""+           xmlns:xs=""http://www.w3.org/2001/XMLSchema""+           xmlns=""urn:keycloak:saml:adapter""+           targetNamespace=""urn:keycloak:saml:adapter""+           elementFormDefault=""qualified""+           attributeFormDefault=""unqualified"">++    <xs:element name=""keycloak-saml-adapter"" type=""adapter-type""/>+    <xs:complexType name=""adapter-type"">+        <xs:annotation>+            <xs:documentation>Keycloak SAML Adapter configuration file.</xs:documentation>+        </xs:annotation>+        <xs:all>+            <xs:element name=""SP"" maxOccurs=""1"" minOccurs=""0"" type=""sp-type"">+                <xs:annotation>+                    <xs:documentation>Describes SAML service provider configuration.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:all>+    </xs:complexType>++    <xs:complexType name=""sp-type"">+        <xs:all>+            <xs:element name=""Keys"" type=""keys-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>+                        List of service provider encryption and validation keys.++                        If the IDP requires that the client application (SP) sign all of its requests and/or if the IDP will encrypt assertions, you must define the keys used to do this. For client signed documents you must define both the private and public key or certificate that will be used to sign documents. For encryption, you only have to define the private key that will be used to decrypt.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""PrincipalNameMapping"" type=""principal-name-mapping-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>When creating a Java Principal object that you obtain from methods like HttpServletRequest.getUserPrincipal(), you can define what name that is returned by the Principal.getName() method.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""RoleIdentifiers"" type=""role-identifiers-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Defines what SAML attributes within the assertion received from the user should be used as role identifiers within the Java EE Security Context for the user.+                        By default Role attribute values are converted to Java EE roles. Some IDPs send roles via a member or memberOf attribute assertion. You can define one or more Attribute elements to specify which SAML attributes must be converted into roles.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""RoleMappingsProvider"" type=""role-mappings-provider-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Specifies the role mappings provider implementation that will be used to map the roles extracted from the SAML assertion into the final set of roles+                        that will be assigned to the principal. A provider is typically used to map roles retrieved from third party IDPs into roles that exist in the JEE application environment. It can also+                        assign extra roles to the assertion principal (for example, by connecting to an LDAP server to obtain more roles) or remove some of the roles that were set by the IDP.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""IDP"" type=""idp-type"" minOccurs=""1"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Describes configuration of SAML identity provider for this service provider.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:all>+        <xs:attribute name=""entityID"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>This is the identifier for this client. The IDP needs this value to determine who the client is that is communicating with it.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""sslPolicy"" type=""ssl-policy-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SSL policy the adapter will enforce.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""nameIDPolicyFormat"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML clients can request a specific NameID Subject format. Fill in this value if you want a specific format. It must be a standard SAML format identifier, i.e. urn:oasis:names:tc:SAML:2.0:nameid-format:transient. By default, no special format is requested.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""logoutPage"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>URL of the logout page.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""forceAuthentication"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML clients can request that a user is re-authenticated even if they are already logged in at the IDP. Default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""keepDOMAssertion"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Attribute to inject the DOM representation of the assertion into the SamlPrincipal (respecting the original syntax). Default value is false</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""isPassive"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML clients can request that a user is never asked to authenticate even if they are not logged in at the IDP. Set this to true if you want this. Do not use together with forceAuthentication as they are opposite. Default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""turnOffChangeSessionIdOnLogin"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>The session id is changed by default on a successful login on some platforms to plug a security attack vector. Change this to true to disable this. It is recommended you do not turn it off. Default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""autodetectBearerOnly"" type=""xs:boolean"" use=""optional"" default=""false"">+            <xs:annotation>+                <xs:documentation>This should be set to true if your application serves both a web application and web services (e.g. SOAP or REST). It allows you to redirect unauthenticated users of the web application to the Keycloak login page, but send an HTTP 401 status code to unauthenticated SOAP or REST clients instead as they would not understand a redirect to the login page. Keycloak auto-detects SOAP or REST clients based on typical headers like X-Requested-With, SOAPAction or Accept. The default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>++    <xs:complexType name=""keys-type"">+        <xs:sequence>+            <xs:element name=""Key"" type=""key-type"" minOccurs=""1"" maxOccurs=""unbounded"">+                <xs:annotation>+                    <xs:documentation>Describes a single key used for signing or encryption.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:sequence>+    </xs:complexType>+    <xs:complexType name=""key-type"">+        <xs:all>+            <xs:element name=""KeyStore"" maxOccurs=""1"" minOccurs=""0"" type=""key-store-type"">+                <xs:annotation>+                    <xs:documentation>Java keystore to load keys and certificates from.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""PrivateKeyPem"" type=""xs:string"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Private key (PEM format)</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""PublicKeyPem"" type=""xs:string"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Public key (PEM format)</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""CertificatePem"" type=""xs:string"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Certificate key (PEM format)</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:all>+        <xs:attribute name=""signing"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Flag defining whether the key should be used for signing.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""encryption"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Flag defining whether the key should be used for encryption</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""key-store-type"">+        <xs:all>+            <xs:element name=""PrivateKey"" maxOccurs=""1"" minOccurs=""0"" type=""private-key-type"">+                <xs:annotation>+                    <xs:documentation>Private key declaration</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""Certificate"" type=""certificate-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Certificate declaration</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:all>+        <xs:attribute name=""file"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>File path to the key store.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""resource"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>WAR resource path to the key store. This is a path used in method call to ServletContext.getResourceAsStream().</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""password"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>The password of the key store.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""type"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Key store format</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""alias"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Key alias</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""private-key-type"">+        <xs:attribute name=""alias"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>Alias that points to the key or cert within the keystore.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""password"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>Keystores require an additional password to access private keys. In the PrivateKey element you must define this password within a password attribute.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""certificate-type"">+        <xs:attribute name=""alias"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>Alias that points to the key or cert within the keystore.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""principal-name-mapping-type"">+        <xs:attribute name=""policy"" type=""principal-name-mapping-policy-type"" use=""required"">+            <xs:annotation>+                <xs:documentation>Policy used to populate value of Java Principal object obtained from methods like HttpServletRequest.getUserPrincipal().</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""attribute"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Name of the SAML assertion attribute to use within.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:simpleType name=""principal-name-mapping-policy-type"">+        <xs:restriction base=""xs:string"">+            <xs:enumeration value=""FROM_NAME_ID"">+                <xs:annotation>+                    <xs:documentation>This policy just uses whatever the SAML subject value is. This is the default setting</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+            <xs:enumeration value=""FROM_ATTRIBUTE"">+                <xs:annotation>+                    <xs:documentation>This will pull the value from one of the attributes declared in the SAML assertion received from the server. You'll need to specify the name of the SAML assertion attribute to use within the attribute XML attribute.</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+        </xs:restriction>+    </xs:simpleType>+    <xs:simpleType name=""ssl-policy-type"">+        <xs:restriction base=""xs:string"">+            <xs:enumeration value=""ALL"">+                <xs:annotation>+                    <xs:documentation>All requests must come in via HTTPS.</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+            <xs:enumeration value=""EXTERNAL"">+                <xs:annotation>+                    <xs:documentation>Only non-private IP addresses must come over the wire via HTTPS.</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+            <xs:enumeration value=""NONE"">+                <xs:annotation>+                    <xs:documentation>no requests are required to come over via HTTPS.</xs:documentation>+                </xs:annotation>+            </xs:enumeration>+        </xs:restriction>+    </xs:simpleType>+    <xs:simpleType name=""signature-algorithm-type"">+        <xs:restriction base=""xs:string"">+            <xs:enumeration value=""RSA_SHA1""/>+            <xs:enumeration value=""RSA_SHA256""/>+            <xs:enumeration value=""RSA_SHA512""/>+            <xs:enumeration value=""DSA_SHA1""/>+        </xs:restriction>+    </xs:simpleType>+    <xs:simpleType name=""binding-type"">+        <xs:restriction base=""xs:string"">+            <xs:enumeration value=""POST""/>+            <xs:enumeration value=""REDIRECT""/>+        </xs:restriction>+    </xs:simpleType>+    <xs:complexType name=""role-identifiers-type"">+        <xs:choice minOccurs=""0"" maxOccurs=""unbounded"">+            <xs:element name=""Attribute"" maxOccurs=""unbounded"" minOccurs=""0"" type=""attribute-type"">+                <xs:annotation>+                    <xs:documentation>Specifies SAML attribute to be converted into roles.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:choice>+    </xs:complexType>+    <xs:complexType name=""attribute-type"">+        <xs:attribute name=""name"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>Specifies name of the SAML attribute to be converted into roles.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""role-mappings-provider-type"">+        <xs:sequence>+            <xs:element name=""Property"" type=""property-type"" minOccurs=""0"" maxOccurs=""unbounded"">+                <xs:annotation>+                    <xs:documentation>Specifies a configuration property for the provider.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:sequence>+        <xs:attribute name=""id"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>The id of the role mappings provider that is to be used. Example: properties-based-provider.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""property-type"">+        <xs:attribute name=""name"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>The name (key) of the configuration property.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""value"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>The value of the configuration property.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""idp-type"">+        <xs:sequence minOccurs=""0"" maxOccurs=""unbounded"">+            <xs:element name=""SingleSignOnService"" maxOccurs=""1"" minOccurs=""1"" type=""sign-on-type"">+                <xs:annotation>+                    <xs:documentation>Configuration of the login SAML endpoint of the IDP.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""SingleLogoutService"" type=""logout-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Configuration of the logout SAML endpoint of the IDP</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""Keys"" type=""keys-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>The Keys sub element of IDP is only used to define the certificate or public key to use to verify documents signed by the IDP.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""HttpClient"" type=""http-client-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>Configuration of HTTP client used for automatic obtaining of certificates containing public keys for IDP signature verification via SAML descriptor of the IDP.</xs:documentation>+                </xs:annotation>+            </xs:element>+            <xs:element name=""AllowedClockSkew"" type=""allowed-clock-skew-type"" minOccurs=""0"" maxOccurs=""1"">+                <xs:annotation>+                    <xs:documentation>This defines the allowed clock skew between IDP and SP in milliseconds. The default value is 0.</xs:documentation>+                </xs:annotation>+            </xs:element>+        </xs:sequence>+        <xs:attribute name=""entityID"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>issuer ID of the IDP.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""signaturesRequired"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>If set to true, the client adapter will sign every document it sends to the IDP. Also, the client will expect that the IDP will be signing any documents sent to it. This switch sets the default for all request and response types.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""signatureAlgorithm"" type=""signature-algorithm-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Signature algorithm that the IDP expects signed documents to use. Defaults to RSA_SHA256</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""signatureCanonicalizationMethod"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the signature canonicalization method that the IDP expects signed documents to use. The default value is https://www.w3.org/2001/10/xml-exc-c14n# and should be good for most IDPs.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""encryption"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation></xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""metadataUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>The URL used to retrieve the IDP metadata, currently this is only used to pick up signing and encryption keys periodically which allow cycling of these keys on the IDP without manual changes on the SP side.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>+    <xs:complexType name=""sign-on-type"">+        <xs:attribute name=""signRequest"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client sign authn requests? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""validateResponseSignature"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client expect the IDP to sign the assertion response document sent back from an auhtn request? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""validateAssertionSignature"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client expect the IDP to sign the individual assertions sent back from an auhtn request? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""requestBinding"" type=""binding-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML binding type used for communicating with the IDP. The default value is POST, but you can set it to REDIRECT as well.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""responseBinding"" type=""binding-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>SAML allows the client to request what binding type it wants authn responses to use. This value maps to ProtocolBinding attribute in SAML AuthnRequest. The default is that the client will not request a specific binding type for responses.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""bindingUrl"" type=""xs:string"" use=""required"">+            <xs:annotation>+                <xs:documentation>This is the URL for the IDP login service that the client will send requests to.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""assertionConsumerServiceUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>URL of the assertion consumer service (ACS) where the IDP login service should send responses to. By default it is unset, relying on the IdP settings. When set, it must end in ""/saml"". This property is typically accompanied by the responseBinding attribute.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>++    <xs:complexType name=""logout-type"">+        <xs:attribute name=""signRequest"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client sign authn requests? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""signResponse"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client sign logout responses it sends to the IDP requests? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""validateRequestSignature"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client expect signed logout request documents from the IDP? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""validateResponseSignature"" type=""xs:boolean"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Should the client expect signed logout response documents from the IDP? Defaults to whatever the IDP signaturesRequired element value is.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""requestBinding"" type=""binding-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the SAML binding type used for communicating SAML requests to the IDP. The default value is POST.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""responseBinding"" type=""binding-type"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the SAML binding type used for communicating SAML responses to the IDP. The default value is POST.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""postBindingUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the URL for the IDP's logout service when using the POST binding. This setting is REQUIRED if using the POST binding.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""redirectBindingUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the URL for the IDP's logout service when using the REDIRECT binding. This setting is REQUIRED if using the REDIRECT binding.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+    </xs:complexType>++    <xs:complexType name=""http-client-type"">+        <xs:attribute name=""allowAnyHostname"" type=""xs:boolean"" use=""optional"" default=""false"">+            <xs:annotation>+                <xs:documentation>If the the IDP server requires HTTPS and this config option is set to true the IDP's certificate+                    is validated via the truststore, but host name validation is not done. This setting should only be used during+                    development and never in production as it will partly disable verification of SSL certificates.+                    This seting may be useful in test environments. The default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""clientKeystore"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>This is the file path to a keystore file. This keystore contains client certificate+                    for two-way SSL when the adapter makes HTTPS requests to the IDP server.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""clientKeystorePassword"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Password for the client keystore and for the client's key.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""connectionPoolSize"" type=""xs:int"" use=""optional"" default=""10"">+            <xs:annotation>+                <xs:documentation>Defines number of pooled connections.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""disableTrustManager"" type=""xs:boolean"" use=""optional"" default=""false"">+            <xs:annotation>+                <xs:documentation>If the the IDP server requires HTTPS and this config option is set to true you do not have to specify a truststore.+                    This setting should only be used during development and never in production as it will disable verification of SSL certificates.+                    The default value is false.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""proxyUrl"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>URL to HTTP proxy to use for HTTP connections.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""truststore"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>The value is the file path to a keystore file. If you prefix the path with classpath:,+                    then the truststore will be obtained from the deployment's classpath instead. Used for outgoing+                    HTTPS communications to the IDP server. Client making HTTPS requests need+                    a way to verify the host of the server they are talking to. This is what the trustore does.+                    The keystore contains one or more trusted host certificates or certificate authorities.+                    You can create this truststore by extracting the public certificate of the IDP's SSL keystore.+                </xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""truststorePassword"" type=""xs:string"" use=""optional"">+            <xs:annotation>+                <xs:documentation>Password for the truststore keystore.</xs:documentation>+            </xs:annotation>+        </xs:attribute>+        <xs:attribute name=""socketTimeout"" type=""xs:long"" default=""-1"">","@mabartos I had a look at the long vs int again and I think we should revert to long, as we are using it in server code as well. The reason probably is, that it is also possible to configure TimeUnit which then decreases the maximum value. Also as you said, we should stay consistent. Sorry for the confusion.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8144,657935722,2021-06-24T13:13:55Z,server-spi/src/main/java/org/keycloak/models/RealmModel.java,"@@ -267,6 +267,9 @@ default Boolean getAttribute(String name, Boolean defaultValue) {     int getActionTokenGeneratedByAdminLifespan();     void setActionTokenGeneratedByAdminLifespan(int seconds); +    int getRequestUriLifespan();","It will be good if we can avoid changes in the RealmModel, RealmAdapter, RepresentationToModel and other core model classes just because of introducing PAR related configurations. Is it possible to add some class like `ParConfig` and move the PAR related configuration parameters to this class? See `CibaConfig` for the inspiration. Note that it has some realm-scoped configuration attributes as well as client-scoped configuration attributes and works fine for both.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8144,657936459,2021-06-24T13:14:48Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCLoginProtocolService.java,"@@ -273,6 +279,13 @@ public Object revoke() {         return endpoint;     } +    @Path(""par"")+    public Object par() {","Can we avoid changes in the OIDCLoginProtocolService and use the extensions approach instead? For example see CibaRootEndpoint and the classes, which it inherits from (OIDCExtProvider, OIDCExtProviderFactory, EnvironmentDependentProviderFactory)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8144,657937779,2021-06-24T13:16:25Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/request/AuthorizationEndpointRequestParserProcessor.java,"@@ -64,19 +64,30 @@ public static AuthorizationEndpointRequest parseRequest(EventBuilder event, Keyc             String requestObjectRequired = OIDCAdvancedConfigWrapper.fromClientModel(client).getRequestObjectRequired();              if (OIDCConfigAttributes.REQUEST_OBJECT_REQUIRED_REQUEST_OR_REQUEST_URI.equals(requestObjectRequired)-                    && requestParam == null && requestUriParam == null) {+                        && requestParam == null && requestUriParam == null) {",Minor: is it possible to remove formatting changes from this class?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8144,657938080,2021-06-24T13:16:48Z,services/src/main/java/org/keycloak/protocol/oidc/par/ParValidationService.java,"@@ -0,0 +1,147 @@+package org.keycloak.protocol.oidc.par;++import org.jboss.resteasy.spi.HttpRequest;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.TokenManager;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequestParserProcessor;+import org.keycloak.protocol.oidc.utils.OIDCResponseMode;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.protocol.oidc.utils.RedirectUtils;+import org.keycloak.representations.idm.OAuth2ErrorRepresentation;+import org.keycloak.services.ErrorResponseException;+import org.keycloak.services.ServicesLogger;+import org.keycloak.util.TokenUtil;++import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;++import static org.keycloak.protocol.oidc.OIDCLoginProtocol.REQUEST_URI_PARAM;++public class ParValidationService {",I think this class is redundant and probably can be removed entirely from this PR?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8144,657940005,2021-06-24T13:19:06Z,services/src/main/java/org/keycloak/protocol/oidc/par/endpoints/ParEndpoint.java,"@@ -0,0 +1,397 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.par.endpoints;++import com.google.common.primitives.Bytes;+import org.jboss.resteasy.spi.HttpRequest;+import org.jboss.resteasy.spi.HttpResponse;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.Profile;+import org.keycloak.common.util.Base64Url;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.headers.SecurityHeadersProvider;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.PushedAuthzRequestStoreProvider;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;+import org.keycloak.protocol.oidc.utils.OIDCResponseMode;+import org.keycloak.protocol.oidc.utils.OIDCResponseType;+import org.keycloak.protocol.oidc.utils.RedirectUtils;+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.TokenManager;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequestParserProcessor;+import org.keycloak.protocol.oidc.par.ParResponse;+import org.keycloak.services.CorsErrorResponseException;+import org.keycloak.services.ServicesLogger;+import org.keycloak.services.resources.Cors;+import org.keycloak.util.TokenUtil;+import org.keycloak.utils.ProfileHelper;++import javax.ws.rs.Consumes;+import javax.ws.rs.POST;+import javax.ws.rs.Produces;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.MediaType;+import javax.ws.rs.core.Response;++import static org.keycloak.protocol.oidc.OIDCLoginProtocol.REQUEST_URI_PARAM;++import java.nio.charset.StandardCharsets;+import java.security.MessageDigest;+import java.security.NoSuchAlgorithmException;+import java.util.HashMap;+import java.util.Map;+import java.util.regex.Matcher;+import java.util.regex.Pattern;+++/**+ * Pushed Authorization Request endpoint+ */+public class ParEndpoint {++    public static final String PAR_CREATED_TIME = ""par.created.time"";+    private static final String REQUEST_URI_TEMPLATE = ""urn:ietf:params:oauth:request_uri:%s"";++    @Context+    private KeycloakSession session;++    @Context+    private HttpRequest request;++    @Context+    private HttpResponse httpResponse;++    @Context+    private HttpHeaders headers;++    @Context+    private ClientConnection clientConnection;++    private EventBuilder event;+    private Cors cors;+    private RealmModel realm;+    private ClientModel client;+    private AuthorizationEndpointRequest authorizationRequest;+    private OIDCResponseType parsedResponseType;+    private OIDCResponseMode parsedResponseMode;++    // https://tools.ietf.org/html/rfc7636#section-4.2+    private static final Pattern VALID_CODE_CHALLENGE_PATTERN = Pattern.compile(""^[0-9a-zA-Z\\-\\.~_]+$"");++    public ParEndpoint(RealmModel realm, EventBuilder event) {+        this.realm = realm;+        this.event = event;+    }++    @POST+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)+    @Produces(MediaType.APPLICATION_JSON)+    public Response par() {++        ProfileHelper.requireFeature(Profile.Feature.PAR);++        cors = Cors.add(request).auth().allowedMethods(""POST"").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);++        event.event(EventType.PUSHED_AUTHORIZATION_REQUEST);++        checkSsl();+        checkRealm();+        authorizeClient();++        if (!OIDCAdvancedConfigWrapper.fromClientModel(client).getRequiredPushedAuthorizationRequests()) {","If I understand correctly the specification chapter 6 here https://datatracker.ietf.org/doc/html/draft-ietf-oauth-par#section-6, my understanding is that:- If `require_pushed_authorization_requests` is false, client is still able to use PAR to send request. However client can choose also the ""classic"" way of initiating OIDC flow with the AuthorizationEndpoint- If `require_pushed_authorization_requests` is true, client MUST use PAR.So if I understand correctly, it will makes sense to remove this check from this ParEndpoint as every client is allowed to use PAR if I understand correctly. But on the other hand, the AuthorizationEndpoint should have some check added, that clients with the `require_pushed_authorization_requests` set to true should be rejected from calling AuthorizationEndpoint (unless they call it with the `request_uri` parameter containing PAR URI).WDYT?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8165,658228158,2021-06-24T19:32:26Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/AbstractServletsAdapterTest.java,"@@ -65,15 +73,25 @@ protected static WebArchive servletDeploymentMultiTenant(String name, Class... s     }      protected static WebArchive servletDeployment(String name, Class... servletClasses) {-        return servletDeployment(name, ""keycloak.json"", servletClasses);+        return servletDeployment(name, DEFAULT_ADAPTER_CONFIG, servletClasses);     } -    protected static WebArchive servletDeployment(String name, String adapterConfig, Class... servletClasses) {+    protected static WebArchive servletDeployment(String name, Consumer<AdapterConfig> adapterConfig, Class... servletClasses) {",It seems that `adapterConfig` here is always `null`. Where is this method used from? Why is the `Consumer` parameter introduced?,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8165,658516576,2021-06-25T06:52:15Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/HttpClientBuilder.java,"@@ -113,9 +113,9 @@ public void checkServerTrusted(X509Certificate[] chain,     protected long connectionTTL = -1;     protected TimeUnit connectionTTLUnit = TimeUnit.MILLISECONDS;     protected HostnameVerifier verifier = null;-    protected long socketTimeout = -1;+    protected int socketTimeout = -1;","I've been discussing it with @mhajas and considering to change from _long_ to _int_ in order to follow Apache HTTP client API. However, as you've mentioned, this is unrelated to the JIRA and the change is not necessary though.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8165,658520153,2021-06-25T06:59:48Z,adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/HttpClientBuilder.java,"@@ -113,9 +113,9 @@ public void checkServerTrusted(X509Certificate[] chain,     protected long connectionTTL = -1;     protected TimeUnit connectionTTLUnit = TimeUnit.MILLISECONDS;     protected HostnameVerifier verifier = null;-    protected long socketTimeout = -1;+    protected int socketTimeout = -1;","Please keep this PR minimal, it is already big enough.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8006,658532308,2021-06-25T07:23:41Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oidc/OIDCWellKnownProviderTest.java,"@@ -173,6 +173,7 @@ public void testDiscovery() {             assertEquals(oidcConfig.getBackchannelAuthenticationEndpoint(), oauth.getBackchannelAuthenticationUrl());             assertContains(oidcConfig.getGrantTypesSupported(), OAuth2Constants.CIBA_GRANT_TYPE);             Assert.assertNames(oidcConfig.getBackchannelTokenDeliveryModesSupported(), ""poll"");+            Assert.assertNames(oidcConfig.getBackchannelAuthenticationRequestSigningAlgValuesSupported(), ""none"", Algorithm.PS256, Algorithm.PS384, Algorithm.PS512, Algorithm.RS256, Algorithm.RS384, Algorithm.RS512, Algorithm.ES256, Algorithm.ES384, Algorithm.ES512, Algorithm.HS256, Algorithm.HS384, Algorithm.HS512);","+1 to everything you mentioned in the last paragraph. We can allow RS* by default, but reject it with the client policy executor similarly like we're doing for other use-cases where RS* is rejected by the executor.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7442,659610177,2021-06-28T09:05:18Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderFactory.java,"@@ -164,6 +171,52 @@ public SAMLIdentityProviderConfig createConfig() {                             samlIdentityProviderConfig.setEncryptionPublicKey(defaultCertificate);                         }                     }+                    if (idpDescriptor.getExtensions() != null && idpDescriptor.getExtensions().getUIInfo() != null) {+                        UIInfoType uiInfo = idpDescriptor.getExtensions().getUIInfo();+                        // import attributes only if values with these locale exist+                        uiInfo.getDisplayName().stream().filter(dn -> lang.equals(dn.getLang())).findFirst().ifPresent(+                            displayName -> samlIdentityProviderConfig.setConfigMduiDisplayName(displayName.getValue()));+                        uiInfo.getDescription().stream().filter(dn -> lang.equals(dn.getLang())).findFirst()+                            .ifPresent(description -> samlIdentityProviderConfig.setMduiDescription(description.getValue()));+                        uiInfo.getInformationURL().stream().filter(dn -> lang.equals(dn.getLang())).findFirst()+                            .ifPresent(informationURL -> samlIdentityProviderConfig+                                .setMduiInformationURL(informationURL.getValue().toString()));+                        uiInfo.getPrivacyStatementURL().stream().filter(dn -> lang.equals(dn.getLang())).findFirst()+                            .ifPresent(privacyStatementURL -> samlIdentityProviderConfig+                                .setMduiPrivacyStatementURL(privacyStatementURL.getValue().toString()));+                        if (!uiInfo.getLogo().isEmpty()) {+                            LogoType logo = uiInfo.getLogo().get(0);+                            samlIdentityProviderConfig.setMduiLogo(logo.getValue().toString());+                            samlIdentityProviderConfig.setMduiLogoHeight(logo.getHeight());+                            samlIdentityProviderConfig.setMduiLogoWidth(logo.getWidth());+                        }++                    }++                    // organization+                    if (entityType.getOrganization() != null) {+                        entityType.getOrganization().getOrganizationName().stream().filter(dn -> lang.equals(dn.getLang()))+                            .findFirst().ifPresent(organizationName -> samlIdentityProviderConfig+                                .setMdOrganizationName(organizationName.getValue()));+                        entityType.getOrganization().getOrganizationDisplayName().stream()+                            .filter(dn -> lang.equals(dn.getLang())).findFirst()+                            .ifPresent(organizationDisplayName -> samlIdentityProviderConfig+                                .setMdOrganizationDisplayName(organizationDisplayName.getValue()));+                        entityType.getOrganization().getOrganizationURL().stream().filter(dn -> lang.equals(dn.getLang()))+                            .findFirst().ifPresent(organizationURL -> samlIdentityProviderConfig+                                .setMdOrganizationURL(organizationURL.getValue().toString()));+                    }++                    // contact person+                    if (!entityType.getContactPerson().isEmpty()) {+                        ContactType contact = entityType.getContactPerson().get(0);",`ContactPerson` is a list of persons. It does not seem correct to store only a single person - either all or none should be stored.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7442,659611470,2021-06-28T09:07:10Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProviderFactory.java,"@@ -164,6 +171,52 @@ public SAMLIdentityProviderConfig createConfig() {                             samlIdentityProviderConfig.setEncryptionPublicKey(defaultCertificate);                         }                     }+                    if (idpDescriptor.getExtensions() != null && idpDescriptor.getExtensions().getUIInfo() != null) {+                        UIInfoType uiInfo = idpDescriptor.getExtensions().getUIInfo();+                        // import attributes only if values with these locale exist+                        uiInfo.getDisplayName().stream().filter(dn -> lang.equals(dn.getLang())).findFirst().ifPresent(+                            displayName -> samlIdentityProviderConfig.setConfigMduiDisplayName(displayName.getValue()));+                        uiInfo.getDescription().stream().filter(dn -> lang.equals(dn.getLang())).findFirst()+                            .ifPresent(description -> samlIdentityProviderConfig.setMduiDescription(description.getValue()));+                        uiInfo.getInformationURL().stream().filter(dn -> lang.equals(dn.getLang())).findFirst()+                            .ifPresent(informationURL -> samlIdentityProviderConfig+                                .setMduiInformationURL(informationURL.getValue().toString()));+                        uiInfo.getPrivacyStatementURL().stream().filter(dn -> lang.equals(dn.getLang())).findFirst()+                            .ifPresent(privacyStatementURL -> samlIdentityProviderConfig+                                .setMduiPrivacyStatementURL(privacyStatementURL.getValue().toString()));+                        if (!uiInfo.getLogo().isEmpty()) {+                            LogoType logo = uiInfo.getLogo().get(0);",`Logo` is a list of images and either should be used in full or not used at all.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/7442,659614943,2021-06-28T09:11:51Z,services/src/main/java/org/keycloak/services/resources/admin/IdentityProvidersResource.java,"@@ -117,6 +117,7 @@ public Response getIdentityProviders(@PathParam(""provider_id"") String providerId         InputPart file = formDataMap.get(""file"").get(0);         InputStream inputStream = file.getBody(InputStream.class, null);         IdentityProviderFactory providerFactory = getProviderFactorytById(providerId);+        session.setAttribute(""locale"", getRealmDefaultLocale());",Session is not intended to pass parameters like this. Remove,
56720952,romge,https://api.github.com/repos/keycloak/keycloak/pulls/7897,659769788,2021-06-28T13:08:16Z,services/src/main/java/org/keycloak/authentication/AuthenticationSelectionResolver.java,"@@ -193,7 +193,7 @@ private static boolean addAllExecutionsFromSubflow(AuthenticationProcessor proce                  // For conditional execution, we must check if condition is true. Otherwise return false, which means trying next                 // requiredExecution in the list-                return !flow.isConditionalSubflowDisabled(ex);+                return !flow.isConditionalSubflowDisabled(ex, false);","When the selection page for authenticators is shown, the results must not be cached because the outcome of the condition may be different during the authenticaion flow process. That is because the level of authentication changes during the flow and must be reevaluated in the conditions.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8144,659859440,2021-06-28T14:52:17Z,server-spi-private/src/main/java/org/keycloak/models/PushedAuthzRequestStoreProvider.java,"@@ -0,0 +1,48 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models;++import org.keycloak.provider.Provider;++import java.util.Map;++/**+ * Provides single-use cache for Pushed Authorization Request. The data of this request may be used only once.+ */+public interface PushedAuthzRequestStoreProvider extends Provider {++    /**+     * Stores the given data and guarantees that data should be available in the store for at least the time specified by {@param lifespanSeconds} parameter.+     *+     * @param key             unique identifier+     * @param lifespanSeconds time to live+     * @param codeData        the data to store+     */+    void put(String key, int lifespanSeconds, Map<String, String> codeData);","@tnorimat Regarding the UUID collision, the chance of having it happen seems to be very unlikely and in general, we don't need to care about it AFAIK. For example see this https://stackoverflow.com/questions/24876188/how-big-is-the-chance-to-get-a-java-uuid-randomuuid-collision . Keycloak already use UUID for various other use-cases where it assumes that UUID must be unique (For example generating ID of users, realms, clients and all the other various objects ).Also UUID.randomUUID uses cryptographically strong algorithm, hence possibly can be used directly for generating request_uri key similarly like various other places in Keycloak?Regarding usage of separate provider or consolidate existing providers, I am not yet 100% sure the way to go. We may need the feedback from @hmlnarik what is the best way to go also for the context of new storage.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8222,660676041,2021-06-29T14:29:36Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/AppInitiatedActionUpdateProfileWithUserProfileTest.java,"@@ -0,0 +1,41 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.actions;++import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.testsuite.forms.AbstractUserProfileTest;++/**+ * Only covers basic use cases for App Initialized actions. Complete dynamic user profile behavior is tested in {@link RequiredActionUpdateProfileWithUserProfileTest} as it shares same code as the App initialized action.   + * + * @author Vlastimil Elias <velias@redhat.com>+ *+ */+public class AppInitiatedActionUpdateProfileWithUserProfileTest extends AppInitiatedActionUpdateProfileTest {+    +    public AppInitiatedActionUpdateProfileWithUserProfileTest() {+        super();+        dynamicFormTest = true;",Easier if you just override a method. Should also help once we refactor testsuite to remove test duplicates once declarative becomes the default.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8222,660679251,2021-06-29T14:32:49Z,themes/src/main/resources/theme/base/login/user-profile-commons.ftl,"@@ -0,0 +1,22 @@+<#macro userProfileField attribute>+<div class=""${properties.kcFormGroupClass!}"">",Why not also include here the `list` directive. Shouldn't it be also part of this directive?,
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8222,661161410,2021-06-30T06:18:17Z,services/src/main/java/org/keycloak/authentication/requiredactions/VerifyUserProfile.java,"@@ -46,11 +41,15 @@ /**  * @author <a href=""mailto:psilva@redhat.com"">Pedro Igor</a>  */-public class VerifyUserProfile implements RequiredActionProvider, RequiredActionFactory, DisplayTypeRequiredActionFactory {+public class VerifyUserProfile extends UpdateProfile {      @Override     public InitiatedActionSupport initiatedActionSupport() {-        return InitiatedActionSupport.SUPPORTED;+        return InitiatedActionSupport.NOT_SUPPORTED;","I don't think we needs it as AIA. It triggers automatically, so client can call common auth flow, no need to ask for this action explicitly in the auth call request (if I understand it correctly, the AIA is one additional parameter in auth request to explicitly ask for some required action which don't trigger automatically)",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8222,661164967,2021-06-30T06:25:50Z,services/src/main/java/org/keycloak/authentication/requiredactions/VerifyUserProfile.java,"@@ -86,60 +85,24 @@ public void requiredActionChallenge(RequiredActionContext context) {                 parameters = context.getHttpRequest().getDecodedFormParameters();             } -            context.challenge(createResponse(context, profile, parameters, errors));-        }-    }--    @Override-    public void processAction(RequiredActionContext context) {-        EventBuilder event = context.getEvent();-        event.event(EventType.VERIFY_PROFILE);-        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();--        if (!context.getRealm().isEditUsernameAllowed()) {-            formData.putSingle(UserModel.USERNAME, context.getUser().getUsername());-        }--        UserProfileProvider provider = context.getSession().getProvider(UserProfileProvider.class);-        UserProfile profile = provider.create(UserProfileContext.UPDATE_PROFILE, formData, context.getUser());--        try {-            profile.update();-            context.success();-        } catch (ValidationException ve) {-            List<FormMessage> errors = Validation.getFormErrorsFromValidation(ve.getErrors());-            context.challenge(createResponse(context, profile, formData, errors));+            context.challenge(createResponse(context, parameters, errors));+            +            EventBuilder event = context.getEvent().clone();+            event.event(EventType.VERIFY_PROFILE);+            event.detail(""fields_to_update"", collectFields(errors));","I took it from the point of view of the admin who sees this event. This event means that verify profile found something what have to be improved in the user profile, and user is asked to update these fields. Maybe even event name isn't the best (I reused event you introduced), and this event should be something like `UPDATE_PROFILE_REQUESTED`.But I'm not sure if there is any side effect of the event type removing/renaming.BTW does every event type have to have `_ERROR` counterpart? It will nener be used for this event type (but VERIFY_PROFILE_ERROR exists)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8158,662035952,2021-07-01T07:09:42Z,core/src/main/java/org/keycloak/representations/AuthorizationToken.java,"@@ -0,0 +1,11 @@+package org.keycloak.representations;++import org.keycloak.TokenCategory;++public class AuthorizationToken extends JsonWebToken{","Is it possible to rename this class to `AuthorizationResponseToken` and rename category to `AUTHORIZATION_RESPONSE`? The reason is, that term ""Authorization"" is already overloaded and is used in Keycloak in various other contexts. So just to make this a bit more clear.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8165,662223598,2021-07-01T11:55:47Z,adapters/oidc/adapter-core/src/test/java/org/keycloak/adapters/KeycloakDeploymentBuilderTest.java,"@@ -101,5 +105,18 @@ public void loadSecretJwtCredentials() {         assertEquals(JWTClientSecretCredentialsProvider.PROVIDER_ID, deployment.getClientAuthenticator().getId());     } +    @Test+    public void loadHttpClientTimeoutConfiguration() {+        KeycloakDeployment deployment = KeycloakDeploymentBuilder.build(getClass().getResourceAsStream(""/keycloak-http-client.json""));+        assertThat(deployment, CoreMatchers.notNullValue());++        HttpClient client = deployment.getClient();+        assertThat(client, CoreMatchers.notNullValue()); +        long socketTimeout = client.getParams().getIntParameter(CoreConnectionPNames.SO_TIMEOUT, -2);+        long connectionTimeout = client.getParams().getIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, -2);++        assertThat(socketTimeout, CoreMatchers.is(2000L));+        assertThat(connectionTimeout, CoreMatchers.is(6000L));","@mhajas However, the `connectionTTL` is only used for internal purposes, especially to create _HttpClient_ with proper _Client Connection Manager_ and with connection pool size greater than 1. The `connectionTTL` attribute is not included in the HttpParams provided by Apache _http-core_ and it seems it shouldn't be revealed in the same manner like those timeouts. In this case, I don't want to create a new parameter which is out of scope of _http-core_ interface. WDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8165,662288914,2021-07-01T13:28:12Z,adapters/oidc/adapter-core/src/test/java/org/keycloak/adapters/KeycloakDeploymentBuilderTest.java,"@@ -101,5 +105,18 @@ public void loadSecretJwtCredentials() {         assertEquals(JWTClientSecretCredentialsProvider.PROVIDER_ID, deployment.getClientAuthenticator().getId());     } +    @Test+    public void loadHttpClientTimeoutConfiguration() {+        KeycloakDeployment deployment = KeycloakDeploymentBuilder.build(getClass().getResourceAsStream(""/keycloak-http-client.json""));+        assertThat(deployment, CoreMatchers.notNullValue());++        HttpClient client = deployment.getClient();+        assertThat(client, CoreMatchers.notNullValue()); +        long socketTimeout = client.getParams().getIntParameter(CoreConnectionPNames.SO_TIMEOUT, -2);+        long connectionTimeout = client.getParams().getIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, -2);++        assertThat(socketTimeout, CoreMatchers.is(2000L));+        assertThat(connectionTimeout, CoreMatchers.is(6000L));","@mabartos I am not sure I am following. Could you elaborate a little bit more, please? What is the difference when the configuration option is used in `HttpParams` and in `ClientConnectionManager`? The `ThreadSafeClientConnManager` class comes from `httpclient` as well, so it is not our internal class. Also, we are using the `connectionTTL` option also for [HttpClientProvider](https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/connections/httpclient/DefaultHttpClientFactory.java#L141) of the Keycloak server.Are you suggesting removing the configuration of connectionTTL from this PR completely?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8227,662313476,2021-07-01T13:56:49Z,model/map/src/main/java/org/keycloak/models/map/storage/QueryParameters.java,"@@ -0,0 +1,94 @@+package org.keycloak.models.map.storage;++import org.keycloak.storage.SearchableModelField;++import java.util.LinkedList;+import java.util.List;++public class QueryParameters<M> {++    protected final Integer offset;+    protected final Integer limit;+    protected final List<OrderingTuple<M>> ordering = new LinkedList<>();++    public QueryParameters(Integer offset, Integer limit, List<OrderingTuple<M>> ordering) {+        this.offset = offset;+        this.limit = limit;+        this.ordering.addAll(ordering);+    }++    public Integer getOffset() {+        return offset;+    }++    public Integer getLimit() {+        return limit;+    }++    public List<OrderingTuple<M>> getOrdering() {+        return ordering;+    }++    enum Order {+        ASCENDING,+        DESCENDING+    }++    public static class OrderingTuple<M> {",```suggestion    public static class OrderBy<M> {```,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8227,662454096,2021-07-01T16:58:28Z,server-spi/src/main/java/org/keycloak/storage/SearchableModelField.java,"@@ -40,31 +40,6 @@ public String getName() {         return fieldClass;     } -    @Override-    public int hashCode() {-        int hash = 5;-        hash = 83 * hash + Objects.hashCode(this.name);-        return hash;-    }--    @Override-    public boolean equals(Object obj) {-        if (this == obj) {-            return true;-        }-        if (obj == null) {-            return false;-        }-        if (getClass() != obj.getClass()) {-            return false;-        }-        final SearchableModelField<?> other = (SearchableModelField<?>) obj;-        if ( ! Objects.equals(this.name, other.name)) {-            return false;-        }-        return true;-    }-","Because of [this](https://github.com/mhajas/keycloak/blob/8feef482dc8400ba37aa128d101923d7b435eda0/model/map/src/main/java/org/keycloak/models/map/storage/MapFieldPredicates.java#L93): ```javaprivate static final Map<SearchableModelField<?>, Comparator<?>> COMPARATORS = new HashMap<>();```and we have more `SearchableModelFields` from more models with the same name (for example CLIENT_ID).",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8227,662505862,2021-07-01T18:22:14Z,model/map/src/main/java/org/keycloak/models/map/storage/QueryParameters.java,"@@ -0,0 +1,94 @@+package org.keycloak.models.map.storage;++import org.keycloak.storage.SearchableModelField;++import java.util.LinkedList;+import java.util.List;++public class QueryParameters<M> {++    protected final Integer offset;+    protected final Integer limit;+    protected final List<OrderingTuple<M>> ordering = new LinkedList<>();++    public QueryParameters(Integer offset, Integer limit, List<OrderingTuple<M>> ordering) {+        this.offset = offset;+        this.limit = limit;+        this.ordering.addAll(ordering);+    }++    public Integer getOffset() {+        return offset;+    }++    public Integer getLimit() {+        return limit;+    }++    public List<OrderingTuple<M>> getOrdering() {+        return ordering;+    }++    enum Order {+        ASCENDING,+        DESCENDING+    }++    public static class OrderingTuple<M> {+        private final SearchableModelField<M> modelField;+        private final Order order;++        public OrderingTuple(SearchableModelField<M> modelField, Order order) {+            this.modelField = modelField;+            this.order = order;+        }++        public SearchableModelField<M> getModelField() {+            return modelField;+        }++        public Order getOrder() {+            return order;+        }+    }++    public static class Builder<M> {","What do you mean by constant? Do you mean that we need to initialize all parameters in the constructor. If yes then setting `orderBy` may be complicated. That is why I introduced Builder to make it simple like `.orderBy(1field).orderBy(2field, DESC).orderBy(3field, DESC)` etc. We can, of course, do without Builder I just want to understand why we don't want it. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8227,662737723,2021-07-02T05:02:23Z,model/map/src/main/java/org/keycloak/models/map/storage/MapStorage.java,"@@ -68,18 +68,48 @@      * @throws IllegalStateException If {@code criteria} is not compatible, i.e. has not been originally created      *   by the {@link #createCriteriaBuilder()} method of this object.      */-    Stream<V> read(ModelCriteriaBuilder<M> criteria);+    default Stream<V> read(ModelCriteriaBuilder<M> criteria) {+        return read(criteria, null);+    }++    /**+     * Returns stream of objects satisfying given {@code criteria} from the storage.+     * The criteria are specified in the given criteria builder based on model properties.+     *+     * @param criteria Criteria filtering out the object, originally obtained+     *   from {@link #createCriteriaBuilder()} method of this object.+     *   If {@code null}, it returns an empty stream.+     * @param queryParameters parameters for the query like firstResult, maxResult, requested ordering, etc.+     * @return Stream of objects. Never returns {@code null}.+     * @throws IllegalStateException If {@code criteria} is not compatible, i.e. has not been originally created+     *   by the {@link #createCriteriaBuilder()} method of this object.+     */+    Stream<V> read(ModelCriteriaBuilder<M> criteria, QueryParameters<M> queryParameters);","The pagination must not be available for individual criteria. What would be the meaning of```java  store.createCriteriaBuilder()    .or(store.createCriteriaBuilder() .compare(aField, EQ, expectedValue) .pagination(first, max, orderByField),         store.createCriteriaBuilder() .compare(aField2, EQ, expectedValue2) .pagination(first, max, orderByField2))    .pagination(0, 1)```?Pagination and order is _query_ parameter, not criteria parameter. Thus it cannot be incorporated in the `ModelCriteriaBuilder`.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8227,662740629,2021-07-02T05:12:41Z,model/map/src/main/java/org/keycloak/models/map/storage/QueryParameters.java,"@@ -0,0 +1,94 @@+package org.keycloak.models.map.storage;++import org.keycloak.storage.SearchableModelField;++import java.util.LinkedList;+import java.util.List;++public class QueryParameters<M> {++    protected final Integer offset;+    protected final Integer limit;+    protected final List<OrderingTuple<M>> ordering = new LinkedList<>();++    public QueryParameters(Integer offset, Integer limit, List<OrderingTuple<M>> ordering) {+        this.offset = offset;+        this.limit = limit;+        this.ordering.addAll(ordering);+    }++    public Integer getOffset() {+        return offset;+    }++    public Integer getLimit() {+        return limit;+    }++    public List<OrderingTuple<M>> getOrdering() {+        return ordering;+    }++    enum Order {+        ASCENDING,+        DESCENDING+    }++    public static class OrderingTuple<M> {+        private final SearchableModelField<M> modelField;+        private final Order order;++        public OrderingTuple(SearchableModelField<M> modelField, Order order) {+            this.modelField = modelField;+            this.order = order;+        }++        public SearchableModelField<M> getModelField() {+            return modelField;+        }++        public Order getOrder() {+            return order;+        }+    }++    public static class Builder<M> {","My point was slightly elsewhere:The `Builder` and all of the calls to `store.getQueryParametersBuilder().[...].build()` are a boilerplate code that should not be necessary. Ideally, the whole part would be short, like `withCriteria` or `orderBy` above which makes the code more readable and maintainable. Also, there is nothing storage-specific in the query parameters (it's all about model fields and numbers), so there is no need to have `MapStorage` implement another method. Sidenote - if we find the way to do it reasonably with query parameters, this can lead to refactor of `ModelCriteriaBuilder` use within `MapStorage` as well.> What do you mean by constant?Apologies, I should have explained precisely. By a constant I mean `public static final` field. Immutability is not strictly necessary (even though it would be nice).> I just want to understand why we don't want it.What is the maximum level of `orderBy` that we really need to support Keycloak? With order, we don't need to be fully generic, it is enough if we support the reasonable usecases.Builder is excellent pattern for initialization of an immutable object with many fields. Neither pagination nor ordering has that many fields so usage of builder pattern rather obscures the use.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8165,662772320,2021-07-02T06:38:10Z,adapters/oidc/adapter-core/src/test/java/org/keycloak/adapters/KeycloakDeploymentBuilderTest.java,"@@ -101,5 +105,18 @@ public void loadSecretJwtCredentials() {         assertEquals(JWTClientSecretCredentialsProvider.PROVIDER_ID, deployment.getClientAuthenticator().getId());     } +    @Test+    public void loadHttpClientTimeoutConfiguration() {+        KeycloakDeployment deployment = KeycloakDeploymentBuilder.build(getClass().getResourceAsStream(""/keycloak-http-client.json""));+        assertThat(deployment, CoreMatchers.notNullValue());++        HttpClient client = deployment.getClient();+        assertThat(client, CoreMatchers.notNullValue()); +        long socketTimeout = client.getParams().getIntParameter(CoreConnectionPNames.SO_TIMEOUT, -2);+        long connectionTimeout = client.getParams().getIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, -2);++        assertThat(socketTimeout, CoreMatchers.is(2000L));+        assertThat(connectionTimeout, CoreMatchers.is(6000L));","@mhajas In the `ThreadSafeClientConnManager` is the field `connectionTTL` with private access modifier and it's not possible to obtain it from the class and where it's only used for internal instantiating of pool entry. The field is completely hidden. Anyway, I'd like to find already existing parameter for `connectionTTL` in order to include it to the `HttpParams`, but I think, we will have to create a new one. However as you've suggested, if the support for the `connectionTTL` is present in this PR, there should be verified the proper settings of the property. I'll add a new parameter to `HttpParams` in order to obtain configuration externally. Thanks.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8244,665087781,2021-07-07T06:45:10Z,adapters/oidc/wildfly/wildfly-subsystem/src/main/java/org/keycloak/subsystem/adapter/extension/KeycloakAdapterConfigService.java,"@@ -147,21 +147,8 @@ public void addRedirectRewriteRule(ModelNode operation, ModelNode model) {         if (!redirectRewritesRules.isDefined()) {             redirectRewritesRules = new ModelNode();         }-         String redirectRewriteRuleName = redirectRewriteRule(operation);-        if (!redirectRewriteRuleName.contains(""."")) {-            redirectRewritesRules.get(redirectRewriteRuleName).set(model.get(""value"").asString());-        } else {-            String[] parts = redirectRewriteRuleName.split(""\\."");-            String provider = parts[0];-            String property = parts[1];-            ModelNode redirectRewriteRule = redirectRewritesRules.get(provider);-            if (!redirectRewriteRule.isDefined()) {-                redirectRewriteRule = new ModelNode();-            }-            redirectRewriteRule.get(property).set(model.get(""value"").asString());-            redirectRewritesRules.set(provider, redirectRewriteRule);-        }",Can the condition and this part be removed?,
43614225,ioemat,https://api.github.com/repos/keycloak/keycloak/pulls/8233,665287208,2021-07-07T11:35:09Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultAttributeGroups.java,"@@ -0,0 +1,58 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.validate.ValidationContext;+import org.keycloak.validate.ValidationError;++import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.function.Consumer;+import java.util.stream.Collectors;++/**+ * <p>The default implementation for {@link AttributeGroups}.+ * Should be reused as much as possible by the different implementations of {@link UserProfileProvider}.+ *+ * <p>This implementation is not specific to any user profile implementation.+ *+ * @author <a href=""mailto:joerg.matysiak@bosch.io"">Jrg Matysiak</a>+ */+public class DefaultAttributeGroups implements AttributeGroups {",We had a discussion internally whether this class should be better named `AttributeGroupsImpl` - if so the rename should probably also been applied to `DefaultAttributes`. @pedroigor  @velias  what do you think?,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/8244,665385897,2021-07-07T13:45:10Z,adapters/oidc/wildfly/wildfly-subsystem/src/main/java/org/keycloak/subsystem/adapter/extension/KeycloakAdapterConfigService.java,"@@ -147,21 +147,8 @@ public void addRedirectRewriteRule(ModelNode operation, ModelNode model) {         if (!redirectRewritesRules.isDefined()) {             redirectRewritesRules = new ModelNode();         }-         String redirectRewriteRuleName = redirectRewriteRule(operation);-        if (!redirectRewriteRuleName.contains(""."")) {-            redirectRewritesRules.get(redirectRewriteRuleName).set(model.get(""value"").asString());-        } else {-            String[] parts = redirectRewriteRuleName.split(""\\."");-            String provider = parts[0];-            String property = parts[1];-            ModelNode redirectRewriteRule = redirectRewritesRules.get(provider);-            if (!redirectRewriteRule.isDefined()) {-                redirectRewriteRule = new ModelNode();-            }-            redirectRewriteRule.get(property).set(model.get(""value"").asString());-            redirectRewritesRules.set(provider, redirectRewriteRule);-        }","I'm assuming it is safe to remove this based on how the redirect-rewrite-rule is used. (https://github.com/keycloak/keycloak/blob/master/adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/OAuthRequestAuthenticator.java#L391). The key is used as a regex to be matched against the path, replacing the matched section with the value. An example here would be `        <redirect-rewrite-rule name=""^/wsmaster/api/(.*)$"">api/$1/</redirect-rewrite-rule>`The dot is a valid part of a regex expression and the logic above would break it into two segments ""^/wsmaster/api/("" and ""*)$"", which makes no sense. In fact, without this change this example would result in an error when creating the AdapterConfig object as JSON cannot deserialize this into a Map<String, String>. It says the value should be an Object, not a String.The logic above seems to have been copied from the credentials handling, where you can have a key format that uses dot as a separator so you can defined different properties for a particular provider. Example, ""jwt.client-keystore-file"" with value ""/tmp/foo.jks"" and then ""jwt.token-timeout"" with value ""10"". It produces a Map<String, Object> in AdapterConfig, whereas redirect-rewrite-rule produces a Map<String, String>, which further indicates that the configured key and value should be read as they come.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8238,665963994,2021-07-08T08:03:17Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureCibaSessionEnforceExecutor.java,"@@ -0,0 +1,72 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.executor;","Since this is CIBA specific executor, it will be ideal to add it under package `org.keycloak.protocol.oidc.grants.ciba.executor` to make the CIBA related stuff consolidated in single place within the codebase as much as possible. WDYT?This comment applies to all executor and executorFactory classes.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8242,665978328,2021-07-08T08:23:34Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -2283,6 +2286,61 @@ public void testExtendedClientPolicyIntefacesForCiba() throws Exception {         assertEquals(""Exception thrown intentionally"", response.getErrorDescription());     } +    @Test+    @EnableFeature(value = Profile.Feature.CIBA, skipRestart = true)+    @AuthServerContainerExclude({REMOTE, QUARKUS})+    public void testExtendedClientPolicyIntefacesForBackchannelTokenRequest() throws Exception {",IMO It will be ideal if ClientPoliciesTest does not have any dependency on the CIBA feature. Is it possible to either move this test to the CIBATest class or add new test class specific to CibaTest?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8240,665981822,2021-07-08T08:28:05Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -2283,6 +2282,45 @@ public void testExtendedClientPolicyIntefacesForCiba() throws Exception {         assertEquals(""Exception thrown intentionally"", response.getErrorDescription());     } +    @Test+    @EnableFeature(value = Profile.Feature.PAR, skipRestart = true)+    @AuthServerContainerExclude({REMOTE, QUARKUS})+    public void testExtendedClientPolicyIntefacesForPar() throws Exception {","Similarly like for other PR, is it possible to either add this to the ParTest or create new test class? IMO it will be good if ClientPoliciesTest does not have any dependency on the preview features like Ciba or PAR.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8240,665990896,2021-07-08T08:40:27Z,services/src/main/java/org/keycloak/services/clientpolicy/context/PushedAuthorizationRequestContext.java,"@@ -0,0 +1,49 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.context;","@mposolda I see, how about the following packages?- `org.keycloak.protocol.oidc.par.clientpolicy.executor` : PAR's executors are located.- `org.keycloak.protocol.oidc.par.clientpolicy.condition` : PAR's conditions are located.- `org.keycloak.protocol.oidc.par.clientpolicy.context` : PAR's contexts are located.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8240,665992322,2021-07-08T08:42:17Z,services/src/main/java/org/keycloak/services/clientpolicy/context/PushedAuthorizationRequestContext.java,"@@ -0,0 +1,49 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.context;","> @mposolda I see, how about the following packages?> >     * `org.keycloak.protocol.oidc.par.clientpolicy.executor` : PAR's executors are located.> >     * `org.keycloak.protocol.oidc.par.clientpolicy.condition` : PAR's conditions are located.> >     * `org.keycloak.protocol.oidc.par.clientpolicy.context` : PAR's contexts are located.+1",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8242,666003374,2021-07-08T08:56:42Z,services/src/main/java/org/keycloak/services/clientpolicy/context/BackchannelTokenRequestContext.java,"@@ -0,0 +1,53 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.context;++import javax.ws.rs.core.MultivaluedMap;++import org.keycloak.protocol.oidc.grants.ciba.channel.CIBAAuthenticationRequest;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;++/**+ * @author <a href=""mailto:takashi.norimatsu.ws@hitachi.com"">Takashi Norimatsu</a>+ */+public class BackchannelTokenRequestContext implements ClientPolicyContext {","@mposolda I see, how about the following packages?* `org.keycloak.protocol.oidc.grants.ciba.clientpolicy.executor` : CIBA's executors are located.* `org.keycloak.protocol.oidc.grants.ciba.clientpolicy.condition` : CIBA's conditions are located.* `org.keycloak.protocol.oidc.grants.ciba.clientpolicy.context` : CIBA's contexts are located.",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8233,666772666,2021-07-09T08:31:13Z,server-spi-private/src/main/java/org/keycloak/userprofile/AttributeGroupMetadata.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import java.util.Map;++/**+ * Configuration of the attribute group.+ *+ * @author <a href=""joerg.matysiak@bosch.io"">Jrg Matysiak</a>+ */+public class AttributeGroupMetadata {","Do we really need all this completely separate and complex handling of groups throught separate `AttributeGroups` interface and its implementation? For me they are only additional info for GUI rendering. Much easier/simpler would be to keep `AttributeGroupMetadata` as field in `AttributeMetdata` of individual attributes, and let `org.keycloak.userprofile.DeclarativeUserProfileProvider.decorateUserProfileForCache(UserProfileMetadata, ComponentModel)` to set it into each attribute based on parsed configuration.",
43614225,ioemat,https://api.github.com/repos/keycloak/keycloak/pulls/8233,666899034,2021-07-09T12:05:42Z,server-spi-private/src/main/java/org/keycloak/userprofile/AttributeGroupMetadata.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import java.util.Map;++/**+ * Configuration of the attribute group.+ *+ * @author <a href=""joerg.matysiak@bosch.io"">Jrg Matysiak</a>+ */+public class AttributeGroupMetadata {","ok, since @pedroigor mention something similar above I'm going to adapt the code, will push an updated version probably on monday",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8252,666923468,2021-07-09T12:48:29Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/clientpolicy/executor/SecureCibaAuthenticationRequestSigningAlgorithmExecutor.java,"@@ -0,0 +1,161 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.protocol.oidc.grants.ciba.clientpolicy.executor;++import java.util.Arrays;+import java.util.HashMap;+import java.util.LinkedHashSet;+import java.util.Map;+import java.util.Optional;+import java.util.Set;++import org.jboss.logging.Logger;++import org.keycloak.OAuthErrorException;+import org.keycloak.crypto.Algorithm;+import org.keycloak.models.CibaConfig;+import org.keycloak.models.KeycloakSession;+import org.keycloak.representations.idm.ClientPolicyExecutorConfigurationRepresentation;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyContext;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.context.AdminClientRegisterContext;+import org.keycloak.services.clientpolicy.context.AdminClientUpdateContext;+import org.keycloak.services.clientpolicy.context.DynamicClientRegisterContext;+import org.keycloak.services.clientpolicy.context.DynamicClientUpdateContext;+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;++import com.fasterxml.jackson.annotation.JsonProperty;++/**+ * @author <a href=""mailto:takashi.norimatsu.ws@hitachi.com"">Takashi Norimatsu</a>+ */+public class SecureCibaAuthenticationRequestSigningAlgorithmExecutor implements ClientPolicyExecutorProvider<SecureCibaAuthenticationRequestSigningAlgorithmExecutor.Configuration> {++    private static final Logger logger = Logger.getLogger(SecureCibaAuthenticationRequestSigningAlgorithmExecutor.class);++    private final KeycloakSession session;+    private Configuration configuration;++    private static final String sigTarget = CibaConfig.CIBA_BACKCHANNEL_AUTH_REQUEST_SIGNING_ALG;++    private static final String DEFAULT_ALGORITHM_VALUE = Algorithm.PS256;++    static final Set<String> ALLOWED_ALGORITHMS = new LinkedHashSet<>(Arrays.asList(","I wonder if we can introduce the shared constant somewhere as this list of FAPI secured algorithms is repeated on few places. How about introduce the `FapiConstant` class and add the ALLOWED_ALGORITHMS constant there? This will allow that it can be consumed from all places (SecureCibaAuthenticationRequestSigningAlgorithmExecutor, SecureSigningAlgorithmExecutor, SecureSigningAlgorithmForSignedJwtExecutor and maybe more in the future if needed...).That way, if there are more FAPI supported algorithms in the future, we can change it in single place in the constant. WDYT?",
16761934,lscorcia,https://api.github.com/repos/keycloak/keycloak/pulls/7817,667502535,2021-07-11T16:06:23Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -369,9 +384,56 @@ public Response export(UriInfo uriInfo, RealmModel realm, String format) {                         }                     }); -            String descriptor = SPMetadataDescriptor.getSPDescriptor(authnBinding, endpoint, endpoint,-              wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,-              entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);+            // Prepare the metadata descriptor model+            StringWriter sw = new StringWriter();+            XMLStreamWriter writer = StaxUtil.getXMLStreamWriter(sw);+            SAMLMetadataWriter metadataWriter = new SAMLMetadataWriter(writer);++            EntityDescriptorType entityDescriptor = SPMetadataDescriptor.buildSPdescriptor(+                authnBinding, authnBinding, endpoint, endpoint,+                wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,+                entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);++            // Create the AttributeConsumingService+            AttributeConsumingServiceType attributeConsumingService = new AttributeConsumingServiceType(attributeConsumingServiceIndex);+            attributeConsumingService.setIsDefault(true);++            if (attributeConsumingServiceName != null && attributeConsumingServiceName.length() > 0)+            {+                String currentLocale = realm.getDefaultLocale() == null ? ""en"": realm.getDefaultLocale();+                LocalizedNameType attributeConsumingServiceNameElement = new LocalizedNameType(currentLocale);+                attributeConsumingServiceNameElement.setValue(attributeConsumingServiceName);+                attributeConsumingService.addServiceName(attributeConsumingServiceNameElement);+            }++            // Look for the SP descriptor and add the attribute consuming service+            for (EntityDescriptorType.EDTChoiceType choiceType: entityDescriptor.getChoiceType()) {+                List<EntityDescriptorType.EDTDescriptorChoiceType> descriptors = choiceType.getDescriptors();++                if (descriptors != null) {+                    for (EntityDescriptorType.EDTDescriptorChoiceType descriptor: descriptors) {+                        if (descriptor.getSpDescriptor() != null) {+                            descriptor.getSpDescriptor().addAttributeConsumerService(attributeConsumingService);+                        }+                    }+                }+            }+            +            // Add the attribute mappers+            realm.getIdentityProviderMappersByAliasStream(getConfig().getAlias())+                .forEach(mapper -> {+                    IdentityProviderMapper target = (IdentityProviderMapper) session.getKeycloakSessionFactory().getProviderFactory(IdentityProviderMapper.class, mapper.getIdentityProviderMapper());","I'm not really fluent with Java streams, but I tried and couldn't make it work because the `updateMetadata` call requires both the interface instance and the mapper model:```realm.getIdentityProviderMappersByAliasStream(getConfig().getAlias())  .map(mapper -> (IdentityProviderMapper) session.getKeycloakSessionFactory().getProviderFactory(IdentityProviderMapper.class, mapper.getIdentityProviderMapper()))  .filter(target -> target instanceof SamlMetadataDescriptorUpdater)  .map(target -> (SamlMetadataDescriptorUpdater)target)  .forEach(metadataAttrProvider -> metadataAttrProvider.updateMetadata(mapper, entityDescriptor)); << error here, mapper is unknown  ```I could probably change the last map call to return a pair-like object, but it seems much harder to read than the original foreach. WDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8227,668073616,2021-07-12T16:18:31Z,model/map/src/main/java/org/keycloak/models/map/authorization/MapPolicyStore.java,"@@ -111,8 +111,8 @@ public void delete(String id) {     public Policy findById(String id, String resourceServerId) {         LOG.tracef(""findById(%s, %s)%s"", id, resourceServerId, getShortStackTrace()); -        return tx.read(forResourceServer(resourceServerId)-                .compare(SearchableFields.ID, Operator.EQ, id))+        return tx.read(withCriteria(forResourceServer(resourceServerId)+                .compare(SearchableFields.ID, Operator.EQ, id)))                 .findFirst()","@hmlnarik I am just looking into this piece of code and it seems we should add the pagination to places like this. I think, we should go through the source code and optimize with pagination where possible. WDYT? And also should we do it as part of this PR or create and enhancement Jira in the cleanup epic? I would probably prefer the second option as this PR is already quite big.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8227,668546642,2021-07-13T08:32:36Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java,"@@ -88,15 +94,21 @@ public long delete(ModelCriteriaBuilder<M> criteria) {         }         Predicate<? super K> keyFilter = b.getKeyFilter();         Predicate<? super V> entityFilter = b.getEntityFilter();-        res = 0;-        for (Iterator<Entry<K, V>> iterator = store.entrySet().iterator(); iterator.hasNext();) {-            Entry<K, V> next = iterator.next();-            if (keyFilter.test(next.getKey()) && entityFilter.test(next.getValue())) {-                res++;-                iterator.remove();-            }+        Stream<Entry<K, V>> storeStream = store.entrySet().stream();+        final AtomicLong res = new AtomicLong(0);++        if (!queryParameters.getOrderBy().isEmpty()) {+            Comparator<V> comparator = MapFieldPredicates.getComparator(queryParameters.getOrderBy().stream());+            storeStream = storeStream.sorted((entry1, entry2) -> comparator.compare(entry1.getValue(), entry2.getValue()));         }-        return res;++        paginatedStream(storeStream.filter(next -> keyFilter.test(next.getKey()) && entityFilter.test(next.getValue()))+                , queryParameters.getOffset(), queryParameters.getLimit())","@hmlnarik Bad news, I am not sure currently, we can set the default limit for each query to 100. There were some test failures with it. The problem is, that we do something like this:```policyStore.findByResourceServer(id).stream()            .map(Policy::getId)            .forEach(policyStore::delete);```This code is executed when you remove a resource server (for example when disabling authz for a client). If the client has more than 100 policies, there are some policies left in the database. This can be fixed however, I would again do it as a follow up enhancement including setting some default value for the `limit` parameter. WDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8227,668563434,2021-07-13T08:53:33Z,model/map/src/main/java/org/keycloak/models/map/authorization/MapPolicyStore.java,"@@ -111,8 +111,8 @@ public void delete(String id) {     public Policy findById(String id, String resourceServerId) {         LOG.tracef(""findById(%s, %s)%s"", id, resourceServerId, getShortStackTrace()); -        return tx.read(forResourceServer(resourceServerId)-                .compare(SearchableFields.ID, Operator.EQ, id))+        return tx.read(withCriteria(forResourceServer(resourceServerId)+                .compare(SearchableFields.ID, Operator.EQ, id)))                 .findFirst()","Well, in this case probably yes because there will be most probably only one PolicyEntity with the given `id`. On the other hand, we should probably go through this as reading 100 objects from the database and then calling findFirst is really inefficient.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8227,668584523,2021-07-13T09:20:44Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java,"@@ -88,15 +94,21 @@ public long delete(ModelCriteriaBuilder<M> criteria) {         }         Predicate<? super K> keyFilter = b.getKeyFilter();         Predicate<? super V> entityFilter = b.getEntityFilter();-        res = 0;-        for (Iterator<Entry<K, V>> iterator = store.entrySet().iterator(); iterator.hasNext();) {-            Entry<K, V> next = iterator.next();-            if (keyFilter.test(next.getKey()) && entityFilter.test(next.getValue())) {-                res++;-                iterator.remove();-            }+        Stream<Entry<K, V>> storeStream = store.entrySet().stream();+        final AtomicLong res = new AtomicLong(0);++        if (!queryParameters.getOrderBy().isEmpty()) {+            Comparator<V> comparator = MapFieldPredicates.getComparator(queryParameters.getOrderBy().stream());+            storeStream = storeStream.sorted((entry1, entry2) -> comparator.compare(entry1.getValue(), entry2.getValue()));         }-        return res;++        paginatedStream(storeStream.filter(next -> keyFilter.test(next.getKey()) && entityFilter.test(next.getValue()))+                , queryParameters.getOffset(), queryParameters.getLimit())","Looking at this for the second time: I would argue that this is a misuse of reading - there should be a method ""delete all policies belonging to given resource server"" in the storage, e.g. `policyStore.deleteByResourceServer(id)`. This way, even caching would be able to invalidate the right events.I get your point though. How many places like this are in the codebase? It seems that they are located to fine-grained permissions?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8227,668628857,2021-07-13T10:18:19Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java,"@@ -88,15 +94,21 @@ public long delete(ModelCriteriaBuilder<M> criteria) {         }         Predicate<? super K> keyFilter = b.getKeyFilter();         Predicate<? super V> entityFilter = b.getEntityFilter();-        res = 0;-        for (Iterator<Entry<K, V>> iterator = store.entrySet().iterator(); iterator.hasNext();) {-            Entry<K, V> next = iterator.next();-            if (keyFilter.test(next.getKey()) && entityFilter.test(next.getValue())) {-                res++;-                iterator.remove();-            }+        Stream<Entry<K, V>> storeStream = store.entrySet().stream();+        final AtomicLong res = new AtomicLong(0);++        if (!queryParameters.getOrderBy().isEmpty()) {+            Comparator<V> comparator = MapFieldPredicates.getComparator(queryParameters.getOrderBy().stream());+            storeStream = storeStream.sorted((entry1, entry2) -> comparator.compare(entry1.getValue(), entry2.getValue()));         }-        return res;++        paginatedStream(storeStream.filter(next -> keyFilter.test(next.getKey()) && entityFilter.test(next.getValue()))+                , queryParameters.getOffset(), queryParameters.getLimit())","This is a good question. I don't know the answer yet. Potentially a lot, maybe only a few. I quickly looked at some occurences and clients/roles suffer from the same thing, so this is not only authz:https://github.com/keycloak/keycloak/blob/a8fdd79d1b9d78e94a7025e2a3f367561fd7557d/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java#L177-L184I would suggest to merge this as is, without the default value 100 for limit (current state of this PR), and add all discussed things in this PR in a separate Jira. The advantage would be, that all work that follows on this (Jpa, HotRod) can use changes from this PR immediately and these enhancements can be added anytime later as there won't be many conflicts probably. WDYT?The other option is to address it in this PR, however I am not sure how much time I will be able to spend on this as I need to investigate the HotRod stuff.",
43614225,ioemat,https://api.github.com/repos/keycloak/keycloak/pulls/8233,668858281,2021-07-13T15:09:14Z,server-spi-private/src/main/java/org/keycloak/userprofile/AttributeGroupMetadata.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.userprofile;++import java.util.Map;++/**+ * Configuration of the attribute group.+ *+ * @author <a href=""joerg.matysiak@bosch.io"">Jrg Matysiak</a>+ */+public class AttributeGroupMetadata {","@velias  @pedroigor, I pushed an update that provides group metadata as part of the attribute metadata",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8233,669331554,2021-07-14T06:38:25Z,server-spi-private/src/main/java/org/keycloak/userprofile/AttributeMetadata.java,"@@ -43,6 +43,8 @@      private final String attributeName;     private String attributeDisplayName;+    private String attributeGroup;","group name is inside of the `AttributeGroupMetadata`, so separate field `attributeGroup` is not necessary here I think",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8264,670241732,2021-07-15T08:19:21Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/MapStorageTest.java,"@@ -35,6 +36,7 @@ import org.jboss.logging.Logger; import org.junit.Before; import org.junit.Test;+import static org.apache.commons.logging.LogFactory.getFactory;",nit: unused import,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8220,670362800,2021-07-15T11:06:38Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/i18n/LoginPageTest.java,"@@ -242,6 +248,31 @@ public void languageUserUpdates() {         Assert.assertNull(localeCookie);     } +    // KEYCLOAK-18590+    @Test+    public void realmLocalizationMessagesAreNotCachedWithinTheTheme() {+        final String locale = Locale.ENGLISH.toLanguageTag();++        final String realmLocalizationMessageKey = ""loginAccountTitle"";+        final String realmLocalizationMessageValue = ""Localization Test"";++        CloseableHttpClient httpClient = (CloseableHttpClient) new HttpClientBuilder().build();","Ensire that you always close any `Response` and `HttpClient` objects, unclosed connections affect stability of the testsuite. Ideally use `try`-with-resources construct to account for the failure as well, see e.g. https://github.com/keycloak/keycloak/blob/c29b8c73a108125511693ec337bc6bb8e9e15cea/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/servlet/SAMLServletAdapterTest.java#L1365-L1373 for correct sample.Also see `org.keycloak.testsuite.util.AdminClientUtil.createResteasyClient()` for preferred method to create RestEasy client",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8271,670472767,2021-07-15T13:40:58Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultUserProfile.java,"@@ -42,14 +43,21 @@  */ public final class DefaultUserProfile implements UserProfile { +    protected final UserProfileMetadata metadata;     private final Function<Attributes, UserModel> userSupplier;     private final Attributes attributes;     private final KeycloakSession session;     private boolean validated;     private UserModel user; -    public DefaultUserProfile(Attributes attributes, Function<Attributes, UserModel> userCreator, UserModel user,+    /**+     * Contexts where change of email address automatically resets {@link UserModel#EMAIL_VERIFIED} to <code>false</code> +     */+    protected static final Set<UserProfileContext> RESET_EMAIL_VERIFIED_CONTEXTS = new HashSet<>(Arrays.asList(UserProfileContext.ACCOUNT, UserProfileContext.ACCOUNT_OLD, UserProfileContext.UPDATE_PROFILE));",I think we finally found a situation where the context should be configured with its own metadata to change specific behavior.I would change the context enum to provide a method `isResetEmailVerified` instead of using this construct. We might need in the future to have more metadata associated with contexts.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8271,670474869,2021-07-15T13:43:18Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultUserProfile.java,"@@ -113,6 +121,11 @@ private UserModel updateInternal(UserModel user, boolean removeAttributes, BiCon                  if (currentValue.size() != updatedValue.size() || !currentValue.containsAll(updatedValue)) {                     user.setAttribute(name, updatedValue);+                    +                    if(UserModel.EMAIL.equals(name) && RESET_EMAIL_VERIFIED_CONTEXTS.contains(metadata.getContext())) {",I think this type of logic is also solved by what we are discussing around listening for attribute changes.We could probably work on this capability prior to introducing this logic to reset email verified.,
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8271,670491276,2021-07-15T14:00:49Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultUserProfile.java,"@@ -113,6 +121,11 @@ private UserModel updateInternal(UserModel user, boolean removeAttributes, BiCon                  if (currentValue.size() != updatedValue.size() || !currentValue.containsAll(updatedValue)) {                     user.setAttribute(name, updatedValue);+                    +                    if(UserModel.EMAIL.equals(name) && RESET_EMAIL_VERIFIED_CONTEXTS.contains(metadata.getContext())) {","Or we can merge this PR and then move this logic into the attribute change listener as an example of its use in the listener PR. Whatever works for you, I don't mind too much (but hope listener will be here soon not to have too much conflicts in this PR while it waits for listeners ;-)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8274,672281058,2021-07-19T13:08:17Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureResponseTypeExecutor.java,"@@ -128,6 +129,15 @@ public void executeOnAuthorizationRequest(             }         } +        if (request.getResponseMode() != null) {+            if (parsedResponseType.hasResponseType(OIDCResponseType.CODE)) {","I think that this condition will be true also for the case when for example `response_type=code id_token` . However if I understand correctly the specification https://openid.net/specs/openid-financial-api-part-2-1_0.html#authorization-server , it mentions that:```the response_type value code in conjunction with the response_mode value jwt; ```So if I understand correctly, the response_type must be exactly `code` , which means that ID Token (or access token) should not be sent in the authorization response when JARM is used.Does it makes sense to you? If yes, will it be possible to slightly update this and make sure we have test for the case when `response_type=code id_token` is rejected when `response_mode=jwt` is used?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8274,672427773,2021-07-19T15:57:22Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureResponseTypeExecutor.java,"@@ -128,6 +129,15 @@ public void executeOnAuthorizationRequest(             }         } +        if (request.getResponseMode() != null) {+            if (parsedResponseType.hasResponseType(OIDCResponseType.CODE)) {","The previous check already checks if the hybrid flow was requested. Pretty much the same behavior as before.But if we want to be more explicit and expect a single response type in the list of response types, we can do it. I think the specs are basically protecting code using JARM so for me a `has` is OK.Whatever you prefer.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8261,672498485,2021-07-19T17:36:33Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java,"@@ -229,6 +243,12 @@ private void executeOnAuthorizationRequest(             throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter. Parameters in 'request' object not matching with request parameters"");         } +        Boolean encryptionRequired = Optional.ofNullable(configuration.isEncryptionRequired()).orElse(Boolean.FALSE);+        if (encryptionRequired && session.getAttribute(AuthzEndpointRequestParser.AUTHZ_REQUEST_OBJECT_ENCRYPTED) == null) {","@pedroigor It seems to me that with this flag `encryptionRequired` set to true, all clients in the realm (which will pass the client policy conditions) will be required to use encrypted request objects. Which I am not sure if it is desired behaviour.IMO it will be good to stick with the same like for request object signatures. Which means that it would be enforced per the client if request object is encrypted just in case that ` request.object.encryption.alg` is used for particular client. And this is already done in this PR (in AuthzEndpointRequestObjectParser).In shortcut, my vote is to remove flag `encryptionRequired` from SecureRequestObjectExecutor. WDYT?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8261,672549764,2021-07-19T18:54:13Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java,"@@ -229,6 +243,12 @@ private void executeOnAuthorizationRequest(             throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter. Parameters in 'request' object not matching with request parameters"");         } +        Boolean encryptionRequired = Optional.ofNullable(configuration.isEncryptionRequired()).orElse(Boolean.FALSE);+        if (encryptionRequired && session.getAttribute(AuthzEndpointRequestParser.AUTHZ_REQUEST_OBJECT_ENCRYPTED) == null) {","As you mentioned, clients that match the policy conditions.I've opened a discussion on keycloak-dev about this topic in order to understand whether a setting should be at the client or at the client policy.I agree with @tnorimat that moving configuration to policies is the best to do. And whether encryption is required looks like a good example.As per signature, I guess it was done before client policies support. Right?I'm not sure, for me either way works. Let me know if the above makes sense if not I can change to do the same as signature.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8261,672633565,2021-07-19T21:09:29Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCConfigAttributes.java,"@@ -21,6 +21,8 @@     public static final String USER_INFO_RESPONSE_SIGNATURE_ALG = ""user.info.response.signature.alg"";      public static final String REQUEST_OBJECT_SIGNATURE_ALG = ""request.object.signature.alg"";+    public static final String REQUEST_OBJECT_ENCRYPTION_ALG = ""request.object.encryption.alg"";+    public static final String REQUEST_OBJECT_ENCRYPTION_ENC_ALG = ""request.object.encryption.enc.alg"";","According to https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata, it might be better to be ```public static final String REQUEST_OBJECT_ENCRYPTION_ENC = ""request.object.encryption.enc"";```WDYT?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8261,672641539,2021-07-19T21:23:38Z,themes/src/main/resources/theme/base/admin/resources/partials/client-detail.html,"@@ -559,6 +559,34 @@                 </div>                 <kc-tooltip>{{:: 'request-object-signature-alg.tooltip' | translate}}</kc-tooltip>             </div>+            <div class=""form-group clearfix block"" data-ng-show=""protocol == 'openid-connect'"">+                <label class=""col-md-2 control-label"" for=""requestObjectEncryptionAlg"">{{:: 'request-object-encryption-alg' | translate}}</label>+                <div class=""col-sm-6"">+                    <div>+                        <select class=""form-control"" id=""requestObjectEncryptionAlg""+                                ng-change=""changeRequestObjectEncryptionAlg()""+                                ng-model=""requestObjectEncryptionAlg"">+                            <option value=""any"">any</option>+                            <option ng-repeat=""provider in serverInfo.listProviderIds('cekmanagement')"" value=""{{provider}}"">{{provider}}</option>+                        </select>+                    </div>+                </div>+                <kc-tooltip>{{:: 'request-object-encryption-alg.tooltip' | translate}}</kc-tooltip>+            </div>+            <div class=""form-group clearfix block"" data-ng-show=""protocol == 'openid-connect'"">+                <label class=""col-md-2 control-label"" for=""requestObjectEncryptionEncAlg"">{{:: 'request-object-encryption-enc-alg' | translate}}</label>","If https://github.com/keycloak/keycloak/pull/8261/files#r672633565 is agreed, it might be better to be```<label class=""col-md-2 control-label"" for=""requestObjectEncryptionEnc"">{{:: 'request-object-encryption-enc' | translate}}</label>```",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8261,672642132,2021-07-19T21:24:43Z,themes/src/main/resources/theme/base/admin/resources/partials/client-detail.html,"@@ -559,6 +559,34 @@                 </div>                 <kc-tooltip>{{:: 'request-object-signature-alg.tooltip' | translate}}</kc-tooltip>             </div>+            <div class=""form-group clearfix block"" data-ng-show=""protocol == 'openid-connect'"">+                <label class=""col-md-2 control-label"" for=""requestObjectEncryptionAlg"">{{:: 'request-object-encryption-alg' | translate}}</label>+                <div class=""col-sm-6"">+                    <div>+                        <select class=""form-control"" id=""requestObjectEncryptionAlg""+                                ng-change=""changeRequestObjectEncryptionAlg()""+                                ng-model=""requestObjectEncryptionAlg"">+                            <option value=""any"">any</option>+                            <option ng-repeat=""provider in serverInfo.listProviderIds('cekmanagement')"" value=""{{provider}}"">{{provider}}</option>+                        </select>+                    </div>+                </div>+                <kc-tooltip>{{:: 'request-object-encryption-alg.tooltip' | translate}}</kc-tooltip>+            </div>+            <div class=""form-group clearfix block"" data-ng-show=""protocol == 'openid-connect'"">+                <label class=""col-md-2 control-label"" for=""requestObjectEncryptionEncAlg"">{{:: 'request-object-encryption-enc-alg' | translate}}</label>+                <div class=""col-sm-6"">+                    <div>+                        <select class=""form-control"" id=""requestObjectEncryptionEncAlg""","If https://github.com/keycloak/keycloak/pull/8261/files#r672633565 is agreed, it might be better to be```<select class=""form-control"" id=""requestObjectEncryptionEnc""    ng-change=""changeRequestObjectEncryptionEnc()""     ng-model=""requestObjectEncryptionEnc"">```",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8273,672862468,2021-07-20T07:07:57Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -147,9 +151,36 @@ public UserRepresentation account() {          rep.setAttributes(profile.getAttributes().getReadable(false)); +        if(userProfileMetadata == null || userProfileMetadata.booleanValue())+            rep.setUserProfileMetadata(createUserProfileMetadata(profile));+                 return rep;     }+    +    private UserProfileMetadata createUserProfileMetadata(final UserProfile profile) {+        Map<String, List<String>> am = profile.getAttributes().getReadable();+        +        if(am == null)+            return null;+        +        List<UserProfileAttributeMetadata> attributes = am.keySet().stream()+                                                          .map(name -> profile.getAttributes().getMetadata(name))+                                                          .filter(Objects::nonNull)+                                                          .sorted((a,b) -> Integer.compare(a.getGuiOrder(), b.getGuiOrder()))+                                                          .map(sam -> toRestMetadata(sam, profile))+                                                          .collect(Collectors.toList());  +        return new UserProfileMetadata(attributes);+    } +    private UserProfileAttributeMetadata toRestMetadata(AttributeMetadata am, UserProfile profile) {+        return new UserProfileAttributeMetadata(am.getName(), +                                                am.getAttributeDisplayName(), +                                                profile.getAttributes().isRequired(am.getName()), +                                                profile.getAttributes().isReadOnly(am.getName()), +                                                am.getAnnotations(), +                                                am.getValidators() == null ? null : am.getValidators().stream().filter(avm -> !avm.getValidatorId().startsWith(""up-"")).collect(Collectors.toMap(AttributeValidatorMetadata::getValidatorId, AttributeValidatorMetadata::getValidatorConfig)));","I though about it before, but I'm not sure if this should be in Validator SPI itself. This mechanism for hiding is really internal, specific for user profile only, not sure if it should be in generic SPI which can provide validators for other use cases. If yes then it should be some form of more generic flagging probably rather than one true/false method.Another approach might be use of marking interface for these validators. But drawback of this solution (same as for the previous solution) is that it will be necessary to really get validator from SPI to check if it should be put into metadata. This adds extra processing and will slow down REST responses each time metadata are collected (probably not too much, but still).This is why I implemented mechanism based on the naming convention of the `validatorId` which is there already, without need to query Validator SPI at all.If you don't like this approach, we should maybe use validator configuration, as it is also available for the processing without need to query SPI. For user profile internal validators we can put some key into the cinfig and filter metadata for the REST API based on it's presence. We can maybe even document this as a feature how to prevent some validator configured in UserProfile JSON to be announced in REST API.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8261,672873496,2021-07-20T07:25:43Z,services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java,"@@ -229,6 +243,12 @@ private void executeOnAuthorizationRequest(             throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, ""Invalid parameter. Parameters in 'request' object not matching with request parameters"");         } +        Boolean encryptionRequired = Optional.ofNullable(configuration.isEncryptionRequired()).orElse(Boolean.FALSE);+        if (encryptionRequired && session.getAttribute(AuthzEndpointRequestParser.AUTHZ_REQUEST_OBJECT_ENCRYPTED) == null) {","Yes, we discussed this already some time ago during work on client policies and during designing client policies. And I also agree that it will be nice to move many of client switches and keep them at the client policy level. This will allow some flexibility (EG. enforce secure ID Token signature algorithm just in case that `scope=fapi` is requested, which is possible due the fact that client policy condition will be evaluated just with the  `scope=fapi` and the particular executor for enforce algorithm will be also called just at that time etc).However one thing is, that some configurations are enforced by OIDC specification itself at the client level (like the `request_object_encryption_alg` and `request_object_encryption_enc`) and hence for those switches we need to stick them at the client level exactly as you did in this PR.I am personally still not sure if the particular switch `encryptionRequired` is needed on the executor as we don't have similar thing for the signature, but I don't see this as a blocker in this PR as it is false by default anyway. so I am approving this. Thanks for the updates!",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8273,673004155,2021-07-20T10:32:43Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -147,9 +151,36 @@ public UserRepresentation account() {          rep.setAttributes(profile.getAttributes().getReadable(false)); +        if(userProfileMetadata == null || userProfileMetadata.booleanValue())+            rep.setUserProfileMetadata(createUserProfileMetadata(profile));+                 return rep;     }+    +    private UserProfileMetadata createUserProfileMetadata(final UserProfile profile) {+        Map<String, List<String>> am = profile.getAttributes().getReadable();+        +        if(am == null)+            return null;+        +        List<UserProfileAttributeMetadata> attributes = am.keySet().stream()+                                                          .map(name -> profile.getAttributes().getMetadata(name))+                                                          .filter(Objects::nonNull)+                                                          .sorted((a,b) -> Integer.compare(a.getGuiOrder(), b.getGuiOrder()))+                                                          .map(sam -> toRestMetadata(sam, profile))+                                                          .collect(Collectors.toList());  +        return new UserProfileMetadata(attributes);+    } +    private UserProfileAttributeMetadata toRestMetadata(AttributeMetadata am, UserProfile profile) {+        return new UserProfileAttributeMetadata(am.getName(), +                                                am.getAttributeDisplayName(), +                                                profile.getAttributes().isRequired(am.getName()), +                                                profile.getAttributes().isReadOnly(am.getName()), +                                                am.getAnnotations(), +                                                am.getValidators() == null ? null : am.getValidators().stream().filter(avm -> !avm.getValidatorId().startsWith(""up-"")).collect(Collectors.toMap(AttributeValidatorMetadata::getValidatorId, AttributeValidatorMetadata::getValidatorConfig)));","Implemented configuration based approach to hide validators from REST Account API metadata.Failing test doesn't look to be related, but I'm not fully sure what it tests. Could you check please?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/7817,673972905,2021-07-21T13:29:27Z,services/src/main/java/org/keycloak/broker/saml/SAMLIdentityProvider.java,"@@ -369,9 +384,56 @@ public Response export(UriInfo uriInfo, RealmModel realm, String format) {                         }                     }); -            String descriptor = SPMetadataDescriptor.getSPDescriptor(authnBinding, endpoint, endpoint,-              wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,-              entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);+            // Prepare the metadata descriptor model+            StringWriter sw = new StringWriter();+            XMLStreamWriter writer = StaxUtil.getXMLStreamWriter(sw);+            SAMLMetadataWriter metadataWriter = new SAMLMetadataWriter(writer);++            EntityDescriptorType entityDescriptor = SPMetadataDescriptor.buildSPdescriptor(+                authnBinding, authnBinding, endpoint, endpoint,+                wantAuthnRequestsSigned, wantAssertionsSigned, wantAssertionsEncrypted,+                entityId, nameIDPolicyFormat, signingKeys, encryptionKeys);++            // Create the AttributeConsumingService+            AttributeConsumingServiceType attributeConsumingService = new AttributeConsumingServiceType(attributeConsumingServiceIndex);+            attributeConsumingService.setIsDefault(true);++            if (attributeConsumingServiceName != null && attributeConsumingServiceName.length() > 0)+            {+                String currentLocale = realm.getDefaultLocale() == null ? ""en"": realm.getDefaultLocale();+                LocalizedNameType attributeConsumingServiceNameElement = new LocalizedNameType(currentLocale);+                attributeConsumingServiceNameElement.setValue(attributeConsumingServiceName);+                attributeConsumingService.addServiceName(attributeConsumingServiceNameElement);+            }++            // Look for the SP descriptor and add the attribute consuming service+            for (EntityDescriptorType.EDTChoiceType choiceType: entityDescriptor.getChoiceType()) {+                List<EntityDescriptorType.EDTDescriptorChoiceType> descriptors = choiceType.getDescriptors();++                if (descriptors != null) {+                    for (EntityDescriptorType.EDTDescriptorChoiceType descriptor: descriptors) {+                        if (descriptor.getSpDescriptor() != null) {+                            descriptor.getSpDescriptor().addAttributeConsumerService(attributeConsumingService);+                        }+                    }+                }+            }+            +            // Add the attribute mappers+            realm.getIdentityProviderMappersByAliasStream(getConfig().getAlias())+                .forEach(mapper -> {+                    IdentityProviderMapper target = (IdentityProviderMapper) session.getKeycloakSessionFactory().getProviderFactory(IdentityProviderMapper.class, mapper.getIdentityProviderMapper());","I see. I think you are right, this way it is easier to read. I just don't like that the lambda is quite long, but I don't see a better option.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/7892,674073647,2021-07-21T15:21:47Z,services/src/main/java/org/keycloak/services/managers/ClientManager.java,"@@ -355,4 +357,7 @@ private boolean showClientCredentialsAdapterConfig(ClientModel client) {         return authenticator.getAdapterConfiguration(client);     } +    private boolean isInternalClient(Stream<RealmModel> stream, String clientId) {+        return stream.anyMatch(realm -> clientId.equals(realm.getName() + ""-realm""));+    }","There is no need to go through all existing realms here, with large number of realms it could become costly operation. Can it be used `session.realms().getRealmByName()` instead?",
16761934,lscorcia,https://api.github.com/repos/keycloak/keycloak/pulls/7817,674996790,2021-07-22T17:09:52Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/KcSamlAttributeConsumingServiceIndexTest.java,"@@ -14,7 +14,9 @@ import org.junit.Assert; import org.junit.Test; import org.w3c.dom.Document;+import org.w3c.dom.Element;","If you're ok with that, I can fix it in the next PR I have prepared already, i.e. metadata support for ""SAML Attribute to Role"" mapper.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7323,675073578,2021-07-22T18:39:55Z,services/src/main/java/org/keycloak/social/apple/AppleIdentityProvider.java,"@@ -0,0 +1,277 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.social.apple;++import com.fasterxml.jackson.core.JsonProcessingException;+import com.fasterxml.jackson.databind.JsonNode;+import com.fasterxml.jackson.databind.ObjectMapper;+import org.apache.commons.lang.StringUtils;+import org.jboss.logging.Logger;+import org.keycloak.OAuth2Constants;+import org.keycloak.OAuthErrorException;+import org.keycloak.broker.oidc.OIDCIdentityProvider;+import org.keycloak.broker.oidc.OIDCIdentityProviderConfig;+import org.keycloak.broker.oidc.mappers.AbstractJsonUserAttributeMapper;+import org.keycloak.broker.provider.BrokeredIdentityContext;+import org.keycloak.broker.provider.util.SimpleHttp;+import org.keycloak.broker.social.SocialIdentityProvider;+import org.keycloak.common.ClientConnection;+import org.keycloak.common.util.Time;+import org.keycloak.crypto.KeyWrapper;+import org.keycloak.crypto.ServerECDSASignatureSignerContext;+import org.keycloak.events.Errors;+import org.keycloak.events.EventBuilder;+import org.keycloak.events.EventType;+import org.keycloak.jose.jws.JWSBuilder;+import org.keycloak.jose.jws.JWSInput;+import org.keycloak.jose.jws.JWSInputException;+import org.keycloak.models.KeycloakContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.RealmModel;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.representations.JsonWebToken;+import org.keycloak.services.ErrorPage;+import org.keycloak.services.Urls;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.FormParam;+import javax.ws.rs.POST;+import javax.ws.rs.WebApplicationException;+import javax.ws.rs.core.Context;+import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.Response;+import java.security.KeyFactory;+import java.security.PrivateKey;+import java.security.spec.PKCS8EncodedKeySpec;+import java.util.Base64;++/**+ * @author Emilien Bondu+ */+public class AppleIdentityProvider extends OIDCIdentityProvider implements SocialIdentityProvider<OIDCIdentityProviderConfig> {++    private static final String OAUTH2_PARAMETER_CODE = ""code"";++    private static final String OAUTH2_PARAMETER_STATE = ""state"";++    private static final String OAUTH2_PARAMETER_USER = ""user"";++    public static final String ACCESS_DENIED = ""access_denied"";++    protected static ObjectMapper mapper = new ObjectMapper();++    public static final String AUTH_URL = ""https://appleid.apple.com/auth/authorize?response_mode=form_post"";++    public static final String TOKEN_URL = ""https://appleid.apple.com/auth/token"";++    public static final String ISSUER = ""https://appleid.apple.com"";++    public static final String JWKS_URL = ""https://appleid.apple.com/auth/keys"";++    public static final String EMAIL_SCOPE = ""email"";++    public static final String NAME_SCOPE = ""name"";++    protected static final Logger logger = Logger.getLogger(AppleIdentityProvider.class);++    public AppleIdentityProvider(KeycloakSession session, AppleIdentityProviderConfig config) {+        super(session, config);++        config.setAuthorizationUrl(AUTH_URL);+        config.setTokenUrl(TOKEN_URL);+        config.setClientAuthMethod(OIDCLoginProtocol.CLIENT_SECRET_POST);+        config.setIssuer(ISSUER);+        config.setUseJwksUrl(true);+        config.setValidateSignature(true);+        config.setJwksUrl(JWKS_URL);+        String defaultScope = config.getDefaultScope();++        if (!isValidSecret(config.getClientSecret())) {+            config.setClientSecret(generateJWS(+                    config.getP8Content(),+                    config.getKeyId(),+                    config.getTeamId())+            );+        }++        if (defaultScope ==  null || defaultScope.trim().equals("""")) {+            config.setDefaultScope(""openid""+ "" "" + NAME_SCOPE+ "" "" + EMAIL_SCOPE);+        }+    }++    @Override+    public Object callback(RealmModel realm, AuthenticationCallback callback, EventBuilder event) {+        return new Endpoint(realm, callback, event);+    }++    @Override+    protected String getDefaultScopes() {+        return ""openid""+ "" "" + NAME_SCOPE+ "" "" + EMAIL_SCOPE;+    }++    protected class Endpoint {","I see. You can add the POST variant of `authResponse` to to your sub-type of `OIDCEndpoint`. I'm only asking for this to leverage existing functionality (like logout, if that works for apple identity) and avoid duplication.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8241,675330160,2021-07-23T06:19:19Z,services/src/main/java/org/keycloak/services/clientpolicy/context/DeviceAuthorizationRequestContext.java,"@@ -0,0 +1,52 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.context;","@tnorimat Is it possible that stuff related to device grant is wrapped in the single place in the codebase whenever possible? Similarly like we try to do for CIBA for example. Hence it is possible to move this class to some sub-package under ""org.keycloak.protocol.oidc.grants.device"" ?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8241,675330230,2021-07-23T06:19:34Z,services/src/main/java/org/keycloak/services/clientpolicy/context/DeviceTokenRequestContext.java,"@@ -0,0 +1,52 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.clientpolicy.context;",Same package comment like for the other class.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8123,675357683,2021-07-23T07:25:58Z,core/src/main/java/org/keycloak/representations/oidc/OIDCClientRepresentation.java,"@@ -62,6 +62,8 @@      private String jwks_uri; +    private String jwks_string;",I see you added `jwks_string` to this representation class. I think this is not correct as the field `jwks_string` is not described in the OIDC client registration specification https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata . We can't add random fields to this representation as it needs to conform with the format of OIDC specification (or other specifications like EG. CIBA which introduce any client metadata). Or is it referenced from any other specification?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8288,675481977,2021-07-23T10:58:42Z,model/map/src/main/java/org/keycloak/models/map/authSession/MapRootAuthenticationSessionProviderFactory.java,"@@ -26,7 +26,7 @@ /**  * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>  */-public class MapRootAuthenticationSessionProviderFactory<K> extends AbstractMapProviderFactory<AuthenticationSessionProvider, K, MapRootAuthenticationSessionEntity<K>, RootAuthenticationSessionModel>+public class MapRootAuthenticationSessionProviderFactory<K> extends AbstractMapProviderFactory<AuthenticationSessionProvider, K, MapRootAuthenticationSessionEntity, RootAuthenticationSessionModel>","It seems this `K` template parameter is unused, should we remove as well?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8288,675558212,2021-07-23T13:19:21Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapKeycloakTransaction.java,"@@ -207,16 +209,21 @@ private V getUpdated(V orig) {      @Override     public V create(V value) {-        K key = value.getId();+        String key = value.getId();+        if (key == null) {+            K newKey = keyConvertor.yieldNewUniqueKey();+            key = keyConvertor.keyToString(newKey);+            value = Serialization.from(value, key);","~FTR: In here we need always to make a copy of a value from the parameter, to ensure that the caller does not get the direct reference to the entered entity (which could be of a completely different type than `Map*EntityImpl`)~The problems with `setId` are far-reaching especially in the context of the future tree store. For that reason, I did not want to get into allowing setting the ID by default for any AbstractEntity",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8314,676108873,2021-07-25T08:36:03Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java,"@@ -42,12 +49,16 @@ import javax.ws.rs.core.HttpHeaders; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response;+",some import directives are no longer used.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8314,676747709,2021-07-26T16:10:29Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java,"@@ -158,4 +180,52 @@ private void denyRequest(AccessToken authReqId, Status status) {          store.deny(realm, authReqId.getId());     }++    protected void sendClientNotificationRequest(ClientModel client, CibaConfig cibaConfig, OAuth2DeviceCodeModel deviceModel) {+        String clientNotificationEndpoint = cibaConfig.getBackchannelClientNotificationEndpoint(client);+        if (clientNotificationEndpoint == null) {+            event.error(Errors.INVALID_REQUEST);+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, ""Client notification endpoint not set for the client with the ping mode"",+                    Response.Status.BAD_REQUEST);+        }++        logger.debugf(""Sending request to client notification endpoint '%s' for the client '%s'"", clientNotificationEndpoint, client.getClientId());++        ClientNotificationEndpointRequest clientNotificationRequest = new ClientNotificationEndpointRequest();+        clientNotificationRequest.setAuthReqId(deviceModel.getAuthReqId());++        SimpleHttp simpleHttp = SimpleHttp.doPost(clientNotificationEndpoint, session)","The timeouts are configurable already at the level of `DefaultHttpClientFactory` . This is for whole server, but IMO it can be sufficient for now?As I see that there is not any other Keycloak functioality, which use timeouts specific per the functionality (including for example requests to Http Channel Provider, JWKS URL or all the other stuff where KEycloak sends some backend requests). Or did I miss any, which already use more fine-grained timeouts?My vote is to add some more fine-grained timeouts support just if someone explicitly requests it for the client notification endpoint as each configuration option has some side-effect of the increased complexity...",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8314,676756435,2021-07-26T16:21:39Z,services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/CibaClientValidation.java,"@@ -0,0 +1,89 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.protocol.oidc.grants.ciba;++import java.util.stream.Collectors;+import java.util.stream.Stream;++import com.google.common.collect.Streams;+import org.keycloak.crypto.ClientSignatureVerifierProvider;+import org.keycloak.crypto.SignatureProvider;+import org.keycloak.jose.jws.Algorithm;+import org.keycloak.models.CibaConfig;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.provider.ProviderFactory;+import org.keycloak.validation.DefaultClientValidationProvider;+import org.keycloak.validation.ValidationContext;++import static org.keycloak.common.util.UriUtils.checkUrl;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class CibaClientValidation {++    private final ValidationContext<ClientModel> context;++    public CibaClientValidation(ValidationContext<ClientModel> context) {+        this.context = context;+    }++    public void validate() {+        ClientModel client = context.getObjectToValidate();++        // Check only ping mode and poll mode allowed+        CibaConfig cibaConfig = client.getRealm().getCibaPolicy();+        String cibaMode = cibaConfig.getBackchannelTokenDeliveryMode(client);+        if (!CibaConfig.CIBA_SUPPORTED_MODES.contains(cibaMode)) {+            context.addError(""cibaBackchannelTokenDeliveryMode"", ""Unsupported requested CIBA Backchannel Token Delivery Mode"", ""invalidCibaBackchannelTokenDeliveryMode"");+        }++        // Check clientNotificationEndpoint URL configured for ping mode+        if (CibaConfig.CIBA_PING_MODE.equals(cibaMode)) {+            if (cibaConfig.getBackchannelClientNotificationEndpoint(client) == null) {+                context.addError(""cibaBackchannelClientNotificationEndpoint"", ""CIBA Backchannel Client Notification Endpoint must be set for the CIBA ping mode"", ""missingCibaBackchannelClientNotificationEndpoint"");+            }+        }++        // Validate clientNotificationEndpoint URL itself+        try {+            checkUrl(client.getRealm().getSslRequired(), cibaConfig.getBackchannelClientNotificationEndpoint(client), ""backchannel_client_notification_endpoint"");","Yes, I use this as aligned with the other functionality, which use `https` . So just in the dev environment like `localhost` etc are allowed non-secure URLs. This is aligned with some other similar functionalities in Keycloak (EG. see `OIDCIdentityProviderConfig.validate()` ).However I've added also check to the `SecureClientUrisExecutor` to doublecheck for enforced `https` in the FAPI concept in similar manner like other client URLs. Also added note to the https://issues.redhat.com/browse/KEYCLOAK-18883 that we document it. Is it ok for you?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8321,677956536,2021-07-28T04:04:51Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -87,6 +87,7 @@ import org.keycloak.testsuite.admin.ApiUtil; import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude; import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer;+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;","Thanks, I've removed this and also some more unused imports from ClientPoliciesTest class. Could you please re-check?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8321,677956565,2021-07-28T04:04:56Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -117,6 +118,8 @@ import static org.junit.Assert.fail; import static org.keycloak.testsuite.admin.AbstractAdminTest.loadJson; import static org.keycloak.testsuite.admin.ApiUtil.findUserByUsername;+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.QUARKUS;+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.REMOTE;","Thanks, I've removed this and also some more unused imports from ClientPoliciesTest class. Could you please re-check?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8322,678024230,2021-07-28T06:53:36Z,core/src/main/java/org/keycloak/protocol/oidc/representations/MTLSEndpointAliases.java,"@@ -0,0 +1,125 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.protocol.oidc.representations;++import java.util.HashMap;+import java.util.Map;++import com.fasterxml.jackson.annotation.JsonAnyGetter;+import com.fasterxml.jackson.annotation.JsonAnySetter;+import com.fasterxml.jackson.annotation.JsonProperty;++public class MTLSEndpointAliases {","@tnorimat Thanks for the suggestion. Since the OIDC WellKnown is supposed to contain only standard data defined in the specifications, my vote is to include just those data. For this Backchannel Logout Endpoint, we don't include it in the OIDC WellKnown endpoint itself and hence IMO it will be good to not include it also in the mtls_endpoint_aliases. Does it makes sense?In the OIDC Wellknown endpoint, we have only ""end_session_endpoint"", but that is supposed for the browser logouts and not subject to cert-bound access tokens if I understand correctly?",
85695506,Kanzow-IHK,https://api.github.com/repos/keycloak/keycloak/pulls/8156,679008964,2021-07-29T09:59:22Z,saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/assertion/SAMLAttributeValueParser.java,"@@ -105,7 +105,23 @@ public Object parse(XMLEventReader xmlEventReader) throws ParsingException {             return StaxParserUtil.getElementText(xmlEventReader);         } -        throw logger.parserUnknownXSI(typeValue);+        // KEYCLOAK-18417: Simply ignore unknown types+        logger.warn(""Skipping attribute value of unsupported type "" + typeValue);","In this class, a PicketLinkLogger is used, it has no method debugf(). I do not want to change too much of the existing code, so I'd rather go with ` logger.debug(""Skipping attribute value of unsupported type "" + typeValue);`",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8156,679027435,2021-07-29T10:26:28Z,saml-core/src/main/java/org/keycloak/saml/processing/core/parsers/saml/assertion/SAMLAttributeValueParser.java,"@@ -105,7 +105,23 @@ public Object parse(XMLEventReader xmlEventReader) throws ParsingException {             return StaxParserUtil.getElementText(xmlEventReader);         } -        throw logger.parserUnknownXSI(typeValue);+        // KEYCLOAK-18417: Simply ignore unknown types+        logger.warn(""Skipping attribute value of unsupported type "" + typeValue);+        skipElementAndSubElements(xmlEventReader);","> Changed this according to your suggestion. Just a remark: The method `StaxParserUtil.bypassElementBlock(xmlEventReader)`uses exactly the same mechanism that I proposed, the only difference being that it implements incrementing and decrementing of a counter instead of recursion (the result is the same, though, honestly I do not see how either implementation could lead to infinite loops).Thank you.When the SAML document contains some other entities, e.g. comments or characters, the `xmlEventReader.peek()` would keep peeking the same event indefinitely. To get the event consumed, at some point, `xmlEventReader.nextEvent()` must be called. See https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/events/XMLEvent.html for all possible events, some of which might appear in the body of that method.You're right though that your code would not be cycling indefinintely, I did not realize there is call for `next()` in the `if` condition. In your case thus this would have done almost the same thing by calling `xmlEventReader.next()`. However there should be no duplication of the code, so `StaxParserUtil.bypassElementBlock(xmlEventReader)` is preferred.",
6230308,mduchrow,https://api.github.com/repos/keycloak/keycloak/pulls/8336,680487016,2021-08-01T10:10:16Z,services/src/main/java/org/keycloak/protocol/oidc/AccessTokenIntrospectionProvider.java,"@@ -56,7 +57,11 @@ public Response introspect(String token) {             if (accessToken != null) {                 tokenMetadata = JsonSerialization.createObjectNode(accessToken);                 tokenMetadata.put(""client_id"", accessToken.getIssuedFor());-                tokenMetadata.put(""username"", accessToken.getPreferredUsername());++                UserModel userModel = session.users().getUserById(realm, accessToken.getSubject());+                if (userModel != null) {+                    tokenMetadata.put(""username"", userModel.getUsername());","IMO this is not the right solution. An introspection should reflect what's in the incoming access token. The ""username"" in the access token could have been set deliberately to a different value than the user's username (e.g. an external unique user name). And exactly that value should be provided in the introspection result.```suggestion                                       if (!tokenMetadata.has(""username"") && tokenMetadata.has(""preferred_username"")) {                      tokenMetadata.put(""username"", tokenMetadata.get(accessToken.getPreferredUsername()));                    }                                      ```With that approach we get the correct value from the access token and as a fallback have compatibility for those who are relying on the current behavior.BTW: ""client_id"" should be treated the same way.",
13566639,ch219318,https://api.github.com/repos/keycloak/keycloak/pulls/8336,680507931,2021-08-01T12:58:42Z,services/src/main/java/org/keycloak/protocol/oidc/AccessTokenIntrospectionProvider.java,"@@ -56,7 +57,11 @@ public Response introspect(String token) {             if (accessToken != null) {                 tokenMetadata = JsonSerialization.createObjectNode(accessToken);                 tokenMetadata.put(""client_id"", accessToken.getIssuedFor());-                tokenMetadata.put(""username"", accessToken.getPreferredUsername());++                UserModel userModel = session.users().getUserById(realm, accessToken.getSubject());+                if (userModel != null) {+                    tokenMetadata.put(""username"", userModel.getUsername());","""tokenMetadata.put(""username"", tokenMetadata.get(accessToken.getPreferredUsername()))"" do you mean ""tokenMetadata.put(""username"", tokenMetadata.get(""preferred_username""))"" or ""tokenMetadata.put(""username"", accessToken.getPreferredUsername())"" ?",
6230308,mduchrow,https://api.github.com/repos/keycloak/keycloak/pulls/8336,680693627,2021-08-02T06:44:21Z,services/src/main/java/org/keycloak/protocol/oidc/AccessTokenIntrospectionProvider.java,"@@ -56,7 +57,11 @@ public Response introspect(String token) {             if (accessToken != null) {                 tokenMetadata = JsonSerialization.createObjectNode(accessToken);                 tokenMetadata.put(""client_id"", accessToken.getIssuedFor());-                tokenMetadata.put(""username"", accessToken.getPreferredUsername());++                UserModel userModel = session.users().getUserById(realm, accessToken.getSubject());+                if (userModel != null) {+                    tokenMetadata.put(""username"", userModel.getUsername());","Well, hopefully both are returning the same value :-)tokenMetadata.get() returns a JsonNode, so I thought taking it from the accessToken.getPreferredUsername() is easier.BTW: If ""preferred_username"" is also not set, your approach to assign it from UserModel.getUsername() might be OK, as a final fallback.",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/8082,682591469,2021-08-04T12:59:40Z,services/src/main/java/org/keycloak/validation/DefaultClientValidationProvider.java,"@@ -180,6 +199,24 @@ private void checkUri(FieldMessages field, String url, ValidationContext<ClientM         }     } +    private void checkUriLogo(FieldMessages field, String url, ValidationContext<ClientModel> context) {+        if (url == null || url.isEmpty()) {+            return;+        }++        try {+            URI uri = new URI(url);++            if (uri.getScheme() != null &&  uri.getScheme().equals(""javascript"")) {","I agree that check must be more strict. However, I am not sure that we should folllow SAML documentation for OIDC clients.I try to use already implemented check for URIs. However, in logo URI ""data"" scheme must be supported. What Keycloak team believe about Logo URI validation? Maybe we should check if scheme is equal to ""data"". This means that URI is accepted. Otherwise uri.toURL() must be executed.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8341,683360433,2021-08-05T11:17:06Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/migration/MigrationTest.java,"@@ -82,6 +83,7 @@ public void migration4_xTest() throws Exception {          // Always test offline-token login during migration test         testOfflineTokenLogin();+        testExtremelyLongClientAttribute(migrationRealm);","The long value of client attribute is only available since Keycloak 3.4.1, after KEYCLOAK-4231 changes. I've thus only put the long value into two newer realm jsons (4.8.3, 9.0.3). `testMigrationTo12_x()` is called from the methods testing migration from 1,*, 2.*, and 3.* as well. Thus I wanted to keep it only for 4.* and 9.* and kept it local here",
11198630,danielFesenmeyer,https://api.github.com/repos/keycloak/keycloak/pulls/8357,685302776,2021-08-09T15:35:39Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java,"@@ -105,7 +105,9 @@ public UserModel addUser(RealmModel realm, String id, String username, boolean a          UserEntity entity = new UserEntity();         entity.setId(id);-        entity.setCreatedTimestamp(System.currentTimeMillis());+        long now = System.currentTimeMillis();+        entity.setCreatedTimestamp(now);+        entity.setLastUpdatedTimestamp(now);","Having lastUpdated already set on creation has the advantage that it is never null (at least for users created after introduction of this feature).Furthermore, it has the advantage that readers of a user representation just have to check one timestamp in order to find out when the data was changed/created. (Otherwise they would have to check both created and lastUpdated, which would be less convenient imho.)",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/8357,685828255,2021-08-10T08:57:08Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java,"@@ -105,7 +105,9 @@ public UserModel addUser(RealmModel realm, String id, String username, boolean a          UserEntity entity = new UserEntity();         entity.setId(id);-        entity.setCreatedTimestamp(System.currentTimeMillis());+        long now = System.currentTimeMillis();+        entity.setCreatedTimestamp(now);+        entity.setLastUpdatedTimestamp(now);","This makes sense to me and I think your implementation is fine.However having a dedicated `null` value would make it easier to check if the user has been updated at all or not, but since this also possible with your change by comparing both timestamps, it should be ok.Out of couriosity:Have you looked at how often this update timestamp is updated during normal API interactions?- Create user?- Update user directly (enable / disable / change profile field)?- Update user attribute?- Change user group / role assignment? Is the `lastUpdatedTimestamp` only updated if there really was a change or is it updated always in the situations above?If it is the latter, then this would change the semantics to ""there may have been changes"" if the `lastUpdatedTimestamp` is newer then the previous one.Perhaps this can surface some potential for additional optimizations (avoid unnecessary updates).",
8414918,iankko,https://api.github.com/repos/keycloak/keycloak/pulls/8364,691062620,2021-08-18T09:24:19Z,quarkus/pom.xml,"@@ -31,21 +31,37 @@     <packaging>pom</packaging>      <properties>-        <quarkus.version>1.13.3.Final</quarkus.version>-        <resteasy.version>4.5.9.Final</resteasy.version>-        <jackson.version>2.12.1</jackson.version>+        <!-- Quarkus version -->+        <quarkus.version>2.1.2.Final</quarkus.version>++        <!--+            Override versions based on Quarkus dependencies.+            Make sure to update these dependencies when Quarkus version changes.+        -->+        <resteasy.version>4.7.0.Final</resteasy.version>+        <jackson.version>2.12.4</jackson.version>         <jackson.databind.version>${jackson.version}</jackson.databind.version>-        <hibernate.version>5.4.29.Final</hibernate.version>-        <mysql.driver.version>8.0.24</mysql.driver.version>-        <postgresql.driver.version>42.2.20</postgresql.driver.version>-        <picocli.version>4.6.1</picocli.version>-        <snakeyaml.version>1.28</snakeyaml.version>-        <surefire-plugin.version>3.0.0-M5</surefire-plugin.version>-        <wildfly.common.format.version>1.5.4.Final-format-001</wildfly.common.format.version>-        <maven.compiler.source>1.8</maven.compiler.source>+        <hibernate.core.version>5.5.6.Final</hibernate.core.version>+        <mysql.driver.version>8.0.25</mysql.driver.version>+        <postgresql.version>42.2.23</postgresql.version>+        <microprofile-metrics-api.version>3.0</microprofile-metrics-api.version>+        <wildfly.common.version>1.5.4.Final-format-001</wildfly.common.version>++        <!--+            Java EE dependencies. Not available from JDK 11+.+            The dependencies and their versions are the same used by Wildfly distribution.+         -->+        <org.jboss.spec.javax.xml.bind.jboss-jaxb-api_2.3_spec.version>2.0.1.Final</org.jboss.spec.javax.xml.bind.jboss-jaxb-api_2.3_spec.version>+        <sun.saaj-impl.version>1.4.1.SP1</sun.saaj-impl.version>+        <org.jvnet.staxex.version>1.8.3</org.jvnet.staxex.version>","@vmuzikar Thx for checking! AFAICT, no. Doing a WF upgrade, the dependencies originating from WF, used by Quarkus aren't updated yet (Quarkus is still left as a separate class citizen). But filed [KEYCLOAK-19065](https://issues.redhat.com/browse/KEYCLOAK-19065) to have this covered (as IMHO it's a great idea btw) in the futureHTHJan",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8160,694631993,2021-08-24T08:30:12Z,testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/realm/LoginSettingsTest.java,"@@ -197,6 +197,34 @@ public void resetPassword() {         assertFalse(testRealmLoginPage.form().isForgotPasswordLinkPresent());         log.info(""verified reset password is disabled"");     }++++    @Test+    public void resetPasswordWithDuplicateEmailsAllowed() throws InterruptedException {++        log.info(""disabling email as username"");+        loginSettingsPage.navigateTo();+        loginSettingsPage.form().setLoginWithEmailAllowed(false);+        assertFalse(loginSettingsPage.form().isLoginWithEmailAllowed());","Just one nitpick. Could you please use `org.hamcrest.MatcherAssert.assertThat` instead of `Assert.*`? I know these `Assert.*` assertions are present in the whole test class, but when a new test case is created, we want to use the `assertThat` as much as possible because it brings a lot of advantages.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8351,695543273,2021-08-25T08:50:07Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/RequiredActionPriorityTest.java,"@@ -35,12 +36,16 @@ import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer; import org.keycloak.testsuite.pages.AppPage; import org.keycloak.testsuite.pages.AppPage.RequestType;+import org.keycloak.testsuite.pages.LoginConfigTotpPage; import org.keycloak.testsuite.pages.LoginPage; import org.keycloak.testsuite.pages.LoginPasswordUpdatePage; import org.keycloak.testsuite.pages.LoginUpdateProfileEditUsernameAllowedPage; import org.keycloak.testsuite.pages.TermsAndConditionsPage; import org.keycloak.testsuite.util.UserBuilder; +import static org.junit.Assert.assertFalse;+import static org.junit.Assert.assertTrue;","Could you please use `org.hamcrest.MatcherAssert.assertThat` instead of `Assert.*`? I know these `Assert.*` assertions are present in the whole test class, but when a new test case is created, we want to use the `assertThat` as much as possible because it brings a lot of advantages.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/7933,696610186,2021-08-26T13:06:31Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -461,6 +461,11 @@ public LinkedAccountsResource linkedAccounts() {         return new LinkedAccountsResource(session, request, client, auth, event, user);     } +    @Path(""/groups"")+    public GroupMembershipResource groupResource() {",Why not calling this method `groups` similar to `applications`?,
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/7933,697217790,2021-08-27T07:31:14Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -461,6 +461,11 @@ public LinkedAccountsResource linkedAccounts() {         return new LinkedAccountsResource(session, request, client, auth, event, user);     } +    @Path(""/groups"")+    public GroupMembershipResource groupResource() {","Ok, no problem. I will make similar implementation with applications.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8360,699293685,2021-08-31T12:54:11Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -302,6 +302,24 @@ public RoleModel getClientRole(ClientModel client, String name) {         return getRolesStream(query, realm, first, max);     } +    @Override+    public Stream<RoleModel> getRolesStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {+        TypedQuery<String> query;++        if (search == null) {+            query = em.createNamedQuery(""getRoleIdsFromIdList"", String.class);+        } else {+            query = em.createNamedQuery(""getRoleIdsByNameContainingFromIdList"", String.class)+                    .setParameter(""search"", search);+        }++        query.setParameter(""realm"", realm.getId())+                .setParameter(""ids"", ids.collect(Collectors.toList()));","What way of fixing this would you prefer? I can think of 3 ways:1. Addition of `Cannot be {@code null}` to each parameter that cannot be `null`, which is true basically for each parameter except for `pagination` and `search`.2. Addition of `@throws NullPointerException When any of required parameters is {@code null}. Parameters are required unless specified differently in the corresponding comment.` to each method. Maybe we can even name all parameters that cannot be `null` instead of the general comment.3. Addition of some class level comment (similar to one in point 2^). I would probably vote for addition of number 2 to `getRolesStream` method in this PR and then include all other methods in some separate PR from cleanup epic. WDYT?  ",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8385,700121507,2021-09-01T11:24:52Z,services/src/main/java/org/keycloak/authentication/AuthenticationSelectionResolver.java,"@@ -60,34 +64,58 @@      * @return an ordered list of the authentication selection options to present the user.      */     static List<AuthenticationSelectionOption> createAuthenticationSelectionList(AuthenticationProcessor processor, AuthenticationExecutionModel model) {-        List<AuthenticationSelectionOption> authenticationSelectionList = new ArrayList<>(); -        if (processor.getAuthenticationSession() != null) {-            Map<String, AuthenticationExecutionModel> typeAuthExecMap = new HashMap<>();-            List<AuthenticationExecutionModel> nonCredentialExecutions = new ArrayList<>();+        AuthenticationSessionModel authSession = processor.getAuthenticationSession();+        if (authSession == null) {+            // we have no authSession so we cannot create an authenticator list.+            return Collections.emptyList();+        } -            String topFlowId = getFlowIdOfTheHighestUsefulFlow(processor, model);+        Map<String, AuthenticationExecutionModel> typeAuthExecMap = new HashMap<>();+        List<AuthenticationExecutionModel> nonCredentialExecutions = new ArrayList<>(); -            if (topFlowId == null) {-                addSimpleAuthenticationExecution(processor, model, typeAuthExecMap, nonCredentialExecutions);-            } else {-                addAllExecutionsFromSubflow(processor, topFlowId, typeAuthExecMap, nonCredentialExecutions);-            }+        String topFlowId = getFlowIdOfTheHighestUsefulFlow(processor, model);++        if (topFlowId == null) {+            addSimpleAuthenticationExecution(processor, model, typeAuthExecMap, nonCredentialExecutions);+        } else {+            addAllExecutionsFromSubflow(processor, topFlowId, typeAuthExecMap, nonCredentialExecutions);+        }++        List<AuthenticationSelectionOption> authenticationSelectionList = new ArrayList<>();+        KeycloakSession session = processor.getSession();+        UserModel authenticatedUser = authSession.getAuthenticatedUser();+        // add authenticator options for the given user if present+        if (authenticatedUser != null) {++            RealmModel realm = processor.getRealm();              //add credential authenticators in order-            if (processor.getAuthenticationSession().getAuthenticatedUser() != null) {-                authenticationSelectionList = processor.getSession().userCredentialManager()-                        .getStoredCredentialsStream(processor.getRealm(), processor.getAuthenticationSession().getAuthenticatedUser())-                        .filter(credential -> typeAuthExecMap.containsKey(credential.getType()))-                        .map(CredentialModel::getType)-                        .distinct()-                        .map(credentialType -> new AuthenticationSelectionOption(processor.getSession(), typeAuthExecMap.get(credentialType)))-                        .collect(Collectors.toList());+            authenticationSelectionList.addAll(session.userCredentialManager()+                    .getStoredCredentialsStream(realm, authenticatedUser)+                    .filter(credential -> typeAuthExecMap.containsKey(credential.getType()))+                    .map(CredentialModel::getType)+                    .distinct()+                    .map(credentialType -> new AuthenticationSelectionOption(session, typeAuthExecMap.get(credentialType)))+                    .collect(Collectors.toList()));++            //add authenticators that require a current user which are also configured for that user+            for (AuthenticationExecutionModel exec : nonCredentialExecutions) {","If authenticated user is not null, this list of executions is fully iterated twice. In this case, what about to reduce these executions or completely avoid the second iteration over whole list? The condition for the `requiresUser` is evaluated twice. I know the list would change and potentially break the process of executing actions for the `nonCredentialExecutions` list in the future, but at this moment, there's no other action for the list. Is there any deeper intention why to use this approach? ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8360,700850341,2021-09-02T08:07:42Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -302,6 +302,24 @@ public RoleModel getClientRole(ClientModel client, String name) {         return getRolesStream(query, realm, first, max);     } +    @Override+    public Stream<RoleModel> getRolesStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {+        TypedQuery<String> query;++        if (search == null) {+            query = em.createNamedQuery(""getRoleIdsFromIdList"", String.class);+        } else {+            query = em.createNamedQuery(""getRoleIdsByNameContainingFromIdList"", String.class)+                    .setParameter(""search"", search);+        }++        query.setParameter(""realm"", realm.getId())+                .setParameter(""ids"", ids.collect(Collectors.toList()));","I'd prefer with 1 (or 1+2) as it clearly specifies for each parameter that these are required. Throwing NPE for parameters which _cannot be {@code null}_ could be expected, but perhaps a better behaviour would be to just return empty stream if any of the parameters is {@null}?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8360,700919510,2021-09-02T09:37:07Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -302,6 +302,24 @@ public RoleModel getClientRole(ClientModel client, String name) {         return getRolesStream(query, realm, first, max);     } +    @Override+    public Stream<RoleModel> getRolesStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {+        TypedQuery<String> query;++        if (search == null) {+            query = em.createNamedQuery(""getRoleIdsFromIdList"", String.class);+        } else {+            query = em.createNamedQuery(""getRoleIdsByNameContainingFromIdList"", String.class)+                    .setParameter(""search"", search);+        }++        query.setParameter(""realm"", realm.getId())+                .setParameter(""ids"", ids.collect(Collectors.toList()));","I don't like the idea of returning an empty stream if some required parameter is `null`. I would rather follow the fail-fast principle. If someone accidentally sets the realm to `null`, while they think they used a realm `realmA` they could think this realm contains no role/clients/groups etc. This might be worked around using some WARN log messages in providers. But still, the other not-so-nice thing is that we would need to add a lot of `if` statements into providers, which could make the code messy. WDYT?I agree with 1+(2-general comment version). But the question is, how we will approach this change? Should we create a new Jira or do we want to have it in this PR? ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8389,703025277,2021-09-06T17:42:35Z,services/src/main/java/org/keycloak/userprofile/UserProfileUtils.java,"@@ -0,0 +1,67 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.userprofile;++import java.util.List;++import org.keycloak.events.Details;+import org.keycloak.events.Event;+import org.keycloak.events.EventBuilder;+import org.keycloak.models.UserModel;++/**+ * + * @author Vlastimil Elias <velias@redhat.com>+ *+ */+public class UserProfileUtils {","Wouldn't make more sense to create a specific listener implementation that can be re-used as this method?Ideally, we should be handling this event within the SPI, but for now I think the approach is OK.",
473926,velias,https://api.github.com/repos/keycloak/keycloak/pulls/8389,703410825,2021-09-07T11:05:27Z,services/src/main/java/org/keycloak/userprofile/UserProfileUtils.java,"@@ -0,0 +1,67 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.userprofile;++import java.util.List;++import org.keycloak.events.Details;+import org.keycloak.events.Event;+import org.keycloak.events.EventBuilder;+import org.keycloak.models.UserModel;++/**+ * + * @author Vlastimil Elias <velias@redhat.com>+ *+ */+public class UserProfileUtils {","Right, specific listener implementation should be better, going to implement it this way",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8415,706166693,2021-09-10T13:08:20Z,model/jpa/src/main/java/org/keycloak/connections/jpa/DefaultJpaConnectionProviderFactory.java,"@@ -91,8 +98,24 @@ public JpaConnectionProvider create(KeycloakSession session) {             em = emf.createEntityManager(SynchronizationType.SYNCHRONIZED);         }         em = PersistenceExceptionConverter.create(session, em);-        if (!jtaEnabled) session.getTransactionManager().enlist(new JpaKeycloakTransaction(em));-        return new DefaultJpaConnectionProvider(em);+        if (!jtaEnabled) {+            session.getTransactionManager().enlist(new JpaKeycloakTransaction(em));+        }+        return em;+    }++    private void addSpecificNamedQueries(KeycloakSession session, Connection connection) {","@hmlnarik @rmartinc We should avoid whenever possible performing blocking/costly operations during startup. Created https://issues.redhat.com/browse/KEYCLOAK-19274.Also, would be possible to just use the connection metadata to obtain the database type rather than querying the liquibase provider? Asking because Liquibase operations are usually costly.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8267,707157645,2021-09-13T09:23:48Z,model/infinispan/src/main/java/org/keycloak/connections/infinispan/DefaultInfinispanConnectionProviderFactory.java,"@@ -205,7 +196,8 @@ protected void initEmbedded() {          if (clustered) {             String jgroupsUdpMcastAddr = config.get(""jgroupsUdpMcastAddr"", System.getProperty(InfinispanConnectionProvider.JGROUPS_UDP_MCAST_ADDR));-            configureTransport(gcb, topologyInfo.getMyNodeName(), topologyInfo.getMySiteName(), jgroupsUdpMcastAddr);+            configureTransport(gcb, topologyInfo.getMyNodeName(), topologyInfo.getMySiteName(), jgroupsUdpMcastAddr,+                    ""default-configs/default-keycloak-jgroups-udp.xml"", this.getClass().getClassLoader());",Is the `ClassLoader` parameter necessary?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8267,707192740,2021-09-13T10:09:22Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionAdapter.java,"@@ -111,22 +111,22 @@ public boolean isOffline() {         Map<String, AuthenticatedClientSessionModel> result = new HashMap<>();         List<String> removedClientUUIDS = new LinkedList<>(); -        entity.getAuthenticatedClientSessions().entrySet()-                .stream()-                .forEach(entry -> {-                    String clientUUID = entry.getKey();-                    ClientModel client = realm.getClientById(clientUUID);--                    if (client != null) {-                        AuthenticatedClientSessionModel clientSession = session.sessions()-                                .getClientSession(this, client, entry.getValue(), isOffline());-                        if (clientSession != null) {-                            result.put(clientUUID, clientSession);-                        }-                    } else {-                        removedClientUUIDS.add(clientUUID);-                    }-                });+        // to avoid concurrentModificationException",This is weird. Do we know why there is the `CME` exception? There is not any place in the lambda that would update the original map.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8267,707383823,2021-09-13T14:22:01Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/util/InfinispanUtil.java,"@@ -92,4 +113,142 @@ public static long toHotrodTimeMs(BasicCache ispnCache, long lifespanOrigMs) {         return lifespanOrigMs;     } +    private static final Object CHANNEL_INIT_SYNCHRONIZER = new Object();",@martin-kanis Are there any significant changes to the methods below or is it just moving them to the util class? I found only the change in `configureTransport` method parameters.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8267,707445564,2021-09-13T15:27:06Z,services/src/main/java/org/keycloak/executors/DefaultExecutorsProviderFactory.java,"@@ -189,7 +189,7 @@ protected ExecutorService createPoolEmbedded(String taskType, KeycloakSession se             // Same like Executors.newCachedThreadPool. Besides that ""min"" and ""max"" are configurable             return new ThreadPoolExecutor(min, max,                     60L, TimeUnit.SECONDS,-                    new SynchronousQueue<Runnable>(),+                    new ArrayBlockingQueue<>(1024),","Why is this change necessary?If I understand correctly, this means, that when 1024 tasks are waiting for execution a `RejectedExecutionException` exception is thrown. Should we catch this exception for example here: https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/saml/SamlService.java#L387?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8267,707463324,2021-09-13T15:47:01Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/UserSessionInitializerTest.java,"@@ -143,18 +147,67 @@ public void testUserSessionInitializerWithDeletingClient() {                     .collect(Collectors.toList());              assertThat(""Size of loaded Sessions"", loadedSessions.size(), is(1));-            assertSessionLoaded(loadedSessions, origSessionIds[0], session.users().getUserByUsername(realm, ""user1""), ""127.0.0.1"", started, started, ""third-party"");+            assertSessionLoaded(loadedSessions, origSessionIds.get(0), session.users().getUserByUsername(realm, ""user1""), ""127.0.0.1"", started, started, ""third-party"");              // Revert client             realm.addClient(""test-app"");         });      } -    // Create sessions in persister + infinispan, but then delete them from infinispan cache. This is to allow later testing of initializer. Return the list of ""origSessions""-    private String[] createSessionsInPersisterOnly() {+    @Test+    public void testUserSessionPropagationBetweenSites() throws InterruptedException {+        AtomicInteger index = new AtomicInteger();+        AtomicReference<String> siteName = new AtomicReference<>();+        AtomicReference<String> userSessionId = new AtomicReference<>();+        AtomicReference<List<Boolean>> containsSession = new AtomicReference<>(new LinkedList<>());++        Object lock = new Object();++        inIndependentFactories(4, 300, () -> {+            synchronized (lock) {+                if (index.incrementAndGet() == 1) {+                    siteName.set(CONFIG.scope(""connectionsInfinispan"", ""default"").get(""siteName"", ""site-1""));++                    // create a user session in the first node+                    UserSessionModel userSessionModel = withRealm(realmId, (session, realm) -> {+                        final UserModel user = session.users().getUserByUsername(realm, ""user1"");+                        return session.sessions().createUserSession(realm, user, ""un1"", ""ip1"", ""auth"", false, null, null);+                    });+                    userSessionId.set(userSessionModel.getId());+                } else {+                    if (siteName.get().equals(CONFIG.scope(""connectionsInfinispan"", ""default"").get(""siteName"", ""site-1""))) {+                        // try to get the user session at other nodes on the same site+                        inComittedTransaction(session -> {+                            InfinispanConnectionProvider provider = session.getProvider(InfinispanConnectionProvider.class);+                            Cache<String, Object> localSessions = provider.getCache(USER_SESSION_CACHE_NAME);+                            RemoteCache<String, Object> remoteSessions = provider.getRemoteCache(USER_SESSION_CACHE_NAME);++                            containsSession.get().add(localSessions.containsKey(userSessionId.get()));+                            containsSession.get().add(remoteSessions.containsKey(userSessionId.get()));+                        });+                    } else {+                        // try to get the user session at other nodes on the different site+                        inComittedTransaction(session -> {+                            InfinispanConnectionProvider provider = session.getProvider(InfinispanConnectionProvider.class);+                            Cache<String, Object> localSessions = provider.getCache(USER_SESSION_CACHE_NAME);+                            RemoteCache<String, Object> remoteSessions = provider.getRemoteCache(USER_SESSION_CACHE_NAME);++                            containsSession.get().add(localSessions.containsKey(userSessionId.get()));+                            containsSession.get().add(remoteSessions.containsKey(userSessionId.get()));+                        });+                    }+                }+            }+        });++        assertThat(containsSession.get(), everyItem(is(true)));",Should we check for `containsSession` size? Or we are sure it passed in each independent factory if all values are `true`?,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8428,708117546,2021-09-14T10:06:19Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/broker/SocialLoginTest.java,"@@ -255,6 +257,16 @@ public void openshift4Login() {         testTokenExchange();     } +    @Test+    public void openshift4KubeAdminLogin() {+        setTestProvider(OPENSHIFT4_ADMIN_LOGIN);+        ((OpenShiftLoginPage) this.currentSocialLoginPage).setUserLoginLinkTitle(getConfig(currentTestProvider, ""loginBtnTitle""));","@vmuzikar True, that'd be a better place for this. Another point: This value needs only to be set when the OCP login page has some boxes to click, leading to the actual login form, which is not the case for every OCP environment, is it? So the `if` should only be used in the case of this provider, not for e.g. `OPENSHIFT4`. Right? Apart from that: I think renaming the Provider enum to OPENSHIFT4_BOXED_LOGIN (other naming suggestions are appreciated) makes more sense, too, because it's possible to not only get to the login for the admin user, but depending on `loginBtnTitle` for other users, too. What do you think?",
1221984,999eagle,https://api.github.com/repos/keycloak/keycloak/pulls/8257,708867449,2021-09-15T06:10:15Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPUserMultipleCredentialTest.java,"@@ -0,0 +1,173 @@+package org.keycloak.testsuite.federation.ldap;+++import org.jboss.arquillian.graphene.page.Page;+import org.junit.*;",Replaced imports with absolute class imports,
1221984,999eagle,https://api.github.com/repos/keycloak/keycloak/pulls/8257,708867474,2021-09-15T06:10:18Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPUserMultipleCredentialTest.java,"@@ -0,0 +1,173 @@+package org.keycloak.testsuite.federation.ldap;+++import org.jboss.arquillian.graphene.page.Page;+import org.junit.*;+import org.junit.runners.MethodSorters;+import org.keycloak.admin.client.resource.RealmResource;+import org.keycloak.authentication.authenticators.browser.OTPFormAuthenticatorFactory;+import org.keycloak.authentication.authenticators.browser.PasswordFormFactory;+import org.keycloak.authentication.authenticators.browser.UsernameFormFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.ModelException;+import org.keycloak.models.RealmModel;+import org.keycloak.models.UserModel;+import org.keycloak.models.credential.OTPCredentialModel;+import org.keycloak.models.utils.DefaultAuthenticationFlows;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.storage.ldap.idm.model.LDAPObject;+import org.keycloak.testsuite.arquillian.annotation.EnableVault;+import org.keycloak.testsuite.client.KeycloakTestingClient;+import org.keycloak.testsuite.pages.LoginTotpPage;+import org.keycloak.testsuite.pages.LoginUsernameOnlyPage;+import org.keycloak.testsuite.pages.PasswordPage;+import org.keycloak.testsuite.pages.SelectAuthenticatorPage;+import org.keycloak.testsuite.runonserver.RunOnServerException;+import org.keycloak.testsuite.util.*;",Replaced imports with absolute class imports,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/8267,708882023,2021-09-15T06:39:28Z,model/infinispan/src/main/java/org/keycloak/connections/infinispan/DefaultInfinispanConnectionProviderFactory.java,"@@ -205,7 +196,8 @@ protected void initEmbedded() {          if (clustered) {             String jgroupsUdpMcastAddr = config.get(""jgroupsUdpMcastAddr"", System.getProperty(InfinispanConnectionProvider.JGROUPS_UDP_MCAST_ADDR));-            configureTransport(gcb, topologyInfo.getMyNodeName(), topologyInfo.getMySiteName(), jgroupsUdpMcastAddr);+            configureTransport(gcb, topologyInfo.getMyNodeName(), topologyInfo.getMySiteName(), jgroupsUdpMcastAddr,+                    ""default-configs/default-keycloak-jgroups-udp.xml"", this.getClass().getClassLoader());",Good point. No removed it and used the classloader in `InfinispanUtil`.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8430,708990117,2021-09-15T09:04:35Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -412,6 +412,20 @@ public GroupModel getGroupById(RealmModel realm, String id) {         return adapter;     } +    @Override+    public GroupModel getGroupByName(RealmModel realm, String name, GroupModel parent) {+        TypedQuery<String> query = em.createNamedQuery(""getGroupIdByName"", String.class);+        query.setParameter(""name"", name);+        query.setParameter(""realm"", realm.getId());+        query.setParameter(""parent"", parent != null ? parent.getId() : GroupEntity.TOP_PARENT_ID);+        List<String> entities = query.getResultList();+        if (entities.isEmpty()) return null;+        if (entities.size() > 1) throw new IllegalStateException(""Should not be more than one Group with same name"");+        String id = query.getResultList().get(0);","I hope we can obtain GroupEntity here instead of ID, which will allow to skip the additiona call to `session.groups.getGroupById` below. See my other review comment for the GroupEntity class.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8430,709111611,2021-09-15T11:56:44Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -267,12 +267,20 @@ private void addedRole(String roleId, String roleContainerId) {      @Override     public void registerGroupInvalidation(String id) {+        // TODO GroupByNameCacheKey","I think it is needed to address this TODO and some caching limitations of this PR. Especially I think that:GroupAddedEvent, GroupMovedEvent, GroupRemovedEvent and maybe others, need to contain the ""name"" as one of the properties of the event. This is needed, so the other cluster node will be able to invalidate corresponding ""groupByNameCacheKey"" as well. This is done in the `addInvalidations` method of the particular event (This method is triggered on cluster node2 after some group CRUD operation was triggered in the cluster node1).See for example `ClientUpdatedEvent` for the inspiration and how it invalidates ""clientId"" (""clientId"" on the client is quite similar to the ""name"" on the group).",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8430,709126834,2021-09-15T12:17:56Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/membership/group/GroupLDAPStorageMapper.java,"@@ -361,22 +363,42 @@ private void updateAttributesOfKCGroup(GroupModel kcGroup, LDAPObject ldapGroup)     }  -    protected GroupModel findKcGroupByLDAPGroup(RealmModel realm, LDAPObject ldapGroup) {+    protected GroupModel findKcGroupByLDAPGroup(RealmModel realm, GroupModel parent, LDAPObject ldapGroup) {         String groupNameAttr = config.getGroupNameLdapAttribute();         String groupName = ldapGroup.getAttributeAsString(groupNameAttr);          if (config.isPreserveGroupsInheritance()) {             // Override if better effectivity or different algorithm is needed-            return getAllKcGroups(realm)+            return getAllKcGroups(realm, parent)                     .filter(group -> Objects.equals(group.getName(), groupName)).findFirst().orElse(null);         } else {             // Without preserved inheritance, it's always at groups path-            return KeycloakModelUtils.findGroupByPath(realm, getKcGroupPathFromLDAPGroupName(groupName));+            return realm.getGroupByName(groupName, parent);+        }+    }+    // TODO how this will work with group names with a / without hitting the db everytime+    private GroupModel findGroupByPath(RealmModel realm, String path) {+        if (path == null) {+            return null;+        }+        if (path.startsWith(""/"")) {+            path = path.substring(1);+        }+        if (path.endsWith(""/"")) {+            path = path.substring(0, path.length() - 1);+        }+        String[] split = path.split(""/"");","Minor: It will be good if calls, which are called often and affect the performance use the regex pattern instead of directly calling `String.split` . I am pretty sure you remember your recent PR for the LdapDn performance improvement, which was related exactly to this :-)",
18034775,bohmber,https://api.github.com/repos/keycloak/keycloak/pulls/8430,709190012,2021-09-15T13:31:44Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/membership/group/GroupLDAPStorageMapper.java,"@@ -361,22 +363,42 @@ private void updateAttributesOfKCGroup(GroupModel kcGroup, LDAPObject ldapGroup)     }  -    protected GroupModel findKcGroupByLDAPGroup(RealmModel realm, LDAPObject ldapGroup) {+    protected GroupModel findKcGroupByLDAPGroup(RealmModel realm, GroupModel parent, LDAPObject ldapGroup) {         String groupNameAttr = config.getGroupNameLdapAttribute();         String groupName = ldapGroup.getAttributeAsString(groupNameAttr);          if (config.isPreserveGroupsInheritance()) {             // Override if better effectivity or different algorithm is needed-            return getAllKcGroups(realm)+            return getAllKcGroups(realm, parent)                     .filter(group -> Objects.equals(group.getName(), groupName)).findFirst().orElse(null);         } else {             // Without preserved inheritance, it's always at groups path-            return KeycloakModelUtils.findGroupByPath(realm, getKcGroupPathFromLDAPGroupName(groupName));+            return realm.getGroupByName(groupName, parent);+        }+    }+    // TODO how this will work with group names with a / without hitting the db everytime+    private GroupModel findGroupByPath(RealmModel realm, String path) {+        if (path == null) {+            return null;+        }+        if (path.startsWith(""/"")) {+            path = path.substring(1);+        }+        if (path.endsWith(""/"")) {+            path = path.substring(0, path.length() - 1);+        }+        String[] split = path.split(""/"");",If the pattern is short there is a fast path in `String.split` without a Pattern. I need to check if a static Pattern will improve performance in this case.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/8267,709270460,2021-09-15T14:53:45Z,services/src/main/java/org/keycloak/executors/DefaultExecutorsProviderFactory.java,"@@ -189,7 +189,7 @@ protected ExecutorService createPoolEmbedded(String taskType, KeycloakSession se             // Same like Executors.newCachedThreadPool. Besides that ""min"" and ""max"" are configurable             return new ThreadPoolExecutor(min, max,                     60L, TimeUnit.SECONDS,-                    new SynchronousQueue<Runnable>(),+                    new ArrayBlockingQueue<>(1024),","I can't remember the exact error message but it was related to `InfinispanNotificationsManager` and some cluster listener. Maybe @hmlnarik can remember more?Anyway, I reverted the change and I don't see the error again. Maybe it was present only in earlier phases of this PR. ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/7656,709528749,2021-09-15T19:56:15Z,services/src/main/java/org/keycloak/authentication/authenticators/x509/AbstractX509ClientCertificateAuthenticatorFactory.java,"@@ -201,6 +206,22 @@         extendedKeyUsage.setLabel(""Validate Extended Key Usage"");         extendedKeyUsage.setHelpText(""Validates the extended purposes of the certificate's key using certificate's Extended Key Usage extension. Leaving the field blank will disable Extended Key Usage validation. See RFC 5280 for a detailed definition of X509 Extended Key Usage extension.""); +        ProviderConfigProperty certificatePolicy = new ProviderConfigProperty();+        certificatePolicy.setType(STRING_TYPE);+        certificatePolicy.setName(CERTIFICATE_POLICY);+        certificatePolicy.setLabel(""Validate Certificate Policy"");+        certificatePolicy.setHelpText(""Validates the certificate policies of the certificate's key using certificate's Policy extension. Leaving the field blank will disable Certificate Policies validation. See RFC 5280 for a detailed definition of X509 Certificate Policy extension."");",Perhaps we should mention here the possibility to provide a comma-separated list of OIDs?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8267,712054539,2021-09-20T10:42:23Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionAdapter.java,"@@ -111,22 +111,22 @@ public boolean isOffline() {         Map<String, AuthenticatedClientSessionModel> result = new HashMap<>();         List<String> removedClientUUIDS = new LinkedList<>(); -        entity.getAuthenticatedClientSessions().entrySet()-                .stream()-                .forEach(entry -> {-                    String clientUUID = entry.getKey();-                    ClientModel client = realm.getClientById(clientUUID);--                    if (client != null) {-                        AuthenticatedClientSessionModel clientSession = session.sessions()-                                .getClientSession(this, client, entry.getValue(), isOffline());-                        if (clientSession != null) {-                            result.put(clientUUID, clientSession);-                        }-                    } else {-                        removedClientUUIDS.add(clientUUID);-                    }-                });+        // to avoid concurrentModificationException","I found out the reason of the `CME`. The problem is, that `session.sessions().getClientSession()` [udpates](https://github.com/keycloak/keycloak/blob/master/model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java#L116) `entity.getAuthenticatedClientSessions()` map when the clientSession expires. We need to do the `getClientSession` call outside of looping through `authenticatedClientSessions`. I cannot come up with any nice solution, so the copy of `authenticatedClientSessions` is probably the best. But if you can find anything better it would be great.",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/8436,712825730,2021-09-21T08:39:17Z,model/jpa/src/main/java/org/keycloak/connections/jpa/util/JpaUtils.java,"@@ -174,42 +174,57 @@ private static String getQueryShortName(String name) {      * that database type.      * @param em The entity manager to use      * @param databaseType The database type as managed in-     *                     <a href=""https://www.liquibase.org/get-started/databases"">liquibase</a>.+     * @return      */-    public static void addSpecificNamedQueries(EntityManager em, String databaseType) {-        final SessionFactoryImplementor sfi = em.getEntityManagerFactory().unwrap(SessionFactoryImplementor.class);+    public static Properties loadSpecificNamedQueries(String databaseType) {         URL specificUrl = JpaUtils.class.getClassLoader().getResource(""META-INF/queries-"" + databaseType + "".properties"");         URL defaultUrl = JpaUtils.class.getClassLoader().getResource(""META-INF/queries-default.properties"");+         if (defaultUrl == null) {             throw new IllegalStateException(""META-INF/queries-default.properties was not found in the classpath"");         }+         Properties specificQueries = loadSqlProperties(specificUrl);         Properties defaultQueries = loadSqlProperties(defaultUrl);          for (String queryNameFull : defaultQueries.stringPropertyNames()) {-            String querySql;+            String querySql = defaultQueries.getProperty(queryNameFull);             String queryName = getQueryShortName(queryNameFull);             String specificQueryNameFull = getQueryFromProperties(queryName, specificQueries);+             if (specificQueryNameFull != null) {                 // the query is redefined in the specific database file => use it                 queryNameFull = specificQueryNameFull;                 querySql = specificQueries.getProperty(queryNameFull);-            } else {-                // use the default query sql-                querySql = defaultQueries.getProperty(queryNameFull);-            }-            boolean isNative = queryNameFull.endsWith(QUERY_NATIVE_SUFFIX);--            logger.tracef(""adding query from properties files native=%b %s:%s"", isNative, queryName, querySql);-            if (isNative) {-                NativeSQLQuerySpecification spec = new NativeSQLQuerySpecification(querySql, new NativeSQLQueryReturn[0], Collections.emptySet());-                sfi.getQueryPlanCache().getNativeSQLQueryPlan(spec);-                em.getEntityManagerFactory().addNamedQuery(queryName, em.createNativeQuery(querySql));-            } else {-                sfi.getQueryPlanCache().getHQLQueryPlan(querySql, false, Collections.emptyMap());-                em.getEntityManagerFactory().addNamedQuery(queryName, em.createQuery(querySql));+                defaultQueries.put(queryNameFull, querySql);","Take care here, if there is a jpql query in the default file and a native one in the specific file, both queries and names are added and it won't work. I would return a different properties with the final queries:```java         Properties specificQueries = loadSqlProperties(specificUrl);         Properties defaultQueries = loadSqlProperties(defaultUrl);+        Properties returnQueries = new Properties();          for (String queryNameFull : defaultQueries.stringPropertyNames()) {             String querySql = defaultQueries.getProperty(queryNameFull);@@ -196,11 +197,13 @@ public class JpaUtils {                 // the query is redefined in the specific database file => use it                 queryNameFull = specificQueryNameFull;                 querySql = specificQueries.getProperty(queryNameFull);-                defaultQueries.put(queryNameFull, querySql);             }+            returnQueries.put(queryNameFull, querySql);         } -        return defaultQueries;+        return returnQueries;```",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/8436,712845441,2021-09-21T09:04:35Z,model/jpa/src/main/java/org/keycloak/connections/jpa/DefaultJpaConnectionProviderFactory.java,"@@ -105,13 +105,16 @@ private EntityManager createEntityManager(KeycloakSession session) {     }      private void addSpecificNamedQueries(KeycloakSession session, Connection connection) {-        LiquibaseConnectionProvider liquibaseProvider = session.getProvider(LiquibaseConnectionProvider.class);         EntityManager em = null;         try {-            Liquibase liquibase = liquibaseProvider.getLiquibase(connection, this.getSchema());             em = createEntityManager(session);-            JpaUtils.addSpecificNamedQueries(em, liquibase.getDatabase().getShortName());-        } catch (LiquibaseException e) {+            String dbKind = connection.getMetaData().getDatabaseProductName();+            for (Map.Entry<Object, Object> query : loadSpecificNamedQueries(dbKind.toLowerCase()).entrySet()) {","I think that the `getDatabaseProductName` returns long names for mssql. Checking the liquibase code:* H2Database: H2* MySQLDatabase: MySQL* MariaDBDatabase: MariaDB* PostgresDatabase: PostgreSQL* MSSQLDatabase: Microsoft SQL Server or SQLOLEDB* OracleDatabase: Oracle* PostgresPlusDatabase: EnterpriseDBSo I think we can better add a little method in the JpaUtils that performs the transformation. It would only affect MSSQL and enterprise postgresql:```java    public static String getDatabaseType(String productName) {        switch (productName) {            case ""Microsoft SQL Server"":            case ""SQLOLEDB"":                return ""mssql"";            case ""EnterpriseDB"":                return ""postgresql"";            default:                return productName.toLowerCase();        }    }```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8436,713022993,2021-09-21T13:09:14Z,quarkus/runtime/src/main/java/org/keycloak/connections/jpa/QuarkusJpaConnectionProviderFactory.java,"@@ -116,14 +119,28 @@ public void init(Config.Scope config) {     }      private void addSpecificNamedQueries(KeycloakSession session, Connection connection) {-        LiquibaseConnectionProvider liquibaseProvider = session.getProvider(LiquibaseConnectionProvider.class);-        EntityManager em = null;+        SessionFactoryImplementor sfi = emf.unwrap(SessionFactoryImplementor.class);+        EntityManager em = createEntityManager(session);+         try {-            Liquibase liquibase = liquibaseProvider.getLiquibase(connection, this.getSchema());-            em = createEntityManager(session);-            JpaUtils.addSpecificNamedQueries(em, liquibase.getDatabase().getShortName());-        } catch (LiquibaseException e) {-            throw new IllegalStateException(e);+            Map<String, Object> unitProperties = emf.getProperties();++            unitProperties.entrySet().stream()+                    .filter(entry -> entry.getKey().startsWith(QUERY_PROPERTY_PREFIX))+                    .forEach(entry -> {+                        String queryName = entry.getKey().substring(QUERY_PROPERTY_PREFIX.length());+                        String querySql = (String) entry.getValue();++                        if (queryName.endsWith(JpaUtils.QUERY_NATIVE_SUFFIX)) {+                            queryName = queryName.substring(0, queryName.indexOf(JpaUtils.QUERY_NATIVE_SUFFIX));+                            NativeSQLQuerySpecification spec = new NativeSQLQuerySpecification(querySql, new NativeSQLQueryReturn[0], Collections.emptySet());+                            sfi.getQueryPlanCache().getNativeSQLQueryPlan(spec);+                            em.getEntityManagerFactory().addNamedQuery(queryName, em.createNativeQuery(querySql));+                        } else {+                            sfi.getQueryPlanCache().getHQLQueryPlan(querySql, false, Collections.emptyMap());+                            em.getEntityManagerFactory().addNamedQuery(queryName, em.createQuery(querySql));+                        }",Ohh right. I was thinking about something else. Changed to use the utility class.,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/8452,713793056,2021-09-22T10:08:53Z,.github/workflows/ci.yml,"@@ -3,6 +3,7 @@ name: Keycloak CI on: [push, pull_request]  env:+  DEFAULT_JDK_DISTRIBUTION: temurin",For more information about this option see [the documentation](https://github.com/actions/setup-java/blob/main/docs/advanced-usage.md#Selecting-a-Java-distribution).,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8267,715523660,2021-09-24T11:10:07Z,testsuite/model/src/main/java/org/keycloak/testsuite/model/KeycloakModelParameters.java,"@@ -67,4 +67,11 @@ public Statement instanceRule(Statement base, Description description) {         return base;     } +    public void suiteRule(Config cf) {++    }++    public void afterClass() {++    }","Are these necessary and / or properly named?- `suiteRule` seems no to define any result applicable as a JUnit `Rule`, perhaps `beforeSuite` would be more fit.- `afterClass` - should this be rather removed in favor of `classRule()`?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8267,715532819,2021-09-24T11:27:22Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/util/InfinispanUtil.java,"@@ -37,6 +56,8 @@  */ public class InfinispanUtil {","Now that this this class is not only for sessions, it should be moved to org/keycloak/connections/infinispan package",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8267,715708064,2021-09-24T15:26:35Z,testsuite/model/src/main/java/org/keycloak/testsuite/model/HotRodServerRule.java,"@@ -0,0 +1,130 @@+package org.keycloak.testsuite.model;++import org.infinispan.client.hotrod.RemoteCacheManager;+import org.infinispan.commons.dataconversion.MediaType;+import org.infinispan.configuration.cache.BackupConfiguration;+import org.infinispan.configuration.cache.BackupFailurePolicy;+import org.infinispan.configuration.cache.CacheMode;+import org.infinispan.configuration.cache.Configuration;+import org.infinispan.configuration.cache.ConfigurationBuilder;+import org.infinispan.jboss.marshalling.commons.GenericJBossMarshaller;+import org.infinispan.manager.DefaultCacheManager;+import org.infinispan.server.hotrod.HotRodServer;+import org.infinispan.server.hotrod.configuration.HotRodServerConfiguration;+import org.infinispan.server.hotrod.configuration.HotRodServerConfigurationBuilder;+import org.junit.rules.ExternalResource;+import org.keycloak.Config;++import java.io.IOException;++import static org.keycloak.connections.infinispan.InfinispanConnectionProvider.ACTION_TOKEN_CACHE;+import static org.keycloak.connections.infinispan.InfinispanConnectionProvider.CLIENT_SESSION_CACHE_NAME;+import static org.keycloak.connections.infinispan.InfinispanConnectionProvider.LOGIN_FAILURE_CACHE_NAME;+import static org.keycloak.connections.infinispan.InfinispanConnectionProvider.OFFLINE_CLIENT_SESSION_CACHE_NAME;+import static org.keycloak.connections.infinispan.InfinispanConnectionProvider.OFFLINE_USER_SESSION_CACHE_NAME;+import static org.keycloak.connections.infinispan.InfinispanConnectionProvider.USER_SESSION_CACHE_NAME;+import static org.keycloak.connections.infinispan.InfinispanConnectionProvider.WORK_CACHE_NAME;++public class HotRodServerRule extends ExternalResource {++    protected HotRodServer hotRodServer;++    protected HotRodServer hotRodServer2;++    protected RemoteCacheManager remoteCacheManager;++    protected DefaultCacheManager hotRodCacheManager;++    protected DefaultCacheManager hotRodCacheManager2;++    public void createEmbeddedHotRodServer(Config.Scope config) {+        try {+            hotRodCacheManager = new DefaultCacheManager(""hotRod/hotRod1.xml"");+            hotRodCacheManager2 = new DefaultCacheManager(""hotRod/hotRod2.xml"");+        } catch (IOException e) {+            throw new RuntimeException(e);+        }++        HotRodServerConfiguration build = new HotRodServerConfigurationBuilder().build();+        hotRodServer = new HotRodServer();+        hotRodServer.start(build, hotRodCacheManager);++        HotRodServerConfiguration build2 = new HotRodServerConfigurationBuilder().port(11333).build();+        hotRodServer2 = new HotRodServer();+        hotRodServer2.start(build2, hotRodCacheManager2);++        // Create a Hot Rod client+        org.infinispan.client.hotrod.configuration.ConfigurationBuilder remoteBuilder = new org.infinispan.client.hotrod.configuration.ConfigurationBuilder();+        remoteBuilder.marshaller(new GenericJBossMarshaller());+        org.infinispan.client.hotrod.configuration.Configuration cfg = remoteBuilder+                .addServers(hotRodServer.getHost() + "":"" + hotRodServer.getPort() + "";""+                        + hotRodServer2.getHost() + "":"" + hotRodServer2.getPort()).build();+        remoteCacheManager = new RemoteCacheManager(cfg);++        boolean async = config.getBoolean(""async"", false);++        // create remote keycloak caches+        createKeycloakCaches(async, USER_SESSION_CACHE_NAME, OFFLINE_USER_SESSION_CACHE_NAME, CLIENT_SESSION_CACHE_NAME,+                OFFLINE_CLIENT_SESSION_CACHE_NAME, LOGIN_FAILURE_CACHE_NAME, WORK_CACHE_NAME, ACTION_TOKEN_CACHE);++        getCaches(USER_SESSION_CACHE_NAME, OFFLINE_USER_SESSION_CACHE_NAME, CLIENT_SESSION_CACHE_NAME, OFFLINE_CLIENT_SESSION_CACHE_NAME,+                LOGIN_FAILURE_CACHE_NAME, WORK_CACHE_NAME, ACTION_TOKEN_CACHE);+    }++    private void getCaches(String ...cache) {","Please use correct format - `...` is type alteration, similar to `[]````suggestion    private void getCaches(String... cache) {```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8447,716712160,2021-09-27T13:50:55Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/script/DeployedScriptMapperTest.java,"@@ -74,20 +72,21 @@ public static JavaArchive deploy() throws IOException {     @BeforeClass     public static void verifyEnvironment() {         ContainerAssume.assumeNotAuthServerUndertow();-        ContainerAssume.assumeNotAuthServerQuarkus();     }      @ArquillianResource     private Deployer deployer;      @Before-    public void configureFlows() {+    public void configureFlows() throws Exception {         deployer.deploy(SCRIPT_DEPLOYMENT_NAME);+        reconnectAdminClient();","As said in our call: There's a problem then because the actual `adminClient` used in the tests (and many more places throughout the testsuite) is not necessarily the one we set via `reconnectAdminClient()` or even `setAdminClient(new..)` in TestContext.Both, `TestContext` and `AbstractKeycloakTest` have a `reconnectAdminClient`-method, and to be sure the client is really reconnected, one has to call `AbstractKeycloakTest::reconnectAdminClient()`, which is not possible in our container (I first thought about reflection, but that won't fit either without many instanceof if/else conditions for every test, because the hierarchy until we reach the AbstractKeycloakTest class is different for the tests).Core reason is our testsuite setup does not expect the server to restart when deploying something, but that's how Keycloak.X works by design. So with that assumption in place, the adminClient was used all over the place directly. As said before, one could replace all direct usages of `AbstractKeycloakTest::adminClient` with a method / supplier which then encapsulates the ""reconnect if closed"" logic, but that would be a kind of major refactoring, and I wanted to avoid that for now.  :) ",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/8513,719299309,2021-09-30T11:08:03Z,services/src/main/java/org/keycloak/userprofile/config/DeclarativeUserProfileModel.java,"@@ -28,8 +28,8 @@  */ public class DeclarativeUserProfileModel extends ComponentModel { -    public DeclarativeUserProfileModel() {","How about just adding another constructor and delegate from the noargs ctor to the other one?```java...public class DeclarativeUserProfileModel extends ComponentModel {    public DeclarativeUserProfileModel() {        this(DeclarativeUserProfileProvider.ID);    }    public DeclarativeUserProfileModel(String providerId) {        setProviderId(providerId);        setProviderType(UserProfileProvider.class.getName());    }}```Additionally I'd extract the call to `new DeclarativeUserProfileModel()` into a protected factory method in `DeclarativeUserProfileProvider`, which can then be overridden in subclasses.",
43614225,ioemat,https://api.github.com/repos/keycloak/keycloak/pulls/8513,719342444,2021-09-30T12:12:09Z,services/src/main/java/org/keycloak/userprofile/config/DeclarativeUserProfileModel.java,"@@ -28,8 +28,8 @@  */ public class DeclarativeUserProfileModel extends ComponentModel { -    public DeclarativeUserProfileModel() {","Thanks for the feedback, I really like the idea of the factory method, since it gives the possibility to use a complete different component model. I will enhance the pull request accordingly.Regarding the default constructor I'm not yet 100% convinced.Let me draft what the changes would mean for the developer of a custom user profile:```javapublic class DeclarativeUserProfileProvider extends ... {  ...  /* new factory method for creating compnent model  *  uses default constructor -> model is hard coded in model class  */  protected ComponentModel createComponentModel() {     return new DeclarativeUserProfileModel(); }}public class CustomUserProfileProvider extends DeclarativeUserProfileProvider {  ...  /*  has to be overriden in any sub class to ensure provider id is set correctly  */  protected ComponentModel createComponentModel() {     return new DeclarativeUserProfileModel(this.getId()); }}```When deriving from `DeclarativeUserProfileProvider` one would be enforced to override `createComponentModel()` in order to ensure that the provider id used in the component model is correct.That wouldn't be required if the implementation in `DeclarativeUserProfileProvider`  would be like this:```javapublic class DeclarativeUserProfileProvider extends ... {  ...  /* new factory method for creating compnent model  *  uses default constructor -> model is hard coded in model class  */  protected ComponentModel createComponentModel() {     return new DeclarativeUserProfileModel(this.getId()); }}````getId()` needs to be overridden anyway since it is part of the `ProviderFactory` interface, so it would choose the correct id automatically.It would still be possible to use a complete different implementation by overriding the factory method, but when nothing special is required it would just work as expected out-of-the-box.What do you think about this @thomasdarimont ?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8459,720002601,2021-10-01T07:22:46Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -0,0 +1,327 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.processor;++import org.keycloak.models.map.annotations.GenerateEntityImplementations;+import org.keycloak.models.map.annotations.GenerateEnumMapFieldType;+import java.io.IOException;+import java.io.PrintWriter;+import java.util.Arrays;+import java.util.HashMap;+import java.util.HashSet;+import java.util.LinkedHashSet;+import java.util.List;+import java.util.Map;+import java.util.Map.Entry;+import java.util.Objects;+import java.util.Set;+import java.util.TreeSet;+import java.util.regex.Matcher;+import java.util.regex.Pattern;+import java.util.stream.Collectors;+import javax.annotation.processing.AbstractProcessor;+import javax.annotation.processing.RoundEnvironment;+import javax.annotation.processing.SupportedAnnotationTypes;+import javax.annotation.processing.SupportedSourceVersion;+import javax.lang.model.SourceVersion;+import javax.lang.model.element.Element;+import javax.lang.model.element.ElementKind;+import javax.lang.model.element.ExecutableElement;+import javax.lang.model.element.Modifier;+import javax.lang.model.element.Name;+import javax.lang.model.element.TypeElement;+import javax.lang.model.element.VariableElement;+import javax.lang.model.type.NoType;+import javax.lang.model.type.TypeMirror;+import javax.lang.model.util.Elements;+import javax.lang.model.util.Types;+import javax.tools.Diagnostic.Kind;+import javax.tools.JavaFileObject;++/**+ *+ * @author hmlnarik+ */+@SupportedAnnotationTypes(""org.keycloak.models.map.annotations.GenerateEntityImplementations"")+@SupportedSourceVersion(SourceVersion.RELEASE_8)+public class GenerateEntityImplementationsProcessor extends AbstractProcessor {++    @Override+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {+        for (TypeElement annotation : annotations) {+            Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith(annotation);+            annotatedElements.stream()+              .map(TypeElement.class::cast)+              .forEach(this::processTypeElement);+        }++        return true;+    }++    private void processTypeElement(TypeElement e) {+        if (e.getKind() != ElementKind.INTERFACE) {+            processingEnv.getMessager().printMessage(Kind.ERROR, ""Annotation @GenerateEntityImplementations is only applicable to interface"", e);+            return;+        }++        // Find all properties+        Map<String, HashSet<ExecutableElement>> methodsPerAttribute = e.getEnclosedElements().stream()+          .filter(ExecutableElement.class::isInstance)+          .map(ExecutableElement.class::cast)+          .filter(ee -> ! (ee.getReceiverType() instanceof NoType))+          .collect(Collectors.toMap(this::determineAttributeFromMethodName, v -> new HashSet(Arrays.asList(v)), (a,b) -> { a.addAll(b); return a; }));++        // Merge plurals with singulars+        methodsPerAttribute.keySet().stream()+          .filter(key -> methodsPerAttribute.containsKey(key + ""s""))+          .collect(Collectors.toSet())+          .forEach(key -> {+              HashSet<ExecutableElement> removed = methodsPerAttribute.remove(key);+              methodsPerAttribute.get(key + ""s"").addAll(removed);+          });++        try {+            generateImpl(e, methodsPerAttribute);+        } catch (IOException ex) {+            processingEnv.getMessager().printMessage(Kind.ERROR, ""Could not generate implementation for class"", e);+        }++//        methodsPerAttribute.entrySet().stream()+//          .sorted(Comparator.comparing(Map.Entry::getKey))+//          .forEach(me -> processingEnv.getMessager().printMessage(+//              Diagnostic.Kind.NOTE,+//              ""** "" + me.getKey() + "": "" + me.getValue().stream().map(ExecutableElement::getSimpleName).sorted(Comparator.comparing(Object::toString)).collect(Collectors.joining("", "")))+//          );+    }++    private static final Pattern BEAN_NAME = Pattern.compile(""(get|set|is|delete|remove|add|update)([A-Z]\\S+)"");+    private static final Map<String, String> FORBIDDEN_PREFIXES = new HashMap<>();+    static {+        FORBIDDEN_PREFIXES.put(""delete"", ""remove"");+    }++    private String determineAttributeFromMethodName(ExecutableElement e) {+        Name name = e.getSimpleName();+        Matcher m = BEAN_NAME.matcher(name.toString());+        if (m.matches()) {+            String prefix = m.group(1);+            if (FORBIDDEN_PREFIXES.containsKey(prefix)) {+                processingEnv.getMessager().printMessage(+                  Kind.ERROR,+                  ""Forbidden prefix "" + prefix + ""... detected, use "" + FORBIDDEN_PREFIXES.get(prefix) + ""... instead"", e+                );+            }+            return m.group(2);+        }+        return null;+    }++    private void generateImpl(TypeElement e, Map<String, HashSet<ExecutableElement>> methodsPerAttribute) throws IOException {+        GenerateEntityImplementations an = e.getAnnotation(GenerateEntityImplementations.class);+        Elements elements = processingEnv.getElementUtils();+        TypeElement parentTypeElement = elements.getTypeElement(an.inherits().isEmpty() ? ""void"" : an.inherits());+        final List<? extends Element> allMembers = elements.getAllMembers(parentTypeElement);+        String className = e.getQualifiedName().toString();+        String packageName = null;+        int lastDot = className.lastIndexOf('.');+        if (lastDot > 0) {+            packageName = className.substring(0, lastDot);+        }++        String simpleClassName = className.substring(lastDot + 1);+        String mapImplClassName = className + ""Impl"";+        String mapSimpleClassName = simpleClassName + ""Impl"";++        JavaFileObject enumFile = processingEnv.getFiler().createSourceFile(mapImplClassName);+        try (PrintWriter pw = new PrintWriter(enumFile.openWriter()) {+            @Override+            public void println(String x) {+                super.println(x == null ? x : x.replaceAll(""java.lang."", """"));+            }+        }) {+            if (packageName != null) {+                pw.println(""package "" + packageName + "";"");+            }++            pw.println(""import java.util.EnumMap;"");+            pw.println(""import java.util.Objects;"");+            pw.println(""public class "" + mapSimpleClassName + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");",Should we add some warning that the class is generated and should not be changed manually?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8459,720019275,2021-10-01T07:44:38Z,model/map/src/main/java/org/keycloak/models/map/common/Serialization.java,"@@ -51,6 +52,7 @@       .setSerializationInclusion(JsonInclude.Include.NON_NULL)       .setVisibility(PropertyAccessor.ALL, Visibility.NONE)       .setVisibility(PropertyAccessor.FIELD, Visibility.ANY)+      .activateDefaultTyping(new LaissezFaireSubTypeValidator() /* TODO - see javadoc */, ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY)","To ensure that the JSONs contain proper typing of values in case of the `EnumMap<Field, Object>` which is necessary for deserialization. It adds type information into the serialized form of the `Object` values. When omitted, the values are deserialized into default collections, e.g. into a singleton read-only set rather than a proper `ArrayList`.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8525,721113787,2021-10-04T07:43:34Z,quarkus/runtime/src/test/java/org/keycloak/provider/quarkus/ConfigurationTest.java,"@@ -110,57 +111,57 @@ public void testCamelCase() {      @Test     public void testEnvVarPriorityOverPropertiesFile() {-        putEnvVar(""KC_SPI_HOSTNAME_DEFAULT_FRONTEND_URL"", ""http://envvar.com"");-        assertEquals(""http://envvar.com"", initConfig(""hostname"", ""default"").get(""frontendUrl""));+        putEnvVar(""KC_SPI_HOSTNAME_DEFAULT_FRONTEND_URL"", ""http://envvar.unittest"");",some of the URLs we used here were actually reachable. Imo we should use some kind of pattern like this here instead.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/8267,721421798,2021-10-04T14:29:15Z,testsuite/model/src/main/java/org/keycloak/testsuite/model/KeycloakModelParameters.java,"@@ -67,4 +67,11 @@ public Statement instanceRule(Statement base, Description description) {         return base;     } +    public void suiteRule(Config cf) {++    }++    public void afterClass() {++    }",I changed `suiteRule` to `beforeSuite` and removed `afterClass` and used `classRule`.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8081,721668896,2021-10-04T19:49:31Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -987,6 +987,9 @@ public AccessTokenResponseBuilder generateIDToken(boolean isIdTokenAsDetachedSig             idToken.setSessionState(accessToken.getSessionState());             idToken.expiration(accessToken.getExpiration());             idToken.setAcr(accessToken.getAcr());+            if(client.isFrontchannelLogout()){                ",I think we no longer need this code because the `sid` should be part of the token already. See `org.keycloak.representations.IDToken#SESSION_ID`.See https://github.com/pedroigor/keycloak/tree/KEYCLOAK-17653.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8081,721708085,2021-10-04T20:50:45Z,themes/src/main/resources/theme/base/login/frontchannel-logout.ftl,"@@ -0,0 +1,32 @@+<#import ""template.ftl"" as layout>+<@layout.registrationLayout; section>+    <#if section = ""header"">+        <script>+            document.title =  ""${msg(""frontchannel-logout.title"")}"";+        </script>+        ${msg(""frontchannel-logout.title"")}+    <#elseif section = ""form"">+        <p>${msg(""frontchannel-logout.message"")}</p>+        <#if frontchannelLogout.urls?has_content>+            <ul>+            <#list frontchannelLogout.urls[0]?split(' ') as url>+                <li>+                    <iframe src=""${url}"" style=""width:1px; height:1px;""></iframe>","Looks like we are not displaying anything on this page to reference the apps we are logging out.IMO, we could create a specific bean to build this page (like we do in some other templates) so that instead of passing the list of URLs we use the client identifiers. This bean than is responsible for returning the frontend urls and any other information about the client we want, such as the display name or client id.Does it make sense? ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8081,721709361,2021-10-04T20:52:37Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCLoginProtocol.java,"@@ -339,8 +341,30 @@ public Response backchannelLogout(UserSessionModel userSession, AuthenticatedCli      @Override     public Response frontchannelLogout(UserSessionModel userSession, AuthenticatedClientSessionModel clientSession) {-        // todo oidc redirect support-        throw new RuntimeException(""NOT IMPLEMENTED"");+        if (clientSession != null) {+            String url = clientSession.getClient().getAttribute(""frontchannel.logout.url"");+            if (url != null && !url.trim().isEmpty()) {+                UriBuilder builder = UriBuilder.fromUri(url);+                builder.queryParam(""sid"", userSession.getId());+                builder.queryParam(""iss"", clientSession.getNote(OIDCLoginProtocol.ISSUER));+                URI uri = builder.build();+                appendUserSession(userSession,""frontchannel_logout_urls"",uri.toString());","IMO, we should just pass a list of client ids. It should have the same effect as this because from the id you can query the client and then obtain the frontend uri.Also, it should help building the freemarker template as we can get more information about the client (e.g.: display name, client id).",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8496,721953156,2021-10-05T07:15:13Z,services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java,"@@ -530,6 +531,10 @@ public Response createLoginPassword(){      @Override     public Response createPasswordReset() {+        MultivaluedMap<String, String> params = context.getUriInfo().getQueryParameters();","I think that the ""login_hint"" can be rather obtained from the authentication session with something like:```authenticationSession.getClientNote(OIDCLoginProtocol.LOGIN_HINT_PARAM)```This will be better than reading it directly from request parameters, as request parameters are OIDC-protocol specific.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8533,722320588,2021-10-05T14:48:44Z,testsuite/integration-arquillian/servers/auth-server/quarkus/src/main/content/conf/keycloak.properties,"@@ -34,4 +34,7 @@ spi.theme.folder.dir=${kc.home.dir:}/themes spi.password-policy.password-blacklist.blacklists-path=${kc.home.dir:}/dependency/password-blacklists  # http client connection reuse settings-spi.connections-http-client.default.reuse-connections=false\ No newline at end of file+spi.connections-http-client.default.reuse-connections=false++# set max-length of event representation stored so the db can handle it+spi.events-store.jpa.max-detail-length=2000","@pedroigor i could add that property to the dists keycloak.properties, too, if needed. seems reasonable for me to have it set by default to a value which does not cause the db to throw an exception. Just not sure if I should do it together with this PR or with a separate ticket/PR.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8267,722947307,2021-10-06T07:10:51Z,services/src/main/java/org/keycloak/executors/DefaultExecutorsProviderFactory.java,"@@ -189,7 +189,7 @@ protected ExecutorService createPoolEmbedded(String taskType, KeycloakSession se             // Same like Executors.newCachedThreadPool. Besides that ""min"" and ""max"" are configurable             return new ThreadPoolExecutor(min, max,                     60L, TimeUnit.SECONDS,-                    new SynchronousQueue<Runnable>(),+                    new ArrayBlockingQueue<>(1024),","> Why is this change necessary?> > If I understand correctly, this means, that when 1024 tasks are waiting for execution a `RejectedExecutionException` exception is thrown. Should we catch this exception for example here: https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/protocol/saml/SamlService.java#L387?No, there are many other places that use this functionality, and the exhausted pool should be visible to the administrator to take appropriate action in configuring the pool. FTR, the default queue in Wildfly is unbounded.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/8393,723034090,2021-10-06T09:01:54Z,GOVERNANCE.md,"@@ -62,8 +62,7 @@ To become a maintainer, you need to demonstrate the following: * Ability to collaborate with the team * Helping the community -A new maintainer must be proposed by sending an email to the [developer mailing list](https://groups.google.com/forum/#!forum/keycloak-dev).-The email should include evidence of the above list.+A new maintainer must be nominated by sending a pull request to the [Maintainers list]https://github.com/keycloak/keycloak/blob/master/MAINTAINERS.md. The PR description must include evidence to support the nomination.",```suggestionA new maintainer must be proposed by sending an email to keycloak-maintainers(at)googlegroups.com.The email should include evidence of the above list.```,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8081,723365291,2021-10-06T14:56:13Z,core/src/main/java/org/keycloak/representations/oidc/OIDCClientRepresentation.java,"@@ -559,4 +561,12 @@ public Boolean getRequirePushedAuthorizationRequests() {     public void setRequirePushedAuthorizationRequests(Boolean require_pushed_authorization_requests) {         this.require_pushed_authorization_requests = require_pushed_authorization_requests;     }++    public String getFrontchannelLogoutUri() {","looking over it after pedros mail on keycloak-dev, just a small note: Please correct the casing here (and in similar places) - sometimes it's ...FrontChannel..., sometimes ...Frontchannel.... Imo: use ...FrontChannel...  everywhere. Thanks!",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8540,724880236,2021-10-08T10:06:08Z,quarkus/runtime/src/main/java/org/keycloak/cli/command/ShowConfig.java,"@@ -31,60 +31,69 @@ import java.util.function.Predicate; import java.util.stream.Collectors; import java.util.stream.StreamSupport;- import org.keycloak.configuration.MicroProfileConfigProvider; import org.keycloak.configuration.PersistedConfigSource; import org.keycloak.configuration.PropertyMappers; import org.keycloak.util.Environment;  import io.smallrye.config.ConfigValue;+import picocli.CommandLine;++@CommandLine.Command(name = ""show-config"",+        description = ""Print out the current configuration."",+        mixinStandardHelpOptions = true,+        optionListHeading = ""%nOptions%n"",+        parameterListHeading = ""Available Commands%n"")+public final class ShowConfig extends AbstractCommand implements Runnable { -public final class ShowConfigCommand {+    @CommandLine.Parameters(paramLabel = ""filter"", defaultValue = ""none"", description = ""Show all configuration options. Use 'all' to show all options."") String filter; -    public static void run() {+    @Override+    public void run() {+        System.setProperty(""kc.show.config"", filter);         String configArgs = System.getProperty(""kc.show.config"");          if (configArgs != null) {","Minor suggestion: SonarLint tells me this method has too many if/else conditions. Perhaps better like this: ``` if (configArgs != null) {            Map<String, Set<String>> properties = getPropertiesByGroup();            String profile = getProfile();            printRunTimeConfig(properties, profile);            if (configArgs.equalsIgnoreCase(""all"")) {                printAllProfilesConfig(properties, profile);                spec.commandLine().getOut().println(""Quarkus Configuration:"");                properties.get(MicroProfileConfigProvider.NS_QUARKUS).stream().sorted()                        .forEachOrdered(this::printProperty);            }            if (!parseBoolean(System.getProperty(""kc.show.config.runtime"", Boolean.FALSE.toString()))) {                System.exit(0);            }        }```...and refactor the code into the methods `printRunTimeConfig`and `printAllProfilesConfig`? wdyt?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8550,725929486,2021-10-11T09:06:11Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -220,109 +165,329 @@ private TypeMirror determineFieldType(String fieldName, HashSet<ExecutableElemen             }         }         if (res == null) {-            processingEnv.getMessager().printMessage(Kind.ERROR, ""Could not determine return type for field "" + fieldName, methods.iterator().next());+            processingEnv.getMessager().printMessage(Kind.ERROR, ""Could not determine return type for the field "" + fieldName, methods.iterator().next());         }         return res;     } -    private boolean printMethodBody(PrintWriter pw, ExecutableElement method, String fieldName, String enumConstant, TypeMirror fieldType) {-        Pattern getter = Pattern.compile(""(get|is)"" + Pattern.quote(fieldName));-        Types types = processingEnv.getTypeUtils();-        final String methodName = method.getSimpleName().toString();-        String setter = ""set"" + fieldName;-        TypeMirror firstParameterType = method.getParameters().isEmpty()-          ? types.getNullType()-          : method.getParameters().get(0).asType();-        String fieldNameSingular = fieldName.endsWith(""s"") ? fieldName.substring(0, fieldName.length() - 1) : fieldName;-        String getFromMap = ""get"" + fieldNameSingular;-        String addToCollection = ""add"" + fieldNameSingular;-        String updateMap = ""set"" + fieldNameSingular;-        String removeFromCollection = ""remove"" + fieldNameSingular;-        Elements elements = processingEnv.getElementUtils();+    private boolean isImmutableFinalType(TypeMirror fieldType) {+        return isPrimitiveType(fieldType) || isBoxedPrimitiveType(fieldType) || Objects.equals(""java.lang.String"", fieldType.toString());+    }++    private boolean isKnownCollectionOfImmutableFinalTypes(TypeMirror fieldType) {         TypeElement typeElement = elements.getTypeElement(types.erasure(fieldType).toString());+        switch (typeElement.getQualifiedName().toString()) {+            case ""java.util.List"":+            case ""java.util.Map"":+            case ""java.util.Set"":+            case ""java.util.Collection"":+            case ""org.keycloak.common.util.MultivaluedHashMap"":+                List<TypeMirror> res = getGenericsDeclaration(fieldType);+                return res.stream().allMatch(tm -> isImmutableFinalType(tm) || isKnownCollectionOfImmutableFinalTypes(tm));+            default:+                return false;+        }+    } -        if (getter.matcher(methodName).matches() && method.getParameters().isEmpty() && types.isSameType(fieldType, method.getReturnType())) {-            pw.println(""    @Override public "" + method.getReturnType() + "" "" + method + "" {"");-            pw.println(""        return ("" + fieldType + "") get(Field."" + enumConstant + "");"");-            pw.println(""    }"");-            return true;-        } else if (setter.equals(methodName) && types.isSameType(firstParameterType, fieldType)) {-            pw.println(""    @Override public "" + method.getReturnType() + "" "" + method.getSimpleName() + ""("" + firstParameterType + "" p0) {"");-            pw.println(""        Object o = set(Field."" + enumConstant + "", p0);"");-            pw.println(""        updated |= ! Objects.equals(o, p0);"");-            pw.println(""    }"");+    private boolean isPrimitiveType(TypeMirror fieldType) {+        try {+            types.getPrimitiveType(fieldType.getKind());             return true;-        } else if (addToCollection.equals(methodName) && method.getParameters().size() == 1) {-            pw.println(""    @Override public "" + method.getReturnType() + "" "" + method.getSimpleName() + ""("" + firstParameterType + "" p0) {"");-            pw.println(""        "" + fieldType + "" o = ("" + fieldType + "") get(Field."" + enumConstant + "");"");-            pw.println(""        if (o == null) { o = "" + interfaceToImplementation(typeElement) + ""; set(Field."" + enumConstant + "", o); }"");-            if (isSetType(typeElement)) {-                pw.println(""        updated |= o.add(p0);"");-            } else {-                pw.println(""        o.add(p0);"");-                pw.println(""        updated = true;"");+        } catch (IllegalArgumentException ex) {+            return false;             }-            pw.println(""    }"");-            return true;-        } else if (removeFromCollection.equals(methodName) && method.getParameters().size() == 1) {-            pw.println(""    @Override public "" + method.getReturnType() + "" "" + method.getSimpleName() + ""("" + firstParameterType + "" p0) {"");-            pw.println(""        "" + fieldType + "" o = ("" + fieldType + "") get(Field."" + enumConstant + "");"");-            pw.println(""        if (o == null) { return; }"");-            pw.println(""        boolean removed = o.remove(p0)"" + (""java.util.Map"".equals(typeElement.getQualifiedName().toString()) ? "" != null"" : """") + "";"");-            pw.println(""        updated |= removed;"");-            pw.println(""    }"");-            return true;-        } else if (updateMap.equals(methodName) && method.getParameters().size() == 2) {-            pw.println(""    @Override public "" + method.getReturnType() + "" "" + method.getSimpleName() + ""("" + firstParameterType + "" p0, "" + method.getParameters().get(1).asType() + "" p1) {"");-            pw.println(""        "" + fieldType + "" o = ("" + fieldType + "") get(Field."" + enumConstant + "");"");-            pw.println(""        if (o == null) { o = "" + interfaceToImplementation(typeElement) + ""; set(Field."" + enumConstant + "", o); }"");-            pw.println(""        Object v = o.put(p0, p1);"");-            pw.println(""        updated |= ! Objects.equals(v, p1);"");-            pw.println(""    }"");-            return true;-        } else if (getFromMap.equals(methodName) && method.getParameters().size() == 1) {-            pw.println(""    @Override public "" + method.getReturnType() + "" "" + method.getSimpleName() + ""("" + firstParameterType + "" p0) {"");-            pw.println(""        "" + fieldType + "" o = ("" + fieldType + "") get(Field."" + enumConstant + "");"");-            pw.println(""        return o == null ? null : o.get(p0);"");-            pw.println(""    }"");-            return true;         } -        return false;-    }--    private String interfaceToImplementation(TypeElement typeElement) {-        GenerateEnumMapFieldType an = typeElement.getAnnotation(GenerateEnumMapFieldType.class);-        if (an != null) {-            return ""new "" + an.value().getCanonicalName() + ""<>()"";+    private boolean isBoxedPrimitiveType(TypeMirror fieldType) {+        try {+            types.unboxedType(fieldType);+            return true;+        } catch (IllegalArgumentException ex) {+            return false;         }+    } +    private String interfaceToImplementation(TypeElement typeElement, String parameter) {         Name parameterTypeQN = typeElement.getQualifiedName();         switch (parameterTypeQN.toString()) {             case ""java.util.List"":-                return ""new java.util.LinkedList<>()"";+            case ""java.util.Collection"":+                return ""new java.util.LinkedList<>("" + parameter + "")"";             case ""java.util.Map"":-                return ""new java.util.HashMap<>()"";+                return ""new java.util.HashMap<>("" + parameter + "")"";             case ""java.util.Set"":-                return ""new java.util.HashSet<>()"";-            case ""java.util.Collection"":-                return ""new java.util.LinkedList<>()"";+                return ""new java.util.HashSet<>("" + parameter + "")"";             default:                 processingEnv.getMessager().printMessage(Kind.ERROR, ""Could not determine implementation for type "" + typeElement, typeElement);                 return ""TODO()"";         }     } -    private String methodParameters(List<? extends VariableElement> parameters) {-        return parameters.stream()-          .map(p -> p.asType() + "" "" + p.getSimpleName())-          .collect(Collectors.joining("", ""));+    private class FieldsGenerator implements Generator {+        @Override+        public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> methodsPerAttribute) throws IOException {+            String className = e.getQualifiedName().toString();+            String packageName = null;+            int lastDot = className.lastIndexOf('.');+            if (lastDot > 0) {+                packageName = className.substring(0, lastDot);+            }++            String simpleClassName = className.substring(lastDot + 1);+            String mapFieldsClassName = className + ""Fields"";+            String mapSimpleFieldsClassName = simpleClassName + ""Fields"";++            JavaFileObject file = processingEnv.getFiler().createSourceFile(mapFieldsClassName);+            try (PrintWriter pw = new PrintWriterNoJavaLang(file.openWriter())) {+                if (packageName != null) {+                    pw.println(""package "" + packageName + "";"");+                }++                pw.println(""public enum "" + mapSimpleFieldsClassName + "" {"");+                methodsPerAttribute.keySet().stream()+                  .sorted()+                  .map(GenerateEntityImplementationsProcessor::toEnumConstant)+                  .forEach(key -> pw.println(""    "" + key + "",""));+                pw.println(""}"");+            }+        }+    }++    private class ImplGenerator implements Generator {++        @Override+        public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> methodsPerAttribute) throws IOException {+            GenerateEntityImplementations an = e.getAnnotation(GenerateEntityImplementations.class);+            TypeElement parentTypeElement = elements.getTypeElement((an.inherits() == null || an.inherits().isEmpty()) ? ""void"" : an.inherits());+            if (parentTypeElement == null) {+                return;+            }+            final List<? extends Element> allMembers = elements.getAllMembers(parentTypeElement);+            String className = e.getQualifiedName().toString();+            String packageName = null;+            int lastDot = className.lastIndexOf('.');+            if (lastDot > 0) {+                packageName = className.substring(0, lastDot);+            }++            String simpleClassName = className.substring(lastDot + 1);+            String mapImplClassName = className + ""Impl"";+            String mapSimpleClassName = simpleClassName + ""Impl"";+            boolean hasId = methodsPerAttribute.containsKey(""Id"") || allMembers.stream().anyMatch(el -> ""getId"".equals(el.getSimpleName().toString()));++            JavaFileObject file = processingEnv.getFiler().createSourceFile(mapImplClassName);+            try (PrintWriter pw = new PrintWriterNoJavaLang(file.openWriter())) {+                if (packageName != null) {+                    pw.println(""package "" + packageName + "";"");+                }++                pw.println(""import java.util.Objects;"");+                pw.println(""// DO NOT CHANGE THIS CLASS, IT IS GENERATED AUTOMATICALLY BY "" + GenerateEntityImplementationsProcessor.class.getSimpleName());+                pw.println(""public class "" + mapSimpleClassName + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");+//                pw.println(""    private final EnumMap<Field, Object> values = new EnumMap<>(Field.class);"");+//                pw.println(""    protected Object get(Field field) { return values.get(field); }"");+//                pw.println(""    protected Object set(Field field, Object p0) { return values.put(field, p0); }"");+                pw.println(""    @Override public boolean equals(Object o) {"");+                pw.println(""        if (o == this) return true; "");+                pw.println(""        if (! (o instanceof "" + mapSimpleClassName + "")) return false; "");+                pw.println(""        "" + mapSimpleClassName + "" other = ("" + mapSimpleClassName + "") o; "");+                pw.println(""        return ""+                  + methodsPerAttribute.entrySet().stream()+                    .map(me -> FieldAccessorType.getMethod(GETTER, me.getValue(), me.getKey(), types, determineFieldType(me.getKey(), me.getValue())))+                    .filter(Optional::isPresent)+                    .map(Optional::get)+                    .map(ExecutableElement::getSimpleName)+                    .map(Name::toString)+                    .sorted()+                    .map(v -> ""Objects.equals("" + v + ""(), other."" + v + ""())"")+                    .collect(Collectors.joining(""\n          && ""))+                  + "";"");+                pw.println(""    }"");+                pw.println(""    @Override public int hashCode() {"");+                pw.println(""        return "" + (hasId ? ""(getId() == null ? super.hashCode() : getId().hashCode())"" : ""super.hashCode()"") + "";"");+                pw.println(""    }"");+                pw.println(""    @Override public String toString() {"");+                pw.println(""        return String.format(\""%s@%08x\"", "" + (hasId ? ""getId()"" : ""\"""" + mapSimpleClassName + ""\"""" ) + "", System.identityHashCode(this));"");+                pw.println(""    }"");++                // Constructors+                allMembers.stream()+                  .filter(ExecutableElement.class::isInstance)+                  .map(ExecutableElement.class::cast)+                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)+                  .forEach((ExecutableElement ee) -> pw.println(""    ""+                  + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))+                  + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""));++                methodsPerAttribute.entrySet().stream().sorted(Comparator.comparing(Map.Entry::getKey)).forEach(me -> {+                    HashSet<ExecutableElement> methods = me.getValue();+                    TypeMirror fieldType = determineFieldType(me.getKey(), methods);+                    if (fieldType == null) {+                        return;+                    }++                    pw.println("""");+                    pw.println(""    private "" + fieldType + "" f"" + me.getKey() + "";"");++                    for (ExecutableElement method : methods) {+                        FieldAccessorType fat = FieldAccessorType.determineType(method, me.getKey(), types, fieldType);+                        if (fat != FieldAccessorType.UNKNOWN && ! printMethodBody(pw, fat, method, ""f"" + me.getKey(), fieldType)) {+                            List<ExecutableElement> parentMethods = allMembers.stream()+                              .filter(ExecutableElement.class::isInstance)+                              .map(ExecutableElement.class::cast)+                              .filter(ee -> Objects.equals(ee.toString(), method.toString()))+                              .filter((ExecutableElement ee) ->  ! ee.getModifiers().contains(Modifier.ABSTRACT))+                              .collect(Collectors.toList());+                            if ( ! parentMethods.isEmpty()) {","Would it make sense to check this condition first and not implement those that are already implemented? This way we could ""override"" methods that we don't want to be implemented by the generator. This could be used for example for `setId`. WDYT? ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8550,726186203,2021-10-11T14:47:42Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientEntity.java,"@@ -35,11 +35,10 @@ @GenerateEntityImplementations(inherits=""org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity"") public interface MapClientEntity extends AbstractEntity, UpdatableEntity { -    static abstract class AbstractClientEntity implements MapClientEntity {+    public abstract class AbstractClientEntity extends UpdatableEntity.Impl implements MapClientEntity {","not here. `ProtocolMapper` is never set in full, only added/removed via `setProtocolMapper` and `removeProtocolMapper`, hence `updated` flag is always maintained correctly, and the protocol mapper is cloned before storing within the entity so no external process can silently modify it.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8550,726905879,2021-10-12T08:53:10Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/FieldAccessorType.java,"@@ -0,0 +1,121 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.processor;++import java.util.HashSet;+import java.util.List;+import java.util.Objects;+import java.util.Optional;+import java.util.regex.Pattern;+import javax.lang.model.element.ExecutableElement;+import javax.lang.model.element.Name;+import javax.lang.model.type.TypeMirror;+import javax.lang.model.util.Types;+import static org.keycloak.models.map.processor.Util.getGenericsDeclaration;++/**+ *+ * @author hmlnarik+ */+enum FieldAccessorType {+    GETTER {+        @Override+        public boolean is(ExecutableElement method, String fieldName, Types types, TypeMirror fieldType) {+            Pattern getter = Pattern.compile(""(get|is)"" + Pattern.quote(fieldName));+            Name methodName = method.getSimpleName();+            return getter.matcher(methodName).matches() && method.getParameters().isEmpty() && types.isSameType(fieldType, method.getReturnType());+        }+    },+    SETTER {+        @Override+        public boolean is(ExecutableElement method, String fieldName, Types types, TypeMirror fieldType) {+            String methodName = ""set"" + fieldName;+            return Objects.equals(methodName, method.getSimpleName().toString())+              && method.getParameters().size() == 1+              && types.isSameType(fieldType, method.getParameters().get(0).asType());+        }+    },+    COLLECTION_ADD {+        @Override+        public boolean is(ExecutableElement method, String fieldName, Types types, TypeMirror fieldType) {+            String fieldNameSingular = fieldName.endsWith(""s"") ? fieldName.substring(0, fieldName.length() - 1) : fieldName;+            String methodName = ""add"" + fieldNameSingular;+            List<TypeMirror> res = getGenericsDeclaration(fieldType);+            return Objects.equals(methodName, method.getSimpleName().toString())+              && res.size() == 1+              && types.isSameType(res.get(0), method.getParameters().get(0).asType());+        }+    },+    COLLECTION_DELETE {+        @Override+        public boolean is(ExecutableElement method, String fieldName, Types types, TypeMirror fieldType) {+            String fieldNameSingular = fieldName.endsWith(""s"") ? fieldName.substring(0, fieldName.length() - 1) : fieldName;+            String removeFromCollection = ""remove"" + fieldNameSingular;+            List<TypeMirror> res = getGenericsDeclaration(fieldType);+            return Objects.equals(removeFromCollection, method.getSimpleName().toString())+              && method.getParameters().size() == 1+              && types.isSameType(res.get(0), method.getParameters().get(0).asType());+        }+    },+    MAP_ADD {+        @Override+        public boolean is(ExecutableElement method, String fieldName, Types types, TypeMirror fieldType) {+            String fieldNameSingular = fieldName.endsWith(""s"") ? fieldName.substring(0, fieldName.length() - 1) : fieldName;+            String methodName = ""set"" + fieldNameSingular;+            List<TypeMirror> res = getGenericsDeclaration(fieldType);+            return Objects.equals(methodName, method.getSimpleName().toString())+              && res.size() == 2+              && types.isSameType(res.get(0), method.getParameters().get(0).asType())+              && types.isSameType(res.get(1), method.getParameters().get(1).asType());+        }+    },+    MAP_GET {+        @Override+        public boolean is(ExecutableElement method, String fieldName, Types types, TypeMirror fieldType) {+            String fieldNameSingular = fieldName.endsWith(""s"") ? fieldName.substring(0, fieldName.length() - 1) : fieldName;+            String methodName = ""get"" + fieldNameSingular;+            List<TypeMirror> res = getGenericsDeclaration(fieldType);+            return Objects.equals(methodName, method.getSimpleName().toString())+              && res.size() == 2+              && types.isSameType(res.get(0), method.getParameters().get(0).asType());+        }+    },+    UNKNOWN /* Must be the last */ {+        @Override+        public boolean is(ExecutableElement method, String fieldName, Types types, TypeMirror fieldType) {+            return true;","I see why it is there. We can leave this as-is, I am leaving the decision to you. However, I think it would be less error-prone to only return `UNKNOWN` when no value matches to avoid returning `UNKNOWN` when enum values are accidentally looped through in a wrong order. I am aware of the fact that this situation should not happen as `values()` always return values in order as they were declared but still, I think this is worth considering.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8550,726964524,2021-10-12T10:04:11Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientEntity.java,"@@ -35,11 +35,10 @@ @GenerateEntityImplementations(inherits=""org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity"") public interface MapClientEntity extends AbstractEntity, UpdatableEntity { -    static abstract class AbstractClientEntity implements MapClientEntity {+    public abstract class AbstractClientEntity extends UpdatableEntity.Impl implements MapClientEntity {","I see. Then, why ProtocolMapperEntityImpl implements `UpdatableEntity` if the flag `updated` is never used?Also, we should be consistent and treat all nested entities in the same way. Therefore, I think we should decide how we want users to work with nested entities. I can see two ways:1. What we have now, `get*()` nested entity model, update it and call `set*()` 2. We can use `updated` flag also for nested entities and change corresponding adapters to do updates also in entitiesI would vote for the second approach, this way we would be consistent across all models regardless the fact whether it is nested or not. On the other hand, we can choose also the first approach, in that case we should probably not have updated flag in nested entities at all and change all usages of it to first approach.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8550,726968419,2021-10-12T10:09:39Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapKeycloakTransaction.java,"@@ -212,6 +212,7 @@ private V getUpdated(V orig) {     public V create(V value) {         String key = value.getId();         if (key == null) {+            value = Serialization.from(value);","Will this be removed when cloners are implemented? Or CHM won't use any cloner? Also, should we move this serialization outside of `if (key == null)` branch?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8550,727034612,2021-10-12T11:27:10Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapKeycloakTransaction.java,"@@ -212,6 +212,7 @@ private V getUpdated(V orig) {     public V create(V value) {         String key = value.getId();         if (key == null) {+            value = Serialization.from(value);","TL;DR: No, No, Yes with cloners.Long answer - the input `value` parameter might be from a different storage, e.g. a JPA store. Such an object we don't want to store in a CHM, so they need to be cloned into a CHM-native (i.e. `Impl`) instance. The cloners will handle this automatically, but at this phase, there are no cloners, so `Serialization` is the only option, and is sufficient for now.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7323,728739694,2021-10-14T08:10:31Z,themes/src/main/resources/theme/keycloak/common/resources/lib/zocial/zocial.css,"@@ -132,6 +132,7 @@ a.zocial { .zocial.gmail, .zocial.instapaper, .zocial.itunes,+.zocial.apple,","Could you please remove changes in this CSS file? The Zocial styles are deprecated and will be removed soon. Instead of that, you can use PF4 icons.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8534,728915584,2021-10-14T12:07:09Z,testsuite/integration-arquillian/tests/other/webauthn/pom.xml,"@@ -0,0 +1,104 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<project xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>integration-arquillian-tests-other</artifactId>+        <version>16.0.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>integration-arquillian-tests-webauthn</artifactId>++    <name>WebAuthn tests</name>++    <properties>+        <selenium.version>4.0.0-rc-3</selenium.version>+        <selenium.server.version>4.0.0-alpha-2</selenium.server.version>+        <arquillian.drone.version>${selenium.version}</arquillian.drone.version>+        <graphene.webdriver.version>2.4.0.Alpha-2</graphene.webdriver.version>+        <htmlunit.driver.version>${selenium.version}</htmlunit.driver.version>+    </properties>++    <repositories>+        <repository>+            <id>github-selenium-bom</id>+            <url>https://keycloak-packages:&#103;hp_tSeU74eZVGTSupVCap28N8TX0M88YJ06kua9@maven.pkg.github.com/mabartos/selenium-bom</url>",Is this really correct approach? Or we don't have any better option right now? Do we have any possibility for more long term solution instead of relying on our own manually built packages?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8564,728925757,2021-10-14T12:20:39Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -282,23 +351,48 @@ public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> meth                 }                  pw.println(""import java.util.Objects;"");+                pw.println(""import "" + FQN_DEEP_CLONER + "";"");                 pw.println(""// DO NOT CHANGE THIS CLASS, IT IS GENERATED AUTOMATICALLY BY "" + GenerateEntityImplementationsProcessor.class.getSimpleName());                 pw.println(""public class "" + mapSimpleClassName + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");-//                pw.println(""    private final EnumMap<Field, Object> values = new EnumMap<>(Field.class);"");-//                pw.println(""    protected Object get(Field field) { return values.get(field); }"");-//                pw.println(""    protected Object set(Field field, Object p0) { return values.put(field, p0); }"");++                // Constructors+                allMembers.stream()+                  .filter(ExecutableElement.class::isInstance)+                  .map(ExecutableElement.class::cast)+                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)+                  .forEach((ExecutableElement ee) -> {+                      if (hasDeepClone || ! needsDeepClone) {+                          pw.println(""    ""+                            + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))+                            + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""+                          );+                      } else if (needsDeepClone) {+                          pw.println(""    /**"");+                          pw.println(""     * @deprecated This constructor uses a {@link DeepCloner#DUMB_CLONER} that does not clone anything. Use {@link #"" + mapSimpleClassName + ""(DeepCloner)} variant instead"");","Is this message correct? `DUMB_CLONER` seems to contain all generated cloners so it should be able to clone for example `ProtocolMapperEntity` if it is provided with its instance.Also, we create `ClientEntities` using this constructor in `MapClientProvider`, what would be the replacement for this deprecated constructor?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8534,728981075,2021-10-14T13:26:21Z,testsuite/integration-arquillian/tests/other/webauthn/src/test/java/org/keycloak/testsuite/webauthn/AbstractWebAuthnVirtualTest.java,"@@ -0,0 +1,79 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.webauthn;++import org.junit.After;+import org.junit.Before;+import org.keycloak.common.Profile;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;+import org.keycloak.testsuite.webauthn.authenticators.DefaultVirtualAuthOptions;+import org.keycloak.testsuite.webauthn.authenticators.VirtualAuthenticatorManager;+import org.openqa.selenium.WebDriver;+import org.openqa.selenium.virtualauthenticator.HasVirtualAuthenticator;+import org.openqa.selenium.virtualauthenticator.VirtualAuthenticatorOptions;++import static org.hamcrest.CoreMatchers.instanceOf;+import static org.junit.Assume.assumeThat;++/**+ * Abstract class for WebAuthn tests which use Virtual Authenticators+ *+ * @author <a href=""mailto:mabartos@redhat.com"">Martin Bartos</a>+ */+@EnableFeature(value = Profile.Feature.WEB_AUTHN, skipRestart = true, onlyForProduct = true)+public abstract class AbstractWebAuthnVirtualTest extends AbstractTestRealmKeycloakTest implements UseVirtualAuthenticators {++    private VirtualAuthenticatorManager virtualAuthenticatorsManager;++    @Before+    @Override+    public void setUpVirtualAuthenticator() {+        assumeThat(""Driver must support Virtual Authenticators"", driver, instanceOf(HasVirtualAuthenticator.class));","Question: Is it needed to have ""assume"" here? I wonder that if someone wants to run the tests in the WebAuthn module, he expects them to work and he expects that WebAuthn should work? I wonder that having ""Assume"" can mean some false positives and hide some potential issues? (For example WebAuthn tests will be marked in the pipeline as SUCCESS even if no tests would be really executed).I see that for example admin-console tests in the ""other/console"" don't have any assume as it is expected that they are executed with the browser, which would support admin-console, so maybe same practice can be used here as well?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8564,728984031,2021-10-14T13:29:28Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -325,16 +416,16 @@ public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> meth                 pw.println(""        return String.format(\""%s@%08x\"", "" + (hasId ? ""getId()"" : ""\"""" + mapSimpleClassName + ""\"""" ) + "", System.identityHashCode(this));"");                 pw.println(""    }""); -                // Constructors-                allMembers.stream()-                  .filter(ExecutableElement.class::isInstance)-                  .map(ExecutableElement.class::cast)-                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)-                  .forEach((ExecutableElement ee) -> pw.println(""    ""-                  + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                  + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""));+                // deepClone+                if (! hasDeepClone && needsDeepClone) {+                    pw.println(""    private final DeepCloner cloner;"");","It took me some time to understand the role of this `cloner` here. It seems that this is here mostly for usage within CHM storage, is it correct? It is not used for the entity created in `MapClientProvider#addClient`, is it?One comment that should not be addressed in this PR, but after these changes, I am more inclined to the idea we discussed earlier to create this `*Impl` implementation only when CHM is used and use some other `MapClientEntity` implementation in `MapClientProvider` for creating new entities. This way we can get rid of the problem with the cleaning updated flag and also the unused `cloner`. Also, I think it would be much easier to understand. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8534,728989518,2021-10-14T13:35:11Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java,"@@ -252,7 +249,7 @@ public void otpTest() {         testRemoveCredential(otp1);     } -    @Test+   /* @Test","Is this commented on purpose? I suppose it will be better to remove this as long as it is replaced by other test? However it seems that there is not yet test for WebAuthn together with new account console in this PR, which is probably something, which we should have? Would it be a follow-up PR or do you plan to add it to this PR?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8564,729049658,2021-10-14T14:35:50Z,model/map/src/main/java/org/keycloak/models/map/common/DeepCloner.java,"@@ -0,0 +1,387 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common;++import java.lang.annotation.ElementType;+import java.lang.annotation.Retention;+import java.lang.annotation.RetentionPolicy;+import java.lang.annotation.Target;+import java.util.Arrays;+import java.util.HashMap;+import java.util.LinkedList;+import java.util.Map;+import java.util.Stack;+import java.util.function.BiFunction;+import java.util.function.Consumer;+import java.util.function.Function;+import java.util.function.Supplier;+import org.jboss.logging.Logger;++/**+ * Helper class for deep cloning and fine-grained instantiation per interface and deep copying their properties.+ * <p>+ * This class is intended to be used by individual map storage implementations for copying+ * over entities into their native implementations.+ * <p>+ * For example, a {@code MapClientEntity} interface could be implemented by {@code MapClientEntityImpl}+ * (used by a file-based storage in this example) and an {@code HotRodClientEntityImpl} (for Infinispan).+ * Say that the Infinispan is stacked on top of the file-based storage to provide caching layer.+ * Upon first read, a {@code MapClientEntityImpl} could be obtained from file-based storage and passed+ * to Infinispan layer for caching. Infinispan, regardless of the actual implementation, need to store+ * the {@code MapClientEntity} data in a form that can be processed and sent over the wire in Infinispan+ * (say in an {@code InfinispanClientEntityImpl}). To achieve this, the Infinispan store has to clone+ * the file entity values from the {@code MapClientEntityImpl} to {@code InfinispanClientEntityImpl},+ * i.e. it performs deep cloning, using this helper class.+ * <p>+ * <i>Broader context:</i>+ * In tree store, map storages are agnostic to their neighbours. Therefore each implementation can be+ * provided with a record (a {@code MapClientEntity} instance in the example above) originating from+ * any other implementation. For a map storage to process the record (beyond read-only mode),+ * it needs to be able to clone it into its own entity. Each of the storages thus can benefit from+ * the {@code DeepCloner} capabilities.+ *+ * @author hmlnarik+ */+public class DeepCloner {++    /**+     * Marker for interfaces that could be requested for instantiation and cloning.+     */+    @Retention(RetentionPolicy.RUNTIME)+    @Target(ElementType.TYPE)+    public @interface Root {}++    @FunctionalInterface+    public interface Cloner<V> {+        V clone(V original, V target);+    }++    public static final DeepCloner DUMB_CLONER = new Builder().build();++    /**+     * Builder for the {@code DeepCloner} helper class.+     */+    public static class Builder {+        private final Map<Class<?>, Supplier<?>> parameterlessConstructors = new HashMap<>();+        private final Map<Class<?>, Function<DeepCloner, ?>> constructors = new HashMap<>();+        private final Map<Class<?>, Cloner> clonersWithId = new HashMap<>(org.keycloak.models.map.common.AutogeneratedCloners.CLONERS_WITH_ID);+        private final Map<Class<?>, Cloner> clonersWithoutId = new HashMap<>(org.keycloak.models.map.common.AutogeneratedCloners.CLONERS_WITHOUT_ID);+        private Cloner<?> genericCloner = (from, to) -> { throw new IllegalStateException(""Cloner not found for class "" + (from == null ? ""<null>"" : from.getClass())); };++        /**+         * Returns a {@link DeepCloner} initialized with the respective constructors and cloners.+         * @return+         */+        public DeepCloner build() {+            return new DeepCloner(parameterlessConstructors, constructors, clonersWithId, clonersWithoutId, genericCloner);+        }++        private <V> void forThisClassAndAllMarkedParentsAndInterfaces(Class<V> rootClazz, Consumer<Class<?>> action) {+            action.accept(rootClazz);++            Stack<Class<?>> c = new Stack<>();+            c.push(rootClazz);+            while (! c.isEmpty()) {+                Class<?> cl = c.pop();+                if (cl == null) {+                    continue;+                }++                c.push(cl.getSuperclass());+                for (Class<?> iface : cl.getInterfaces()) {+                    c.push(iface);+                }++                if (cl.getAnnotation(Root.class) != null) {+                    action.accept(cl);+                }+            }+        }++        /**+         * Adds a method, often a constructor, that instantiates a record of type {@code V}.+         * +         * @param <V> Class or interface that would be instantiated by the given methods+         * @param clazz Class or interface that would be instantiated by the given methods+         * @param constructorNoParameters Parameterless function that creates a new instance of class {@code V}.+         *          If {@code null}, parameterless constructor is not available.+         * @return This builder.+         */+        public <V> Builder constructor(Class<V> clazz, Supplier<? extends V> constructorNoParameters) {+            if (constructorNoParameters != null) {+                forThisClassAndAllMarkedParentsAndInterfaces(clazz, cl -> this.parameterlessConstructors.put(cl, constructorNoParameters));+            }+            return this;+        }++        /**+         * Adds a method, often a constructor, that instantiates a record of type {@code V}.+         *+         * @param <V> Class or interface that would be instantiated by the given methods+         * @param clazz Class or interface that would be instantiated by the given methods+         * @param constructor Function that creates a new instance of class {@code V}.+         *          If {@code null}, such a single-parameter constructor is not available.+         * @return This builder.+         */+        public <V> Builder constructorDC(Class<V> clazz, Function<DeepCloner, ? extends V> constructor) {+            if (constructor != null) {+                forThisClassAndAllMarkedParentsAndInterfaces(clazz, cl -> this.constructors.put(cl, constructor));+            }+            return this;+        }++        /**+         * Adds a method that copies (as in a deep copy) an object properties from one object to another+         *+         * @param <V> Class or interface whose instance would be copied over to another instance by the given cloner+         * @param clazz Class or interface whose instance would be copied over to another instance by the given cloner+         * @param cloner A method for cloning with the following signature: {@code V deepClone(V from, V to)} which+         *          copies properties of an object {@code from} onto the object {@code to}. This+         *          function usually returns {@code to}+         * @return This builder.+         */+        public <V> Builder cloner(Class<? extends V> clazz, Cloner cloner) {",Do we have some use case for overriding/adding cloners?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8564,729098021,2021-10-14T15:26:17Z,model/map/src/main/java/org/keycloak/models/map/common/DeepCloner.java,"@@ -0,0 +1,387 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common;++import java.lang.annotation.ElementType;+import java.lang.annotation.Retention;+import java.lang.annotation.RetentionPolicy;+import java.lang.annotation.Target;+import java.util.Arrays;+import java.util.HashMap;+import java.util.LinkedList;+import java.util.Map;+import java.util.Stack;+import java.util.function.BiFunction;+import java.util.function.Consumer;+import java.util.function.Function;+import java.util.function.Supplier;+import org.jboss.logging.Logger;++/**+ * Helper class for deep cloning and fine-grained instantiation per interface and deep copying their properties.+ * <p>+ * This class is intended to be used by individual map storage implementations for copying+ * over entities into their native implementations.+ * <p>+ * For example, a {@code MapClientEntity} interface could be implemented by {@code MapClientEntityImpl}+ * (used by a file-based storage in this example) and an {@code HotRodClientEntityImpl} (for Infinispan).+ * Say that the Infinispan is stacked on top of the file-based storage to provide caching layer.+ * Upon first read, a {@code MapClientEntityImpl} could be obtained from file-based storage and passed+ * to Infinispan layer for caching. Infinispan, regardless of the actual implementation, need to store+ * the {@code MapClientEntity} data in a form that can be processed and sent over the wire in Infinispan+ * (say in an {@code InfinispanClientEntityImpl}). To achieve this, the Infinispan store has to clone+ * the file entity values from the {@code MapClientEntityImpl} to {@code InfinispanClientEntityImpl},+ * i.e. it performs deep cloning, using this helper class.+ * <p>+ * <i>Broader context:</i>+ * In tree store, map storages are agnostic to their neighbours. Therefore each implementation can be+ * provided with a record (a {@code MapClientEntity} instance in the example above) originating from+ * any other implementation. For a map storage to process the record (beyond read-only mode),+ * it needs to be able to clone it into its own entity. Each of the storages thus can benefit from+ * the {@code DeepCloner} capabilities.+ *+ * @author hmlnarik+ */+public class DeepCloner {++    /**+     * Marker for interfaces that could be requested for instantiation and cloning.+     */+    @Retention(RetentionPolicy.RUNTIME)+    @Target(ElementType.TYPE)+    public @interface Root {}++    @FunctionalInterface+    public interface Cloner<V> {+        V clone(V original, V target);+    }++    public static final DeepCloner DUMB_CLONER = new Builder().build();++    /**+     * Builder for the {@code DeepCloner} helper class.+     */+    public static class Builder {+        private final Map<Class<?>, Supplier<?>> parameterlessConstructors = new HashMap<>();+        private final Map<Class<?>, Function<DeepCloner, ?>> constructors = new HashMap<>();+        private final Map<Class<?>, Cloner> clonersWithId = new HashMap<>(org.keycloak.models.map.common.AutogeneratedCloners.CLONERS_WITH_ID);+        private final Map<Class<?>, Cloner> clonersWithoutId = new HashMap<>(org.keycloak.models.map.common.AutogeneratedCloners.CLONERS_WITHOUT_ID);+        private Cloner<?> genericCloner = (from, to) -> { throw new IllegalStateException(""Cloner not found for class "" + (from == null ? ""<null>"" : from.getClass())); };++        /**+         * Returns a {@link DeepCloner} initialized with the respective constructors and cloners.+         * @return+         */+        public DeepCloner build() {+            return new DeepCloner(parameterlessConstructors, constructors, clonersWithId, clonersWithoutId, genericCloner);+        }++        private <V> void forThisClassAndAllMarkedParentsAndInterfaces(Class<V> rootClazz, Consumer<Class<?>> action) {+            action.accept(rootClazz);++            Stack<Class<?>> c = new Stack<>();+            c.push(rootClazz);+            while (! c.isEmpty()) {+                Class<?> cl = c.pop();+                if (cl == null) {+                    continue;+                }++                c.push(cl.getSuperclass());+                for (Class<?> iface : cl.getInterfaces()) {+                    c.push(iface);+                }++                if (cl.getAnnotation(Root.class) != null) {+                    action.accept(cl);+                }+            }+        }++        /**+         * Adds a method, often a constructor, that instantiates a record of type {@code V}.+         * +         * @param <V> Class or interface that would be instantiated by the given methods+         * @param clazz Class or interface that would be instantiated by the given methods+         * @param constructorNoParameters Parameterless function that creates a new instance of class {@code V}.+         *          If {@code null}, parameterless constructor is not available.+         * @return This builder.+         */+        public <V> Builder constructor(Class<V> clazz, Supplier<? extends V> constructorNoParameters) {+            if (constructorNoParameters != null) {+                forThisClassAndAllMarkedParentsAndInterfaces(clazz, cl -> this.parameterlessConstructors.put(cl, constructorNoParameters));+            }+            return this;+        }++        /**+         * Adds a method, often a constructor, that instantiates a record of type {@code V}.+         *+         * @param <V> Class or interface that would be instantiated by the given methods+         * @param clazz Class or interface that would be instantiated by the given methods+         * @param constructor Function that creates a new instance of class {@code V}.+         *          If {@code null}, such a single-parameter constructor is not available.+         * @return This builder.+         */+        public <V> Builder constructorDC(Class<V> clazz, Function<DeepCloner, ? extends V> constructor) {+            if (constructor != null) {+                forThisClassAndAllMarkedParentsAndInterfaces(clazz, cl -> this.constructors.put(cl, constructor));+            }+            return this;+        }++        /**+         * Adds a method that copies (as in a deep copy) an object properties from one object to another+         *+         * @param <V> Class or interface whose instance would be copied over to another instance by the given cloner+         * @param clazz Class or interface whose instance would be copied over to another instance by the given cloner+         * @param cloner A method for cloning with the following signature: {@code V deepClone(V from, V to)} which+         *          copies properties of an object {@code from} onto the object {@code to}. This+         *          function usually returns {@code to}+         * @return This builder.+         */+        public <V> Builder cloner(Class<? extends V> clazz, Cloner cloner) {+            if (cloner != null) {+                forThisClassAndAllMarkedParentsAndInterfaces(clazz, cl -> this.clonersWithId.put(cl, cloner));+            }+            return this;+        }++        /**+         * Adds a method that copies (as in a deep copy) an object properties from one object to another+         *+         * @param <V> Class or interface whose instance would be copied over to another instance by the given cloner+         * @param clazz Class or interface whose instance would be copied over to another instance by the given cloner+         * @param clonerWithId A method for cloning with the following signature: {@code V deepClone(V from, V to)} which+         *          copies properties of an object {@code from} onto the object {@code to}. This+         *          function usually returns {@code to}+         * @return This builder.+         */+        public <V> Builder cloner(Class<? extends V> clazz, Cloner clonerWithId, Cloner clonerWithoutId) {+            if (clonerWithId != null) {+                forThisClassAndAllMarkedParentsAndInterfaces(clazz, cl -> this.clonersWithId.put(cl, clonerWithId));+            }+            if (clonerWithoutId != null) {+                forThisClassAndAllMarkedParentsAndInterfaces(clazz, cl -> this.clonersWithId.put(cl, clonerWithoutId));+            }+            return this;+        }++        /**+         * Adds a method that copies (as in a deep copy) an object properties to another object for any class+         * that is not covered by a specific cloner set via {@link #cloner(Class, BiFunction)} method.+         * +         * @param <V> Class or interface whose instance would be copied over to another instance by the given cloner+         * @param clazz Class or interface whose instance would be copied over to another instance by the given cloner+         * @param cloner A method for cloning with the following signature: {@code V deepClone(V from, V to)} which+         *          copies properties of an object {@code from} onto the object {@code to}. This+         *          function usually returns {@code to}+         * @return This builder.+         */+        public <V> Builder genericCloner(Cloner<V> genericCloner) {+            this.genericCloner = genericCloner;+            return this;+        }+    }++    private static final Logger LOG = Logger.getLogger(DeepCloner.class);++    private final Map<Class<?>, Supplier<?>> parameterlessConstructors;+    private final Map<Class<?>, Function<DeepCloner, ?>> constructors;+    private final Map<Class<?>, Cloner> clonersWithId;+    private final Map<Class<?>, Cloner> clonersWithoutId;+    private final Cloner<?> genericCloner;++    private DeepCloner(Map<Class<?>, Supplier<?>> parameterlessConstructors,+      Map<Class<?>, Function<DeepCloner, ?>> constructors,+      Map<Class<?>, Cloner> clonersWithId,+      Map<Class<?>, Cloner> clonersWithoutId,+      Cloner<?> genericCloner) {+        this.parameterlessConstructors = parameterlessConstructors;+        this.constructors = constructors;+        this.clonersWithId = clonersWithId;+        this.clonersWithoutId = clonersWithoutId;+        this.genericCloner = genericCloner;+    }++    private <V> V getFromClassRespectingHierarchy(Map<Class<?>, V> map, Class<?> clazz) {+        // fast lookup+        V res = map.get(clazz);+        if (res != null) {+            return res;+        }++        // BFS on implemented supertypes and interfaces. Skip clazz as it has been looked up already+        LinkedList<Class<?>> ll = new LinkedList<>();+        ll.push(clazz.getSuperclass());+        for (Class<?> iface : clazz.getInterfaces()) {+            ll.push(iface);+        }++        while (! ll.isEmpty()) {+            Class<?> cl = ll.pollFirst();+            if (cl == null) {+                continue;+            }++            res = map.get(cl);+            if (res != null) {+                map.put(clazz, res);        // Wire clazz with the result for fast lookup next time+                return res;+            }++            ll.push(cl.getSuperclass());+            ll.addAll(Arrays.asList(cl.getInterfaces()));+        }+        return null;+    }++    /**+     * Creates a new instance of the given class or interface if the parameterless constructor for that type is known.+     * @param <V> Type (class or a {@code @Root} interface) to create a new instance+     * @param clazz Type (class or a {@code @Root} interface) to create a new instance+     * @return A new instance+     * @throws IllegalStateException When the constructor is not known.+     */+    public <V> V newInstance(Class<V> clazz) {+        if (clazz == null) {+            return null;+        }++        V res;+        @SuppressWarnings(""unchecked"")+        Function<DeepCloner, V> c = (Function<DeepCloner, V>) getFromClassRespectingHierarchy(this.constructors, clazz);+        if (c == null) {+            @SuppressWarnings(""unchecked"")+            Supplier<V> s = (Supplier<V>) getFromClassRespectingHierarchy(this.parameterlessConstructors, clazz);+            if (s == null) {+                try {+                    res = clazz.newInstance();+                } catch (InstantiationException | IllegalAccessException ex) {+                    res = null;+                }+            } else {+                res = s.get();+            }+        } else {+            res = c.apply(this);+        }++        if (res == null) {+            throw new IllegalStateException(""Cannot instantiate "" + clazz);+        }++        return res;+    }++    /**+     * Deeply clones properties from the {@code from} instance to the {@code to} instance.+     * @param <V> Type (class or a {@code @Root} interface) to clone the instance+     * @param from Original instance+     * @param to Instance to copy the properties onto+     * @return Instance which has all the properties same as the {@code from}. Preferably, {@code to} is returned.+     *   However {@code from} is returned if the cloner is not known and generic cloner is not available.+     */+    public <V> V deepClone(V from, V to) {+        return deepClone(from, to, this.clonersWithId);+    }++    /**+     * Deeply clones properties from the {@code from} instance to the {@code to} instance excluding the ID field.+     * @param <V> Type (class or a {@code @Root} interface) to clone the instance+     * @param from Original instance+     * @param to Instance to copy the properties onto+     * @return Instance which has all the properties same as the {@code from}. Preferably, {@code to} is returned.+     *   However {@code from} is returned if the cloner is not known and generic cloner is not available.+     */+    public <V> V deepCloneNoId(V from, V to) {+        return deepClone(from, to, this.clonersWithoutId);+    }++    @SuppressWarnings(""unchecked"")+    private <V> V deepClone(V from, V to, Map<Class<?>, Cloner> cloners) {+        Cloner<V> cloner = (Cloner<V>) getFromClassRespectingHierarchy(cloners, from.getClass());+        if (cloner != null) {+            return cloner.clone(from, to);+        }++        if (genericCloner != null) {+            LOG.debugf(""Using generic cloner for %s"", from.getClass());+            final V res = ((Cloner<V>) genericCloner).clone(from, to);++            if (res instanceof UpdatableEntity) {+                ((UpdatableEntity) res).clearUpdatedFlag();+            }++            return res;+        }++        return warnCloneNotSupported(from);+    }++    /**+     * Creates a new instance of the given type and copies its properties from the {@code from} instance+     * @param <V> Type (class or a {@code @Root} interface) to create a new instance and clone properties from+     * @param newId ID of the new object+     * @param from Original instance+     * @return Newly created instance or {@code null} if {@code from} is {@code null}.+     */+    @SuppressWarnings(""unchecked"")+    public <V extends AbstractEntity> V from(String newId, V from) {+        if (from == null) {+            return null;+        }+        final V res = newInstance((Class<V>) from.getClass());+        if (newId != null) {+            res.setId(newId);+        }+        return deepCloneNoId(from, res);+    }++    /**+     * Creates a new instance of the given type and copies its properties including ID from the {@code from} instance+     * @param <V> Type (class or a {@code @Root} interface) to create a new instance and clone properties from+     * @param from Original instance+     * @return Newly created instance or {@code null} if {@code from} is {@code null}.+     */+    public <V extends AbstractEntity> V from(V from) {",Why do we treat `AbstractEntity` differently than other entities? Can we use `cloneWithId` cloners?,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8534,729561908,2021-10-15T06:50:23Z,testsuite/integration-arquillian/tests/other/webauthn/pom.xml,"@@ -0,0 +1,104 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<project xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>integration-arquillian-tests-other</artifactId>+        <version>16.0.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>integration-arquillian-tests-webauthn</artifactId>++    <name>WebAuthn tests</name>++    <properties>+        <selenium.version>4.0.0-rc-3</selenium.version>+        <selenium.server.version>4.0.0-alpha-2</selenium.server.version>+        <arquillian.drone.version>${selenium.version}</arquillian.drone.version>+        <graphene.webdriver.version>2.4.0.Alpha-2</graphene.webdriver.version>+        <htmlunit.driver.version>${selenium.version}</htmlunit.driver.version>+    </properties>++    <repositories>+        <repository>+            <id>github-selenium-bom</id>+            <url>https://keycloak-packages:&#103;hp_tSeU74eZVGTSupVCap28N8TX0M88YJ06kua9@maven.pkg.github.com/mabartos/selenium-bom</url>","At this moment, we don't have any better options. I know it's not very good approach, but this PR is mainly focused on prototyping of WebAuthn testing. As we don't want to wait for GA releases all those components which depend on Selenium 4, the best way, IMHO, was to temporary create packages, which contain necessary changes for providing the support. This approach allows us to work on follow-up tasks and verify the functionality. It's only matter of time, those original packages will be officially released and we can replace our packages one by one without a lot of changes.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/8534,729567376,2021-10-15T07:01:08Z,testsuite/integration-arquillian/tests/other/base-ui/src/test/java/org/keycloak/testsuite/ui/account2/SigningInTest.java,"@@ -252,7 +249,7 @@ public void otpTest() {         testRemoveCredential(otp1);     } -    @Test+   /* @Test","Yes, it's commented on purpose, because I moved some WebAuthn classes to this separate module and the `base-ui` module depends on it for some test cases. I didn't want to solve the issue in this PR, which is quite huge already. However, I created a follow-up tasks for verifying the account and admin console and other tests. More details in general comment.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8564,729700462,2021-10-15T10:18:41Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java,"@@ -46,24 +46,25 @@  */ public class ConcurrentHashMapStorage<K, V extends AbstractEntity & UpdatableEntity, M> implements MapStorage<V, M> { -    private final ConcurrentMap<K, V> store = new ConcurrentHashMap<>();+    protected final ConcurrentMap<K, V> store = new ConcurrentHashMap<>();","To be accessible from the descendants, see e.g. `cloner` usage in `UserSessionConcurrentHashMapStorage`",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8564,729706769,2021-10-15T10:29:19Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -282,23 +351,48 @@ public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> meth                 }                  pw.println(""import java.util.Objects;"");+                pw.println(""import "" + FQN_DEEP_CLONER + "";"");                 pw.println(""// DO NOT CHANGE THIS CLASS, IT IS GENERATED AUTOMATICALLY BY "" + GenerateEntityImplementationsProcessor.class.getSimpleName());                 pw.println(""public class "" + mapSimpleClassName + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");-//                pw.println(""    private final EnumMap<Field, Object> values = new EnumMap<>(Field.class);"");-//                pw.println(""    protected Object get(Field field) { return values.get(field); }"");-//                pw.println(""    protected Object set(Field field, Object p0) { return values.put(field, p0); }"");++                // Constructors+                allMembers.stream()+                  .filter(ExecutableElement.class::isInstance)+                  .map(ExecutableElement.class::cast)+                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)+                  .forEach((ExecutableElement ee) -> {+                      if (hasDeepClone || ! needsDeepClone) {+                          pw.println(""    ""+                            + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))+                            + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""+                          );+                      } else if (needsDeepClone) {+                          pw.println(""    /**"");+                          pw.println(""     * @deprecated This constructor uses a {@link DeepCloner#DUMB_CLONER} that does not clone anything. Use {@link #"" + mapSimpleClassName + ""(DeepCloner)} variant instead"");","> Is this message correct? `DUMP_CLONER` seems to contain all generated cloners so it should be able to clone for example `ProtocolMapperEntity` if it is provided with its instance.Yes, the message is correct. The `DUMB_CLONER` contains cloners but it does not contain any instantiators like e.g. [in CHM](https://github.com/keycloak/keycloak/blob/49f81a11f04c4c2dbe5503caecb235cb68fc56f4/model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorageProviderFactory.java#L104-L105). Hence it may fail to instantiate a new class when using `from` method, especially for non-final non-trivial properties like `MapProtocolMapperEntity` in this PR.> Also, we create `ClientEntities` using this constructor in `MapClientProvider`, what would be the replacement for this deprecated constructor?There is no replacement, the deprecation note is to warn that it is unwise to use it unless all consequences have been understood.In this particular case, the instantiated value is short-lived: When put into transaction, it not that value but it's copy that is [obtained using a proper `DeepCloner`](https://github.com/keycloak/keycloak/pull/8564/files#diff-d2e8fdbf028601d9141a13c58a7aebabfdb6850ab3b82975e9d1e7a78972677cR219-R221).",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8564,729710540,2021-10-15T10:36:19Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -325,16 +416,16 @@ public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> meth                 pw.println(""        return String.format(\""%s@%08x\"", "" + (hasId ? ""getId()"" : ""\"""" + mapSimpleClassName + ""\"""" ) + "", System.identityHashCode(this));"");                 pw.println(""    }""); -                // Constructors-                allMembers.stream()-                  .filter(ExecutableElement.class::isInstance)-                  .map(ExecutableElement.class::cast)-                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)-                  .forEach((ExecutableElement ee) -> pw.println(""    ""-                  + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                  + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""));+                // deepClone+                if (! hasDeepClone && needsDeepClone) {+                    pw.println(""    private final DeepCloner cloner;"");","> It took me some time to understand the role of this `cloner` here. It seems that this is here mostly for usage within CHM storage, is it correct? It is not used for the entity created in `MapClientProvider#addClient`, is it?No, it is used for cloning all complex-typed properties, e.g. `MapProtocolMapperEntity`. So it would be used for the entity created in `MapClientProvider#addClient` if it contained any protocol mappers.> One comment that should not be addressed in this PR, but after these changes, I am more inclined to the idea we discussed earlier to create this `*Impl` implementation only when CHM is used and use some other `MapClientEntity` implementation in `MapClientProvider` for creating new entities. This way we can get rid of the problem with the cleaning updated flag and also the unused `cloner`. Also, I think it would be much easier to understand. WDYT?I agree that this should be done after this PR. There are multiple ways to achieve this behaviour (e.g. via delegates) that might be better, so let's park this for a discussion later.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8564,729716932,2021-10-15T10:48:22Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -325,16 +416,16 @@ public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> meth                 pw.println(""        return String.format(\""%s@%08x\"", "" + (hasId ? ""getId()"" : ""\"""" + mapSimpleClassName + ""\"""" ) + "", System.identityHashCode(this));"");                 pw.println(""    }""); -                // Constructors-                allMembers.stream()-                  .filter(ExecutableElement.class::isInstance)-                  .map(ExecutableElement.class::cast)-                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)-                  .forEach((ExecutableElement ee) -> pw.println(""    ""-                  + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                  + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""));+                // deepClone+                if (! hasDeepClone && needsDeepClone) {+                    pw.println(""    private final DeepCloner cloner;"");","> No, it is used for cloning all complex-typed properties, e.g. MapProtocolMapperEntity. So it would be used for the entity created in MapClientProvider#addClient if it contained any protocol mappers.Well, that is the point, entity in the `addClient` method never contains any `ProtocolMapper` it is added later using `ClientAdapter`, however the adapter always use cloned entity, so the DUMP_CLONER is basically never used.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8564,729848517,2021-10-15T14:01:28Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -325,16 +416,16 @@ public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> meth                 pw.println(""        return String.format(\""%s@%08x\"", "" + (hasId ? ""getId()"" : ""\"""" + mapSimpleClassName + ""\"""" ) + "", System.identityHashCode(this));"");                 pw.println(""    }""); -                // Constructors-                allMembers.stream()-                  .filter(ExecutableElement.class::isInstance)-                  .map(ExecutableElement.class::cast)-                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)-                  .forEach((ExecutableElement ee) -> pw.println(""    ""-                  + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                  + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""));+                // deepClone+                if (! hasDeepClone && needsDeepClone) {+                    pw.println(""    private final DeepCloner cloner;"");","Well, we cannot. But, we are not able to `setProtocolMapper` to entity with `DUMB_CLONER` anyway, it would end up with an exception that it cannot instantiate any Object of class `ProtocolMapperEntity`. To me, it seems that we don't need to have `cloner` in entities created in `Map*Provider` because they will end up cloned later in the chain. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8564,729915381,2021-10-15T15:20:42Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -325,16 +416,16 @@ public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> meth                 pw.println(""        return String.format(\""%s@%08x\"", "" + (hasId ? ""getId()"" : ""\"""" + mapSimpleClassName + ""\"""" ) + "", System.identityHashCode(this));"");                 pw.println(""    }""); -                // Constructors-                allMembers.stream()-                  .filter(ExecutableElement.class::isInstance)-                  .map(ExecutableElement.class::cast)-                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)-                  .forEach((ExecutableElement ee) -> pw.println(""    ""-                  + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                  + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""));+                // deepClone+                if (! hasDeepClone && needsDeepClone) {+                    pw.println(""    private final DeepCloner cloner;"");","You are correct with no need for cloner for provider entities and eventually we might get to the point where the two implementations differ. At this moment, it does not hurt - it _is_ possible to `setProtocolMapper` with `DUMB_CLONER`. Reason is that the new instance creation [falls back to the default constructor if no specialized constructor is found](https://github.com/keycloak/keycloak/blob/2b50d5f14205ee978c999b5836576789bc080cc0/model/map/src/main/java/org/keycloak/models/map/common/DeepCloner.java#L278-L283), and the protocol mapper cloners are autogenerated and [thus are known](https://github.com/keycloak/keycloak/blob/2b50d5f14205ee978c999b5836576789bc080cc0/model/map/src/main/java/org/keycloak/models/map/common/DeepCloner.java#L90-L91) even to the `DUMB_CLONER`. Even the `DUMB_CLONER` is not _that_ dumb..",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8564,730650435,2021-10-18T07:45:26Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -325,16 +416,16 @@ public void generate(TypeElement e, Map<String, HashSet<ExecutableElement>> meth                 pw.println(""        return String.format(\""%s@%08x\"", "" + (hasId ? ""getId()"" : ""\"""" + mapSimpleClassName + ""\"""" ) + "", System.identityHashCode(this));"");                 pw.println(""    }""); -                // Constructors-                allMembers.stream()-                  .filter(ExecutableElement.class::isInstance)-                  .map(ExecutableElement.class::cast)-                  .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)-                  .forEach((ExecutableElement ee) -> pw.println(""    ""-                  + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                  + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""));+                // deepClone+                if (! hasDeepClone && needsDeepClone) {+                    pw.println(""    private final DeepCloner cloner;"");","Ah, I missed the fallback to the default constructor. I thought it would throw an exception. Thanks for the discussion.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8534,731185250,2021-10-18T18:03:31Z,testsuite/integration-arquillian/tests/other/webauthn/pom.xml,"@@ -0,0 +1,104 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<project xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">+    <parent>+        <groupId>org.keycloak.testsuite</groupId>+        <artifactId>integration-arquillian-tests-other</artifactId>+        <version>16.0.0-SNAPSHOT</version>+    </parent>+    <modelVersion>4.0.0</modelVersion>++    <artifactId>integration-arquillian-tests-webauthn</artifactId>++    <name>WebAuthn tests</name>++    <properties>+        <selenium.version>4.0.0-rc-3</selenium.version>+        <selenium.server.version>4.0.0-alpha-2</selenium.server.version>+        <arquillian.drone.version>${selenium.version}</arquillian.drone.version>+        <graphene.webdriver.version>2.4.0.Alpha-2</graphene.webdriver.version>+        <htmlunit.driver.version>${selenium.version}</htmlunit.driver.version>+    </properties>++    <repositories>+        <repository>+            <id>github-selenium-bom</id>+            <url>https://keycloak-packages:&#103;hp_tSeU74eZVGTSupVCap28N8TX0M88YJ06kua9@maven.pkg.github.com/mabartos/selenium-bom</url>",Thanks for clarification Martin. I am fine with this approach as long as it is temporary and it works and does not break any other things (EG. some pipeline related functionality or productization).,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8092,732771495,2021-10-20T13:22:13Z,services/src/main/java/org/keycloak/validation/DefaultClientValidationProvider.java,"@@ -151,6 +167,9 @@ private void validateUrls(ValidationContext<ClientModel> context) {         client.getRedirectUris().stream()                 .map(u -> ResolveRelative.resolveRelativeUri(authServerUrl, authServerUrl, rootUrl, u))                 .forEach(u -> checkUri(FieldMessages.REDIRECT_URIS, u, context, false, true));+        checkUriLogo(FieldMessages.LOGO_URI, client.getAttribute(OIDCConfigAttributes.LOGO_URI), context);",Does make sense to enforce realm settings for external requests using https://github.com/keycloak/keycloak/blob/1b8369c7d5cc6846f97ccf213a957816db5b9e10/common/src/main/java/org/keycloak/common/util/UriUtils.java#L92?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8589,732929438,2021-10-20T16:01:34Z,server-spi/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyEvent.java,"@@ -42,6 +42,7 @@     BACKCHANNEL_TOKEN_REQUEST,     PUSHED_AUTHORIZATION_REQUEST,     DEVICE_AUTHORIZATION_REQUEST,-    DEVICE_TOKEN_REQUEST+    DEVICE_TOKEN_REQUEST,+    ROPC_AUTHORIZATION_REQUEST","My vote is RESOURCE_OWNER_PASSWORD_CREDENTIALS_REQUEST . I know it is long, but ""ROPC"" may not be 100% clear what it means? Also strictly said, it is not ""AUTHORIZATION"" request, but request to TokenEndpoint, so I think it is fine to remove word ""Authorization"" . This can likely apply to all ""ROPC"" occurences for other things in this PR.WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8589,732965028,2021-10-20T16:45:05Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -2666,6 +2668,47 @@ public void testSecureLogoutExecutor() throws Exception {         assertTrue(driver.getPageSource().contains(""Front-channel logout is not allowed for this client""));     } +    @Test+    public void testRejectResourceOwnerCredentialsGrantExecutor() throws Exception {++        String clientId = generateSuffixedName(CLIENT_NAME);+        String clientSecret = ""secret"";++        createClientByAdmin(clientId, (ClientRepresentation clientRep) -> {+            clientRep.setSecret(clientSecret);+            clientRep.setStandardFlowEnabled(Boolean.TRUE);+            clientRep.setDirectAccessGrantsEnabled(Boolean.TRUE);+            clientRep.setPublicClient(Boolean.FALSE);+        });++        // register profiles+        String json = (new ClientProfilesBuilder()).addProfile(+                (new ClientProfileBuilder()).createProfile(PROFILE_NAME, ""Purofairu desu"")+                    .addExecutor(RejectROPCGrantExecutorFactory.PROVIDER_ID,+                        createRejectROPCGrantExecutorConfig(Boolean.TRUE))+                    .toRepresentation()+                ).toString();+        updateProfiles(json);++        // register policies+        json = (new ClientPoliciesBuilder()).addPolicy(+                (new ClientPolicyBuilder()).createPolicy(POLICY_NAME, ""Porisii desu"", Boolean.TRUE)+                    .addCondition(AnyClientConditionFactory.PROVIDER_ID, ","I think there is one issue that this executor can be currently used together just in the policy, which uses ""Any-client-condition"" . The reason is that all other conditions (EG. ClientAccessTypeCondition, ClientRolesCondition, ClientScopesCondition etc) are not aware of ROPC_AUTHORIZATION_REQUEST (or RESOURCE_OWNER_PASSWORD_CREDENTIALS_REQUEST if we use new name) type. Similarly there are also executors, where this new type will makes sense to add (EG. SecureSigningAlgorithmForSignedJwtExecutor, Maybe HolderOfKey and possibly others...)As a workaround for this PR, it can be just this type added to various conditions and executors IMO.But from the longer term, it will be nice to improve this in client policies in general as IMO as I think it is more general issue.I think it will be nice if ClientPolicyContext interface is more rich and have some methods like for example:- `boolean isTokenRequest();`- `boolean isClientAuthenticationAwareRequest(); // true for all requests, which require client authentication`- `boolean isInitialRequest() // true for all requests, which are supposed to start authentication (EG. AuthorizationRequest, ResourceOwnerPasswordCredentialsRequest, but also DeviceRequest, or BackchannelEndpointRequest etc`- `boolean isClientCRUDRequest() -- true for client create/update requests`In some cases, it will be good if we have also ""sub-interfaces"" . For example we can have `InitialRequestContext` interface, which will have methods like `getParameter(String paramName)` or something like this. This will allow that conditions/executors can retrieve the initial value of some parameter directly from the context without need to so much re-typing.For example ClientScopesCondition is a bit messy code IMO due it needs to be aware of all the various types and needs to retype explicitly all the various types of contexts and retrieve ""scope"" in the context-specific way. This also  means that it contains some CIBA related code (which is not so great as we want the most of the ""core"" code to NOT be aware of ""advanced"" grant functionalities like CIBA). If we do this, then for example ClientScopesCondition will need to do just something like this to retrieve scope parameter:```if (context.isInitialRequest()) {    String scope = ((InitialRequestContext) context).getParameter(OAuth2Constants.SCOPE)    ...```This would result in much better design IMO as we won't need to update all the code of all conditions/executors, as we need now in this PR when new context type is introduced. WDYT? Are you ok if I create new JIRA for this?",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8589,733325970,2021-10-21T05:16:22Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPoliciesTest.java,"@@ -2666,6 +2668,47 @@ public void testSecureLogoutExecutor() throws Exception {         assertTrue(driver.getPageSource().contains(""Front-channel logout is not allowed for this client""));     } +    @Test+    public void testRejectResourceOwnerCredentialsGrantExecutor() throws Exception {++        String clientId = generateSuffixedName(CLIENT_NAME);+        String clientSecret = ""secret"";++        createClientByAdmin(clientId, (ClientRepresentation clientRep) -> {+            clientRep.setSecret(clientSecret);+            clientRep.setStandardFlowEnabled(Boolean.TRUE);+            clientRep.setDirectAccessGrantsEnabled(Boolean.TRUE);+            clientRep.setPublicClient(Boolean.FALSE);+        });++        // register profiles+        String json = (new ClientProfilesBuilder()).addProfile(+                (new ClientProfileBuilder()).createProfile(PROFILE_NAME, ""Purofairu desu"")+                    .addExecutor(RejectROPCGrantExecutorFactory.PROVIDER_ID,+                        createRejectROPCGrantExecutorConfig(Boolean.TRUE))+                    .toRepresentation()+                ).toString();+        updateProfiles(json);++        // register policies+        json = (new ClientPoliciesBuilder()).addPolicy(+                (new ClientPolicyBuilder()).createPolicy(POLICY_NAME, ""Porisii desu"", Boolean.TRUE)+                    .addCondition(AnyClientConditionFactory.PROVIDER_ID, ","@mposolda I totally agree with you. It is a nice idea to use `ClientPolicyContext`'s characteristics instead of referring to `ClientPolicyEvent` directly to avoid modifying existing conditions/executors whenever introducing new `ClientPolicyEvent`.As you said, could you create the new JIRA ticket for treating this matter? Also I would like to work on this new JIRA ticket and revise 'RejectResourceOwnerPasswordCredentialsGrantExecutor'. WDYT? ",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/8092,733623006,2021-10-21T12:27:14Z,services/src/main/java/org/keycloak/validation/DefaultClientValidationProvider.java,"@@ -151,6 +167,9 @@ private void validateUrls(ValidationContext<ClientModel> context) {         client.getRedirectUris().stream()                 .map(u -> ResolveRelative.resolveRelativeUri(authServerUrl, authServerUrl, rootUrl, u))                 .forEach(u -> checkUri(FieldMessages.REDIRECT_URIS, u, context, false, true));+        checkUriLogo(FieldMessages.LOGO_URI, client.getAttribute(OIDCConfigAttributes.LOGO_URI), context);","I did not know this method.However, some SAML clients have value starting with data:image/png ( accepted according to SAML specifications).It is the same value that have length over 4000 characters.",
55974447,cgeorgilakis,https://api.github.com/repos/keycloak/keycloak/pulls/8312,734351450,2021-10-22T08:45:21Z,services/src/main/java/org/keycloak/broker/saml/mappers/AttributeToRoleMapper.java,"@@ -138,4 +144,38 @@ public String getHelpText() {         return ""If an attribute exists, grant the user the specified realm or client role."";     } +    // SamlMetadataDescriptorUpdater interface+    @Override+    public void updateMetadata(IdentityProviderMapperModel mapperModel, EntityDescriptorType entityDescriptor) {+        String attributeName = mapperModel.getConfig().get(UserAttributeMapper.ATTRIBUTE_NAME);+        String attributeFriendlyName = mapperModel.getConfig().get(AttributeToRoleMapper.ATTRIBUTE_FRIENDLY_NAME);++        RequestedAttributeType requestedAttribute = new RequestedAttributeType(mapperModel.getConfig().get(AttributeToRoleMapper.ATTRIBUTE_NAME));+        requestedAttribute.setIsRequired(null);+        requestedAttribute.setNameFormat(ATTRIBUTE_FORMAT_BASIC.get());++        if (attributeFriendlyName != null && attributeFriendlyName.length() > 0)+            requestedAttribute.setFriendlyName(attributeFriendlyName);++        // Add the requestedAttribute item to any AttributeConsumingServices+        for (EntityDescriptorType.EDTChoiceType choiceType: entityDescriptor.getChoiceType()) {+            List<EntityDescriptorType.EDTDescriptorChoiceType> descriptors = choiceType.getDescriptors();++            if (descriptors != null) {+                for (EntityDescriptorType.EDTDescriptorChoiceType descriptor: descriptors) {+                    if (descriptor.getSpDescriptor() != null && descriptor.getSpDescriptor().getAttributeConsumingService() != null) {","This and previous if is useless and I propose to be removed. If you see code in export method of SAMLIdentityProvider, AttributeConsumingService have been created before running this code. AttributeConsumingService based on SAML specification requires at least one RequestedAttribute.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/7897,735557373,2021-10-25T12:39:19Z,docs/README_Step up mechanism.md,"@@ -0,0 +1,56 @@+# Step up Authentiation","I appreciate this document here. However the docs is probably not needed here and should be removed from this PR IMO.Instead of that, it will be good to send PR to the official Keycloak documentation where this feature will be properly documented https://github.com/keycloak/keycloak-documentation/ . . I hope that most of the text in this file can be re-used for the docs PR.Optionally another PR can be sent to keycloak-community repository to update this document https://github.com/keycloak/keycloak-community/blob/master/design/multi-factor-admin-and-step-up.md#design-proposal-for-keycloak-847 with some small notes of what was implemented from the step-up requirements, but that can be done as a follow-up optionally.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8648,736570419,2021-10-26T13:56:05Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/command/Build.java,"@@ -24,15 +24,24 @@  import io.quarkus.bootstrap.runner.QuarkusEntryPoint; import io.quarkus.bootstrap.runner.RunnerClassLoader;-import picocli.CommandLine; -@CommandLine.Command(name = Build.NAME,-        header = ""Creates a new and optimized server image based on the configuration options passed to this command."",+import picocli.CommandLine.Command;++@Command(name = Build.NAME,+        header = ""Creates a new and optimized server image based on the configuration options passed to this command.%n"",         description = {-            ""Creates a new and optimized server image based on the configuration options passed to this command. Once created, configuration will be read from the server image and the server can be started without passing the same options again."",+            ""%n Creates a new and optimized server image based on the configuration options passed to this command.%n"" ++            ""Once created, configuration will be read from the server image and the server can be started without passing the same options again."",             """",-            ""Some configuration options require this command to be executed in order to actually change a configuration. For instance, the database vendor.""+            ""Some configuration options require this command to be executed in order to actually change a configuration. For instance:%n"" ++            ""- Change database vendor%n"" ++            ""- enable/disable a feature%n"" ++            ""- change the used SPI Provider ([--spi-name-in-dashcase-]-provider=...)%n""         },+        footerHeading = ""%nUse \""${ROOT-COMMAND-NAME:-the root command of this command} ""+Build.NAME+"" <parameters>\"" to create an optimized image.%n"" +","I think we can do a bit more here, let me know what you think:```Creates a new and optimized server image based on the configuration options passed to this command. Once created, the configuration will be persisted and read during startup without having to pass them over again.Some configuration options can only be set when running this command.Configure a database:      $ kc.sh buid --db=postgres --db-url=jdbc:postgresql://mydb/mydatabase --db-username=<USER> --db-password=<PASSWORD>Enable a feature:      $ kc.sh build --features-token_exchange=enabledOr alternatively, enable all tech preview features:      $ kc.sh build --features=previewEnable metrics:      $ kc.sh build --metrics-enabled=truePlease see the help for more details about the subcommands and options available from this command.```What about the `--auto-build` option, does it make sense to mention here?It would be nice to also mention:* Briefly talk about deploying providers to providers dir and how to run the command once the JAR is deployed",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8648,736581121,2021-10-26T14:06:15Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/command/Start.java,"@@ -17,10 +17,16 @@  package org.keycloak.quarkus.runtime.cli.command; -import picocli.CommandLine;+import picocli.CommandLine.Command; -@CommandLine.Command(name = Start.NAME,+@Command(name = Start.NAME,         description = ""Start the server."",+        footerHeading = ""%nUse \""${ROOT-COMMAND-NAME:-the root command of this command} ""+Start.NAME+""\"" to start the server. "" +","I think the same pattern can be used here as suggested to other commands.We could also suggest an example command with the basic settings to run the server in production. Or the steps to run in production.What about the `--auto-build` option, does it make sense to mention here?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8660,738639635,2021-10-28T18:15:47Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/storage/infinispan/CacheInitializer.java,"@@ -0,0 +1,65 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.storage.infinispan;++import javax.enterprise.context.ApplicationScoped;+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;+import org.infinispan.configuration.parsing.ParserRegistry;+import org.infinispan.jboss.marshalling.core.JBossUserMarshaller;+import org.infinispan.manager.DefaultCacheManager;+import org.jboss.logging.Logger;+import org.keycloak.Config;++public class CacheInitializer {++    private static final Logger log = Logger.getLogger(QuarkusCacheManagerProvider.class);",wrong .class here(?),
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8660,738643703,2021-10-28T18:21:57Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/storage/infinispan/QuarkusCacheManagerProvider.java,"@@ -31,75 +31,15 @@ import org.keycloak.Config; import org.keycloak.quarkus.runtime.Environment; ",pls remove unused imports here.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8660,738644281,2021-10-28T18:22:40Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/storage/infinispan/CacheInitializer.java,"@@ -0,0 +1,65 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.storage.infinispan;++import javax.enterprise.context.ApplicationScoped;",unused import,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8660,738645143,2021-10-28T18:24:00Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/KeycloakProcessor.java,"@@ -27,14 +28,23 @@ import static org.keycloak.quarkus.runtime.Environment.CLI_ARGS; import static org.keycloak.quarkus.runtime.Environment.getProviderFiles; +import javax.enterprise.context.ApplicationScoped; import javax.persistence.Entity; import javax.persistence.spi.PersistenceUnitTransactionType;+import java.io.BufferedReader;+import java.io.ByteArrayInputStream;",unused imports here.,
34234041,CorneliaLahnsteiner,https://api.github.com/repos/keycloak/keycloak/pulls/7897,739314683,2021-10-29T15:07:13Z,docs/README_Step up mechanism.md,"@@ -0,0 +1,56 @@+# Step up Authentiation++The Step up mechanism is based on the design proposal [1].++What has been implemented (for OIDC):+* Text mapping in the client configuration to do the text to value translation+* Putting the achieved level of authentication at the 'acr' claim in both the access token and the id token (either as an integer or an textual representation)+* Condition Execution to execute the flow (Condition 1, Condition 2, ...)+* Set Loa on Success Execution (with the option to store the achieved LoA into the user session or not)+* Extension to the Default Authentication Flow in order to determine if a certain level of authentication is reached++## Auth Request for a Specific Level of Authentication+To specify a requested level of authentication (LoA) the claims parameter is used in the auth request.++Example Request:++https://{DOMAIN}/auth/realms/{REALMNAME}/protocol/openid-connect/auth?client_id={CLIENT-ID}&redirect_uri={REDIRECT-URI}&scope=openid&response_type=code&response_mode=query&nonce=exg16fxdjcu&claims=%7B%22id_token%22%3A%7B%22acr%22%3A%7B%22essential%22%3Atrue%2C%22values%22%3A%5B%22gold%22%5D%7D%7D%7D++The claims parameter is specified in a JSON representation:+claims= {+            ""id_token"": {+                ""acr"": {+                    ""essential"": true,+                    ""values"": [""silver"", ""gold""]+                }+            }+        }++Please refer to the openid-spec for further details.++## Flow Configuration++![Flow configuration](Example_Auth_Flow_Step_up.PNG)++## Configure the Text Mapping at the Client+It is possible to map the acr_values to a textual representation at the client.++If configured, both the access token and the id token will include the acr in a textual representation.++![Client configuration](Client_Config_Step_up.PNG)+++## Open Points++### No ACR Value Specified in the Request+The design proposal describes that if no LoA is configured at the client, and in the auth request no LoA (acr_value) is specified, the value -1 shall be used. -1 is a constant that indicates that a full authentication should be performed. +This means that Keycloak will always do a full authentication, even if the user is already authenticated to a certain level of authentication, e.g.","@pedroigor @mposolda We are still not pretty sure, which strategy we should follow.The official OIDC spec says [2]:'_Authentication using a long-lived browser cookie, for instance, is one example where the use of ""level 0"" is appropriate. Authentications with level 0 SHOULD NOT be used to authorize access to any resource of any monetary value_.'If we change the behavior in our code meaning a re-authentication via cookie will always result in a LoA = 0, than we will not fulfill the first use-case of the design proposal [1] anymore:""_A user has a session in Keycloak for a client A after having logged in with username and password. However, when connecting to a client B which demands greater security, the user is asked for a second authentication factor before proceeding._* ""Reason: The user is always prompted to provide their username and password and second factor when connecting to Client B, rather than just providing their second factor.Hence, our suggestion is to leave the behavior as it is implemented now. The admin should decide which LoAs are not critical to store in the user session (`SetLoAOnSuccess` Execution) and LoAs that access a resource of any monetary value should be configured not to be stored in the user session.Or what is your opinion on this?[1] https://github.com/keycloak/keycloak-community/blob/master/design/multi-factor-admin-and-step-up.md#design-proposal-for-keycloak-847[2] https://openid.net/specs/openid-connect-core-1_0.html",
34234041,CorneliaLahnsteiner,https://api.github.com/repos/keycloak/keycloak/pulls/7897,739321101,2021-10-29T15:15:32Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/SetLoaAuthenticatorFactory.java,"@@ -0,0 +1,93 @@+package org.keycloak.authentication.authenticators.browser;++import java.util.List;+import org.keycloak.Config;+import org.keycloak.authentication.Authenticator;+import org.keycloak.authentication.AuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.provider.ProviderConfigurationBuilder;++public class SetLoaAuthenticatorFactory implements AuthenticatorFactory {++  public static final String PROVIDER_ID = ""set-level-of-authentication"";+  private static final SetLoaAuthenticator SINGLETON = new SetLoaAuthenticator();+  private static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = new AuthenticationExecutionModel.Requirement[]{+      AuthenticationExecutionModel.Requirement.REQUIRED, AuthenticationExecutionModel.Requirement.DISABLED+  };++  private static final List<ProviderConfigProperty> CONFIG = ProviderConfigurationBuilder.create()+      .property()+      .name(SetLoaAuthenticator.LEVEL)+      .label(SetLoaAuthenticator.LEVEL)+      .helpText(SetLoaAuthenticator.LEVEL + "".tooltip"")+      .type(ProviderConfigProperty.STRING_TYPE)+      .add()+      .property()+      .name(SetLoaAuthenticator.STORE_IN_USER_SESSION)","@mposolda But I agree with @pedroigor, getting rid of the `SetLoaAuthenticator` would improve UX a lot. Would it be possible to move the StoreUserSession option to the condition?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8649,740219981,2021-11-01T13:43:00Z,server-spi-private/src/main/java/org/keycloak/userprofile/DefaultUserProfile.java,"@@ -146,9 +147,9 @@ private UserModel updateInternal(UserModel user, boolean removeAttributes, Attri                     }                 }             }-        } catch (ModelException me) {-            // some client code relies on this exception to react to exceptions from the storage-            throw me;+        } catch (ModelException | ReadOnlyException e) {",It should be fine as long as the client code is handling those exceptions.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8665,740840561,2021-11-02T09:03:22Z,model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapCRUDOperations.java,"@@ -0,0 +1,85 @@+package org.keycloak.models.map.storage.chm;++import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.common.UpdatableEntity;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.QueryParameters;++import java.util.Comparator;+import java.util.Map;+import java.util.Objects;+import java.util.concurrent.atomic.AtomicLong;+import java.util.function.Predicate;+import java.util.stream.Stream;++import static org.keycloak.utils.StreamsUtil.paginatedStream;++public interface ConcurrentHashMapCRUDOperations<V extends AbstractEntity & UpdatableEntity, M> {","```suggestionpublic interface ConcurrentHashMapCrudOperations<V extends AbstractEntity & UpdatableEntity, M> {```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8666,742377585,2021-11-03T22:05:51Z,services/src/main/java/org/keycloak/protocol/oidc/grants/device/endpoints/DeviceEndpoint.java,"@@ -219,6 +219,11 @@ public Response verifyUserCode(@QueryParam(""user_code"") String userCode) {                 return createVerificationPage(Messages.OAUTH2_DEVICE_EXPIRED_USER_CODE);             } +            if (deviceCode.isDenied()) {+                event.error(Errors.INVALID_OAUTH2_USER_CODE);+                return createVerificationPage(Messages.OAUTH2_DEVICE_CONSENT_DENIED);","At this stage, we should probably give a user code error, similar to what you did to the pending state.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8693,742634360,2021-11-04T08:48:02Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Picocli.java,"@@ -323,37 +322,77 @@ private static void addOption(CommandSpec spec, String command, boolean includeB         List<PropertyMapper> mappers = new ArrayList<>(PropertyMappers.getRuntimeMappers());          if (includeBuildTime) {-            mappers.addAll(PropertyMappers.getBuiltTimeMappers());+            mappers.addAll(PropertyMappers.getBuildTimeMappers());         } -        for (PropertyMapper mapper : mappers) {-            String name = ARG_PREFIX + PropertyMappers.toCLIFormat(mapper.getFrom()).substring(3);-            String description = mapper.getDescription();--            if (description == null || commandSpec.optionsMap().containsKey(name)-                || name.endsWith(ARG_PART_SEPARATOR)) {-                continue;+        if (includeBuildTime) {","@pedroigor First of all thanks, forgotten these ones as they're not fetched by kc/quarkus config! :) Just a small change request: The same if condition in line 324 and line 328 could be merged. Also, for readability reasons I think it's better to create a method for the generation of the Features. Like -> ```private static void addOption(CommandSpec spec, String command, boolean includeBuildTime) {        CommandSpec commandSpec = spec.subcommands().get(command).getCommandSpec();        List<PropertyMapper> mappers = new ArrayList<>(PropertyMappers.getRuntimeMappers());        if (includeBuildTime) {            mappers.addAll(PropertyMappers.getBuildTimeMappers());            addFeatureOptionsInArgGroup(commandSpec);        }        addMappedOptionsToArgGroups(commandSpec, mappers);    }    private static void addFeatureOptionsInArgGroup(CommandSpec commandSpec) {     // logic from PR stays here    }    ```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8694,743057357,2021-11-04T17:26:49Z,model/map/src/main/java/org/keycloak/models/map/loginFailure/MapUserLoginFailureProvider.java,"@@ -54,9 +54,9 @@ public MapUserLoginFailureProvider(KeycloakSession session, MapStorage<MapUserLo      @Override     public UserLoginFailureModel getUserLoginFailure(RealmModel realm, String userId) {-        ModelCriteriaBuilder<UserLoginFailureModel> mcb = criteria();-        mcb = mcb.compare(UserLoginFailureModel.SearchableFields.REALM_ID, ModelCriteriaBuilder.Operator.EQ, realm.getId())-                .compare(UserLoginFailureModel.SearchableFields.USER_ID, ModelCriteriaBuilder.Operator.EQ, userId);+        DefaultModelCriteria<UserLoginFailureModel> mcb = criteria();+        mcb = mcb.compare(UserLoginFailureModel.SearchableFields.REALM_ID, DefaultModelCriteria.Operator.EQ, realm.getId())",Just for this reason we should keep `ModelCriteriaBuilder.Operator`. The `Operator` is the same (semantically) as used in other `ModelCriteriaBuilder` implementations so it makes sense to keep them the same instance,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8694,743206845,2021-11-04T21:12:15Z,model/map/src/main/java/org/keycloak/models/map/storage/criteria/ModelCriteriaNode.java,"@@ -35,45 +36,45 @@      public static enum ExtOperator {         AND {-            @Override public <M, C extends ModelCriteriaBuilder<M>> C apply(C mcb, ModelCriteriaNode<M> node) {+            @Override public <M, C extends ModelCriteriaBuilder<M, C>> C apply(C mcb, ModelCriteriaNode<M> node) {                 if (node.getChildren().isEmpty()) {                     return null;                 }-                final ModelCriteriaBuilder[] operands = node.getChildren().stream()+                final C[] operands = node.getChildren().stream()                   .map(n -> n.flashToModelCriteriaBuilder(mcb))                   .filter(Objects::nonNull)-                  .toArray(ModelCriteriaBuilder[]::new);-                return operands.length == 0 ? null : (C) mcb.and(operands);+                  .toArray(n -> (C[]) Array.newInstance(mcb.getClass(), n));+                return operands.length == 0 ? null : mcb.and(operands);","During rebase I've debugged the code and at this point operands contains two identical instances of the same MCB, I was wondering if it is expected. It seems like bug to me, but maybe there is something wrong in my end. It ends up calling ModelCriteriaBuilder.and method where there are two identical builders. I'll perform some additional tests to investigate it further. In the meantime I wanted to let you know about it. Thank you",
3496559,alechenninger,https://api.github.com/repos/keycloak/keycloak/pulls/8666,744348274,2021-11-08T01:04:11Z,services/src/main/java/org/keycloak/protocol/oidc/grants/device/endpoints/DeviceEndpoint.java,"@@ -286,12 +294,6 @@ private Response createVerificationPage(String errorMessage) {     }      private Response processVerification(OAuth2DeviceCodeModel deviceCode, String userCode) {-        long expiresIn = deviceCode.getExpiration() - Time.currentTime();-        if (expiresIn < 0) {-            event.error(Errors.EXPIRED_OAUTH2_USER_CODE);-            return createVerificationPage(Messages.OAUTH2_DEVICE_INVALID_USER_CODE);-        }-",This was redundant with the `isExpired` check already happening in `verifyUserCode`. This condition would never evaluate to true. It's also less readable than the `isExpired()` method on `OAuth2DeviceCodeModel` which has the exact same logic.An interesting aspect here is that it was duplicated and also subtly differentit used a different event code _and_ verification page message than the logic in `verifyUserCode` for this same condition. This diff keeps the same behavior as before but it's not exactly clear which message was intended.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8710,744655224,2021-11-08T11:57:05Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/themes/QuarkusFolderThemeProviderFactory.java,"@@ -0,0 +1,50 @@+package org.keycloak.quarkus.runtime.themes;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.quarkus.runtime.Environment;+import org.keycloak.theme.FolderThemeProvider;+import org.keycloak.theme.ThemeProvider;+import org.keycloak.theme.ThemeProviderFactory;++import java.io.File;++public class QuarkusFolderThemeProviderFactory implements ThemeProviderFactory {++    private FolderThemeProvider themeProvider;++    @Override+    public ThemeProvider create(KeycloakSession sessions) {+        return themeProvider;+    }++    @Override+    public void init(Config.Scope config) {+        String d = config.get(""dir"");+        File rootDir = null;+        if (d != null) {+            rootDir = new File(d);+        } else {+            //assume standard path as fallback+            rootDir = new File(Environment.getDefaultThemeRootDir());+        }+        themeProvider = new FolderThemeProvider(rootDir);",I know this is something we don't do in the original implementation. But in order to avoid mistakes we should probably check if the dir exists and if not throw some exception?,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/8710,744731560,2021-11-08T13:38:48Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/themes/QuarkusFolderThemeProviderFactory.java,"@@ -0,0 +1,50 @@+package org.keycloak.quarkus.runtime.themes;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.quarkus.runtime.Environment;+import org.keycloak.theme.FolderThemeProvider;+import org.keycloak.theme.ThemeProvider;+import org.keycloak.theme.ThemeProviderFactory;++import java.io.File;++public class QuarkusFolderThemeProviderFactory implements ThemeProviderFactory {++    private FolderThemeProvider themeProvider;++    @Override+    public ThemeProvider create(KeycloakSession sessions) {+        return themeProvider;+    }++    @Override+    public void init(Config.Scope config) {+        String d = config.get(""dir"");+        File rootDir = null;+        if (d != null) {+            rootDir = new File(d);+        } else {+            //assume standard path as fallback+            rootDir = new File(Environment.getDefaultThemeRootDir());+        }+        themeProvider = new FolderThemeProvider(rootDir);","I don't think we should throw an exception if the dir doesn't exist, as it's not strictly required unless there's custom themes deployed there.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8710,744738447,2021-11-08T13:47:05Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/themes/QuarkusFolderThemeProviderFactory.java,"@@ -0,0 +1,50 @@+package org.keycloak.quarkus.runtime.themes;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.quarkus.runtime.Environment;+import org.keycloak.theme.FolderThemeProvider;+import org.keycloak.theme.ThemeProvider;+import org.keycloak.theme.ThemeProviderFactory;++import java.io.File;++public class QuarkusFolderThemeProviderFactory implements ThemeProviderFactory {++    private FolderThemeProvider themeProvider;++    @Override+    public ThemeProvider create(KeycloakSession sessions) {+        return themeProvider;+    }++    @Override+    public void init(Config.Scope config) {+        String d = config.get(""dir"");+        File rootDir = null;+        if (d != null) {+            rootDir = new File(d);+        } else {+            //assume standard path as fallback+            rootDir = new File(Environment.getDefaultThemeRootDir());+        }+        themeProvider = new FolderThemeProvider(rootDir);","pushed a new version, only throws an exception when themedir is set up in config but not accessible, OR when default theme dir is not accessible. For the sake of completeness, my work in progress solution was a bit more fallback-y (and thus, a little more verbose) -> ```private File createOrRetrieveThemeRootDir(String rootDirFromConfig) {        File themeRootDir = null;        try {            if (rootDirFromConfig != null) {                themeRootDir = new File(rootDirFromConfig);                //rootdir specified in config does not exist. use default fallback.                if (!themeRootDir.exists()) {                    boolean created = new File(Environment.getDefaultThemeRootDir()).mkdir();                    Logger.getLogger(QuarkusFolderThemeProviderFactory.class)                            .warnf(""Could not get theme root directory '%s' specified in config. "" +                                    (created ? ""Created new default theme root directory at %s"" : ""Using default directory at %s instead.""), rootDirFromConfig, Environment.DEFAULT_THEMES_PATH);                }            } else {                //assume standard path as fallback                themeRootDir = new File(Environment.getDefaultThemeRootDir());                                //someone deleted the /themes folder. re-create it.                if (!themeRootDir.exists()) {                    themeRootDir = new File(Environment.getDefaultThemeRootDir());                    themeRootDir.mkdir();                }            }            //only if that fails, throw runtimeexception.        } catch (SecurityException e) {            throw new RuntimeException(""It was not possible to create theme root directory either from config or from default location."", e);        }        return themeRootDir;    }```and would've tried to create the default dir if it does not exist. @pedroigor @stianst  If you want, I can remove the exceptions and return null and a log warning instead. ",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8710,744845714,2021-11-08T15:39:32Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/themes/QuarkusFolderThemeProviderFactory.java,"@@ -0,0 +1,50 @@+package org.keycloak.quarkus.runtime.themes;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.quarkus.runtime.Environment;+import org.keycloak.theme.FolderThemeProvider;+import org.keycloak.theme.ThemeProvider;+import org.keycloak.theme.ThemeProviderFactory;++import java.io.File;++public class QuarkusFolderThemeProviderFactory implements ThemeProviderFactory {++    private FolderThemeProvider themeProvider;++    @Override+    public ThemeProvider create(KeycloakSession sessions) {+        return themeProvider;+    }++    @Override+    public void init(Config.Scope config) {+        String d = config.get(""dir"");+        File rootDir = null;+        if (d != null) {+            rootDir = new File(d);+        } else {+            //assume standard path as fallback+            rootDir = new File(Environment.getDefaultThemeRootDir());+        }+        themeProvider = new FolderThemeProvider(rootDir);","Added new changes: if config value exists use config, else use default. if file doesnt exist, return null (as we talked about earlier). No Warn/exception included.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8713,744855292,2021-11-08T15:49:19Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Help.java,"@@ -0,0 +1,81 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.cli;++import static picocli.CommandLine.Help.Column.Overflow.SPAN;+import static picocli.CommandLine.Help.Column.Overflow.WRAP;++import java.util.List;",pls remove unused import.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8713,744862579,2021-11-08T15:56:28Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/OptionRenderer.java,"@@ -0,0 +1,86 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.cli;++import static org.keycloak.quarkus.runtime.cli.Picocli.NO_PARAM_LABEL;+import static picocli.CommandLine.Help.Ansi.OFF;++import org.keycloak.utils.StringUtil;++import picocli.CommandLine;+import picocli.CommandLine.Help.Ansi.Text;+import picocli.CommandLine.Help.ColorScheme;+import picocli.CommandLine.Help.IParamLabelRenderer;+import picocli.CommandLine.Model.OptionSpec;++public class OptionRenderer implements CommandLine.Help.IOptionRenderer {++    private static final String OPTION_NAME_SEPARATOR = "", "";+    private static final Text EMPTY_TEXT = OFF.text("""");++    @Override+    public Text[][] render(OptionSpec option, IParamLabelRenderer paramLabelRenderer, ColorScheme scheme) {+        String[] names = option.names();++        if (names.length > 2) {+            throw new CommandLine.PicocliException(""Options should have 2 names at most."");+        }++        Text shortName = names.length > 1 ? scheme.optionText(names[0]) : EMPTY_TEXT;+        Text longName = createLongName(option, scheme);+        Text[][] result = new Text[1][];+        String[] descriptions = option.description();++        // for better formatting, only a single line is expected in the description+        // formatting is done by customizations to the text table+        if (descriptions.length > 1) {","not sure if we should really raise an exception here. On the one hand it leads to fast feedback if you write too much in the description of the option, on the other hand there might be an option needing a long description. but ok for now.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8713,744866778,2021-11-08T16:00:31Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/command/Main.java,"@@ -17,6 +17,10 @@  package org.keycloak.quarkus.runtime.cli.command; +import static org.keycloak.quarkus.runtime.cli.Picocli.NO_PARAM_LABEL;++import org.keycloak.quarkus.runtime.cli.Picocli;",import org.keycloak.quarkus.runtime.cli.Picocli; <- unused.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8713,744867968,2021-11-08T16:01:42Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/command/Start.java,"@@ -17,18 +17,23 @@  package org.keycloak.quarkus.runtime.cli.command; +import static org.keycloak.quarkus.runtime.cli.Picocli.NO_PARAM_LABEL;++import org.keycloak.quarkus.runtime.cli.Picocli;",import org.keycloak.quarkus.runtime.cli.Picocli; <- unused.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8710,744956759,2021-11-08T17:45:34Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/themes/QuarkusFolderThemeProviderFactory.java,"@@ -0,0 +1,50 @@+package org.keycloak.quarkus.runtime.themes;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.quarkus.runtime.Environment;+import org.keycloak.theme.FolderThemeProvider;+import org.keycloak.theme.ThemeProvider;+import org.keycloak.theme.ThemeProviderFactory;++import java.io.File;++public class QuarkusFolderThemeProviderFactory implements ThemeProviderFactory {++    private FolderThemeProvider themeProvider;++    @Override+    public ThemeProvider create(KeycloakSession sessions) {+        return themeProvider;+    }++    @Override+    public void init(Config.Scope config) {+        String d = config.get(""dir"");+        File rootDir = null;+        if (d != null) {+            rootDir = new File(d);+        } else {+            //assume standard path as fallback+            rootDir = new File(Environment.getDefaultThemeRootDir());+        }+        themeProvider = new FolderThemeProvider(rootDir);",@stianst Ideally we should fail fast and give useful messages when the server is building/starting. The idea was to avoid unexpected behavior at runtime due to a bad configuration.It should be fine to keep it behaving as today but perhaps we should be discussing more how to improve this and some other providers.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8665,745443727,2021-11-09T09:41:50Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/HotRodMapStorage.java,"@@ -0,0 +1,178 @@+package org.keycloak.models.map.storage.hotRod;++import org.infinispan.client.hotrod.RemoteCache;+import org.infinispan.client.hotrod.Search;+import org.infinispan.commons.util.CloseableIterator;+import org.infinispan.query.dsl.Query;+import org.infinispan.query.dsl.QueryFactory;+import org.jboss.logging.Logger;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.HotRodEntityDescriptor;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.common.UpdatableEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.ConcurrentHashMapCRUDOperations;+import org.keycloak.models.map.storage.chm.ConcurrentHashMapKeycloakTransaction;+import org.keycloak.storage.SearchableModelField;++import java.util.Objects;+import java.util.Spliterators;+import java.util.concurrent.atomic.AtomicLong;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import java.util.stream.StreamSupport;++import static org.keycloak.models.map.common.HotRodUtils.paginateQuery;+import static org.keycloak.utils.StreamsUtil.closing;++public class HotRodMapStorage<K, V extends AbstractEntity & UpdatableEntity, M> implements MapStorage<V, M>, ConcurrentHashMapCRUDOperations<V, M> {++    private static final Logger LOG = Logger.getLogger(HotRodMapStorage.class);++    private final RemoteCache<K, V> remoteCache;+    private final StringKeyConvertor<K> keyConvertor;+    private final HotRodEntityDescriptor<V> storedEntityDescriptor;+    private final DeepCloner cloner;++    public HotRodMapStorage(RemoteCache<K, V> remoteCache, StringKeyConvertor<K> keyConvertor, HotRodEntityDescriptor<V> storedEntityDescriptor, DeepCloner cloner) {+        this.remoteCache = remoteCache;+        this.keyConvertor = keyConvertor;+        this.storedEntityDescriptor = storedEntityDescriptor;+        this.cloner = cloner;+    }++    @Override+    public V create(V value) {+        K key = keyConvertor.fromStringSafe(value.getId());+        if (key == null) {+            key = keyConvertor.yieldNewUniqueKey();+            value = cloner.from(keyConvertor.keyToString(key), value);+        }++        remoteCache.putIfAbsent(key, value);++        return value;+    }++    @Override+    public V read(String key) {+        Objects.requireNonNull(key, ""Key must be non-null"");+        K k = keyConvertor.fromStringSafe(key);+        return remoteCache.get(k);+    }++    @Override+    public V update(V value) {+        K key = keyConvertor.fromStringSafe(value.getId());+        return remoteCache.replace(key, value);+    }++    @Override+    public boolean delete(String key) {+        K k = keyConvertor.fromStringSafe(key);+        return remoteCache.remove(k) != null;+    }++    private static String toOrderString(QueryParameters.OrderBy<?> orderBy) {+        SearchableModelField<?> field = orderBy.getModelField();+        String modelFieldName = IckleQueryMapModelCriteriaBuilder.getFieldName(field);+        String orderString = orderBy.getOrder().equals(QueryParameters.Order.ASCENDING) ? ""ASC"" : ""DESC"";++        return modelFieldName + "" "" + orderString;+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public Stream<V> read(QueryParameters<M> queryParameters) {+        IckleQueryMapModelCriteriaBuilder<K, V, M> iqmcb = queryParameters.getModelCriteriaBuilder().unwrap(IckleQueryMapModelCriteriaBuilder.class);+        String queryString = iqmcb.getIckleQuery();++        if (!queryParameters.getOrderBy().isEmpty()) {+            queryString += "" ORDER BY "" + queryParameters.getOrderBy().stream().map(HotRodMapStorage::toOrderString)+                                            .collect(Collectors.joining("", ""));+        }++        LOG.tracef(""Executing read Ickle query: %s"", queryString);++        QueryFactory queryFactory = Search.getQueryFactory(remoteCache);++        Query<V> query = paginateQuery(queryFactory.create(queryString), queryParameters.getOffset(),+                queryParameters.getLimit());++        query.setParameters(iqmcb.getParameters());++        CloseableIterator<V> iterator = query.iterator();+        return closing(StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false))+                .onClose(iterator::close);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public long getCount(QueryParameters<M> queryParameters) {+        IckleQueryMapModelCriteriaBuilder<K, V, M> iqmcb = queryParameters.getModelCriteriaBuilder().unwrap(IckleQueryMapModelCriteriaBuilder.class);+        String queryString = iqmcb.getIckleQuery();++        if (!queryParameters.getOrderBy().isEmpty()) {+            queryString += "" ORDER BY "" + queryParameters.getOrderBy().stream().map(HotRodMapStorage::toOrderString)+                    .collect(Collectors.joining("", ""));+        }++        LOG.tracef(""Executing count Ickle query: %s"", queryString);++        QueryFactory queryFactory = Search.getQueryFactory(remoteCache);++        Query<V> query = paginateQuery(queryFactory.create(queryString), queryParameters.getOffset(),+                queryParameters.getLimit());++        query.setParameters(iqmcb.getParameters());++        return query.execute().hitCount().orElse(0);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public long delete(QueryParameters<M> queryParameters) {+        IckleQueryMapModelCriteriaBuilder<K, V, M> iqmcb = queryParameters.getModelCriteriaBuilder().unwrap(IckleQueryMapModelCriteriaBuilder.class);+        String queryString = ""SELECT id "" + iqmcb.getIckleQuery();++        if (!queryParameters.getOrderBy().isEmpty()) {+            queryString += "" ORDER BY "" + queryParameters.getOrderBy().stream().map(HotRodMapStorage::toOrderString)","I think should do it. In the future, we may want to have some default value for `maxResult` to prevent the removal of too many items and we need to remove always the same values. We are sorting also in [CHM](https://github.com/keycloak/keycloak/blob/main/model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java#L145).  ",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8665,745448092,2021-11-09T09:47:06Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/HotRodMapStorage.java,"@@ -0,0 +1,178 @@+package org.keycloak.models.map.storage.hotRod;++import org.infinispan.client.hotrod.RemoteCache;+import org.infinispan.client.hotrod.Search;+import org.infinispan.commons.util.CloseableIterator;+import org.infinispan.query.dsl.Query;+import org.infinispan.query.dsl.QueryFactory;+import org.jboss.logging.Logger;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.HotRodEntityDescriptor;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.common.UpdatableEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.ConcurrentHashMapCRUDOperations;+import org.keycloak.models.map.storage.chm.ConcurrentHashMapKeycloakTransaction;+import org.keycloak.storage.SearchableModelField;++import java.util.Objects;+import java.util.Spliterators;+import java.util.concurrent.atomic.AtomicLong;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import java.util.stream.StreamSupport;++import static org.keycloak.models.map.common.HotRodUtils.paginateQuery;+import static org.keycloak.utils.StreamsUtil.closing;++public class HotRodMapStorage<K, V extends AbstractEntity & UpdatableEntity, M> implements MapStorage<V, M>, ConcurrentHashMapCRUDOperations<V, M> {++    private static final Logger LOG = Logger.getLogger(HotRodMapStorage.class);++    private final RemoteCache<K, V> remoteCache;+    private final StringKeyConvertor<K> keyConvertor;+    private final HotRodEntityDescriptor<V> storedEntityDescriptor;+    private final DeepCloner cloner;++    public HotRodMapStorage(RemoteCache<K, V> remoteCache, StringKeyConvertor<K> keyConvertor, HotRodEntityDescriptor<V> storedEntityDescriptor, DeepCloner cloner) {+        this.remoteCache = remoteCache;+        this.keyConvertor = keyConvertor;+        this.storedEntityDescriptor = storedEntityDescriptor;+        this.cloner = cloner;+    }++    @Override+    public V create(V value) {+        K key = keyConvertor.fromStringSafe(value.getId());+        if (key == null) {+            key = keyConvertor.yieldNewUniqueKey();+            value = cloner.from(keyConvertor.keyToString(key), value);+        }++        remoteCache.putIfAbsent(key, value);++        return value;+    }++    @Override+    public V read(String key) {+        Objects.requireNonNull(key, ""Key must be non-null"");+        K k = keyConvertor.fromStringSafe(key);+        return remoteCache.get(k);+    }++    @Override+    public V update(V value) {+        K key = keyConvertor.fromStringSafe(value.getId());+        return remoteCache.replace(key, value);+    }++    @Override+    public boolean delete(String key) {+        K k = keyConvertor.fromStringSafe(key);+        return remoteCache.remove(k) != null;+    }++    private static String toOrderString(QueryParameters.OrderBy<?> orderBy) {+        SearchableModelField<?> field = orderBy.getModelField();+        String modelFieldName = IckleQueryMapModelCriteriaBuilder.getFieldName(field);+        String orderString = orderBy.getOrder().equals(QueryParameters.Order.ASCENDING) ? ""ASC"" : ""DESC"";++        return modelFieldName + "" "" + orderString;+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public Stream<V> read(QueryParameters<M> queryParameters) {+        IckleQueryMapModelCriteriaBuilder<K, V, M> iqmcb = queryParameters.getModelCriteriaBuilder().unwrap(IckleQueryMapModelCriteriaBuilder.class);+        String queryString = iqmcb.getIckleQuery();++        if (!queryParameters.getOrderBy().isEmpty()) {+            queryString += "" ORDER BY "" + queryParameters.getOrderBy().stream().map(HotRodMapStorage::toOrderString)+                                            .collect(Collectors.joining("", ""));+        }++        LOG.tracef(""Executing read Ickle query: %s"", queryString);++        QueryFactory queryFactory = Search.getQueryFactory(remoteCache);++        Query<V> query = paginateQuery(queryFactory.create(queryString), queryParameters.getOffset(),+                queryParameters.getLimit());++        query.setParameters(iqmcb.getParameters());++        CloseableIterator<V> iterator = query.iterator();+        return closing(StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, 0), false))+                .onClose(iterator::close);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public long getCount(QueryParameters<M> queryParameters) {+        IckleQueryMapModelCriteriaBuilder<K, V, M> iqmcb = queryParameters.getModelCriteriaBuilder().unwrap(IckleQueryMapModelCriteriaBuilder.class);+        String queryString = iqmcb.getIckleQuery();++        if (!queryParameters.getOrderBy().isEmpty()) {+            queryString += "" ORDER BY "" + queryParameters.getOrderBy().stream().map(HotRodMapStorage::toOrderString)","This is a good question. We probably don't need it. However, there is another thing similar to this for this method. Currently, we are ignoring pagination for `getCount` as [`hitCount`](https://docs.jboss.org/infinispan/11.0/apidocs/org/infinispan/query/dsl/QueryResult.html#hitCount()) method ignores it. We use it for CHM though.I am not sure whether we need to have pagination for `getCount`, @martin-kanis  @hmlnarik WDYT?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8731,745678647,2021-11-09T14:38:12Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/storage/database/liquibase/FastServiceLocator.java,"@@ -79,6 +79,15 @@ public FastServiceLocator(Map<String, List<String>> services) {         getPackages().remove(""liquibase.parser.core.json"");","just a merely related note: should we make this class final to avoid extension of it? When someone would extend the class, all the overridable methods in the constructor could cause serious headache ;)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8665,747400462,2021-11-11T10:56:17Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/HotRodMapStorageProviderFactory.java,"@@ -0,0 +1,102 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.hotRod;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.component.AmphibianProviderFactory;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.models.map.client.HotRodAttributeEntity;+import org.keycloak.models.map.client.HotRodClientEntity;+import org.keycloak.models.map.client.HotRodProtocolMapperEntity;+import org.keycloak.models.map.common.HotRodPair;+import org.keycloak.models.map.client.MapClientEntity;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.HotRodEntityDescriptor;+import org.keycloak.models.map.connections.HotRodConnectionProvider;+import org.keycloak.models.map.storage.MapStorageProvider;+import org.keycloak.models.map.storage.MapStorageProviderFactory;+import org.keycloak.provider.EnvironmentDependentProviderFactory;++import java.util.Arrays;+import java.util.HashMap;+import java.util.Map;++public class HotRodMapStorageProviderFactory implements AmphibianProviderFactory<MapStorageProvider>, MapStorageProviderFactory, EnvironmentDependentProviderFactory {++    public static final String PROVIDER_ID = ""hotrod"";+    private static final Logger LOG = Logger.getLogger(HotRodMapStorageProviderFactory.class);++    private final static DeepCloner CLONER = new DeepCloner.Builder()+            .constructorDC(MapClientEntity.class,         HotRodClientEntity::new)+            .constructor(MapProtocolMapperEntity.class,   HotRodProtocolMapperEntity::new)+            .build();++    public static final Map<Class<?>, HotRodEntityDescriptor<?>> ENTITY_DESCRIPTOR_MAP = new HashMap<>();+    static {+        // Clients descriptor+        ENTITY_DESCRIPTOR_MAP.put(ClientModel.class,+                new HotRodEntityDescriptor<>(ClientModel.class,+                        MapClientEntity.class,+                        Arrays.asList(HotRodClientEntity.class, HotRodAttributeEntity.class, HotRodProtocolMapperEntity.class, HotRodPair.class),+                        ""clients""));+    }++    @Override+    public MapStorageProvider create(KeycloakSession session) {+        HotRodConnectionProvider cacheProvider = session.getProvider(HotRodConnectionProvider.class);+        +        if (cacheProvider == null) {+            throw new IllegalStateException(""Cannot find HotRodConnectionProvider interface implementation"");+        }+        +        return new HotRodMapStorageProvider(this, cacheProvider, CLONER);+    }++    public HotRodEntityDescriptor<?> getEntityDescriptor(Class<?> c) {+        return ENTITY_DESCRIPTOR_MAP.get(c);+    }++    @Override+    public void init(Config.Scope config) {++    }++    @Override+    public void postInit(KeycloakSessionFactory factory) {++    }++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    @Override+    public boolean isSupported() {+        return true;",Apologies for late spot. This should be supported if and only map-storage feature is enabled. See e.g. https://github.com/keycloak/keycloak/blob/36da2d20e97a10821c7305881d3ffa343b5ad001/model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorageProviderFactory.java#L341,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8803,747607151,2021-11-11T15:40:44Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/PropertyMapper.java,"@@ -105,6 +106,10 @@ ConfigValue getOrDefault(String name, ConfigSourceInterceptorContext context, Co             // if not defined, return the current value from the property as a default if the property is not explicitly set             if (defaultValue == null                     || (current != null && !current.getConfigSourceName().equalsIgnoreCase(""default values""))) {+                if (defaultValue == null && mapper != null) {","        this.mapper = mapper == null ? PropertyMapper::defaultTransformer : mapper;=> mapper is always defined, so we could remove the `&& mapper != null` part of the condition here, couldn't we?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8803,747617920,2021-11-11T15:53:50Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/PropertyMapper.java,"@@ -48,7 +49,7 @@ public ConfigValue getOrDefault(String name, ConfigSourceInterceptorContext cont     PropertyMapper(String from, String to, String defaultValue, BiFunction<String, ConfigSourceInterceptorContext, String> mapper,             String mapFrom, boolean buildTime, String description, String paramLabel, boolean mask, Iterable<String> expectedValues, ConfigCategory category) {         this.from = MicroProfileConfigProvider.NS_KEYCLOAK_PREFIX + from;-        this.to = to;+        this.to = to == null ? this.from : to;",In the next round of changes. These are properties that do not map to other properties but are used as a dependency to others.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8775,748142747,2021-11-12T10:31:49Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/command/Start.java,"@@ -37,11 +44,56 @@      public static final String NAME = ""start""; -    @CommandLine.Option(names = {AUTO_BUILD_OPTION_SHORT, AUTO_BUILD_OPTION_LONG },+    @CommandLine.Option(names = {AUTO_BUILD_OPTION_SHORT, AUTO_BUILD_OPTION_LONG},             description = ""Automatically detects whether the server configuration changed and a new server image must be built"" +                     "" prior to starting the server. This option provides an alternative to manually running the '"" + Build.NAME + ""'"" +                     "" prior to starting the server. Use this configuration carefully in production as it might impact the startup time."",             paramLabel = NO_PARAM_LABEL,             order = 1)     Boolean autoConfig;++    @Override+    protected void doBeforeRun() {+        checkIfProfileIsNotDev();+    }++    /**+     * Checks if the profile provided by either the current argument, the system environment or the persisted properties is dev.+     * Fails with an error when dev profile is used for the start command, or continues with the found profile if its not the dev profile.+     */+    private void checkIfProfileIsNotDev() {+        List<String> currentCliArgs = spec.commandLine().getParseResult().expandedArgs();+        String profileLongArg = ""--profile"";+        String profileShortArg = ""-pf"";++        String currentArgsProfile = currentCliArgs.stream().filter(arg -> arg.contains(profileLongArg)).findFirst()",We also need to support options using a space as the key/value separator: `./kc.sh [-pf][--profile] dev`.Do you really need to query the arg list to query the profile? It should be enough to obtain it from `Environment.getProfile` because the profile should be set already prior to executing the start command.It should help to make it simpler.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8775,749274637,2021-11-15T12:17:51Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/KeycloakMain.java,"@@ -80,7 +79,7 @@ public static void start(List<String> cliArgs, PrintWriter errorWriter) {      */     @Override     public int run(String... args) throws Exception {-        if (isDevMode()) {+        if (getProfile().equals(""dev"")) {",Wouldn't make more sense to have this as a method on the `Environment` class similar to others?,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8819,749275968,2021-11-15T12:19:56Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/DatabasePropertyMappers.java,"@@ -16,14 +16,18 @@ private DatabasePropertyMappers(){}      public static PropertyMapper[] getDatabasePropertyMappers() {         return new PropertyMapper[] {-                builder().from(""db"")+                builder().from(""db-dialect"")+                        .mapFrom(""db"")                         .to(""quarkus.hibernate-orm.dialect"")                         .isBuildTimeProperty(true)                         .transformer((db, context) -> Database.getDialect(db).orElse(null))+                        .hidden(true)","just one note about using""hidden"" here: I assume these options should never be set by the CLI. Is that so? If so, when using ""hidden"", they just don't show up in help, but could be used nevertheless, e.g. by `./kc.sh start --db-dialect=...` - To actually remove them from the CLI completely, we have to remove them from the list of Options we add to the arggroups when creating the CLI. Also:  If we still plan to hide some options in the normal help in relation to commands (e.g. build only shows buildtime, start only runtime), we need to have a Collection restricted_options which then removes these options, am I right?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8819,750171131,2021-11-16T11:23:07Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/KeycloakProcessor.java,"@@ -143,7 +146,10 @@             DefaultJpaConnectionProviderFactory.class,             DefaultLiquibaseConnectionProvider.class,             FolderThemeProviderFactory.class,-            LiquibaseJpaUpdaterProviderFactory.class);+            LiquibaseJpaUpdaterProviderFactory.class,+            DefaultHostnameProviderFactory.class,+            FixedHostnameProviderFactory.class,+            RequestHostnameProviderFactory.class);",This is a list of providers being excluded. We only have the new one available at build/runtime.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8819,750178669,2021-11-16T11:33:25Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/DatabasePropertyMappers.java,"@@ -16,14 +16,18 @@ private DatabasePropertyMappers(){}      public static PropertyMapper[] getDatabasePropertyMappers() {         return new PropertyMapper[] {-                builder().from(""db"")+                builder().from(""db-dialect"")+                        .mapFrom(""db"")                         .to(""quarkus.hibernate-orm.dialect"")                         .isBuildTimeProperty(true)                         .transformer((db, context) -> Database.getDialect(db).orElse(null))+                        .hidden(true)","It should be useful to leverage Picocli capabilities to hide options from help messages. For instance, we might want in the future to include options we don't want to make explicit via configuration. We have that for free from Piccoli, so I'm just adding support for this capability into our mappers.W.r.t. why the option is not showing, we are very strict about how the option definition (helping to create some standard on how we define options). In this case, the options are not shown because they do not have a description. I would like to go over this part later to explicitly throw exceptions or ignore when hidden is true.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8092,750426983,2021-11-16T16:03:21Z,server-spi/src/main/java/org/keycloak/models/ClientScopeModel.java,"@@ -67,6 +67,9 @@     String CONSENT_SCREEN_TEXT = ""consent.screen.text"";     String GUI_ORDER = ""gui.order"";     String INCLUDE_IN_TOKEN_SCOPE = ""include.in.token.scope"";+    String LOGO_URI =""logoUri"";","I am not sure why these constants are defined on the ClientScopeModel? Existing constants on ClientScopeModel are the configuration options of client scope. However these constants logoUri, policyUri, tosUri are not config options of clientScopeModel. It seems the better place for define them might be ClientModel class or ""org.keycloak.models.Constants""",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/7860,750816427,2021-11-17T01:36:08Z,services/src/main/java/org/keycloak/authentication/DefaultAuthenticationFlow.java,"@@ -430,16 +430,17 @@ private Response processSingleFlowExecutionModel(AuthenticationExecutionModel mo             if (authUser == null) {                 throw new AuthenticationFlowException(""authenticator: "" + factory.getId(), AuthenticationFlowError.UNKNOWN_USER);             }-            if (!authenticator.configuredFor(processor.getSession(), processor.getRealm(), authUser)) {-                if (factory.isUserSetupAllowed() && model.isRequired() && authenticator.areRequiredActionsEnabled(processor.getSession(), processor.getRealm())) {-                    //This means that having even though the user didn't validate the-                    logger.debugv(""authenticator SETUP_REQUIRED: {0}"", factory.getId());-                    processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SETUP_REQUIRED);-                    authenticator.setRequiredActions(processor.getSession(), processor.getRealm(), processor.getAuthenticationSession().getAuthenticatedUser());-                    return null;-                } else {-                    throw new AuthenticationFlowException(""authenticator: "" + factory.getId(), AuthenticationFlowError.CREDENTIAL_SETUP_REQUIRED);-                }+        }+        //  Trigger authenticator setup if needed if possible and if allowed+        if (authUser != null && factory.isUserSetupAllowed() && !authenticator.configuredFor(processor.getSession(), processor.getRealm(), authUser)) {","It seems that L435 and L436 changes the original codes' logic for condition of throwing `AuthenticationFlowException` in L442.To keep the same condition for throwing it in the original codes, how about the following?```    if (authUser != null && !authenticator.configuredFor(processor.getSession(), processor.getRealm(), authUser)) {        if (factory.isUserSetupAllowed() && model.isRequired() && authenticator.areRequiredActionsEnabled(processor.getSession(), processor.getRealm())) {```If you intentionally changed this condition, could you tell me this reason?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8819,751025790,2021-11-17T08:56:12Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/DatabasePropertyMappers.java,"@@ -16,14 +16,18 @@ private DatabasePropertyMappers(){}      public static PropertyMapper[] getDatabasePropertyMappers() {         return new PropertyMapper[] {-                builder().from(""db"")+                builder().from(""db-dialect"")+                        .mapFrom(""db"")                         .to(""quarkus.hibernate-orm.dialect"")                         .isBuildTimeProperty(true)                         .transformer((db, context) -> Database.getDialect(db).orElse(null))+                        .hidden(true)","Let me elaborate a bit:1) I never meant to say ""never use the hidden flag"". I just wanted to note, that this might get us into problems _when_ and only when we use the hidden flag to hide some options _based on the current command used_ in the help message. Because _then_ we would need to have a Collection which has the ""shouldbehiddenoneverycommand"" in it. 2) here you can see the code and video of a PoC I created a few days ago, perhaps that makes a bit clearer what I meant:Video:  https://youtu.be/9C5aCbvllzQinteresting code:https://github.com/DGuhr/keycloak/blob/PoC_Conditional_Hidden/quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Picocli.java#L399-L417 (here we're setting hidden based on the currently executed command).So, when we want to implement this (and there are some hurdles in the way that'll increase code complexity picocli-wise, see e.g. arggroups with all params ""hidden"", but the heading showing up), then we'd need the aforementioned collection to override this behaviour for ""always hidden, no matter the command"" options. *short digression:*Another alternative would e.g. be to show the buildtime props some other wy, e.g. like this:![Screenshot 2021-11-12 at 10 05 41](https://user-images.githubusercontent.com/89905860/142167154-7935ec72-a943-4209-8f0f-89b99ab55a46.png)imo this also leads to a good UX, bc. you don't have to add an extra command to actually show them, and the lock (with a short description above in the help, for sure) shows exactly what you shouldn't change, but gives you the help directly, so you directly know what to do then. One could also think of showing an open lock ( https://unicode-table.com/en/1F513/ ) for start-dev to symbolize that you can use both there. cc @stianst ;) *digression end*That said, I still don't understand why you set hidden in this context in the first place, bc. when this: https://github.com/keycloak/keycloak/pull/8819/files#diff-5e7526010bd1f3d3c2735d6b5d600aaf3457a83eb1699ef7e10c91e2257ae6d2R406 is set, the collection of propertymappers we iterate over does not contain the commands without the description, they are sorted out before, as you stated, bc. no description is given.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8819,751136833,2021-11-17T11:09:38Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/DatabasePropertyMappers.java,"@@ -16,14 +16,18 @@ private DatabasePropertyMappers(){}      public static PropertyMapper[] getDatabasePropertyMappers() {         return new PropertyMapper[] {-                builder().from(""db"")+                builder().from(""db-dialect"")+                        .mapFrom(""db"")                         .to(""quarkus.hibernate-orm.dialect"")                         .isBuildTimeProperty(true)                         .transformer((db, context) -> Database.getDialect(db).orElse(null))+                        .hidden(true)","I think we are mixing topics here. The properties here are not at all related to build time properties. The main change here is to change these properties to not reference the `db` option, otherwise, we have issues because properties are going to overlap with each other.In regards to hidden, I thought it was clear based on what we discussed. Piccoli supports that and I'm just enabling this capability at our end. In fact, these options should be hidden from help. Why they can not be marked as such?As I mentioned, the fact that options with no description are completely removed when building the option specs is something we already have and it is not the proper way to remove (not hide) options. For that, we need something more meaningful that clearly indicates that an option should be available internally (from the map of mappers) but not enabled to users.That said, I don't want to push this behavior now. So what is your proposal? Remove the `hidden` from option config?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/8819,751161865,2021-11-17T11:44:47Z,testsuite/integration-arquillian/servers/auth-server/quarkus/src/main/content/conf/keycloak.properties,"@@ -6,6 +6,10 @@ db.password = keycloak # Testsuite still relies on HTTP listener http.enabled=true +# Disables strict hostname+hostname.strict=false+hostname.strict-https=false","Yeah, let's just hide the option, and make it always true in prod, without any way of changing it. I see you have ""hidden"" properties now so that should be simple ;)",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8847,751189249,2021-11-17T12:23:34Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/DatabasePropertyMappers.java,"@@ -41,12 +41,32 @@ private DatabasePropertyMappers(){}                         .to(""quarkus.datasource.jdbc.url"")                         .mapFrom(""db"")                         .transformer((value, context) -> Database.getDefaultUrl(value).orElse(value))-                        .description(""The database JDBC URL. If not provided, a default URL is set based on the selected database vendor. "" +-                                ""For instance, if using 'postgres', the JDBC URL would be 'jdbc:postgresql://localhost/keycloak'. "" +-                                ""The host, database and properties can be overridden by setting the following system properties,"" +-                                "" respectively: -Dkc.db.url.host, -Dkc.db.url.database, -Dkc.db.url.properties."")+                        .description(""The full database JDBC URL. If not provided, a default URL is set based on the selected database vendor. "" ++                                ""For instance, if using 'postgres', the default JDBC URL would be 'jdbc:postgresql://localhost/keycloak'. "" ++                                ""Attention: Setting the URL overrides the set values for the default URL via '--db-url-host', '--db-url-database' or '--db-url-properties'."")","```suggestion                        .description(""The full database JDBC URL. If not provided, a default URL is set based on the selected database vendor. "" +                                ""For instance, if using 'postgres', the default JDBC URL would be 'jdbc:postgresql://localhost/keycloak'."")```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8847,751191786,2021-11-17T12:27:01Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/DatabasePropertyMappers.java,"@@ -41,12 +41,32 @@ private DatabasePropertyMappers(){}                         .to(""quarkus.datasource.jdbc.url"")                         .mapFrom(""db"")                         .transformer((value, context) -> Database.getDefaultUrl(value).orElse(value))-                        .description(""The database JDBC URL. If not provided, a default URL is set based on the selected database vendor. "" +-                                ""For instance, if using 'postgres', the JDBC URL would be 'jdbc:postgresql://localhost/keycloak'. "" +-                                ""The host, database and properties can be overridden by setting the following system properties,"" +-                                "" respectively: -Dkc.db.url.host, -Dkc.db.url.database, -Dkc.db.url.properties."")+                        .description(""The full database JDBC URL. If not provided, a default URL is set based on the selected database vendor. "" ++                                ""For instance, if using 'postgres', the default JDBC URL would be 'jdbc:postgresql://localhost/keycloak'. "" ++                                ""Attention: Setting the URL overrides the set values for the default URL via '--db-url-host', '--db-url-database' or '--db-url-properties'."")                         .paramLabel(""jdbc-url"")                         .build(),+                builder().from(""db.url.host"")+                        .to(""kc.db.url.host"")+                        .description(""Sets the hostname of the default database vendor. "" ++                                ""For instance, if using 'db=postgres' and setting the value to myurl:5432,"" ++                                "" the resulting default JDBC URL would be 'jdbc:postgresql://myurl:5432/keycloak'. "")+                        .paramLabel(""hostname"")+                        .build(),+                builder().from(""db.url.database"")+                        .to(""kc.db.url.database"")+                        .description(""Sets the database name of the default database vendor. "" ++                                ""For instance, if using 'db=postgres' and setting the value to kcdb,"" ++                                "" the resulting default JDBC URL would be 'jdbc:postgres://localhost/kcdb'. "")","```suggestion                        .description(""Sets the database name of the default JDBC URL of the chosen vendor. If the `db-url` option is set, this option is ignored."")```",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8858,754549815,2021-11-22T18:49:43Z,distribution/server-x-dist/assembly.xml,"@@ -102,7 +102,7 @@             <outputDirectory>conf</outputDirectory>         </file>         <file>-            <source>target/keycloak-quarkus-server-app/META-INF/keycloak.properties</source>+            <source>../../quarkus/runtime/src/main/resources/META-INF/keycloak.properties</source>","Now, the `keycloak.properties` file is within the runtime module. The main reasons are:* Being the default settings, it is now also loaded from our JAR.* If a user accidentally removes this file from the distribution (e.g.: `conf/keycloak.properties`) the server is still fully functional. It should be possible to easily revert changes.* We have the possibility to make the `conf/keycloak.properties` even simpler by just enabling what we think people should care about. For instance, we could just have there the recommended settings for ""prod"" profile. ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8858,755944654,2021-11-24T11:09:04Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/KeycloakMain.java,"@@ -87,7 +97,17 @@ public int run(String... args) throws Exception {         if (isDevProfile()) {             LOGGER.warnf(""Running the server in dev mode. DO NOT use this configuration in production."");         }-        Quarkus.waitForExit();-        return ApplicationLifecycleManager.getExitCode();++        int exitCode = ApplicationLifecycleManager.getExitCode();++        if (isTestLaunchMode()) {","TBH, I would like to have any code change related to changes completely decoupled from the core code base. In fact, I tried that like having a specific main class for tests, but it brings a bit more complexity and hard to get right due to how Quarkus Main works.Could you please elaborate more about your proposal? it is just a different name for the property?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8925,757125140,2021-11-25T21:01:26Z,.github/workflows/ci.yml,"@@ -403,6 +403,14 @@ jobs:           java-version: ${{ env.DEFAULT_JDK_VERSION }}       - name: Update maven settings         run: mkdir -p ~/.m2 ; cp .github/settings.xml ~/.m2/+      - name: Prepare the local distribution archives+        run: mvn clean install -DskipTests -Pdistribution+      - name: Run Quarkus Tests in Docker+        run: |+          mvn clean install -nsu -B -f quarkus/tests/pom.xml -DkcDistribution=docker | misc/log/trimmer.sh","Shall we keep the format we are using for properties and have `kcDistribution` as `kc.tests.dist` ? Or something similar.Also, I'm wondering if it makes more sense to run tests in GHA against docker, only. It should be enough to test not only the image but the distribution itself (as we do for the standalone distribution, still useful for dev purposes).",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8930,757454296,2021-11-26T12:14:56Z,quarkus/tests/integration/src/main/java/org/keycloak/it/junit5/extension/CLITestExtension.java,"@@ -76,17 +76,17 @@ public void afterEach(ExtensionContext context) throws Exception {     public void afterAll(ExtensionContext context) throws Exception {         if (dist != null) {             // just to make sure the server is stopped after all tests-            dist.stopIfRunning();+            dist.stop();+            dist.close();         }         super.afterAll(context);     }      private KeycloakDistribution createDistribution(DistributionTest config) {-        KeycloakDistribution distribution = new KeycloakDistribution();--        distribution.setReCreate(!ReInstall.NEVER.equals(config.reInstall()));",Could you please elaborate why this config is no longer set to the raw distribution?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8930,757657568,2021-11-26T18:31:05Z,quarkus/tests/integration/pom.xml,"@@ -62,4 +62,39 @@             <scope>test</scope>         </dependency>     </dependencies>++    <build>+        <plugins>+            <plugin>+                <groupId>org.apache.maven.plugins</groupId>+                <artifactId>maven-surefire-plugin</artifactId>+                <configuration>+                    <skipTests>true</skipTests>","Sorry, I think I misunderstood when you mentioned that to me before. Is it really a good idea to disable tests by default?If we are avoiding running in unit tests, perhaps we should just add a `skipQuarkusTests` similarly to the `skipTestsuite`. See https://github.com/keycloak/keycloak/blob/6a766884f632858990a05dabc4019ff3f18d972c/pom.xml#L2024.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8948,758459476,2021-11-29T15:15:31Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/common/AbstractHotRodEntity.java,"@@ -17,6 +17,5 @@  package org.keycloak.models.map.common; -public interface Versioned {-    int getEntityVersion();+public interface AbstractHotRodEntity {","Here is a link directly to the file: https://github.com/keycloak/keycloak/blob/dfa6636aa94372e4c7ca889e122c2f581414b7ff/model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateHotRodEntityImplementationsProcessor.java#L376-L388With the previous link, it should be enough to scroll to the `GenerateHotRodEntityImplementationsProcessor` file and click `Show diff`.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8918,759104214,2021-11-30T09:49:43Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ClientTest.java,"@@ -536,6 +539,8 @@ public void offlineUserSessions() throws IOException {         List<UserSessionRepresentation> offlineUserSessions = realm.clients().get(id).getOfflineUserSessions(0, 100);         assertEquals(1, offlineUserSessions.size());         assertEquals(""testuser"", offlineUserSessions.get(0).getUsername());+        org.hamcrest.MatcherAssert.assertThat(offlineUserSessions.get(0).getLastAccess(),","Thanks for this. Is it possible to use a bit bigger time instead of 1000 (EG. 10000)? In some environments, testsuite is quite slow (for example when executed with custom databases in our internal pipeline) and I afraid that with 1000 ms, it can fail this condition due this slowness.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8928,760301981,2021-12-01T15:34:52Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/DefaultFactory.java,"@@ -0,0 +1,29 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.cli;++import picocli.CommandLine.IFactory;++public class DefaultFactory implements IFactory {",I don't mind. The class is within the `cli` package though. isn't redundant to change the name as you are proposing?Whatever works best for you.,
4205291,marcelomrwin,https://api.github.com/repos/keycloak/keycloak/pulls/8921,760309260,2021-12-01T15:42:07Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/idm/store/ldap/LDAPOperationManager.java,"@@ -370,26 +370,36 @@ private SearchControls getSearchControls(Collection<String> returningAttributes,     }      public String getFilterById(String id) {-        String filter = null;+        StringBuilder filter = new StringBuilder();+        filter.insert(0, ""(&"");          if (this.config.isObjectGUID()) {             byte[] objectGUID = LDAPUtil.encodeObjectGUID(id);--            filter = ""(&(objectClass=*)("" + getUuidAttributeName() + LDAPConstants.EQUAL + LDAPUtil.convertObjectGUIDToByteString(objectGUID) + ""))"";+            filter.append(""(objectClass=*)("").append(+                    getUuidAttributeName()).append(LDAPConstants.EQUAL)+                .append(LDAPUtil.convertObjectGUIDToByteString(+                    objectGUID)).append("")"");          } else if (this.config.isEdirectoryGUID()) {-            filter = ""(&(objectClass=*)("" + getUuidAttributeName().toUpperCase() + LDAPConstants.EQUAL + LDAPUtil.convertGUIDToEdirectoryHexString(id) + ""))"";+            filter.append(""(objectClass=*)("").append(getUuidAttributeName().toUpperCase())+                .append(LDAPConstants.EQUAL+                ).append(LDAPUtil.convertGUIDToEdirectoryHexString(id)).append("")"");+        } else {+            filter.append(""(objectClass=*)("").append(getUuidAttributeName()).append(LDAPConstants.EQUAL)+                .append(id).append("")"");         } -        if (filter == null) {-            filter = ""(&(objectClass=*)("" + getUuidAttributeName() + LDAPConstants.EQUAL + id + ""))"";+        if (config.getCustomUserSearchFilter() != null) {+            filter.append(config.getCustomUserSearchFilter());         }          if (logger.isTraceEnabled()) {-            logger.tracef(""Using filter for lookup user by LDAP ID: %s"", filter);+            logger.tracef(""Using filter for lookup user by LDAP ID: %s"", filter.toString());         }","@hmlnarik Thanks. I tried to make the code model closer to other classes that do similar things. At the end, if we are going to reuse the generated String I extract it straight to a variable, so we can make use of String.intern(). The indentation has been fixed @mposolda , thanks for the tip.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/8928,760333954,2021-12-01T16:07:09Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/DefaultFactory.java,"@@ -0,0 +1,29 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.cli;++import picocli.CommandLine.IFactory;++public class DefaultFactory implements IFactory {","I'd like DefaultCliFactory then, if you dont mind too much, but also not hard on this :) true, redundant, but just a bit more easy qhen searching all classes and makes the intention more clear.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,761147734,2021-12-02T14:31:27Z,model/map-jpa/src/main/java/org/keycloak/models/map/jpa/client/entity/JpaClientEntity.java,"@@ -0,0 +1,622 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.jpa.client.entity;++import java.io.Serializable;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Generated;+import org.hibernate.annotations.GenerationTime;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import static org.keycloak.models.map.jpa.client.storage.JpaClientMapStorage.SUPPORTED_VERSION;+import org.keycloak.models.map.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""client"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaClientEntity extends AbstractClientEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaClientMetadata metadata = new JpaClientMetadata();",Perhaps a shared instance could be used here rather than new instance with every `JpaClientEntity`?```suggestion    private final JpaClientMetadata metadata = JpaClientMetadata.INSTANCE;```Or maybe even `null`?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8948,761236732,2021-12-02T15:59:19Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/common/HotRodEntityDescriptor.java,"@@ -17,35 +17,34 @@  package org.keycloak.models.map.storage.hotRod.common; -import java.util.List;-import java.util.stream.Stream;+import java.util.function.Function; -public class HotRodEntityDescriptor<EntityType> {+public class HotRodEntityDescriptor<HotRodEntityType, HotRodDelegate extends HotRodEntityDelegate<HotRodEntityType>> {","If possible, please use type parameter names that can be told apart from a real class / interface name at the first sight.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,761455072,2021-12-02T20:49:59Z,model/map-jpa/src/main/java/org/keycloak/models/map/jpa/client/storage/JpaClientMapKeycloakTransaction.java,"@@ -0,0 +1,176 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.jpa.client.storage;++import java.util.LinkedList;+import java.util.List;+import java.util.UUID;+import java.util.stream.Stream;+import javax.persistence.EntityManager;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.CriteriaDelete;+import javax.persistence.criteria.CriteriaQuery;+import javax.persistence.criteria.Order;+import javax.persistence.criteria.Root;+import org.keycloak.connections.jpa.JpaKeycloakTransaction;+import org.keycloak.models.ClientModel;+import static org.keycloak.models.jpa.PaginationUtils.paginateQuery;+import org.keycloak.models.map.client.MapClientEntity;+import org.keycloak.models.map.client.MapClientEntityDelegate;+import org.keycloak.models.map.common.StringKeyConvertor.UUIDKey;+import org.keycloak.models.map.jpa.client.delegate.JpaClientDelegateProvider;+import org.keycloak.models.map.jpa.client.entity.JpaClientEntity;+import static org.keycloak.models.map.jpa.client.storage.JpaClientMapStorage.SUPPORTED_VERSION;+import static org.keycloak.models.map.jpa.client.storage.JpaClientMapStorageProviderFactory.CLONER;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.QueryParameters;+import static org.keycloak.utils.StreamsUtil.closing;++public class JpaClientMapKeycloakTransaction extends JpaKeycloakTransaction implements MapKeycloakTransaction<MapClientEntity, ClientModel> {++    public JpaClientMapKeycloakTransaction(EntityManager em) {+        super(em);+    }++    @Override+    public MapClientEntity create(MapClientEntity mapEntity) {+        JpaClientEntity jpaEntity = (JpaClientEntity) CLONER.deepClone(mapEntity, CLONER.newInstance(JpaClientEntity.class)); +        if (mapEntity.getId() == null) {+            jpaEntity.setId(UUIDKey.INSTANCE.yieldNewUniqueKey().toString());+        }+        jpaEntity.setEntityVersion(SUPPORTED_VERSION);+        em.persist(jpaEntity);+        return jpaEntity;+    }++    @Override+    public MapClientEntity read(String key) {+        if (key == null) return null;+        UUID uuid = UUIDKey.INSTANCE.fromStringSafe(key);+        if (uuid == null) return null;++        return em.find(JpaClientEntity.class, uuid);+    }++    @Override+    public Stream<MapClientEntity> read(QueryParameters<ClientModel> queryParameters) {+        JpaClientModelCriteriaBuilder mcb = queryParameters.getModelCriteriaBuilder()+                .flashToModelCriteriaBuilder(new JpaClientModelCriteriaBuilder());++        CriteriaBuilder cb = em.getCriteriaBuilder();+        CriteriaQuery<JpaClientEntity> query = cb.createQuery(JpaClientEntity.class);+        Root<JpaClientEntity> root = query.from(JpaClientEntity.class);+        query.select(cb.construct(JpaClientEntity.class, +                root.get(""id""), +                root.get(""entityVersion""), +                root.get(""realmId""), +                root.get(""clientId""), +                root.get(""protocol""), +                root.get(""enabled"")+        ));++        //ordering+        if (!queryParameters.getOrderBy().isEmpty()) {+            List<Order> orderByList = new LinkedList();+            for (QueryParameters.OrderBy<ClientModel> order : queryParameters.getOrderBy()) {+                switch (order.getOrder()) {+                    case ASCENDING:+                        orderByList.add(cb.asc(root.get(order.getModelField().getName())));+                        break;+                    case DESCENDING:+                        orderByList.add(cb.desc(root.get(order.getModelField().getName())));+                        break;+                    default:+                        throw new UnsupportedOperationException(""Unknown ordering."");+                }+            }+            query.orderBy(orderByList);+        }++        if (mcb.getPredicateFunc() != null) query.where(mcb.getPredicateFunc().apply(cb, root));++        return closing(+                paginateQuery(em.createQuery(query), queryParameters.getOffset(), queryParameters.getLimit())+                        .getResultStream())+                .map(c -> new MapClientEntityDelegate(new JpaClientDelegateProvider(c, em)));+    }++    @Override+    public long getCount(QueryParameters<ClientModel> queryParameters) {+        JpaClientModelCriteriaBuilder mcb = queryParameters.getModelCriteriaBuilder()+                .flashToModelCriteriaBuilder(new JpaClientModelCriteriaBuilder());++        CriteriaBuilder cb = em.getCriteriaBuilder();++        CriteriaQuery<Long> countQuery = cb.createQuery(Long.class);+        Root<JpaClientEntity> root = countQuery.from(JpaClientEntity.class);+        countQuery.select(cb.count(root));++        if (mcb.getPredicateFunc() != null) countQuery.where(mcb.getPredicateFunc().apply(cb, root));++        return em.createQuery(countQuery).getSingleResult();+    }++    @Override+    public boolean delete(String key) {+        if (key == null) return false;+        UUID uuid = UUIDKey.INSTANCE.fromStringSafe(key);+        if (uuid == null) return false;+        em.remove(em.getReference(JpaClientEntity.class, uuid));+        return true;+    }++    @Override+    public long delete(QueryParameters<ClientModel> queryParameters) {+        JpaClientModelCriteriaBuilder mcb = queryParameters.getModelCriteriaBuilder()+                .flashToModelCriteriaBuilder(new JpaClientModelCriteriaBuilder());++        CriteriaBuilder cb = em.getCriteriaBuilder();++        CriteriaDelete<JpaClientEntity> deleteQuery = cb.createCriteriaDelete(JpaClientEntity.class);++        Root<JpaClientEntity> root = deleteQuery.from(JpaClientEntity.class);++        if (mcb.getPredicateFunc() != null) deleteQuery.where(mcb.getPredicateFunc().apply(cb, root));++// TODO find out the flush and clear https://thorben-janssen.com/5-common-hibernate-mistakes-that-cause-dozens-of-unexpected-queries/#Remove_Child_Entities_With_a_Bulk_Operation+//        em.flush();+//        em.clear();++        return em.createQuery(deleteQuery).executeUpdate();+    }++    /**+     * @return all clients with lower entityVersion field than {@code JpaClientMapStorage.SUPPORED_VERSION} as a stream.+     */","I think there needs to be an amendment. The histogram (KEYCLOAK-18719) is about getting a summary information: entityVersion -> count of rows with that entity version.If there is a need to get the list of IDs of old entity version rows, then there should be no other columns selected, only that ID. The very structure of the table might change which means that one of the columns that's being selected here might not exist yet / anymore.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,761455094,2021-12-02T20:50:01Z,model/map-jpa/src/main/java/org/keycloak/models/map/jpa/client/entity/JpaClientEntity.java,"@@ -0,0 +1,622 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.jpa.client.entity;++import java.io.Serializable;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Generated;+import org.hibernate.annotations.GenerationTime;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import static org.keycloak.models.map.jpa.client.storage.JpaClientMapStorage.SUPPORTED_VERSION;+import org.keycloak.models.map.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""client"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaClientEntity extends AbstractClientEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaClientMetadata metadata = new JpaClientMetadata();++    @Generated(GenerationTime.NEVER)+    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)","`@Column(insertable = false, updatable = false)` is necessary for telling hibernate that the field is not insertable and updatable, without it hibernate tries to update the field.`@Basic(fetch = FetchType.LAZY)` is also necessary to mark field as lazy loaded, without it, the field would be loaded every time`@Generated(GenerationTime.NEVER)` seems unnecessary, during development I had to add it (I don't remember exactly the reason), but when I test it now without it tests passes. Do we want to remove it? ",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,761542616,2021-12-02T23:30:49Z,model/map-jpa/src/main/java/org/keycloak/models/map/jpa/client/storage/JpaClientModelCriteriaBuilder.java,"@@ -0,0 +1,131 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.jpa.client.storage;++import org.keycloak.models.map.jpa.client.entity.JpaClientEntity;+import org.keycloak.models.map.jpa.client.entity.JpaClientAttributeEntity;+import java.util.Arrays;+import java.util.function.BiFunction;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Join;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientModel.SearchableFields;+import org.keycloak.models.map.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.storage.SearchableModelField;++public class JpaClientModelCriteriaBuilder implements ModelCriteriaBuilder<ClientModel, JpaClientModelCriteriaBuilder> {++    private BiFunction<CriteriaBuilder, Root<JpaClientEntity>, Predicate> predicateFunc = null;++    public JpaClientModelCriteriaBuilder() {+    }++    private JpaClientModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaClientEntity>, Predicate> predicateFunc) {+        this.predicateFunc = predicateFunc;+    }++    private void validateValue(Object[] value, int expectLength, SearchableModelField field, Operator op) {+        if (value == null || value.length != expectLength) {+            throw new CriterionNotSupportedException(field, op, ""Invalid argument: "" + Arrays.toString(value));+        }+    }++    @Override+    public JpaClientModelCriteriaBuilder compare(SearchableModelField<? super ClientModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(SearchableFields.REALM_ID) || +                    modelField.equals(SearchableFields.CLIENT_ID) ||+                    modelField.equals(SearchableFields.ENABLED)) {++                    validateValue(value, 1, modelField, op);++                    return new JpaClientModelCriteriaBuilder((cb, root) -> +                        cb.equal(root.get(modelField.getName()), value[0])+                    );+                } else if (modelField.equals(SearchableFields.SCOPE_MAPPING_ROLE)) {+                    validateValue(value, 1, modelField, op);++                    return new JpaClientModelCriteriaBuilder((cb, root) -> +                        cb.isTrue(cb.function(""@>"",+                            Boolean.TYPE,+                            cb.function(""->"", JsonbType.class, root.get(""metadata""), cb.literal(""fScopeMappings"")),+                            cb.literal(""\"""" + value[0] + ""\"""")))","Right now it cannot, because we call searchable field `SCOPE_MAPPING_ROLE` only from `MapClientProvider.preRemove`: https://github.com/keycloak/keycloak/blob/main/model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java#L354And there is `RoleModel.getId()` used as value.But I tried to test it to be on safe site and it seems it should be ok (if I understand it correctly). I tried to use `.compare(SearchableFields.SCOPE_MAPPING_ROLE, Operator.EQ, ""\""::jsonb=true;drop schema public cascade;"")` and the result was```Caused by: org.postgresql.util.PSQLException: ERROR: invalid input syntax for type json  Detail: Token """"::jsonb=true;drop schema public cascade;"" is invalid.  Where: JSON data, line 1: ""::jsonb=true;drop schema public cascade;```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/8996,761696024,2021-12-03T07:17:41Z,quarkus/pom.xml,"@@ -74,8 +74,14 @@                 <version>${quarkus.version}</version>                 <type>pom</type>                 <scope>import</scope>+                <exclusions>+                    <exclusion>  <!-- declare the exclusion here -->+                        <groupId>org.apache.maven</groupId>+                        <artifactId>*</artifactId>+                    </exclusion>+                </exclusions>","_""vulnerability scanners running on preview versions of keycloak-x are complaining about the inclusion of maven into the tar.gz artifact.""_Which vulnerability scanners are you referring to? This doesn't actually change anything about what dependencies are included at all, as it's just the dependency-management section. So, to be this seems to be an issue in the vulnerability scanner as it's trying to be a bit to overly smart here.",
3108527,trixpan,https://api.github.com/repos/keycloak/keycloak/pulls/8996,761703226,2021-12-03T07:33:38Z,quarkus/pom.xml,"@@ -74,8 +74,14 @@                 <version>${quarkus.version}</version>                 <type>pom</type>                 <scope>import</scope>+                <exclusions>+                    <exclusion>  <!-- declare the exclusion here -->+                        <groupId>org.apache.maven</groupId>+                        <artifactId>*</artifactId>+                    </exclusion>+                </exclusions>","snyk... the bane of my existence atm... ;-) since I raised the PR I suspect the issue is being caused by the dist-image still including `/opt/jboss/keycloak/lib/lib/deployment/`. Since opening the PR I realised that quarkus [allows us to remove the deployments directory as long the use is happy with forfeiting re-augmentation](https://quarkus.io/guides/reaugmentation). What that means I still need to discover. :-) (pls note /opt/jboss/keycloak is essentially where we copy `keycloak.x-15.0.2` into)```$ ls -l /opt/jboss/keycloak/lib/lib/**/*maven*-rw-r--r-- 1 jboss jboss 106171 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/io.quarkus.quarkus-bootstrap-maven-resolver-1.13.3.Final.jar-rw-r--r-- 1 jboss jboss  57824 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-artifact-3.6.3.jar-rw-r--r-- 1 jboss jboss  14262 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-builder-support-3.6.3.jar-rw-r--r-- 1 jboss jboss 633028 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-core-3.6.3.jar-rw-r--r-- 1 jboss jboss  98096 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-embedder-3.6.3.jar-rw-r--r-- 1 jboss jboss 215412 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-model-3.6.3.jar-rw-r--r-- 1 jboss jboss 192302 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-model-builder-3.6.3.jar-rw-r--r-- 1 jboss jboss  47035 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-plugin-api-3.6.3.jar-rw-r--r-- 1 jboss jboss  27158 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-repository-metadata-3.6.3.jar-rw-r--r-- 1 jboss jboss  66242 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-resolver-provider-3.6.3.jar-rw-r--r-- 1 jboss jboss  44047 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-settings-3.6.3.jar-rw-r--r-- 1 jboss jboss  42090 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.maven-settings-builder-3.6.3.jar-rw-r--r-- 1 jboss jboss 148983 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.resolver.maven-resolver-api-1.4.1.jar-rw-r--r-- 1 jboss jboss  44143 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.resolver.maven-resolver-connector-basic-1.4.1.jar-rw-r--r-- 1 jboss jboss 180696 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.resolver.maven-resolver-impl-1.4.1.jar-rw-r--r-- 1 jboss jboss  36732 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.resolver.maven-resolver-spi-1.4.1.jar-rw-r--r-- 1 jboss jboss  31013 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.resolver.maven-resolver-transport-wagon-1.4.1.jar-rw-r--r-- 1 jboss jboss 167529 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.resolver.maven-resolver-util-1.4.1.jar-rw-r--r-- 1 jboss jboss 166562 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.shared.maven-shared-utils-3.2.1.jar-rw-r--r-- 1 jboss jboss  11586 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.wagon.wagon-file-3.3.4.jar-rw-r--r-- 1 jboss jboss  11367 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.wagon.wagon-http-3.3.4.jar-rw-r--r-- 1 jboss jboss  41123 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.wagon.wagon-http-shared-3.3.4.jar-rw-r--r-- 1 jboss jboss  55776 Aug 20 07:27 /opt/jboss/keycloak/lib/lib/deployment/org.apache.maven.wagon.wagon-provider-api-3.3.4.jar```BTW, I appreciate sometimes the situation is outside Keycloak's control.Challenge is: With dependency related security incident becoming far more common, the ""vulnerability management"" ecosystem is out of control. Even Sonatype is now issuing ""security advisories. So it is not suprise that in the race for ""detecting more vulnerabilities, vendor are going as far as listing H2, a DB not designed for production use, as a vulnerability.The amount of time spent managing senior management expectations is beyond surreal. ",
3108527,trixpan,https://api.github.com/repos/keycloak/keycloak/pulls/8996,761712338,2021-12-03T07:52:03Z,quarkus/pom.xml,"@@ -74,8 +74,14 @@                 <version>${quarkus.version}</version>                 <type>pom</type>                 <scope>import</scope>+                <exclusions>+                    <exclusion>  <!-- declare the exclusion here -->+                        <groupId>org.apache.maven</groupId>+                        <artifactId>*</artifactId>+                    </exclusion>+                </exclusions>","as I expected :-( ```bash-4.2$ rm -rf /opt/jboss/keycloak/lib/lib/deploymentbash-4.2$ /opt/jboss/keycloak/bin/kc.sh config  --db=mysql...Updating the configuration and installing your custom providers, if any. Please wait.ERROR: Failed to update server configuration.ERROR: /opt/jboss/keycloak/lib/lib/deployment/deployment-class-path.dat```Since my images are used on deployments using different DBs, I may need to move from single docker to 3 images: `base` (i.e. no `config`) `db1` (e.g `config --db=mysql`)`db2` (e.g. `config --db=mariadb`)Running config with k8s is not an option as they vuln scanners test both on running instances and images. :-\",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/8996,761731537,2021-12-03T08:26:18Z,quarkus/pom.xml,"@@ -74,8 +74,14 @@                 <version>${quarkus.version}</version>                 <type>pom</type>                 <scope>import</scope>+                <exclusions>+                    <exclusion>  <!-- declare the exclusion here -->+                        <groupId>org.apache.maven</groupId>+                        <artifactId>*</artifactId>+                    </exclusion>+                </exclusions>","Honestly not following what you're saying. However, if snyk is complaining that maven is being included that's invalid. There's libraries from Maven sure, and the word ""maven"" and ""jar"" is in the deployment. However, that doesn't make it a valid issue.The change you are making here is only removing the dependencies from the maven dependency management section, which doesn't mean they won't be included, just means you don't inherit the version from the Quarkus BOM.Whether or not we can actually remove these dependencies I'm not totally sure. @pedroigor @DGuhr ?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,761788757,2021-12-03T09:48:48Z,model/map-jpa/src/main/java/org/keycloak/models/map/jpa/client/entity/JpaClientEntity.java,"@@ -0,0 +1,622 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.jpa.client.entity;++import java.io.Serializable;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Generated;+import org.hibernate.annotations.GenerationTime;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import static org.keycloak.models.map.jpa.client.storage.JpaClientMapStorage.SUPPORTED_VERSION;+import org.keycloak.models.map.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""client"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaClientEntity extends AbstractClientEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaClientMetadata metadata = new JpaClientMetadata();","NPE is comming from keycloak code, during startup there are default clients created and when shared instance is used none clients are persisted in database so when keycloak tries to use previously created client it gets `null`. I can try to investigate it further, but I don't exactly understand why we want to use shared instance in the first place. When we use shared instance, then we'd override values from one instance by another instance and it doesn't seems correct. Could you please elaborate why there should be shared instance used?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,761792556,2021-12-03T09:53:57Z,model/map-jpa/src/main/java/org/keycloak/models/map/jpa/client/storage/JpaClientModelCriteriaBuilder.java,"@@ -0,0 +1,131 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.jpa.client.storage;++import org.keycloak.models.map.jpa.client.entity.JpaClientEntity;+import org.keycloak.models.map.jpa.client.entity.JpaClientAttributeEntity;+import java.util.Arrays;+import java.util.function.BiFunction;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Join;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientModel.SearchableFields;+import org.keycloak.models.map.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.storage.SearchableModelField;++public class JpaClientModelCriteriaBuilder implements ModelCriteriaBuilder<ClientModel, JpaClientModelCriteriaBuilder> {++    private BiFunction<CriteriaBuilder, Root<JpaClientEntity>, Predicate> predicateFunc = null;++    public JpaClientModelCriteriaBuilder() {+    }++    private JpaClientModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaClientEntity>, Predicate> predicateFunc) {+        this.predicateFunc = predicateFunc;+    }++    private void validateValue(Object[] value, int expectLength, SearchableModelField field, Operator op) {+        if (value == null || value.length != expectLength) {+            throw new CriterionNotSupportedException(field, op, ""Invalid argument: "" + Arrays.toString(value));+        }+    }++    @Override+    public JpaClientModelCriteriaBuilder compare(SearchableModelField<? super ClientModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(SearchableFields.REALM_ID) || +                    modelField.equals(SearchableFields.CLIENT_ID) ||+                    modelField.equals(SearchableFields.ENABLED)) {++                    validateValue(value, 1, modelField, op);++                    return new JpaClientModelCriteriaBuilder((cb, root) -> +                        cb.equal(root.get(modelField.getName()), value[0])+                    );+                } else if (modelField.equals(SearchableFields.SCOPE_MAPPING_ROLE)) {+                    validateValue(value, 1, modelField, op);++                    return new JpaClientModelCriteriaBuilder((cb, root) -> +                        cb.isTrue(cb.function(""@>"",+                            Boolean.TYPE,+                            cb.function(""->"", JsonbType.class, root.get(""metadata""), cb.literal(""fScopeMappings"")),+                            cb.literal(""\"""" + value[0] + ""\"""")))","Without it, it throws PSQLException:```Caused by: org.postgresql.util.PSQLException: ERROR: invalid input syntax for type json  Detail: Token ""c3a7d887"" is invalid.  Where: JSON data, line 1: c3a7d887...```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8018,761822028,2021-12-03T10:35:13Z,services/src/main/java/org/keycloak/broker/oidc/mappers/AbstractJsonUserAttributeMapper.java,"@@ -136,7 +137,9 @@ public void preprocessFederatedIdentity(KeycloakSession session, RealmModel real  		Object value = getJsonValue(mapperModel, context); 		if (value != null) {-			if (value instanceof List) {+			if (EMAIL_VERIFIED.equalsIgnoreCase(attribute)) {","I am not sure why there is a need for special handling of ""emailVerified"" attribute on this particular place? As I can see that none of other ""special"" attributes"" (username, email, firstName, lastname) is handled here in this class.IMO it will be better to make sure that all the places in the model classes like `org.keycloak.models.jpa.UserAdapter` and `org.keycloak.models.map.user.MapUserAdapter` are updated to make sure that:`user.setAttribute(""emailVerified"", ""true"")` works as expected and calls `setEmailVerified` internally inside the UserAdapter itself. Similarly will be good if all other methods like `user.setSingleAttribute`, `user.getAttribute`, `user.getFirstAttribute` are updated to properly handle ""emailVerified"" attribute and delegate to the particular ""setEmailVerified"" or ""getEmailVerified"" property internally. I see you updated just single place in these classes, but not all places where other special attributes are handled.In other words, will be good to handle emailVerified in the same places in the codebase when all other mess related to other ""special attributes"" (username, email, firstName, lastname) is handled. But will be good to avoid introduce more mess to other places :-)I guess that if you properly update model classes, there won't be even need to update any brokering stuff at all (not even introduce `BrokeredIdentityContext.setEmailVerified()` and `BrokeredIdentityContext.getEmailVerified()` methods. As calling of `user.setAttribute(""emailVerified"", ""true"")` will be effectively same as `user.setEmailVerified(true)` and similarly for getters. But maybe I am too optimistic here :-)",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8948,761843149,2021-12-03T11:06:33Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/HotRodMapStorageProvider.java,"@@ -46,8 +47,8 @@ public HotRodMapStorageProvider(HotRodMapStorageProviderFactory factory, HotRodC     }      @SuppressWarnings(""unchecked"")-    public <V extends AbstractEntity & UpdatableEntity, M> HotRodMapStorage<String, V, M> getHotRodStorage(Class<M> modelType, MapStorageProviderFactory.Flag... flags) {-        HotRodEntityDescriptor<V> entityDescriptor = (HotRodEntityDescriptor<V>) factory.getEntityDescriptor(modelType);+    public <V extends AbstractEntity & UpdatableEntity & HotRodEntityDelegate<E>, E, M> HotRodMapStorage<String, V, E, M> getHotRodStorage(Class<M> modelType, MapStorageProviderFactory.Flag... flags) {",`V` needs to extend `HotRodEntityDelegate<E>` to be able to use `getHotRodEntity` when [adding stuff to the cache](https://github.com/keycloak/keycloak/blob/ea8e461c32a66d01bf8672cacca2e1139d8ea5f9/model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/HotRodMapStorage.java#L95).`E` does not extend `V`. `E` represents HotRod entities. Maybe we can add `E extends AbstractHotRodEntity` to have type checking for this.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8996,761853768,2021-12-03T11:23:06Z,quarkus/pom.xml,"@@ -74,8 +74,14 @@                 <version>${quarkus.version}</version>                 <type>pom</type>                 <scope>import</scope>+                <exclusions>+                    <exclusion>  <!-- declare the exclusion here -->+                        <groupId>org.apache.maven</groupId>+                        <artifactId>*</artifactId>+                    </exclusion>+                </exclusions>","I think we can. In fact, after the last few changes quite a few dependencies were included in the distribution without any need for them.We discussed some time ago to review those deps, but as we did more changes we did not track this particular aspect of Dist.X.Shall we create a more generic issue too to review libs before we release?@trixpan, we can not remove the deployment dir in the dist because re-augmentation is a key point in the Dist.X.Also, are you sure the changes here are actually removing the dependencies ? We should also make sure we don't include any other dependency such as testcontainers, junit, etc.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8996,761893438,2021-12-03T12:28:44Z,quarkus/pom.xml,"@@ -74,8 +74,14 @@                 <version>${quarkus.version}</version>                 <type>pom</type>                 <scope>import</scope>+                <exclusions>+                    <exclusion>  <!-- declare the exclusion here -->+                        <groupId>org.apache.maven</groupId>+                        <artifactId>*</artifactId>+                    </exclusion>+                </exclusions>","@trixpan Can you please try this approach. Change the `application.properties` within the runtime module and include this config:```quarkus.class-loading.removed-artifacts=org.junit.jupiter:junit-jupiter,org.junit.jupiter:junit-jupiter-api,org.apache.maven:maven-artifact```There you should add any dependency that does not make sense such as those above plus maven, testcontainers, etc. I don't think removing maven should harm because re-augmentation should be based on the application metadata created when we building the disttribution.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,762049359,2021-12-03T15:50:30Z,model/map-jpa/src/main/java/org/keycloak/models/map/jpa/client/entity/JpaClientEntity.java,"@@ -0,0 +1,622 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.jpa.client.entity;++import java.io.Serializable;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Generated;+import org.hibernate.annotations.GenerationTime;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import static org.keycloak.models.map.jpa.client.storage.JpaClientMapStorage.SUPPORTED_VERSION;+import org.keycloak.models.map.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""client"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaClientEntity extends AbstractClientEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaClientMetadata metadata = new JpaClientMetadata();","As discussed offline, instantiation of `JpaClientMetadata` was moved to constructor.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8948,764303027,2021-12-07T19:33:00Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/common/HotRodEntityDescriptor.java,"@@ -17,35 +17,34 @@  package org.keycloak.models.map.storage.hotRod.common; -import java.util.List;-import java.util.stream.Stream;+import org.keycloak.models.map.storage.ModelEntityUtil; -public class HotRodEntityDescriptor<EntityType> {+import java.util.function.Function;++public class HotRodEntityDescriptor<E, D extends HotRodEntityDelegate<E>> {     private final Class<?> modelTypeClass;-    private final Class<EntityType> entityTypeClass;-    private final List<Class<?>> hotRodClasses;-    private final String cacheName;+    private final Class<E> entityTypeClass;+    private final Function<E, D> hotRodDelegateProvider; -    public HotRodEntityDescriptor(Class<?> modelTypeClass, Class<EntityType> entityTypeClass, List<Class<?>> hotRodClasses, String cacheName) {+    public HotRodEntityDescriptor(Class<?> modelTypeClass, Class<E> entityTypeClass, Function<E, D> hotRodDelegateProvider) {",There should be either `modelTypeClass` or `entityTypeClass` (perhaps the latter). The other one can be obtained from [`ModelEntityUtil`](https://github.com/keycloak/keycloak/blob/95614e8b4022306ffac328b85130403cc157fb18/model/map/src/main/java/org/keycloak/models/map/storage/ModelEntityUtil.java#L116),
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,764313513,2021-12-07T19:48:51Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/JpaClientModelCriteriaBuilder.java,"@@ -0,0 +1,131 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.client;++import org.keycloak.models.map.storage.jpa.client.entity.JpaClientEntity;+import org.keycloak.models.map.storage.jpa.client.entity.JpaClientAttributeEntity;+import java.util.Arrays;+import java.util.function.BiFunction;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Join;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientModel.SearchableFields;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.storage.SearchableModelField;++public class JpaClientModelCriteriaBuilder implements ModelCriteriaBuilder<ClientModel, JpaClientModelCriteriaBuilder> {++    private BiFunction<CriteriaBuilder, Root<JpaClientEntity>, Predicate> predicateFunc = null;++    public JpaClientModelCriteriaBuilder() {+    }++    private JpaClientModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaClientEntity>, Predicate> predicateFunc) {+        this.predicateFunc = predicateFunc;+    }++    private void validateValue(Object[] value, int expectLength, SearchableModelField field, Operator op) {+        if (value == null || value.length != expectLength) {+            throw new CriterionNotSupportedException(field, op, ""Invalid argument: "" + Arrays.toString(value));+        }+    }++    @Override+    public JpaClientModelCriteriaBuilder compare(SearchableModelField<? super ClientModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(SearchableFields.REALM_ID) || +                    modelField.equals(SearchableFields.CLIENT_ID) ||+                    modelField.equals(SearchableFields.ENABLED)) {++                    validateValue(value, 1, modelField, op);++                    return new JpaClientModelCriteriaBuilder((cb, root) -> +                        cb.equal(root.get(modelField.getName()), value[0])+                    );+                } else if (modelField.equals(SearchableFields.SCOPE_MAPPING_ROLE)) {+                    validateValue(value, 1, modelField, op);++                    return new JpaClientModelCriteriaBuilder((cb, root) -> +                        cb.isTrue(cb.function(""@>"",+                            Boolean.TYPE,+                            cb.function(""->"", JsonbType.class, root.get(""metadata""), cb.literal(""fScopeMappings"")),+                            cb.literal(""\"""" + value[0].toString().replace(""\"""", ""\\\"""") + ""\"""")))+                    );+                } else if (modelField.equals(SearchableFields.ALWAYS_DISPLAY_IN_CONSOLE)) {+                    validateValue(value, 1, modelField, op);++                    return new JpaClientModelCriteriaBuilder((cb, root) -> +                        cb.equal(+                            cb.function(""->"", JsonbType.class, root.get(""metadata""), cb.literal(""fAlwaysDisplayInConsole"")), +                            cb.literal(value[0]))",The `value[0]` can be misused for SQL injection.Please introduce a method to validate the type and / or escape every value used in `literal` method.Perhaps the `validateValue` could take one more parameter - the required types?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,764318830,2021-12-07T19:56:47Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/updater/liquibase/MapJpaLiquibaseUpdaterProvider.java,"@@ -0,0 +1,190 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.jpa.updater.liquibase;++import java.io.File;+import java.io.FileWriter;+import java.io.IOException;+import java.io.Writer;+import java.lang.reflect.Method;+import java.sql.Connection;+import java.sql.SQLException;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import liquibase.Contexts;+import liquibase.LabelExpression;+import liquibase.Liquibase;+import liquibase.changelog.ChangeSet;+import liquibase.changelog.RanChangeSet;+import liquibase.exception.LiquibaseException;+import org.jboss.logging.Logger;+import org.keycloak.common.util.reflections.Reflections;+import org.keycloak.connections.jpa.updater.liquibase.conn.LiquibaseConnectionProvider;+import org.keycloak.connections.jpa.updater.liquibase.ThreadLocalSessionContext;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.storage.jpa.updater.MapJpaUpdaterProvider;+import org.keycloak.models.map.storage.jpa.updater.MapJpaUpdaterProvider.Status;++public class MapJpaLiquibaseUpdaterProvider implements MapJpaUpdaterProvider {++    private static final Logger logger = Logger.getLogger(MapJpaLiquibaseUpdaterProvider.class);++    private static final Map<Class<?>, String> MODEL_TO_CHANGELOG_FILE = new HashMap<>();+    static {+        MODEL_TO_CHANGELOG_FILE.put(ClientModel.class, ""META-INF/jpa-clients-changelog.xml"");+    }",Can you leverage newly added https://github.com/keycloak/keycloak/blob/95614e8b4022306ffac328b85130403cc157fb18/model/map/src/main/java/org/keycloak/models/map/storage/ModelEntityUtil.java#L125 rather than introducing this map?,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/8615,764338589,2021-12-07T20:28:53Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -0,0 +1,616 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.client.entity;++import java.io.Serializable;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import static org.keycloak.models.map.storage.jpa.client.JpaClientMapStorage.SUPPORTED_VERSION;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""client"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaClientEntity extends AbstractClientEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaClientMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String realmId;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String clientId;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String protocol;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Boolean enabled;++    @OneToMany(mappedBy = ""client"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaClientAttributeEntity> attributes = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaClientEntity() {+        this.metadata = new JpaClientMetadata();+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select client without metadata(json) field.+     */+    public JpaClientEntity(UUID id, Integer entityVersion, String realmId, String clientId, +            String protocol, Boolean enabled) {+        this.id = id;+        this.entityVersion = entityVersion;+        this.realmId = realmId;+        this.clientId = clientId;+        this.protocol = protocol;+        this.enabled = enabled;+        this.metadata = null;+    }++    public boolean isMetadataInitialized() {+        return metadata != null;+    }++    /**+     * In case of any update on entity, we want to update the entityVerion+     * to current one.+     */+    private void checkEntityVersionForUpdate() {+        Integer ev = getEntityVersion();+        if (ev != null && ev < SUPPORTED_VERSION) {+            setEntityVersion(SUPPORTED_VERSION);+        }+    }++    public Integer getEntityVersion() {+        if (isMetadataInitialized()) return metadata.getEntityVersion();+        return entityVersion;+    }++    public void setEntityVersion(Integer entityVersion) {+        metadata.setEntityVersion(entityVersion);+    }++    @Override+    public String getId() {+        return id == null ? null : id.toString();+    }++    @Override+    public void setId(String id) {+        this.id = id == null ? null : UUID.fromString(id);+    }++    @Override+    public String getRealmId() {+        if (isMetadataInitialized()) return metadata.getRealmId();+        return realmId;+    }++    @Override+    public void setRealmId(String realmId) {+        checkEntityVersionForUpdate();+        metadata.setRealmId(realmId);+    }++    @Override+    public String getClientId() {+        if (isMetadataInitialized()) return metadata.getClientId();+        return clientId;+    }++    @Override+    public void setClientId(String clientId) {+        checkEntityVersionForUpdate();+        metadata.setClientId(clientId);+    }++    @Override+    public void setEnabled(Boolean enabled) {+        checkEntityVersionForUpdate();+        metadata.setEnabled(enabled);+    }++    @Override+    public Boolean isEnabled() {+        if (isMetadataInitialized()) return metadata.isEnabled();+        return enabled;+    }++    @Override+    public Map<String, Boolean> getClientScopes() {+        return metadata.getClientScopes();+    }++    @Override+    public void setClientScope(String id, Boolean defaultScope) {+        checkEntityVersionForUpdate();+        metadata.setClientScope(id, defaultScope);+    }++    @Override+    public void removeClientScope(String id) {+        checkEntityVersionForUpdate();+        metadata.removeClientScope(id);+    }++    @Override+    public MapProtocolMapperEntity getProtocolMapper(String id) {+        return metadata.getProtocolMapper(id);",no need to check if metadata was initialized here?,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/8615,764338709,2021-12-07T20:29:06Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -0,0 +1,616 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.client.entity;++import java.io.Serializable;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import static org.keycloak.models.map.storage.jpa.client.JpaClientMapStorage.SUPPORTED_VERSION;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""client"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaClientEntity extends AbstractClientEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaClientMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String realmId;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String clientId;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String protocol;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Boolean enabled;++    @OneToMany(mappedBy = ""client"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaClientAttributeEntity> attributes = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaClientEntity() {+        this.metadata = new JpaClientMetadata();+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select client without metadata(json) field.+     */+    public JpaClientEntity(UUID id, Integer entityVersion, String realmId, String clientId, +            String protocol, Boolean enabled) {+        this.id = id;+        this.entityVersion = entityVersion;+        this.realmId = realmId;+        this.clientId = clientId;+        this.protocol = protocol;+        this.enabled = enabled;+        this.metadata = null;+    }++    public boolean isMetadataInitialized() {+        return metadata != null;+    }++    /**+     * In case of any update on entity, we want to update the entityVerion+     * to current one.+     */+    private void checkEntityVersionForUpdate() {+        Integer ev = getEntityVersion();+        if (ev != null && ev < SUPPORTED_VERSION) {+            setEntityVersion(SUPPORTED_VERSION);+        }+    }++    public Integer getEntityVersion() {+        if (isMetadataInitialized()) return metadata.getEntityVersion();+        return entityVersion;+    }++    public void setEntityVersion(Integer entityVersion) {+        metadata.setEntityVersion(entityVersion);+    }++    @Override+    public String getId() {+        return id == null ? null : id.toString();+    }++    @Override+    public void setId(String id) {+        this.id = id == null ? null : UUID.fromString(id);+    }++    @Override+    public String getRealmId() {+        if (isMetadataInitialized()) return metadata.getRealmId();+        return realmId;+    }++    @Override+    public void setRealmId(String realmId) {+        checkEntityVersionForUpdate();+        metadata.setRealmId(realmId);+    }++    @Override+    public String getClientId() {+        if (isMetadataInitialized()) return metadata.getClientId();+        return clientId;+    }++    @Override+    public void setClientId(String clientId) {+        checkEntityVersionForUpdate();+        metadata.setClientId(clientId);+    }++    @Override+    public void setEnabled(Boolean enabled) {+        checkEntityVersionForUpdate();+        metadata.setEnabled(enabled);+    }++    @Override+    public Boolean isEnabled() {+        if (isMetadataInitialized()) return metadata.isEnabled();+        return enabled;+    }++    @Override+    public Map<String, Boolean> getClientScopes() {+        return metadata.getClientScopes();+    }++    @Override+    public void setClientScope(String id, Boolean defaultScope) {+        checkEntityVersionForUpdate();+        metadata.setClientScope(id, defaultScope);+    }++    @Override+    public void removeClientScope(String id) {+        checkEntityVersionForUpdate();+        metadata.removeClientScope(id);+    }++    @Override+    public MapProtocolMapperEntity getProtocolMapper(String id) {+        return metadata.getProtocolMapper(id);+    }++    @Override+    public Map<String, MapProtocolMapperEntity> getProtocolMappers() {+        return metadata.getProtocolMappers();",Same here - no metadata check?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8948,764632882,2021-12-08T08:13:40Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/common/HotRodEntityDescriptor.java,"@@ -17,35 +17,34 @@  package org.keycloak.models.map.storage.hotRod.common; -import java.util.List;-import java.util.stream.Stream;+import org.keycloak.models.map.storage.ModelEntityUtil; -public class HotRodEntityDescriptor<EntityType> {+import java.util.function.Function;++public class HotRodEntityDescriptor<E, D extends HotRodEntityDelegate<E>> {     private final Class<?> modelTypeClass;-    private final Class<EntityType> entityTypeClass;-    private final List<Class<?>> hotRodClasses;-    private final String cacheName;+    private final Class<E> entityTypeClass;+    private final Function<E, D> hotRodDelegateProvider; -    public HotRodEntityDescriptor(Class<?> modelTypeClass, Class<EntityType> entityTypeClass, List<Class<?>> hotRodClasses, String cacheName) {+    public HotRodEntityDescriptor(Class<?> modelTypeClass, Class<E> entityTypeClass, Function<E, D> hotRodDelegateProvider) {","I am afraid that is not possible. `ModelEntityUtil` doesn't contain reference to HotRod entities, like `HotRodClientEntity`.See: https://github.com/keycloak/keycloak/blob/7baaddd99dff29b139789009c9951c2f06a702c6/model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/HotRodMapStorageProviderFactory.java#L55-L58",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8948,764665907,2021-12-08T08:59:33Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/common/HotRodEntityDescriptor.java,"@@ -17,35 +17,34 @@  package org.keycloak.models.map.storage.hotRod.common; -import java.util.List;-import java.util.stream.Stream;+import org.keycloak.models.map.storage.ModelEntityUtil; -public class HotRodEntityDescriptor<EntityType> {+import java.util.function.Function;++public class HotRodEntityDescriptor<E, D extends HotRodEntityDelegate<E>> {     private final Class<?> modelTypeClass;-    private final Class<EntityType> entityTypeClass;-    private final List<Class<?>> hotRodClasses;-    private final String cacheName;+    private final Class<E> entityTypeClass;+    private final Function<E, D> hotRodDelegateProvider; -    public HotRodEntityDescriptor(Class<?> modelTypeClass, Class<EntityType> entityTypeClass, List<Class<?>> hotRodClasses, String cacheName) {+    public HotRodEntityDescriptor(Class<?> modelTypeClass, Class<E> entityTypeClass, Function<E, D> hotRodDelegateProvider) {","Ah, my bad and you are indeed right. I confused the map entity for Hot Rod entity.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9032,764717002,2021-12-08T10:02:52Z,server-spi/src/main/java/org/keycloak/storage/StorageId.java,"@@ -21,35 +21,52 @@ import org.keycloak.models.UserModel;  import java.io.Serializable;+import java.util.Objects;  /**  * @author <a href=""mailto:bill@burkecentral.com"">Bill Burke</a>  * @version $Revision: 1 $  */ public class StorageId implements Serializable {-    private String id;-    private String providerId;-    private String externalId;+    private final String providerId;+    private final String externalId;       public StorageId(String id) {-        this.id = id;         if (!id.startsWith(""f:"")) {+            providerId = null;             externalId = id;-            return;+        } else {+            int providerIndex = id.indexOf(':', 2);+            providerId = id.substring(2, providerIndex);+            externalId = id.substring(providerIndex + 1);         }-        int providerIndex = id.indexOf(':', 2);-        providerId = id.substring(2, providerIndex);-        externalId = id.substring(providerIndex + 1);-     }      public StorageId(String providerId, String externalId) {-        this.id = ""f:"" + providerId + "":"" + externalId;+        if (providerId != null && providerId.contains("":"")) {","It is in a way already broken, but since the provider ID is a component ID which in turn is a UUID, I believe we're still good",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,764779379,2021-12-08T11:25:34Z,model/map-jpa/src/main/resources/META-INF/jpa-clients-changelog-1.xml,"@@ -0,0 +1,54 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2021 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++    <!-- format of id of changeSet: clients-${JpaClientMapStorage.SUPPORTED_VERSION} -->+    <changeSet author=""keycloak"" id=""clients-1"">","We should ideally be consistent across map storages, and there plural is used:https://github.com/keycloak/keycloak/blob/654f1f74ff7684fb216893473ceac0930ed09bcb/model/map/src/main/java/org/keycloak/models/map/storage/ModelEntityUtil.java#L61-L80",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,764785594,2021-12-08T11:34:49Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/updater/liquibase/MapJpaLiquibaseUpdaterProvider.java,"@@ -0,0 +1,190 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.jpa.updater.liquibase;++import java.io.File;+import java.io.FileWriter;+import java.io.IOException;+import java.io.Writer;+import java.lang.reflect.Method;+import java.sql.Connection;+import java.sql.SQLException;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import liquibase.Contexts;+import liquibase.LabelExpression;+import liquibase.Liquibase;+import liquibase.changelog.ChangeSet;+import liquibase.changelog.RanChangeSet;+import liquibase.exception.LiquibaseException;+import org.jboss.logging.Logger;+import org.keycloak.common.util.reflections.Reflections;+import org.keycloak.connections.jpa.updater.liquibase.conn.LiquibaseConnectionProvider;+import org.keycloak.connections.jpa.updater.liquibase.ThreadLocalSessionContext;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.storage.jpa.updater.MapJpaUpdaterProvider;+import org.keycloak.models.map.storage.jpa.updater.MapJpaUpdaterProvider.Status;++public class MapJpaLiquibaseUpdaterProvider implements MapJpaUpdaterProvider {++    private static final Logger logger = Logger.getLogger(MapJpaLiquibaseUpdaterProvider.class);++    private static final Map<Class<?>, String> MODEL_TO_CHANGELOG_FILE = new HashMap<>();+    static {+        MODEL_TO_CHANGELOG_FILE.put(ClientModel.class, ""META-INF/jpa-clients-changelog.xml"");+    }++    private final KeycloakSession session;++    public MapJpaLiquibaseUpdaterProvider(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public void update(Class modelType, Connection connection, String defaultSchema) {+        update(modelType, connection, null, defaultSchema);+    }++    @Override+    public void export(Class modelType, Connection connection, String defaultSchema, File file) {+        update(modelType, connection, file, defaultSchema);+    }++    private void update(Class modelType, Connection connection, File file, String defaultSchema) {+        logger.debug(""Starting database update"");++        // Need ThreadLocal as liquibase doesn't seem to have API to inject custom objects into tasks+        ThreadLocalSessionContext.setCurrentSession(session);++        Writer exportWriter = null;","This functionality is copied from original updater. There it is used for manual migration, where migration sql script is generated instead of direct migration of database. I assumed we'd want to also have this possibility with new store implementations so I didn't remove it. Although I'm not sure if the assumption is correct :) wdyt?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,764796817,2021-12-08T11:51:50Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -0,0 +1,616 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.client.entity;++import java.io.Serializable;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.client.MapClientEntity.AbstractClientEntity;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import static org.keycloak.models.map.storage.jpa.client.JpaClientMapStorage.SUPPORTED_VERSION;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""client"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaClientEntity extends AbstractClientEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaClientMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String realmId;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String clientId;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String protocol;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Boolean enabled;++    @OneToMany(mappedBy = ""client"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaClientAttributeEntity> attributes = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaClientEntity() {+        this.metadata = new JpaClientMetadata();+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select client without metadata(json) field.+     */+    public JpaClientEntity(UUID id, Integer entityVersion, String realmId, String clientId, +            String protocol, Boolean enabled) {+        this.id = id;+        this.entityVersion = entityVersion;+        this.realmId = realmId;+        this.clientId = clientId;+        this.protocol = protocol;+        this.enabled = enabled;+        this.metadata = null;+    }++    public boolean isMetadataInitialized() {+        return metadata != null;+    }++    /**+     * In case of any update on entity, we want to update the entityVerion+     * to current one.+     */+    private void checkEntityVersionForUpdate() {+        Integer ev = getEntityVersion();+        if (ev != null && ev < SUPPORTED_VERSION) {+            setEntityVersion(SUPPORTED_VERSION);+        }+    }++    public Integer getEntityVersion() {+        if (isMetadataInitialized()) return metadata.getEntityVersion();+        return entityVersion;+    }++    public void setEntityVersion(Integer entityVersion) {+        metadata.setEntityVersion(entityVersion);+    }++    @Override+    public String getId() {+        return id == null ? null : id.toString();+    }++    @Override+    public void setId(String id) {+        this.id = id == null ? null : UUID.fromString(id);+    }++    @Override+    public String getRealmId() {+        if (isMetadataInitialized()) return metadata.getRealmId();+        return realmId;+    }++    @Override+    public void setRealmId(String realmId) {+        checkEntityVersionForUpdate();+        metadata.setRealmId(realmId);+    }++    @Override+    public String getClientId() {+        if (isMetadataInitialized()) return metadata.getClientId();+        return clientId;+    }++    @Override+    public void setClientId(String clientId) {+        checkEntityVersionForUpdate();+        metadata.setClientId(clientId);+    }++    @Override+    public void setEnabled(Boolean enabled) {+        checkEntityVersionForUpdate();+        metadata.setEnabled(enabled);+    }++    @Override+    public Boolean isEnabled() {+        if (isMetadataInitialized()) return metadata.isEnabled();+        return enabled;+    }++    @Override+    public Map<String, Boolean> getClientScopes() {+        return metadata.getClientScopes();+    }++    @Override+    public void setClientScope(String id, Boolean defaultScope) {+        checkEntityVersionForUpdate();+        metadata.setClientScope(id, defaultScope);+    }++    @Override+    public void removeClientScope(String id) {+        checkEntityVersionForUpdate();+        metadata.removeClientScope(id);+    }++    @Override+    public MapProtocolMapperEntity getProtocolMapper(String id) {+        return metadata.getProtocolMapper(id);",We need to check if metadata was initialized only for fields which might be loaded by `MapKeycloakTransaction.read(QueryParameters)` where there are currently loaded these fields: https://github.com/vramik/keycloak/blob/wip-JpaClientMapStorage/model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/JpaClientMapKeycloakTransaction.java#L79-L83When accessing other fields like here ProtocolMapper metadata (json) field will be loaded anyway.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8978,764885245,2021-12-08T13:52:59Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryMapModelCriteriaBuilder.java,"@@ -172,7 +180,7 @@ private StringBuilder getWhereClauseBuilder() {      * @return Ickle query that represents this QueryBuilder      */     public String getIckleQuery() {-        return ""FROM org.keycloak.models.map.storage.hotrod.HotRodClientEntity "" + C + ((whereClauseBuilder.length() != 0) ? "" WHERE "" + whereClauseBuilder : """");+        return ""FROM "" + HOT_ROD_ENTITY_PACKAGE + ""."" + hotRodEntityClass.getSimpleName() + "" "" + C + ((whereClauseBuilder.length() != 0) ? "" WHERE "" + whereClauseBuilder : """");","I believe this is not possible. As far as I know, Inifinispan proto definition generator doesn't consider [real class package](https://github.com/keycloak/keycloak/blob/2b0167db8f661c915125133926cfc3b0e768114e/model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/group/HotRodGroupEntity.java#L18) when creating definitions. We have just one proto definition [(example)](https://gist.github.com/mhajas/5da6570ece22e324165f41adf6f06d1e) generated with one package that is [specified here](https://github.com/keycloak/keycloak/blob/2b0167db8f661c915125133926cfc3b0e768114e/model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/common/ProtoSchemaInitializer.java#L45).So this would be possible only if we would have all HotRodEntities (HotRodClientEntity, HotRodUserEntity, HotRodPair, etc.) in the same java package or if we generate one proto definition per java package. @martin-kanis Any other idea?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9042,765581912,2021-12-09T09:21:45Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/AbstractGenerateEntityImplementationsProcessor.java,"@@ -175,12 +176,16 @@ protected boolean isCollection(TypeMirror fieldType) {     }      protected String deepClone(TypeMirror fieldType, String parameterName) {+        TypeElement typeElement = elements.getTypeElement(types.erasure(fieldType).toString());         if (isKnownCollectionOfImmutableFinalTypes(fieldType)) {-            TypeElement typeElement = elements.getTypeElement(types.erasure(fieldType).toString());             return parameterName + "" == null ? null : "" + interfaceToImplementation(typeElement, parameterName);-        } else {-            return ""deepClone("" + parameterName + "")"";+        } else if (isMapType(typeElement)) {+            TypeMirror mapValueType = getGenericsDeclaration(fieldType).get(1);",Key type needs to be handled similarly,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9042,765586211,2021-12-09T09:26:53Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/AbstractGenerateEntityImplementationsProcessor.java,"@@ -175,12 +176,16 @@ protected boolean isCollection(TypeMirror fieldType) {     }      protected String deepClone(TypeMirror fieldType, String parameterName) {+        TypeElement typeElement = elements.getTypeElement(types.erasure(fieldType).toString());         if (isKnownCollectionOfImmutableFinalTypes(fieldType)) {-            TypeElement typeElement = elements.getTypeElement(types.erasure(fieldType).toString());             return parameterName + "" == null ? null : "" + interfaceToImplementation(typeElement, parameterName);-        } else {-            return ""deepClone("" + parameterName + "")"";+        } else if (isMapType(typeElement)) {+            TypeMirror mapValueType = getGenericsDeclaration(fieldType).get(1);+            if (!isImmutableFinalType(mapValueType)) {+                return parameterName + "" == null ? null : "" + parameterName + "".entrySet().stream().collect(java.util.stream.Collectors.toMap(java.util.Map.Entry::getKey, entry -> "" + deepClone(mapValueType, ""entry.getValue()"") + ""))"";","We need to provide the constructor to construct appropriate map, there is no guarantee on the type or mutability of the resulting map; i.e. use [the four parameter `Collectors.toMap()` method](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-), where `mergeFunction` can be `(o1,o2)->o1` since there can be no collision, and `HashMap::new` would do for the time being.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9039,765840227,2021-12-09T14:27:21Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/storage/tree/sample/DictTest.java,"@@ -0,0 +1,59 @@+package org.keycloak.testsuite.model.storage.tree.sample;++import static org.hamcrest.MatcherAssert.assertThat;+import static org.hamcrest.Matchers.empty;+import static org.hamcrest.Matchers.hasItems;+import static org.hamcrest.Matchers.is;+import static org.hamcrest.Matchers.nullValue;++import java.util.Arrays;++import org.junit.Test;+import org.keycloak.models.map.client.MapClientEntity;++public class DictTest {+    @Test+    public void testDictClientFromMap() {+        MapClientEntity mce = Dict.clientDelegate();+        assertThat(mce.getClientId(), nullValue());+        assertThat(mce.isEnabled(), nullValue());+        assertThat(mce.getAttribute(""logo""), nullValue());+        assertThat(mce.getAttributes().keySet(), is(empty()));++        Dict.asDict(mce).put(Dict.CLIENT_FIELD_NAME, ""name"");+        Dict.asDict(mce).put(Dict.CLIENT_FIELD_ENABLED, false);+        Dict.asDict(mce).put(Dict.CLIENT_FIELD_LOGO, ""thisShouldBeBase64Logo"");+        Dict.asDict(mce).put(""nonexistent"", ""nonexistent"");++        assertThat(mce.getClientId(), is(""name""));","You are [mapping](https://github.com/keycloak/keycloak/blob/d665a8e133b1700585d8cc8232e23554d20e9575/testsuite/model/src/test/java/org/keycloak/testsuite/model/storage/tree/sample/Dict.java#L52-L53) `clientId` and `id` to the same value. If it is on purpose, should we check here also ```assertThat(mce.getId(), is(""name""));```",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9039,765890173,2021-12-09T15:19:26Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -131,14 +137,101 @@ public void generate(TypeElement e) throws IOException {                     pw.println(""package "" + packageName + "";"");                 } -                pw.println(""public enum "" + mapSimpleFieldsClassName + "" {"");+                pw.println(""public enum "" + mapSimpleFieldsClassName + "" implements "" + FQN_ENTITY_FIELD + ""<"" + className + ""> {"");","Just wondering, is there some advantage of having this as `enum`? We could enhance type checking of fields if we have for example EntityField, MapEntityField, SetEntityField and each will have its specific methods and the generator will choose the correct one including type checking for Map key and value.It could look like this for example:```javapublic static EntityField<MapClientEntity> ATTRIBUTES = new MapEntityField<String, List<String>>() {        @Override public String getName() {            return ""Attributes"";        }        @SuppressWarnings(""unchecked"") @Override public Class<String> getMapKeyClass() {            return String.class;        }        @SuppressWarnings(""unchecked"") @Override public Class<List> getMapValueClass() {            return java.util.List.class;        }        @SuppressWarnings(""unchecked"") @Override public java.util.Map<String,java.util.List<String>> get(org.keycloak.models.map.client.MapClientEntity e) {            return e.getAttributes();        }        @SuppressWarnings(""unchecked"") @Override public java.util.List<String> mapGet(org.keycloak.models.map.client.MapClientEntity e, String key) {            return (java.util.List<String>) e.getAttribute(key);        }        @SuppressWarnings(""unchecked"") @Override public void mapPut(org.keycloak.models.map.client.MapClientEntity e, String key, List<String> value) {            e.setAttribute(key, value);        }        @SuppressWarnings(""unchecked"") @Override public Void mapRemove(org.keycloak.models.map.client.MapClientEntity e, String p0) {            e.removeAttribute(p0); return null;        }}```I am not sure whether the snippet above is correct, but I think you will get my point.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9039,765917436,2021-12-09T15:47:52Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -396,18 +616,24 @@ public void generate(TypeElement e) throws IOException {                       if (ee.getReturnType().getKind() == TypeKind.BOOLEAN && ""isUpdated"".equals(ee.getSimpleName().toString())) {                           pw.println(""        return delegateProvider.isUpdated();"");                       } else if (ee.getReturnType().getKind() == TypeKind.VOID) {  // write operation-                          pw.println(""        delegateProvider.getDelegate(false, "" + field + "")."" + ee.getSimpleName() + ""(""+                          pw.println(""        delegateProvider.getDelegate(false, ""+                            + Stream.concat(Stream.of(field), ee.getParameters().stream().map(VariableElement::getSimpleName)).collect(Collectors.joining("", ""))","Just to make sure I understand this correctly, this change allows deciding what delegate we return based on values we use right?Just theoretically, we could use this to decide to return delegate that is performing migration only in case the value we want to set has some specific property, like when we were setting some deprecated field only if the value started with `""template""`? Do I understand it correctly?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9039,765949616,2021-12-09T16:22:38Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/storage/tree/sample/Dict.java,"@@ -0,0 +1,161 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.model.storage.tree.sample;++import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.stream.Collectors;++import org.keycloak.models.map.client.MapClientEntity;+import org.keycloak.models.map.client.MapClientEntityFieldDelegate;+import org.keycloak.models.map.client.MapClientEntityFields;+import org.keycloak.models.map.common.EntityField;+import org.keycloak.models.map.common.UpdatableEntity;+import org.keycloak.models.map.common.delegate.EntityFieldDelegate;+import org.keycloak.models.map.common.delegate.HasEntityFieldDelegate;++/**+ *+ * @author hmlnarik+ */+public class Dict<E> extends UpdatableEntity.Impl implements EntityFieldDelegate<E> {",This class serves as a cheap example of a LDAP or Yaml store. It will be used in the tree store which will be tested in model tests. So it is intentionally in the model tests.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9039,765951861,2021-12-09T16:24:46Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/storage/tree/sample/DictTest.java,"@@ -0,0 +1,59 @@+package org.keycloak.testsuite.model.storage.tree.sample;++import static org.hamcrest.MatcherAssert.assertThat;+import static org.hamcrest.Matchers.empty;+import static org.hamcrest.Matchers.hasItems;+import static org.hamcrest.Matchers.is;+import static org.hamcrest.Matchers.nullValue;++import java.util.Arrays;++import org.junit.Test;+import org.keycloak.models.map.client.MapClientEntity;++public class DictTest {+    @Test+    public void testDictClientFromMap() {+        MapClientEntity mce = Dict.clientDelegate();+        assertThat(mce.getClientId(), nullValue());+        assertThat(mce.isEnabled(), nullValue());+        assertThat(mce.getAttribute(""logo""), nullValue());+        assertThat(mce.getAttributes().keySet(), is(empty()));++        Dict.asDict(mce).put(Dict.CLIENT_FIELD_NAME, ""name"");+        Dict.asDict(mce).put(Dict.CLIENT_FIELD_ENABLED, false);+        Dict.asDict(mce).put(Dict.CLIENT_FIELD_LOGO, ""thisShouldBeBase64Logo"");+        Dict.asDict(mce).put(""nonexistent"", ""nonexistent"");++        assertThat(mce.getClientId(), is(""name""));",This could be done but I believe it is not necessary. The mapping to ID is used anyway by a [test in the work in progress tree store](https://github.com/hmlnarik/keycloak/blob/5020da183d8f9dd422dcc1afb77fe7bdd09f14ed/testsuite/model/src/test/java/org/keycloak/testsuite/model/storage/tree/ReadTest.java#L94),
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9039,766041450,2021-12-09T18:16:32Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -275,6 +363,29 @@ public void generate(TypeElement e) throws IOException {                         }                     }                 });++                // Read-only class overrides setters to be no-op+                pw.println(""    public static class Empty "" + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");","Methods won't be undeclared if we implement them in the generator . But currently, the Empty class might not be really empty as it will store id for most entities.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9015,766368164,2021-12-10T06:28:29Z,quarkus/tests/integration/src/main/java/org/keycloak/it/junit5/extension/CLITestExtension.java,"@@ -100,6 +97,24 @@ public void beforeAll(ExtensionContext context) throws Exception {         super.beforeAll(context);     } +    @Override+    public void afterAll(ExtensionContext context) throws Exception {+        if (dist != null) {+            //make sure sysprop raw gets unset after tests in class annotated with @DistributionTest finished in raw mode.+            if (System.getProperty(DIST_TYPE_SYSPROP) != null && System.getProperty(DIST_TYPE_SYSPROP).equals(""raw"")) {+                System.setProperty(DIST_TYPE_SYSPROP,"""");","Now we're setting the sysprop in Maven, so it's always set to ""raw"" if not explicitly set otherwise. As long as we don't need the distinction between whitebox @CLITest and @DistributionTest raw, this suffices and the above code wasn't necessary anymore and thus removed.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9039,767140878,2021-12-11T10:48:55Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -275,6 +363,29 @@ public void generate(TypeElement e) throws IOException {                         }                     }                 });++                // Read-only class overrides setters to be no-op+                pw.println(""    public static class Empty "" + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");","I am not following. Some of the methods in the entities are not generated and that is the primary reason for having ability to supply parent class in the `GenerateEntityImplementations` annotation, e.g. [MapClientEntity.getClientScopes(boolean)](https://github.com/keycloak/keycloak/blob/38174212f90739e3bc8ec854f28106f1ebdf578c/model/map/src/main/java/org/keycloak/models/map/client/MapClientEntity.java#L58).",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9039,767491217,2021-12-13T08:13:48Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -275,6 +363,29 @@ public void generate(TypeElement e) throws IOException {                         }                     }                 });++                // Read-only class overrides setters to be no-op+                pw.println(""    public static class Empty "" + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");","I understand that, but I believe [these methods]((https://github.com/keycloak/keycloak/blob/38174212f90739e3bc8ec854f28106f1ebdf578c/model/map/src/main/java/org/keycloak/models/map/client/MapClientEntity.java#L41)) should not be part of the `Empty` class as they make it non-empty. For example:```MapClientEntity client = MapClientEntityImpl.Empty.INSTANCE;client.setId(""MyId"");client.getId(); // returns ""MyId""```I would say we should implement all methods in the Empty class including ignored and already implemented in the parent class.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9039,767517348,2021-12-13T08:52:29Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -275,6 +363,29 @@ public void generate(TypeElement e) throws IOException {                         }                     }                 });++                // Read-only class overrides setters to be no-op+                pw.println(""    public static class Empty "" + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");","I see your point. Still, some of the methods might not be that easy to generate automatically, especially those returning primitive types. I am thinking of unconditional overriding all property accessors (these can be generated automatically), while still allowing for the inheritance that is already there. This would cover the `id` case.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9039,767539584,2021-12-13T09:21:59Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -275,6 +363,29 @@ public void generate(TypeElement e) throws IOException {                         }                     }                 });++                // Read-only class overrides setters to be no-op+                pw.println(""    public static class Empty "" + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");","I just realized it is not only the `isUpdated` method, what will we do about this: https://github.com/keycloak/keycloak/blob/main/model/map/src/main/java/org/keycloak/models/map/user/MapUserEntity.java#L238?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9039,767888614,2021-12-13T15:55:01Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -275,6 +363,29 @@ public void generate(TypeElement e) throws IOException {                         }                     }                 });++                // Read-only class overrides setters to be no-op+                pw.println(""    public static class Empty "" + (an.inherits().isEmpty() ? """" : "" extends "" + an.inherits()) + "" implements "" + className + "" {"");",Based on this discussion we had a call and we agreed we will implement all fields accessor methods in the `Empty` class including `isUpdated` so it always returns `false`.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8615,768718362,2021-12-14T14:27:04Z,server-spi-private/src/main/java/org/keycloak/component/ComponentModelScope.java,"@@ -84,7 +84,8 @@ public Integer getInt(String key) {     @Override     public Integer getInt(String key, Integer defaultValue) {         final String res = componentConfig.get(prefix + key, null);-        return (res == null) ? origScope.getInt(key, defaultValue) : Integer.parseInt(res);+        if (res == null) return origScope.getInt(key, defaultValue);+        return Integer.parseInt(res);",I am not sure why but without throws NPE:```Caused by: java.lang.NullPointerException	at org.keycloak.component.ComponentModelScope.getInt(ComponentModelScope.java:87)	at org.keycloak.component.ComponentModelScope.getInt(ComponentModelScope.java:81)	at org.keycloak.models.map.storage.jpa.client.JpaClientMapStorageProviderFactory.lazyInit(JpaClientMapStorageProviderFactory.java:147)```,
3108527,trixpan,https://api.github.com/repos/keycloak/keycloak/pulls/9077,769051560,2021-12-14T21:16:40Z,quarkus/pom.xml,"@@ -169,5 +169,105 @@             <url>https://repository.jboss.org/nexus/content/groups/public/</url>         </repository>     </repositories>-    ++    <profiles>+        <profile>+            <!--+                This profile is intended for building the distribution.+                It should be enabled whenever building the distribution so that only the expected+                artifacts are included within the distribution.+                By+            -->+            <id>distribution</id>+            <dependencyManagement>+                <dependencies>","^^^^^ this. the profile also allows you to run specific tests in exotic environments. e.g. afaik keycloak java keystore provider is not compatible with BouncyCastle running in FIPS mode (as IIRC, BC FIPS does not support JKS keysstores and the keycloak provider [only supports JKS](https://github.com/keycloak/keycloak/blob/bfce612641a70e106b20b136431f0e4046b5c37f/services/src/main/java/org/keycloak/keys/JavaKeystoreKeyProvider.java#L65))",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769177163,2021-12-15T01:36:53Z,core/src/main/java/org/keycloak/util/JWKSUtils.java,"@@ -95,4 +105,47 @@ public static JWK getKeyForUse(JSONWebKeySet keySet, JWK.Use requestedUse) {          return null;     }++    public static KeyWrapper getKeyWrapper(JWK jwk) {+        JWKParser parser = JWKParser.create(jwk);+        if (parser.isKeyTypeSupported(jwk.getKeyType())) {+            return wrap(jwk, parser);+        } else {+            return null;+        }+    }++    private static KeyWrapper wrap(JWK jwk, JWKParser parser) {+        KeyWrapper keyWrapper = new KeyWrapper();+        keyWrapper.setKid(jwk.getKeyId());+        if (jwk.getAlgorithm() != null) {+            keyWrapper.setAlgorithm(jwk.getAlgorithm());+        }+        keyWrapper.setType(jwk.getKeyType());+        keyWrapper.setUse(getKeyUse(jwk.getPublicKeyUse()));+        keyWrapper.setPublicKey(parser.toPublicKey());+        return keyWrapper;+    }++    public static String computeThumbprint(JWK key)  {+        return computeThumbprint(key, JWK_THUMBPRINT_DEFAULT_HASH_ALGORITHM);+    }++    public static String computeThumbprint(JWK key, String hashAlg)  {","To prove this hash calculation algorithm over JWK is valid, how about test it in JWKSUtils.java by using the example of [RFC 7638](https://datatracker.ietf.org/doc/html/rfc7638#section-3.1)? Unfortunately, it only treats RSA key and no EC key example...",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769177227,2021-12-15T01:37:08Z,core/src/main/java/org/keycloak/util/JWKSUtils.java,"@@ -95,4 +105,47 @@ public static JWK getKeyForUse(JSONWebKeySet keySet, JWK.Use requestedUse) {          return null;     }++    public static KeyWrapper getKeyWrapper(JWK jwk) {+        JWKParser parser = JWKParser.create(jwk);+        if (parser.isKeyTypeSupported(jwk.getKeyType())) {+            return wrap(jwk, parser);+        } else {+            return null;+        }+    }++    private static KeyWrapper wrap(JWK jwk, JWKParser parser) {+        KeyWrapper keyWrapper = new KeyWrapper();+        keyWrapper.setKid(jwk.getKeyId());+        if (jwk.getAlgorithm() != null) {+            keyWrapper.setAlgorithm(jwk.getAlgorithm());+        }+        keyWrapper.setType(jwk.getKeyType());+        keyWrapper.setUse(getKeyUse(jwk.getPublicKeyUse()));+        keyWrapper.setPublicKey(parser.toPublicKey());+        return keyWrapper;+    }++    public static String computeThumbprint(JWK key)  {+        return computeThumbprint(key, JWK_THUMBPRINT_DEFAULT_HASH_ALGORITHM);+    }++    public static String computeThumbprint(JWK key, String hashAlg)  {+        Map<String, String> members = new TreeMap<>();+        members.put(JWK.KEY_TYPE, key.getKeyType());++        for (String member : JWK_THUMBPRINT_REQUIRED_MEMBERS.get(key.getKeyType())) {",It seems that this method does not consider lexicographic ordering of [RFC 7638](https://datatracker.ietf.org/doc/html/rfc7638#section-3.2).,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769177498,2021-12-15T01:37:55Z,server-spi-private/src/main/java/org/keycloak/crypto/SignatureProvider.java,"@@ -17,6 +17,7 @@ package org.keycloak.crypto;  import org.keycloak.common.VerificationException;+import org.keycloak.jose.jwk.JWK; import org.keycloak.provider.Provider;  public interface SignatureProvider extends Provider {","How about using `ClientSignatureVerifierProvider` that is used for keycloak to verify the data that a client creates and signs (e.g. request object)?`SignatureProvider` is used for keycloak to sign and verify JWS (e.g. access token, ID token, refresh token). DPoP Proof is the data that a client creates and signs and keycloak verify.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769177718,2021-12-15T01:38:31Z,services/src/main/java/org/keycloak/crypto/AsymmetricSignatureProvider.java,"@@ -17,7 +17,9 @@ package org.keycloak.crypto;  import org.keycloak.common.VerificationException;+import org.keycloak.jose.jwk.JWK; import org.keycloak.models.KeycloakSession;+import org.keycloak.util.JWKSUtils;  public class AsymmetricSignatureProvider implements SignatureProvider {","How about using `AsymmetricClientSignatureVerifierProvider` that is used for keycloak to verify the data that a client creates and signs (e.g. request object, JWS client assertion for client authentication)?`AsymmetricSignatureProvider` is used for keycloak to sign and verify JWS (e.g. access token, ID token). DPoP Proof is the data that a client creates and signs and keycloak verify.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769177873,2021-12-15T01:38:56Z,services/src/main/java/org/keycloak/crypto/ECDSASignatureProvider.java,"@@ -7,7 +7,9 @@ import org.bouncycastle.asn1.DERSequenceGenerator; import org.bouncycastle.asn1.x9.X9IntegerConverter; import org.keycloak.common.VerificationException;+import org.keycloak.jose.jwk.JWK; import org.keycloak.models.KeycloakSession;+import org.keycloak.util.JWKSUtils; ","How about using `ECDSAClientSignatureVerifierProvider` that is used for keycloak to verify the data that a client creates and signs (e.g. request object, JWS client assertion for client authentication)?`ECDSASignatureProvider` is used for keycloak to sign and verify JWS (e.g. access token, ID token). DPoP Proof is the data that a client creates and signs and keycloak verify.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769177967,2021-12-15T01:39:12Z,services/src/main/java/org/keycloak/crypto/MacSecretSignatureProvider.java,"@@ -17,7 +17,9 @@ package org.keycloak.crypto;  import org.keycloak.common.VerificationException;+import org.keycloak.jose.jwk.JWK; import org.keycloak.models.KeycloakSession;+import org.keycloak.util.JWKSUtils;  public class MacSecretSignatureProvider implements SignatureProvider {","How about using `MacSecretClientSignatureVerifierProvider` that is used for keycloak to verify the data that a client creates and signs (e.g. request object, JWS client assertion for client authentication)?`MacSecretSignatureProvider` is used for keycloak to sign and verify JWS (e.g. access token, ID token). DPoP Proof is the data that a client creates and signs and keycloak verify.As for DPoP, I'm afraid that HMAC method might not be used...",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769178110,2021-12-15T01:39:33Z,services/src/main/java/org/keycloak/crypto/ServerAsymmetricSignatureVerifierContext.java,"@@ -21,6 +21,10 @@ ","How about using `ClientAsymmetricSignatureVerifierContext` that is used for keycloak to verify the data that a client creates and signs (e.g. request object, JWS client assertion for client authentication)?`ServerAsymmetricSignatureVerifierContext` is used for keycloak to sign and verify JWS (e.g. access token, ID token). DPoP Proof is the data that a client creates and signs and keycloak verify.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769178184,2021-12-15T01:39:48Z,services/src/main/java/org/keycloak/crypto/ServerMacSignatureVerifierContext.java,"@@ -21,6 +21,10 @@  public class ServerMacSignatureVerifierContext extends MacSignatureVerifierContext {","How about using `ClientMacSignatureVerifierContext` that is used for keycloak to verify the data that a client creates and signs (e.g. request object, JWS client assertion for client authentication)?`ServerMacSignatureVerifierContext` is used for keycloak to sign and verify JWS (e.g. access token, ID token). DPoP Proof is the data that a client creates and signs and keycloak verify.As for DPoP, I'm afraid that HMAC method might not be used...",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769178557,2021-12-15T01:40:36Z,services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java,"@@ -410,6 +415,11 @@ public RefreshResult refreshAccessToken(KeycloakSession session, UriInfo uriInfo          AccessTokenResponse res = responseBuilder.build(); +        // KEYCLOAK-15169 OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP)+        if (clientConfig.isDPoPEnabled()) {","[The design documents](https://github.com/keycloak/keycloak-community/blob/abdb40b888e9c7689239679ca30cc7a6a4376c2e/design/dpop.md#relation-to-other-token-binding-mechanisms) said that ether MTLS or DPoP should be applied per client, not both. The current codes accept a client that MTLS and DPoP are both applied to. If following the design document, some methanism is needed to only allow ether MTLS or DPoP to be applied per client.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769178765,2021-12-15T01:41:08Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java,"@@ -489,6 +519,18 @@ private void checkMtlsHoKToken(TokenManager.AccessTokenResponseBuilder responseB         }     } +    private void checkDPoPToken(TokenManager.AccessTokenResponseBuilder responseBuilder, boolean useRefreshToken) {+        // KEYCLOAK-15169 OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP)+        // https://tools.ietf.org/id/draft-ietf-oauth-dpop-04.html#section-6+        if (clientConfig.isDPoPEnabled()) {+            DPoPUtil.bindToken(responseBuilder.getAccessToken(), dPoP);+            // TODO do not bind refresh tokens issued to confidential clients, see 5. DPoP Access Token Request","As this comments say and [DPoP's specification](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop#section-5) described, it might be better not to make refresh tokens to be DPoP bind for a confidential client.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8895,769179057,2021-12-15T01:41:57Z,services/src/main/java/org/keycloak/services/util/DPoPUtil.java,"@@ -0,0 +1,327 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.util;++import java.net.URI;+import java.net.URISyntaxException;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.UriInfo;++import org.jboss.resteasy.spi.HttpRequest;++import org.keycloak.TokenVerifier;+import org.keycloak.common.VerificationException;+import org.keycloak.common.util.Time;+import org.keycloak.crypto.Algorithm;+import org.keycloak.crypto.KeyWrapper;+import org.keycloak.crypto.SignatureProvider;+import org.keycloak.crypto.SignatureVerifierContext;+import org.keycloak.exceptions.TokenVerificationException;+import org.keycloak.jose.jwk.JWK;+import org.keycloak.jose.jws.JWSHeader;+import org.keycloak.jose.jws.crypto.HashUtils;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.SingleUseTokenStoreProvider;+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;+import org.keycloak.representations.AccessToken;+import org.keycloak.representations.dpop.DPoP;+import org.keycloak.util.JWKSUtils;++/**+ * @author <a href=""mailto:dmitryt@backbase.com"">Dmitry Telegin</a>+ */+public class DPoPUtil {++    public static final int DEFAULT_PROOF_LIFETIME = 10;+    public static final int DEFAULT_ALLOWED_CLOCK_SKEW = 2;+    public static final String DPOP_TOKEN_TYPE = ""DPoP"";+    public static final String DPOP_SCHEME = ""DPoP"";+    public final static String DPOP_SESSION_ATTRIBUTE = ""dpop"";++    public static enum Mode {+        ENABLED,+        OPTIONAL,+        DISABLED+    }++    private static final String DPOP_HEADER = ""DPoP"";+    private static final String DPOP_HEADER_TYPE = ""dpop+jwt"";+    private static final String DPOP_ATH_ALG = ""RS256"";++    public static final Set<String> DPOP_SUPPORTED_ALGS = Stream.of(+        Algorithm.ES256,+        Algorithm.ES384,+        Algorithm.ES512,+        Algorithm.PS256,+        Algorithm.PS384,+        Algorithm.PS512,+        Algorithm.RS256,+        Algorithm.RS384,+        Algorithm.RS512+    ).collect(Collectors.toSet());++    public static DPoP validateDPoP(KeycloakSession session, ClientModel client, HttpHeaders headers, HttpRequest request, UriInfo uri) throws VerificationException {+        return validateDPoP(session, client, headers, request, uri, null);+    }++    public static DPoP validateDPoP(KeycloakSession session, ClientModel client, HttpHeaders headers, HttpRequest request, UriInfo uri, String tokenString) throws VerificationException {+        String token = headers.getHeaderString(DPOP_HEADER);++        if (token == null || token.trim().equals("""")) {+            throw new VerificationException(""DPoP proof is missing"");+        }++        TokenVerifier<DPoP> verifier = TokenVerifier.create(token, DPoP.class);+        JWSHeader header;++        try {+            header = verifier.getHeader();+        } catch (VerificationException ex) {+            throw new VerificationException(""DPoP header verification failure"");+        }++        if (!DPOP_HEADER_TYPE.equals(header.getType())) {+            throw new VerificationException(""Invalid or missing type in DPoP header: "" + header.getType());+        }++        String algorithm = header.getAlgorithm().name();++        if (!DPOP_SUPPORTED_ALGS.contains(algorithm)) {+            throw new VerificationException(""Unsupported DPoP algorithm: "" + header.getAlgorithm());+        }++        JWK key = header.getKey();++        if (key == null) {+            throw new VerificationException(""No JWK in DPoP header"");+        } else {+            KeyWrapper wrapper = JWKSUtils.getKeyWrapper(key);+            if (wrapper.getPublicKey() == null) {+                throw new VerificationException(""No public key in DPoP header"");+            }+            if (wrapper.getPrivateKey() != null) {+                throw new VerificationException(""Private key is present in DPoP header"");+            }+        }++        key.setAlgorithm(header.getAlgorithm().name());++        SignatureVerifierContext signatureVerifier = session.getProvider(SignatureProvider.class, algorithm).verifier(key);+        verifier.verifierContext(signatureVerifier);+        verifier.withChecks(+                DPoPClaimsCheck.INSTANCE,+                new DPoPHTTPCheck(request, uri),+                new DPoPIsActiveCheck(session, client),+                new DPoPReplayCheck(session, client));++        if (tokenString != null) {+            verifier.withChecks(new DPoPAccessTokenHashCheck(tokenString));+        }++        try {+            DPoP dPoP = verifier.verify().getToken();+            dPoP.setThumbprint(JWKSUtils.computeThumbprint(key));+            return dPoP;+        } catch (DPoPVerificationException ex) {+            throw ex;+        } catch (VerificationException ex) {+            throw new VerificationException(""DPoP verification failure"", ex);+        }++    }++    public static void validateBinding(AccessToken token, DPoP dPoP) throws VerificationException {+        try {+            TokenVerifier.createWithoutSignature(token)+                    .withChecks(new DPoPUtil.DPoPBindingCheck(dPoP))+                    .verify();+        } catch (TokenVerificationException ex) {+            throw ex;+        } catch (VerificationException ex) {+            throw new VerificationException(""Token verification failure"", ex);+        }+    }++    public static void bindToken(AccessToken token, DPoP dPoP) {+        AccessToken.Confirmation confirmation = token.getConfirmation();++        if (confirmation == null) {+            confirmation = new AccessToken.Confirmation();+            token.setConfirmation(confirmation);+        }++        confirmation.setKeyThumbprint(dPoP.getThumbprint());+    }++    private static class DPoPClaimsCheck implements TokenVerifier.Predicate<DPoP> {++        static final TokenVerifier.Predicate<DPoP> INSTANCE = new DPoPClaimsCheck();++        @Override+        public boolean test(DPoP t) throws DPoPVerificationException {+            Long iat = t.getIat();+            String jti = t.getId(), htu = t.getHttpUri(), htm = t.getHttpMethod();++            if (iat != null &&+                jti != null && !jti.trim().equals("""") &&+                htm != null && !htm.trim().equals("""") &&+                htu != null && !htu.trim().equals("""")) {+                return true;+            } else {+                throw new DPoPVerificationException(t, ""DPoP mandatory claims are missing"");+            }+        }++    }++    private static class DPoPHTTPCheck implements TokenVerifier.Predicate<DPoP> {++        private final HttpRequest request;+        private final UriInfo uri;++        DPoPHTTPCheck(HttpRequest request, UriInfo uri) {+            this.request = request;+            this.uri = uri;+        }++        @Override+        public boolean test(DPoP t) throws DPoPVerificationException {+            try {+                if (new URI(t.getHttpUri()).equals(uri.getAbsolutePath()) &&+                    request.getHttpMethod().equals(t.getHttpMethod())) {+                    return true;+                } else {+                    throw new DPoPVerificationException(t, ""DPoP HTTP method/URL mismatch"");+                }+            } catch (URISyntaxException ex) {+                throw new DPoPVerificationException(t, ""Malformed HTTP URL in DPoP proof"");+            }+        }++    }++    private static class DPoPReplayCheck implements TokenVerifier.Predicate<DPoP> {++        private final KeycloakSession session;+        private final int lifetime;++        public DPoPReplayCheck(KeycloakSession session, ClientModel client) {+            this.session = session;+            OIDCAdvancedConfigWrapper config = OIDCAdvancedConfigWrapper.fromClientModel(client);+            this.lifetime = config.getDPoPProofLifetime();+        }++        @Override+        public boolean test(DPoP t) throws DPoPVerificationException {+            SingleUseTokenStoreProvider singleUseCache = session.getProvider(SingleUseTokenStoreProvider.class);+            byte[] hash = HashUtils.hash(""SHA1"", (t.getId() + ""\n"" + t.getHttpUri()).getBytes());","As [DPoP's specification](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop#section-4.2) mentions, it might be sufficient to use only ""jti"". Could you tell me why you include ""htu""?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9077,769319061,2021-12-15T07:23:13Z,quarkus/pom.xml,"@@ -169,5 +169,105 @@             <url>https://repository.jboss.org/nexus/content/groups/public/</url>         </repository>     </repositories>-    ++    <profiles>+        <profile>+            <!--+                This profile is intended for building the distribution.+                It should be enabled whenever building the distribution so that only the expected+                artifacts are included within the distribution.+                By+            -->+            <id>distribution</id>+            <dependencyManagement>+                <dependencies>",In that case wouldn't you just use the test scope for the dependency instead of a profile?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/9136,769567754,2021-12-15T12:10:46Z,.github/workflows/ci.yml,"@@ -414,7 +414,7 @@ jobs:        - name: Run Quarkus Tests in Docker         run: |-          mvn clean install -nsu -B -f quarkus/tests/pom.xml -Dkc.quarkus.tests.dist=docker | misc/log/trimmer.sh+          mvn clean install -nsu -B -f quarkus/tests/pom.xml -Dkc.quarkus.tests.dist=docker -Dtest=StartCommandDistTest | misc/log/trimmer.sh","@andreaTP We are still running one of the main tests for docker. It should cover a lot already, please check the test class.We can not be blocked at the moment by instability on docker tests. If you have the fix already, please send it and we can revert this change.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/9136,769656034,2021-12-15T14:05:14Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/storage/ClientStorageOnQuarkusTest.java,"@@ -0,0 +1,68 @@+/*+ * Copyright 2017 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.testsuite.federation.storage;++import java.util.Arrays;+import org.jboss.arquillian.container.spi.Container;+import org.jboss.arquillian.test.api.ArquillianResource;+import org.junit.BeforeClass;+import org.keycloak.testsuite.arquillian.ContainerInfo;+import org.keycloak.testsuite.arquillian.SuiteContext;+import org.keycloak.testsuite.arquillian.containers.KeycloakQuarkusServerDeployableContainer;+import org.keycloak.testsuite.util.ContainerAssume;++public class ClientStorageOnQuarkusTest extends ClientStorageTest {++    @BeforeClass+    public static void enabled() {+        ContainerAssume.assumeAuthServerQuarkus();+    }++    @ArquillianResource+    SuiteContext suiteContext;++    @Override+    public void testClientStats() throws Exception {+        try {+            enablePreLoadOfflineSessions();+            super.testClientStats();+        } finally {+            reset();+        }+    }++    private void enablePreLoadOfflineSessions() throws Exception {+        KeycloakQuarkusServerDeployableContainer container = getQuarkusContainer();++        container.setAdditionalBuildArgs(Arrays.asList(""--spi-user-sessions-infinispan-preload-offline-sessions-from-database=true""));","My guess is, that removing Wildfly support is still quite long time before we really do it. But maybe I am wrong :-)I am approving the PR.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9166,769916485,2021-12-15T18:53:01Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/hibernate/jsonb/JsonbType.java,"@@ -148,9 +154,14 @@ private Object extractJson(CallableStatement statement, String name) throws SQLE         }     } -    private static class JsonbJavaTypeDescriptor extends AbstractTypeDescriptor<Object> {+    private static class JsonbJavaTypeDescriptor extends AbstractTypeDescriptor<Object> implements DynamicParameterizedType { -        private static final JsonbJavaTypeDescriptor INSTANCE = new JsonbJavaTypeDescriptor();+        private Class valueType;++        @Override+        public void setParameterValues(Properties parameters) {+            valueType = ((ParameterType) parameters.get(PARAMETER_TYPE)).getReturnedClass();",There is the declaration: https://github.com/hibernate/hibernate-orm/blob/main/hibernate-core/src/main/java/org/hibernate/usertype/DynamicParameterizedType.java#L22,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9200,771199357,2021-12-17T08:37:30Z,quarkus/tests/integration/src/main/java/org/keycloak/it/utils/DockerKeycloakDistribution.java,"@@ -6,12 +6,18 @@ import org.testcontainers.containers.GenericContainer; import org.testcontainers.containers.output.OutputFrame; import org.testcontainers.containers.output.ToStringConsumer;+import org.testcontainers.containers.wait.strategy.Wait; import org.testcontainers.images.builder.ImageFromDockerfile;+import org.testcontainers.shaded.com.google.common.util.concurrent.RateLimiter;","unused import, pls remove",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9200,771206207,2021-12-17T08:48:56Z,quarkus/tests/integration/src/main/java/org/keycloak/it/utils/DockerKeycloakDistribution.java,"@@ -58,50 +72,75 @@ private GenericContainer getKeycloakContainer() {         }         fetchDockerfile();         return new GenericContainer(-                new ImageFromDockerfile()+                new ImageFromDockerfile(""keycloak.x-under-test"", false)                         .withFileFromFile(""keycloakx.tar.gz"", distributionFile)                         .withFileFromFile(""Dockerfile"", cachedDockerfile)                         .withBuildArg(""KEYCLOAK_DIST"", ""keycloakx.tar.gz"")         )-                .withExposedPorts(8080);-    }--    public <T> DockerKeycloakDistribution(boolean debug, boolean manualStop, boolean reCreate) {-        this.debug = debug;-        this.manualStop = manualStop;+                .withExposedPorts(8080)+                .withStartupAttempts(1)+                .withStartupTimeout(Duration.ofSeconds(120))","Seems very long to me. If I understood correctly, we try a one-time startup, which should even on a bad gha runner be there in <=30s. Perhaps make it parametrizable?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9200,771209786,2021-12-17T08:54:34Z,quarkus/tests/integration/src/main/java/org/keycloak/it/utils/DockerKeycloakDistribution.java,"@@ -58,50 +72,75 @@ private GenericContainer getKeycloakContainer() {         }         fetchDockerfile();         return new GenericContainer(-                new ImageFromDockerfile()+                new ImageFromDockerfile(""keycloak.x-under-test"", false)                         .withFileFromFile(""keycloakx.tar.gz"", distributionFile)                         .withFileFromFile(""Dockerfile"", cachedDockerfile)                         .withBuildArg(""KEYCLOAK_DIST"", ""keycloakx.tar.gz"")         )-                .withExposedPorts(8080);-    }--    public <T> DockerKeycloakDistribution(boolean debug, boolean manualStop, boolean reCreate) {-        this.debug = debug;-        this.manualStop = manualStop;+                .withExposedPorts(8080)+                .withStartupAttempts(1)+                .withStartupTimeout(Duration.ofSeconds(120))+                .waitingFor(Wait.forListeningPort());     }      @Override     public void start(List<String> arguments) {+        stop();         try {             this.exitCode = -1;             this.stdout = """";             this.stderr = """";+            this.containerId = null;             this.backupConsumer = new ToStringConsumer(); -             keycloakContainer = getKeycloakContainer();              keycloakContainer                     .withLogConsumer(backupConsumer)                     .withCommand(arguments.toArray(new String[0]))                     .start();+            containerId = keycloakContainer.getContainerId();++            waitForStableOutput();              // TODO: this is based on a lot of assumptions             io.restassured.RestAssured.port = keycloakContainer.getMappedPort(8080);         } catch (Exception cause) {             this.exitCode = -1;             this.stdout = backupConsumer.toUtf8String();             this.stderr = backupConsumer.toUtf8String();+            cleanupContainer();             keycloakContainer = null;             LOGGER.warn(""Failed to start Keycloak container"", cause);         }     } +    // After the web server is responding we are still producing some logs that got checked in the tests+    private void waitForStableOutput() {+        String lastLine = """";+        boolean stableOutput = false;+        while (!stableOutput) {+            if (keycloakContainer.isRunning()) {+                try {+                    Thread.sleep(200);+                } catch (InterruptedException e) {","hum, just ignoring the InterruptedException will really suffice here? See e.g. SonarLint:```""InterruptedException"" should not be ignored Bug Majorjava:S2142 InterruptedExceptions should never be ignored in the code, and simply logging the exception counts in this case as ""ignoring"". The throwing of the InterruptedException clears the interrupted state of the Thread, so if the exception is not handled properly the information that the thread was interrupted will be lost. Instead, InterruptedExceptions should either be rethrown - immediately or after cleaning up the methods state - or the thread should be re-interrupted by calling Thread.interrupt() even if this is supposed to be a single-threaded application. Any other course of action risks delaying thread shutdown and loses the information that the thread was interrupted - probably without finishing its task.Similarly, the ThreadDeath exception should also be propagated. According to its JavaDoc:If ThreadDeath is caught by a method, it is important that it be rethrown so that the thread actually dies.Noncompliant Code Example public void run () { try { while (true) { // do stuff } }catch (InterruptedException e) { // Noncompliant; logging is not enough LOGGER.log(Level.WARN, ""Interrupted!"", e); } } Compliant Solution public void run () { try { while (true) { // do stuff } }catch (InterruptedException e) { LOGGER.log(Level.WARN, ""Interrupted!"", e); // Restore interrupted state... Thread.currentThread().interrupt(); } } SeeMITRE, CWE-391 - Unchecked Error Condition```",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9200,771223838,2021-12-17T09:15:57Z,quarkus/tests/integration/src/main/java/org/keycloak/it/utils/DockerKeycloakDistribution.java,"@@ -58,50 +72,75 @@ private GenericContainer getKeycloakContainer() {         }         fetchDockerfile();         return new GenericContainer(-                new ImageFromDockerfile()+                new ImageFromDockerfile(""keycloak.x-under-test"", false)                         .withFileFromFile(""keycloakx.tar.gz"", distributionFile)                         .withFileFromFile(""Dockerfile"", cachedDockerfile)                         .withBuildArg(""KEYCLOAK_DIST"", ""keycloakx.tar.gz"")         )-                .withExposedPorts(8080);-    }--    public <T> DockerKeycloakDistribution(boolean debug, boolean manualStop, boolean reCreate) {-        this.debug = debug;-        this.manualStop = manualStop;+                .withExposedPorts(8080)+                .withStartupAttempts(1)",it throws an exception that is catch and handle in the `start` method.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8972,771912457,2021-12-19T08:07:20Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/liquibase/MapLiquibaseConnectionProvider.java,"@@ -0,0 +1,111 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.jpa.liquibase;++import java.sql.Connection;+import java.util.concurrent.atomic.AtomicBoolean;++import liquibase.Liquibase;+import liquibase.change.ChangeFactory;+import liquibase.database.Database;+import liquibase.database.DatabaseFactory;+import liquibase.database.jvm.JdbcConnection;+import liquibase.datatype.DataTypeFactory;+import liquibase.exception.LiquibaseException;+import liquibase.resource.ClassLoaderResourceAccessor;+import liquibase.resource.ResourceAccessor;+import liquibase.sqlgenerator.SqlGeneratorFactory;+import org.jboss.logging.Logger;+import org.keycloak.connections.jpa.updater.liquibase.conn.LiquibaseConnectionProvider;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.storage.jpa.liquibase.extension.GeneratedColumnSqlGenerator;+import org.keycloak.models.map.storage.jpa.liquibase.extension.CreateJsonIndexChange;+import org.keycloak.models.map.storage.jpa.liquibase.extension.CreateJsonIndexGenerator;+import org.keycloak.models.map.storage.jpa.liquibase.extension.GeneratedColumnChange;+import org.keycloak.models.map.storage.jpa.liquibase.extension.JsonDataType;++/**+ * A {@link LiquibaseConnectionProvider} implementation for the map-jpa module. This provider registers the custom {@code Liquibase}+ * changes and data types that were developed to better support working with data stored as JSON in the database.+ * </p>+ * An instance of this provider has to be obtained via {@link KeycloakSession#getProvider(Class, String)} as follows:+ * <pre>+ *     LiquibaseConnectionProvider liquibaseProvider = session.getProvider(LiquibaseConnectionProvider.class, ""map-jpa"");","```suggestion *     LiquibaseConnectionProvider liquibaseProvider = session.getProvider(LiquibaseConnectionProvider.class, MapLiquibaseConnectionProviderFactory.PROVIDER_ID);```",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/8972,771923298,2021-12-19T09:40:23Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/liquibase/extension/GeneratedColumnSqlGenerator.java,"@@ -0,0 +1,96 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.jpa.liquibase.extension;++import java.util.ArrayList;+import java.util.List;++import liquibase.database.Database;+import liquibase.database.core.PostgresDatabase;+import liquibase.sql.Sql;+import liquibase.sql.UnparsedSql;+import liquibase.sqlgenerator.SqlGenerator;+import liquibase.sqlgenerator.core.AddColumnGenerator;+import liquibase.statement.core.AddColumnStatement;++/**+ * A {@link SqlGenerator} implementation that supports {@link GeneratedColumnStatement}s. It generates the SQL required+ * to add a column whose values are generated from a property of a JSON file stored in one of the table columns.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class GeneratedColumnSqlGenerator extends AddColumnGenerator {++    /**+     * Override the priority. This is needed because {@link GeneratedColumnStatement} is a subtype of {@link AddColumnStatement}+     * and is thus a match for the standard column generators. By increasing the priority we ensure this is processed before+     * the other generators.+     *+     * @return this generator's priority.+     */+    @Override+    public int getPriority() {+        return SqlGenerator.PRIORITY_DEFAULT + 1;+    }++    /**+     * Implement {@link #supports(AddColumnStatement, Database)} to return {@code true} only if the statement type is an instance+     * of {@link GeneratedColumnStatement}.+     * </p>+     * This is needed because this generator is a sub-class of {@link AddColumnGenerator} and is thus registered as being+     * able to handle statements of type {@link AddColumnStatement}. Due to the increased priority, this generator ends up+     * being selected to handle standard {@code addColumn} changes, which is not desirable. By returning {@code true} only+     * when the statement is a {@link GeneratedColumnStatement} we ensure this implementation is selected only when a generated+     * column is being added, allowing liquibase to continure iterating through the chain of generator in order to select the","```suggestion     * column is being added, allowing liquibase to continue iterating through the chain of generator in order to select the```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9221,772203920,2021-12-20T09:25:49Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/AbstractGenerateEntityImplementationsProcessor.java,"@@ -123,11 +123,15 @@ private void processTypeElement(TypeElement e) {          // Merge plurals with singulars         methodsPerAttribute.keySet().stream()-                .filter(key -> methodsPerAttribute.containsKey(key + ""s""))+                .filter(key -> methodsPerAttribute.containsKey(key + ""s"") || (key.endsWith(""y"") && methodsPerAttribute.containsKey(key.substring(0, key.length() -1) + ""ies"")))","Could the filter to check whether the property is plural and the transformer from plural to singular be extracted into two methods, `hasPlural` and `pluralToSinglular`, perhaps in `Util` class? They would be used in `FieldAccessorType` as well.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,772206093,2021-12-20T09:28:40Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryMapModelCriteriaBuilder.java,"@@ -175,6 +206,65 @@ private StringBuilder getWhereClauseBuilder() {         return whereClauseBuilder;     } +    public static Object getFirstArrayElement(Object[] value) throws IllegalStateException {+        if (value == null || value.length == 0) {+            throw new IllegalStateException(""Invalid argument: "" + Arrays.toString(value));+        }+        return value[0];+    }++    public static Object[] sanitizeValues(SearchableModelField<?> modelField, Object[] values) {+        if (isAnalyzedModelField(modelField.getName()) || isOverriddenModelField(modelField)) {+            Object value0 = IckleQueryMapModelCriteriaBuilder.getFirstArrayElement(values);+            if (value0 instanceof String) {+                sanitizeStringInputs(values, modelField);+            }+        }++        return values;+    }++    private static void sanitizeStringInputs(Object[] values, SearchableModelField modelField) {+        if (isAnalyzedModelField(modelField.getName())) {+            IntStream.range(0, values.length).forEach(i -> values[i] = sanitizeAnalyzed((String) values[i]));+        } else {+            if (isOverriddenModelField(modelField)) {+                IntStream.range(0, values.length).forEach(i -> values[i] = sanitize((String) values[i]).toLowerCase());+            } else {+                IntStream.range(0, values.length).forEach(i -> values[i] = sanitize((String) values[i]));+            }+        }+    }++    private static String sanitize(String value) {+        boolean anyBeginning = value.startsWith(""%"");+        boolean anyEnd = value.endsWith(""%"");++        String sanitizedString = value.substring(anyBeginning ? 1 : 0, value.length() - (anyEnd ? 1 : 0))+                .replaceAll(NON_ANALYZED_FIELD_REGEX, ""\\\\\\\\"" + ""$0"");++        return (anyBeginning ? ""%"" : """") + sanitizedString + (anyEnd ? ""%"" : """");+    }++    private static String sanitizeAnalyzed(String value) {+        boolean anyBeginning = value.startsWith(""%"");+        boolean anyEnd = value.endsWith(""%"");++        String sanitizedString = value.substring(anyBeginning ? 1 : 0, value.length() - (anyEnd ? 1 : 0))+                .replaceAll(""\\\\"", ""\\\\\\\\""); // escape ""\"" with extra ""\""+        //      .replaceAll(ANALYZED_FIELD_REGEX, ""\\\\\\\\"" + ""$0""); skipped for now because Infinispan is not able to escape special characters for analyzed fields++        return (anyBeginning ? ""*"" : """") + sanitizedString + (anyEnd ? ""*"" : """");+    }++    public static boolean isAnalyzedModelField(String modelFieldName) {",This method should have `SearchableModelField` as the parameter instead of String as we can have the same field name for more entities.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9221,772216845,2021-12-20T09:43:21Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -363,7 +362,7 @@ public void generate(TypeElement e) throws IOException {                          if (parentMethod.isPresent()) {                             processingEnv.getMessager().printMessage(Kind.OTHER, ""Method "" + method + "" is declared in a parent class."", method);-                        } else if (fat != FieldAccessorType.UNKNOWN && ! printMethodBody(pw, fat, method, ""f"" + me.getKey(), fieldType)) {+                        } else if (fat == FieldAccessorType.UNKNOWN || ! printMethodBody(pw, fat, method, ""f"" + me.getKey(), fieldType)) {",This changes the semantics significantly. We should ignore unknown methods completely as long as the method is not recognized as one of the field accessors.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9221,772219031,2021-12-20T09:46:19Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientMetadata.java,"@@ -18,9 +18,18 @@  import java.io.Serializable; import org.keycloak.models.map.client.MapClientEntityImpl;+import org.keycloak.models.map.common.DeepCloner;  public class JpaClientMetadata extends MapClientEntityImpl implements Serializable { +    public JpaClientMetadata(DeepCloner cloner) {+        super(cloner);","This needs extra care. We do not want to serialize `cloner` into database. Is this handled in this way, @vramik?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,772248485,2021-12-20T10:27:25Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryMapModelCriteriaBuilder.java,"@@ -66,6 +91,12 @@ public static String getFieldName(SearchableModelField<?> modelField) {         return INFINISPAN_NAME_OVERRIDES.getOrDefault(modelField, modelField.getName());     } +    public static SearchableModelField<?> getModelFieldOverride(SearchableModelField<?> modelField, ModelCriteriaBuilder.Operator op) {+        return op.equals(ModelCriteriaBuilder.Operator.ILIKE) ?","Can we have this solved in a new `ExpressionCombinator` that is specific only for `ILIKE`: https://github.com/keycloak/keycloak/blob/main/model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryOperators.java#L57I think we should throw an exception if there is any `ILIKE` query for a field that is not analyzed nor contain a lowercase version, WDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,772251310,2021-12-20T10:31:31Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryOperators.java,"@@ -156,6 +156,9 @@ private static ExpressionCombinator singleValueOperator(ModelCriteriaBuilder.Ope             String namedParameter = findAvailableNamedParam(parameters.keySet(), modelFieldName);             parameters.put(namedParameter, values[0]); +            if (IckleQueryMapModelCriteriaBuilder.isAnalyzedModelField(modelFieldName)) {","We should log some warning/throw an exception if the operator is not `EQ` or `ILIKE`. Maybe even `LIKE` would be possible, but it is a little bit more difficult as we don't know here whether the resulting operation will be `LIKE` or `ILIKE` as it depends on the analyzer.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,772285831,2021-12-20T11:24:07Z,pom.xml,"@@ -78,8 +78,8 @@         <jakarta.persistence.version>2.2.3</jakarta.persistence.version>         <hibernate.core.version>5.3.20.Final</hibernate.core.version>         <hibernate.c3p0.version>5.3.20.Final</hibernate.c3p0.version>-        <infinispan.version>11.0.9.Final</infinispan.version>-        <infinispan.protostream.processor.version>4.3.4.Final</infinispan.protostream.processor.version>+        <infinispan.version>12.1.7.Final</infinispan.version>",I just asked Stian about this and he said that we can do this> as long as Quarkus Infinispan version && WildFly Infinispan version >= KC parent POM versionbut I believe we should do this in a separate PR if it is really necessary.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9221,772304961,2021-12-20T11:55:17Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientMetadata.java,"@@ -18,9 +18,18 @@  import java.io.Serializable; import org.keycloak.models.map.client.MapClientEntityImpl;+import org.keycloak.models.map.common.DeepCloner;  public class JpaClientMetadata extends MapClientEntityImpl implements Serializable { +    public JpaClientMetadata(DeepCloner cloner) {+        super(cloner);",It should be handled by https://github.com/keycloak/keycloak/blob/main/model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/hibernate/jsonb/JsonbType.java#L72,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9221,772396900,2021-12-20T14:13:32Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -363,7 +362,7 @@ public void generate(TypeElement e) throws IOException {                          if (parentMethod.isPresent()) {                             processingEnv.getMessager().printMessage(Kind.OTHER, ""Method "" + method + "" is declared in a parent class."", method);-                        } else if (fat != FieldAccessorType.UNKNOWN && ! printMethodBody(pw, fat, method, ""f"" + me.getKey(), fieldType)) {+                        } else if (fat == FieldAccessorType.UNKNOWN || ! printMethodBody(pw, fat, method, ""f"" + me.getKey(), fieldType)) {",Could you please elaborate more on how this changes the semantics? As far as I can see it just prints a warning message when there is a method with a signature not known to the generator. I added this because during development it is good to know what methods were not recognized.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9221,772410829,2021-12-20T14:31:09Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientMetadata.java,"@@ -18,9 +18,18 @@  import java.io.Serializable; import org.keycloak.models.map.client.MapClientEntityImpl;+import org.keycloak.models.map.common.DeepCloner;  public class JpaClientMetadata extends MapClientEntityImpl implements Serializable { +    public JpaClientMetadata(DeepCloner cloner) {+        super(cloner);","The `cloner` is there anyway, the change is that it is possible to use something different than `DUMB_CLONER`. Not sure it makes sense though, I just needed to add a constructor with DeepCloner so that it is possible to use it in `DeepCloner.Builder#constructor`. If there is something wrong we can revert.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9221,772435234,2021-12-20T15:01:12Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java,"@@ -283,28 +284,26 @@ public void generate(TypeElement e) throws IOException {                   .map(ExecutableElement.class::cast)                   .filter((ExecutableElement ee) -> ee.getKind() == ElementKind.CONSTRUCTOR)                   .forEach((ExecutableElement ee) -> {-                      if (hasDeepClone || ! needsDeepClone) {-                          pw.println(""    ""-                            + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                            + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); }""-                          );-                      } else if (needsDeepClone) {+                      // Create constructor and initialize cloner to DUMB_CLONER if necessary+                      if (usingGeneratedCloner) {                           pw.println(""    /**"");                           pw.println(""     * @deprecated This constructor uses a {@link DeepCloner#DUMB_CLONER} that does not clone anything. Use {@link #"" + mapSimpleClassName + ""(DeepCloner)} variant instead"");                           pw.println(""     */"");-                          pw.println(""    ""-                            + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                            + "" ""-                            + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") { this(DeepCloner.DUMB_CLONER"" + (ee.getParameters().isEmpty() ? """" : "", "") + ee.getParameters() + ""); }""-                          );-                          pw.println(""    ""-                            + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))-                            + "" ""-                            + mapSimpleClassName + ""(DeepCloner cloner"" + (ee.getParameters().isEmpty() ? """" : "", "") + methodParameters(ee.getParameters()) + "") { super("" + ee.getParameters() + ""); this.cloner = cloner; }""-                          );                       }+                      pw.println(""    ""+                              + ee.getModifiers().stream().map(Object::toString).collect(Collectors.joining("" ""))+                              + "" "" + mapSimpleClassName + ""("" + methodParameters(ee.getParameters()) + "") {""+                      );+                      pw.println(""        super("" + ee.getParameters() + "");"");+                      if (usingGeneratedCloner) pw.println(""        this.cloner = DeepCloner.DUMB_CLONER;"");+                      pw.println(""    }"");                   }); +                pw.println(""    ""+                        + ""public ""+                        + mapSimpleClassName + ""(DeepCloner cloner) { super(); "" + (!usingGeneratedCloner ? """" : ""this.cloner = cloner;"") + ""}""",The compilation would fail. But it sounds like correct behavior to me as all these classes need to be instantiable by `DeepCloner` that is not able to provide any parameters.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9221,772503547,2021-12-20T16:27:00Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientMetadata.java,"@@ -18,9 +18,18 @@  import java.io.Serializable; import org.keycloak.models.map.client.MapClientEntityImpl;+import org.keycloak.models.map.common.DeepCloner;  public class JpaClientMetadata extends MapClientEntityImpl implements Serializable { +    public JpaClientMetadata(DeepCloner cloner) {+        super(cloner);","The constructor is not used from anywhere at the moment. I'm not sure about future use cases, but right now the class is instantiated only with `DUMP_CLONER`.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9253,772540260,2021-12-20T17:18:12Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -87,6 +89,10 @@ public JpaClientEntity() {         this.metadata = new JpaClientMetadata();     } +    public JpaClientEntity(DeepCloner cloner) {+        this.metadata = new JpaClientMetadata(cloner);+    }",Do we plan to instantiate `JpaClientEntity` using this constructor? Right now it's not used from anywhere.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9260,772911456,2021-12-21T08:10:22Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapStorage.java,"@@ -0,0 +1,50 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.HashMap;+import java.util.Map;+import java.util.function.Supplier;+import javax.persistence.EntityManager;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.jpa.client.JpaClientMapKeycloakTransaction;++public class JpaMapStorage<V extends AbstractEntity, M> implements MapStorage<V, M> {++    private final Class<?> modelType;++    public static final Integer SUPPORTED_VERSION_CLIENT = 1;",This constant should be rather in the provider factory or a separate constants class.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9253,772927202,2021-12-21T08:33:05Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -87,6 +89,10 @@ public JpaClientEntity() {         this.metadata = new JpaClientMetadata();     } +    public JpaClientEntity(DeepCloner cloner) {+        this.metadata = new JpaClientMetadata(cloner);+    }","It is used from cloner. See: https://github.com/keycloak/keycloak/blob/33ebbdf2c088f24dc78ac80bbc2bfc0e625e213a/model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/JpaClientMapStorageProviderFactory.java#L61.But I am not sure whether it makes sense to have the cloner stored in the metadata.Let me summarize how it works for CHM and HR, probably you already know but to be on same page:1. Each factory has a CLONER created which knows how to create storage-specific entities. (like. `HotRodClientEntity`, `MapClientEntityImpl`, `JpaClientEntity`)2. When storage obtains an entity it always makes a copy/clone so that it is sure the stored object has the correct type3. Now, some entities have also nested entities and we need to be able to copy also those, therefore entities (like `MapClientEntityImpl`) store the cloner reference that created the object so when, for example, `setProtocolMapper` is called the entity setter can create a copy of correct type.Before this change, we had two types of constructors in DeepCloner: parameter-less and constructor with `DeepCloner`. When a class didn't have `DeepCloner` constructor (it has no mutable fields) we used parameter-less for creating it. However, this can cause problems in the future as some entities may be extended with some complex field that requires deep cloning, however, in `DeepCloner` we still use parameter-less constructor, therefore only `DUMB_CLONER` will be used. This issue can be hard to find so we decided to always use constructor with `DeepCloner` inside.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9253,773022168,2021-12-21T10:37:15Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -87,6 +89,10 @@ public JpaClientEntity() {         this.metadata = new JpaClientMetadata();     } +    public JpaClientEntity(DeepCloner cloner) {+        this.metadata = new JpaClientMetadata(cloner);+    }",Thank you very much for the reply. I wrongly assumed that `JpaClientEntity::new` is equivalent  to `() -> new JpaClientEntity()`. Now when I played a little bit with it I can see what you mean. It is called exactly from [there](https://github.com/keycloak/keycloak/blob/6383f073c26dc2f3ca53a605a74b67ec2cee16f2/model/map/src/main/java/org/keycloak/models/map/common/DeepCloner.java#L392).`DeepCloner` object is not stored in database. It's ignored when serialization is done. There is the configuration: https://github.com/keycloak/keycloak/blob/6383f073c26dc2f3ca53a605a74b67ec2cee16f2/model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/hibernate/jsonb/JsonbType.java#L73I'd say that having the cloner in metadata makes sense for cases when we would want to call `deepClone` method on metadata object. I'm not sure if a such situation could occur. But to be on the safe site I think we should leave it as you have it atm.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8972,773068400,2021-12-21T11:45:49Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/updater/liquibase/MapJpaLiquibaseUpdaterProvider.java,"@@ -163,7 +164,7 @@ protected Status validateChangeSet(Liquibase liquibase, String changelog) throws     }      private Liquibase getLiquibase(Class modelType, Connection connection, String defaultSchema) throws LiquibaseException {-        LiquibaseConnectionProvider liquibaseProvider = session.getProvider(LiquibaseConnectionProvider.class);+        LiquibaseConnectionProvider liquibaseProvider = session.getProvider(LiquibaseConnectionProvider.class, MapLiquibaseConnectionProviderFactory.PROVIDER_ID);","This should be a separate SPI with a separate provider that should not specify the `MapLiquibaseConnectionProviderFactory.PROVIDER_ID` as a specific provider ID, rather rely on the one picked by the system. ```suggestion        MapLiquibaseProvider liquibaseProvider = session.getProvider(MapLiquibaseProvider.class);```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/8972,773070865,2021-12-21T11:49:30Z,model/map-jpa/src/main/resources/META-INF/jpa-clients-changelog-1.xml,"@@ -17,37 +17,55 @@ limitations under the License. -->  -<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">+<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">      <!-- format of id of changeSet: clients-${JpaClientMapStorage.SUPPORTED_VERSION} -->     <changeSet author=""keycloak"" id=""clients-1""> -        <sql>-            create table client (-                id uuid primary key not null,-                entityVersion integer generated always as ((metadata->>'entityVersion')::int) stored,-                realmId varchar(36) generated always as (metadata->>'fRealmId') stored,-                clientId varchar(255) generated always as (metadata->>'fClientId') stored,-                protocol varchar(36) generated always as (metadata->>'fProtocol') stored,-                enabled boolean generated always as ((metadata->>'fEnabled')::boolean) stored,-                metadata jsonb-            );--            create index client_entityVersion on client(entityVersion);-            create index client_realmId_clientId on client(realmId, clientId);-            create index client_scopeMappings on client using gin ((metadata->'fScopeMappings') jsonb_path_ops);--            create table client_attribute (-                id uuid primary key not null,-                fk_client uuid references client(id) on delete cascade,-                name varchar(255),-                value text-            );--            create index client_attr_fk_client on client_attribute(fk_client);-            create index client_attr_name_value on client_attribute(name, (value::varchar(250))); -        </sql>+        <createTable tableName=""client"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""client"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""realmid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fRealmId""/>+            <ext:column name=""clientid"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fClientId""/>+            <ext:column name=""protocol"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fProtocol""/>+            <ext:column name=""enabled"" type=""BOOLEAN"" jsonColumn=""metadata"" jsonProperty=""fEnabled""/>+        </ext:addGeneratedColumn>+        <createIndex tableName=""client"" indexName=""client_entityVersion"">+            <column name=""entityversion""/>+        </createIndex>+        <createIndex tableName=""client"" indexName=""client_realmId_clientId"">+            <column name=""realmid""/>+            <column name=""clientid""/>+        </createIndex>+        <ext:createJsonIndex tableName=""client"" indexName=""client_scopeMappings"">+            <ext:column jsonColumn=""metadata"" jsonProperty=""fScopeMappings""/>+        </ext:createJsonIndex> +        <createTable tableName=""client_attribute"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""fk_client"" type=""UUID"">+                <constraints foreignKeyName=""client_attr_fk_client_fkey"" references=""client(id)"" deleteCascade=""true""/>+            </column>+            <column name=""name"" type=""VARCHAR(255)""/>+            <column name=""value"" type=""text""/>+        </createTable>+        <createIndex tableName=""client_attribute"" indexName=""client_attr_fk_client"">+            <column name=""fk_client""/>+        </createIndex>+        <createIndex tableName=""client_attribute"" indexName=""client_attr_name_value"">+            <column name=""name""/>+            <column name=""(value::varchar(250))""/>",Can you use the same trick as in https://github.com/keycloak/keycloak/blob/6383f073c26dc2f3ca53a605a74b67ec2cee16f2/model/jpa/src/main/resources/META-INF/jpa-changelog-14.0.0.xml#L60-L79,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9260,773079638,2021-12-21T12:03:25Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapStorage.java,"@@ -0,0 +1,50 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.HashMap;+import java.util.Map;+import java.util.function.Supplier;+import javax.persistence.EntityManager;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.jpa.client.JpaClientMapKeycloakTransaction;++public class JpaMapStorage<V extends AbstractEntity, M> implements MapStorage<V, M> {",Would this be better positioned as an inner class of `JpaMapStorageProvider`?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9260,773080577,2021-12-21T12:05:00Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapStorageProvider.java,"@@ -0,0 +1,129 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.sql.Connection;+import java.sql.DatabaseMetaData;+import java.sql.DriverManager;+import java.sql.SQLException;+import java.util.HashMap;+import java.util.LinkedHashMap;+import javax.naming.InitialContext;+import javax.naming.NamingException;+import javax.persistence.EntityManager;+import javax.sql.DataSource;+import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.common.util.StringPropertyReplacer;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.dblock.DBLockManager;+import org.keycloak.models.dblock.DBLockProvider;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;+import org.keycloak.models.map.storage.MapStorageProviderFactory.Flag;+import org.keycloak.models.map.storage.jpa.updater.MapJpaUpdaterProvider;+import org.keycloak.models.utils.KeycloakModelUtils;++public class JpaMapStorageProvider implements MapStorageProvider {++    private static final Logger logger = Logger.getLogger(JpaMapStorageProvider.class);+    private final EntityManager em;+    private final KeycloakSession session;+    private final Config.Scope config;++    public JpaMapStorageProvider(EntityManager em, KeycloakSession session, Config.Scope config) {+        this.em = em;+        this.session = session;+        this.config = config;+    }++    @Override+    public void close() {+        em.close();+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public <V extends AbstractEntity, M> MapStorage<V, M> getStorage(Class<M> modelType, Flag... flags) {+        init(modelType);+        return new JpaMapStorage(em, modelType);+    }++    private void init(Class<?> modelType) {+        Connection connection = getConnection();+        printOperationalInfo(connection);","Should this be printed always? Also it could be executed conditionally, e.g. only when DEBUG level is enabled",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9260,773082609,2021-12-21T12:08:41Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapStorageProvider.java,"@@ -0,0 +1,129 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.sql.Connection;+import java.sql.DatabaseMetaData;+import java.sql.DriverManager;+import java.sql.SQLException;+import java.util.HashMap;+import java.util.LinkedHashMap;+import javax.naming.InitialContext;+import javax.naming.NamingException;+import javax.persistence.EntityManager;+import javax.sql.DataSource;+import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.common.util.StringPropertyReplacer;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.dblock.DBLockManager;+import org.keycloak.models.dblock.DBLockProvider;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;+import org.keycloak.models.map.storage.MapStorageProviderFactory.Flag;+import org.keycloak.models.map.storage.jpa.updater.MapJpaUpdaterProvider;+import org.keycloak.models.utils.KeycloakModelUtils;++public class JpaMapStorageProvider implements MapStorageProvider {++    private static final Logger logger = Logger.getLogger(JpaMapStorageProvider.class);+    private final EntityManager em;+    private final KeycloakSession session;+    private final Config.Scope config;++    public JpaMapStorageProvider(EntityManager em, KeycloakSession session, Config.Scope config) {+        this.em = em;+        this.session = session;+        this.config = config;+    }++    @Override+    public void close() {+        em.close();+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public <V extends AbstractEntity, M> MapStorage<V, M> getStorage(Class<M> modelType, Flag... flags) {+        init(modelType);",- Could the attempted updates be tracked in the factory to prevent locking / rechecking the update status upon every provider instantiation?- Perhaps the whole `init` method logic could be put into the `JpaMapStorageProviderFactory`? This would enable removing reference to `config` in this class.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9251,773204160,2021-12-21T14:56:19Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/storage/database/jpa/QuarkusJpaConnectionProviderFactory.java,"@@ -81,7 +81,7 @@      public static final String QUERY_PROPERTY_PREFIX = ""kc.query."";     private static final Logger logger = Logger.getLogger(QuarkusJpaConnectionProviderFactory.class);-    private static final String SQL_GET_LATEST_VERSION = ""SELECT VERSION FROM %sMIGRATION_MODEL"";+    private static final String SQL_GET_LATEST_VERSION = ""SELECT VERSION FROM %sMIGRATION_MODEL ORDER BY UPDATE_TIME DESC"";",Shouldn't this use: https://github.com/keycloak/keycloak/blob/db60f56fe8fba2c842d99a3ade3857cae9b82b50/model/jpa/src/main/java/org/keycloak/models/jpa/entities/MigrationModelEntity.java#L37,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9176,773265080,2021-12-21T16:10:06Z,model/map/src/main/java/org/keycloak/models/map/storage/tree/TreeStorageNodePrescription.java,"@@ -0,0 +1,271 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.tree;++import java.util.Collection;+import java.util.HashMap;+import java.util.Map;+import java.util.Map.Entry;+import java.util.Optional;+import java.util.concurrent.ConcurrentHashMap;+import java.util.function.Supplier;+import java.util.regex.Matcher;+import java.util.regex.Pattern;+import java.util.stream.Collectors;++import org.jboss.logging.Logger;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.common.EntityField;+import org.keycloak.models.map.storage.ModelEntityUtil;+import org.keycloak.models.map.storage.criteria.DefaultModelCriteria;++/**+ * Prescription of the tree storage. This prescription can+ * be externalized and contains e.g. details on the particular storage type+ * represented by this node, or properties of the node and edge between this+ * and the parent storage.+ * <p>+ * Realization of this prescription is in {@link TreeStorageNodeInstance}, namely it does not+ * contain a map storage instance that can be directly used+ * for accessing data.+ *+ * @author hmlnarik+ */+public class TreeStorageNodePrescription extends DefaultTreeNode<TreeStorageNodePrescription> {++    private static final Logger LOG = Logger.getLogger(TreeStorageNodePrescription.class);+    private final boolean isPrimarySourceForAnything;+    private final boolean isPrimarySourceForEverything;+    private final boolean isCacheForAnything;++    public static enum FieldContainedStatus {+        /** +         * Field is fully contained in the storage in this node.+         * For example, attribute {@code foo} or field {@code NAME} stored in this node would be {@code FULLY} contained field.+         * @see #PARTIALLY+         */+        FULLY {+            @Override+            public FieldContainedStatus minus(FieldContainedStatus s) {+                switch (s) {+                    case FULLY:+                        return FieldContainedStatus.NOT_CONTAINED;+                    case PARTIALLY:+                        return FieldContainedStatus.PARTIALLY;+                    default:+                        return FieldContainedStatus.FULLY;+                }+            }+        },+        /**+         * Field is contained in the storage in this node but parts of it might be contained in some child node as well.+         * For example, a few attributes can be partially supplied from an LDAP, and the rest could be supplied from the+         * supplementing JPA node.+         * <p>+         * This status is never used in the case of a fully specified field access but can be used for map-like attributes+         * where the key is not specified.+         */+        PARTIALLY {+            @Override+            public FieldContainedStatus minus(FieldContainedStatus s) {+                switch (s) {+                    case FULLY:+                        return FieldContainedStatus.NOT_CONTAINED;+                    default:+                        return FieldContainedStatus.PARTIALLY;+                }+            }+        },+        /** Field is not contained in the storage in this node but parts of it might be contained in some child node as well */+        NOT_CONTAINED {+            @Override+            public FieldContainedStatus minus(FieldContainedStatus s) {+                return FieldContainedStatus.NOT_CONTAINED;+            }+        };++        public abstract FieldContainedStatus minus(FieldContainedStatus s);+        /**+         * Returns higher of this and the {@code other} field status: {@link #FULLY} &gt; {@link #PARTIALLY} &gt; {@link #NOT_CONTAINED}+         */+        public FieldContainedStatus max(FieldContainedStatus other) {+            return (other == null || ordinal() < other.ordinal()) ? this : other;+        }+        public FieldContainedStatus max(Supplier<FieldContainedStatus> otherFunc) {+            if (ordinal() == 0) {+                return this;+            }+            FieldContainedStatus other = otherFunc.get();+            return other == null || ordinal() < other.ordinal() ? this : other;+        }+    }++    /**+     * Map of prescriptions restricted per entity class derived from this prescription.+     */+    private final Map<Class<? extends AbstractEntity>, TreeStorageNodePrescription> restricted = new ConcurrentHashMap<>();++    public TreeStorageNodePrescription(Map<String, Object> treeProperties) {+        this(treeProperties, null, null);+    }++    public TreeStorageNodePrescription(Map<String, Object> nodeProperties, Map<String, Object> edgeProperties, Map<String, Object> treeProperties) {+        super(nodeProperties, edgeProperties, treeProperties);+        Map<?, ?> psf = (Map<?, ?>) this.nodeProperties.get(NodeProperties.PRIMARY_SOURCE_FOR);+        Map<?, ?> psfe = (Map<?, ?>) this.nodeProperties.get(NodeProperties.PRIMARY_SOURCE_FOR_EXCLUDED);+        isPrimarySourceForAnything = (psf != null && ! psf.isEmpty()) || (psfe != null && ! psfe.isEmpty());+        isPrimarySourceForEverything = (psf == null) && (psfe == null || psfe.isEmpty());   // This could be restricted further+        Map<?, ?> cf = (Map<?, ?>) this.nodeProperties.get(NodeProperties.CACHE_FOR);+        Map<?, ?> cfe = (Map<?, ?>) this.nodeProperties.get(NodeProperties.CACHE_FOR_EXCLUDED);+        isCacheForAnything = (cf != null && ! cf.isEmpty()) || (cfe != null && ! cfe.isEmpty());+    }++    public boolean isStronglyAuthoritative(DefaultModelCriteria<?> criteria) {+        Optional<DefaultModelCriteria> dmc = getNodeProperty(NodeProperties.ENTITY_RESTRICTION, DefaultModelCriteria.class);",This is unused,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9176,773277596,2021-12-21T16:26:26Z,model/map/src/test/java/org/keycloak/models/map/common/delegate/PerFieldDelegateProviderCacheTest.java,"@@ -0,0 +1,325 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common.delegate;++import org.keycloak.models.map.client.MapClientEntity;+import org.keycloak.models.map.client.MapClientEntityFields;+import org.keycloak.models.map.client.MapClientEntityImpl;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.storage.tree.NodeProperties;+import org.keycloak.models.map.storage.tree.TreeStorageNodeInstance;+import org.keycloak.models.map.storage.tree.TreeStorageNodePrescription;+import java.util.Arrays;+import java.util.Collections;+import java.util.EnumMap;+import java.util.HashMap;+import java.util.concurrent.atomic.AtomicInteger;+import org.junit.Before;+import org.junit.Test;+import static org.hamcrest.MatcherAssert.assertThat;+import static org.hamcrest.Matchers.contains;+import static org.hamcrest.Matchers.containsInAnyOrder;+import static org.hamcrest.Matchers.hasEntry;+import static org.hamcrest.Matchers.is;+import static org.hamcrest.Matchers.nullValue;++/**+ *+ * @author hmlnarik+ */+public class PerFieldDelegateProviderCacheTest {++    private MapClientEntity upperEnt;+    private MapClientEntity lowerEnt;++    private HashMap<String, Object> upperNodeProperties;+    private EnumMap<MapClientEntityFields, Object> upperCacheFor;+    private EnumMap<MapClientEntityFields, Object> upperCacheForExcluded;++    private HashMap<String, Object> lowerNodeProperties;+    private EnumMap<MapClientEntityFields, Object> lowerCacheFor;+    private EnumMap<MapClientEntityFields, Object> lowerCacheForExcluded;++    private TreeStorageNodeInstance<MapClientEntity> upperTsni;+    private TreeStorageNodeInstance<MapClientEntity> lowerTsni;++    AtomicInteger lowerEntSupplierCallCount = new AtomicInteger();++    @Before+    public void initEntities() {+        upperEnt = new MapClientEntityImpl();+        lowerEnt = new MapClientEntityImpl();++        upperEnt.setProtocol(""upper-protocol"");+        upperEnt.addRedirectUri(""upper-redirectUri-1"");+        upperEnt.addRedirectUri(""upper-redirectUri-2"");+        upperEnt.setClientId(""upper-clientId-1"");+        upperEnt.setAttribute(""attr1"", Arrays.asList(""upper-value-1""));+        upperEnt.setAttribute(""attr2"", Arrays.asList(""upper-value-2""));+        upperEnt.setAttribute(""attr3"", Arrays.asList(""upper-value-3""));++        lowerEnt.setProtocol(""lower-protocol"");+        lowerEnt.addRedirectUri(""lower-redirectUri-1"");+        lowerEnt.addRedirectUri(""lower-redirectUri-2"");+        lowerEnt.setClientId(""lower-clientId-1"");+        lowerEnt.setAttribute(""attr1"", Arrays.asList(""lower-value-1""));+        lowerEnt.setAttribute(""attr3"", Arrays.asList(""lower-value-3""));+        lowerEnt.setAttribute(""attr4"", Arrays.asList(""lower-value-4""));++        upperNodeProperties = new HashMap<>();+        upperCacheFor = new EnumMap<>(MapClientEntityFields.class);+        upperCacheForExcluded = new EnumMap<>(MapClientEntityFields.class);++        lowerNodeProperties = new HashMap<>();+        lowerCacheFor = new EnumMap<>(MapClientEntityFields.class);+        lowerCacheForExcluded = new EnumMap<>(MapClientEntityFields.class);++        lowerEntSupplierCallCount.set(0);+    }++    private MapClientEntity prepareEntityAndTreeNodeInstances() {+        TreeStorageNodePrescription upperTsnp = new TreeStorageNodePrescription(upperNodeProperties, null, null);+        TreeStorageNodePrescription lowerTsnp = new TreeStorageNodePrescription(lowerNodeProperties, null, null);++        upperTsni = new TreeStorageNodeInstance<>(null, upperTsnp);+        lowerTsni = new TreeStorageNodeInstance<>(null, lowerTsnp);",This is unused,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9176,773278327,2021-12-21T16:27:22Z,model/map/src/test/java/org/keycloak/models/map/common/delegate/PerFieldDelegateProviderCacheTest.java,"@@ -0,0 +1,325 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common.delegate;++import org.keycloak.models.map.client.MapClientEntity;+import org.keycloak.models.map.client.MapClientEntityFields;+import org.keycloak.models.map.client.MapClientEntityImpl;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.storage.tree.NodeProperties;+import org.keycloak.models.map.storage.tree.TreeStorageNodeInstance;+import org.keycloak.models.map.storage.tree.TreeStorageNodePrescription;+import java.util.Arrays;+import java.util.Collections;+import java.util.EnumMap;+import java.util.HashMap;+import java.util.concurrent.atomic.AtomicInteger;+import org.junit.Before;+import org.junit.Test;+import static org.hamcrest.MatcherAssert.assertThat;+import static org.hamcrest.Matchers.contains;+import static org.hamcrest.Matchers.containsInAnyOrder;+import static org.hamcrest.Matchers.hasEntry;+import static org.hamcrest.Matchers.is;+import static org.hamcrest.Matchers.nullValue;++/**+ *+ * @author hmlnarik+ */+public class PerFieldDelegateProviderCacheTest {++    private MapClientEntity upperEnt;+    private MapClientEntity lowerEnt;++    private HashMap<String, Object> upperNodeProperties;+    private EnumMap<MapClientEntityFields, Object> upperCacheFor;+    private EnumMap<MapClientEntityFields, Object> upperCacheForExcluded;++    private HashMap<String, Object> lowerNodeProperties;+    private EnumMap<MapClientEntityFields, Object> lowerCacheFor;+    private EnumMap<MapClientEntityFields, Object> lowerCacheForExcluded;++    private TreeStorageNodeInstance<MapClientEntity> upperTsni;+    private TreeStorageNodeInstance<MapClientEntity> lowerTsni;++    AtomicInteger lowerEntSupplierCallCount = new AtomicInteger();++    @Before+    public void initEntities() {+        upperEnt = new MapClientEntityImpl();+        lowerEnt = new MapClientEntityImpl();++        upperEnt.setProtocol(""upper-protocol"");+        upperEnt.addRedirectUri(""upper-redirectUri-1"");+        upperEnt.addRedirectUri(""upper-redirectUri-2"");+        upperEnt.setClientId(""upper-clientId-1"");+        upperEnt.setAttribute(""attr1"", Arrays.asList(""upper-value-1""));+        upperEnt.setAttribute(""attr2"", Arrays.asList(""upper-value-2""));+        upperEnt.setAttribute(""attr3"", Arrays.asList(""upper-value-3""));++        lowerEnt.setProtocol(""lower-protocol"");+        lowerEnt.addRedirectUri(""lower-redirectUri-1"");+        lowerEnt.addRedirectUri(""lower-redirectUri-2"");+        lowerEnt.setClientId(""lower-clientId-1"");+        lowerEnt.setAttribute(""attr1"", Arrays.asList(""lower-value-1""));+        lowerEnt.setAttribute(""attr3"", Arrays.asList(""lower-value-3""));+        lowerEnt.setAttribute(""attr4"", Arrays.asList(""lower-value-4""));++        upperNodeProperties = new HashMap<>();+        upperCacheFor = new EnumMap<>(MapClientEntityFields.class);+        upperCacheForExcluded = new EnumMap<>(MapClientEntityFields.class);++        lowerNodeProperties = new HashMap<>();+        lowerCacheFor = new EnumMap<>(MapClientEntityFields.class);+        lowerCacheForExcluded = new EnumMap<>(MapClientEntityFields.class);++        lowerEntSupplierCallCount.set(0);+    }++    private MapClientEntity prepareEntityAndTreeNodeInstances() {+        TreeStorageNodePrescription upperTsnp = new TreeStorageNodePrescription(upperNodeProperties, null, null);+        TreeStorageNodePrescription lowerTsnp = new TreeStorageNodePrescription(lowerNodeProperties, null, null);",This is unused,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9176,773694865,2021-12-22T08:28:26Z,model/map/src/main/java/org/keycloak/models/map/storage/tree/TreeStorageNodeInstance.java,"@@ -0,0 +1,128 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.tree;","I think not because of the following:- Tree storage will only be a few classes- Tree storage is based on map storage, and interferes with it- In most cases, map storage will be used in tree setup",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,773763572,2021-12-22T10:07:16Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryWhereClauses.java,"@@ -71,11 +73,20 @@ private static WhereClauseProducer whereClauseProducerForModelField(SearchableMo      */     public static String produceWhereClause(SearchableModelField<?> modelField, ModelCriteriaBuilder.Operator op,                                             Object[] values, Map<String, Object> parameters) {+        if (IckleQueryMapModelCriteriaBuilder.isAnalyzedModelField(modelField) && !op.equals(ModelCriteriaBuilder.Operator.ILIKE)) {+            throw new CriterionNotSupportedException(modelField, op, ""Analyzed field "" + modelField.getName() + "" can be only used with ILIKE operator!"");+        }++        // determine, based on the operator and type of field, whether we need to use lowercase variant of a field+        String fieldName = op.equals(ModelCriteriaBuilder.Operator.ILIKE) && !IckleQueryMapModelCriteriaBuilder.isAnalyzedModelField(modelField) ?+                IckleQueryMapModelCriteriaBuilder.MODEL_FIELD_OVERRIDES.getOrDefault(modelField, modelField.getName()) :+                IckleQueryMapModelCriteriaBuilder.getFieldName(modelField);+         return whereClauseProducerForModelField(modelField)-                .produceWhereClause(IckleQueryMapModelCriteriaBuilder.getFieldName(modelField), op, values, parameters);+                .produceWhereClause(modelField, fieldName, op, sanitizeValues(modelField, op, values), parameters);",`fieldName` doesn't need to be passed as a parameter. It can be derived from the `modelField` later.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,773782659,2021-12-22T10:34:52Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryMapModelCriteriaBuilder.java,"@@ -175,6 +200,67 @@ private StringBuilder getWhereClauseBuilder() {         return whereClauseBuilder;     } +    public static Object getFirstArrayElement(Object[] value) throws IllegalStateException {+        if (value == null || value.length == 0) {+            throw new IllegalStateException(""Invalid argument: "" + Arrays.toString(value));+        }+        return value[0];+    }++    public static Object[] sanitizeValues(SearchableModelField<?> modelField, Operator op, Object[] values) {+        if (isAnalyzedModelField(modelField) || isOverriddenModelField(modelField, op)) {+            Object value0 = IckleQueryMapModelCriteriaBuilder.getFirstArrayElement(values);+            if (value0 instanceof String) {+                sanitizeStringInputs(modelField, op, values);+            }+        }++        return values;+    }++    private static void sanitizeStringInputs(SearchableModelField modelField, Operator op, Object[] values) {+        if (isAnalyzedModelField(modelField)) {+            IntStream.range(0, values.length).forEach(i -> values[i] = sanitizeAnalyzed((String) values[i]));+        } else {+            if (isOverriddenModelField(modelField, op)) {+                IntStream.range(0, values.length).forEach(i -> values[i] = sanitize((String) values[i]).toLowerCase());","Sanitize method should not switch the case to lowercase, it should just sanitize the string. Would it be possible to move all sanitization methods to some Util class and use it as the last thing before adding to the query? This way we wouldn't need to check here whether it is analyzed, lowercase, etc. we will just use the correct method because at the time we are adding it to the query, we know whether it is analyzed or not. In the end, we would have only two methods `sanitize` and `sanitizeAnalyzed`.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9294,773825229,2021-12-22T11:44:42Z,quarkus/tests/integration/src/test/java/org/keycloak/it/storage/database/MariaDBStartDatabaseTest.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.it.storage.database;++import org.junit.jupiter.api.Test;+import org.keycloak.it.junit5.extension.CLIResult;+import org.keycloak.it.junit5.extension.CLITest;+import org.keycloak.it.junit5.extension.WithDatabase;++import io.quarkus.test.junit.main.Launch;+import io.quarkus.test.junit.main.LaunchResult;++@CLITest+@WithDatabase(alias = ""mariadb"")+public class MariaDBStartDatabaseTest {++    @Test","The standard tests are mostly copy-pasted across implementation, can we refactor into an `abstract class`?",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/9252,773857213,2021-12-22T12:40:05Z,services/src/main/java/org/keycloak/forms/login/freemarker/model/WebAuthnAuthenticatorsBean.java,"@@ -34,22 +39,35 @@ public WebAuthnAuthenticatorsBean(KeycloakSession session, RealmModel realm, Use                 .map(WebAuthnCredentialModel::createFromCredentialModel)                 .map(webAuthnCredential -> {                     String credentialId = Base64Url.encodeBase64ToBase64Url(webAuthnCredential.getWebAuthnCredentialData().getCredentialId());-                    String label = (webAuthnCredential.getUserLabel()==null || webAuthnCredential.getUserLabel().isEmpty()) ? ""label missing"" : webAuthnCredential.getUserLabel();-                    return new WebAuthnAuthenticatorBean(credentialId, label);+                    String label = (webAuthnCredential.getUserLabel() == null || webAuthnCredential.getUserLabel().isEmpty()) ? ""label missing"" : webAuthnCredential.getUserLabel();+                    String createdAt = getDateTimeFromMillis(webAuthnCredential.getCreatedDate());+                    return new WebAuthnAuthenticatorBean(credentialId, label, createdAt);                 }).collect(Collectors.toList());     } +    private String getDateTimeFromMillis(long millis) {+        return getDateTimeFromMillis(millis, ""dd-MM-yyyy HH:mm"");","Unfortunately, AFAIK the date is not displayed anywhere in login theme. There's some JS/TS util class for account console, but we are not able to use it here. Therefore, we need to create custom time formatter.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/9294,773871253,2021-12-22T13:04:08Z,quarkus/tests/integration/src/main/java/org/keycloak/it/junit5/extension/WithDatabase.java,"@@ -0,0 +1,40 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.it.junit5.extension;++import java.lang.annotation.ElementType;+import java.lang.annotation.Retention;+import java.lang.annotation.RetentionPolicy;+import java.lang.annotation.Target;+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;++/**+ * {@link WithDatabase} is used to start a database container.+ */+@Target({ElementType.TYPE, ElementType.METHOD})+@Retention(RetentionPolicy.RUNTIME)+@EnabledIfSystemProperty(named = ""kc.test.storage.database"", matches = ""true"", disabledReason = ""Docker takes too much time and stability depends on the environment. We should try running these tests in CI but isolated."")",I did not try yet to run all database tests. Locally they are not very stable for me and I would gradually add more database tests.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/9294,773871572,2021-12-22T13:04:43Z,quarkus/tests/integration/src/test/java/org/keycloak/it/storage/database/MariaDBStartDatabaseTest.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.it.storage.database;++import org.junit.jupiter.api.Test;+import org.keycloak.it.junit5.extension.CLIResult;+import org.keycloak.it.junit5.extension.CLITest;+import org.keycloak.it.junit5.extension.WithDatabase;++import io.quarkus.test.junit.main.Launch;+import io.quarkus.test.junit.main.LaunchResult;++@CLITest+@WithDatabase(alias = ""mariadb"")+public class MariaDBStartDatabaseTest {++    @Test","Not sure, they have specific messages accordingly to the database.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9260,774078011,2021-12-22T18:10:37Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapStorage.java,"@@ -0,0 +1,50 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.HashMap;+import java.util.Map;+import java.util.function.Supplier;+import javax.persistence.EntityManager;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.jpa.client.JpaClientMapKeycloakTransaction;++public class JpaMapStorage<V extends AbstractEntity, M> implements MapStorage<V, M> {",As discussed it is replaced by anonymous class in `JpaMapStorageProvider`,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9260,774337851,2021-12-23T06:12:27Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapStorageProvider.java,"@@ -0,0 +1,58 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.HashMap;+import java.util.Map;+import java.util.function.Function;+import javax.persistence.EntityManager;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;+import org.keycloak.models.map.storage.MapStorageProviderFactory.Flag;+import org.keycloak.models.map.storage.jpa.client.JpaClientMapKeycloakTransaction;++public class JpaMapStorageProvider implements MapStorageProvider {++    private final JpaMapStorageProviderFactory factory;+    private final KeycloakSession session;+    private final EntityManager em;+    private final Map<Class<?>, Function<EntityManager, MapKeycloakTransaction>> transactionConstructors = new HashMap<>();","Should this be put into provider factory, perhaps even `static` there? It seems pretty stable and independent, initialized only in the constructor, and there is a reference to `factory` anyway. Ideally there would be a method in the provider factory that would access it rather than a direct access to the field.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9260,774351671,2021-12-23T06:34:17Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapStorageProvider.java,"@@ -0,0 +1,58 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.HashMap;+import java.util.Map;+import java.util.function.Function;+import javax.persistence.EntityManager;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;+import org.keycloak.models.map.storage.MapStorageProviderFactory.Flag;+import org.keycloak.models.map.storage.jpa.client.JpaClientMapKeycloakTransaction;++public class JpaMapStorageProvider implements MapStorageProvider {++    private final JpaMapStorageProviderFactory factory;+    private final KeycloakSession session;+    private final EntityManager em;+    private final Map<Class<?>, Function<EntityManager, MapKeycloakTransaction>> transactionConstructors = new HashMap<>();++    public JpaMapStorageProvider(JpaMapStorageProviderFactory factory, KeycloakSession session, EntityManager em) {+        this.factory = factory;+        this.session = session;+        this.em = em;+        transactionConstructors.put(ClientModel.class, JpaClientMapKeycloakTransaction::new);+    }++    @Override+    public void close() {+        em.close();+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public <V extends AbstractEntity, M> MapStorage<V, M> getStorage(Class<M> modelType, Flag... flags) {+        factory.validateAndUpdateSchema(session, modelType);+        return (session) -> transactionConstructors.get(modelType).apply(em);","- There is no guarantee that `MapStorage` would remain a single-method interface in the future, and likely there will be further methods added. Please use a proper (inner or just anonymous) class- I realized we have a bug in logic in this method, #9321. Please keep track of created transactions in the storage per model in the `session` and just return an existing one if called multiple times. See e.g. https://github.com/keycloak/keycloak/blob/96b2669a00dc1396138f863bbc11aa0b0aa3f0b6/model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java#L131",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9381,778068998,2022-01-04T13:10:01Z,.github/workflows/operator-ci.yml,"@@ -0,0 +1,42 @@+name: Keycloak Operator CI++on: [push, pull_request]++env:+  JDK_VERSION: 17++concurrency:+  # Only run once for latest commit per ref and cancel other (previous) runs.+  group: ci-operator-keycloak-${{ github.ref }}+  cancel-in-progress: true++jobs:+  build:+    name: Build+    runs-on: ubuntu-latest+    steps:+      - uses: actions/checkout@v2+      - name: Update maven settings+        run: mkdir -p ~/.m2 ; cp .github/settings.xml ~/.m2/+      - name: Cache Maven packages+        id: cache+        uses: actions/cache@v2+        with:+          path: |+            ~/.m2/repository+          key: cache-1-${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}+          restore-keys: cache-1-${{ runner.os }}-m2++      - uses: actions/setup-java@v1+        with:+          java-version: 11+      - name: Create the Keycloak distribution+        run: |+          mvn clean install -Pdistribution -DskipTests -DskipExamples -DskipTestsuite",Why to build the ZIP dist? For tests we'll have to build the image instead. For the dependencies we can build without `-Pdistribution` as it's significantly faster.Just a note. This workflow should be moved to the main [ci.yaml](https://github.com/keycloak/keycloak/blob/main/.github/workflows/ci.yml) in the future (once the operator is out of the prototype stage) so this line won't be then necessary at all.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9381,778929685,2022-01-05T15:49:40Z,operator/src/main/java/org/keycloak/operator/Constants.java,"@@ -0,0 +1,36 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator;++import java.util.Map;++public final class Constants {+    public static final String CRDS_GROUP = ""keycloak.org"";+    public static final String CRDS_VERSION = ""v1alpha1"";+    public static final String SHORT_NAME = ""kc"";+    public static final String NAME = ""keycloak"";+    public static final String PLURAL_NAME = ""keycloaks"";+    public static final String MANAGED_BY_LABEL = ""app.kubernetes.io/managed-by"";+    public static final String MANAGED_BY_VALUE = ""keycloak-quarkus-operator"";",A generic comment. I'd omit `quarkus` from the operator identification. It's too long and we don't need to differentiate that it's a Quarkus operator. IMHO conflicts with the old operator are not a problem as the old operator was never installed cluster wide.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9381,778958439,2022-01-05T16:26:04Z,operator/src/main/java/org/keycloak/operator/KeycloakDeployment.java,"@@ -0,0 +1,146 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.api.model.apps.DeploymentBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import org.keycloak.operator.crds.Keycloak;+import org.keycloak.operator.crds.KeycloakSpec;+import org.keycloak.operator.crds.KeycloakStatus;++import static org.keycloak.operator.crds.KeycloakStatus.State.*;++public class KeycloakDeployment {++    KubernetesClient client = null;++    KeycloakDeployment(KubernetesClient client) {+        this.client = client;+    }++    public Deployment getKeycloakDeployment(Keycloak keycloak) {+        // TODO this should be done through an informer to leverage caches+        // WORKAROUND for: https://github.com/java-operator-sdk/java-operator-sdk/issues/781+        return client+                .apps()+                .deployments()+                .inNamespace(keycloak.getMetadata().getNamespace())+                .list()+                .getItems()+                .stream()+                .filter((d) -> d.getMetadata().getName().equals(org.keycloak.operator.Constants.NAME))+                .findFirst()+                .orElse(null);+//                .withName(Constants.NAME)+//                .get();+    }++    public void createKeycloakDeployment(Keycloak keycloak) {+        client+            .apps()+            .deployments()+            .inNamespace(keycloak.getMetadata().getNamespace())+            .create(newKeycloakDeployment(keycloak));+    }++    public Deployment newKeycloakDeployment(Keycloak keycloak) {+        return new DeploymentBuilder()",Just something to discuss for a follow-up task (doesn't block this PR). Maybe we could use a YAML file template and just modify the variable parts in it instead of doing this spaghetti. :) WDYT?,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9381,778998391,2022-01-05T17:18:51Z,operator/pom.xml,"@@ -0,0 +1,149 @@+<?xml version=""1.0""?>+<project xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd""+         xmlns=""http://maven.apache.org/POM/4.0.0""+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">+    <modelVersion>4.0.0</modelVersion>++    <parent>+        <artifactId>keycloak-parent</artifactId>+        <groupId>org.keycloak</groupId>+        <version>17.0.0-SNAPSHOT</version>+    </parent>+    +    <name>Keycloak Quarkus Operator</name>+    <artifactId>keycloak-quarkus-operator</artifactId>++    <properties>+        <!--+            Override versions based on Quarkus dependencies.+            Make sure to update these dependencies when Quarkus version changes.+            See https://github.com/quarkusio/quarkus/blob/<versionTag>/bom/application/pom.xml+            for reference+        -->+        <resteasy.version>4.7.4.Final</resteasy.version>+        <wildfly.common.version>1.5.4.Final-format-001</wildfly.common.version>++        <compiler-plugin.version>3.8.1</compiler-plugin.version>+        <maven.compiler.parameters>true</maven.compiler.parameters>+        <maven.compiler.release>11</maven.compiler.release>+        <maven.compiler.source>11</maven.compiler.source>+        <maven.compiler.target>11</maven.compiler.target>+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>+        <quarkus.operator.sdk.version>3.0.0-SNAPSHOT</quarkus.operator.sdk.version>+        <quarkus.version>2.6.1.Final</quarkus.version>",we are bumping the patch version from what is provided:https://github.com/quarkiverse/quarkus-operator-sdk/blob/355ac8d8798d3485acffc70133a7dcce04419827/build-parent/pom.xml#L20,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9381,779418827,2022-01-06T09:41:04Z,operator/src/main/java/org/keycloak/operator/Constants.java,"@@ -0,0 +1,36 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator;++import java.util.Map;++public final class Constants {+    public static final String CRDS_GROUP = ""keycloak.org"";+    public static final String CRDS_VERSION = ""v1alpha1"";","Needed to change the group at all, temporary set to `keycloak.io` to have successful validation, we can discuss and decide on this detail later.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9415,780210568,2022-01-07T11:36:36Z,model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java,"@@ -70,6 +70,7 @@ public RoleModel addRealmRole(RealmModel realm, String id, String name) {         entity.setId(id);         entity.setRealmId(realm.getId());         entity.setName(name);+        entity.setClientRole(false);         if (tx.read(entity.getId()) != null) {             throw new ModelDuplicateException(""Role exists: "" + id);         }","I assume this ID is a UUID and wonder why this code exists. Is it because there could be a UUID collision? I wonder if the exception would be more helpful if it would provide also the name of the role, and would be worded differently, as it is not necessarily about the role, but the ID of the role.Same goes for the Exception above, where a pre-existing realm role is checked. This should have the name in the exception IMHO, and it read maybe ""Role with same name exists:"".",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9415,780213881,2022-01-07T11:43:50Z,model/map-jpa/src/main/resources/META-INF/roles/jpa-roles-changelog-1.xml,"@@ -0,0 +1,72 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: roles-${org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_ROLE} -->+    <changeSet author=""keycloak"" id=""roles-1"">++        <createTable tableName=""role"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""role"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""name"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fName""/>+        </ext:addGeneratedColumn>+        <createIndex tableName=""role"" indexName=""role_entityVersion"">+            <column name=""entityversion""/>+        </createIndex>+        <createIndex tableName=""role"" indexName=""role_name"">+            <column name=""name""/>+        </createIndex>","While the MapRoleProvider checks if a role already exists, this depends on the isolation level for the JPA provider. I wonder if this index could be unique to be independent of the isolation level. Depending on the decision here, I wonder if some of other indexes here should be unique as well, or if there should be some deferable constraints avoiding hibernate-ordering of deletes and inserts.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9415,780229044,2022-01-07T12:18:07Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/entity/JpaRoleEntity.java,"@@ -0,0 +1,273 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.role.entity;++import java.io.Serializable;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.role.MapRoleEntity.AbstractRoleEntity;+import static org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_ROLE;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""role"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaRoleEntity extends AbstractRoleEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaRoleMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String name;++    @OneToMany(mappedBy = ""role"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaRoleAttributeEntity> attributes = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaRoleEntity() {+        this.metadata = new JpaRoleMetadata();+    }++    public JpaRoleEntity(DeepCloner cloner) {+        this.metadata = new JpaRoleMetadata(cloner);+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select role without metadata(json) field.+     */+    public JpaRoleEntity(UUID id, Integer entityVersion, String name) {+        this.id = id;+        this.entityVersion = entityVersion;+        this.name = name;+        this.metadata = null;+    }++    public boolean isMetadataInitialized() {+        return metadata != null;+    }++    /**+     * In case of any update on entity, we want to update the entityVerion+     * to current one.+     */+    private void checkEntityVersionForUpdate() {+        Integer ev = getEntityVersion();+        if (ev != null && ev < SUPPORTED_VERSION_ROLE) {+            setEntityVersion(SUPPORTED_VERSION_ROLE);+        }+    }++    public Integer getEntityVersion() {+        if (isMetadataInitialized()) return metadata.getEntityVersion();+        return entityVersion;+    }++    public void setEntityVersion(Integer entityVersion) {+        metadata.setEntityVersion(entityVersion);+    }++    @Override+    public String getId() {+        return id == null ? null : id.toString();+    }++    @Override+    public void setId(String id) {+        this.id = id == null ? null : UUID.fromString(id);+    }++    @Override+    public Boolean isClientRole() {+        return metadata.isClientRole();+    }++    @Override+    public String getRealmId() {+        return metadata.getRealmId();+    }++    @Override+    public String getClientId() {+        return metadata.getClientId();+    }++    @Override+    public String getName() {+        if (isMetadataInitialized()) return metadata.getName();+        return name;+    }++    @Override+    public String getDescription() {+        return metadata.getDescription();+    }++    @Override+    public void setClientRole(Boolean clientRole) {+        checkEntityVersionForUpdate();+        metadata.setClientRole(clientRole);+    }++    @Override+    public void setRealmId(String realmId) {+        checkEntityVersionForUpdate();+        metadata.setRealmId(realmId);+    }++    @Override+    public void setClientId(String clientId) {+        checkEntityVersionForUpdate();+        metadata.setClientId(clientId);+    }++    @Override+    public void setName(String name) {+        checkEntityVersionForUpdate();+        metadata.setName(name);+    }++    @Override+    public void setDescription(String description) {+        checkEntityVersionForUpdate();+        metadata.setDescription(description);+    }++    @Override+    public Set<String> getCompositeRoles() {+        return metadata.getCompositeRoles();+    }++    @Override+    public void setCompositeRoles(Set<String> compositeRoles) {+        checkEntityVersionForUpdate();+        metadata.setCompositeRoles(compositeRoles);+    }++    @Override+    public void addCompositeRole(String roleId) {+        checkEntityVersionForUpdate();+        metadata.addCompositeRole(roleId);+    }++    @Override+    public void removeCompositeRole(String roleId) {+        checkEntityVersionForUpdate();+        metadata.removeCompositeRole(roleId);+    }++    @Override+    public Map<String, List<String>> getAttributes() {+        Map<String, List<String>> result = new HashMap<>();+        for (JpaRoleAttributeEntity attribute : attributes) {+            List<String> values = result.getOrDefault(attribute.getName(), new LinkedList<>());+            values.add(attribute.getValue());+            result.put(attribute.getName(), values);+        }+        return result;+    }++    @Override+    public List<String> getAttribute(String name) {+        return attributes.stream()+                .filter(a -> Objects.equals(a.getName(), name))+                .map(JpaRoleAttributeEntity::getValue)+                .collect(Collectors.toList());+    }++    @Override+    public void setAttributes(Map<String, List<String>> attributes) {+        checkEntityVersionForUpdate();+        for (Iterator<JpaRoleAttributeEntity> iterator = this.attributes.iterator(); iterator.hasNext();) {+            JpaRoleAttributeEntity attr = iterator.next();+            iterator.remove();+            attr.setRole(null);+        }+        if (attributes != null) {+            for (Map.Entry<String, List<String>> entry : attributes.entrySet()) {+                setAttribute(entry.getKey(), entry.getValue());+            }+        }+    }++    @Override+    public void setAttribute(String name, List<String> values) {+        checkEntityVersionForUpdate();+        removeAttribute(name);+        for (String value : values) {+            JpaRoleAttributeEntity attribute = new JpaRoleAttributeEntity(this, name, value);+            attributes.add(attribute);+        }+    }++    @Override+    public void removeAttribute(String name) {+        checkEntityVersionForUpdate();+        for (Iterator<JpaRoleAttributeEntity> iterator = attributes.iterator(); iterator.hasNext();) {+            JpaRoleAttributeEntity attr = iterator.next();+            if (Objects.equals(attr.getName(), name)) {+                iterator.remove();+                attr.setRole(null);+            }+        }+    }","While the setters store their data in metadata as well, I don't see this happening for the attribute field (all setter/remove instances).For example for `removeAttribute` I would have expected a call to `metadata.removeAttribute(name);` Is this missing here, or is this triggered somewhere else?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9351,780394014,2022-01-07T16:53:38Z,adapters/oidc/js/rollup.config.ts,"@@ -0,0 +1,81 @@+import commonjs from ""@rollup/plugin-commonjs"";+import inject from ""@rollup/plugin-inject"";+import { nodeResolve } from ""@rollup/plugin-node-resolve"";+import path from ""node:path"";+import type { OutputOptions, RollupOptions } from ""rollup"";+import { defineConfig } from ""rollup"";+import { terser } from ""rollup-plugin-terser"";++interface DefineOptionsArgs {+  file: string;+  name: string;+  amdId: string;+}++function defineOptions({+  file,+  name,+  amdId,+}: DefineOptionsArgs): RollupOptions[] {+  const sourceDir = ""src/main/js"";+  const targetDir = ""target/classes"";+  const commonOptions: RollupOptions = {+    input: path.join(sourceDir, `${file}.js`),+    plugins: [commonjs(), nodeResolve()],+  };++  const umdOutput: OutputOptions = {+    format: ""umd"",+    name,+    amd: { id: amdId },+  };++  return [+    // Modern ES module variant, with externalized dependencies.+    {+      ...commonOptions,+      output: [+        {+          file: path.join(targetDir, `${file}.mjs`),+        },+      ],+      external: [""base64-js"", ""js-sha256""],+    },+    // Legacy Universal Module Definition, or UMD, with inlined dependencies.+    {+      ...commonOptions,+      output: [+        {+          ...umdOutput,+          file: path.join(targetDir, `${file}.js`),+        },+        {+          ...umdOutput,+          file: path.join(targetDir, `${file}.min.js`),+          sourcemap: true,+          sourcemapExcludeSources: true,+          plugins: [terser()],+        },+      ],+      plugins: [+        ...commonOptions.plugins,+        inject({+          Promise: [""es6-promise/dist/es6-promise.min.js"", ""Promise""],","If I understand correctly this is a replacement for the `promise-polyfill` we had hardcoded inside `keycloak.js` previously. This is inlined into the resulting `keycloak.js` so the `keycloak.js` file available from `/auth/js/keycloak.js` always has the Promise definition. Is it correct?However, when `keycloak-js` is used from npm (`keycloak.mjs`), the `Promise` definition seems to be missing. Are we are relying on users of `keycloak-js` to import something that provides Promise themselves, otherwise, it throws an exception [1]? Does it mean that by default applications using `keycloak-js` adapter do not work on old browsers?[1]```throw Error('Keycloak requires an environment that supports Promises. Make sure that you include the appropriate polyfill.');```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/9351,780416226,2022-01-07T17:29:39Z,adapters/oidc/js/rollup.config.ts,"@@ -0,0 +1,81 @@+import commonjs from ""@rollup/plugin-commonjs"";+import inject from ""@rollup/plugin-inject"";+import { nodeResolve } from ""@rollup/plugin-node-resolve"";+import path from ""node:path"";+import type { OutputOptions, RollupOptions } from ""rollup"";+import { defineConfig } from ""rollup"";+import { terser } from ""rollup-plugin-terser"";++interface DefineOptionsArgs {+  file: string;+  name: string;+  amdId: string;+}++function defineOptions({+  file,+  name,+  amdId,+}: DefineOptionsArgs): RollupOptions[] {+  const sourceDir = ""src/main/js"";+  const targetDir = ""target/classes"";+  const commonOptions: RollupOptions = {+    input: path.join(sourceDir, `${file}.js`),+    plugins: [commonjs(), nodeResolve()],+  };++  const umdOutput: OutputOptions = {+    format: ""umd"",+    name,+    amd: { id: amdId },+  };++  return [+    // Modern ES module variant, with externalized dependencies.+    {+      ...commonOptions,+      output: [+        {+          file: path.join(targetDir, `${file}.mjs`),+        },+      ],+      external: [""base64-js"", ""js-sha256""],+    },+    // Legacy Universal Module Definition, or UMD, with inlined dependencies.+    {+      ...commonOptions,+      output: [+        {+          ...umdOutput,+          file: path.join(targetDir, `${file}.js`),+        },+        {+          ...umdOutput,+          file: path.join(targetDir, `${file}.min.js`),+          sourcemap: true,+          sourcemapExcludeSources: true,+          plugins: [terser()],+        },+      ],+      plugins: [+        ...commonOptions.plugins,+        inject({+          Promise: [""es6-promise/dist/es6-promise.min.js"", ""Promise""],","Yes that is correct, this is indeed intended to ensure the scripts that are served statically from the Keycloak server always include a polyfill for `Promise`. Since these statically served scripts are unversioned we have to assume the worst case scenario in terms of browser compatibility, as the server might get upgraded and still serve older browsers in application code.In the case of the ES module variant we are indeed not loading the Promise polyfill by default to reduce final bundle size for end users. The reason for this is that any browser (or other runtime) that supports ES modules natively also has support for `Promise`.This still leaves the edge case of build tooling that bundles this kind of module into an older variant of JavaScript (such as ES5). However since the support for the `module` field is quite new in front-end tooling, I think we can safely assume that users that make use of these tools and want to support older browsers are already actively shipping a polyfill for `Promise`.For those very small subset of users that do not meet the aforementioned conditions, they would still be protected by the fact that they need to upgrade to a new major version (Keycloak 17) of the package. I've made the choice here not to burden new applications with an increased bundle size vs. supporting a group of users that likely does not exist.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/9351,780420266,2022-01-07T17:36:26Z,adapters/oidc/js/rollup.config.ts,"@@ -0,0 +1,81 @@+import commonjs from ""@rollup/plugin-commonjs"";+import inject from ""@rollup/plugin-inject"";+import { nodeResolve } from ""@rollup/plugin-node-resolve"";+import path from ""node:path"";+import type { OutputOptions, RollupOptions } from ""rollup"";+import { defineConfig } from ""rollup"";+import { terser } from ""rollup-plugin-terser"";++interface DefineOptionsArgs {+  file: string;+  name: string;+  amdId: string;+}++function defineOptions({+  file,+  name,+  amdId,+}: DefineOptionsArgs): RollupOptions[] {+  const sourceDir = ""src/main/js"";+  const targetDir = ""target/classes"";+  const commonOptions: RollupOptions = {+    input: path.join(sourceDir, `${file}.js`),+    plugins: [commonjs(), nodeResolve()],+  };++  const umdOutput: OutputOptions = {+    format: ""umd"",+    name,+    amd: { id: amdId },+  };++  return [+    // Modern ES module variant, with externalized dependencies.+    {+      ...commonOptions,+      output: [+        {+          file: path.join(targetDir, `${file}.mjs`),+        },+      ],+      external: [""base64-js"", ""js-sha256""],+    },+    // Legacy Universal Module Definition, or UMD, with inlined dependencies.+    {+      ...commonOptions,+      output: [+        {+          ...umdOutput,+          file: path.join(targetDir, `${file}.js`),+        },+        {+          ...umdOutput,+          file: path.join(targetDir, `${file}.min.js`),+          sourcemap: true,+          sourcemapExcludeSources: true,+          plugins: [terser()],+        },+      ],+      plugins: [+        ...commonOptions.plugins,+        inject({+          Promise: [""es6-promise/dist/es6-promise.min.js"", ""Promise""],",I just realized the last edge case actually does not exist either due to the fact that we were already conditionally loading the polyfill (and other dependencies) in the [module detection code](https://github.com/keycloak/keycloak/blob/443bd4a1baa229cf674cb2b617df8838fc92d22d/adapters/oidc/js/src/main/resources/keycloak.js#L25). So this should not be changing any of the expected behavior we already have in place.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9221,780683538,2022-01-08T16:27:36Z,model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java,"@@ -139,15 +145,19 @@ public void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIden          getEntityById(realm, user.getId())                 .ifPresent(userEntity ->-                        userEntity.addFederatedIdentity(UserFederatedIdentityEntity.fromModel(socialLink)));+                        userEntity.addFederatedIdentity(MapUserFederatedIdentityEntity.fromModel(socialLink)));     }      @Override     public boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {         LOG.tracef(""removeFederatedIdentity(%s, %s, %s)%s"", realm, user.getId(), socialProvider, getShortStackTrace());-        return getEntityById(realm, user.getId())-                .map(entity -> entity.removeFederatedIdentity(socialProvider))-                .orElse(false);++        Optional<MapUserEntity> entityById = getEntityById(realm, user.getId());+        if (!entityById.isPresent()) return false;++        return entityById.map(u -> u.getFederatedIdentity(socialProvider))+                .map(uc -> uc.isPresent() && entityById.get().removeFederatedIdentity(uc.get()))+                .orElse(true); // TODO: make removeFederatedIdentity return Boolean so the caller can correctly handle ""I don't know"" null answer","Does this have to change? Could `removeFederatedIdentity(String federatedIdentity)` be retained and the logic moved to the `AbstractUserEntity` implementation?It seems to me that in the `AbstractUserEntity` it could be as simple as using `removeIf(fi -> Objects.equals(fi.getIdentityProvider(), federatedIdentity)` while keeping existing provider implementation.If so, similarly this would happen in other places in this file",
5443269,csviri,https://api.github.com/repos/keycloak/keycloak/pulls/9381,781006251,2022-01-10T09:16:11Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import javax.inject.Inject;++import io.fabric8.kubernetes.client.KubernetesClient;+import io.javaoperatorsdk.operator.api.reconciler.*;+import io.javaoperatorsdk.operator.api.reconciler.Constants;+import org.jboss.logging.Logger;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;++@ControllerConfiguration(namespaces = Constants.WATCH_CURRENT_NAMESPACE, finalizerName = Constants.NO_FINALIZER)+public class KeycloakController implements Reconciler<Keycloak> {++    @Inject+    Logger logger;++    @Inject+    KubernetesClient client;++    @Override+    public UpdateControl<Keycloak> reconcile(Keycloak kc, Context context) {+        logger.trace(""Reconcile loop started"");+        final var spec = kc.getSpec();++        logger.info(""Reconciling Keycloak: "" + kc.getMetadata().getName() + "" in namespace: "" + kc.getMetadata().getNamespace());++        KeycloakStatus status = kc.getStatus();+        var deployment = new KeycloakDeployment(client);++        try {+            var kcDeployment = deployment.getKeycloakDeployment(kc);++            if (kcDeployment == null) {","Not sure about the target scope of this operator, looks great as a baseline. Just maybe a small comment here:The situation might be covered when, when the target deployment specs is different from the one is already there. In that case you might want to update the deployment. This is for the case when 3rd party (accidentally or intentionally) changed the deployment. Also it's a good practice to add an Informer for the deployment, currently if the deployment is created, the reconciliation won't be triggered if the deployment changes.Hope it helps :)",
5443269,csviri,https://api.github.com/repos/keycloak/keycloak/pulls/9381,781007910,2022-01-10T09:18:40Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -0,0 +1,76 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import javax.inject.Inject;++import io.fabric8.kubernetes.client.KubernetesClient;+import io.javaoperatorsdk.operator.api.reconciler.*;+import io.javaoperatorsdk.operator.api.reconciler.Constants;+import org.jboss.logging.Logger;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;++@ControllerConfiguration(namespaces = Constants.WATCH_CURRENT_NAMESPACE, finalizerName = Constants.NO_FINALIZER)+public class KeycloakController implements Reconciler<Keycloak> {++    @Inject+    Logger logger;++    @Inject+    KubernetesClient client;++    @Override+    public UpdateControl<Keycloak> reconcile(Keycloak kc, Context context) {+        logger.trace(""Reconcile loop started"");+        final var spec = kc.getSpec();++        logger.info(""Reconciling Keycloak: "" + kc.getMetadata().getName() + "" in namespace: "" + kc.getMetadata().getNamespace());++        KeycloakStatus status = kc.getStatus();+        var deployment = new KeycloakDeployment(client);++        try {+            var kcDeployment = deployment.getKeycloakDeployment(kc);++            if (kcDeployment == null) {+                // Need to create the deployment+                deployment.createKeycloakDeployment(kc);+            }++            var nextStatus = deployment.getNextStatus(spec, status, kcDeployment);++            if (!nextStatus.equals(status)) {+                logger.trace(""Updating the status"");+                kc.setStatus(nextStatus);+                return UpdateControl.updateStatus(kc);+            } else {+                logger.trace(""Nothing to do"");+                return UpdateControl.noUpdate();+            }+        } catch (Exception e) {","There is a feature to support this nicely, along with retries, see: https://github.com/java-operator-sdk/java-operator-sdk/blob/main/operator-framework-core/src/main/java/io/javaoperatorsdk/operator/api/reconciler/ErrorStatusHandler.javaSee also in docs:https://javaoperatorsdk.io/docs/features",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9221,781058932,2022-01-10T10:28:06Z,model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java,"@@ -795,38 +837,59 @@ public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserMo      @Override     public boolean moveCredentialTo(RealmModel realm, UserModel user, String id, String newPreviousCredentialId) {-        LOG.tracef(""moveCredentialTo(%s, %s, %s, %s)%s"", realm, user.getId(), id, newPreviousCredentialId, getShortStackTrace());-        String userId = user.getId();-        MapUserEntity userEntity = getEntityById(realm, userId).orElse(null);-        if (userEntity == null) {-            LOG.warnf(""User with id: [%s] not found"", userId);-            return false;-        } -        // Find index of credential which should be before id in the list-        int newPreviousCredentialIdIndex = -1; // If newPreviousCredentialId == null we need to put id credential to index 0-        if (newPreviousCredentialId != null) {-            newPreviousCredentialIdIndex = userEntity.getCredentialIndex(newPreviousCredentialId);-            if (newPreviousCredentialIdIndex == -1) { // If not null previous credential not found, print warning and return false-                LOG.warnf(""Credential with id: [%s] for user: [%s] not found"", newPreviousCredentialId, userId);-                return false;+        MapUserEntity userEntity = getEntityByIdOrThrow(realm, user.getId());++        // 1 - Create new list and move everything to it.+        Set<MapUserCredentialEntity> credentialEntityMap = userEntity.getCredentials();+        List<MapUserCredentialEntity> newList = credentialEntityMap == null ? new LinkedList<>()+                : credentialEntityMap.stream()+                        .sorted(MapUserCredentialEntity.ORDER_BY_PRIORITY)+                        .collect(Collectors.toList());++        // 2 - Find indexes of our and newPrevious credential+        int ourCredentialIndex = -1;+        int newPreviousCredentialIndex = -1;+        MapUserCredentialEntity ourCredential = null;+        int i = 0;+        for (MapUserCredentialEntity credential : newList) {+            if (id.equals(credential.getId())) {+                ourCredentialIndex = i;+                ourCredential = credential;+            } else if(newPreviousCredentialId != null && newPreviousCredentialId.equals(credential.getId())) {+                newPreviousCredentialIndex = i;             }+            i++;         } -        // Find current index of credential (id) which will be moved-        int currentPositionOfId = userEntity.getCredentialIndex(id);-        if (currentPositionOfId == -1) {-            LOG.warnf(""Credential with id: [%s] for user: [%s] not found"", id, userId);+        if (ourCredentialIndex == -1) {+            LOG.warnf(""Not found credential with id [%s] of user [%s]"", id, user.getUsername());             return false;         } -        // If id is before newPreviousCredentialId in priority list, it will be moved to position -1-        if (currentPositionOfId < newPreviousCredentialIdIndex) {-            newPreviousCredentialIdIndex -= 1;+        if (newPreviousCredentialId != null && newPreviousCredentialIndex == -1) {+            LOG.warnf(""Can't move up credential with id [%s] of user [%s]"", id, user.getUsername());+            return false;         } -        // Move credential to desired index-        userEntity.moveCredential(currentPositionOfId, newPreviousCredentialIdIndex + 1);+        // 3 - Compute index where we move our credential+        int toMoveIndex = newPreviousCredentialId==null ? 0 : newPreviousCredentialIndex + 1;++        // 4 - Insert our credential to new position, remove it from the old position+        newList.add(toMoveIndex, ourCredential);+        int indexToRemove = toMoveIndex < ourCredentialIndex ? ourCredentialIndex + 1 : ourCredentialIndex;+        newList.remove(indexToRemove);++        // 5 - newList contains credentials in requested order now. Iterate through whole list and change priorities accordingly.+        int expectedPriority = 0;+        for (MapUserCredentialEntity credential : newList) {+            expectedPriority += PRIORITY_DIFFERENCE;+            if (credential.getPriority() != expectedPriority) {+                credential.setPriority(expectedPriority);++                LOG.tracef(""Priority of credential [%s] of user [%s] changed to [%d]"", credential.getId(), user.getUsername(), expectedPriority);+            }+        }","Nice refactor.I believe this method belongs mostly, if not completely, to the entity where its logic can be optimized for a particular storage.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/9432,781112662,2022-01-10T11:30:35Z,docs/guides/src/main/server/config-mainaspects.adoc,"@@ -0,0 +1,128 @@+<#import ""/templates/guide.adoc"" as template>+<#import ""/templates/kc.adoc"" as kc>++<@template.guide+title=""Core concepts for configuring Keycloak""+summary=""Understand main aspects around Keycloaks configuration"">++With the underlying Quarkus distribution, configuring Keycloak got a lot easier. There are some main aspects to understand, though. This guide will help you to understand the core concepts around the configuration of Keycloak.++== Distinction between runtime- and buildtime options+Configuration options are divided in two categories:++- Runtime Options are options that can be set at runtime when starting the server","In my proposal, I tried to avoid exposing to users additional complexity by not mentioning what a runtime/build time option is. But just say that some are only available when building.This is one of the toughest concepts to explain and bringing these ""internal"" concepts I think does not help to make it easier for users. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,781576318,2022-01-10T21:42:49Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/JpaRoleModelCriteriaBuilder.java,"@@ -0,0 +1,140 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.role;++import java.util.function.BiFunction;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.CriteriaBuilder.In;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.RoleModel;+import org.keycloak.models.RoleModel.SearchableFields;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.role.entity.JpaRoleEntity;+import org.keycloak.storage.SearchableModelField;++public class JpaRoleModelCriteriaBuilder extends JpaModelCriteriaBuilder implements ModelCriteriaBuilder<RoleModel, JpaRoleModelCriteriaBuilder> {++    private BiFunction<CriteriaBuilder, Root<JpaRoleEntity>, Predicate> predicateFunc = null;++    public JpaRoleModelCriteriaBuilder() {+    }++    private JpaRoleModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaRoleEntity>, Predicate> predicateFunc) {+        this.predicateFunc = predicateFunc;+    }++    private String getFieldName(SearchableModelField<? super RoleModel> modelField) {+        return ""f"" + modelField.getName().substring(0, 1).toUpperCase() + modelField.getName().substring(1);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public JpaRoleModelCriteriaBuilder compare(SearchableModelField<? super RoleModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(SearchableFields.REALM_ID) ||+                    modelField.equals(SearchableFields.CLIENT_ID)) {++                    validateValue(value, modelField, op, String.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) -> +                        cb.equal(+                            cb.function(""->"", JsonbType.class, root.get(""metadata""), cb.literal(getFieldName(modelField))), +                            cb.literal(convertToJson(value[0]))+                        )+                    );+                } else if (modelField.equals(SearchableFields.NAME)) {+                    validateValue(value, modelField, op, String.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) -> +                        cb.equal(root.get(modelField.getName()), value[0])+                    );+                } else if (modelField.equals(SearchableFields.IS_CLIENT_ROLE)) {+                    validateValue(value, modelField, op, Boolean.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) -> +                        cb.equal(+                            cb.function(""->"", JsonbType.class, root.get(""metadata""), cb.literal(""fClientRole"")), +                            cb.literal(convertToJson(value[0]))+                        )+                    );+                } else {+                    throw new CriterionNotSupportedException(modelField, op);+                }+            case IN:+                if (modelField.equals(SearchableFields.ID)) {+                    validateValue(value, modelField, op, String.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) -> {+                        In<String> in = cb.in(root.get(""id""));+                        ((Stream<String>) value[0]).forEach(id -> in.value(id));+                        return in;+                    });+                } else {+                    throw new CriterionNotSupportedException(modelField, op);+                }+            case ILIKE:+                if (modelField.equals(SearchableFields.NAME) ||+                    modelField.equals(SearchableFields.DESCRIPTION)) {++                    validateValue(value, modelField, op, String.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) ->+                        cb.like(+                            cb.lower(cb.function(""->"", String.class, root.get(""metadata""), cb.literal(getFieldName(modelField)))),+                            cb.literal(convertToJson(value[0]).toLowerCase())+                        )+                    );+                } else {+                    throw new CriterionNotSupportedException(modelField, op);+                }+            default:+                throw new CriterionNotSupportedException(modelField, op);+        }+    }++    @Override+    public JpaRoleModelCriteriaBuilder and(JpaRoleModelCriteriaBuilder... builders) {+        return new JpaRoleModelCriteriaBuilder(+            (cb, root) -> cb.and(Stream.of(builders).map(b -> b.getPredicateFunc().apply(cb, root)).toArray(Predicate[]::new))+        );+    }++    @Override+    public JpaRoleModelCriteriaBuilder or(JpaRoleModelCriteriaBuilder... builders) {+        return new JpaRoleModelCriteriaBuilder(+            (cb, root) -> cb.or(Stream.of(builders).map(b -> b.getPredicateFunc().apply(cb, root)).toArray(Predicate[]::new))+        );+    }++    @Override+    public JpaRoleModelCriteriaBuilder not(JpaRoleModelCriteriaBuilder builder) {+        return new JpaRoleModelCriteriaBuilder(+            (cb, root) -> cb.not(builder.getPredicateFunc().apply(cb, root))+        );+    }","Could these methods be defined in `JpaModelCriteriaBuilder`?Perhaps if the class was updated like this:```javapublic class JpaModelCriteriaBuilder<Self> {    private static final Function<BiFunction<CriteriaBuilder, Root<JpaRoleEntity>, Predicate>, Self> instantiator;   // ... e.g.    @Override    public Self not(Self builder) {        return instantiator.apply(            (cb, root) -> cb.not(builder.getPredicateFunc().apply(cb, root))        );    }```and this `instantiator` could be initialized in the constructor, called from the descendants like this:```    JpaRoleModelCriteriaBuilder() {        super(JpaRoleModelCriteriaBuilder::new);    }```",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,781818671,2022-01-11T07:34:14Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/entity/JpaRoleEntity.java,"@@ -0,0 +1,273 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.role.entity;++import java.io.Serializable;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.role.MapRoleEntity.AbstractRoleEntity;+import static org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_ROLE;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""role"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaRoleEntity extends AbstractRoleEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaRoleMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String name;++    @OneToMany(mappedBy = ""role"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaRoleAttributeEntity> attributes = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaRoleEntity() {+        this.metadata = new JpaRoleMetadata();+    }++    public JpaRoleEntity(DeepCloner cloner) {+        this.metadata = new JpaRoleMetadata(cloner);+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select role without metadata(json) field.+     */+    public JpaRoleEntity(UUID id, Integer entityVersion, String name) {+        this.id = id;+        this.entityVersion = entityVersion;+        this.name = name;+        this.metadata = null;+    }++    public boolean isMetadataInitialized() {+        return metadata != null;+    }++    /**+     * In case of any update on entity, we want to update the entityVerion+     * to current one.+     */+    private void checkEntityVersionForUpdate() {+        Integer ev = getEntityVersion();+        if (ev != null && ev < SUPPORTED_VERSION_ROLE) {+            setEntityVersion(SUPPORTED_VERSION_ROLE);+        }+    }++    public Integer getEntityVersion() {+        if (isMetadataInitialized()) return metadata.getEntityVersion();+        return entityVersion;+    }++    public void setEntityVersion(Integer entityVersion) {+        metadata.setEntityVersion(entityVersion);+    }++    @Override+    public String getId() {+        return id == null ? null : id.toString();+    }++    @Override+    public void setId(String id) {+        this.id = id == null ? null : UUID.fromString(id);+    }++    @Override+    public Boolean isClientRole() {+        return metadata.isClientRole();+    }++    @Override+    public String getRealmId() {+        return metadata.getRealmId();+    }++    @Override+    public String getClientId() {+        return metadata.getClientId();+    }++    @Override+    public String getName() {+        if (isMetadataInitialized()) return metadata.getName();+        return name;+    }++    @Override+    public String getDescription() {+        return metadata.getDescription();+    }++    @Override+    public void setClientRole(Boolean clientRole) {+        checkEntityVersionForUpdate();+        metadata.setClientRole(clientRole);+    }++    @Override+    public void setRealmId(String realmId) {+        checkEntityVersionForUpdate();+        metadata.setRealmId(realmId);+    }++    @Override+    public void setClientId(String clientId) {+        checkEntityVersionForUpdate();+        metadata.setClientId(clientId);+    }++    @Override+    public void setName(String name) {+        checkEntityVersionForUpdate();+        metadata.setName(name);+    }++    @Override+    public void setDescription(String description) {+        checkEntityVersionForUpdate();+        metadata.setDescription(description);+    }++    @Override+    public Set<String> getCompositeRoles() {+        return metadata.getCompositeRoles();+    }++    @Override+    public void setCompositeRoles(Set<String> compositeRoles) {+        checkEntityVersionForUpdate();+        metadata.setCompositeRoles(compositeRoles);+    }++    @Override+    public void addCompositeRole(String roleId) {+        checkEntityVersionForUpdate();+        metadata.addCompositeRole(roleId);+    }++    @Override+    public void removeCompositeRole(String roleId) {+        checkEntityVersionForUpdate();+        metadata.removeCompositeRole(roleId);+    }++    @Override+    public Map<String, List<String>> getAttributes() {+        Map<String, List<String>> result = new HashMap<>();+        for (JpaRoleAttributeEntity attribute : attributes) {+            List<String> values = result.getOrDefault(attribute.getName(), new LinkedList<>());+            values.add(attribute.getValue());+            result.put(attribute.getName(), values);+        }+        return result;+    }++    @Override+    public List<String> getAttribute(String name) {+        return attributes.stream()+                .filter(a -> Objects.equals(a.getName(), name))+                .map(JpaRoleAttributeEntity::getValue)+                .collect(Collectors.toList());+    }++    @Override+    public void setAttributes(Map<String, List<String>> attributes) {+        checkEntityVersionForUpdate();+        for (Iterator<JpaRoleAttributeEntity> iterator = this.attributes.iterator(); iterator.hasNext();) {+            JpaRoleAttributeEntity attr = iterator.next();+            iterator.remove();+            attr.setRole(null);+        }+        if (attributes != null) {+            for (Map.Entry<String, List<String>> entry : attributes.entrySet()) {+                setAttribute(entry.getKey(), entry.getValue());+            }+        }+    }++    @Override+    public void setAttribute(String name, List<String> values) {+        checkEntityVersionForUpdate();+        removeAttribute(name);+        for (String value : values) {+            JpaRoleAttributeEntity attribute = new JpaRoleAttributeEntity(this, name, value);+            attributes.add(attribute);+        }+    }++    @Override+    public void removeAttribute(String name) {+        checkEntityVersionForUpdate();+        for (Iterator<JpaRoleAttributeEntity> iterator = attributes.iterator(); iterator.hasNext();) {+            JpaRoleAttributeEntity attr = iterator.next();+            if (Objects.equals(attr.getName(), name)) {+                iterator.remove();+                attr.setRole(null);+            }+        }+    }","Attributes are stored as [association](https://github.com/vramik/keycloak/blob/KEYCLOAK-18565-roles/model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/entity/JpaRoleEntity.java#L67-L68), therefore the field is omitted from json when [serialization](https://github.com/keycloak/keycloak/blob/main/model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/hibernate/jsonb/JsonbType.java#L78) is done (the same applies to id field). ",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,781823843,2022-01-11T07:41:07Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/entity/JpaRoleEntity.java,"@@ -0,0 +1,273 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.role.entity;++import java.io.Serializable;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.role.MapRoleEntity.AbstractRoleEntity;+import static org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_ROLE;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""role"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaRoleEntity extends AbstractRoleEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaRoleMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String name;++    @OneToMany(mappedBy = ""role"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaRoleAttributeEntity> attributes = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaRoleEntity() {+        this.metadata = new JpaRoleMetadata();+    }++    public JpaRoleEntity(DeepCloner cloner) {+        this.metadata = new JpaRoleMetadata(cloner);+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select role without metadata(json) field.+     */+    public JpaRoleEntity(UUID id, Integer entityVersion, String name) {+        this.id = id;+        this.entityVersion = entityVersion;+        this.name = name;+        this.metadata = null;+    }++    public boolean isMetadataInitialized() {+        return metadata != null;+    }++    /**+     * In case of any update on entity, we want to update the entityVerion+     * to current one.+     */+    private void checkEntityVersionForUpdate() {+        Integer ev = getEntityVersion();+        if (ev != null && ev < SUPPORTED_VERSION_ROLE) {+            setEntityVersion(SUPPORTED_VERSION_ROLE);+        }+    }++    public Integer getEntityVersion() {+        if (isMetadataInitialized()) return metadata.getEntityVersion();+        return entityVersion;+    }++    public void setEntityVersion(Integer entityVersion) {+        metadata.setEntityVersion(entityVersion);+    }++    @Override+    public String getId() {+        return id == null ? null : id.toString();+    }++    @Override+    public void setId(String id) {+        this.id = id == null ? null : UUID.fromString(id);+    }++    @Override+    public Boolean isClientRole() {+        return metadata.isClientRole();+    }++    @Override+    public String getRealmId() {+        return metadata.getRealmId();+    }++    @Override+    public String getClientId() {+        return metadata.getClientId();+    }++    @Override+    public String getName() {+        if (isMetadataInitialized()) return metadata.getName();+        return name;+    }++    @Override+    public String getDescription() {+        return metadata.getDescription();+    }++    @Override+    public void setClientRole(Boolean clientRole) {+        checkEntityVersionForUpdate();+        metadata.setClientRole(clientRole);+    }++    @Override+    public void setRealmId(String realmId) {+        checkEntityVersionForUpdate();+        metadata.setRealmId(realmId);+    }++    @Override+    public void setClientId(String clientId) {+        checkEntityVersionForUpdate();+        metadata.setClientId(clientId);+    }++    @Override+    public void setName(String name) {+        checkEntityVersionForUpdate();+        metadata.setName(name);","This field is marked as ""non-insertable"" and ""non-updatable"": https://github.com/vramik/keycloak/blob/KEYCLOAK-18565-roles/model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/entity/JpaRoleEntity.java#L63It is generated from json and it's happening on database level, so when update happens it's updated only in metadata object and then database generates value of this field automatically. It's used when we want to load just subset of fields using `read(QueryParameters<RoleModel> queryParameters)`: https://github.com/vramik/keycloak/blob/KEYCLOAK-18565-roles/model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/JpaRoleMapKeycloakTransaction.java#L77-L81",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,781835283,2022-01-11T07:52:32Z,model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java,"@@ -70,6 +70,7 @@ public RoleModel addRealmRole(RealmModel realm, String id, String name) {         entity.setId(id);         entity.setRealmId(realm.getId());         entity.setName(name);+        entity.setClientRole(false);         if (tx.read(entity.getId()) != null) {             throw new ModelDuplicateException(""Role exists: "" + id);         }",The id is `String` in terms of `MapRoleProvider`: https://github.com/vramik/keycloak/blob/KEYCLOAK-18565-roles/model/map/src/main/java/org/keycloak/models/map/common/AbstractEntity.java#L25+1 for updating wording for exceptions.,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9415,781863936,2022-01-11T08:19:00Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/entity/JpaRoleEntity.java,"@@ -0,0 +1,273 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.role.entity;++import java.io.Serializable;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.role.MapRoleEntity.AbstractRoleEntity;+import static org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_ROLE;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++@Entity+@Table(name = ""role"")+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaRoleEntity extends AbstractRoleEntity implements Serializable {++    @Id+    @Column+    private UUID id;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaRoleMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String name;++    @OneToMany(mappedBy = ""role"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaRoleAttributeEntity> attributes = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaRoleEntity() {+        this.metadata = new JpaRoleMetadata();+    }++    public JpaRoleEntity(DeepCloner cloner) {+        this.metadata = new JpaRoleMetadata(cloner);+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select role without metadata(json) field.+     */+    public JpaRoleEntity(UUID id, Integer entityVersion, String name) {+        this.id = id;+        this.entityVersion = entityVersion;+        this.name = name;+        this.metadata = null;+    }++    public boolean isMetadataInitialized() {+        return metadata != null;+    }++    /**+     * In case of any update on entity, we want to update the entityVerion+     * to current one.+     */+    private void checkEntityVersionForUpdate() {+        Integer ev = getEntityVersion();+        if (ev != null && ev < SUPPORTED_VERSION_ROLE) {+            setEntityVersion(SUPPORTED_VERSION_ROLE);+        }+    }++    public Integer getEntityVersion() {+        if (isMetadataInitialized()) return metadata.getEntityVersion();+        return entityVersion;+    }++    public void setEntityVersion(Integer entityVersion) {+        metadata.setEntityVersion(entityVersion);+    }++    @Override+    public String getId() {+        return id == null ? null : id.toString();+    }++    @Override+    public void setId(String id) {+        this.id = id == null ? null : UUID.fromString(id);+    }++    @Override+    public Boolean isClientRole() {+        return metadata.isClientRole();+    }++    @Override+    public String getRealmId() {+        return metadata.getRealmId();+    }++    @Override+    public String getClientId() {+        return metadata.getClientId();+    }++    @Override+    public String getName() {+        if (isMetadataInitialized()) return metadata.getName();+        return name;+    }++    @Override+    public String getDescription() {+        return metadata.getDescription();+    }++    @Override+    public void setClientRole(Boolean clientRole) {+        checkEntityVersionForUpdate();+        metadata.setClientRole(clientRole);+    }++    @Override+    public void setRealmId(String realmId) {+        checkEntityVersionForUpdate();+        metadata.setRealmId(realmId);+    }++    @Override+    public void setClientId(String clientId) {+        checkEntityVersionForUpdate();+        metadata.setClientId(clientId);+    }++    @Override+    public void setName(String name) {+        checkEntityVersionForUpdate();+        metadata.setName(name);+    }++    @Override+    public void setDescription(String description) {+        checkEntityVersionForUpdate();+        metadata.setDescription(description);+    }++    @Override+    public Set<String> getCompositeRoles() {+        return metadata.getCompositeRoles();+    }++    @Override+    public void setCompositeRoles(Set<String> compositeRoles) {+        checkEntityVersionForUpdate();+        metadata.setCompositeRoles(compositeRoles);+    }++    @Override+    public void addCompositeRole(String roleId) {+        checkEntityVersionForUpdate();+        metadata.addCompositeRole(roleId);+    }++    @Override+    public void removeCompositeRole(String roleId) {+        checkEntityVersionForUpdate();+        metadata.removeCompositeRole(roleId);+    }++    @Override+    public Map<String, List<String>> getAttributes() {+        Map<String, List<String>> result = new HashMap<>();+        for (JpaRoleAttributeEntity attribute : attributes) {+            List<String> values = result.getOrDefault(attribute.getName(), new LinkedList<>());+            values.add(attribute.getValue());+            result.put(attribute.getName(), values);+        }+        return result;+    }++    @Override+    public List<String> getAttribute(String name) {+        return attributes.stream()+                .filter(a -> Objects.equals(a.getName(), name))+                .map(JpaRoleAttributeEntity::getValue)+                .collect(Collectors.toList());+    }++    @Override+    public void setAttributes(Map<String, List<String>> attributes) {+        checkEntityVersionForUpdate();+        for (Iterator<JpaRoleAttributeEntity> iterator = this.attributes.iterator(); iterator.hasNext();) {+            JpaRoleAttributeEntity attr = iterator.next();+            iterator.remove();+            attr.setRole(null);+        }+        if (attributes != null) {+            for (Map.Entry<String, List<String>> entry : attributes.entrySet()) {+                setAttribute(entry.getKey(), entry.getValue());+            }+        }+    }++    @Override+    public void setAttribute(String name, List<String> values) {+        checkEntityVersionForUpdate();+        removeAttribute(name);+        for (String value : values) {+            JpaRoleAttributeEntity attribute = new JpaRoleAttributeEntity(this, name, value);+            attributes.add(attribute);+        }+    }++    @Override+    public void removeAttribute(String name) {+        checkEntityVersionForUpdate();+        for (Iterator<JpaRoleAttributeEntity> iterator = attributes.iterator(); iterator.hasNext();) {+            JpaRoleAttributeEntity attr = iterator.next();+            if (Objects.equals(attr.getName(), name)) {+                iterator.remove();+                attr.setRole(null);+            }+        }+    }","Thanks for the explanation, I can now understand. Still it was a ""surprise"" for me, maybe that's something that would help future developers if it would be part of a general rule for this store (unless a field is being migrated to a searchable field in a future version, and will be in metadata so that the previous entity version finds it there as well when reading the data).Consider this comment to be resolved.  ",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9415,781947372,2022-01-11T09:27:58Z,model/map-jpa/src/main/resources/META-INF/roles/jpa-roles-changelog-1.xml,"@@ -0,0 +1,72 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: roles-${org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_ROLE} -->+    <changeSet author=""keycloak"" id=""roles-1"">++        <createTable tableName=""role"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""role"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""name"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fName""/>+        </ext:addGeneratedColumn>+        <createIndex tableName=""role"" indexName=""role_entityVersion"">+            <column name=""entityversion""/>+        </createIndex>+        <createIndex tableName=""role"" indexName=""role_name"">+            <column name=""name""/>+        </createIndex>","To elaborate on the isolation level: The Map storage doesn't know about the isolation level, still the results will vary depending on the isolation configured for the storage. The following assumes that all actions are performed within a single transaction.The code in `addRealmRole` calls `getRealmRole`, and then throws an exception if the role already exists. It then later adds the role to the store (in this case the JPA store). Here the varying results based on the JPA store's configuration (by reading the code, not by testing, let's hope I get it right here):Isolation level SERAILIZABLE: The database will ensure that the search result for the realm role is stable (guaranteed not to change) within the transaction. Therefore no-one can insert another role to the database with the same name and realm (the items used in the query). Therefore the `addRealmRole` can take as long as it wants to add the new role to the database and commit the change, no-one can interfere. Anyone who tries to interfere will either be blocked or will receive an exception when trying to commit.Any other isolation level (both REPEATABLE_READ and READ_COMMITTED): After the check that the client role is not in the database at that moment, any other parallel thread can add the role with the same name to the database and commit the change. The data would then be inconsistent. REPEATABLE_READ will only ensure that rows read from the database are unchanged (no rows have been read when looking for the existing role), and READ_COMMITTED will will only ensure that any rows read previously have been committed by their previous transactions and won't be rolled back. One way to prevent this inconsistency in REPEATABLE_READ or READ_COMMITTED would be a database constraint or unique index. Contrary to my previous comment, the index or constraint would need to be on realm and role, not on role alone. On the other hand: By having this `getRealmRole` in `addRealmRole`, the map storage provider is making an implicit assumption on the storage provider that no-one else will add a role between the check and the insert. Such implicit assumptions make it hard for a provider to do the right thing here. @hmlnarik ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,782358033,2022-01-11T17:07:22Z,services/src/main/java/org/keycloak/authentication/authenticators/browser/RecoveryAuthnCodesFormAuthenticator.java,"@@ -0,0 +1,153 @@+package org.keycloak.authentication.authenticators.browser;++import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.authentication.Authenticator;+import org.keycloak.authentication.authenticators.util.AuthenticatorUtils;+import org.keycloak.common.util.ObjectUtil;+import org.keycloak.credential.CredentialModel;+import org.keycloak.events.Details;+import org.keycloak.events.Errors;+import org.keycloak.forms.login.LoginFormsProvider;+import org.keycloak.models.*;+import org.keycloak.models.credential.RecoveryAuthnCodesCredentialModel;+import org.keycloak.models.utils.RecoveryAuthnCodesUtils;+import org.keycloak.models.utils.FormMessage;+import org.keycloak.services.messages.Messages;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.Optional;++import static org.keycloak.services.validation.Validation.FIELD_USERNAME;++public class RecoveryAuthnCodesFormAuthenticator implements Authenticator {++    private final UserCredentialManager userCredentialManager;++    public RecoveryAuthnCodesFormAuthenticator(KeycloakSession keycloakSession) {+        this.userCredentialManager = keycloakSession.userCredentialManager();+    }++    @Override+    public void authenticate(AuthenticationFlowContext context) {+        context.challenge(createLoginForm(context, false, null, null));+    }++    @Override+    public void action(AuthenticationFlowContext context) {+        context.getEvent().detail(Details.CREDENTIAL_TYPE, RecoveryAuthnCodesCredentialModel.TYPE);+        if (isRecoveryAuthnCodeInputValid(context)) {+            context.success();+        }+    }++    private boolean isRecoveryAuthnCodeInputValid(AuthenticationFlowContext authnFlowContext) {+        boolean result = false;+        MultivaluedMap<String, String> formParamsMap;+        String recoveryAuthnCodeUserInput;+        RealmModel targetRealm;+        UserModel authenticatedUser;+        Response responseChallenge;+        boolean isValid;+        Optional<CredentialModel> optUserCredentialFound;+        RecoveryAuthnCodesCredentialModel recoveryCodeCredentialModel = null;++        formParamsMap = authnFlowContext.getHttpRequest().getDecodedFormParameters();+        recoveryAuthnCodeUserInput = formParamsMap.getFirst(RecoveryAuthnCodesUtils.FIELD_RECOVERY_CODE_IN_BROWSER_FLOW);++        if (ObjectUtil.isBlank(recoveryAuthnCodeUserInput)) {+            authnFlowContext.forceChallenge(createLoginForm(authnFlowContext, true,+                    RecoveryAuthnCodesUtils.RECOVERY_AUTHN_CODES_INPUT_DEFAULT_ERROR_MESSAGE,+                    RecoveryAuthnCodesUtils.FIELD_RECOVERY_CODE_IN_BROWSER_FLOW));+        } else {+            targetRealm = authnFlowContext.getRealm();+            authenticatedUser = authnFlowContext.getUser();+            if (!isDisabledByBruteForce(authnFlowContext, authenticatedUser)) {+                isValid = this.userCredentialManager.isValid(targetRealm, authenticatedUser,+                        UserCredentialModel.buildFromBackupAuthnCode(recoveryAuthnCodeUserInput.replace(""-"", """")));+                if (!isValid) {+                    responseChallenge = createLoginForm(authnFlowContext, true,+                            RecoveryAuthnCodesUtils.RECOVERY_AUTHN_CODES_INPUT_DEFAULT_ERROR_MESSAGE,+                            RecoveryAuthnCodesUtils.FIELD_RECOVERY_CODE_IN_BROWSER_FLOW);+                    authnFlowContext.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, responseChallenge);+                } else {+                    result = true;+                    optUserCredentialFound = this.userCredentialManager.getStoredCredentialsByTypeStream(targetRealm,+                            authenticatedUser, RecoveryAuthnCodesCredentialModel.TYPE).findFirst();+                    if (optUserCredentialFound.isPresent()) {+                        recoveryCodeCredentialModel = RecoveryAuthnCodesCredentialModel+                                .createFromCredentialModel(optUserCredentialFound.get());+                        if (recoveryCodeCredentialModel.allCodesUsed()) {+                            this.userCredentialManager.removeStoredCredential(targetRealm, authenticatedUser,+                                    recoveryCodeCredentialModel.getId());+                        }+                    }+                    if (recoveryCodeCredentialModel == null || recoveryCodeCredentialModel.allCodesUsed()) {+                        authenticatedUser.addRequiredAction(UserModel.RequiredAction.CONFIGURE_RECOVERY_AUTHN_CODES);+                    }+                }+            }+        }+        return result;+    }++    protected boolean isDisabledByBruteForce(AuthenticationFlowContext authnFlowContext, UserModel authenticatedUser) {+        boolean bolResult = false;+        String bruteForceError;+        Response challengeResponse;+        bruteForceError = AuthenticatorUtils.getDisabledByBruteForceEventError(authnFlowContext.getProtector(),+                authnFlowContext.getSession(), authnFlowContext.getRealm(), authenticatedUser);+        if (bruteForceError != null) {+            authnFlowContext.getEvent().user(authenticatedUser);+            authnFlowContext.getEvent().error(bruteForceError);+            challengeResponse = createLoginForm(authnFlowContext, false, Messages.INVALID_USER, FIELD_USERNAME);+            authnFlowContext.forceChallenge(challengeResponse);+            bolResult = true;+        }+        return bolResult;+    }++    private Response createLoginForm(AuthenticationFlowContext authnFlowContext, boolean withInvalidUserCredentialsError,+            String errorToRaise, String fieldError) {+        Response challengeResponse;+        LoginFormsProvider loginFormsProvider;+        if (withInvalidUserCredentialsError) {+            loginFormsProvider = authnFlowContext.form();+            authnFlowContext.getEvent().user(authnFlowContext.getUser());+            authnFlowContext.getEvent().error(Errors.INVALID_USER_CREDENTIALS);+            loginFormsProvider.addError(new FormMessage(fieldError, errorToRaise));+        } else {+            loginFormsProvider = authnFlowContext.form().setExecution(authnFlowContext.getExecution().getId());+            if (errorToRaise != null) {+                if (fieldError != null) {+                    loginFormsProvider.addError(new FormMessage(fieldError, errorToRaise));+                } else {+                    loginFormsProvider.setError(errorToRaise);+                }+            }+        }+        challengeResponse = loginFormsProvider.createLoginRecoveryAuthnCode();+        return challengeResponse;+    }++    @Override+    public boolean requiresUser() {+        return true;+    }++    @Override+    public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {+        return session.userCredentialManager().isConfiguredFor(realm, user, RecoveryAuthnCodesCredentialModel.TYPE);+    }++    @Override+    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {+        user.addRequiredAction(UserModel.RequiredAction.CONFIGURE_RECOVERY_AUTHN_CODES.name());",I think it will be better if required action is added to the authentication session rather than to the user. See `OTPFormAuthenticator` or `WebAuthnAuthenticator` classes for the inspiration. Or is there any reason why for backup codes it needs to be done differently than for OTP/WebAuthn?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,782359668,2022-01-11T17:09:21Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/AuthenticationMethodSetupPage.java,"@@ -0,0 +1,54 @@+package org.keycloak.testsuite.pages;++import org.openqa.selenium.By;+import org.openqa.selenium.NoSuchElementException;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++/**+ * Setup page for various authentication methods(Password/OTP/RecoveryAuthnCodes etc.)+ *+ * @author <a href=""mailto:vnukala@redhat.com"">Venkata Nukala</a>+ */+public class AuthenticationMethodSetupPage extends LanguageComboboxAwarePage {","This class is used in RecoveryAuthnCodesAuthenticatorTest, but this test does not use it for anything. So since this class is effectively not used anywhere, it can be possible removed from this PR?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,782359796,2022-01-11T17:09:30Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/LandingPage.java,"@@ -0,0 +1,50 @@+package org.keycloak.testsuite.pages;++import org.openqa.selenium.By;+import org.openqa.selenium.NoSuchElementException;+import org.openqa.selenium.WebElement;+import org.openqa.selenium.support.FindBy;++/**+ * Backup Code Authentication test+ *+ * @author <a href=""mailto:vnukala@redhat.com"">Venkata Nukala</a>+ */+public class LandingPage extends LanguageComboboxAwarePage {","This class is used in RecoveryAuthnCodesAuthenticatorTest, but this test does not use it for anything. So since this class is effectively not used anywhere, it can be possible removed from this PR?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9478,782410301,2022-01-11T18:11:58Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,190 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/link.adoc"" as link>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Configuration Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at the <@link.guide title=""All configuration""/> section.++These options can be set using different formats:++.Command-line argument+<@kc.all parameters=""--<category>-<sub-category>-<property>=<value>""/>++.Environment variable+```+export KC_CATEGORY_SUB_CATEGORY_PROPERTY=<value>+```++.Properties at `conf/keycloak.properties`+```+<category>.<sub-category>.<property>=<value>+```++The format you should use is use-case specific but most of the time it should be enough to use the CLI. As an example, when running+the server as a container you should be fine using both environment variables or command-line options.++[NOTE]+If you are unsure about the format of a specific property, consider looking at the <@link.guide title=""All configuration""/> section.++If a same configuration option is defined in different configuration sources, the effective value should be resolved respecting the following order:++. Command-line arguments+. Environment variables+. Properties++== Configuring the server for optimal runtime++Some configuration options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++By looking at the individual configuration options at this <@link.guide title=""All configuration"" text=""section""/>, you will notice+that some options require a `build`. In other words, they can only be set when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++[NOTE]+By default, the `help` message for the `build` command only shows the options that require a build. You can also use the `help-all` option to list all the available options, including those+that do not require a build.++The `build` command is responsible for producing an immutable and optimized server image (similar concept to building a container image). In addition to persisting+any configuration option you have set, this command will also perform a series of optimizations to deliver the best runtime when starting and running the server. Basically,+a lot of processing that would usually happen when starting/running the server is no longer necessary and the server can start and run faster.","""is no longer necessary at startup"" would be a better explanation imo. It is still necessary, just happens beforehand at the build step.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9478,782416740,2022-01-11T18:21:05Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,190 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/link.adoc"" as link>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Configuration Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at the <@link.guide title=""All configuration""/> section.++These options can be set using different formats:++.Command-line argument+<@kc.all parameters=""--<category>-<sub-category>-<property>=<value>""/>++.Environment variable+```+export KC_CATEGORY_SUB_CATEGORY_PROPERTY=<value>+```++.Properties at `conf/keycloak.properties`+```+<category>.<sub-category>.<property>=<value>+```++The format you should use is use-case specific but most of the time it should be enough to use the CLI. As an example, when running+the server as a container you should be fine using both environment variables or command-line options.++[NOTE]+If you are unsure about the format of a specific property, consider looking at the <@link.guide title=""All configuration""/> section.++If a same configuration option is defined in different configuration sources, the effective value should be resolved respecting the following order:++. Command-line arguments+. Environment variables+. Properties++== Configuring the server for optimal runtime++Some configuration options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++By looking at the individual configuration options at this <@link.guide title=""All configuration"" text=""section""/>, you will notice+that some options require a `build`. In other words, they can only be set when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++[NOTE]+By default, the `help` message for the `build` command only shows the options that require a build. You can also use the `help-all` option to list all the available options, including those+that do not require a build.++The `build` command is responsible for producing an immutable and optimized server image (similar concept to building a container image). In addition to persisting+any configuration option you have set, this command will also perform a series of optimizations to deliver the best runtime when starting and running the server. Basically,+a lot of processing that would usually happen when starting/running the server is no longer necessary and the server can start and run faster.++Some optimizations performed by the `build` command are:++* Closed-world assumption about installed providers, hence no need to re-create the registry everytime the server starts+* Configuration files (e.g.: clustering) are pre-parsed to reduce IO when starting the server+* Database specific resources are configured and prepared to run against a specific database vendor+* By persisting configuration options into the server image, the server does not perform any additional step to interpret configuration options and (re)configure itself++There are many more optimizations, most of them performed by <@link.external url=""https://quarkus.io"" text=""Quarkus""/> itself. Just keep in mind that this additional step is a key aspect to achieve the optimal runtime,+ideally when running Keycloak as a container.++Once you run the `build` command, you won't need to set the same configuration options again (they are now persisted) so that you can just `start` the server:++.Building an optimized server image+<@kc.build parameters=""--db=postgres --db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++.Starting the server+<@kc.start/>++As a rule of thumb, prefer building a server image to achieve the optimal runtime as well as running the `start` command without any parameter for faster startup time.++=== Overriding settings++Once you have built a server image using the `build` command, you should be able to override any property that is available from the `start` command.++For instance, if you have built an image as follows:++<@kc.build parameters=""--db=postgres --db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++You should be able to override the `db-username`, `hostname`, or any other property available to the `start` command:++<@kc.start parameters=""--db-username foo --hostname newkeycloak.acme.com""/>++As a result, the server should start using all the configuration options previously set using the `build` command but overriding those that you explicitly+set when starting the server.++This configuration approach can be useful when building an opinionated server image with the possibility to override specific options that are allowed to+change when starting the server (those available to the `start` command).++== Using placeholders++You should be able to use placeholders to dynamically change the value of configuration options when starting the server.++For that, you should use the following format when defining the value of an option:++```+db.username=${r""${my.db.user}""}","When I use this syntax, I get ```ERROR: Build failure: Build failed due to errors	[error]: Build step org.keycloak.quarkus.deployment.KeycloakProcessor#persistBuildTimeProperties threw an exception: java.util.NoSuchElementException: SRCFG00011: Could not expand value r""mydbuser"" in property kc.db.username```Typo? Should be ${my.db.user}, shouldn't it? Also: I'd prefer the example to be with an environment variable instead of a system property. So ${MY_DB_USER}. Imo we shouldn't encourage the usage of system properties, but that's just my opinion. ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/9478,782435183,2022-01-11T18:47:57Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,190 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/link.adoc"" as link>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Configuration Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at the <@link.guide title=""All configuration""/> section.++These options can be set using different formats:++.Command-line argument+<@kc.all parameters=""--<category>-<sub-category>-<property>=<value>""/>++.Environment variable+```+export KC_CATEGORY_SUB_CATEGORY_PROPERTY=<value>+```++.Properties at `conf/keycloak.properties`+```+<category>.<sub-category>.<property>=<value>+```++The format you should use is use-case specific but most of the time it should be enough to use the CLI. As an example, when running+the server as a container you should be fine using both environment variables or command-line options.++[NOTE]+If you are unsure about the format of a specific property, consider looking at the <@link.guide title=""All configuration""/> section.++If a same configuration option is defined in different configuration sources, the effective value should be resolved respecting the following order:++. Command-line arguments+. Environment variables+. Properties++== Configuring the server for optimal runtime++Some configuration options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++By looking at the individual configuration options at this <@link.guide title=""All configuration"" text=""section""/>, you will notice+that some options require a `build`. In other words, they can only be set when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++[NOTE]+By default, the `help` message for the `build` command only shows the options that require a build. You can also use the `help-all` option to list all the available options, including those+that do not require a build.++The `build` command is responsible for producing an immutable and optimized server image (similar concept to building a container image). In addition to persisting+any configuration option you have set, this command will also perform a series of optimizations to deliver the best runtime when starting and running the server. Basically,+a lot of processing that would usually happen when starting/running the server is no longer necessary and the server can start and run faster.++Some optimizations performed by the `build` command are:++* Closed-world assumption about installed providers, hence no need to re-create the registry everytime the server starts+* Configuration files (e.g.: clustering) are pre-parsed to reduce IO when starting the server+* Database specific resources are configured and prepared to run against a specific database vendor+* By persisting configuration options into the server image, the server does not perform any additional step to interpret configuration options and (re)configure itself++There are many more optimizations, most of them performed by <@link.external url=""https://quarkus.io"" text=""Quarkus""/> itself. Just keep in mind that this additional step is a key aspect to achieve the optimal runtime,+ideally when running Keycloak as a container.++Once you run the `build` command, you won't need to set the same configuration options again (they are now persisted) so that you can just `start` the server:++.Building an optimized server image+<@kc.build parameters=""--db=postgres --db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++.Starting the server+<@kc.start/>++As a rule of thumb, prefer building a server image to achieve the optimal runtime as well as running the `start` command without any parameter for faster startup time.++=== Overriding settings++Once you have built a server image using the `build` command, you should be able to override any property that is available from the `start` command.++For instance, if you have built an image as follows:++<@kc.build parameters=""--db=postgres --db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++You should be able to override the `db-username`, `hostname`, or any other property available to the `start` command:++<@kc.start parameters=""--db-username foo --hostname newkeycloak.acme.com""/>++As a result, the server should start using all the configuration options previously set using the `build` command but overriding those that you explicitly+set when starting the server.++This configuration approach can be useful when building an opinionated server image with the possibility to override specific options that are allowed to+change when starting the server (those available to the `start` command).++== Using placeholders++You should be able to use placeholders to dynamically change the value of configuration options when starting the server.++For that, you should use the following format when defining the value of an option:++```+db.username=${r""${my.db.user}""}+```++By using a placeholder like in the example above, the server is going to try to resolve the `my.db.user` variable from:++* A system property using the same key+* An environment variable by replacing dots with `_`.++Placeholders can also be used when building a server image using the `build` command so that the value of a configuration option is updated+with the value set to the placeholder (system property or environment variable) when starting the server.++[NOTE]+You should not use placeholders for configuration options that can only be set through the `build` command. The reason is that these options+can not change once they are persisted into the server image. Prefer using placeholders only for the configurations options available to+the `start` command.++== Configuration profiles++Most of the time the server is deployed to different environments like testing, staging, and production environments. Although they share some+core configuration options (e.g: database, clustering, etc) some other options might change on a per-environment basis.+In order to make easier to support multiple configurations, the server allows you to create configuration profiles.",If I have to change `server` then I would need to change a lot of other places. The reason why I'm not using `Keycloak` is to be more neutral about community/product. We should probably have a macro to resolve the proper name similarly as how we do in the current documentation?,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9478,782458858,2022-01-11T19:22:50Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,190 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/link.adoc"" as link>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Configuration Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at the <@link.guide title=""All configuration""/> section.++These options can be set using different formats:++.Command-line argument+<@kc.all parameters=""--<category>-<sub-category>-<property>=<value>""/>++.Environment variable+```+export KC_CATEGORY_SUB_CATEGORY_PROPERTY=<value>+```++.Properties at `conf/keycloak.properties`+```+<category>.<sub-category>.<property>=<value>+```++The format you should use is use-case specific but most of the time it should be enough to use the CLI. As an example, when running+the server as a container you should be fine using both environment variables or command-line options.++[NOTE]+If you are unsure about the format of a specific property, consider looking at the <@link.guide title=""All configuration""/> section.++If a same configuration option is defined in different configuration sources, the effective value should be resolved respecting the following order:++. Command-line arguments+. Environment variables+. Properties++== Configuring the server for optimal runtime++Some configuration options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++By looking at the individual configuration options at this <@link.guide title=""All configuration"" text=""section""/>, you will notice+that some options require a `build`. In other words, they can only be set when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++[NOTE]+By default, the `help` message for the `build` command only shows the options that require a build. You can also use the `help-all` option to list all the available options, including those+that do not require a build.++The `build` command is responsible for producing an immutable and optimized server image (similar concept to building a container image). In addition to persisting+any configuration option you have set, this command will also perform a series of optimizations to deliver the best runtime when starting and running the server. Basically,+a lot of processing that would usually happen when starting/running the server is no longer necessary and the server can start and run faster.++Some optimizations performed by the `build` command are:++* Closed-world assumption about installed providers, hence no need to re-create the registry everytime the server starts+* Configuration files (e.g.: clustering) are pre-parsed to reduce IO when starting the server+* Database specific resources are configured and prepared to run against a specific database vendor+* By persisting configuration options into the server image, the server does not perform any additional step to interpret configuration options and (re)configure itself++There are many more optimizations, most of them performed by <@link.external url=""https://quarkus.io"" text=""Quarkus""/> itself. Just keep in mind that this additional step is a key aspect to achieve the optimal runtime,+ideally when running Keycloak as a container.++Once you run the `build` command, you won't need to set the same configuration options again (they are now persisted) so that you can just `start` the server:++.Building an optimized server image+<@kc.build parameters=""--db=postgres --db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++.Starting the server+<@kc.start/>++As a rule of thumb, prefer building a server image to achieve the optimal runtime as well as running the `start` command without any parameter for faster startup time.++=== Overriding settings++Once you have built a server image using the `build` command, you should be able to override any property that is available from the `start` command.++For instance, if you have built an image as follows:++<@kc.build parameters=""--db=postgres --db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++You should be able to override the `db-username`, `hostname`, or any other property available to the `start` command:++<@kc.start parameters=""--db-username foo --hostname newkeycloak.acme.com""/>++As a result, the server should start using all the configuration options previously set using the `build` command but overriding those that you explicitly+set when starting the server.++This configuration approach can be useful when building an opinionated server image with the possibility to override specific options that are allowed to+change when starting the server (those available to the `start` command).++== Using placeholders++You should be able to use placeholders to dynamically change the value of configuration options when starting the server.++For that, you should use the following format when defining the value of an option:++```+db.username=${r""${my.db.user}""}+```++By using a placeholder like in the example above, the server is going to try to resolve the `my.db.user` variable from:++* A system property using the same key+* An environment variable by replacing dots with `_`.++Placeholders can also be used when building a server image using the `build` command so that the value of a configuration option is updated+with the value set to the placeholder (system property or environment variable) when starting the server.++[NOTE]+You should not use placeholders for configuration options that can only be set through the `build` command. The reason is that these options+can not change once they are persisted into the server image. Prefer using placeholders only for the configurations options available to+the `start` command.++== Configuration profiles++Most of the time the server is deployed to different environments like testing, staging, and production environments. Although they share some+core configuration options (e.g: database, clustering, etc) some other options might change on a per-environment basis.+In order to make easier to support multiple configurations, the server allows you to create configuration profiles.++Configuration profiles are basically a set of one or more configuration options grouped together using a unique key.++You can activate a profile by using the `[-pf|--profile]` option as follows:++<@kc.all rootParameters=""-pf myprofile""/>++Once a profile is activated, all the configuration options defined for the profile should take effect when configuring or starting the server.++=== Understanding the default profiles++By default, the server defines two main profiles:++* `dev`+* `prod`++The `dev` profile is activated everytime you run the `start-dev` command. In this profile, some key configuration options are set to make possible to start the+server for development purposes without the burden of having to define additional settings that are mandatory for production.++The `prod` profile is activated by default whenever you run the `build` or the `start` command. You should use this profile to set any configuration option that+makes sense when deploying the server in production.++By default, the configurations options for the `prod` profile are commented in the `conf/keycloak.properties`. By looking at these options+you should have an idea about the main settings that you should consider when running in production.++You should be able to change the configuration options for these built-in profiles as well as create your own.++=== Defining a configuration profile++A profile can be created by adding a set of one or more properties to the `conf/keycloak.properties` file as follows:++```+%myprofile.db.username=foo+%myprofile.db.password=foo_secret+%myprofile.hostname=mykeycloak+```++Any configuration option associated with a profile should be prefixed by a `%` followed by the profile name and a dot `.` like in the example above.++== Using Quarkus configuration options++The server is built on top of <@link.external url=""https://quarkus.io"" text=""Quarkus""/> and you should be able to use any property available from Quarkus+if you do not find a corresponding options in the server configuration. The server has a configuration layer that provides a 1:N mapping between the server configuration options and those available from Quarkus.","+1 for removing completely, for now. Only generates noise imo, as is. :)Alternatively, I thought about sth like this:```== Using Quarkus configuration optionsThe server is built on top of <@link.external url=""https://quarkus.io"" text=""Quarkus""/> and you are basically able to use any property available within Quarkus, using for example `quarkus.datasource.jdbc.max-size=...`. We generally want to provide an extra convenience layer over the raw Quarkus properties using our own configuration. So we'd love to hear from you over at <@link.external url=""https://github.com/keycloak/keycloak/discussions"" text=""GitHub Discussions""/>. if you think something is missing.``` Either way fine for me ;)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8866,782800180,2022-01-12T08:14:42Z,server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java,"@@ -2905,4 +2905,21 @@ public static ResourceServer createResourceServer(ClientModel client, KeycloakSe          return toModel(representation, authorization);     }+ +    public static void validateRealmRepresentation(RealmRepresentation rep, RealmModel realm, KeycloakSession session) throws ModelException {+        int secondsPerYear = 31536000; // valid value condition the same as admin UI's partials/realm-tokens.html","I am not 100% sure if 1 year is sufficient for all the use-cases? For example is it possible that someone uses ""offline session"" timeouts longer than 1 year? Should we rather increase to something like 10 years or Integer.MAX_VALUE?What do others thing about this?I agree that it will be good to have admin console validations in sync with the REST validations on server side. So whatever we agree on, we should make both places in sync. ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,783136856,2022-01-12T14:40:44Z,services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidateRecoveryAuthnCode.java,"@@ -0,0 +1,142 @@+package org.keycloak.authentication.authenticators.directgrant;++import org.apache.commons.lang.StringUtils;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.authentication.CredentialValidator;+import org.keycloak.credential.RecoveryAuthnCodesCredentialProvider;+import org.keycloak.credential.RecoveryAuthnCodesCredentialProviderFactory;+import org.keycloak.credential.CredentialProvider;+import org.keycloak.events.Errors;+import org.keycloak.models.*;+import org.keycloak.models.credential.RecoveryAuthnCodesCredentialModel;+import org.keycloak.models.utils.RecoveryAuthnCodesUtils;+import org.keycloak.provider.ProviderConfigProperty;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.LinkedList;+import java.util.List;++public class ValidateRecoveryAuthnCode extends AbstractDirectGrantAuthenticator","I was wondering about the same yesterday...However I was thinking about the case when 2-factor is required for browser login and at the same time, you have ""Direct Grant"" enabled for some clients. Isn't it strange that browser login will require 2-factor, but direct-grant allows to login with simple username/password? Hence it makes sense to me to have authenticator for direct-grant as well (similarly like we have for OTP).",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,783173834,2022-01-12T15:18:15Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -249,7 +259,32 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta      private credentialRowCells(credential: UserCredential, type: string): React.ReactNode[] {         const credRowCells: React.ReactNode[] = [];-        credRowCells.push(<DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>{credential.userLabel}</DataListCell>);+        const credData: CredData = JSON.parse(credential.credentialData!);+        credRowCells.push(+            <DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>+                {credential.userLabel}+                {credData.remainingCodes && credData.totalCodes &&+                    <div>{credData.totalCodes - credData.remainingCodes}/{credData.totalCodes} recovery codes used</div>+                }+                {credData.remainingCodes && credData.remainingCodes < 4 &&+                    <>+                        <br />+                        <div className=""pf-c-alert pf-m-warning pf-m-inline"" aria-label=""Success alert"">+                            <div className=""pf-c-alert__icon"">+                                <i className=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+                            </div>+                            <h4 className=""pf-c-alert__title"">","It will be ideal if we can avoid the account-console code specific for ""recovery-code"" credential type.The account console is supposed to be used with custom credential type implementations provided by administrator. Having the code specific for each credential does not scale IMO. Will be good if we can handle all of this with credential metadata.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9535,783277950,2022-01-12T17:09:52Z,operator/kubernetes/jobs-role.yaml,"@@ -0,0 +1,29 @@+apiVersion: rbac.authorization.k8s.io/v1+kind: ClusterRole+metadata:+  name: realmcontroller-jobs-cluster-role+rules:+  - apiGroups:+      - batch+    resources:+      - jobs+    verbs:+      - get+      - list+      - watch+---+apiVersion: rbac.authorization.k8s.io/v1+kind: ClusterRoleBinding+metadata:+  name: realmcontroller-jobs-role-binding+roleRef:+  kind: ClusterRole+  apiGroup: rbac.authorization.k8s.io+  name: realmcontroller-jobs-cluster-role+subjects:+  - kind: ServiceAccount+    name: keycloak-operator+    # TODO: no clear way how to get this value OOB with kustomize, do we need Helm?+    # reference issue:+    # https://github.com/quarkiverse/quarkus-operator-sdk/issues/187+    namespace: default","I know we don't have a clear path ahead here but cc. @metacosmref: https://github.com/quarkiverse/quarkus-operator-sdk/issues/187@vmuzikar this is actually problematic to be done with ""just"" `kustomize`, Helm solves this problem much better e.g: https://github.com/lightbend/akka-operator-helm/blob/67a43096f3e5f0dad4abc3efee313e5e1f3a6d1e/akka-operator/templates/030-clusterrolebinding.yaml#L14",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9535,783282604,2022-01-12T17:15:39Z,operator/src/main/java/org/keycloak/operator/v2alpha1/RealmJob.java,"@@ -0,0 +1,165 @@+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.*;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.api.model.batch.v1.Job;+import io.fabric8.kubernetes.api.model.batch.v1.JobBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import org.jboss.logging.Logger;+import org.keycloak.operator.v2alpha1.crds.realm.RealmStatus;++import java.util.ArrayList;+import java.util.List;+import java.util.function.Consumer;+import java.util.function.Supplier;+import java.util.stream.Collectors;++import static org.keycloak.operator.Constants.*;+import static org.keycloak.operator.v2alpha1.NameUtils.getValidDNSSubdomainName;++public class RealmJob {++    private final static Logger logger = Logger.getLogger(RealmJob.class);++    private KubernetesClient client;++    private Consumer<Supplier<Job>> createJobFn = (jb) -> {+        var job = jb.get();+        client+                .batch()+                .v1()+                .jobs()+                .create(job);+    };+++    public RealmJob(KubernetesClient client) {+        this.client = client;+    }++    private Job buildJob(String name, String namespace, String realmCRName, Container keycloakContainer, Volume secretVolume, List<OwnerReference> ownerReferences) {+        return new JobBuilder()+                .withNewMetadata()+                .withName(name)+                .withNamespace(namespace)+                .addToLabels(PART_OF_LABEL, realmCRName)+                .addToLabels(MANAGED_BY_LABEL, MANAGED_BY_VALUE)+                .withOwnerReferences(ownerReferences)+                .endMetadata()+                .withNewSpec()+                .withNewTemplate()+                .withNewSpec()+                .withContainers(keycloakContainer)+                .addToVolumes(secretVolume)+                .withRestartPolicy(""Never"")+                .endSpec()+                .endTemplate()+                .endSpec()+                .build();+    }++    private Volume buildSecretVolume(String volumeName, String secretName) {+        return new VolumeBuilder()+                .withName(volumeName)+                .withSecret(new SecretVolumeSourceBuilder()+                        .withSecretName(secretName)+                        .build())+                .build();+    }++    private Container buildKeycloakJobContainer(PodTemplateSpec spec, String realmName, String volumeName) {+        var keycloakContainer = spec.getSpec().getContainers().get(0);++        var importMntPath = ""/mnt/realm-import/"";++        var dbOptions = keycloakContainer",this might be different as soon as we have a fix for #9171 @vmuzikar if you have anticipations I can start to integrate those,
120057,metacosm,https://api.github.com/repos/keycloak/keycloak/pulls/9535,783382220,2022-01-12T19:28:24Z,operator/src/main/java/org/keycloak/operator/v2alpha1/NameUtils.java,"@@ -0,0 +1,46 @@+package org.keycloak.operator.v2alpha1;++import java.nio.charset.StandardCharsets;+import java.util.Locale;++public class NameUtils {++    // DNS Subdomain Names+    // https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names+    // TODO: test me+    public static String getValidDNSSubdomainName(String in) {","There's one such utility in the fabric8 client, iirc. `HasMetadata` has a regexp that checks finalizers (which include a DNS subdomain name as the first part) also.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9415,783818182,2022-01-13T10:18:02Z,model/map-jpa/src/main/resources/META-INF/roles/jpa-roles-changelog-1.xml,"@@ -0,0 +1,72 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: roles-${org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_ROLE} -->+    <changeSet author=""keycloak"" id=""roles-1"">++        <createTable tableName=""role"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""role"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""name"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fName""/>+        </ext:addGeneratedColumn>+        <createIndex tableName=""role"" indexName=""role_entityVersion"">+            <column name=""entityversion""/>+        </createIndex>+        <createIndex tableName=""role"" indexName=""role_name"">+            <column name=""name""/>+        </createIndex>","I talked to Hynek yesterday about this, and the differences we will have across different providers. The current code in MapRoleProvider does a best-effort to check if the role exists.A provider implementation should see what additional checks it can implement to prevent inconsistent data. For the JPA provider this would be adding constraints and unique keys. As this would need to be added for both clients and roles, I would be fine to add constraints in a separate issue and pull request after this PR has been merged.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/9536,783878694,2022-01-13T11:39:07Z,docs/guides/src/main/server/enabletls.adoc,"@@ -0,0 +1,70 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+title=""Configure Keycloak to use TLS""+summary=""Learn how to use HTTPS/TLS with Keycloak"">++Transport Layer Security (short: TLS) is crucial to exchange data over a secured channel. For production environments, you should never expose Keycloak endpoints through HTTP, as sensitive data is at the core of what Keycloak exchanges with other applications. In this guide you will learn how to configure Keycloak to use HTTPS/TLS.++== Configure TLS in Keycloak+Keycloak can be configured to load the needed certificate infrastructure either from a certificate / key file pair in PEM format or from an existing keystore file. When both alternatives are set up, the certificate / key file configuration takes precedence over the keystore configuration.++=== Providing a certificate / key file pair+When you use a pair of matching certificate / private key files in PEM format, configure Keycloak to use them by running:++<@kc.all parameters=""--https-certificate-file=/path/to/certfile.pem --https-certificate-key-file=/path/to/keyfile.pem""/>++Keycloak creates a keystore out of these files in memory and uses this keystore afterwards.++=== Providing a keystore+As an alternative, you can use an existing keystore by running:+<@kc.all parameters=""--https-key-store-file=/path/to/existing-keystore-file""/>++When no keystore file is configured explicitly, but http.enabled is set to false, Keycloak will try to use a `server.keystore` file in the `conf` subdirectory by default.++[NOTE]+No matter which alternative you choose for setting up the TLS configuration, please make sure to set a secure password for your keystore using the `https.key-store.password` option. We recommend to not set the password in plaintext via CLI or in `conf/keycloak.properties`, but instead using good practices such as using a vault or an environment variable - both can be substituted in the properties file. If no password is set, the default password `password` is used.++== Enable other TLS Version(s)+As per default, Keycloak uses the current TLS Version, which is 1.3 at the time of writing. If you need to use an older version, you may change the version by running:++<@kc.all parameters=""--https-protocols=<version>[,<version>]""/>++To also allow TLSv1.2, you can use for example `kc.sh start --http-protocols=TLSv1.3,TLSv1.2`.++== Switch the HTTPS port+You can switch the port Keycloak listens on for HTTPS traffic by running:+<@kc.all parameters=""--https-port=<port>""/>++== Using a truststore","I'm not sure if this part is accurate.The trust-store configuration here should be about setting up the HTTPS listener to verify client certificates.The examples you are giving here are related to another level of configuration. Please, see https://www.keycloak.org/docs/latest/server_installation/#_truststore.  ",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9535,783894002,2022-01-13T12:01:42Z,operator/src/main/java/org/keycloak/operator/v2alpha1/NameUtils.java,"@@ -0,0 +1,46 @@+package org.keycloak.operator.v2alpha1;++import java.nio.charset.StandardCharsets;+import java.util.Locale;++public class NameUtils {++    // DNS Subdomain Names+    // https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names+    // TODO: test me+    public static String getValidDNSSubdomainName(String in) {","Cannot find it, BTW this is ""automatic-mangling"" of names (and probably we would need something similar in the CRD generator too ...)",
120057,metacosm,https://api.github.com/repos/keycloak/keycloak/pulls/9535,783962922,2022-01-13T13:36:46Z,operator/src/main/java/org/keycloak/operator/v2alpha1/NameUtils.java,"@@ -0,0 +1,46 @@+package org.keycloak.operator.v2alpha1;++import java.nio.charset.StandardCharsets;+import java.util.Locale;++public class NameUtils {++    // DNS Subdomain Names+    // https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names+    // TODO: test me+    public static String getValidDNSSubdomainName(String in) {",See https://github.com/fabric8io/kubernetes-client/blob/master/kubernetes-client/src/main/java/io/fabric8/kubernetes/client/utils/KubernetesResourceUtil.java#L228 for example (and other methods in that class). That's probably where we should consolidate such methods.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,784108021,2022-01-13T16:11:30Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryMapModelCriteriaBuilder.java,"@@ -175,6 +189,43 @@ private StringBuilder getWhereClauseBuilder() {         return whereClauseBuilder;     } +    public static Object sanitize(Object value) {",This method is unused.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,784109028,2022-01-13T16:12:38Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryOperators.java,"@@ -74,25 +76,31 @@         /**          * Produces an Ickle query where clause for obtained parameters          *+         * @param modelField searchable field          * @param fieldName left side operand          * @param values right side operands          * @param parameters mapping between named parameters and actual parameter values          * @return resulting string that will be part of resulting          */-        String combine(String fieldName, Object[] values, Map<String, Object> parameters);+        String combine(SearchableModelField<?> modelField, String fieldName, Object[] values, Map<String, Object> parameters);","We introduced this parameter to distinguish between analyzed and non-analyzed fields. However, currently, we are not using it, should we remove this parameter?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,784260502,2022-01-13T19:24:44Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/JpaRoleModelCriteriaBuilder.java,"@@ -82,11 +86,29 @@ public JpaRoleModelCriteriaBuilder compare(SearchableModelField<? super RoleMode                 }             case IN:                 if (modelField.equals(SearchableFields.ID)) {-                    validateValue(value, modelField, op, String.class);+                    if (value == null || value.length == 0) throw new CriterionNotSupportedException(modelField, op);++                    final Collection collectionValues;+                    if (value.length > 1) { // array","The operand may be an array even when `value.length == 1`. For correct treatment, please see e.g. https://github.com/keycloak/keycloak/blob/4c747047cef126a182b78cb1238824b447c1fbc9/model/map/src/main/java/org/keycloak/models/map/storage/chm/CriteriaOperator.java#L144-L157",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,784261921,2022-01-13T19:26:49Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/JpaRoleModelCriteriaBuilder.java,"@@ -82,11 +86,29 @@ public JpaRoleModelCriteriaBuilder compare(SearchableModelField<? super RoleMode                 }             case IN:                 if (modelField.equals(SearchableFields.ID)) {-                    validateValue(value, modelField, op, String.class);+                    if (value == null || value.length == 0) throw new CriterionNotSupportedException(modelField, op);++                    final Collection collectionValues;+                    if (value.length > 1) { // array+                        collectionValues = Arrays.asList(value);+                    } else if (value[0] instanceof Collection) {+                        collectionValues = (Collection) value[0];+                    } else if (value[0] instanceof Stream) {+                        Stream<Object> str = ((Stream) value[0]);+                        collectionValues = str.collect(Collectors.toCollection(LinkedList::new));+                    } else {+                        throw new CriterionNotSupportedException(modelField, op);+                    }                      return new JpaRoleModelCriteriaBuilder((cb, root) -> {                         In<String> in = cb.in(root.get(""id""));-                        ((Stream<String>) value[0]).forEach(id -> in.value(id));+                        for (Object id : collectionValues) {+                            if (id instanceof String) {+                                in.value((String) id);+                            } else {+                                throw new CriterionNotSupportedException(modelField, op);+                            }","Could you just use `Objects.toString(id, null)` rather than throwing an exception?",
13701445,dteleguin,https://api.github.com/repos/keycloak/keycloak/pulls/8895,784404282,2022-01-13T23:35:12Z,services/src/main/java/org/keycloak/services/util/DPoPUtil.java,"@@ -0,0 +1,327 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.services.util;++import java.net.URI;+import java.net.URISyntaxException;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;++import javax.ws.rs.core.HttpHeaders;+import javax.ws.rs.core.UriInfo;++import org.jboss.resteasy.spi.HttpRequest;++import org.keycloak.TokenVerifier;+import org.keycloak.common.VerificationException;+import org.keycloak.common.util.Time;+import org.keycloak.crypto.Algorithm;+import org.keycloak.crypto.KeyWrapper;+import org.keycloak.crypto.SignatureProvider;+import org.keycloak.crypto.SignatureVerifierContext;+import org.keycloak.exceptions.TokenVerificationException;+import org.keycloak.jose.jwk.JWK;+import org.keycloak.jose.jws.JWSHeader;+import org.keycloak.jose.jws.crypto.HashUtils;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.SingleUseTokenStoreProvider;+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;+import org.keycloak.representations.AccessToken;+import org.keycloak.representations.dpop.DPoP;+import org.keycloak.util.JWKSUtils;++/**+ * @author <a href=""mailto:dmitryt@backbase.com"">Dmitry Telegin</a>+ */+public class DPoPUtil {++    public static final int DEFAULT_PROOF_LIFETIME = 10;+    public static final int DEFAULT_ALLOWED_CLOCK_SKEW = 2;+    public static final String DPOP_TOKEN_TYPE = ""DPoP"";+    public static final String DPOP_SCHEME = ""DPoP"";+    public final static String DPOP_SESSION_ATTRIBUTE = ""dpop"";++    public static enum Mode {+        ENABLED,+        OPTIONAL,+        DISABLED+    }++    private static final String DPOP_HEADER = ""DPoP"";+    private static final String DPOP_HEADER_TYPE = ""dpop+jwt"";+    private static final String DPOP_ATH_ALG = ""RS256"";++    public static final Set<String> DPOP_SUPPORTED_ALGS = Stream.of(+        Algorithm.ES256,+        Algorithm.ES384,+        Algorithm.ES512,+        Algorithm.PS256,+        Algorithm.PS384,+        Algorithm.PS512,+        Algorithm.RS256,+        Algorithm.RS384,+        Algorithm.RS512+    ).collect(Collectors.toSet());++    public static DPoP validateDPoP(KeycloakSession session, ClientModel client, HttpHeaders headers, HttpRequest request, UriInfo uri) throws VerificationException {+        return validateDPoP(session, client, headers, request, uri, null);+    }++    public static DPoP validateDPoP(KeycloakSession session, ClientModel client, HttpHeaders headers, HttpRequest request, UriInfo uri, String tokenString) throws VerificationException {+        String token = headers.getHeaderString(DPOP_HEADER);++        if (token == null || token.trim().equals("""")) {+            throw new VerificationException(""DPoP proof is missing"");+        }++        TokenVerifier<DPoP> verifier = TokenVerifier.create(token, DPoP.class);+        JWSHeader header;++        try {+            header = verifier.getHeader();+        } catch (VerificationException ex) {+            throw new VerificationException(""DPoP header verification failure"");+        }++        if (!DPOP_HEADER_TYPE.equals(header.getType())) {+            throw new VerificationException(""Invalid or missing type in DPoP header: "" + header.getType());+        }++        String algorithm = header.getAlgorithm().name();++        if (!DPOP_SUPPORTED_ALGS.contains(algorithm)) {+            throw new VerificationException(""Unsupported DPoP algorithm: "" + header.getAlgorithm());+        }++        JWK key = header.getKey();++        if (key == null) {+            throw new VerificationException(""No JWK in DPoP header"");+        } else {+            KeyWrapper wrapper = JWKSUtils.getKeyWrapper(key);+            if (wrapper.getPublicKey() == null) {+                throw new VerificationException(""No public key in DPoP header"");+            }+            if (wrapper.getPrivateKey() != null) {+                throw new VerificationException(""Private key is present in DPoP header"");+            }+        }++        key.setAlgorithm(header.getAlgorithm().name());++        SignatureVerifierContext signatureVerifier = session.getProvider(SignatureProvider.class, algorithm).verifier(key);+        verifier.verifierContext(signatureVerifier);+        verifier.withChecks(+                DPoPClaimsCheck.INSTANCE,+                new DPoPHTTPCheck(request, uri),+                new DPoPIsActiveCheck(session, client),+                new DPoPReplayCheck(session, client));++        if (tokenString != null) {+            verifier.withChecks(new DPoPAccessTokenHashCheck(tokenString));+        }++        try {+            DPoP dPoP = verifier.verify().getToken();+            dPoP.setThumbprint(JWKSUtils.computeThumbprint(key));+            return dPoP;+        } catch (DPoPVerificationException ex) {+            throw ex;+        } catch (VerificationException ex) {+            throw new VerificationException(""DPoP verification failure"", ex);+        }++    }++    public static void validateBinding(AccessToken token, DPoP dPoP) throws VerificationException {+        try {+            TokenVerifier.createWithoutSignature(token)+                    .withChecks(new DPoPUtil.DPoPBindingCheck(dPoP))+                    .verify();+        } catch (TokenVerificationException ex) {+            throw ex;+        } catch (VerificationException ex) {+            throw new VerificationException(""Token verification failure"", ex);+        }+    }++    public static void bindToken(AccessToken token, DPoP dPoP) {+        AccessToken.Confirmation confirmation = token.getConfirmation();++        if (confirmation == null) {+            confirmation = new AccessToken.Confirmation();+            token.setConfirmation(confirmation);+        }++        confirmation.setKeyThumbprint(dPoP.getThumbprint());+    }++    private static class DPoPClaimsCheck implements TokenVerifier.Predicate<DPoP> {++        static final TokenVerifier.Predicate<DPoP> INSTANCE = new DPoPClaimsCheck();++        @Override+        public boolean test(DPoP t) throws DPoPVerificationException {+            Long iat = t.getIat();+            String jti = t.getId(), htu = t.getHttpUri(), htm = t.getHttpMethod();++            if (iat != null &&+                jti != null && !jti.trim().equals("""") &&+                htm != null && !htm.trim().equals("""") &&+                htu != null && !htu.trim().equals("""")) {+                return true;+            } else {+                throw new DPoPVerificationException(t, ""DPoP mandatory claims are missing"");+            }+        }++    }++    private static class DPoPHTTPCheck implements TokenVerifier.Predicate<DPoP> {++        private final HttpRequest request;+        private final UriInfo uri;++        DPoPHTTPCheck(HttpRequest request, UriInfo uri) {+            this.request = request;+            this.uri = uri;+        }++        @Override+        public boolean test(DPoP t) throws DPoPVerificationException {+            try {+                if (new URI(t.getHttpUri()).equals(uri.getAbsolutePath()) &&+                    request.getHttpMethod().equals(t.getHttpMethod())) {+                    return true;+                } else {+                    throw new DPoPVerificationException(t, ""DPoP HTTP method/URL mismatch"");+                }+            } catch (URISyntaxException ex) {+                throw new DPoPVerificationException(t, ""Malformed HTTP URL in DPoP proof"");+            }+        }++    }++    private static class DPoPReplayCheck implements TokenVerifier.Predicate<DPoP> {++        private final KeycloakSession session;+        private final int lifetime;++        public DPoPReplayCheck(KeycloakSession session, ClientModel client) {+            this.session = session;+            OIDCAdvancedConfigWrapper config = OIDCAdvancedConfigWrapper.fromClientModel(client);+            this.lifetime = config.getDPoPProofLifetime();+        }++        @Override+        public boolean test(DPoP t) throws DPoPVerificationException {+            SingleUseTokenStoreProvider singleUseCache = session.getProvider(SingleUseTokenStoreProvider.class);+            byte[] hash = HashUtils.hash(""SHA1"", (t.getId() + ""\n"" + t.getHttpUri()).getBytes());","The spec also [says](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop#section-10.1):>    Servers SHOULD store, **in the context of the request URI**, the `jti`   value of each DPoP proof for the time window in which the respective   DPoP proof JWT would be accepted and decline HTTP requests **to the   same URI** for which the `jti` value has been seen before.From this, I conclude that the `jti` values should be URI-scoped. The simplest way to enforce one-time use of a URI-scoped `jti` is to incorporate the URI representation into the single use cache key. Hashing is used to guard against any unexpected characters in input strings, but maybe I'm somewhat overcautious here.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,784404852,2022-01-13T23:36:50Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/JpaRoleModelCriteriaBuilder.java,"@@ -0,0 +1,140 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.role;++import java.util.function.BiFunction;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.CriteriaBuilder.In;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.RoleModel;+import org.keycloak.models.RoleModel.SearchableFields;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.role.entity.JpaRoleEntity;+import org.keycloak.storage.SearchableModelField;++public class JpaRoleModelCriteriaBuilder extends JpaModelCriteriaBuilder implements ModelCriteriaBuilder<RoleModel, JpaRoleModelCriteriaBuilder> {++    private BiFunction<CriteriaBuilder, Root<JpaRoleEntity>, Predicate> predicateFunc = null;++    public JpaRoleModelCriteriaBuilder() {+    }++    private JpaRoleModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaRoleEntity>, Predicate> predicateFunc) {+        this.predicateFunc = predicateFunc;+    }++    private String getFieldName(SearchableModelField<? super RoleModel> modelField) {+        return ""f"" + modelField.getName().substring(0, 1).toUpperCase() + modelField.getName().substring(1);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public JpaRoleModelCriteriaBuilder compare(SearchableModelField<? super RoleModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(SearchableFields.REALM_ID) ||+                    modelField.equals(SearchableFields.CLIENT_ID)) {++                    validateValue(value, modelField, op, String.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) -> +                        cb.equal(+                            cb.function(""->"", JsonbType.class, root.get(""metadata""), cb.literal(getFieldName(modelField))), +                            cb.literal(convertToJson(value[0]))+                        )+                    );+                } else if (modelField.equals(SearchableFields.NAME)) {+                    validateValue(value, modelField, op, String.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) -> +                        cb.equal(root.get(modelField.getName()), value[0])+                    );+                } else if (modelField.equals(SearchableFields.IS_CLIENT_ROLE)) {+                    validateValue(value, modelField, op, Boolean.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) -> +                        cb.equal(+                            cb.function(""->"", JsonbType.class, root.get(""metadata""), cb.literal(""fClientRole"")), +                            cb.literal(convertToJson(value[0]))+                        )+                    );+                } else {+                    throw new CriterionNotSupportedException(modelField, op);+                }+            case IN:+                if (modelField.equals(SearchableFields.ID)) {+                    validateValue(value, modelField, op, String.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) -> {+                        In<String> in = cb.in(root.get(""id""));+                        ((Stream<String>) value[0]).forEach(id -> in.value(id));+                        return in;+                    });+                } else {+                    throw new CriterionNotSupportedException(modelField, op);+                }+            case ILIKE:+                if (modelField.equals(SearchableFields.NAME) ||+                    modelField.equals(SearchableFields.DESCRIPTION)) {++                    validateValue(value, modelField, op, String.class);++                    return new JpaRoleModelCriteriaBuilder((cb, root) ->+                        cb.like(+                            cb.lower(cb.function(""->"", String.class, root.get(""metadata""), cb.literal(getFieldName(modelField)))),+                            cb.literal(convertToJson(value[0]).toLowerCase())+                        )+                    );+                } else {+                    throw new CriterionNotSupportedException(modelField, op);+                }+            default:+                throw new CriterionNotSupportedException(modelField, op);+        }+    }++    @Override+    public JpaRoleModelCriteriaBuilder and(JpaRoleModelCriteriaBuilder... builders) {+        return new JpaRoleModelCriteriaBuilder(+            (cb, root) -> cb.and(Stream.of(builders).map(b -> b.getPredicateFunc().apply(cb, root)).toArray(Predicate[]::new))+        );+    }++    @Override+    public JpaRoleModelCriteriaBuilder or(JpaRoleModelCriteriaBuilder... builders) {+        return new JpaRoleModelCriteriaBuilder(+            (cb, root) -> cb.or(Stream.of(builders).map(b -> b.getPredicateFunc().apply(cb, root)).toArray(Predicate[]::new))+        );+    }++    @Override+    public JpaRoleModelCriteriaBuilder not(JpaRoleModelCriteriaBuilder builder) {+        return new JpaRoleModelCriteriaBuilder(+            (cb, root) -> cb.not(builder.getPredicateFunc().apply(cb, root))+        );+    }","Thank you for the suggestion. I've played a little bit with it and came up with 2 possible solutions (https://github.com/keycloak/keycloak/pull/9415/commits/28dacf606aa1d5ad699d844f050c7d0979e706aa or https://github.com/keycloak/keycloak/pull/9415/commits/80d13940a7cfbabc295b1762800ab08169e0b8dd). The first approach uses `public abstract class JpaModelCriteriaBuilder<E, Self extends JpaModelCriteriaBuilder>` and child classes then `implements ModelCriteriaBuilder`. Methods `and`, `or` and `not` don't require casting `Self builder` into `JpaModelCriteriaBuilder` when using this approach. But we cannot mark the methods by `@Override` annotation (and IDE doesn't find then as implementations, at least in my case :) )While the second approach uses `public abstract class JpaModelCriteriaBuilder<E, M, Self extends ModelCriteriaBuilder<M, Self>> implements ModelCriteriaBuilder<M, Self>` and child classes then just extends it. I wonder which approach would be better, wdyt? There might be some other even better solution though.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9565,784717648,2022-01-14T10:09:12Z,docs/guides/src/main/server/features.adoc,"@@ -0,0 +1,105 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+title=""Enabling and disabling features""+summary=""Understand how to configure Keycloak to use optional features""+includedOptions=""features features.*"">++Keycloak has packed some functionality in features, some of them not enabled by default. These features include features that are in tech preview or deprecated features. In addition there are some features that are enabled by default, but can be disabled if you don't need them for your specific usage scenario.++== List of optional features++[cols=""4*"", options=""header""]","@stianst fyi: this manual listing of options here in the table is why i created https://github.com/keycloak/keycloak/issues/9549 - also the dependency I had to add and the change in Options.java should not be necessary anymore when #9549 is solved. We should be able to add features as ""normal"" Configuration options and add e.g. a field ""extended description"" or sth to show the description in this table. Reduces additional maintenance overhead and polishes the codebase",
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/9478,785180294,2022-01-14T21:27:48Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,196 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/link.adoc"" as link>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Configuration Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at the <@link.guide title=""All configuration""/> section.++These options can be set using different formats:++.Command-line argument+<@kc.all parameters=""--<category>-<sub-category>-<property>=<value>""/>++.Environment variable+```+export KC_CATEGORY_SUB_CATEGORY_PROPERTY=<value>+```++.Properties at `conf/keycloak.properties`+```+<category>.<sub-category>.<property>=<value>+```++The format you should use is use-case specific but most of the time it should be enough to use the CLI. As an example, when running+the server as a container you should be fine using both environment variables or command-line options.++[NOTE]+If you are unsure about the format of a specific property, consider looking at the <@link.guide title=""All configuration""/> section.++If the same configuration option is defined in different configuration sources, the effective value will be resolved by respecting the following order:++. Command-line arguments+. Environment variables+. From `conf/keycloak.properties`++== Configuring the server for optimal runtime++Some configuration options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++By looking at the individual configuration options at this <@link.guide title=""All configuration"" text=""section""/>, you will notice+that some options require a `build`. In other words, they can only be set when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++[NOTE]+By default, the `help` message for the `build` command only shows the options that require a build. You can also use the `help-all` option to list all the available options, including those+that do not require a build.++The `build` command is responsible for producing an immutable and optimized server image (similar concept to building a container image). In addition to persisting+any configuration option you have set, this command will also perform a series of optimizations to deliver the best runtime when starting and running the server. Basically,+a lot of processing that would usually happen when starting/running the server is no longer necessary and the server can start and run faster.++Some optimizations performed by the `build` command are:++* Closed-world assumption about installed providers, hence no need to re-create the registry everytime the server starts+* Configuration files (e.g.: clustering) are pre-parsed to reduce IO when starting the server+* Database specific resources are configured and prepared to run against a specific database vendor+* By persisting configuration options into the server image, the server does not perform any additional step to interpret configuration options and (re)configure itself++There are many more optimizations, most of them performed by <@link.external url=""https://quarkus.io"" text=""Quarkus""/> itself. Just keep in mind that this additional step is a key aspect to achieve the optimal runtime,+ideally when running Keycloak as a container.++Once you run the `build` command, you won't need to set the same configuration options again (they are now persisted) so that you can just `start` the server:++.Building an optimized server image+<@kc.build parameters=""--db=postgres --db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++.Starting the server+<@kc.start/>++As a rule of thumb, prefer building a server image to achieve the optimal runtime as well as running the `start` command without any parameter for faster startup time.++=== Overriding settings++Once you have built a server image using the `build` command, you should be able to override any property that is available from the `start` command.++For instance, if you have built an image as follows:++<@kc.build parameters=""--db=postgres --db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++You should be able to override the `db-username`, `hostname`, or any other property available to the `start` command:++<@kc.start parameters=""--db-username foo --hostname newkeycloak.acme.com""/>++As a result, the server should start using all the configuration options previously set using the `build` command but overriding those that you explicitly+set when starting the server.++This configuration approach can be useful when building an opinionated server image with the possibility to override specific options that are allowed to+change when starting the server (those available to the `start` command).++== Configuring the server from a properties file++By default, the server is going to always fetch any configuration option you set in the `conf/keycloak.properties` file. When you are using a fresh distribution,+this file holds only the recommended settings for running in production which are initially commented out.++You are able to also specify a different configuration file by using the `[-cf|--config-file] option as follows:++<@kc.all rootParameters=""-cf myconfig.properties""/>++[NOTE]+Changes to any configuration option defined in the `keycloak.properties` file that is targeted for the `build` command will be ignored+if the value differs from the value used to previously run the `build` command. In this case, make sure you run the `build` command again so that+these configurations options take effect.++== Using placeholders++You should be able to use placeholders to dynamically change the value of configuration options when starting the server.++For that, you should use the following format when defining the value of an option:++```+db.username=${r""${my.db.user}""}+```++By using a placeholder like in the example above, the server is going to try to resolve the `my.db.user` variable from:++* A system property using the same key+* An environment variable by replacing dots with `_`.++Placeholders can also be used when building a server image using the `build` command so that the value of a configuration option is updated+with the value set to the placeholder (system property or environment variable) when starting the server.++[NOTE]+You should not use placeholders for configuration options that can only be set through the `build` command. The reason is that these options+can not change once they are persisted into the server image. Prefer using placeholders only for the configurations options available to+the `start` command.++== Configuration profiles++Most of the time the server is deployed to different environments like testing, staging, and production environments. Although they share some+core configuration options (e.g: database, clustering, etc) some other options might change on a per-environment basis.","change (e.g: database, clustering, etc)TO, such as database or clustering,",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,785448030,2022-01-16T14:20:44Z,model/map-jpa/src/main/resources/META-INF/roles/jpa-roles-changelog-1.xml,"@@ -0,0 +1,72 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: roles-${org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_ROLE} -->+    <changeSet author=""keycloak"" id=""roles-1"">++        <createTable tableName=""role"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""role"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""name"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fName""/>+        </ext:addGeneratedColumn>+        <createIndex tableName=""role"" indexName=""role_entityVersion"">+            <column name=""entityversion""/>+        </createIndex>+        <createIndex tableName=""role"" indexName=""role_name"">+            <column name=""name""/>","It's used every time when exact match for the role.name is queried. It is not possible to use both gin and b-tree index for single sql statement, therefore index gin on `fRealmId` cannot be used.The query plan then looks like:```Index Scan using role_name on role  (cost=0.43..8.46 rows=1 width=175) (actual time=0.037..0.038 rows=1 loops=1)  Index Cond: ((name)::text = '94f269adc0'::text)  Filter: ((metadata -> 'fRealmId'::text) = '""test0""'::jsonb)Planning Time: 0.217 msExecution Time: 0.049 ms```Another possibility would be to introduce realmId generated column and then edit this index to multi-column one.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9546,785710748,2022-01-17T07:54:27Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -54,6 +55,10 @@     @Column     private UUID id; +    //used for implicit optimistic locking+    @Version+    private int version;","The `@Column` annotation is optional from a technical point of view as long as you don't use it to change the database field name, type or to add constraints. Basically every time we use the ""plain"" annotation without any parameters we could leave it out. ",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9546,785711947,2022-01-17T07:56:38Z,model/map-jpa/src/main/resources/META-INF/clients/jpa-clients-changelog-1.xml,"@@ -29,6 +29,7 @@ limitations under the License.             <column name=""id"" type=""UUID"">                 <constraints primaryKey=""true"" nullable=""false""/>             </column>+            <column name=""version"" type=""INTEGER""/>","As this is the initial setup of the table with no data in it, the default value would be optional. +1 for ""not null"". If we want consistency on this for version columns, there should be a unit test for that (but that should be a separate GitHub issue). ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9536,785794832,2022-01-17T09:49:02Z,docs/guides/src/main/server/enabletls.adoc,"@@ -0,0 +1,58 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+title=""Configure Keycloak to use TLS""+summary=""Learn how to use HTTPS/TLS with Keycloak""+includedOptions=""https.* http.enabled"">++Transport Layer Security (short: TLS) is crucial to exchange data over a secured channel. For production environments, you should never expose Keycloak endpoints through HTTP, as sensitive data is at the core of what Keycloak exchanges with other applications. In this guide you will learn how to configure Keycloak to use HTTPS/TLS.++== Configure TLS in Keycloak+Keycloak can be configured to load the needed certificate infrastructure either from a certificate / key file pair in PEM format or from an existing keystore file. When both alternatives are set up, the certificate / key file configuration takes precedence over the keystore configuration.","""certificate / key file pair in PEM format"" is a bit long and hard to read. Perhaps something like:```suggestionKeycloak can be configured to load the needed certificate infrastructure using files in PEM format or from a Java KeyStore. When both alternatives are set up, the PEM files takes precedence over the Java KeyStores.```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9536,785801368,2022-01-17T09:56:56Z,docs/guides/src/main/server/enabletls.adoc,"@@ -0,0 +1,58 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+title=""Configure Keycloak to use TLS""+summary=""Learn how to use HTTPS/TLS with Keycloak""+includedOptions=""https.* http.enabled"">++Transport Layer Security (short: TLS) is crucial to exchange data over a secured channel. For production environments, you should never expose Keycloak endpoints through HTTP, as sensitive data is at the core of what Keycloak exchanges with other applications. In this guide you will learn how to configure Keycloak to use HTTPS/TLS.++== Configure TLS in Keycloak+Keycloak can be configured to load the needed certificate infrastructure either from a certificate / key file pair in PEM format or from an existing keystore file. When both alternatives are set up, the certificate / key file configuration takes precedence over the keystore configuration.++=== Providing a certificate / key file pair+When you use a pair of matching certificate / private key files in PEM format, configure Keycloak to use them by running:++<@kc.all parameters=""--https-certificate-file=/path/to/certfile.pem --https-certificate-key-file=/path/to/keyfile.pem""/>++Keycloak creates a keystore out of these files in memory and uses this keystore afterwards.++=== Providing a keystore+As an alternative, you can use an existing keystore by running:+<@kc.all parameters=""--https-key-store-file=/path/to/existing-keystore-file""/>++When no keystore file is configured explicitly, but `http.enabled` is set to false, Keycloak tries to use a `server.keystore` file in the `conf` location by default.++==== Setting a keystore password+You can set a secure password for your keystore using the `https.key-store.password` option:+<@kc.all parameters=""--https-key-store-password=<value>""/>++[NOTE]+We recommend to not set the password in plaintext via the CLI or in `conf/keycloak.properties`, but instead using good practices such as using a vault or an environment variable - both can be substituted in the properties file. If no password is set, the default password `password` is used.++== Enable other TLS Version(s)+As per default, Keycloak uses the current TLS Version, which is 1.3 at the time of writing. If you need to use an older version, you may change the version by running:","```suggestionBy default, Keycloak does not enable deprecated TLS protocols. In situations where clients only support deprecated protocols, first consider upgrading the client, but as a temporary work-around you can enable deprecated protocols with:```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9536,785801572,2022-01-17T09:57:08Z,docs/guides/src/main/server/enabletls.adoc,"@@ -0,0 +1,58 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+title=""Configure Keycloak to use TLS""+summary=""Learn how to use HTTPS/TLS with Keycloak""+includedOptions=""https.* http.enabled"">++Transport Layer Security (short: TLS) is crucial to exchange data over a secured channel. For production environments, you should never expose Keycloak endpoints through HTTP, as sensitive data is at the core of what Keycloak exchanges with other applications. In this guide you will learn how to configure Keycloak to use HTTPS/TLS.++== Configure TLS in Keycloak+Keycloak can be configured to load the needed certificate infrastructure either from a certificate / key file pair in PEM format or from an existing keystore file. When both alternatives are set up, the certificate / key file configuration takes precedence over the keystore configuration.++=== Providing a certificate / key file pair+When you use a pair of matching certificate / private key files in PEM format, configure Keycloak to use them by running:++<@kc.all parameters=""--https-certificate-file=/path/to/certfile.pem --https-certificate-key-file=/path/to/keyfile.pem""/>++Keycloak creates a keystore out of these files in memory and uses this keystore afterwards.++=== Providing a keystore+As an alternative, you can use an existing keystore by running:+<@kc.all parameters=""--https-key-store-file=/path/to/existing-keystore-file""/>++When no keystore file is configured explicitly, but `http.enabled` is set to false, Keycloak tries to use a `server.keystore` file in the `conf` location by default.++==== Setting a keystore password+You can set a secure password for your keystore using the `https.key-store.password` option:+<@kc.all parameters=""--https-key-store-password=<value>""/>++[NOTE]+We recommend to not set the password in plaintext via the CLI or in `conf/keycloak.properties`, but instead using good practices such as using a vault or an environment variable - both can be substituted in the properties file. If no password is set, the default password `password` is used.++== Enable other TLS Version(s)+As per default, Keycloak uses the current TLS Version, which is 1.3 at the time of writing. If you need to use an older version, you may change the version by running:++<@kc.all parameters=""--https-protocols=<version>[,<version>]""/>","```suggestion<@kc.all parameters=""--https-protocols=<protocol>[,<protocol>]""/>```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9604,786131238,2022-01-17T15:55:53Z,docs/guides/src/main/server/features.adoc,"@@ -0,0 +1,61 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+title=""Enabling and disabling features""+summary=""Understand how to configure Keycloak to use optional features"">++Keycloak has packed some functionality in features, some of them not enabled by default. These features include features that are in tech preview or deprecated features. In addition there are some features that are enabled by default, but can be disabled if you don't need them for your specific usage scenario.++=== Enabling and disabling features++Features need to be enabled/disabled using the `build` command.+To enabe a specific feature, for example to enable the ability to use the `token_exchange` functionality, run:++<@kc.build parameters=""--features-token_exchange=enabled""/>++To disable it, respectively, run:+<@kc.build parameters=""--features-token_exchange=disabled""/>++If you want to have all preview features enabled at once, you can build the server using+<@kc.build parameters=""--features=preview""/>++== List of supported features++The following features are supported.++<@showFeatures ctx.features.supported/>++=== Disabled by default++The following features are supported, but are not enabled by default.++<@showFeatures ctx.features.supportedDisabledByDefault/>++== List of preview features++The following list are preview features that are not recommended in production. These features may also be changed, or even removed, in a future release.","(imo) better: ""The following list contains..."", so remove ""are""",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9604,786135729,2022-01-17T16:01:39Z,common/src/main/java/org/keycloak/common/Profile.java,"@@ -48,37 +48,43 @@     }      public enum Feature {-        AUTHORIZATION(Type.DEFAULT),-        ACCOUNT2(Type.DEFAULT),-        ACCOUNT_API(Type.DEFAULT),-        ADMIN_FINE_GRAINED_AUTHZ(Type.PREVIEW),-        ADMIN2(Type.EXPERIMENTAL),-        DOCKER(Type.DISABLED_BY_DEFAULT),-        IMPERSONATION(Type.DEFAULT),-        OPENSHIFT_INTEGRATION(Type.PREVIEW),-        SCRIPTS(Type.PREVIEW),-        TOKEN_EXCHANGE(Type.PREVIEW),-        UPLOAD_SCRIPTS(DEPRECATED),-        WEB_AUTHN(Type.DEFAULT, Type.PREVIEW),-        CLIENT_POLICIES(Type.DEFAULT),-        CIBA(Type.DEFAULT),-        MAP_STORAGE(Type.EXPERIMENTAL),-        PAR(Type.DEFAULT),-        DECLARATIVE_USER_PROFILE(Type.PREVIEW),-        DYNAMIC_SCOPES(Type.EXPERIMENTAL);-+        AUTHORIZATION(""Authorization Service"", Type.DEFAULT),","Just a thought: Does it make sense to align the implementation here: https://github.com/keycloak/keycloak/blob/f80d336276fb73603415aedda56b6da4580deb00/quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Picocli.java#L303-L329 with the new Profile.java implementation? Benefit: Having the default value set to enabled/disabled and showing this in the CLI help, plus optionally having the same description from the label (if we want this). ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9414,786274794,2022-01-17T20:25:42Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -341,28 +342,37 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool      protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserSessionPredicate predicate, boolean offline) { -        if (offline && loadOfflineSessionsStatsFromDatabase) {+        if (offline && loadOfflineSessionsFromDatabase) {              // fetch the offline user-sessions from the persistence provider             UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class); -            UserModel user = session.users().getUserById(realm, predicate.getUserId());-            if (user != null) {-                return persister.loadUserSessionsStream(realm, user, offline, 0, null);+            if (predicate.getUserId() != null) {+                UserModel user = session.users().getUserById(realm, predicate.getUserId());+                if (user != null) {+                    return persister.loadUserSessionsStream(realm, user, true, 0, null);+                }+            }++            if (predicate.getBrokerUserId() != null) {+                String[] idpAliasSessionId = predicate.getBrokerUserId().split(""\\."");++                Map<String, String> attributes = new HashMap<>();+                attributes.put(UserModel.IDP_ALIAS, idpAliasSessionId[0]);+                attributes.put(UserModel.IDP_USER_ID, idpAliasSessionId[1]);++                UserProvider userProvider = session.getProvider(UserProvider.class);+                UserModel userModel = userProvider.searchForUserStream(realm, attributes, 0, null).findFirst().orElse(null);+                return userModel != null ?+                        persister.loadUserSessionsStream(realm, userModel, true, 0, null) :+                        Stream.empty();             }              if (predicate.getBrokerSessionId() != null) {                 // TODO add support for offline user-session lookup by brokerSessionId                 // currently it is not possible to access the brokerSessionId in offline user-session in a database agnostic way-                throw new ModelException(""Dynamic database lookup for offline user-sessions by brokerSessionId is currently only supported for preloaded sessions."");+                throw new ModelException(""Dynamic database lookup for offline user-sessions by brokerSessionId is currently only supported for preloaded sessions. Set preloadOfflineSessionsFromDatabase = true in InfinispanUserSessionProviderFactory to enable the lookup."");","```suggestion                throw new ModelException(""Dynamic database lookup for offline user-sessions by broker session ID is currently only supported for preloaded sessions. Set preloadOfflineSessionsFromDatabase option to ""true"" in "" + UserSessionSpi.NAME + "" SPI in "" + InfinispanUserSessionProviderFactory.PROVIDER_ID + "" provider to enable the lookup."");```",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9419,786557944,2022-01-18T09:25:42Z,themes/src/main/resources/theme/base/admin/resources/js/controllers/realm.js,"@@ -556,10 +556,14 @@ module.controller('RealmLocalizationCtrl', function($scope, Current, $location,      $scope.updateRealmSpecificLocalizationTexts = function() {         RealmSpecificLocalizationTexts.get({id: realm.realm, locale: $scope.selectedRealmSpecificLocales }, function (updated) {-            $scope.localizationTexts = updated;+            $scope.localizationTexts = sortObjectByKeys(updated);         })     } +    function sortObjectByKeys(o) {+        return Object.keys(o).sort().reduce((r, k) => (r[k] = o[k], r), {});","Hi @jonkoops - thanks for looking at this and finding this I didn't. ""+1"" for the arrow functions. As I was wondering why my manual test succeeded while the spec says this is no guaranteed behavior, I found this discussion on SO indicating that the specified behavior changed in ES6 (see answer by Mathias Bynens): https://stackoverflow.com/questions/5467129/sort-javascript-object-by-keyAs you point out that this should run on older browsers as well, this must not be relied upon. A quick look at the docs didn't reveal a list of supported browsers to me. Could you please point me at more information about this topic? Thanks!",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9478,786588581,2022-01-18T09:59:55Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,196 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/link.adoc"" as link>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Configuration Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at the <@link.guide title=""All configuration""/> section.++These options can be set using different formats:++.Command-line argument+<@kc.all parameters=""--<category>-<sub-category>-<property>=<value>""/>","Perhaps category and sub-category is confusing as that hasn't been defined here. Maybe just change this to:```suggestion<@kc.all parameters=""--<property>=<value>""/>```",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,786953763,2022-01-18T16:43:24Z,operator/pom.xml,"@@ -63,6 +67,11 @@             <groupId>io.quarkiverse.operatorsdk</groupId>             <artifactId>quarkus-operator-sdk</artifactId>         </dependency>+        <dependency>","java-operator is a transitive dependency from the Quarkus operator SDK, just bump the Quarkus SDK to `3.0.0`.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,786956609,2022-01-18T16:46:14Z,operator/pom.xml,"@@ -105,6 +114,50 @@             <groupId>org.keycloak</groupId>             <artifactId>keycloak-core</artifactId>         </dependency>+        <dependency>+            <groupId>io.quarkus</groupId>+            <artifactId>quarkus-test-common</artifactId>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>io.quarkus</groupId>+            <artifactId>quarkus-junit5</artifactId>+            <version>2.6.1.Final</version>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.assertj</groupId>+            <artifactId>assertj-core</artifactId>+            <version>3.22.0</version>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>org.awaitility</groupId>+            <artifactId>awaitility</artifactId>+            <version>4.1.1</version>+            <scope>test</scope>+        </dependency>+        <dependency>+            <groupId>io.javaoperatorsdk</groupId>+            <artifactId>operator-framework-junit-5</artifactId>+            <version>2.0.1</version>+            <exclusions>+                <exclusion>+                    <groupId>org.apache.logging.log4j</groupId>+                    <artifactId>log4j-slf4j-impl</artifactId>+                </exclusion>+            </exclusions>+        </dependency>+        <dependency>+            <groupId>org.jboss.slf4j</groupId>+            <artifactId>slf4j-jboss-logmanager</artifactId>","Quarkus should already inject the proper jboss logging, do we need this explicit dependency?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,787005275,2022-01-18T17:43:02Z,operator/src/test/java/org/keycloak/operator/OperatorBatteryTests.java,"@@ -0,0 +1,65 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.Node;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.dsl.Resource;+import org.awaitility.Awaitility;+import org.awaitility.core.ConditionTimeoutException;+import org.jboss.logging.Logger;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.io.File;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.InputStream;+import java.time.Duration;+import java.util.List;++import static org.assertj.core.api.Assertions.assertThat;++public class OperatorBatteryTests {",sorry I personally find `Battery` a little wired `OperatorTestSuite` ?naming is hard ... ,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,787010567,2022-01-18T17:49:58Z,operator/src/test/java/org/keycloak/operator/OperatorE2ELocalRunTest.java,"@@ -0,0 +1,51 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.dsl.Resource;+import io.javaoperatorsdk.operator.config.runtime.DefaultConfigurationService;+import io.javaoperatorsdk.operator.junit.OperatorExtension;+import org.jboss.logging.Logger;+import org.junit.jupiter.api.BeforeEach;+import org.junit.jupiter.api.Test;+import org.junit.jupiter.api.extension.RegisterExtension;+import org.keycloak.operator.v2alpha1.KeycloakController;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.io.File;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.InputStream;++public class OperatorE2ELocalRunTest {+    private static final Logger logger = Logger.getLogger(OperatorE2ELocalRunTest.class);++    @RegisterExtension+    OperatorExtension operator =+            OperatorExtension.builder()+                    .withConfigurationService(DefaultConfigurationService.instance())+                    .waitForNamespaceDeletion(false)","> namespace deletion takes foreverIf we are not using any specific finalizer this should not happen AFAIK, but I know it might be challenging to fix this in this PR ( [e.g.](https://github.com/lightbend/cloudflow/blob/7dad9e424c2ad89292fba5fbc24c6d6a2478e388/core/cloudflow-it/src/it/scala/ItSetup.scala#L97) ).I'm happy to leave it as-is for now and open an Issue to follow up in the future.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787044874,2022-01-18T18:36:22Z,operator/src/main/java/org/keycloak/operator/OperatorManagedResource.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.OwnerReferenceBuilder;+import io.fabric8.kubernetes.client.CustomResource;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;++import java.util.Collections;+import java.util.HashMap;+import java.util.Map;+import java.util.Optional;++/**+ * Represents a single K8s resource that is managed by this operator (e.g. Deployment, Service, Ingress, etc.)+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public abstract class OperatorManagedResource {+    protected KubernetesClient client;+    protected CustomResource<?, ?> cr;++    public OperatorManagedResource(KubernetesClient client, CustomResource<?, ?> cr) {+        this.client = client;+        this.cr = cr;+    }++    protected abstract HasMetadata getReconciledResource();++    public void createOrUpdateReconciled() {+        HasMetadata resource = getReconciledResource();+        setDefaultLabels(resource);+        setOwnerReferences(resource);++        Log.debugf(""Creating or updating resource: %s"", resource);",Can we agree on one logging framework and stick with it? I don't really mind which as long as is one.,
1836434,jonathanvila,https://api.github.com/repos/keycloak/keycloak/pulls/9625,787459194,2022-01-19T08:25:22Z,.github/workflows/operator-ci.yml,"@@ -36,4 +36,35 @@ jobs:        - name: Build the Keycloak Operator         run: |-          mvn clean package -nsu -B -e -pl operator -Doperator -Dquarkus.container-image.build=true -Dquarkus.kubernetes.deployment-target=minikube+          mvn clean package -nsu -B -e -pl operator -Doperator -Dquarkus.container-image.build=true -Dquarkus.kubernetes.deployment-target=minikube -DskipTests+  test:+    name: test+    runs-on: ubuntu-latest+    steps:+      - name: Checkout+        uses: actions/checkout@v2.3.4+      - name: Setup Minikube-Kubernetes+        uses: manusa/actions-setup-minikube@v2.4.3+        with:+          minikube version: v1.22.0+          kubernetes version: v1.21.1+          github token: ${{ secrets.GITHUB_TOKEN }}+          start args: ' --force'","To bypass several validations, as it is in CI we don't ""care"" about those validations in my opinion.Here you can see that all checks are not exiting if forced is passed : https://github.com/kubernetes/minikube/blob/master/cmd/minikube/cmd/start.go",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,787469590,2022-01-19T08:34:33Z,.github/workflows/operator-ci.yml,"@@ -36,4 +36,35 @@ jobs:        - name: Build the Keycloak Operator         run: |-          mvn clean package -nsu -B -e -pl operator -Doperator -Dquarkus.container-image.build=true -Dquarkus.kubernetes.deployment-target=minikube+          mvn clean package -nsu -B -e -pl operator -Doperator -Dquarkus.container-image.build=true -Dquarkus.kubernetes.deployment-target=minikube -DskipTests+  test:+    name: test+    runs-on: ubuntu-latest+    steps:+      - name: Checkout+        uses: actions/checkout@v2.3.4+      - name: Setup Minikube-Kubernetes+        uses: manusa/actions-setup-minikube@v2.4.3+        with:+          minikube version: v1.22.0+          kubernetes version: v1.21.1+          github token: ${{ secrets.GITHUB_TOKEN }}+          start args: ' --force'","Are we, currently, hitting any issue with those validations?I do believe that the CI environment should mirror the local development and I would like to be aware of the fact that we are hitting any edge.Can you try to run the CI without this parameter and, if it works, we can safely remove the option (at least for now)? ",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787536169,2022-01-19T09:30:10Z,operator/src/main/java/org/keycloak/operator/OperatorManagedResource.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.OwnerReferenceBuilder;+import io.fabric8.kubernetes.client.CustomResource;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;++import java.util.Collections;+import java.util.HashMap;+import java.util.Map;+import java.util.Optional;++/**+ * Represents a single K8s resource that is managed by this operator (e.g. Deployment, Service, Ingress, etc.)+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public abstract class OperatorManagedResource {+    protected KubernetesClient client;+    protected CustomResource<?, ?> cr;++    public OperatorManagedResource(KubernetesClient client, CustomResource<?, ?> cr) {+        this.client = client;+        this.cr = cr;+    }++    protected abstract HasMetadata getReconciledResource();++    public void createOrUpdateReconciled() {+        HasMetadata resource = getReconciledResource();+        setDefaultLabels(resource);+        setOwnerReferences(resource);++        Log.debugf(""Creating or updating resource: %s"", resource);+        resource = client.resource(resource).createOrReplace();+        Log.debugf(""Successfully created or updated resource: %s"", resource);+    }++    protected void setDefaultLabels(HasMetadata resource) {+        Map<String, String> labels = Optional.ofNullable(resource.getMetadata().getLabels()).orElse(new HashMap<>());+        labels.putAll(Constants.DEFAULT_LABELS);+        resource.getMetadata().setLabels(labels);+    }++    protected void setOwnerReferences(HasMetadata resource) {+        if (!cr.getMetadata().getNamespace().equals(resource.getMetadata().getNamespace())) {",> Cross-namespace owner references are disallowed by design. Namespaced dependents can specify cluster-scoped or namespaced owners.https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787538669,2022-01-19T09:32:23Z,operator/src/main/java/org/keycloak/operator/WatchedResourcesStore.java,"@@ -0,0 +1,148 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator;++import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.stream.Collectors;++/**+ * Stores a set of resource names that are related to (but not owned by) some CR. To be used by a controller for watching+ * those resources. Also stores a {@code modified} flag for each resource. Motivation for this in-memory store is to avoid+ * touching (e.g. adding labels) the resources that are not owned by the operator and not to store state in K8s.+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public class WatchedResourcesStore {",Do we? Could you please point me to it? :) I'd be more than happy to remove this class and rely only on what the SDK provides but AFAIK we currently need to handle ourselves what resources do we watch and how.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787552327,2022-01-19T09:45:13Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -16,82 +16,162 @@  */ package org.keycloak.operator.v2alpha1; +import io.fabric8.kubernetes.api.model.Container;+import io.fabric8.kubernetes.api.model.EnvVar;+import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.fabric8.kubernetes.api.model.EnvVarSourceBuilder;+import io.fabric8.kubernetes.api.model.HasMetadata; import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.api.model.apps.DeploymentBuilder; import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource; import org.keycloak.operator.v2alpha1.crds.Keycloak;-import org.keycloak.operator.v2alpha1.crds.KeycloakSpec;-import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;  import java.net.URL;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Optional;+import java.util.Set;+import java.util.regex.Matcher;+import java.util.regex.Pattern;+import java.util.stream.Collectors;++public class KeycloakDeployment extends OperatorManagedResource {++    public static final Pattern CONFIG_SECRET_PATTERN = Pattern.compile(""^\\$\\{secret:([^:]+):(.+)}$"");++    private final Config config;+    private final Keycloak keycloakCR;+    private final Deployment existingDeployment;+    private final Deployment defaultDeployment;","Nope. ;) It is basically the template, the new deployment if it does not exist already. Desired deployment is basically a merge of existing and default. I'm open to suggestions for better naming.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787563238,2022-01-19T09:55:48Z,operator/src/main/resources/example-keycloak.yml,"@@ -1,6 +1,20 @@-apiVersion: keycloak.io/v2alpha1+apiVersion: keycloak.org/v2alpha1 kind: Keycloak metadata:   name: example-kc spec:   instances: 1+  distConfig:+    KC_DB: postgres+    KC_DB_URL_HOST: postgres-db+    KC_DB_USERNAME: ${secret:keycloak-db-secret:username}","See the comment above please. I wanted to ""hide"" the impl details from users  that we're using env vars currently",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787573924,2022-01-19T10:06:05Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -18,59 +18,139 @@  import javax.inject.Inject; +import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.Secret;+import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.client.KubernetesClient;-import io.javaoperatorsdk.operator.api.reconciler.*;-import io.javaoperatorsdk.operator.api.reconciler.Constants;-import org.jboss.logging.Logger;+import io.fabric8.kubernetes.client.informers.SharedIndexInformer;+import io.javaoperatorsdk.operator.api.reconciler.Context;+import io.javaoperatorsdk.operator.api.reconciler.ControllerConfiguration;+import io.javaoperatorsdk.operator.api.reconciler.DeleteControl;+import io.javaoperatorsdk.operator.api.reconciler.ErrorStatusHandler;+import io.javaoperatorsdk.operator.api.reconciler.EventSourceContext;+import io.javaoperatorsdk.operator.api.reconciler.EventSourceInitializer;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.javaoperatorsdk.operator.api.reconciler.RetryInfo;+import io.javaoperatorsdk.operator.api.reconciler.UpdateControl;+import io.javaoperatorsdk.operator.processing.event.ResourceID;+import io.javaoperatorsdk.operator.processing.event.source.EventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.InformerEventSource;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants;+import org.keycloak.operator.WatchedResourcesStore; import org.keycloak.operator.v2alpha1.crds.Keycloak; import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder; -@ControllerConfiguration(namespaces = Constants.WATCH_CURRENT_NAMESPACE, finalizerName = Constants.NO_FINALIZER)-public class KeycloakController implements Reconciler<Keycloak> {+import java.util.Collections;+import java.util.List;+import java.util.Optional;+import java.util.Set;+import java.util.stream.Collectors; -    @Inject-    Logger logger;+import static io.javaoperatorsdk.operator.api.reconciler.Constants.NO_FINALIZER;+import static io.javaoperatorsdk.operator.api.reconciler.Constants.WATCH_CURRENT_NAMESPACE;++@ControllerConfiguration(namespaces = WATCH_CURRENT_NAMESPACE)+public class KeycloakController implements Reconciler<Keycloak>, EventSourceInitializer<Keycloak>, ErrorStatusHandler<Keycloak> {      @Inject     KubernetesClient client; +    @Inject+    Config config;++    private final WatchedResourcesStore watchedSecrets = new WatchedResourcesStore();++    @Override+    public List<EventSource> prepareEventSources(EventSourceContext<Keycloak> context) {+        SharedIndexInformer<Deployment> deploymentInformer =+                client.apps().deployments().inAnyNamespace()+                        .withLabels(Constants.DEFAULT_LABELS)+                        .runnableInformer(0);++        EventSource deploymentEvent = new InformerEventSource<>(+                deploymentInformer, d -> {+                    List<OwnerReference> ownerReferences = d.getMetadata().getOwnerReferences();+                    if (!ownerReferences.isEmpty()) {+                        return Set.of(new ResourceID(ownerReferences.get(0).getName(), d.getMetadata().getNamespace()));+                    } else {+                        return Collections.emptySet();+                    }+        });++        // TODO optimize this (set labels?) to not watch all namespaces","We could use labels of course. But it'd add additional complexity (to already complex problem ;))  we need to remove those labels once no longer used in any CR etc. Wondering, if the ""Dependent Resources"" in the SDK could help with this in the future, before we add even more complexity. WDYT?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787596329,2022-01-19T10:27:15Z,operator/src/main/java/org/keycloak/operator/OperatorManagedResource.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.OwnerReferenceBuilder;+import io.fabric8.kubernetes.client.CustomResource;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;++import java.util.Collections;+import java.util.HashMap;+import java.util.Map;+import java.util.Optional;++/**+ * Represents a single K8s resource that is managed by this operator (e.g. Deployment, Service, Ingress, etc.)+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public abstract class OperatorManagedResource {+    protected KubernetesClient client;+    protected CustomResource<?, ?> cr;++    public OperatorManagedResource(KubernetesClient client, CustomResource<?, ?> cr) {+        this.client = client;+        this.cr = cr;+    }++    protected abstract HasMetadata getReconciledResource();++    public void createOrUpdateReconciled() {+        HasMetadata resource = getReconciledResource();+        setDefaultLabels(resource);+        setOwnerReferences(resource);++        Log.debugf(""Creating or updating resource: %s"", resource);+        resource = client.resource(resource).createOrReplace();+        Log.debugf(""Successfully created or updated resource: %s"", resource);+    }++    protected void setDefaultLabels(HasMetadata resource) {+        Map<String, String> labels = Optional.ofNullable(resource.getMetadata().getLabels()).orElse(new HashMap<>());+        labels.putAll(Constants.DEFAULT_LABELS);+        resource.getMetadata().setLabels(labels);+    }++    protected void setOwnerReferences(HasMetadata resource) {+        if (!cr.getMetadata().getNamespace().equals(resource.getMetadata().getNamespace())) {",In this case I would `throw` an exception instead of silently ignoring.,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787600704,2022-01-19T10:31:00Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -18,59 +18,139 @@  import javax.inject.Inject; +import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.Secret;+import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.client.KubernetesClient;-import io.javaoperatorsdk.operator.api.reconciler.*;-import io.javaoperatorsdk.operator.api.reconciler.Constants;-import org.jboss.logging.Logger;+import io.fabric8.kubernetes.client.informers.SharedIndexInformer;+import io.javaoperatorsdk.operator.api.reconciler.Context;+import io.javaoperatorsdk.operator.api.reconciler.ControllerConfiguration;+import io.javaoperatorsdk.operator.api.reconciler.DeleteControl;+import io.javaoperatorsdk.operator.api.reconciler.ErrorStatusHandler;+import io.javaoperatorsdk.operator.api.reconciler.EventSourceContext;+import io.javaoperatorsdk.operator.api.reconciler.EventSourceInitializer;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.javaoperatorsdk.operator.api.reconciler.RetryInfo;+import io.javaoperatorsdk.operator.api.reconciler.UpdateControl;+import io.javaoperatorsdk.operator.processing.event.ResourceID;+import io.javaoperatorsdk.operator.processing.event.source.EventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.InformerEventSource;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants;+import org.keycloak.operator.WatchedResourcesStore; import org.keycloak.operator.v2alpha1.crds.Keycloak; import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder; -@ControllerConfiguration(namespaces = Constants.WATCH_CURRENT_NAMESPACE, finalizerName = Constants.NO_FINALIZER)-public class KeycloakController implements Reconciler<Keycloak> {+import java.util.Collections;+import java.util.List;+import java.util.Optional;+import java.util.Set;+import java.util.stream.Collectors; -    @Inject-    Logger logger;+import static io.javaoperatorsdk.operator.api.reconciler.Constants.NO_FINALIZER;+import static io.javaoperatorsdk.operator.api.reconciler.Constants.WATCH_CURRENT_NAMESPACE;++@ControllerConfiguration(namespaces = WATCH_CURRENT_NAMESPACE)+public class KeycloakController implements Reconciler<Keycloak>, EventSourceInitializer<Keycloak>, ErrorStatusHandler<Keycloak> {      @Inject     KubernetesClient client; +    @Inject+    Config config;++    private final WatchedResourcesStore watchedSecrets = new WatchedResourcesStore();++    @Override+    public List<EventSource> prepareEventSources(EventSourceContext<Keycloak> context) {+        SharedIndexInformer<Deployment> deploymentInformer =+                client.apps().deployments().inAnyNamespace()+                        .withLabels(Constants.DEFAULT_LABELS)+                        .runnableInformer(0);++        EventSource deploymentEvent = new InformerEventSource<>(+                deploymentInformer, d -> {+                    List<OwnerReference> ownerReferences = d.getMetadata().getOwnerReferences();+                    if (!ownerReferences.isEmpty()) {+                        return Set.of(new ResourceID(ownerReferences.get(0).getName(), d.getMetadata().getNamespace()));+                    } else {+                        return Collections.emptySet();+                    }+        });++        // TODO optimize this (set labels?) to not watch all namespaces","> we need to remove those labels once no longer used in any CR etc.why?I think we can rely on one or more [""Recommended Labels""](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/)",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787622564,2022-01-19T10:50:06Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -16,82 +16,162 @@  */ package org.keycloak.operator.v2alpha1; +import io.fabric8.kubernetes.api.model.Container;+import io.fabric8.kubernetes.api.model.EnvVar;+import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.fabric8.kubernetes.api.model.EnvVarSourceBuilder;+import io.fabric8.kubernetes.api.model.HasMetadata; import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.api.model.apps.DeploymentBuilder; import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource; import org.keycloak.operator.v2alpha1.crds.Keycloak;-import org.keycloak.operator.v2alpha1.crds.KeycloakSpec;-import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;  import java.net.URL;+import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Optional;+import java.util.Set;+import java.util.regex.Matcher;+import java.util.regex.Pattern;+import java.util.stream.Collectors;++public class KeycloakDeployment extends OperatorManagedResource {++    public static final Pattern CONFIG_SECRET_PATTERN = Pattern.compile(""^\\$\\{secret:([^:]+):(.+)}$"");++    private final Config config;+    private final Keycloak keycloakCR;+    private final Deployment existingDeployment;+    private final Deployment defaultDeployment;+    private final Set<String> configSecretsNames;++    public KeycloakDeployment(KubernetesClient client, Config config, Keycloak keycloakCR, Deployment existingDeployment) {+        super(client, keycloakCR);+        this.config = config;+        this.keycloakCR = keycloakCR;++        if (existingDeployment != null) {+            Log.info(""Existing Deployment provided by controller"");+            this.existingDeployment = existingDeployment;+        }+        else {+            Log.info(""Trying to fetch existing Deployment from the API"");+            this.existingDeployment = fetchExistingDeployment();+        }++        // process the CR++        URL url = this.getClass().getResource(""/base-keycloak-deployment.yaml"");+        defaultDeployment = client.apps().deployments().load(url).get(); -import static org.keycloak.operator.v2alpha1.crds.KeycloakStatus.State.*;+        defaultDeployment.getMetadata().setName(getName());+        defaultDeployment.getMetadata().setNamespace(getNamespace());+        defaultDeployment.getSpec().getSelector().setMatchLabels(Constants.DEFAULT_LABELS);+        defaultDeployment.getSpec().setReplicas(keycloakCR.getSpec().getInstances());+        defaultDeployment.getSpec().getTemplate().getMetadata().setLabels(Constants.DEFAULT_LABELS); -public class KeycloakDeployment {+        Container container = defaultDeployment.getSpec().getTemplate().getSpec().getContainers().get(0);+        container.setImage(Optional.ofNullable(keycloakCR.getSpec().getImage()).orElse(config.operand().image())); -    KubernetesClient client = null;+        var distConfig = new HashMap<>(Constants.DEFAULT_DIST_CONFIG);+        if (keycloakCR.getSpec().getDistConfig() != null) {+            distConfig.putAll(keycloakCR.getSpec().getDistConfig());+        } -    KeycloakDeployment(KubernetesClient client) {-        this.client = client;+        Set<String> configSecretsNames = new HashSet<>();+        List<EnvVar> configEnvVars = distConfig.entrySet().stream()+                .map(e -> {+                    EnvVarBuilder builder = new EnvVarBuilder().withName(e.getKey());+                    Matcher matcher = CONFIG_SECRET_PATTERN.matcher(e.getValue());","I was thinking about this indirection and I do believe that it brings a number of downsides:- not standard- it works as a re-name that can be misleading- the re-naming makes it harder to debug issues- it's not operator business to mangle Keycloak distribution properties- custom implementation of an already existing feature- no proper feedback for the user in case of misconfiguration- subject to subtle and nasty bugs (e.g. add a space `${ source:`)- additional logic to be handledI do see a single interesting use-case that, potentially(not with the current implementation), this feature can bring on the table that is: - fetch env variable values from external Secrets (such as the credentials of the DB from the Secret created by the Crunchy operator)  to get there we would need to add support for namespaces and Json parsing. All in all, this PR is intended to be a `Baseline` for the deployment, I believe we agree that this is already a `feature`, so, my suggestion is to leave the passwords in clear text for now, remove this logic, and open a issue to re-visit/re-iterate/better discuss this feature in a separate PR.",
5443269,csviri,https://api.github.com/repos/keycloak/keycloak/pulls/9628,787686099,2022-01-19T12:15:19Z,operator/src/main/java/org/keycloak/operator/WatchedResourcesStore.java,"@@ -0,0 +1,148 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator;++import java.util.Collections;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.stream.Collectors;++/**+ * Stores a set of resource names that are related to (but not owned by) some CR. To be used by a controller for watching+ * those resources. Also stores a {@code modified} flag for each resource. Motivation for this in-memory store is to avoid+ * touching (e.g. adding labels) the resources that are not owned by the operator and not to store state in K8s.+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public class WatchedResourcesStore {","Hi, yes informers are caching the resources, you generally have everything if not managing non K8S resources:https://github.com/java-operator-sdk/java-operator-sdk/blob/e5c3c713d7431c246f5f4775594dbd45324447eb/sample-operators/tomcat-operator/src/main/java/io/javaoperatorsdk/operator/sample/TomcatReconciler.java#L61see this, but if you just create a reference in the reconciler to the informer event source, you can access it's api directly, it has bunch of methods to access cache and cached objects",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9625,787752486,2022-01-19T13:38:49Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -21,15 +21,15 @@ import io.fabric8.kubernetes.client.KubernetesClient; import io.javaoperatorsdk.operator.api.reconciler.*; import io.javaoperatorsdk.operator.api.reconciler.Constants;+import io.javaoperatorsdk.operator.junit.KubernetesClientAware; import org.jboss.logging.Logger; import org.keycloak.operator.v2alpha1.crds.Keycloak; import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;  @ControllerConfiguration(namespaces = Constants.WATCH_CURRENT_NAMESPACE, finalizerName = Constants.NO_FINALIZER)-public class KeycloakController implements Reconciler<Keycloak> {+public class KeycloakController implements Reconciler<Keycloak>, KubernetesClientAware { -    @Inject-    Logger logger;+    private static final Logger logger = Logger.getLogger(KeycloakController.class);",Is there an issue with Quarkus CDI when running tests? My Deployment e.g. [consumes even config through CDI](https://github.com/keycloak/keycloak/blob/8b5af1a6ac7ff898e2029365e5e6a5a45da6e041/operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java#L61-L62). There must be a way to test it.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9625,787768158,2022-01-19T13:55:45Z,operator/src/test/java/org/keycloak/operator/OperatorBatteryTests.java,"@@ -0,0 +1,65 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.Node;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.dsl.Resource;+import org.awaitility.Awaitility;+import org.awaitility.core.ConditionTimeoutException;+import org.jboss.logging.Logger;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.io.File;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.InputStream;+import java.time.Duration;+import java.util.List;++import static org.assertj.core.api.Assertions.assertThat;++public class OperatorBatteryTests {","@andreaTP ""a little **wired**""? :)+1 the name is a bit weird but I think we should not need this class at all. I don't like the approach of having different test classes for different tests setups relying on a battery tests. Let's discuss offline.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9415,787876326,2022-01-19T15:37:32Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/role/JpaRoleModelCriteriaBuilder.java,"@@ -82,11 +86,29 @@ public JpaRoleModelCriteriaBuilder compare(SearchableModelField<? super RoleMode                 }             case IN:                 if (modelField.equals(SearchableFields.ID)) {-                    validateValue(value, modelField, op, String.class);+                    if (value == null || value.length == 0) throw new CriterionNotSupportedException(modelField, op);++                    final Collection collectionValues;+                    if (value.length > 1) { // array+                        collectionValues = Arrays.asList(value);+                    } else if (value[0] instanceof Collection) {+                        collectionValues = (Collection) value[0];+                    } else if (value[0] instanceof Stream) {+                        Stream<Object> str = ((Stream) value[0]);+                        collectionValues = str.collect(Collectors.toCollection(LinkedList::new));+                    } else {+                        throw new CriterionNotSupportedException(modelField, op);+                    }                      return new JpaRoleModelCriteriaBuilder((cb, root) -> {                         In<String> in = cb.in(root.get(""id""));-                        ((Stream<String>) value[0]).forEach(id -> in.value(id));+                        for (Object id : collectionValues) {+                            if (id instanceof String) {+                                in.value((String) id);+                            } else {+                                throw new CriterionNotSupportedException(modelField, op);+                            }","The exception would be if there in `(String) id`, an `id` is a non-String object: then there would have been class cast exception. I am thus lost here.I shared some updated comment inline.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9635,787918261,2022-01-19T16:18:47Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java,"@@ -139,15 +139,19 @@ public void unregisterNode(String nodeHost) {     public ClientModel addClient(RealmModel realm, String id, String clientId) {         LOG.tracef(""addClient(%s, %s, %s)%s"", realm, id, clientId, getShortStackTrace()); +        if (id != null && tx.read(id) != null) {+            throw new ModelDuplicateException(""Client with same id exists: "" + id);+        }+        if (clientId != null && getClientByClientId(realm, clientId) != null) {+            throw new ModelDuplicateException(""Client with same clientId in realm "" + realm.getName() + "" exists: "" + clientId);+        }+         MapClientEntity entity = new MapClientEntityImpl();         entity.setId(id);         entity.setRealmId(realm.getId());         entity.setClientId(clientId);         entity.setEnabled(true);         entity.setStandardFlowEnabled(true);-        if (id != null && tx.read(id) != null) {-            throw new ModelDuplicateException(""Client exists: "" + id);-        }         entity = tx.create(entity);         if (clientId == null) {",Probably out of scope. It could happen that `entity.clientId` could remain `null` in case both method arguments `id` and `clientId` is `null`.I believe this check was added here based on  https://github.com/keycloak/keycloak/blob/main/model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java#L651-L653 where `id` cannot be `null`.This brings the question whether we should also check the `clientId` in `JpaClientMapKeycloakTransaction.create`.,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,787920279,2022-01-19T16:20:52Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryOperators.java,"@@ -82,17 +84,29 @@         String combine(String fieldName, Object[] values, Map<String, Object> parameters);     } -    private static String exists(String modelField, Object[] values, Map<String, Object> parameters) {-        String field = C + ""."" + modelField;+    private static String exists(String modelFieldName, Object[] values, Map<String, Object> parameters) {+        String field = C + ""."" + modelFieldName;         return field + "" IS NOT NULL AND "" + field + "" IS NOT EMPTY"";     } -    private static String notExists(String modelField, Object[] values, Map<String, Object> parameters) {-        String field = C + ""."" + modelField;+    private static String notExists(String modelFieldName, Object[] values, Map<String, Object> parameters) {+        String field = C + ""."" + modelFieldName;         return field + "" IS NULL OR "" + field + "" IS EMPTY"";     } -    private static String in(String modelField, Object[] values, Map<String, Object> parameters) {+    private static String iLike(String modelFieldName, Object[] values, Map<String, Object> parameters) {+        String sanitizedValue = (String) IckleQueryMapModelCriteriaBuilder.sanitize(values[0]);+        return singleValueOperator(ModelCriteriaBuilder.Operator.ILIKE)",This smells with a possibility to introduce an infinite loop in the future.```suggestion        return singleValueOperator(ModelCriteriaBuilder.Operator.LIKE)```,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/9569,787946251,2022-01-19T16:48:06Z,services/src/main/java/org/keycloak/protocol/oidc/rar/ClientScopeAuthorizationRequestParserProviderFactory.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.protocol.oidc.rar;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.protocol.oidc.rar.parsers.ClientScopeAuthorizationRequestParser;++/**+ * @author <a href=""mailto:dgozalob@redhat.com"">Daniel Gozalo</a>+ */+public class ClientScopeAuthorizationRequestParserProviderFactory implements AuthorizationRequestParserProviderFactory {",Minor: Maybe this class should be in the package with `ClientScopeAuthorizationRequestParser` ? Not sure why it is in the parent package where are also SPI classes?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/9569,787952424,2022-01-19T16:54:46Z,server-spi/src/main/java/org/keycloak/rar/AuthorizationDetailsJSONRepresentation.java,"@@ -0,0 +1,154 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.rar;++import com.fasterxml.jackson.annotation.JsonAnyGetter;+import com.fasterxml.jackson.annotation.JsonAnySetter;+import com.fasterxml.jackson.annotation.JsonProperty;++import java.io.Serializable;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;++/**+ * The JSON representation of a Rich Authorization Request's ""authorization_details"" object.+ *+ * @see {@link <a href=""https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar#section-2"">Request parameter ""authorization_details""</a>}+ *+ * @author <a href=""mailto:dgozalob@redhat.com"">Daniel Gozalo</a>+ */+public class AuthorizationDetailsJSONRepresentation implements Serializable {","Minor: Maybe we can move this class to the ""core"" package together with classes like for example `AccessToken` ? There is a chance that this class might be used by applications/adapters and hence it may fit better into that place IMO.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9414,788527167,2022-01-20T08:53:48Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/UserSessionProviderOfflineModelTest.java,"@@ -297,6 +304,69 @@ public void testLoadUserSessionsWithNotDeletedOfflineClientSessions() {         }     } +    @Test+    public void testOfflineSessionLazyLoading() throws InterruptedException {+        AtomicReference<List<UserSessionModel>> offlineUserSessions = new AtomicReference<>(new LinkedList<>());+        AtomicReference<List<AuthenticatedClientSessionModel>> offlineClientSessions = new AtomicReference<>(new LinkedList<>());+        createOfflineSessions(""user1"", 10, offlineUserSessions, offlineClientSessions);++        reinitializeKeycloakSessionFactory();++        AtomicBoolean result = new AtomicBoolean(true);+        CountDownLatch latch = new CountDownLatch(4);+        inIndependentFactories(4, 300, () -> {+            withRealm(realmId, (session, realm) -> {+                final UserModel user = session.users().getUserByUsername(realm, ""user1"");+                result.set(result.get() & assertOfflineSession(offlineUserSessions, session.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())));+                return null;+            });++            latch.countDown();++            awaitLatch(latch);+        });++        Assert.assertTrue(result.get());+    }++    @Test+    public void testOfflineSessionLazyLoadingPropagationBetweenNodes() throws InterruptedException {+        AtomicReference<List<UserSessionModel>> offlineUserSessions = new AtomicReference<>(new LinkedList<>());+        AtomicReference<List<AuthenticatedClientSessionModel>> offlineClientSessions = new AtomicReference<>(new LinkedList<>());+        AtomicBoolean result = new AtomicBoolean(true);+        AtomicInteger index = new AtomicInteger();+        CountDownLatch latch = new CountDownLatch(4);+        CountDownLatch afterFirstNodeLatch = new CountDownLatch(1);++        inIndependentFactories(4, 300, () -> {+            if (index.incrementAndGet() == 1) {+                createOfflineSessions(""user1"", 10, offlineUserSessions, offlineClientSessions);++                // we need to force persistence of the offline sessions by the node restart",I don't follow this. Why is this restart necessary? If I look at: https://github.com/keycloak/keycloak/blob/61fbb2fb2eaa14006b761392d2e1cdd924ee62ea/model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java#L725-L737it seems offline sessions are persisted when created. I am probably just missing something.,
48915630,dgozalo,https://api.github.com/repos/keycloak/keycloak/pulls/9569,788605503,2022-01-20T10:09:14Z,server-spi/src/main/java/org/keycloak/rar/AuthorizationDetailsJSONRepresentation.java,"@@ -0,0 +1,154 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.rar;++import com.fasterxml.jackson.annotation.JsonAnyGetter;+import com.fasterxml.jackson.annotation.JsonAnySetter;+import com.fasterxml.jackson.annotation.JsonProperty;++import java.io.Serializable;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;++/**+ * The JSON representation of a Rich Authorization Request's ""authorization_details"" object.+ *+ * @see {@link <a href=""https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar#section-2"">Request parameter ""authorization_details""</a>}+ *+ * @author <a href=""mailto:dgozalob@redhat.com"">Daniel Gozalo</a>+ */+public class AuthorizationDetailsJSONRepresentation implements Serializable {","Good point. I wasn't sure about the best place to put some of these classes. As you said, this may be used by applications and adapters to create the RAR representation to be sent to the server, so I'm moving it.",
48915630,dgozalo,https://api.github.com/repos/keycloak/keycloak/pulls/9569,788606757,2022-01-20T10:10:23Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/request/AuthorizationEndpointRequestParserProcessor.java,"@@ -96,6 +99,18 @@ public static AuthorizationEndpointRequest parseRequest(EventBuilder event, Keyc                 }             } +            if(Profile.isFeatureEnabled(Profile.Feature.DYNAMIC_SCOPES)) {","Apparently I didn't run the formatter on existing files to avoid introducing too many changes. Interestinly, even with the Eclipse Formatter using Wildfly's profile, the changes to most files are quite big.Anyway, fixed those formatting issues.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9414,788703219,2022-01-20T12:11:30Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/PersistentUserSessionEntity.java,"@@ -47,14 +47,14 @@                 "" AND sess.realmId = :realmId AND sess.userId = :userId ORDER BY sess.userSessionId""),         @NamedQuery(name=""findUserSessionsByClientId"", query=""SELECT sess FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" +                 "" ON sess.userSessionId = clientSess.userSessionId AND clientSess.clientId = :clientId WHERE sess.offline = :offline "" +-                "" AND sess.userSessionId = clientSess.userSessionId AND sess.realmId = :realmId ORDER BY sess.userSessionId""),-        @NamedQuery(name=""findUserSessionsCountsByClientId"", query=""SELECT clientSess.clientId, count(clientSess) "" +-                "" FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" +-                "" ON sess.userSessionId = clientSess.userSessionId "" +-                // find all available offline user-session for all clients in a realm-                "" WHERE sess.offline = :offline "" +-                "" AND sess.userSessionId = clientSess.userSessionId AND sess.realmId = :realmId "" +-                "" GROUP BY clientSess.clientId"")+                "" AND sess.realmId = :realmId ORDER BY sess.userSessionId""),+        @NamedQuery(name=""findUserSessionsByExternalClientId"", query=""SELECT sess FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" ++                "" ON sess.userSessionId = clientSess.userSessionId AND clientSess.clientStorageProvider = :clientStorageProvider AND clientSess.externalClientId = :externalClientId WHERE sess.offline = :offline "" ++                "" AND sess.realmId = :realmId ORDER BY sess.userSessionId""),+        @NamedQuery(name=""findClientSessionsClientIds"", query=""SELECT clientSess.clientId, clientSess.externalClientId, clientSess.clientStorageProvider"" ++                "" FROM PersistentClientSessionEntity clientSess INNER JOIN PersistentUserSessionEntity sess ON clientSess.userSessionId = sess.userSessionId "" ++                "" WHERE sess.offline = :offline AND sess.realmId = :realmId "" ++                "" GROUP BY clientSess.clientId, clientSess.externalClientId, clientSess.clientStorageProvider"")","I am a little bit confused about this `GROUP BY` here. The purpose of this query is eventually to provide mapping client -> number of sessions. Isn't this `GROUP BY` removing sessions from the result? For example, if we have the following entries in the database:```clientId    | externalClientId | clientStorageProvider | usernamemyClient    | null             | null                  | user1myClient    | null             | null                  | user2```These entries in the database should result in mapping:`myClient -> 2`However, if I am not mistaken the `GROUP BY` statement will remove one of the results because it has the same `clientSess.clientId, clientSess.externalClientId, clientSess.clientStorageProvider` value. Am I missing something?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9414,788709706,2022-01-20T12:20:17Z,model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java,"@@ -341,28 +343,39 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool      protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, UserSessionPredicate predicate, boolean offline) { -        if (offline && loadOfflineSessionsStatsFromDatabase) {+        if (offline && loadOfflineSessionsFromDatabase) {              // fetch the offline user-sessions from the persistence provider             UserSessionPersisterProvider persister = session.getProvider(UserSessionPersisterProvider.class); -            UserModel user = session.users().getUserById(realm, predicate.getUserId());-            if (user != null) {-                return persister.loadUserSessionsStream(realm, user, offline, 0, null);+            if (predicate.getUserId() != null) {+                UserModel user = session.users().getUserById(realm, predicate.getUserId());+                if (user != null) {+                    return persister.loadUserSessionsStream(realm, user, true, 0, null);+                }+            }++            if (predicate.getBrokerUserId() != null) {+                String[] idpAliasSessionId = predicate.getBrokerUserId().split(""\\."");++                Map<String, String> attributes = new HashMap<>();+                attributes.put(UserModel.IDP_ALIAS, idpAliasSessionId[0]);+                attributes.put(UserModel.IDP_USER_ID, idpAliasSessionId[1]);++                UserProvider userProvider = session.getProvider(UserProvider.class);+                UserModel userModel = userProvider.searchForUserStream(realm, attributes, 0, null).findFirst().orElse(null);+                return userModel != null ?+                        persister.loadUserSessionsStream(realm, userModel, true, 0, null) :+                        Stream.empty();             }              if (predicate.getBrokerSessionId() != null) {                 // TODO add support for offline user-session lookup by brokerSessionId                 // currently it is not possible to access the brokerSessionId in offline user-session in a database agnostic way-                throw new ModelException(""Dynamic database lookup for offline user-sessions by brokerSessionId is currently only supported for preloaded sessions."");+                throw new ModelException(""Dynamic database lookup for offline user-sessions by broker session ID is currently only supported for preloaded sessions. "" +",Is it possible that this exception is thrown or we are sure that all occurrences of searching by `brokerSessionId` were replaced by some other search?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/9161,788716478,2022-01-20T12:29:23Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryOperators.java,"@@ -82,17 +84,29 @@         String combine(String fieldName, Object[] values, Map<String, Object> parameters);     } -    private static String exists(String modelField, Object[] values, Map<String, Object> parameters) {-        String field = C + ""."" + modelField;+    private static String exists(String modelFieldName, Object[] values, Map<String, Object> parameters) {+        String field = C + ""."" + modelFieldName;         return field + "" IS NOT NULL AND "" + field + "" IS NOT EMPTY"";     } -    private static String notExists(String modelField, Object[] values, Map<String, Object> parameters) {-        String field = C + ""."" + modelField;+    private static String notExists(String modelFieldName, Object[] values, Map<String, Object> parameters) {+        String field = C + ""."" + modelFieldName;         return field + "" IS NULL OR "" + field + "" IS EMPTY"";     } -    private static String in(String modelField, Object[] values, Map<String, Object> parameters) {+    private static String iLike(String modelFieldName, Object[] values, Map<String, Object> parameters) {+        String sanitizedValue = (String) IckleQueryMapModelCriteriaBuilder.sanitize(values[0]);+        return singleValueOperator(ModelCriteriaBuilder.Operator.ILIKE)","You are correct. Currently, this works like this. What this method does is that it delegates the creation of the resulting query to another operator (LIKE) with a different parameter - lowercase. However, it is now using `ILIKE`, which works because `ILIKE` is mapped to the same operator string. I just find it a little bit confusing that `ILIKE` is used again. This is just a nitpick so feel free to ignore it.  ",
13701445,dteleguin,https://api.github.com/repos/keycloak/keycloak/pulls/8895,788824709,2022-01-20T14:36:09Z,server-spi-private/src/main/java/org/keycloak/crypto/SignatureProvider.java,"@@ -17,6 +17,7 @@ package org.keycloak.crypto;  import org.keycloak.common.VerificationException;+import org.keycloak.jose.jwk.JWK; import org.keycloak.provider.Provider;  public interface SignatureProvider extends Provider {","When looking for an SPI in Keycloak that would allow to validate RSA/EC JWSs in a unified manner, I've ended up with these:- `org.keycloak.crypto.ClientSignatureVerifierProvider`- `org.keycloak.jose.jws.crypto.*Provider`- `org.keycloak.crypto.SignatureProvider``ClientSignatureVerifierProvider` and friends would work well, but the key point about this SPI is that it recognizes only the keys that have been registered to the clients beforehand (hence the ""Client"" bit in the class names). OTOH, DPoP (whilst being initiated from the client side) uses ephemeral keys generated on the fly that Keycloak has no knowledge of. In theory, we could add methods taking just JWS and public key, but IMO this will result even in more changes to the whole hierarchy.`org.keycloak.jose.jws.crypto.*Provider` classes are used in `TokenVerifier::verifySignature` in case no custom verifier has been supplied. I'm not sure if this code path is used in Keycloak at all, since e.g. there is no EC provider implementation in `org.keycloak.jose.jws.crypto`. In theory, we could add one, which will be yet third signature verification SPI alongside the other two.With the above, I've considered `SignatureProvider` the most appropriate SPI. Yet, it required addition of `SignatureProvider::verifier(JWK key)` which had repercussions across the hierarchy.I'm open to suggestions; which of the above SPIs seem most relevant to you?",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/9698,789091368,2022-01-20T19:35:09Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/KeycloakProcessor.java,"@@ -421,7 +422,14 @@ void configureDevMode(BuildProducer<HotDeploymentWatchedFileBuildItem> hotFiles)             Map<String, ProviderFactory> preConfiguredProviders) {         Config.init(new MicroProfileConfigProvider());         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();-        ProviderManager pm = new ProviderManager(KeycloakDeploymentInfo.create().services(), classLoader);++        KeycloakDeploymentInfo keycloakDeploymentInfo = KeycloakDeploymentInfo.create()+                .name(""classpath"")","I needed to provide a name for the deployment unit here, using ""classpath"" since we only scan things from classpath.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9641,789476429,2022-01-21T09:07:37Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/KeycloakProcessor.java,"@@ -62,6 +60,7 @@ import io.quarkus.deployment.builditem.LaunchModeBuildItem; import io.quarkus.deployment.builditem.RuntimeConfigSetupCompleteBuildItem; import io.quarkus.deployment.builditem.StaticInitConfigSourceProviderBuildItem;+import io.quarkus.dev.console.QuarkusConsole;","unused, pls remove.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,789578138,2022-01-21T11:24:02Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -249,7 +259,32 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta      private credentialRowCells(credential: UserCredential, type: string): React.ReactNode[] {         const credRowCells: React.ReactNode[] = [];-        credRowCells.push(<DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>{credential.userLabel}</DataListCell>);+        const credData: CredData = JSON.parse(credential.credentialData!);+        credRowCells.push(+            <DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>+                {credential.userLabel}+                {credData.remainingCodes && credData.totalCodes &&+                    <div>{credData.totalCodes - credData.remainingCodes}/{credData.totalCodes} recovery codes used</div>+                }+                {credData.remainingCodes && credData.remainingCodes < 4 &&+                    <>+                        <br />+                        <div className=""pf-c-alert pf-m-warning pf-m-inline"" aria-label=""Success alert"">+                            <div className=""pf-c-alert__icon"">+                                <i className=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+                            </div>+                            <h4 className=""pf-c-alert__title"">","Yes, it can be a bit tricky to do it properly and might require some small changes in the SPI/infrastructure itself.One possible path I am thinking about is along the way of:- Introduce method `CredentialProvider.getCredentialMetadata` . This will have likely credential as one of the arguments and `CredentialTypeMetadata` as another argument. I suppose this method will be called from the method `AccountCredentialResource.credentialTypes` and likely will be called for each credential of the user- Credential metadata can have fields like the credential itself, but also some others like:-  `infoMessage` (This can be `credential.userLabel` by default, but for recovery codes, this may be some different text like ""Remaining codes: 8"")- `warningMessage` (This can be null by default, but it can be the message for recovery codes displayed here in case there is small amount of remaining codes)Both `infoMessage` and `warningMessage` likely should have support for localization including parametes, so theme can translate them into proper localized messageI can imagine something like this:```class CredentialMetadata {    CredentialModel credential;    LocalizedMessage infoMessage;    LocalizedMessage warningMessage;    class LocalizedMessage {        String key;        Object parameters; // Parameters of localized message. Something similar to class `FormMessage` from `keycloak-services` module    }}```Hopefully these metadata can be consumed from the account console credential screen.WDYT?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9604,789614793,2022-01-21T12:23:02Z,docs/guides/src/main/server/features.adoc,"@@ -0,0 +1,78 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+title=""Enabling and disabling features""+summary=""Understand how to configure Keycloak to use optional features"">++Keycloak has packed some functionality in features, some of them not enabled by default. These features include features that are in tech preview or deprecated features. In addition there are some features that are enabled by default, but can be disabled if you don't need them for your specific usage scenario.++== Enabling features++Some supported features, and all preview features, are not enabled by default. To enable a feature use:++<@kc.build parameters=""--features=<name>[,<name>]""/>++For example to enable `docker` and `token-exchange` use:++<@kc.build parameters=""--features=docker,token-exchange""/>++All preview features can be enabled with the special name `preview`:++<@kc.build parameters=""--features=preview""/>++== Disabling features++To disable a feature that is enabled by default use:++<@kc.build parameters=""--features-disabled=<name>[,<name>]""/>++For example to disable `impersonation` use:++<@kc.build parameters=""--features-disabled=impersonation""/>++It is also possible to disable all default features with:++<@kc.build parameters=""--features-disabled=default""/>++This can be used in combination with `features` to explicitly set what features should be available.","so ""features"" list takes precedence over ""disabled-features"" list. Should we add a sentence around this? e.g. ""When you have put a feture in the features list, and also in the features-disabled list, this feature will get enabled""? ",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9641,789670588,2022-01-21T13:47:26Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/BuildCommandDistTest.java,"@@ -53,4 +54,11 @@ void failIfDevProfile(LaunchResult result) {                 () -> ""The Error Output:\n"" + result.getErrorOutput() + ""doesn't contains the expected string."");         assertEquals(4, result.getErrorStream().size());     }++    @Test+    @Launch({ ""build"", ""--db=postgres"", ""--db-username=myuser"", ""--db-password=mypassword"", ""--http-enabled=true"" })+    void testFailRuntimeOptions(LaunchResult result) {+        CLIResult cliResult = (CLIResult) result;+        cliResult.assertError(""Unknown options: '--db-username=myuser', '--db-password=mypassword', '--http-enabled=true'"");","You are right. Created https://github.com/keycloak/keycloak/issues/9720 - not sure we can/should really do something about mistyped keys, though, at least not without exceptionally adding complexity to check for blurriness in keys ;)",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9551,789676052,2022-01-21T13:54:32Z,operator/overlays/default-namespace/kustomization.yaml,"@@ -0,0 +1,7 @@+apiVersion: kustomize.config.k8s.io/v1beta1+kind: Kustomization++bases:",`bases` field is [deprecated](https://kubernetes-sigs.github.io/kustomize/blog/2019/06/18/v2.1.0/#field-changes--deprecations).,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9700,789699790,2022-01-21T14:24:37Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/VaultPropertyMappers.java,"@@ -8,26 +8,45 @@ private VaultPropertyMappers() {     public static PropertyMapper[] getVaultPropertyMappers() {         return new PropertyMapper[] {                 builder()-                        .from(""vault-file-path"")-                        .to(""kc.spi-vault-files-plaintext-dir"")-                        .description(""If set, secrets can be obtained by reading the content of files within the given path."")+                        .from(""vault"")+                        .description(""Enables a vault provider."")+                        .expectedValues(""file"", ""hashicorp"")+                        .paramLabel(""provider"")+                        .build(),+                builder(false)+                        .from(""vault-dir"")+                        .to(""kc.spi-vault-file-dir"")+                        .description(""If set, secrets can be obtained by reading the content of files within the given directory."")                         .paramLabel(""dir"")                         .build(),                 builder()-                        .from(""vault-hashicorp-"")+                        .from(""vault-"")                         .to(""quarkus.vault."")-                        .description(""If set, secrets can be obtained from Hashicorp Vault."")+                        .description(""Maps any vault option to their corresponding properties in quarkus-vault extension."")+                        .hidden(true)                         .build(),                 builder()-                        .from(""vault-hashicorp-paths"")+                        .from(""vault-url"")+                        .to(""quarkus.vault.url"")+                        .description(""The vault server url."")+                        .paramLabel(""paths"")+                        .hidden(true)+                        .build(),+                builder(false)+                        .from(""vault-kv-paths"")                         .to(""kc.spi-vault-hashicorp-paths"")-                        .description(""A set of one or more paths that should be used when looking up secrets."")+                        .description(""A set of one or more key/value paths that should be used when looking up secrets."")                         .paramLabel(""paths"")+                        .hidden(true)                         .build()         };     }      private static PropertyMapper.Builder builder() {-        return PropertyMapper.builder(ConfigCategory.VAULT).isBuildTimeProperty(true);+        return builder(true);+    }++    private static PropertyMapper.Builder builder(boolean buildTime) {+        return PropertyMapper.builder(ConfigCategory.VAULT).isBuildTimeProperty(buildTime);","hum, can't we do it the same way as everywhere else in the mappers, by just adding this to the property? just a slight bit more readable imo, i can see if the property is buildTime or not at first sight, so not really hard on this, though. See e.g. https://github.com/keycloak/keycloak/blob/438fc2865f019cebaa1e1fea762a1f6c77038b7b/quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/HttpPropertyMappers.java#L36-L42 - no need to scroll to see what that ""true"" or ""false"" in the builder call actually means.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9628,789759192,2022-01-21T15:33:50Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -16,82 +16,162 @@  */ package org.keycloak.operator.v2alpha1; +import io.fabric8.kubernetes.api.model.Container;+import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.fabric8.kubernetes.api.model.HasMetadata; import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.api.model.apps.DeploymentBuilder; import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource; import org.keycloak.operator.v2alpha1.crds.Keycloak;-import org.keycloak.operator.v2alpha1.crds.KeycloakSpec;-import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;  import java.net.URL;+import java.util.HashMap;+import java.util.Optional;+import java.util.stream.Collectors; -import static org.keycloak.operator.v2alpha1.crds.KeycloakStatus.State.*;+public class KeycloakDeployment extends OperatorManagedResource { -public class KeycloakDeployment {+//    public static final Pattern CONFIG_SECRET_PATTERN = Pattern.compile(""^\\$\\{secret:([^:]+):(.+)}$""); -    KubernetesClient client = null;+    private final Config config;+    private final Keycloak keycloakCR;+    private final Deployment existingDeployment;+    private final Deployment baseDeployment; -    KeycloakDeployment(KubernetesClient client) {-        this.client = client;+    public KeycloakDeployment(KubernetesClient client, Config config, Keycloak keycloakCR, Deployment existingDeployment) {+        super(client, keycloakCR);+        this.config = config;+        this.keycloakCR = keycloakCR;++        if (existingDeployment != null) {+            Log.info(""Existing Deployment provided by controller"");+            this.existingDeployment = existingDeployment;+        }+        else {+            Log.info(""Trying to fetch existing Deployment from the API"");+            this.existingDeployment = fetchExistingDeployment();+        }++        baseDeployment = createBaseDeployment();     } -    private Deployment baseDeployment;+    @Override+    protected HasMetadata getReconciledResource() {+        Deployment defaultDeployment = new DeploymentBuilder(this.baseDeployment).build(); // clone+        Deployment reconciledDeployment;+        if (existingDeployment == null) {+            Log.info(""No existing Deployment found, using the default"");+            reconciledDeployment = defaultDeployment;+        }+        else {+            Log.info(""Existing Deployment found, updating specs"");+            reconciledDeployment = existingDeployment;+            // don't override metadata, just specs+            reconciledDeployment.setSpec(defaultDeployment.getSpec());+        }++        return reconciledDeployment;+    } -    public Deployment getKeycloakDeployment(Keycloak keycloak) {-        // TODO this should be done through an informer to leverage caches-        // WORKAROUND for: https://github.com/java-operator-sdk/java-operator-sdk/issues/781+    private Deployment fetchExistingDeployment() {         return client                 .apps()                 .deployments()-                .inNamespace(keycloak.getMetadata().getNamespace())-                .list()-                .getItems()-                .stream()-                .filter((d) -> d.getMetadata().getName().equals(org.keycloak.operator.Constants.NAME))-                .findFirst()-                .orElse(null);-//                .withName(Constants.NAME)-//                .get();+                .inNamespace(getNamespace())+                .withName(getName())+                .get();     } -    public void createKeycloakDeployment(Keycloak keycloak) {-        client-            .apps()-            .deployments()-            .inNamespace(keycloak.getMetadata().getNamespace())-            .create(newKeycloakDeployment(keycloak));+    private Deployment createBaseDeployment() {+        URL url = this.getClass().getResource(""/base-keycloak-deployment.yaml"");+        Deployment baseDeployment = client.apps().deployments().load(url).get();++        baseDeployment.getMetadata().setName(getName());+        baseDeployment.getMetadata().setNamespace(getNamespace());+        baseDeployment.getSpec().getSelector().setMatchLabels(Constants.DEFAULT_LABELS);+        baseDeployment.getSpec().setReplicas(keycloakCR.getSpec().getInstances());+        baseDeployment.getSpec().getTemplate().getMetadata().setLabels(Constants.DEFAULT_LABELS);++        Container container = baseDeployment.getSpec().getTemplate().getSpec().getContainers().get(0);+        container.setImage(Optional.ofNullable(keycloakCR.getSpec().getImage()).orElse(config.operand().image()));++        var distConfig = new HashMap<>(Constants.DEFAULT_DIST_CONFIG);+        if (keycloakCR.getSpec().getDistConfig() != null) {+            distConfig.putAll(keycloakCR.getSpec().getDistConfig());+        }++        container.setEnv(distConfig.entrySet().stream()+                .map(e -> new EnvVarBuilder().withName(e.getKey()).withValue(e.getValue()).build())+                .collect(Collectors.toList()));++//        Set<String> configSecretsNames = new HashSet<>();+//        List<EnvVar> configEnvVars = distConfig.entrySet().stream()+//                .map(e -> {+//                    EnvVarBuilder builder = new EnvVarBuilder().withName(e.getKey());+//                    Matcher matcher = CONFIG_SECRET_PATTERN.matcher(e.getValue());+//                    // check if given config var is actually a secret reference+//                    if (matcher.matches()) {+//                        builder.withValueFrom(+//                                new EnvVarSourceBuilder()+//                                        .withNewSecretKeyRef(matcher.group(2), matcher.group(1), false)+//                                        .build());+//                        configSecretsNames.add(matcher.group(1)); // for watching it later+//                    } else {+//                        builder.withValue(e.getValue());+//                    }+//                    builder.withValue(e.getValue());+//                    return builder.build();+//                })+//                .collect(Collectors.toList());+//        container.setEnv(configEnvVars);+//        this.configSecretsNames = Collections.unmodifiableSet(configSecretsNames);+//        Log.infof(""Found config secrets names: %s"", configSecretsNames);++        return baseDeployment;     } -    public Deployment newKeycloakDeployment(Keycloak keycloak) {-        if (baseDeployment == null) {-            URL url = this.getClass().getResource(""/base-deployment.yaml"");-            baseDeployment = client.apps().deployments().load(url).get();+    public void updateStatus(KeycloakStatusBuilder status) {+        if (existingDeployment == null) {+            status.addNotReadyMessage(""No existing Deployment found, waiting for creating a new one"");+            return;         } -        var deployment = baseDeployment;+        var replicaFailure = existingDeployment.getStatus().getConditions().stream()+                .filter(d -> d.getType().equals(""ReplicaFailure"")).findFirst();","Just out of curiosity, any reason why are you re-mapping just this specific failure condition?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9628,789770682,2022-01-21T15:47:12Z,operator/src/main/java/org/keycloak/operator/OperatorManagedResource.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.OwnerReferenceBuilder;+import io.fabric8.kubernetes.client.CustomResource;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;++import java.util.Collections;+import java.util.HashMap;+import java.util.Map;+import java.util.Optional;++/**+ * Represents a single K8s resource that is managed by this operator (e.g. Deployment, Service, Ingress, etc.)+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public abstract class OperatorManagedResource {+    protected KubernetesClient client;+    protected CustomResource<?, ?> cr;++    public OperatorManagedResource(KubernetesClient client, CustomResource<?, ?> cr) {+        this.client = client;+        this.cr = cr;+    }++    protected abstract HasMetadata getReconciledResource();++    public void createOrUpdateReconciled() {+        HasMetadata resource = getReconciledResource();+        setDefaultLabels(resource);+        setOwnerReferences(resource);++        Log.debugf(""Creating or updating resource: %s"", resource);+        resource = client.resource(resource).createOrReplace();+        Log.debugf(""Successfully created or updated resource: %s"", resource);+    }++    protected void setDefaultLabels(HasMetadata resource) {+        Map<String, String> labels = Optional.ofNullable(resource.getMetadata().getLabels()).orElse(new HashMap<>());+        labels.putAll(Constants.DEFAULT_LABELS);+        resource.getMetadata().setLabels(labels);+    }++    protected void setOwnerReferences(HasMetadata resource) {+        if (!cr.getMetadata().getNamespace().equals(resource.getMetadata().getNamespace())) {","this comment instead is still valid, can you, please, either remove the condition at all or throw an Exception instead of silently returning?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,789790554,2022-01-21T16:10:53Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -18,59 +18,101 @@  import javax.inject.Inject; +import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.client.KubernetesClient;-import io.javaoperatorsdk.operator.api.reconciler.*;-import io.javaoperatorsdk.operator.api.reconciler.Constants;-import org.jboss.logging.Logger;+import io.fabric8.kubernetes.client.informers.SharedIndexInformer;+import io.javaoperatorsdk.operator.api.reconciler.Context;+import io.javaoperatorsdk.operator.api.reconciler.ControllerConfiguration;+import io.javaoperatorsdk.operator.api.reconciler.ErrorStatusHandler;+import io.javaoperatorsdk.operator.api.reconciler.EventSourceContext;+import io.javaoperatorsdk.operator.api.reconciler.EventSourceInitializer;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.javaoperatorsdk.operator.api.reconciler.RetryInfo;+import io.javaoperatorsdk.operator.api.reconciler.UpdateControl;+import io.javaoperatorsdk.operator.processing.event.ResourceID;+import io.javaoperatorsdk.operator.processing.event.source.EventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.InformerEventSource;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants; import org.keycloak.operator.v2alpha1.crds.Keycloak; import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder; -@ControllerConfiguration(namespaces = Constants.WATCH_CURRENT_NAMESPACE, finalizerName = Constants.NO_FINALIZER)-public class KeycloakController implements Reconciler<Keycloak> {+import java.util.Collections;+import java.util.List;+import java.util.Optional;+import java.util.Set; -    @Inject-    Logger logger;+import static io.javaoperatorsdk.operator.api.reconciler.Constants.WATCH_CURRENT_NAMESPACE;++@ControllerConfiguration(namespaces = WATCH_CURRENT_NAMESPACE)+public class KeycloakController implements Reconciler<Keycloak>, EventSourceInitializer<Keycloak>, ErrorStatusHandler<Keycloak> {      @Inject     KubernetesClient client; +    @Inject+    Config config;++    @Override+    public List<EventSource> prepareEventSources(EventSourceContext<Keycloak> context) {+        SharedIndexInformer<Deployment> deploymentInformer =+                client.apps().deployments().inAnyNamespace()+                        .withLabels(Constants.DEFAULT_LABELS)+                        .runnableInformer(0);++        EventSource deploymentEvent = new InformerEventSource<>(+                deploymentInformer, d -> {+                    List<OwnerReference> ownerReferences = d.getMetadata().getOwnerReferences();+                    if (!ownerReferences.isEmpty()) {+                        return Set.of(new ResourceID(ownerReferences.get(0).getName(), d.getMetadata().getNamespace()));+                    } else {+                        return Collections.emptySet();+                    }+        });++        return List.of(deploymentEvent);+    }+     @Override     public UpdateControl<Keycloak> reconcile(Keycloak kc, Context context) {-        logger.trace(""Reconcile loop started"");-        final var spec = kc.getSpec();--        logger.info(""Reconciling Keycloak: "" + kc.getMetadata().getName() + "" in namespace: "" + kc.getMetadata().getNamespace());--        KeycloakStatus status = kc.getStatus();-        var deployment = new KeycloakDeployment(client);--        try {-            var kcDeployment = deployment.getKeycloakDeployment(kc);--            if (kcDeployment == null) {-                // Need to create the deployment-                deployment.createKeycloakDeployment(kc);-            }--            var nextStatus = deployment.getNextStatus(spec, status, kcDeployment);--            if (!nextStatus.equals(status)) {-                logger.trace(""Updating the status"");-                kc.setStatus(nextStatus);-                return UpdateControl.updateStatus(kc);-            } else {-                logger.trace(""Nothing to do"");-                return UpdateControl.noUpdate();-            }-        } catch (Exception e) {-            logger.error(""Error reconciling"", e);-            status = new KeycloakStatus();-            status.setMessage(""Error performing operations:\n"" + e.getMessage());-            status.setState(KeycloakStatus.State.ERROR);-            status.setError(true);+        String kcName = kc.getMetadata().getName();+        String namespace = kc.getMetadata().getNamespace();++        Log.infof(""--- Reconciling Keycloak: %s in namespace: %s"", kcName, namespace); +        var statusBuilder = new KeycloakStatusBuilder();++        // TODO use caches in secondary resources; this is a workaround for https://github.com/java-operator-sdk/java-operator-sdk/issues/830+        // KeycloakDeployment deployment = new KeycloakDeployment(client, config, kc, context.getSecondaryResource(Deployment.class).orElse(null));+        var kcDeployment = new KeycloakDeployment(client, config, kc, null);+        kcDeployment.updateStatus(statusBuilder);+        kcDeployment.createOrUpdateReconciled();","Nope, resource version is not changed most of the times this is called. As far as I understand it, it's something like `kubectl apply`. Not sure if we like [`edit`](https://github.com/fabric8io/kubernetes-client/blob/master/doc/CHEATSHEET.md#deployment) more. ;)",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,789792199,2022-01-21T16:12:54Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -16,82 +16,162 @@  */ package org.keycloak.operator.v2alpha1; +import io.fabric8.kubernetes.api.model.Container;+import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.fabric8.kubernetes.api.model.HasMetadata; import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.api.model.apps.DeploymentBuilder; import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource; import org.keycloak.operator.v2alpha1.crds.Keycloak;-import org.keycloak.operator.v2alpha1.crds.KeycloakSpec;-import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;  import java.net.URL;+import java.util.HashMap;+import java.util.Optional;+import java.util.stream.Collectors; -import static org.keycloak.operator.v2alpha1.crds.KeycloakStatus.State.*;+public class KeycloakDeployment extends OperatorManagedResource { -public class KeycloakDeployment {+//    public static final Pattern CONFIG_SECRET_PATTERN = Pattern.compile(""^\\$\\{secret:([^:]+):(.+)}$""); -    KubernetesClient client = null;+    private final Config config;+    private final Keycloak keycloakCR;+    private final Deployment existingDeployment;+    private final Deployment baseDeployment; -    KeycloakDeployment(KubernetesClient client) {-        this.client = client;+    public KeycloakDeployment(KubernetesClient client, Config config, Keycloak keycloakCR, Deployment existingDeployment) {+        super(client, keycloakCR);+        this.config = config;+        this.keycloakCR = keycloakCR;++        if (existingDeployment != null) {+            Log.info(""Existing Deployment provided by controller"");+            this.existingDeployment = existingDeployment;+        }+        else {+            Log.info(""Trying to fetch existing Deployment from the API"");+            this.existingDeployment = fetchExistingDeployment();+        }++        baseDeployment = createBaseDeployment();     } -    private Deployment baseDeployment;+    @Override+    protected HasMetadata getReconciledResource() {+        Deployment defaultDeployment = new DeploymentBuilder(this.baseDeployment).build(); // clone+        Deployment reconciledDeployment;+        if (existingDeployment == null) {+            Log.info(""No existing Deployment found, using the default"");+            reconciledDeployment = defaultDeployment;+        }+        else {+            Log.info(""Existing Deployment found, updating specs"");+            reconciledDeployment = existingDeployment;+            // don't override metadata, just specs+            reconciledDeployment.setSpec(defaultDeployment.getSpec());+        }++        return reconciledDeployment;+    } -    public Deployment getKeycloakDeployment(Keycloak keycloak) {-        // TODO this should be done through an informer to leverage caches-        // WORKAROUND for: https://github.com/java-operator-sdk/java-operator-sdk/issues/781+    private Deployment fetchExistingDeployment() {         return client                 .apps()                 .deployments()-                .inNamespace(keycloak.getMetadata().getNamespace())-                .list()-                .getItems()-                .stream()-                .filter((d) -> d.getMetadata().getName().equals(org.keycloak.operator.Constants.NAME))-                .findFirst()-                .orElse(null);-//                .withName(Constants.NAME)-//                .get();+                .inNamespace(getNamespace())+                .withName(getName())+                .get();     } -    public void createKeycloakDeployment(Keycloak keycloak) {-        client-            .apps()-            .deployments()-            .inNamespace(keycloak.getMetadata().getNamespace())-            .create(newKeycloakDeployment(keycloak));+    private Deployment createBaseDeployment() {+        URL url = this.getClass().getResource(""/base-keycloak-deployment.yaml"");+        Deployment baseDeployment = client.apps().deployments().load(url).get();++        baseDeployment.getMetadata().setName(getName());+        baseDeployment.getMetadata().setNamespace(getNamespace());+        baseDeployment.getSpec().getSelector().setMatchLabels(Constants.DEFAULT_LABELS);+        baseDeployment.getSpec().setReplicas(keycloakCR.getSpec().getInstances());+        baseDeployment.getSpec().getTemplate().getMetadata().setLabels(Constants.DEFAULT_LABELS);++        Container container = baseDeployment.getSpec().getTemplate().getSpec().getContainers().get(0);+        container.setImage(Optional.ofNullable(keycloakCR.getSpec().getImage()).orElse(config.operand().image()));++        var distConfig = new HashMap<>(Constants.DEFAULT_DIST_CONFIG);+        if (keycloakCR.getSpec().getDistConfig() != null) {+            distConfig.putAll(keycloakCR.getSpec().getDistConfig());+        }++        container.setEnv(distConfig.entrySet().stream()+                .map(e -> new EnvVarBuilder().withName(e.getKey()).withValue(e.getValue()).build())+                .collect(Collectors.toList()));++//        Set<String> configSecretsNames = new HashSet<>();+//        List<EnvVar> configEnvVars = distConfig.entrySet().stream()+//                .map(e -> {+//                    EnvVarBuilder builder = new EnvVarBuilder().withName(e.getKey());+//                    Matcher matcher = CONFIG_SECRET_PATTERN.matcher(e.getValue());+//                    // check if given config var is actually a secret reference+//                    if (matcher.matches()) {+//                        builder.withValueFrom(+//                                new EnvVarSourceBuilder()+//                                        .withNewSecretKeyRef(matcher.group(2), matcher.group(1), false)+//                                        .build());+//                        configSecretsNames.add(matcher.group(1)); // for watching it later+//                    } else {+//                        builder.withValue(e.getValue());+//                    }+//                    builder.withValue(e.getValue());+//                    return builder.build();+//                })+//                .collect(Collectors.toList());+//        container.setEnv(configEnvVars);+//        this.configSecretsNames = Collections.unmodifiableSet(configSecretsNames);+//        Log.infof(""Found config secrets names: %s"", configSecretsNames);++        return baseDeployment;     } -    public Deployment newKeycloakDeployment(Keycloak keycloak) {-        if (baseDeployment == null) {-            URL url = this.getClass().getResource(""/base-deployment.yaml"");-            baseDeployment = client.apps().deployments().load(url).get();+    public void updateStatus(KeycloakStatusBuilder status) {+        if (existingDeployment == null) {+            status.addNotReadyMessage(""No existing Deployment found, waiting for creating a new one"");+            return;         } -        var deployment = baseDeployment;+        var replicaFailure = existingDeployment.getStatus().getConditions().stream()+                .filter(d -> d.getType().equals(""ReplicaFailure"")).findFirst();","Unfortunately, conditions are missing official documentation but to my understanding it is a good practice that K8s API server creates this condition when there are errors. Other conditions just tell us if we have all pods ready or if they're scaling. This one is about errors specifically.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,789827169,2022-01-21T16:48:37Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -18,59 +18,101 @@  import javax.inject.Inject; +import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.client.KubernetesClient;-import io.javaoperatorsdk.operator.api.reconciler.*;-import io.javaoperatorsdk.operator.api.reconciler.Constants;-import org.jboss.logging.Logger;+import io.fabric8.kubernetes.client.informers.SharedIndexInformer;+import io.javaoperatorsdk.operator.api.reconciler.Context;+import io.javaoperatorsdk.operator.api.reconciler.ControllerConfiguration;+import io.javaoperatorsdk.operator.api.reconciler.ErrorStatusHandler;+import io.javaoperatorsdk.operator.api.reconciler.EventSourceContext;+import io.javaoperatorsdk.operator.api.reconciler.EventSourceInitializer;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.javaoperatorsdk.operator.api.reconciler.RetryInfo;+import io.javaoperatorsdk.operator.api.reconciler.UpdateControl;+import io.javaoperatorsdk.operator.processing.event.ResourceID;+import io.javaoperatorsdk.operator.processing.event.source.EventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.InformerEventSource;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants; import org.keycloak.operator.v2alpha1.crds.Keycloak; import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder; -@ControllerConfiguration(namespaces = Constants.WATCH_CURRENT_NAMESPACE, finalizerName = Constants.NO_FINALIZER)-public class KeycloakController implements Reconciler<Keycloak> {+import java.util.Collections;+import java.util.List;+import java.util.Optional;+import java.util.Set; -    @Inject-    Logger logger;+import static io.javaoperatorsdk.operator.api.reconciler.Constants.WATCH_CURRENT_NAMESPACE;++@ControllerConfiguration(namespaces = WATCH_CURRENT_NAMESPACE)+public class KeycloakController implements Reconciler<Keycloak>, EventSourceInitializer<Keycloak>, ErrorStatusHandler<Keycloak> {      @Inject     KubernetesClient client; +    @Inject+    Config config;++    @Override+    public List<EventSource> prepareEventSources(EventSourceContext<Keycloak> context) {+        SharedIndexInformer<Deployment> deploymentInformer =+                client.apps().deployments().inAnyNamespace()+                        .withLabels(Constants.DEFAULT_LABELS)+                        .runnableInformer(0);++        EventSource deploymentEvent = new InformerEventSource<>(+                deploymentInformer, d -> {+                    List<OwnerReference> ownerReferences = d.getMetadata().getOwnerReferences();+                    if (!ownerReferences.isEmpty()) {+                        return Set.of(new ResourceID(ownerReferences.get(0).getName(), d.getMetadata().getNamespace()));+                    } else {+                        return Collections.emptySet();+                    }+        });++        return List.of(deploymentEvent);+    }+     @Override     public UpdateControl<Keycloak> reconcile(Keycloak kc, Context context) {-        logger.trace(""Reconcile loop started"");-        final var spec = kc.getSpec();--        logger.info(""Reconciling Keycloak: "" + kc.getMetadata().getName() + "" in namespace: "" + kc.getMetadata().getNamespace());--        KeycloakStatus status = kc.getStatus();-        var deployment = new KeycloakDeployment(client);--        try {-            var kcDeployment = deployment.getKeycloakDeployment(kc);--            if (kcDeployment == null) {-                // Need to create the deployment-                deployment.createKeycloakDeployment(kc);-            }--            var nextStatus = deployment.getNextStatus(spec, status, kcDeployment);--            if (!nextStatus.equals(status)) {-                logger.trace(""Updating the status"");-                kc.setStatus(nextStatus);-                return UpdateControl.updateStatus(kc);-            } else {-                logger.trace(""Nothing to do"");-                return UpdateControl.noUpdate();-            }-        } catch (Exception e) {-            logger.error(""Error reconciling"", e);-            status = new KeycloakStatus();-            status.setMessage(""Error performing operations:\n"" + e.getMessage());-            status.setState(KeycloakStatus.State.ERROR);-            status.setError(true);+        String kcName = kc.getMetadata().getName();+        String namespace = kc.getMetadata().getNamespace();++        Log.infof(""--- Reconciling Keycloak: %s in namespace: %s"", kcName, namespace); +        var statusBuilder = new KeycloakStatusBuilder();++        // TODO use caches in secondary resources; this is a workaround for https://github.com/java-operator-sdk/java-operator-sdk/issues/830+        // KeycloakDeployment deployment = new KeycloakDeployment(client, config, kc, context.getSecondaryResource(Deployment.class).orElse(null));+        var kcDeployment = new KeycloakDeployment(client, config, kc, null);+        kcDeployment.updateStatus(statusBuilder);+        kcDeployment.createOrUpdateReconciled();","Sure, let's keep it simple for the prototype for now and watch for possible issues. We can always add a complex logic for comparing and evaluating the need of calling `createOrUpdate`.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,789832298,2022-01-21T16:53:39Z,operator/src/main/java/org/keycloak/operator/OperatorManagedResource.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.OwnerReferenceBuilder;+import io.fabric8.kubernetes.client.CustomResource;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;++import java.util.Collections;+import java.util.HashMap;+import java.util.Map;+import java.util.Optional;++/**+ * Represents a single K8s resource that is managed by this operator (e.g. Deployment, Service, Ingress, etc.)+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public abstract class OperatorManagedResource {+    protected KubernetesClient client;+    protected CustomResource<?, ?> cr;++    public OperatorManagedResource(KubernetesClient client, CustomResource<?, ?> cr) {+        this.client = client;+        this.cr = cr;+    }++    protected abstract HasMetadata getReconciledResource();++    public void createOrUpdateReconciled() {+        HasMetadata resource = getReconciledResource();+        setDefaultLabels(resource);+        setOwnerReferences(resource);++        Log.debugf(""Creating or updating resource: %s"", resource);+        resource = client.resource(resource).createOrReplace();+        Log.debugf(""Successfully created or updated resource: %s"", resource);+    }++    protected void setDefaultLabels(HasMetadata resource) {+        Map<String, String> labels = Optional.ofNullable(resource.getMetadata().getLabels()).orElse(new HashMap<>());+        labels.putAll(Constants.DEFAULT_LABELS);+        resource.getMetadata().setLabels(labels);+    }++    protected void setOwnerReferences(HasMetadata resource) {+        if (!cr.getMetadata().getNamespace().equals(resource.getMetadata().getNamespace())) {","So what do you suggest exactly? For sure throwing an exception is not a solution in context of this method. Of course, for true support for foreign resources located in other namespaces we'd need to implement additional logic.In any case, I'm pretty sure this gets refactored sooner or later when the Dependent Resources are ready in the SDK.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9628,789834092,2022-01-21T16:55:11Z,operator/src/main/java/org/keycloak/operator/OperatorManagedResource.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.OwnerReference;+import io.fabric8.kubernetes.api.model.OwnerReferenceBuilder;+import io.fabric8.kubernetes.client.CustomResource;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;++import java.util.Collections;+import java.util.HashMap;+import java.util.Map;+import java.util.Optional;++/**+ * Represents a single K8s resource that is managed by this operator (e.g. Deployment, Service, Ingress, etc.)+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public abstract class OperatorManagedResource {+    protected KubernetesClient client;+    protected CustomResource<?, ?> cr;++    public OperatorManagedResource(KubernetesClient client, CustomResource<?, ?> cr) {+        this.client = client;+        this.cr = cr;+    }++    protected abstract HasMetadata getReconciledResource();++    public void createOrUpdateReconciled() {+        HasMetadata resource = getReconciledResource();+        setDefaultLabels(resource);+        setOwnerReferences(resource);++        Log.debugf(""Creating or updating resource: %s"", resource);+        resource = client.resource(resource).createOrReplace();+        Log.debugf(""Successfully created or updated resource: %s"", resource);+    }++    protected void setDefaultLabels(HasMetadata resource) {+        Map<String, String> labels = Optional.ofNullable(resource.getMetadata().getLabels()).orElse(new HashMap<>());+        labels.putAll(Constants.DEFAULT_LABELS);+        resource.getMetadata().setLabels(labels);+    }++    protected void setOwnerReferences(HasMetadata resource) {+        if (!cr.getMetadata().getNamespace().equals(resource.getMetadata().getNamespace())) {","I would completely remove this condition as it's misleading and not used ATM, but not anything blocking  ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9659,790184832,2022-01-22T21:04:27Z,model/map/src/main/java/org/keycloak/models/map/clientscope/MapClientScopeAdapter.java,"@@ -72,8 +79,20 @@ public void setProtocol(String protocol) {         entity.setProtocol(protocol);     } +    @Override+    public RealmModel getRealm() {+        return realm;+    }+     @Override     public void setAttribute(String name, String value) {+        boolean valueUndefined = value == null || """".equals(value.trim());++        if (valueUndefined) {+            removeAttribute(name);+            return;+        }",The broken test was brought in with #9327.@dgozalo Any reason (apart from it being the current behaviour) for checking that [the `ClientScopeModel.DYNAMIC_SCOPE_REGEXP` attribute is empty](https://github.com/keycloak/keycloak/blob/e751626ac83515ef363ffde19d803185ab4d95d0/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/client/ClientScopeTest.java#L700)? It seems to me that it should have been removed.,
1836434,jonathanvila,https://api.github.com/repos/keycloak/keycloak/pulls/9628,790809491,2022-01-24T14:41:55Z,operator/src/main/resources/application.properties,"@@ -2,3 +2,6 @@ quarkus.operator-sdk.crd.apply=true quarkus.operator-sdk.generate-csv=true quarkus.container-image.builder=jib quarkus.operator-sdk.crd.validate=false++# Operator config+operator.operand.image=quay.io/keycloak/keycloak-x:latest","I would suggest another naming, as every element created by the operator are operands .... so probably operator.operand.keycloakImage could be clearer ? wdyt ?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9759,790832297,2022-01-24T15:04:46Z,core/src/main/java/org/keycloak/representations/idm/AbstractAuthenticationExecutionRepresentation.java,"@@ -67,6 +67,9 @@ public void setPriority(int priority) {      *      * @return      */+    @Deprecated+    private boolean autheticatorFlow;","Instead of adding this unused field I would be happy to remove the following accessors, unfortunately, the latter is a breaking change for the import/export functionality.cc. @stianst @pedroigor ",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,790846447,2022-01-24T15:18:59Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -0,0 +1,117 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.NamespaceBuilder;+import io.fabric8.kubernetes.client.Config;+import io.fabric8.kubernetes.client.ConfigBuilder;+import io.fabric8.kubernetes.client.DefaultKubernetesClient;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.javaoperatorsdk.operator.Operator;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.quarkiverse.operatorsdk.runtime.OperatorProducer;+import io.quarkiverse.operatorsdk.runtime.QuarkusConfigurationService;+import org.awaitility.Awaitility;+import org.eclipse.microprofile.config.inject.ConfigProperty;+import org.jboss.logging.Logger;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.BeforeEach;++import javax.enterprise.inject.Instance;+import javax.inject.Inject;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.InputStream;+import java.time.Duration;+import java.util.*;++import static org.assertj.core.api.Assertions.assertThat;++public abstract class ClusterOperatorTest {+  public static final String TARGET_KUBERNETES_MINIKUBE_YML = ""target/kubernetes/minikube.yml"";+  @Inject+  Logger logger;++  @ConfigProperty(name = ""testremote"", defaultValue = ""false"")+  Boolean testremote;++  @Inject+  Instance<Reconciler<? extends HasMetadata>> reconcilers;++  @Inject+  QuarkusConfigurationService configuration;++  protected Operator operator;+  protected KubernetesClient k8sclient;+  protected String namespace;++  @BeforeEach",I was expecting this method to be run `BeforeAll` to have: 1 namespace + 1 deployment + 1 test classand possibly multiple behavioural tests there. wdyt?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9628,790908493,2022-01-24T16:18:29Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -16,82 +16,162 @@  */ package org.keycloak.operator.v2alpha1; +import io.fabric8.kubernetes.api.model.Container;+import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.fabric8.kubernetes.api.model.HasMetadata; import io.fabric8.kubernetes.api.model.apps.Deployment; import io.fabric8.kubernetes.api.model.apps.DeploymentBuilder; import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.keycloak.operator.Config;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource; import org.keycloak.operator.v2alpha1.crds.Keycloak;-import org.keycloak.operator.v2alpha1.crds.KeycloakSpec;-import org.keycloak.operator.v2alpha1.crds.KeycloakStatus;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;  import java.net.URL;+import java.util.HashMap;+import java.util.Optional;+import java.util.stream.Collectors; -import static org.keycloak.operator.v2alpha1.crds.KeycloakStatus.State.*;+public class KeycloakDeployment extends OperatorManagedResource { -public class KeycloakDeployment {+//    public static final Pattern CONFIG_SECRET_PATTERN = Pattern.compile(""^\\$\\{secret:([^:]+):(.+)}$""); -    KubernetesClient client = null;+    private final Config config;+    private final Keycloak keycloakCR;+    private final Deployment existingDeployment;+    private final Deployment baseDeployment; -    KeycloakDeployment(KubernetesClient client) {-        this.client = client;+    public KeycloakDeployment(KubernetesClient client, Config config, Keycloak keycloakCR, Deployment existingDeployment) {+        super(client, keycloakCR);+        this.config = config;+        this.keycloakCR = keycloakCR;++        if (existingDeployment != null) {+            Log.info(""Existing Deployment provided by controller"");+            this.existingDeployment = existingDeployment;+        }+        else {+            Log.info(""Trying to fetch existing Deployment from the API"");+            this.existingDeployment = fetchExistingDeployment();+        }++        baseDeployment = createBaseDeployment();     } -    private Deployment baseDeployment;+    @Override+    protected HasMetadata getReconciledResource() {","Ok, unified the naming of the local variable with the field name.",
1836434,jonathanvila,https://api.github.com/repos/keycloak/keycloak/pulls/9625,791009913,2022-01-24T17:50:41Z,operator/src/test/java/org/keycloak/operator/OperatorE2EIT.java,"@@ -0,0 +1,75 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.Node;+import io.fabric8.kubernetes.client.KubernetesClientException;+import io.fabric8.kubernetes.client.dsl.Resource;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.awaitility.core.ConditionTimeoutException;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.time.Duration;+import java.util.List;++import static org.assertj.core.api.Assertions.assertThat;++@QuarkusTest+public class OperatorE2EIT extends ClusterOperatorTest {++    @Test+    public void given_ClusterAndOperatorRunning_when_KeycloakCRCreated_Then_KeycloakStructureIsDeployedAndStatusIsOK() {+        logger.info(((testremote) ? ""Remote "" : ""Local "") + ""Run Test :"" + operator + "" -- "" + namespace);++        // Node+        List<Node> nodes = k8sclient.nodes().list().getItems();+        assertThat(nodes).hasSize(1);++        // NS created by the extension [ probably this doesnt make sense as if not passes, then extension would fail]+        Awaitility.await()+                .atMost(Duration.ofSeconds(5))+                .pollDelay(Duration.ofSeconds(1))+                .untilAsserted(() -> assertThat(k8sclient.namespaces().withName(namespace).get()).isNotNull());+        assertThat(k8sclient.namespaces().withName(namespace + ""XX"").get()).isNull();++        // CR+        Resource<Keycloak> keycloakResource = k8sclient.resources(Keycloak.class).load(""kubernetes/example-keycloak.yml"");+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloakResource.get());++        Awaitility.await()+                .atMost(Duration.ofSeconds(5))+                .pollDelay(Duration.ofSeconds(1))+                .untilAsserted(() -> assertThat(k8sclient.resources(Keycloak.class).inNamespace(namespace).withName(""example-kc"").get()).isNotNull());++        // Check Operator has deployed Keycloak+        Awaitility.await()+                .atMost(Duration.ofSeconds(30))+                .pollDelay(Duration.ofSeconds(2))+                .untilAsserted(() -> assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(""keycloak"").get()).isNotNull());++        // Check Keycloak has status ready+        StringBuffer podlog = new StringBuffer();+        try {+            Awaitility.await()+                    .atMost(Duration.ofSeconds(60))+                    .pollDelay(Duration.ofSeconds(5))+                    .untilAsserted(() -> {+                        try {+                            k8sclient.pods().inNamespace(namespace).list().getItems().stream()+                                    .filter(a -> a.getMetadata().getName().startsWith(""keycloak""))+                                    .forEach(a -> podlog.append(a.getMetadata().getName()).append("" : "")","I think is doing any harm, and can provide value if for any reason (timeout, or any other cluster conditions ) the test doesnt pass....",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,791022169,2022-01-24T18:06:01Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -0,0 +1,117 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.NamespaceBuilder;+import io.fabric8.kubernetes.client.Config;+import io.fabric8.kubernetes.client.ConfigBuilder;+import io.fabric8.kubernetes.client.DefaultKubernetesClient;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.javaoperatorsdk.operator.Operator;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.quarkiverse.operatorsdk.runtime.OperatorProducer;+import io.quarkiverse.operatorsdk.runtime.QuarkusConfigurationService;+import org.awaitility.Awaitility;+import org.eclipse.microprofile.config.inject.ConfigProperty;+import org.jboss.logging.Logger;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.BeforeEach;++import javax.enterprise.inject.Instance;+import javax.inject.Inject;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.InputStream;+import java.time.Duration;+import java.util.*;++import static org.assertj.core.api.Assertions.assertThat;++public abstract class ClusterOperatorTest {+  public static final String TARGET_KUBERNETES_MINIKUBE_YML = ""target/kubernetes/minikube.yml"";+  @Inject+  Logger logger;++  @ConfigProperty(name = ""testremote"", defaultValue = ""false"")+  Boolean testremote;++  @Inject+  Instance<Reconciler<? extends HasMetadata>> reconcilers;++  @Inject+  QuarkusConfigurationService configuration;++  protected Operator operator;+  protected KubernetesClient k8sclient;+  protected String namespace;++  @BeforeEach","I do believe that this belong to `BeforeAll` as per our discussion, but I let @vmuzikar chip in here.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,791051889,2022-01-24T18:45:38Z,.github/workflows/operator-ci.yml,"@@ -34,6 +34,20 @@ jobs:         run: |           mvn clean install -DskipTests -DskipExamples -DskipTestsuite -      - name: Build the Keycloak Operator+      - name: Setup Minikube-Kubernetes+        uses: manusa/actions-setup-minikube@v2.4.3+        with:+          minikube version: v1.24.0+          kubernetes version: v1.22.3+          github token: ${{ secrets.GITHUB_TOKEN }}+          driver: docker+          start args: ' --addons=ingress '++      - name: Build , deploy and test operator in minikube         run: |-          mvn clean package -nsu -B -e -pl operator -Doperator -Dquarkus.container-image.build=true -Dquarkus.kubernetes.deployment-target=minikube+          cd operator+          eval $(minikube -p minikube docker-env) +          mvn clean verify \+              -Dquarkus.container-image.build=true \+              -Dquarkus.kubernetes.deployment-target=minikube \+              --no-transfer-progress -DtestRemote=true",I like this last naming ,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9763,791543526,2022-01-25T09:57:57Z,quarkus/tests/integration/src/main/java/org/keycloak/it/utils/RawKeycloakDistribution.java,"@@ -309,6 +316,44 @@ private void startServer(List<String> arguments) throws Exception {          FileUtils.deleteDirectory(distPath.resolve(""data"").toFile()); +        for (DistributionLifecycleManager lifecycleManager : lifecycleManagers) {+            lifecycleManager.beforeStart(this);+        }+         keycloak = builder.start();     }++    @Override+    public void setProperty(String key, String value) {+        setProperty(key, value, distPath.resolve(""conf"").resolve(""keycloak.conf"").toFile());+    }++    @Override+    public void setQuarkusProperty(String key, String value) {+        setProperty(key, value, distPath.resolve(""conf"").resolve(""quarkus.properties"").toFile());+    }++    private void setProperty(String key, String value, File confFile) {+        Properties properties = new Properties();++        if (confFile.exists()) {+            try (+                FileInputStream in = new FileInputStream(confFile);+            ) {++                properties.load(in);+            } catch (Exception e) {+                throw new RuntimeException(""Failed to update keycloak.conf"", e);","if I understand it right, this could either be `keycloak.conf` or `quarkus.properties`, so the exception message might be misleading when called from setQuarkusProperty. ",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9625,791548895,2022-01-25T10:04:10Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -0,0 +1,117 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.NamespaceBuilder;+import io.fabric8.kubernetes.client.Config;+import io.fabric8.kubernetes.client.ConfigBuilder;+import io.fabric8.kubernetes.client.DefaultKubernetesClient;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.javaoperatorsdk.operator.Operator;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.quarkiverse.operatorsdk.runtime.OperatorProducer;+import io.quarkiverse.operatorsdk.runtime.QuarkusConfigurationService;+import org.awaitility.Awaitility;+import org.eclipse.microprofile.config.inject.ConfigProperty;+import org.jboss.logging.Logger;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.BeforeEach;++import javax.enterprise.inject.Instance;+import javax.inject.Inject;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.io.InputStream;+import java.time.Duration;+import java.util.*;++import static org.assertj.core.api.Assertions.assertThat;++public abstract class ClusterOperatorTest {+  public static final String TARGET_KUBERNETES_MINIKUBE_YML = ""target/kubernetes/minikube.yml"";+  @Inject+  Logger logger;++  @ConfigProperty(name = ""testremote"", defaultValue = ""false"")+  Boolean testremote;++  @Inject+  Instance<Reconciler<? extends HasMetadata>> reconcilers;++  @Inject+  QuarkusConfigurationService configuration;++  protected Operator operator;+  protected KubernetesClient k8sclient;+  protected String namespace;++  @BeforeEach",+1 for `BeforeAll`. We want to have 1 operator deployment per 1 test class.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9625,791558791,2022-01-25T10:15:32Z,operator/src/test/java/org/keycloak/operator/OperatorE2EIT.java,"@@ -0,0 +1,75 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.Node;+import io.fabric8.kubernetes.client.KubernetesClientException;+import io.fabric8.kubernetes.client.dsl.Resource;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.awaitility.core.ConditionTimeoutException;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.time.Duration;+import java.util.List;++import static org.assertj.core.api.Assertions.assertThat;++@QuarkusTest+public class OperatorE2EIT extends ClusterOperatorTest {++    @Test+    public void given_ClusterAndOperatorRunning_when_KeycloakCRCreated_Then_KeycloakStructureIsDeployedAndStatusIsOK() {+        logger.info(((testremote) ? ""Remote "" : ""Local "") + ""Run Test :"" + operator + "" -- "" + namespace);++        // Node+        List<Node> nodes = k8sclient.nodes().list().getItems();+        assertThat(nodes).hasSize(1);++        // NS created by the extension [ probably this doesnt make sense as if not passes, then extension would fail]+        Awaitility.await()+                .atMost(Duration.ofSeconds(5))+                .pollDelay(Duration.ofSeconds(1))+                .untilAsserted(() -> assertThat(k8sclient.namespaces().withName(namespace).get()).isNotNull());+        assertThat(k8sclient.namespaces().withName(namespace + ""XX"").get()).isNull();++        // CR+        Resource<Keycloak> keycloakResource = k8sclient.resources(Keycloak.class).load(""kubernetes/example-keycloak.yml"");+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloakResource.get());++        Awaitility.await()+                .atMost(Duration.ofSeconds(5))+                .pollDelay(Duration.ofSeconds(1))+                .untilAsserted(() -> assertThat(k8sclient.resources(Keycloak.class).inNamespace(namespace).withName(""example-kc"").get()).isNotNull());++        // Check Operator has deployed Keycloak+        Awaitility.await()+                .atMost(Duration.ofSeconds(30))+                .pollDelay(Duration.ofSeconds(2))+                .untilAsserted(() -> assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(""keycloak"").get()).isNotNull());++        // Check Keycloak has status ready+        StringBuffer podlog = new StringBuffer();+        try {+            Awaitility.await()+                    .atMost(Duration.ofSeconds(60))+                    .pollDelay(Duration.ofSeconds(5))+                    .untilAsserted(() -> {+                        try {+                            k8sclient.pods().inNamespace(namespace).list().getItems().stream()+                                    .filter(a -> a.getMetadata().getName().startsWith(""keycloak""))+                                    .forEach(a -> podlog.append(a.getMetadata().getName()).append("" : "")","We should definitely have some logic like that but it should be generic  some error handler at the testsuite level that will save all pod logs. This would help tremendously in CI runs. We do similar thing with server logs there. But of course, it can be done as a follow-up.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9604,791789385,2022-01-25T14:48:48Z,common/src/main/java/org/keycloak/common/Profile.java,"@@ -48,37 +48,43 @@     }      public enum Feature {-        AUTHORIZATION(Type.DEFAULT),-        ACCOUNT2(Type.DEFAULT),-        ACCOUNT_API(Type.DEFAULT),-        ADMIN_FINE_GRAINED_AUTHZ(Type.PREVIEW),-        ADMIN2(Type.EXPERIMENTAL),-        DOCKER(Type.DISABLED_BY_DEFAULT),-        IMPERSONATION(Type.DEFAULT),-        OPENSHIFT_INTEGRATION(Type.PREVIEW),-        SCRIPTS(Type.PREVIEW),-        TOKEN_EXCHANGE(Type.PREVIEW),-        UPLOAD_SCRIPTS(DEPRECATED),-        WEB_AUTHN(Type.DEFAULT, Type.PREVIEW),-        CLIENT_POLICIES(Type.DEFAULT),-        CIBA(Type.DEFAULT),-        MAP_STORAGE(Type.EXPERIMENTAL),-        PAR(Type.DEFAULT),-        DECLARATIVE_USER_PROFILE(Type.PREVIEW),-        DYNAMIC_SCOPES(Type.EXPERIMENTAL);-+        AUTHORIZATION(""Authorization Service"", Type.DEFAULT),",Closing this as it is no longer relevant when we don't have per-feature options,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9772,791808036,2022-01-25T15:06:11Z,docs/guides/src/main/server/vault.adoc,"@@ -0,0 +1,59 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+title=""Using Kubernetes Secrets""+summary=""Learn how to use Kubernetes / OpenShift secrets in Keycloak""+priority=30+includedOptions=""vault vault-*"">++Keycloak supports a file based vault implementation for Kubernetes / OpenShift secrets. Mount Kubernetes secrets as data volumes, and they appear in a directory with a flat-file structure. Keycloak represents each secret as a file with the files name as the secret name and the files content as the secret value.","```suggestionKeycloak supports a file based vault implementation for Kubernetes / OpenShift secrets. Mount Kubernetes secrets into the Keycloak Container, and the data fields will be available in the mounted folder with a flat-file structure.```",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9772,791819322,2022-01-25T15:16:47Z,docs/guides/src/main/server/vault.adoc,"@@ -0,0 +1,59 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+title=""Using Kubernetes Secrets""+summary=""Learn how to use Kubernetes / OpenShift secrets in Keycloak""+priority=30+includedOptions=""vault vault-*"">++Keycloak supports a file based vault implementation for Kubernetes / OpenShift secrets. Mount Kubernetes secrets as data volumes, and they appear in a directory with a flat-file structure. Keycloak represents each secret as a file with the files name as the secret name and the files content as the secret value.++== Available integrations+You can use Kubernetes / OpenShift secrets for the following use-cases:++* Obtain the SMTP Mail server Password+* Obtain the LDAP Bind Credential when using LDAP-based User Federation+* Obtain the OIDC identity providers Client Secret when integrating external identity providers++== Enabling the vault+Enable the file based vault by building Keycloak using the following build option:++<@kc.build parameters=""--vault=file""/>++== Setting the base directory to lookup secrets+Kubernetes / OpenShift secrets are basically mounted files, so you have to configure a directory for these files to be mounted in:++<@kc.start parameters=""--vault-dir=/my/path""/>++== Realm-specific secret files+Kubernetes / OpenShift Secrets are used per-realm basis in Keycloak, so there's a naming convention for the file in place:","I think we need to explain a little better how to name the `data` fields into the Secrets, since it can be quite challenging to align all the strings to match.Here you have an example with a working configuration:https://issues.redhat.com/browse/SSOSUP-105?focusedCommentId=19404192&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-19404192",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9759,791833102,2022-01-25T15:29:21Z,core/src/main/java/org/keycloak/representations/overrides/NoSubGroupsGroupRepresentation.java,"@@ -0,0 +1,98 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.representations.overrides;++import java.util.Arrays;+import java.util.HashMap;+import java.util.List;+import java.util.Map;++public class NoSubGroupsGroupRepresentation {","I hate that we need to have another Group representation just without sub-groups. It feels very error prone as changes in the main class could be easily forgot to be ported here. But I guess we don't have many options, right?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9759,791835546,2022-01-25T15:31:34Z,core/src/test/java/org/keycloak/crd/ExampleRealmCRD.java,"@@ -0,0 +1,30 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.crd;++import io.fabric8.kubernetes.api.model.Namespaced;+import io.fabric8.kubernetes.client.CustomResource;+import io.fabric8.kubernetes.model.annotation.Group;+import io.fabric8.kubernetes.model.annotation.Version;++// Demo CRD to verify that the generator doesn't break+// Result is available at: target/test-classes/META-INF/fabric8/examplerealmcrds.keycloak.org-v1.yml+@Group(""keycloak.org"")+@Version(""v1alpha1"")+public class ExampleRealmCRD extends CustomResource<ExampleRealmCRDSpec, Void> implements Namespaced {",This should not be part of the final PR. This belongs to the operator.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9759,791835882,2022-01-25T15:31:53Z,core/src/test/java/org/keycloak/crd/ExampleRealmCRDSpec.java,"@@ -0,0 +1,45 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.crd;++import org.keycloak.representations.idm.RealmRepresentation;++import javax.validation.constraints.NotNull;++public class ExampleRealmCRDSpec {",This should not be part of the final PR. This belongs to the operator.,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9759,792015908,2022-01-25T18:41:12Z,core/src/test/java/org/keycloak/crd/ExampleRealmCRD.java,"@@ -0,0 +1,30 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.crd;++import io.fabric8.kubernetes.api.model.Namespaced;+import io.fabric8.kubernetes.client.CustomResource;+import io.fabric8.kubernetes.model.annotation.Group;+import io.fabric8.kubernetes.model.annotation.Version;++// Demo CRD to verify that the generator doesn't break+// Result is available at: target/test-classes/META-INF/fabric8/examplerealmcrds.keycloak.org-v1.yml+@Group(""keycloak.org"")+@Version(""v1alpha1"")+public class ExampleRealmCRD extends CustomResource<ExampleRealmCRDSpec, Void> implements Namespaced {","This is in the `test` scope, and guarantees that the model can generate a CRD without throwing exceptions at compile time. It's actually a ""compile-time"" regression test.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9646,792383289,2022-01-26T07:59:25Z,docs/guides/src/main/server/run-containers.adoc,"@@ -0,0 +1,106 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Running in a container""+summary=""Learn how to run Keycloak from a container image""+priority=20+includedOptions="""">++Keycloak is handling containerized environments like Kubernetes or OpenShift as first-class-citizens. In this guide you'll learn how to run and optimize the Keycloak container image to have the best experience running a Keycloak container.++== Create an optimized container image+To get the best startup experience for your Keycloak container, we recommend building an optimized container image by running the `build` step explicitly before starting:++=== Build your optimized Keycloak docker image+The `Dockerfile` below creates a pre-configured Keycloak image which enables the metrics endpoint, the token exchange feature and uses a postgres database.++.Dockerfile:+[source, dockerfile]+----+FROM quay.io/keycloak/keycloak-x:latest as builder++ENV KC_METRICS_ENABLED=true+ENV KC_FEATURES=token_exchange+ENV KC_DB=postgres+RUN /opt/keycloak/bin/kc.sh build++FROM quay.io/keycloak/keycloak-x:latest+COPY --from=builder /opt/keycloak/lib/quarkus/ /opt/keycloak/lib/quarkus/+WORKDIR /opt/keycloak+# for demonstration purposes only, please make sure to use proper certificates in production instead+RUN keytool -genkeypair -storepass password -storetype PKCS12 -keyalg RSA -keysize 2048 -dname ""CN=server"" -alias server -ext ""SAN:c=DNS:localhost,IP:127.0.0.1"" -keystore conf/server.keystore+ENV KEYCLOAK_ADMIN=admin+ENV KEYCLOAK_ADMIN_PASSWORD=change_me+# change these values to point to a running postgres instance+ENV KC_DB_URL=<DBURL>+ENV KC_DB_USERNAME=<DBUSERNAME>+ENV KC_DB_PASSWORD=<DBPASSWORD>+ENV KC_HOSTNAME=localhost:8443+ENTRYPOINT [""/opt/keycloak/bin/kc.sh"", ""start""]+----+In the first stage of this multi-staged build, we're creating the optimized image using the `build` command to apply the build options. From the `builder`, we're copying the files generated by the `build` process into a new image. In this runner image, we apply the specific run configuration, containing e.g. a keystore, the environment-specific hostname configuration and database configuration. Then this image gets started in production mode by using the `start` command in the entrypoint.++Note that this example uses a multi-staged build to explicitly showcase the build and run steps. It could also be run as a single-staged docker build.++=== Building the docker image+To build the actual docker image, run the following command form the Directory containing your Dockerfile:+[source,bash]+----+podman|docker build . -t prebuilt_keycloak+----++=== Start the optimized Keycloak docker image:+To start the image, run:+[source, bash]+----+podman|docker run --rm -it --name optimized_keycloak -p 8443:8443 prebuilt_keycloak+----++You'll notice that the startup log contains the following line:+[source, bash]+----+INFO  [org.key.com.Profile] (main) Preview feature enabled: token_exchange+----+stating that the desired feature is enabled.+Also, opening up `https://localhost:8443/metrics` leads to a page containing operational metrics which could be used by your monitoring solution.++== Try Keycloak out in development mode+The easiest way to try out Keycloak from a container for development or testing purposes is using the Development mode(_todo_link_to_missing_guide_) by using the `start-dev` command:++[source,bash]+----+podman|docker run --rm -it --name keycloak_test -p 8080:8080 \+        -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=change_me \+        quay.io/keycloak/keycloak-x:latest \+        start-dev+----++Invoking this command will spin up the Keycloak server in development mode.++Keep in mind that this mode is by no means meant to be used in production environments, as it has insecure defaults. For more information about running Keycloak in production, see _todo_link_to_running_in_production_guide_.++== Use auto-build to run a standard keycloak container+Following concepts such as immutable infrastructure, containers need to be re-provisioned fairly often. In these environments, you want to have containers which start up fast by using an optimized image as described above.++However, when your environment is different, you may want to run a standard Keycloak image using the `--auto-build` flag like below:++[source, bash]+----+podman|docker run --rm -it --name keycloak_auto_build -p 8080:8080 \+        -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=change_me \+        quay.io/keycloak/keycloak-x:latest \+        start \+        --auto-build \+        --db=postgres --features-token_exchange=enabled \+        --db-url=<JDBC-URL> --db-username=<DB-USER> --db-password=<DB-PASSWORD> \+        --https-key-store-file=<file> --https-key-store-password=<password>+----++Running the above will spin up a Keycloak server which detects and applies the build configuration first. In the example, it's  `--db=postgres --features-token_exchange=enabled` to set the used database vendor to postgres and enable the token exchange feature.++Keycloak will then start up and apply the configuration for the specific environment. This usually takes way more time than spinning up an already optimized image, and is therefore not recommended.","What about something like:```suggestionKeycloak will then start up and apply the configuration for the specific environment. This approach results in a significantly bigger startup time, and an image that is mutable, and is therefor not the best practice.```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9646,792394895,2022-01-26T08:18:00Z,docs/guides/src/main/server/run-containers.adoc,"@@ -0,0 +1,106 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Running in a container""+summary=""Learn how to run Keycloak from a container image""+priority=20+includedOptions="""">","I can do this, but might grow quite big. Let me try. Btw: What about KEYCLOAK_ADMIN / KEYCLOAK_ADMIN_PASSWORD - they're not documented yet in the all-config guide, and are kinda special. ",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9759,792460891,2022-01-26T09:42:59Z,core/src/main/java/org/keycloak/representations/idm/AbstractAuthenticationExecutionRepresentation.java,"@@ -67,6 +67,9 @@ public void setPriority(int priority) {      *      * @return      */+    @Deprecated+    private boolean autheticatorFlow;","Here we are adding back the field, that remains unused, since it's emitted by the Json serialization.If we don't add it, you would need to remove all the relevant fields `autheticatorFlow` (WITH the typo) from the exported `RealmRepresentation` before importing it as a CR.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9761,792464166,2022-01-26T09:46:38Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -583,7 +586,6 @@ public void removeAttribute(String name) {             JpaClientAttributeEntity attr = iterator.next();             if (Objects.equals(attr.getName(), name)) {                 iterator.remove();-                attr.setClient(null);","I found that the `@PreDelete` handler needed to know the parent entity to enforce the locking. When setting it to null, this wan't possible any more.Then I digged deeper into the Hibernate things and found that ""orphanRemoval"" should do the job of removing an attribute that was removed from a collection. Then I tested it, and the attributes were removed correctly. ""orphanRemoval"" is a JPA 2 feature. Setting the attribute might have been necessary in the past, but my manual tests showed that this is no longer necessary; it is sufficient to remove the item from the collection.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9759,792525514,2022-01-26T11:02:02Z,pom.xml,"@@ -81,7 +81,7 @@         <infinispan.version>12.1.7.Final</infinispan.version>         <infinispan.protostream.processor.version>4.4.1.Final</infinispan.protostream.processor.version>         <javax.annotation-api.version>1.3.2</javax.annotation-api.version>-        <jackson.version>2.12.1</jackson.version>+        <jackson.version>2.13.1</jackson.version>",Jackson version needs to honor quarkus / wildfly versions and cannot be changed for the sake of an added library local to a part of the project. See e.g. quarkus/pom.xml on how to override library versions should this be necessary.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9763,792539402,2022-01-26T11:21:43Z,quarkus/deployment/src/main/java/org/keycloak/quarkus/deployment/KeycloakProcessor.java,"@@ -327,6 +337,8 @@ void persistBuildTimeProperties(BuildProducer<GeneratedResourceBuildItem> resour             properties.put(String.format(""kc.provider.file.%s.last-modified"", jar.getName()), String.valueOf(jar.lastModified()));         } +        properties.put(QUARKUS_PROPERTY_ENABLED, String.valueOf(QuarkusPropertiesConfigSource.getConfigurationFile() != null));","Might be more reusable and readable to use e.g. a method like `quarkusPropertiesExists()` in `QuarkusPropertiesConfigSource` which hides the String.valueOf... implementation detail? Advantage:* ConfigSource related impl stays in ConfigSource class, can be reused elsewhere and when it changes you only have to change it there",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9759,792620191,2022-01-26T13:11:30Z,core/src/main/java/org/keycloak/representations/idm/AbstractAuthenticationExecutionRepresentation.java,"@@ -67,6 +67,9 @@ public void setPriority(int priority) {      *      * @return      */+    @Deprecated+    private boolean autheticatorFlow;","@stianst this is the only change in the core I'm leaving, as far as I can tell it should be ok, but let me know if I have to duplicate even this file.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9761,792621064,2022-01-26T13:12:39Z,server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java,"@@ -17,6 +17,8 @@  package org.keycloak.models.utils; +import org.jboss.logging.Logger;+import org.keycloak.TokenVerifier;",unused import,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9761,792623051,2022-01-26T13:15:16Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapStorageProviderFactory.java,"@@ -160,6 +168,32 @@ private void lazyInit() {                     properties.put(""hibernate.format_sql"", config.getBoolean(""formatSql"", true));                     properties.put(""hibernate.dialect"", config.get(""driverDialect"")); +                    properties.put(+                            ""hibernate.integrator_provider"",+                            (IntegratorProvider) () -> Collections.singletonList(+                                    new org.hibernate.integrator.spi.Integrator() {++                                        @Override+                                        public void integrate(Metadata metadata, SessionFactoryImplementor sessionFactoryImplementor,+                                                              SessionFactoryServiceRegistry sessionFactoryServiceRegistry) {+                                            final EventListenerRegistry eventListenerRegistry =+                                                    sessionFactoryServiceRegistry.getService( EventListenerRegistry.class );++                                            JpaChildEntityListener instance = new JpaChildEntityListener();+                                            eventListenerRegistry.appendListeners(EventType.PRE_INSERT, instance);+                                            eventListenerRegistry.appendListeners(EventType.PRE_UPDATE, instance);+                                            eventListenerRegistry.appendListeners(EventType.PRE_DELETE, instance);","Maybe there could be singleton instance introduced, wdyt?```suggestion                                            eventListenerRegistry.appendListeners(EventType.PRE_INSERT, JpaChildEntityListener.INSTANCE);                                            eventListenerRegistry.appendListeners(EventType.PRE_UPDATE, JpaChildEntityListener.INSTANCE);                                            eventListenerRegistry.appendListeners(EventType.PRE_DELETE, JpaChildEntityListener.INSTANCE);```",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9761,792627226,2022-01-26T13:20:38Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/delegate/JpaClientDelegateProvider.java,"@@ -28,21 +28,21 @@ import org.keycloak.models.map.client.MapClientEntityFields; import org.keycloak.models.map.common.EntityField; import org.keycloak.models.map.common.delegate.DelegateProvider;+import org.keycloak.models.map.storage.jpa.JpaDelegateProvider; import org.keycloak.models.map.storage.jpa.client.entity.JpaClientEntity; -public class JpaClientDelegateProvider implements DelegateProvider<MapClientEntity> {+public class JpaClientDelegateProvider extends JpaDelegateProvider<JpaClientEntity> implements DelegateProvider<MapClientEntity>  {",nitpick: ```suggestionpublic class JpaClientDelegateProvider extends JpaDelegateProvider<JpaClientEntity> implements DelegateProvider<MapClientEntity> {```,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9786,792730006,2022-01-26T15:03:33Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -129,12 +130,23 @@ public boolean isMetadataInitialized() {     }      /**-     * In case of any update on entity, we want to update the entityVerion+     * In case of any update on entity, we want to update the entityVersion      * to current one.+     * This includes downgrading from a future version of Keycloak, as the entityVersion must match the JSON+     * and the additional tables this version writes.+     *+     * The @PreUpdate makes JPA calling this when any attribute of this entity has been changed and is about to be persisted+     * .+     * Must be called explicitly when a child (like the attributes) is modified, as that doesn't trigger @PreUpdate.+     * Still, the entityVersion needs to match the application's SUPPORTED_VERSION_CLIENT as the structure and contents+     * of the additional tables might depend on the version.+     *+     * Future versions of this method might restrict downgrading to downgrade only from the next version.      */-    private void checkEntityVersionForUpdate() {+    @PreUpdate+    private void updateEntityVersion() {         Integer ev = getEntityVersion();-        if (ev != null && ev < SUPPORTED_VERSION_CLIENT) {+        if (ev != null && !Objects.equals(ev, SUPPORTED_VERSION_CLIENT)) {","I was thinking about restricting downgrading as well, and then didn't. Let me explain why and let's see where we agree and where it can be improved.The current version doesn't support reading a version that is larger than N+1, instead it will throw an exception. Reading versions from further in the [future is optional](https://github.com/keycloak/keycloak-community/blob/main/design/keycloak.x/storage-persistence.md#-version-compatibility-vc): > Extended forward compatibility (optional). Object stored by store of version N MAY be readable by much older store, i.e. store of version M where M  N-2, but the store MUST throw an IllegalArgumentException if the object cannot be reliably reconstructed from the stored data.The ""reliably reconstructed"" could mean that it can only be used for read-only access, or it is ""good enough"" to also write it to the database. If it is good enough to also write it to the database, no change to the code is necessary. If it is only good enough for reading, then the code needs to be amended to restrict downgrading it to the current version - in that case it would need to throw an exception. Either way, reading data from multiple versions in the future depends on a concrete example at hand. Therefore, I would pull the YAGNI card, and argue that it should be implemented once we have the example at hand. As checking the entity version read from the database in one place (JpaEntityMigration), and upgrading the entity version here, I could imagine a comment in the code in JpaEntityMigrationthat if you change one place, that you remember to change also the other place. WDYT?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/9801,792791859,2022-01-26T16:01:10Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/FeaturesDistTest.java,"@@ -3,22 +3,71 @@ import io.quarkus.test.junit.main.Launch; import io.quarkus.test.junit.main.LaunchResult; import org.hamcrest.CoreMatchers;+import org.junit.jupiter.api.MethodOrderer;+import org.junit.jupiter.api.Order; import org.junit.jupiter.api.Test;+import org.junit.jupiter.api.TestMethodOrder; import org.keycloak.it.junit5.extension.CLIResult; import org.keycloak.it.junit5.extension.DistributionTest;+import org.keycloak.it.junit5.extension.RawDistOnly;+import org.keycloak.quarkus.runtime.cli.command.Build;+import org.keycloak.quarkus.runtime.cli.command.Start; import org.keycloak.quarkus.runtime.cli.command.StartDev;  import static org.hamcrest.CoreMatchers.containsString; import static org.hamcrest.MatcherAssert.assertThat;+import static org.junit.jupiter.api.Assertions.assertFalse;  @DistributionTest+@RawDistOnly(reason = ""Containers are immutable"")+@TestMethodOrder(MethodOrderer.OrderAnnotation.class) public class FeaturesDistTest { +    @Test+    @Launch({ Build.NAME, ""--features=preview"", ""--cache=local""})+    @Order(1)+    public void testEnableOnBuild(LaunchResult result) {+        CLIResult cliResult = (CLIResult) result;+        cliResult.assertBuild();+        assertPreviewFeaturesEnabled(cliResult);+    }++    @Test+    @Launch({ Start.NAME, ""--http-enabled=true"", ""--hostname-strict=false""})+    @Order(2)+    public void testFeatureEnabledOnStart(LaunchResult result) {+        assertPreviewFeaturesEnabled((CLIResult) result);+    }+     @Test     @Launch({StartDev.NAME, ""--features=preview""})-    public void testPreviewFeaturesGetEnabledWhenCliArgIsSet(LaunchResult result) {+    public void testEnablePreviewFeatures(LaunchResult result) {         CLIResult cliResult = (CLIResult) result;         cliResult.assertStartedDevMode();+        assertPreviewFeaturesEnabled((CLIResult) result);+    }++    @Test+    @Launch({StartDev.NAME, ""--features=preview"", ""--features-disabled=token-exchange""})+    public void testEnablePrecedenceOverDisable(LaunchResult result) {+        CLIResult cliResult = (CLIResult) result;+        cliResult.assertStartedDevMode();+        assertPreviewFeaturesEnabled((CLIResult) result);+    }++    @Test+    @Launch({StartDev.NAME, ""--features=token-exchange,admin-fine-grained-authz""})+    public void testEnableMultipleFeatures(LaunchResult result) {+        CLIResult cliResult = (CLIResult) result;+        cliResult.assertStartedDevMode();+        assertThat(cliResult.getOutput(), CoreMatchers.allOf(+                containsString(""Preview feature enabled: admin_fine_grained_authz""),+                containsString(""Preview feature enabled: token_exchange"")));",Agree is not aligned with Dist.X values. I don't think we should change this now. It is a message from the Profile class.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/9414,792799115,2022-01-26T16:08:25Z,model/jpa/src/main/java/org/keycloak/models/jpa/session/PersistentUserSessionEntity.java,"@@ -47,14 +47,14 @@                 "" AND sess.realmId = :realmId AND sess.userId = :userId ORDER BY sess.userSessionId""),         @NamedQuery(name=""findUserSessionsByClientId"", query=""SELECT sess FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" +                 "" ON sess.userSessionId = clientSess.userSessionId AND clientSess.clientId = :clientId WHERE sess.offline = :offline "" +-                "" AND sess.userSessionId = clientSess.userSessionId AND sess.realmId = :realmId ORDER BY sess.userSessionId""),-        @NamedQuery(name=""findUserSessionsCountsByClientId"", query=""SELECT clientSess.clientId, count(clientSess) "" +-                "" FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" +-                "" ON sess.userSessionId = clientSess.userSessionId "" +-                // find all available offline user-session for all clients in a realm-                "" WHERE sess.offline = :offline "" +-                "" AND sess.userSessionId = clientSess.userSessionId AND sess.realmId = :realmId "" +-                "" GROUP BY clientSess.clientId"")+                "" AND sess.realmId = :realmId ORDER BY sess.userSessionId""),+        @NamedQuery(name=""findUserSessionsByExternalClientId"", query=""SELECT sess FROM PersistentUserSessionEntity sess INNER JOIN PersistentClientSessionEntity clientSess "" ++                "" ON sess.userSessionId = clientSess.userSessionId AND clientSess.clientStorageProvider = :clientStorageProvider AND clientSess.externalClientId = :externalClientId WHERE sess.offline = :offline "" ++                "" AND sess.realmId = :realmId ORDER BY sess.userSessionId""),+        @NamedQuery(name=""findClientSessionsClientIds"", query=""SELECT clientSess.clientId, clientSess.externalClientId, clientSess.clientStorageProvider"" ++                "" FROM PersistentClientSessionEntity clientSess INNER JOIN PersistentUserSessionEntity sess ON clientSess.userSessionId = sess.userSessionId "" ++                "" WHERE sess.offline = :offline AND sess.realmId = :realmId "" ++                "" GROUP BY clientSess.clientId, clientSess.externalClientId, clientSess.clientStorageProvider"")",I think your point is correct that we might lose some entries. I removed the `GROUP BY` but I want to recheck that all databases are OK with that. (Can't do it ATM because keycloak-build-pipeline is not working). If some database will complain about missing GROUP BY I can still select the whole `PersistentClientSessionEntity` and then process it in Java code.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9559,793461460,2022-01-27T10:23:00Z,docs/guides/src/main/server/configuring-database.adoc,"@@ -0,0 +1,92 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+    title=""Configuring a database""+    summary=""An overview about how to configure relational databases""+    includedOptions=""db db.*"">++In this guide, you are going to understand how to configure the server to store data using different relational databases. You should also learn+what are the databases supported by the server and how to proceed when using a unsupported database version.++== Querying the list of supported databases++The server has built-in support for different databases. You should be able to query the available databases by looking at the expected values+for the `db` configuration option.++The list of supported databases and their corresponding versions are:++|===+|Database | Version++|mariadb| 10.3+|mssql| 2016+|mssql-2012| 2012+|mysql| 8+|oracle| 12c+|postgres| 10+|postgres-95| 9.5+|===++[NOTE]+The server is opinionated about the databases and their respective versions. If you need support for a different database, there are some+advanced configuration options to override the default configuration (e.g.: JDBC driver, Hibernate ORM Dialect, disable XA, etc). In this case, please help us by creating an issue to discuss+the possibility for built-in support.++== Configuring a database++For each supported database, the server provides some opinionated defaults to make it simpler to configure a database. The defaults allow+you to easily configure a database by just providing some key settings like the database host and credentials.++To configure a database, run the `build` command to build a server image using the `db` option to configure the server for specific database:++<@kc.build parameters=""--db postgres --db-url-host mypostgres --db-username myuser --db-password change_me""/>++In addition to the `db` configuration option, the `db-url-host`, `db-username`, and the `db-password`, are the bare minimum settings that you+need to provide in order to successfully connect to a database.++[NOTE]+By default, the default schema is set to `keycloak`. You can change that by using the `db-schema` configuration option.++== Configuring database credentials++You should be able to set database credentials using the `db-username` and `db-password` configuration options.++While tempting to set database credentials in plain text, you should avoid doing that whenever running in production in order to avoid unauthorized+access to your database.++The server allows you to securely store database credentials using different methods:++* Using placeholders+* Using the `build` command when creating a server image+* Using Hashicorp Vault++Some methods are more suitable when deploying to a specific environment. For instance, using placeholders and environment variables is suitable when running on Kubernetes.+Each method has its pros and cons, and you should consider them carefully when picking one.++=== Using placeholders to reference credentials++Credentials can be resolved from environment variables when starting the server instead of having them explicitly set in+a configuration file (e.g.: conf/keycloak.properties) or when passing arguments via CLI.++<@kc.start parameters=r""--db-username ${MY_DB_USER} --db-password ${MY_DB_PASSWORD}""/>++In this case, when the server is starting both ${r""MY_DB_USER""} and ${r""MY_DB_PASSWORD""} are going to be resolved as environment variables.++=== Persisting credentials into the server image++When running the `build` command, any configuration option you set is persisted into the server image. By having the database+credentials into the server image, you no longer need to set them when starting the server.++When using this method, you should make sure that:++* The file permissions for the server distribution are properly set so that only specific users/groups are allowed to read and write to files+* If using a container registry, make sure the repository is protected+* The node where the server is running is properly secured from unathorized access","This should be removed as it's no longer supported, and not a good idea anyways",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/9839,793664316,2022-01-27T14:31:53Z,distribution/server-x-dist/pom.xml,"@@ -49,7 +49,7 @@     </dependencies>      <build>-        <finalName>keycloak.x-${project.version}</finalName>+        <finalName>keycloak-${project.version}</finalName>",Could you please also update these resources to reflect the name changes:* https://github.com/keycloak/keycloak/blob/6c12c188542aeacc6d40aff9160e83b6a12f5b97/quarkus/tests/integration/src/main/java/org/keycloak/it/utils/DockerKeycloakDistribution.java#L33* https://github.com/keycloak/keycloak/blob/781ceb24fddec2655e3461f1b297aac02c737f04/quarkus/tests/integration/src/main/java/org/keycloak/it/utils/RawKeycloakDistribution.java#L253We were using Maven API to resolve the artifact but we gave up in favor of referencing it directly from the filesystem. We should be improving that.These changes should help with the quarkus tests.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9839,793688075,2022-01-27T14:54:42Z,quarkus/tests/integration/src/main/java/org/keycloak/it/utils/DockerKeycloakDistribution.java,"@@ -30,7 +30,7 @@     private String stderr = """";     private ToStringConsumer backupConsumer = new ToStringConsumer(); -    private File distributionFile = new File(""../../../distribution/server-x-dist/target/keycloak.x-"" + Version.VERSION_KEYCLOAK + "".tar.gz"");+    private File distributionFile = new File(""../../../distribution/server-x-dist/target/keycloak-"" + Version.VERSION_KEYCLOAK + "".tar.gz"");","I think we should also rename the directory here? so that `server-dist` then uses quarkus and `server-dist-legacy` or similar uses wildfly.That'd be followed by a bunch of other changes to readme's etc, though I guess. so perhaps sth for another PR.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8260,794351537,2022-01-28T09:49:52Z,services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java,"@@ -788,6 +788,11 @@ public Response handleBrowserException(Exception failure) {                 event.error(Errors.INVALID_USER_CREDENTIALS);                 if (e.getResponse() != null) return e.getResponse();                 return ErrorPage.error(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.CREDENTIAL_SETUP_REQUIRED);+            } else if (e.getError() == AuthenticationFlowError.SESSION_LIMIT_EXCEEDED) {","I know that this is not your fault, but it is in general not good that we need to change class `AuthenticationProcessor` and `AuthenticationFlowError` always when we introduce new ""error type"" . This means that authentication SPI is not generic enough to handle generic error situations.I wonder that instead of introducing another error type (SESSION_LIMIT_EXCEEDED), it will be nice if we can go in the path of introducing some generic error. And then possibly have some code like this in `AuthenticationProcessor` ```            } else if (e.getError() == AuthenticationFlowError.GENERIC_AUTHENTICATON_ERROR) {                ServicesLogger.LOGGER.failedAuthentication(e);                if (e.getEventDetail() != null) {                    event.detail(Details.AUTHENTICATION_ERROR_DETAIL, e.getEventDetail());                }                event.error(Errors.GENERIC_AUTHENTICATION_ERROR);                if (e.getResponse() != null) return e.getResponse();                return ErrorPage.error(session, authenticationSession, Response.Status.BAD_REQUEST, e.getUserErrorMessage());```This will mean introduce two new fields `userErrorMessage` and `eventDetails` on `AuthenticationFlowException` class. And those may need to be filled by the Authenticator itself. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8260,794353572,2022-01-28T09:52:40Z,services/src/main/java/org/keycloak/authentication/authenticators/sessionlimits/RealmSessionLimitsAuthenticator.java,"@@ -0,0 +1,52 @@+package org.keycloak.authentication.authenticators.sessionlimits;++import org.jboss.logging.Logger;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.KeycloakSession;++import java.util.Map;+import java.util.Optional;+import javax.ws.rs.core.Response;+import org.keycloak.events.Errors;+import org.keycloak.services.messages.Messages;++public class RealmSessionLimitsAuthenticator extends AbstractSessionLimitsAuthenticator {","Question: Do you really have good use-case for `RealmSessionLimitsAuthenticator`? TBH I would support only limits only per user and if possible, I would prefer to remove this authenticator from this PR. The realm-limits authenticator has disadvantage of possibly non-trivial performance penalty (when calling `session.sessions().getActiveClientSessionStats`) and it is another thing to maintain, which I am not sure would be generically useful.Removing this authenticator will allow to ""merge"" class `AbstractSessionLimitsAuthenticator` to the `UserSessionLimitsAuthenticator` and will make whole PR easier. WDYT?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8260,794356651,2022-01-28T09:56:42Z,services/src/main/java/org/keycloak/authentication/authenticators/sessionlimits/UserSessionLimitsAuthenticator.java,"@@ -0,0 +1,102 @@+package org.keycloak.authentication.authenticators.sessionlimits;++import org.jboss.logging.Logger;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserSessionModel;+import org.keycloak.services.managers.AuthenticationManager;++import java.util.Comparator;+import java.util.List;+import java.util.Map;+import java.util.Optional;+import java.util.stream.Collectors;+import javax.ws.rs.core.Response;+import org.keycloak.events.Errors;+import org.keycloak.services.messages.Messages;++public class UserSessionLimitsAuthenticator extends AbstractSessionLimitsAuthenticator {++    private static Logger logger = Logger.getLogger(UserSessionLimitsAuthenticator.class);++    String behavior;++    public UserSessionLimitsAuthenticator(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public void authenticate(AuthenticationFlowContext context) {+        AuthenticatorConfigModel authenticatorConfig = context.getAuthenticatorConfig();+        Map<String, String> config = authenticatorConfig.getConfig();++        // Get the configuration for this authenticator+        behavior = config.get(UserSessionLimitsAuthenticatorFactory.BEHAVIOR);+        int userRealmLimit = getIntConfigProperty(UserSessionLimitsAuthenticatorFactory.USER_REALM_LIMIT, config);+        int userClientLimit = getIntConfigProperty(UserSessionLimitsAuthenticatorFactory.USER_CLIENT_LIMIT, config);++        if (context.getRealm() != null && context.getUser() != null) {++            // Get the session count in this realm for this specific user+            List<UserSessionModel> userSessionsForRealm = session.sessions().getUserSessions(context.getRealm(), context.getUser());+            int userSessionCountForRealm = userSessionsForRealm.size();++            // Get the session count related to the current client for this user+            ClientModel currentClient = context.getAuthenticationSession().getClient();+            logger.debugf(""session-limiter's current keycloak clientId: %s"", currentClient.getClientId());++            List<UserSessionModel> userSessionsForClient = userSessionsForRealm.stream().filter(session -> session.getAuthenticatedClientSessionByClient(currentClient.getId()) != null).collect(Collectors.toList());+            int userSessionCountForClient = userSessionsForClient.size();+            logger.debugf(""session-limiter's configured realm session limit: %s"", userRealmLimit);+            logger.debugf(""session-limiter's configured client session limit: %s"", userClientLimit);+            logger.debugf(""session-limiter's count of total user sessions for the entire realm (could be apps other than web apps): %s"", userSessionCountForRealm);+            logger.debugf(""session-limiter's count of total user sessions for this keycloak client: %s"", userSessionCountForClient);++            // First check if the user has too many sessions in this realm+            if (exceedsLimit(userSessionCountForRealm, userRealmLimit)) {+                logger.infof(""Too many session in this realm for the current user. Session count: %s"", userSessionCountForRealm);+                handleLimitExceeded(context, userSessionsForRealm);+            } // otherwise if the user is still allowed to create a new session in the realm, check if this applies for this specific client as well.+            else if (exceedsLimit(userSessionCountForClient, userClientLimit)) {+                logger.infof(""Too many sessions related to the current client for this user. Session count: %s"", userSessionCountForRealm);+                handleLimitExceeded(context, userSessionsForClient);+            } else {+                context.success();+            }+        } else {+            context.success();+        }+    }++    private void handleLimitExceeded(AuthenticationFlowContext context, List<UserSessionModel> userSessions) {+        switch (behavior) {+            case UserSessionLimitsAuthenticatorFactory.DENY_NEW_SESSION:+                logger.info(""Denying new session"");+                String errorMessage = Optional.ofNullable(context.getAuthenticatorConfig())+                        .map(AuthenticatorConfigModel::getConfig)+                        .map(f -> f.get(UserSessionLimitsAuthenticatorFactory.ERROR_MESSAGE))+                        .orElse(Messages.SESSION_LIMIT_EXCEEDED);++                context.getEvent().error(Errors.SESSION_LIMIT_EXCEEDED);+                Response challenge = context.form()+                        .setError(errorMessage)+                        .createErrorPage(Response.Status.FORBIDDEN);+                context.failure(AuthenticationFlowError.SESSION_LIMIT_EXCEEDED, challenge);+                break;+            case UserSessionLimitsAuthenticatorFactory.TERMINATE_OLDEST_SESSION:+                logger.info(""Terminating oldest session"");+                logoutOldestSession(userSessions);+                context.success();+                break;+        }+    }++    private void logoutOldestSession(List<UserSessionModel> userSessions) {+        logger.info(""Logging out oldest session"");+        Optional<UserSessionModel> oldest = userSessions.stream().sorted(Comparator.comparingInt(UserSessionModel::getStarted)).findFirst();","Is it possible to use `getLastSessionRefresh` instead of `getStarted` ? This means that the session, which was not used for the longest time would be removed by default. WDYT? If you strongly prefer `started`, then we can consider having the configuration option for this, however IMO `lastSessionRefresh` will be better for most of the use-cases.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8260,794358129,2022-01-28T09:58:34Z,services/src/main/java/org/keycloak/authentication/authenticators/sessionlimits/UserSessionLimitsAuthenticatorFactory.java,"@@ -0,0 +1,109 @@+package org.keycloak.authentication.authenticators.sessionlimits;++import org.keycloak.Config;+import org.keycloak.authentication.Authenticator;+import org.keycloak.authentication.AuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.KeycloakSessionFactory;+import org.keycloak.provider.ProviderConfigProperty;++import java.util.Arrays;+import java.util.List;++public class UserSessionLimitsAuthenticatorFactory implements AuthenticatorFactory {+    public static final String USER_REALM_LIMIT = ""userRealmLimit"";+    public static final String USER_CLIENT_LIMIT = ""userClientLimit"";+    public static final String BEHAVIOR = ""behavior"";+    public static final String DENY_NEW_SESSION = ""Deny new session"";+    public static final String TERMINATE_OLDEST_SESSION = ""Terminate oldest session"";+    public static final String USER_SESSION_LIMITS = ""user-session-limits"";+    public static final String ERROR_MESSAGE = ""errorMessage"";++    private static AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {+            AuthenticationExecutionModel.Requirement.REQUIRED,+            AuthenticationExecutionModel.Requirement.DISABLED+    };++    @Override+    public String getDisplayType() {+        return ""User session count limiter"";+    }++    @Override+    public String getReferenceCategory() {+        return null;+    }++    @Override+    public boolean isConfigurable() {+        return true;+    }++    @Override+    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {+        return REQUIREMENT_CHOICES;+    }++    @Override+    public boolean isUserSetupAllowed() {+        return false;+    }++    @Override+    public String getHelpText() {+        return ""Configures how many concurrent sessions a single user is allowed to create for this realm and/or client"";+    }++    @Override+    public List<ProviderConfigProperty> getConfigProperties() {+        ProviderConfigProperty userRealmLimit = new ProviderConfigProperty();+        userRealmLimit.setName(USER_REALM_LIMIT);+        userRealmLimit.setLabel(""Maximum concurrent sessions for each user"");",Note: Will be good to have a chance to disable realm limit for the case when guys want to use only per-client limit. Hence also add something to the tooltip like `Use 0 or negative value to not have limits per realm` .And similar for the USER_CLIENT_LIMIT . Also adjust the functionality accordingly. WDYT?,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8260,794359496,2022-01-28T10:00:22Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/sessionlimits/UserSessionLimitsTest.java,"@@ -0,0 +1,145 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.sessionlimits;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Before;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.authentication.authenticators.browser.UsernamePasswordFormFactory;+import org.keycloak.authentication.authenticators.sessionlimits.UserSessionLimitsAuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.AuthenticationFlowModel;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.RealmModel;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.pages.LoginPage;+import org.keycloak.testsuite.util.RealmBuilder;+import org.keycloak.testsuite.util.UserBuilder;++import java.util.HashMap;+import java.util.Map;+import org.junit.Assert;+import org.keycloak.testsuite.pages.AppPage;+import org.keycloak.testsuite.pages.ErrorPage;++public class UserSessionLimitsTest extends AbstractTestRealmKeycloakTest {",I believe this will need to have something like `@AuthServerContainerExclude(REMOTE)` at the top as AFAIK the setup of authentication flows with `testingClient.server.run()` probably won't work on the remote server. See some other classes in the testsuite for the inspiration (This annotation can be probably just added to the top of the class).,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8260,794359931,2022-01-28T10:00:58Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/sessionlimits/UserSessionLimitsTest.java,"@@ -0,0 +1,145 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.sessionlimits;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Before;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.authentication.authenticators.browser.UsernamePasswordFormFactory;+import org.keycloak.authentication.authenticators.sessionlimits.UserSessionLimitsAuthenticatorFactory;+import org.keycloak.models.AuthenticationExecutionModel;+import org.keycloak.models.AuthenticationFlowModel;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.RealmModel;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.pages.LoginPage;+import org.keycloak.testsuite.util.RealmBuilder;+import org.keycloak.testsuite.util.UserBuilder;++import java.util.HashMap;+import java.util.Map;+import org.junit.Assert;+import org.keycloak.testsuite.pages.AppPage;+import org.keycloak.testsuite.pages.ErrorPage;++public class UserSessionLimitsTest extends AbstractTestRealmKeycloakTest {++    private static final String LOGINTEST1 = ""login-test-1"";+    private static final String PASSWORD1 = ""password1"";++    private static final String ERROR_TO_DISPLAY = ""This account has too many sessions"";++    @Override+    public void configureTestRealm(RealmRepresentation testRealm) {+        UserRepresentation user1 = UserBuilder.create()+                .id(LOGINTEST1)+                .username(LOGINTEST1)+                .email(""login1@test.com"")+                .enabled(true)+                .password(PASSWORD1)+                .build();+        RealmBuilder.edit(testRealm).user(user1);+    }++    @Before+    public void setupFlows() {+        // Do this just once per class+        if (testContext.isInitialized()) {+            return;+        }+        testingClient.server().run(session -> {+            RealmModel realm = session.realms().getRealmByName(""test"");++            if (realm.getBrowserFlow().getAlias().equals(""parent-flow"")) {",Minor: This can be simplified a bit with `FlowUtil` class. For example see `BrowserFlowTest` class for the inspiration.,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9840,794516645,2022-01-28T13:47:21Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/infinispan/CacheExpirationTest.java,"@@ -51,69 +51,75 @@ @RequireProvider(InfinispanConnectionProvider.class) public class CacheExpirationTest extends KeycloakModelTest { +    public static final int NUM_THREADS = 4;+     @Test     public void testCacheExpiration() throws Exception {-        AtomicLong putTime = new AtomicLong();++        log.debug(""Put two events to the main cache"");         inComittedTransaction(session -> {             InfinispanConnectionProvider provider = session.getProvider(InfinispanConnectionProvider.class);             Cache<String, Object> cache = provider.getCache(InfinispanConnectionProvider.WORK_CACHE_NAME);             cache.entrySet().stream()               .filter(me -> me.getValue() instanceof AuthenticationSessionAuthNoteUpdateEvent)               .forEach((c, me) -> c.remove(me.getKey())); -            putTime.set(System.currentTimeMillis());             cache.put(""1-2"", AuthenticationSessionAuthNoteUpdateEvent.create(""g1"", ""p1"", ""r1"", Collections.emptyMap()), 20000, TimeUnit.MILLISECONDS);             cache.put(""1-2-3"", AuthenticationSessionAuthNoteUpdateEvent.create(""g2"", ""p2"", ""r2"", Collections.emptyMap()), 20000, TimeUnit.MILLISECONDS);         }); +        AtomicInteger completedTests = new AtomicInteger(0);+         assumeThat(""jmap output format unsupported"", getNumberOfInstancesOfClass(AuthenticationSessionAuthNoteUpdateEvent.class), notNullValue()); -        // Infinispan server is decoding the client request before processing the request at the cache level,-        // therefore there are sometimes three instances of AuthenticationSessionAuthNoteUpdateEvent class in the memory-        assertThat(getNumberOfInstancesOfClass(AuthenticationSessionAuthNoteUpdateEvent.class), greaterThanOrEqualTo(2));+        log.debug(""Starting other nodes and see that they join, receive the data and have their data expired""); -        AtomicInteger maxCountOfInstances = new AtomicInteger();-        AtomicInteger minCountOfInstances = new AtomicInteger(100);-        inIndependentFactories(4, 5 * 60, () -> {+        inIndependentFactories(NUM_THREADS, 5 * 60, () -> {             log.debug(""Joining the cluster"");             inComittedTransaction(session -> {                 InfinispanConnectionProvider provider = session.getProvider(InfinispanConnectionProvider.class);                 Cache<String, Object> cache = provider.getCache(InfinispanConnectionProvider.WORK_CACHE_NAME);++                log.debug(""Waiting for caches to join the cluster"");                 do {                     try { Thread.sleep(1000); } catch (InterruptedException ex) { Thread.currentThread().interrupt(); throw new RuntimeException(ex); }                 } while (! cache.getAdvancedCache().getDistributionManager().isJoinComplete());-                cache.keySet().forEach(s -> {});-            });-            String site = CONFIG.scope(""connectionsInfinispan"", ""default"").get(""siteName"");-            log.debug(""Cluster joined "" + site);--            // access the items in the local cache in the different site (site-2) in order to fetch them from the remote cache-            if (""site-2"".equals(site)) {-                inComittedTransaction(session -> {-                    InfinispanConnectionProvider provider = session.getProvider(InfinispanConnectionProvider.class);-                    Cache<String, Object> cache = provider.getCache(InfinispanConnectionProvider.WORK_CACHE_NAME);-                    cache.get(""1-2"");-                    cache.get(""1-2-3"");-                });-            }-            int c = getNumberOfInstancesOfClass(AuthenticationSessionAuthNoteUpdateEvent.class);-            maxCountOfInstances.getAndAccumulate(c, Integer::max);-            assumeThat(""Seems we're running on a way too slow a computer"", System.currentTimeMillis() - putTime.get(), Matchers.lessThan(20000L));--            // Wait for at most 3 minutes which is much more than 15 seconds expiration set in DefaultInfinispanConnectionProviderFactory-            for (int i = 0; i < 3 * 60; i++) {-                try { Thread.sleep(1000); } catch (InterruptedException ex) { Thread.currentThread().interrupt(); throw new RuntimeException(ex); }-                if (getNumberOfInstancesOfClass(AuthenticationSessionAuthNoteUpdateEvent.class) == 0) {-                    break;-                }-            } -            c = getNumberOfInstancesOfClass(AuthenticationSessionAuthNoteUpdateEvent.class);-            minCountOfInstances.getAndAccumulate(c, Integer::min);+                String site = CONFIG.scope(""connectionsInfinispan"", ""default"").get(""siteName"");+                log.debug(""Cluster joined "" + site);++                log.debug(""Waiting for cache to receive the two elements within the cluster"");+                do {+                    try { Thread.sleep(1000); } catch (InterruptedException ex) { Thread.currentThread().interrupt(); throw new RuntimeException(ex); }+                } while (cache.entrySet().stream()+                        .filter(me -> me.getValue() instanceof AuthenticationSessionAuthNoteUpdateEvent)+                        .count() != 2);++                assertThat(cache.get(""1-2""), notNullValue());+                assertThat(cache.get(""1-2-3""), notNullValue());++                log.debug(""Waiting two elements to expire"");+                do {+                    try { Thread.sleep(1000); } catch (InterruptedException ex) { Thread.currentThread().interrupt(); throw new RuntimeException(ex); }+                } while (cache.entrySet().stream()","This change is now no longer part of this PR, it will be part of another PR.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9746,794528327,2022-01-28T14:01:49Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/JpaClientMapKeycloakTransaction.java,"@@ -16,146 +16,53 @@  */ package org.keycloak.models.map.storage.jpa.client; -import java.util.LinkedList;-import java.util.List;-import java.util.UUID; import java.util.stream.Stream; import javax.persistence.EntityManager; import javax.persistence.criteria.CriteriaBuilder;-import javax.persistence.criteria.CriteriaDelete; import javax.persistence.criteria.CriteriaQuery;-import javax.persistence.criteria.Order; import javax.persistence.criteria.Root;-import org.keycloak.connections.jpa.JpaKeycloakTransaction; import org.keycloak.models.ClientModel;-import static org.keycloak.models.jpa.PaginationUtils.paginateQuery; import org.keycloak.models.map.client.MapClientEntity; import org.keycloak.models.map.client.MapClientEntityDelegate;-import org.keycloak.models.map.common.StringKeyConvertor.UUIDKey; import org.keycloak.models.map.storage.jpa.client.delegate.JpaClientDelegateProvider; import org.keycloak.models.map.storage.jpa.client.entity.JpaClientEntity;-import static org.keycloak.models.map.storage.jpa.JpaMapStorageProviderFactory.CLONER;-import org.keycloak.models.map.storage.MapKeycloakTransaction; import org.keycloak.models.map.storage.QueryParameters; import static org.keycloak.models.map.storage.jpa.Constants.SUPPORTED_VERSION_CLIENT;-import static org.keycloak.utils.StreamsUtil.closing;+import org.keycloak.models.map.storage.jpa.JpaMapKeycloakTransaction;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.JpaRootEntity; -public class JpaClientMapKeycloakTransaction extends JpaKeycloakTransaction implements MapKeycloakTransaction<MapClientEntity, ClientModel> {+public class JpaClientMapKeycloakTransaction extends JpaMapKeycloakTransaction<JpaClientEntity, MapClientEntity, ClientModel> { +    @SuppressWarnings(""unchecked"")     public JpaClientMapKeycloakTransaction(EntityManager em) {-        super(em);+        super(JpaClientEntity.class, em);     }      @Override-    public MapClientEntity create(MapClientEntity mapEntity) {-        JpaClientEntity jpaEntity = (JpaClientEntity) CLONER.from(mapEntity);-        if (mapEntity.getId() == null) {-            jpaEntity.setId(UUIDKey.INSTANCE.yieldNewUniqueKey().toString());-        }-        jpaEntity.setEntityVersion(SUPPORTED_VERSION_CLIENT);-        em.persist(jpaEntity);-        return jpaEntity;-    }--    @Override-    public MapClientEntity read(String key) {-        if (key == null) return null;-        UUID uuid = UUIDKey.INSTANCE.fromStringSafe(key);-        if (uuid == null) return null;--        return em.find(JpaClientEntity.class, uuid);+    public Stream<MapClientEntity> read(QueryParameters<ClientModel> queryParameters) {+        return super.readByQueryParameters(queryParameters).map(e -> new MapClientEntityDelegate(new JpaClientDelegateProvider(e, em)));     }      @Override-    public Stream<MapClientEntity> read(QueryParameters<ClientModel> queryParameters) {-        JpaClientModelCriteriaBuilder mcb = queryParameters.getModelCriteriaBuilder()-                .flashToModelCriteriaBuilder(new JpaClientModelCriteriaBuilder());--        CriteriaBuilder cb = em.getCriteriaBuilder();-        CriteriaQuery<JpaClientEntity> query = cb.createQuery(JpaClientEntity.class);-        Root<JpaClientEntity> root = query.from(JpaClientEntity.class);+    public void selectCbConstruct(CriteriaQuery<JpaClientEntity> query, CriteriaBuilder cb, Root<JpaClientEntity> root) {","Could this only be the following?```java        return cb.construct(JpaClientEntity.class,             root.get(""id""),             root.get(""entityVersion""),             root.get(""realmId""),             root.get(""clientId""),             root.get(""protocol""),             root.get(""enabled""));        ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9746,794542080,2022-01-28T14:17:44Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapKeycloakTransaction.java,"@@ -0,0 +1,164 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.LinkedList;+import java.util.List;+import java.util.UUID;+import java.util.function.BiFunction;+import java.util.stream.Stream;+import javax.persistence.EntityManager;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.CriteriaDelete;+import javax.persistence.criteria.CriteriaQuery;+import javax.persistence.criteria.Order;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.connections.jpa.JpaKeycloakTransaction;+import static org.keycloak.models.jpa.PaginationUtils.paginateQuery;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.common.StringKeyConvertor.UUIDKey;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.QueryParameters;+import static org.keycloak.models.map.storage.jpa.JpaMapStorageProviderFactory.CLONER;+import static org.keycloak.utils.StreamsUtil.closing;++public abstract class JpaMapKeycloakTransaction<E extends JpaRootEntity, MapEntity extends AbstractEntity, M> extends JpaKeycloakTransaction implements MapKeycloakTransaction<MapEntity, M> {","Please avoid type parameter names that can be confused for real class names.Also `E` is often used for map entity type in other classes, so it would be better to use some other name```suggestionpublic abstract class JpaMapKeycloakTransaction<RE extends JpaRootEntity, E extends AbstractEntity, M> extends JpaKeycloakTransaction implements MapKeycloakTransaction<E, M> {```",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9761,794584161,2022-01-28T15:04:49Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -107,7 +107,6 @@ public static RealmRepresentation exportRealm(KeycloakSession session, RealmMode          if (options.isClientsIncluded()) {             clients = realm.getClientsStream()-              .filter(c -> { try { c.getClientId(); return true; } catch (Exception ex) { return false; } } )","Hi @hmlnarik, I did this change intentionally as stated above, see my comment: > ExportUtils will fail if a client can't be exported ... this changes the existing behavior, but seems to be reasonable as exportutils should export everything, and no clients should be missing.I now change the code as you requested. As the code needs a list of ClientModels later to process groups etc., the code is now a bit more complex to construct the list of client models that are valid client representations. Please let me know what you think.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9761,794590344,2022-01-28T15:11:56Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -107,7 +107,6 @@ public static RealmRepresentation exportRealm(KeycloakSession session, RealmMode          if (options.isClientsIncluded()) {             clients = realm.getClientsStream()-              .filter(c -> { try { c.getClientId(); return true; } catch (Exception ex) { return false; } } )","A client might be missing permanently, leading to permanently thrown exception, and throwing an exception effectively removes ability to run export; so I'd rather keep it as is with your current changes.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9761,794592613,2022-01-28T15:14:38Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -103,15 +101,17 @@ public static RealmRepresentation exportRealm(KeycloakSession session, RealmMode                 .map(ClientScopeModel::getName).collect(Collectors.toList()));          // Clients-        List<ClientModel> clients = Collections.emptyList();+        List<ClientModel> clients = new ArrayList<>();",Please either use `ArrayList(int initialCapacity)` or prefer `LinkedList` since the list is only added to and iterated.,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9761,794595377,2022-01-28T15:17:50Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -107,7 +107,6 @@ public static RealmRepresentation exportRealm(KeycloakSession session, RealmMode          if (options.isClientsIncluded()) {             clients = realm.getClientsStream()-              .filter(c -> { try { c.getClientId(); return true; } catch (Exception ex) { return false; } } )","I could see a situation where someone would be happy to know about this problem by seeing the exception, and I also see the case you make here. When you're happy with the change, then please resolve this thread. ",
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/9478,794607939,2022-01-28T15:31:35Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,173 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Understanding Server Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at <@links.server id=""all-config""/>.++Configuration options are loaded from different sources in a specific order and they use different formats:++|===+|*Source* | *Format*++|CLI+|--<category>-<sub-category>-<property>=<value>++|Environment Variable+|KC_CATEGORY_SUB_CATEGORY_PROPERTY++|`conf/keycloak.conf`+|<category>-<sub-category>-<property>=<value>+|===++By taking the `db-url-host` option as an example, you would set this property as follows:++.Command-line argument+<@kc.all parameters=""--db-url-host=mykeycloakdb""/>++.Environment variable+```+export KC_DB_URL_HOST=mykeycloakdb+```++.`conf/keycloak.conf`+```+db-url-host=mykeycloakdb+```++The configuration source and the corresponding format you should use is use-case specific. It depends on the platform the server is deployed to","""It"" is ambiguous. To clarify change it to ""That decision....""",
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/9478,794629796,2022-01-28T15:55:26Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,173 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Understanding Server Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at <@links.server id=""all-config""/>.++Configuration options are loaded from different sources in a specific order and they use different formats:++|===+|*Source* | *Format*++|CLI+|--<category>-<sub-category>-<property>=<value>++|Environment Variable+|KC_CATEGORY_SUB_CATEGORY_PROPERTY++|`conf/keycloak.conf`+|<category>-<sub-category>-<property>=<value>+|===++By taking the `db-url-host` option as an example, you would set this property as follows:++.Command-line argument+<@kc.all parameters=""--db-url-host=mykeycloakdb""/>++.Environment variable+```+export KC_DB_URL_HOST=mykeycloakdb+```++.`conf/keycloak.conf`+```+db-url-host=mykeycloakdb+```++The configuration source and the corresponding format you should use is use-case specific. It depends on the platform the server is deployed to+as well as on the optimizations you can get for an optimal runtime.++== Configuration Stages++The server options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and is related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++Configuration is basically done in two stages:++* Before starting the server in order to build an optimized server image for an optimal runtime+* When starting the server++The first stage involves running the `build` command using any **build option** available from this command. On the other hand, the second stage involves+starting the server using any **configuration option** available from the `start` command.++== Configuring the server++The clear separation between build options and configuration options is one of the key aspects+of the server configuration and related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++The first step when configuring the server is to use the `build` command to set any build option you want to change. For instance, to choose a specific database vendor.+By looking at the individual configuration options at <@links.server id=""all-config""/>, you notice+that some options are marked with an icon to indicate they are a build option. In other words, they can only be set and only take effect when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++The `build` command is responsible for producing an immutable and optimized server image (similar concept to building a container image). In addition to persisting","Change (similar concept to building a container image)to , which is similar concept to building a container image.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9478,794631233,2022-01-28T15:56:55Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,173 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+configuration options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Understanding Server Options++All the available configuration options can be found by either running the `help` command for individual commands:++<@kc.all parameters=""--help""/>++Or by looking at all the configuration options at <@links.server id=""all-config""/>.++Configuration options are loaded from different sources in a specific order and they use different formats:++|===+|*Source* | *Format*++|CLI+|--<category>-<sub-category>-<property>=<value>++|Environment Variable+|KC_CATEGORY_SUB_CATEGORY_PROPERTY++|`conf/keycloak.conf`+|<category>-<sub-category>-<property>=<value>+|===++By taking the `db-url-host` option as an example, you would set this property as follows:++.Command-line argument+<@kc.all parameters=""--db-url-host=mykeycloakdb""/>++.Environment variable+```+export KC_DB_URL_HOST=mykeycloakdb+```++.`conf/keycloak.conf`+```+db-url-host=mykeycloakdb+```++The configuration source and the corresponding format you should use is use-case specific. It depends on the platform the server is deployed to+as well as on the optimizations you can get for an optimal runtime.++== Configuration Stages++The server options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and is related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++Configuration is basically done in two stages:++* Before starting the server in order to build an optimized server image for an optimal runtime+* When starting the server++The first stage involves running the `build` command using any **build option** available from this command. On the other hand, the second stage involves+starting the server using any **configuration option** available from the `start` command.++== Configuring the server++The clear separation between build options and configuration options is one of the key aspects+of the server configuration and related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++The first step when configuring the server is to use the `build` command to set any build option you want to change. For instance, to choose a specific database vendor.+By looking at the individual configuration options at <@links.server id=""all-config""/>, you notice+that some options are marked with an icon to indicate they are a build option. In other words, they can only be set and only take effect when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++The `build` command is responsible for producing an immutable and optimized server image (similar concept to building a container image). In addition to persisting","isn't it "", which is _a_ similar concept to building...""? ;)",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9849,794684596,2022-01-28T16:54:21Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakRealmJob.java,"@@ -0,0 +1,206 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.*;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.api.model.batch.v1.Job;+import io.fabric8.kubernetes.api.model.batch.v1.JobBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.utils.KubernetesResourceUtil;+import io.quarkus.logging.Log;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealm;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealmStatusBuilder;++import java.util.List;+import java.util.Optional;++public class KeycloakRealmJob extends OperatorManagedResource {++    private final KeycloakRealm realmCR;+    private final Deployment existingDeployment;+    private final Job existingJob;+    private final String secretName;+    private final String volumeName;++    public KeycloakRealmJob(KubernetesClient client, KeycloakRealm realmCR, String secretName) {+        super(client, realmCR);+        this.realmCR = realmCR;+        this.secretName = secretName;+        this.volumeName = KubernetesResourceUtil.sanitizeName(secretName + ""-volume"");++        this.existingJob = fetchExistingJob();+        this.existingDeployment = fetchExistingDeployment();+    }++    @Override+    protected Optional<HasMetadata> getReconciledResource() {+        if (existingJob == null) {+            Log.info(""Creating a new Job"");+            return Optional.of(createImportJob());+        } else {+            Log.info(""Job already available"");+            return Optional.empty();+        }+    }++    private Job fetchExistingJob() {+        return client+                .batch()+                .v1()+                .jobs()+                .inNamespace(getNamespace())+                .withName(getName())+                .get();+    }++    private Deployment fetchExistingDeployment() {+        return client+                .apps()+                .deployments()+                .inNamespace(getNamespace())+                .withName(getKeycloakName())+                .get();+    }++    private Job buildJob(Container keycloakContainer, Volume secretVolume) {+        return new JobBuilder()+                .withNewMetadata()+                .withName(getName())+                .withNamespace(getNamespace())+                .endMetadata()+                .withNewSpec()+                .withNewTemplate()+                .withNewSpec()+                .withContainers(keycloakContainer)+                .addToVolumes(secretVolume)+                .withRestartPolicy(""Never"")+                .endSpec()+                .endTemplate()+                .endSpec()+                .build();+    }++    private Volume buildSecretVolume() {+        return new VolumeBuilder()+                .withName(volumeName)+                .withSecret(new SecretVolumeSourceBuilder()+                        .withSecretName(secretName)+                        .build())+                .build();+    }++    private Job createImportJob() {+        var keycloakContainer = buildKeycloakJobContainer();+        var secretVolume = buildSecretVolume();+        var importJob = buildJob(keycloakContainer, secretVolume);++        return importJob;+    }++    private Container buildKeycloakJobContainer() {+        var keycloakContainer =+            this+                .existingDeployment+                .getSpec()+                .getTemplate()+                .getSpec()+                .getContainers()+                .get(0);","If there's no existing deployment, this will result in an NPE. I know we're handling this case in the status below, but this is still an uncaught exception which will cause the reconcile loop to fail even before calling `updateStatus`.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9849,794699153,2022-01-28T17:13:55Z,operator/src/main/resources/base-keycloak-deployment.yaml,"@@ -29,14 +29,25 @@ spec:         livenessProbe:           exec:             command:-              - curl --head --fail --silent http://127.0.0.1:8080/health/live+              - curl+              - --head+              - --fail+              - --silent+              - http://localhost:8080/health/live           periodSeconds: 1+          failureThreshold: 10+          initialDelaySeconds: 30         readinessProbe:           exec:             command:-              - curl --head --fail --silent http://127.0.0.1:8080/health/ready+              - curl+              - --head+              - --fail+              - --silent+              - http://localhost:8080/health/ready           periodSeconds: 1-          failureThreshold: 180+          failureThreshold: 10",This is effectively just 10 secs. What if the server is taking longer to boot?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9849,794699473,2022-01-28T17:14:21Z,operator/src/main/resources/base-keycloak-deployment.yaml,"@@ -29,14 +29,25 @@ spec:         livenessProbe:           exec:             command:-              - curl --head --fail --silent http://127.0.0.1:8080/health/live+              - curl+              - --head+              - --fail+              - --silent+              - http://localhost:8080/health/live           periodSeconds: 1+          failureThreshold: 10",This is effectively just 10 secs. What if the server is taking longer to boot?,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9849,794731648,2022-01-28T17:51:47Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakRealmJob.java,"@@ -0,0 +1,206 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.*;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.api.model.batch.v1.Job;+import io.fabric8.kubernetes.api.model.batch.v1.JobBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.utils.KubernetesResourceUtil;+import io.quarkus.logging.Log;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealm;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealmStatusBuilder;++import java.util.List;+import java.util.Optional;++public class KeycloakRealmJob extends OperatorManagedResource {++    private final KeycloakRealm realmCR;+    private final Deployment existingDeployment;+    private final Job existingJob;+    private final String secretName;+    private final String volumeName;++    public KeycloakRealmJob(KubernetesClient client, KeycloakRealm realmCR, String secretName) {+        super(client, realmCR);+        this.realmCR = realmCR;+        this.secretName = secretName;+        this.volumeName = KubernetesResourceUtil.sanitizeName(secretName + ""-volume"");++        this.existingJob = fetchExistingJob();+        this.existingDeployment = fetchExistingDeployment();+    }++    @Override+    protected Optional<HasMetadata> getReconciledResource() {+        if (existingJob == null) {+            Log.info(""Creating a new Job"");+            return Optional.of(createImportJob());+        } else {+            Log.info(""Job already available"");+            return Optional.empty();+        }+    }++    private Job fetchExistingJob() {+        return client+                .batch()+                .v1()+                .jobs()+                .inNamespace(getNamespace())+                .withName(getName())+                .get();+    }++    private Deployment fetchExistingDeployment() {+        return client+                .apps()+                .deployments()+                .inNamespace(getNamespace())+                .withName(getKeycloakName())+                .get();+    }++    private Job buildJob(Container keycloakContainer, Volume secretVolume) {+        return new JobBuilder()+                .withNewMetadata()+                .withName(getName())+                .withNamespace(getNamespace())+                .endMetadata()+                .withNewSpec()+                .withNewTemplate()+                .withNewSpec()+                .withContainers(keycloakContainer)+                .addToVolumes(secretVolume)+                .withRestartPolicy(""Never"")+                .endSpec()+                .endTemplate()+                .endSpec()+                .build();+    }++    private Volume buildSecretVolume() {+        return new VolumeBuilder()+                .withName(volumeName)+                .withSecret(new SecretVolumeSourceBuilder()+                        .withSecretName(secretName)+                        .build())+                .build();+    }++    private Job createImportJob() {+        var keycloakContainer = buildKeycloakJobContainer();+        var secretVolume = buildSecretVolume();+        var importJob = buildJob(keycloakContainer, secretVolume);++        return importJob;+    }++    private Container buildKeycloakJobContainer() {+        var keycloakContainer =+            this+                .existingDeployment+                .getSpec()+                .getTemplate()+                .getSpec()+                .getContainers()+                .get(0);++        var importMntPath = ""/mnt/realm-import/"";++        var command = List.of(""/bin/bash"");++        var commandArgs = List.of(""-c"",+                ""/opt/keycloak/bin/kc.sh build && "" ++                    ""/opt/keycloak/bin/kc.sh import --file='"" + importMntPath + getRealmName() + ""-realm.json' --override=true"");","I have been going forth and back in this decision, let's discuss what's the desired behaviour.Maybe I should add this as a parameter in the CR?",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/9761,794764420,2022-01-28T18:41:21Z,server-spi/src/main/java/org/keycloak/models/ModelIllegalStateException.java,"@@ -0,0 +1,49 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models;++import java.util.function.Function;+import java.util.stream.Stream;++/**+ * Thrown when data can't be retrieved for the model.+ *+ * This occurs when an entity has been removed or update in the meantime. This might wrap an optimistic lock exception",```suggestion * This occurs when an entity has been removed or updated in the meantime. This might wrap an optimistic lock exception```,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/9761,794766626,2022-01-28T18:45:08Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -71,11 +60,20 @@ import org.keycloak.representations.idm.authorization.ScopeRepresentation; import org.keycloak.util.JsonSerialization; -import com.fasterxml.jackson.core.JsonEncoding;-import com.fasterxml.jackson.core.JsonFactory;-import com.fasterxml.jackson.core.JsonGenerator;-import com.fasterxml.jackson.databind.ObjectMapper;-import com.fasterxml.jackson.databind.SerializationFeature;+import java.io.IOException;+import java.io.OutputStream;+import java.util.ArrayList;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;","@hmlnarik Do we have a template for the imports? Some files in the codebase have the java and javax packages first, others have them at the end of the imports list. Just wondering because IIRC we've been keeping java and javax at the top.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/9761,794771909,2022-01-28T18:53:20Z,services/src/main/java/org/keycloak/services/resources/admin/ClientsResource.java,"@@ -87,9 +86,11 @@ public ClientsResource(RealmModel realm, AdminPermissionEvaluator auth, AdminEve     }      /**-     * Get clients belonging to the realm+     * Get clients belonging to the realm.      *-     * Returns a list of clients belonging to the realm+     * Returns a list of clients belonging to the realm. If a clients can't be retrieved from the storage due",```suggestion     * Returns a list of clients belonging to the realm. If a client can't be retrieved from the storage due```,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9746,794775503,2022-01-28T18:58:44Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapKeycloakTransaction.java,"@@ -0,0 +1,164 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.LinkedList;+import java.util.List;+import java.util.UUID;+import java.util.function.BiFunction;+import java.util.stream.Stream;+import javax.persistence.EntityManager;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.CriteriaDelete;+import javax.persistence.criteria.CriteriaQuery;+import javax.persistence.criteria.Order;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.connections.jpa.JpaKeycloakTransaction;+import static org.keycloak.models.jpa.PaginationUtils.paginateQuery;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.common.StringKeyConvertor.UUIDKey;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.QueryParameters;+import static org.keycloak.models.map.storage.jpa.JpaMapStorageProviderFactory.CLONER;+import static org.keycloak.utils.StreamsUtil.closing;++public abstract class JpaMapKeycloakTransaction<E extends JpaRootEntity, MapEntity extends AbstractEntity, M> extends JpaKeycloakTransaction implements MapKeycloakTransaction<MapEntity, M> {++    private final Class<E> entityType;++    @SuppressWarnings(""unchecked"")+    public JpaMapKeycloakTransaction(Class<E> entityType, EntityManager em) {+        super(em);+        this.entityType = entityType;+    }++    protected abstract void selectCbConstruct(CriteriaQuery<E> query, CriteriaBuilder cb, Root<E> root);+    protected abstract void setEntityVersion(JpaRootEntity entity);","It's not known what entity we're dealing with. It could be used directly if we introduce mapping between jpa entity and its supported version. Something like following```    private static final Map<Class<? extends JpaRootEntity>, Integer> ENTITY_SUPPORTED_VERSION = new HashMap<>();    static {        ENTITY_SUPPORTED_VERSION.put(JpaClientScopeEntity.class,       Constants.SUPPORTED_VERSION_CLIENT_SCOPE);        ENTITY_SUPPORTED_VERSION.put(JpaClientEntity.class,            Constants.SUPPORTED_VERSION_CLIENT);        ENTITY_SUPPORTED_VERSION.put(JpaRoleEntity.class,              Constants.SUPPORTED_VERSION_ROLE);    }```Then it could be called like `jpaEntity.setEntityVersion(ENTITY_SUPPORTED_VERSION.get(entityType));`wdyt?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9746,794794184,2022-01-28T19:27:13Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapKeycloakTransaction.java,"@@ -0,0 +1,168 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.LinkedList;+import java.util.List;+import java.util.UUID;+import java.util.function.BiFunction;+import java.util.stream.Stream;+import javax.persistence.EntityManager;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.CriteriaDelete;+import javax.persistence.criteria.CriteriaQuery;+import javax.persistence.criteria.Order;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import javax.persistence.criteria.Selection;+import org.keycloak.connections.jpa.JpaKeycloakTransaction;+import static org.keycloak.models.jpa.PaginationUtils.paginateQuery;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.common.StringKeyConvertor.UUIDKey;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.QueryParameters;+import static org.keycloak.models.map.storage.jpa.JpaMapStorageProviderFactory.CLONER;+import static org.keycloak.utils.StreamsUtil.closing;++public abstract class JpaMapKeycloakTransaction<RE extends JpaRootEntity, E extends AbstractEntity, M> extends JpaKeycloakTransaction implements MapKeycloakTransaction<E, M> {","Wondering if this should be?```suggestionpublic abstract class JpaMapKeycloakTransaction<E extends AbstractEntity, RE extends E & JpaRootEntity, M> extends JpaKeycloakTransaction implements MapKeycloakTransaction<E, M> {```",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/9746,794895833,2022-01-28T21:18:52Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/clientscope/entity/JpaClientScopeMetadata.java,"@@ -0,0 +1,43 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.clientscope.entity;++import java.io.Serializable;+import org.keycloak.models.map.clientscope.MapClientScopeEntityImpl;+import org.keycloak.models.map.common.DeepCloner;++public class JpaClientScopeMetadata extends MapClientScopeEntityImpl implements Serializable {","Just to double check: this entityVersion tha we include in every metadata class can't be moved into the corresponding Map*Impl because it is JPA specific, right?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9883,795017804,2022-01-29T07:27:03Z,docs/guides/src/main/server/containers.adoc,"@@ -100,8 +109,10 @@ podman|docker run --name keycloak_auto_build -p 8080:8080 \         --https-key-store-file=<file> --https-key-store-password=<password> ---- -Running the above will spin up a Keycloak server which detects and applies the build configuration first. In the example, it's  `--db=postgres --features=token-exchange` to set the used database vendor to postgres and enable the token exchange feature.+Running this command starts a Keycloak server that detects and applies the build configuration first.","```suggestionRunning this command starts a Keycloak server that detects and applies the build options first.```See #9709 for details about the general naming. ""Build configuration"" might be a bit ambiguous here.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9746,795163322,2022-01-30T10:56:02Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/clientscope/entity/JpaClientScopeMetadata.java,"@@ -0,0 +1,43 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.clientscope.entity;++import java.io.Serializable;+import org.keycloak.models.map.clientscope.MapClientScopeEntityImpl;+import org.keycloak.models.map.common.DeepCloner;++public class JpaClientScopeMetadata extends MapClientScopeEntityImpl implements Serializable {",I believe it's not just jpa specific. Each implementation should maintain an [_entity schema version_](https://github.com/keycloak/keycloak-community/blob/main/design/keycloak.x/storage-persistence.md#-version-compatibility-vc). IMO it requires wider discussion.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9746,795239777,2022-01-30T19:47:57Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/clientscope/entity/JpaClientScopeMetadata.java,"@@ -0,0 +1,43 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.clientscope.entity;++import java.io.Serializable;+import org.keycloak.models.map.clientscope.MapClientScopeEntityImpl;+import org.keycloak.models.map.common.DeepCloner;++public class JpaClientScopeMetadata extends MapClientScopeEntityImpl implements Serializable {","It is specific to a particular implementation. Several implementations could share the same mechanism of versioning entities - then they could leverage the same entity schema version. This however cannot be applied generally to _every_ implementations, thus it cannot be moved into any of the generic map classes (including `Map*Impl`)",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9761,795403704,2022-01-31T07:38:22Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -71,11 +60,20 @@ import org.keycloak.representations.idm.authorization.ScopeRepresentation; import org.keycloak.util.JsonSerialization; -import com.fasterxml.jackson.core.JsonEncoding;-import com.fasterxml.jackson.core.JsonFactory;-import com.fasterxml.jackson.core.JsonGenerator;-import com.fasterxml.jackson.databind.ObjectMapper;-import com.fasterxml.jackson.databind.SerializationFeature;+import java.io.IOException;+import java.io.OutputStream;+import java.util.ArrayList;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;","I had the auto-format for imports enabled when I missed some unused imports the other day. Will revert this change, and re-calibrate my IDE. If there is some information how to configure IntelliJ, or some rules that I can translate for IntelliJ, I'd be happy to do so. Another rule I learned in another review: no star imports :roll_eyes: ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9761,795446552,2022-01-31T08:48:37Z,services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java,"@@ -71,11 +60,20 @@ import org.keycloak.representations.idm.authorization.ScopeRepresentation; import org.keycloak.util.JsonSerialization; -import com.fasterxml.jackson.core.JsonEncoding;-import com.fasterxml.jackson.core.JsonFactory;-import com.fasterxml.jackson.core.JsonGenerator;-import com.fasterxml.jackson.databind.ObjectMapper;-import com.fasterxml.jackson.databind.SerializationFeature;+import java.io.IOException;+import java.io.OutputStream;+import java.util.ArrayList;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;",I don't think there is any strict rule for import ordering.Generally the aim is to keep PRs minimal and focused on the particular task so the aim is to prevent large purely syntactical changes.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9625,795586018,2022-01-31T11:38:00Z,operator/src/main/java/org/keycloak/operator/Config.java,"@@ -19,12 +19,15 @@  import io.smallrye.config.ConfigMapping; +import java.util.Optional;+ /**  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */ @ConfigMapping(prefix = ""operator"") public interface Config {     Keycloak keycloak();+    Optional<String> deployment();","This does not belong here as it is a test config. As agreed offline, please use a different config prefix (e.g. `tests.operator`) for tests.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/9802,795697949,2022-01-31T14:02:05Z,themes/src/main/resources/theme/base/login/login-oauth-grant.ftl,"@@ -18,7 +18,12 @@                 <#if oauth.clientScopesRequested??>                     <#list oauth.clientScopesRequested as clientScope>                         <li>-                            <span>${advancedMsg(clientScope.consentScreenText)}</span>+                            <span><#if !clientScope.dynamicScopeParameter??>+                                        ${advancedMsg(clientScope.consentScreenText)}+                                    <#else>+                                        ${advancedMsg(clientScope.consentScreenText)} - Dynamic Scope Parameter: <b>${clientScope.dynamicScopeParameter}</b>","I wonder that it may be more user-friendly to display some message like```Send 200 USD```instead of something like:```Sending USD - Dynamic Scope Parameter: 200```The consent screen is displayed to end users, but end-user probably won't know at all what the `Dynamic Scope Parameter` is?IMO the ideal experience is, that dynamic client scope `send-money` will have consentScreenText configured like `sendMoneyScopeTxt` . Then in `messages_en.properties` resource bundle will be some message like:```sendMoneyScopeTxt=Send {0} USD```Then in the ftl template, you would use something like:```${advancedMsg(clientScope.consentScreenText, clientScope.dynamicScopeParameter)}```This assumes single parameter, which won't be the case for the more complex RAR structures, but for parameterized scope single parameter is likely ok?I guess this can require some changes in the `AdvancedMessageFormatterMethod` utility as it seems it does not yet have support for parameters sent to the messages.WDYT?Or would you prefer to go with this one and then improve message in the follow-up PR?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9849,795701898,2022-01-31T14:06:49Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakRealmJob.java,"@@ -0,0 +1,206 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.*;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.api.model.batch.v1.Job;+import io.fabric8.kubernetes.api.model.batch.v1.JobBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.utils.KubernetesResourceUtil;+import io.quarkus.logging.Log;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealm;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealmStatusBuilder;++import java.util.List;+import java.util.Optional;++public class KeycloakRealmJob extends OperatorManagedResource {++    private final KeycloakRealm realmCR;+    private final Deployment existingDeployment;+    private final Job existingJob;+    private final String secretName;+    private final String volumeName;++    public KeycloakRealmJob(KubernetesClient client, KeycloakRealm realmCR, String secretName) {+        super(client, realmCR);+        this.realmCR = realmCR;+        this.secretName = secretName;+        this.volumeName = KubernetesResourceUtil.sanitizeName(secretName + ""-volume"");++        this.existingJob = fetchExistingJob();+        this.existingDeployment = fetchExistingDeployment();+    }++    @Override+    protected Optional<HasMetadata> getReconciledResource() {+        if (existingJob == null) {+            Log.info(""Creating a new Job"");+            return Optional.of(createImportJob());+        } else {+            Log.info(""Job already available"");+            return Optional.empty();+        }+    }++    private Job fetchExistingJob() {+        return client+                .batch()+                .v1()+                .jobs()+                .inNamespace(getNamespace())+                .withName(getName())+                .get();+    }++    private Deployment fetchExistingDeployment() {+        return client+                .apps()+                .deployments()+                .inNamespace(getNamespace())+                .withName(getKeycloakName())+                .get();+    }++    private Job buildJob(Container keycloakContainer, Volume secretVolume) {+        return new JobBuilder()+                .withNewMetadata()+                .withName(getName())+                .withNamespace(getNamespace())+                .endMetadata()+                .withNewSpec()+                .withNewTemplate()+                .withNewSpec()+                .withContainers(keycloakContainer)+                .addToVolumes(secretVolume)+                .withRestartPolicy(""Never"")+                .endSpec()+                .endTemplate()+                .endSpec()+                .build();+    }++    private Volume buildSecretVolume() {+        return new VolumeBuilder()+                .withName(volumeName)+                .withSecret(new SecretVolumeSourceBuilder()+                        .withSecretName(secretName)+                        .build())+                .build();+    }++    private Job createImportJob() {+        var keycloakContainer = buildKeycloakJobContainer();+        var secretVolume = buildSecretVolume();+        var importJob = buildJob(keycloakContainer, secretVolume);++        return importJob;+    }++    private Container buildKeycloakJobContainer() {+        var keycloakContainer =+            this+                .existingDeployment+                .getSpec()+                .getTemplate()+                .getSpec()+                .getContainers()+                .get(0);","I know, it's definitely a desired behavior to re-trigger the reconciler in this case (although AFAIK it has a few caveats, there's some threshold after which the reconciler is not re-triggered after errors). However, do we really correctly update the status? As far as I can tell, the NPE is thrown before [we even update the status with a proper message](https://github.com/keycloak/keycloak/blob/b8b10099837c6ed54dbe9b47e0273ac6cffc5a43/operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakRealmImportController.java#L85-L86). That means it will default to the [generic status error handler](https://github.com/keycloak/keycloak/blob/b8b10099837c6ed54dbe9b47e0273ac6cffc5a43/operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakRealmImportController.java#L101-L109) which will put the NPE into the status field.But of course, this is good enough for the prototype can be addressed later.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9849,795707911,2022-01-31T14:13:29Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakRealmJob.java,"@@ -0,0 +1,206 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.*;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.api.model.batch.v1.Job;+import io.fabric8.kubernetes.api.model.batch.v1.JobBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.utils.KubernetesResourceUtil;+import io.quarkus.logging.Log;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealm;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealmStatusBuilder;++import java.util.List;+import java.util.Optional;++public class KeycloakRealmJob extends OperatorManagedResource {++    private final KeycloakRealm realmCR;+    private final Deployment existingDeployment;+    private final Job existingJob;+    private final String secretName;+    private final String volumeName;++    public KeycloakRealmJob(KubernetesClient client, KeycloakRealm realmCR, String secretName) {+        super(client, realmCR);+        this.realmCR = realmCR;+        this.secretName = secretName;+        this.volumeName = KubernetesResourceUtil.sanitizeName(secretName + ""-volume"");++        this.existingJob = fetchExistingJob();+        this.existingDeployment = fetchExistingDeployment();+    }++    @Override+    protected Optional<HasMetadata> getReconciledResource() {+        if (existingJob == null) {+            Log.info(""Creating a new Job"");+            return Optional.of(createImportJob());+        } else {+            Log.info(""Job already available"");+            return Optional.empty();+        }+    }++    private Job fetchExistingJob() {+        return client+                .batch()+                .v1()+                .jobs()+                .inNamespace(getNamespace())+                .withName(getName())+                .get();+    }++    private Deployment fetchExistingDeployment() {+        return client+                .apps()+                .deployments()+                .inNamespace(getNamespace())+                .withName(getKeycloakName())+                .get();+    }++    private Job buildJob(Container keycloakContainer, Volume secretVolume) {+        return new JobBuilder()+                .withNewMetadata()+                .withName(getName())+                .withNamespace(getNamespace())+                .endMetadata()+                .withNewSpec()+                .withNewTemplate()+                .withNewSpec()+                .withContainers(keycloakContainer)+                .addToVolumes(secretVolume)+                .withRestartPolicy(""Never"")+                .endSpec()+                .endTemplate()+                .endSpec()+                .build();+    }++    private Volume buildSecretVolume() {+        return new VolumeBuilder()+                .withName(volumeName)+                .withSecret(new SecretVolumeSourceBuilder()+                        .withSecretName(secretName)+                        .build())+                .build();+    }++    private Job createImportJob() {+        var keycloakContainer = buildKeycloakJobContainer();+        var secretVolume = buildSecretVolume();+        var importJob = buildJob(keycloakContainer, secretVolume);++        return importJob;+    }++    private Container buildKeycloakJobContainer() {+        var keycloakContainer =+            this+                .existingDeployment+                .getSpec()+                .getTemplate()+                .getSpec()+                .getContainers()+                .get(0);","> But of course, this is good enough for the prototype can be addressed later.Agreed, and marking as resolved.> However, do we really correctly update the status?What you say is correct, we are possibly showing a temporary error for a few seconds, I think it's ok.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9625,795723313,2022-01-31T14:29:41Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -0,0 +1,140 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.NamespaceBuilder;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.client.Config;+import io.fabric8.kubernetes.client.ConfigBuilder;+import io.fabric8.kubernetes.client.DefaultKubernetesClient;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.javaoperatorsdk.operator.Operator;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.quarkiverse.operatorsdk.runtime.OperatorProducer;+import io.quarkiverse.operatorsdk.runtime.QuarkusConfigurationService;+import io.quarkus.logging.Log;+import org.eclipse.microprofile.config.ConfigProvider;+import org.junit.jupiter.api.AfterAll;+import org.junit.jupiter.api.BeforeAll;++import javax.enterprise.inject.Instance;+import javax.enterprise.inject.spi.CDI;+import javax.enterprise.util.TypeLiteral;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.util.List;+import java.util.UUID;++public abstract class ClusterOperatorTest {++  public static final String QUARKUS_KUBERNETES_DEPLOYMENT_TARGET = ""quarkus.kubernetes.deployment-target"";+  public static final String OPERATOR_DEPLOYMENT_PROP = ""test.operator.deployment"";+  public static final String TARGET_KUBERNETES_GENERATED_YML_FOLDER = ""target/kubernetes/"";++  public enum OperatorDeployment {local,remote}++  protected static OperatorDeployment operatorDeployment;+  protected static Instance<Reconciler<? extends HasMetadata>> reconcilers;+  protected static QuarkusConfigurationService configuration;+  protected static KubernetesClient k8sclient;+  protected static String namespace;+  protected static String deploymentTarget;+  private static Operator operator;+++  @BeforeAll+  public static void before() throws FileNotFoundException {+    configuration = CDI.current().select(QuarkusConfigurationService.class).get();+    reconcilers = CDI.current().select(new TypeLiteral<>() {});+    operatorDeployment = ConfigProvider.getConfig().getOptionalValue(OPERATOR_DEPLOYMENT_PROP, OperatorDeployment.class).orElse(OperatorDeployment.local);+    deploymentTarget = ConfigProvider.getConfig().getOptionalValue(QUARKUS_KUBERNETES_DEPLOYMENT_TARGET, String.class).orElse(""kubernetes"");++    calculateNamespace();+    createK8sClient();+    createNamespace();++    if (operatorDeployment == OperatorDeployment.remote) {+      createCRD();+      createRBACresourcesAndOperatorDeployment();+    } else {+      createOperator();+      registerReconcilers();+      operator.start();+    }++  }++  private static void createK8sClient() {+    k8sclient = new DefaultKubernetesClient(new ConfigBuilder(Config.autoConfigure(null)).withNamespace(namespace).build());+  }++  private static void createRBACresourcesAndOperatorDeployment() throws FileNotFoundException {+    Log.info(""Creating RBAC into Namespace "" + namespace);+    List<HasMetadata> hasMetadata = k8sclient.load(new FileInputStream(TARGET_KUBERNETES_GENERATED_YML_FOLDER + deploymentTarget + "".yml""))+            .inNamespace(namespace).get();+    hasMetadata.stream()+            .map(b -> {+              if (""Deployment"".equalsIgnoreCase(b.getKind()) && b.getMetadata().getName().contains(""operator"")) {+                ((Deployment) b).getSpec().getTemplate().getSpec().getContainers().get(0).setImagePullPolicy(""Never"");","This obviously can't work in our QE env, but it's ok for the prototype. We can't hold this PR due to discussions for much longer...",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9625,795729615,2022-01-31T14:36:13Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -0,0 +1,140 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.NamespaceBuilder;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.client.Config;+import io.fabric8.kubernetes.client.ConfigBuilder;+import io.fabric8.kubernetes.client.DefaultKubernetesClient;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.javaoperatorsdk.operator.Operator;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.quarkiverse.operatorsdk.runtime.OperatorProducer;+import io.quarkiverse.operatorsdk.runtime.QuarkusConfigurationService;+import io.quarkus.logging.Log;+import org.eclipse.microprofile.config.ConfigProvider;+import org.junit.jupiter.api.AfterAll;+import org.junit.jupiter.api.BeforeAll;++import javax.enterprise.inject.Instance;+import javax.enterprise.inject.spi.CDI;+import javax.enterprise.util.TypeLiteral;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.util.List;+import java.util.UUID;++public abstract class ClusterOperatorTest {++  public static final String QUARKUS_KUBERNETES_DEPLOYMENT_TARGET = ""quarkus.kubernetes.deployment-target"";+  public static final String OPERATOR_DEPLOYMENT_PROP = ""test.operator.deployment"";+  public static final String TARGET_KUBERNETES_GENERATED_YML_FOLDER = ""target/kubernetes/"";++  public enum OperatorDeployment {local,remote}++  protected static OperatorDeployment operatorDeployment;+  protected static Instance<Reconciler<? extends HasMetadata>> reconcilers;+  protected static QuarkusConfigurationService configuration;+  protected static KubernetesClient k8sclient;+  protected static String namespace;+  protected static String deploymentTarget;+  private static Operator operator;+++  @BeforeAll+  public static void before() throws FileNotFoundException {+    configuration = CDI.current().select(QuarkusConfigurationService.class).get();+    reconcilers = CDI.current().select(new TypeLiteral<>() {});+    operatorDeployment = ConfigProvider.getConfig().getOptionalValue(OPERATOR_DEPLOYMENT_PROP, OperatorDeployment.class).orElse(OperatorDeployment.local);+    deploymentTarget = ConfigProvider.getConfig().getOptionalValue(QUARKUS_KUBERNETES_DEPLOYMENT_TARGET, String.class).orElse(""kubernetes"");++    calculateNamespace();+    createK8sClient();+    createNamespace();++    if (operatorDeployment == OperatorDeployment.remote) {+      createCRD();+      createRBACresourcesAndOperatorDeployment();+    } else {+      createOperator();+      registerReconcilers();+      operator.start();+    }++  }++  private static void createK8sClient() {+    k8sclient = new DefaultKubernetesClient(new ConfigBuilder(Config.autoConfigure(null)).withNamespace(namespace).build());+  }++  private static void createRBACresourcesAndOperatorDeployment() throws FileNotFoundException {+    Log.info(""Creating RBAC into Namespace "" + namespace);+    List<HasMetadata> hasMetadata = k8sclient.load(new FileInputStream(TARGET_KUBERNETES_GENERATED_YML_FOLDER + deploymentTarget + "".yml""))+            .inNamespace(namespace).get();+    hasMetadata.stream()+            .map(b -> {+              if (""Deployment"".equalsIgnoreCase(b.getKind()) && b.getMetadata().getName().contains(""operator"")) {+                ((Deployment) b).getSpec().getTemplate().getSpec().getContainers().get(0).setImagePullPolicy(""Never"");","> We can't hold this PR due to discussions for much longer...I agree that we should not keep this PR open much longer, but I don't think this comment is the cause of any additional harm or delay.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/9625,795758041,2022-01-31T15:04:56Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -0,0 +1,140 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.NamespaceBuilder;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.fabric8.kubernetes.client.Config;+import io.fabric8.kubernetes.client.ConfigBuilder;+import io.fabric8.kubernetes.client.DefaultKubernetesClient;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.javaoperatorsdk.operator.Operator;+import io.javaoperatorsdk.operator.api.reconciler.Reconciler;+import io.quarkiverse.operatorsdk.runtime.OperatorProducer;+import io.quarkiverse.operatorsdk.runtime.QuarkusConfigurationService;+import io.quarkus.logging.Log;+import org.eclipse.microprofile.config.ConfigProvider;+import org.junit.jupiter.api.AfterAll;+import org.junit.jupiter.api.BeforeAll;++import javax.enterprise.inject.Instance;+import javax.enterprise.inject.spi.CDI;+import javax.enterprise.util.TypeLiteral;+import java.io.FileInputStream;+import java.io.FileNotFoundException;+import java.util.List;+import java.util.UUID;++public abstract class ClusterOperatorTest {++  public static final String QUARKUS_KUBERNETES_DEPLOYMENT_TARGET = ""quarkus.kubernetes.deployment-target"";+  public static final String OPERATOR_DEPLOYMENT_PROP = ""test.operator.deployment"";+  public static final String TARGET_KUBERNETES_GENERATED_YML_FOLDER = ""target/kubernetes/"";++  public enum OperatorDeployment {local,remote}++  protected static OperatorDeployment operatorDeployment;+  protected static Instance<Reconciler<? extends HasMetadata>> reconcilers;+  protected static QuarkusConfigurationService configuration;+  protected static KubernetesClient k8sclient;+  protected static String namespace;+  protected static String deploymentTarget;+  private static Operator operator;+++  @BeforeAll+  public static void before() throws FileNotFoundException {+    configuration = CDI.current().select(QuarkusConfigurationService.class).get();+    reconcilers = CDI.current().select(new TypeLiteral<>() {});+    operatorDeployment = ConfigProvider.getConfig().getOptionalValue(OPERATOR_DEPLOYMENT_PROP, OperatorDeployment.class).orElse(OperatorDeployment.local);+    deploymentTarget = ConfigProvider.getConfig().getOptionalValue(QUARKUS_KUBERNETES_DEPLOYMENT_TARGET, String.class).orElse(""kubernetes"");++    calculateNamespace();+    createK8sClient();+    createNamespace();++    if (operatorDeployment == OperatorDeployment.remote) {+      createCRD();+      createRBACresourcesAndOperatorDeployment();+    } else {+      createOperator();+      registerReconcilers();+      operator.start();+    }++  }++  private static void createK8sClient() {+    k8sclient = new DefaultKubernetesClient(new ConfigBuilder(Config.autoConfigure(null)).withNamespace(namespace).build());+  }++  private static void createRBACresourcesAndOperatorDeployment() throws FileNotFoundException {+    Log.info(""Creating RBAC into Namespace "" + namespace);+    List<HasMetadata> hasMetadata = k8sclient.load(new FileInputStream(TARGET_KUBERNETES_GENERATED_YML_FOLDER + deploymentTarget + "".yml""))+            .inNamespace(namespace).get();+    hasMetadata.stream()+            .map(b -> {+              if (""Deployment"".equalsIgnoreCase(b.getKind()) && b.getMetadata().getName().contains(""operator"")) {+                ((Deployment) b).getSpec().getTemplate().getSpec().getContainers().get(0).setImagePullPolicy(""Never"");","@andreaTP We're already delaying it with this discussion.  Really, this is a more complex problem and need to be addressed separately. Created #9898.",
48915630,dgozalo,https://api.github.com/repos/keycloak/keycloak/pulls/9802,796398549,2022-02-01T09:19:21Z,themes/src/main/resources/theme/base/login/login-oauth-grant.ftl,"@@ -18,7 +18,12 @@                 <#if oauth.clientScopesRequested??>                     <#list oauth.clientScopesRequested as clientScope>                         <li>-                            <span>${advancedMsg(clientScope.consentScreenText)}</span>+                            <span><#if !clientScope.dynamicScopeParameter??>+                                        ${advancedMsg(clientScope.consentScreenText)}+                                    <#else>+                                        ${advancedMsg(clientScope.consentScreenText)} - Dynamic Scope Parameter: <b>${clientScope.dynamicScopeParameter}</b>","Yes, this is definitely a great feature to have and as you said, it would be necessary for RAR too.For this PR though, I thought of the format as the ""default"" one without any reference to parameters.I made a small change to the format however, and it should read as:<scope_name | scope_display_text>:<parameter>I'll open a follow up issue to handle the parameterized display text.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9559,796532260,2022-02-01T12:09:51Z,docs/guides/src/main/server/configuring-database.adoc,"@@ -0,0 +1,126 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+    title=""Configuring a database""","```suggestion    title=""Configuring the database""```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9559,796534091,2022-02-01T12:12:34Z,docs/guides/src/main/server/configuring-database.adoc,"@@ -0,0 +1,126 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+    title=""Configuring a database""+    summary=""An overview about how to configure relational databases""+    includedOptions=""db db-*"">++In this guide, you are going to understand how to configure the server to store data using different relational databases. You should also learn+what are the databases supported by the server and how to proceed when using a unsupported database version.",```suggestionwhat are databases are supported by the server.```,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9559,796539603,2022-02-01T12:20:17Z,docs/guides/src/main/server/configuring-database.adoc,"@@ -0,0 +1,126 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+    title=""Configuring a database""+    summary=""An overview about how to configure relational databases""+    includedOptions=""db db-*"">++In this guide, you are going to understand how to configure the server to store data using different relational databases. You should also learn+what are the databases supported by the server and how to proceed when using a unsupported database version.","another suggestion, without doubled ""are"" as in @stianst s ;) : ```suggestionYou will also learn what databases are supported by the server.```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9559,796540238,2022-02-01T12:21:09Z,docs/guides/src/main/server/configuring-database.adoc,"@@ -0,0 +1,126 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+    title=""Configuring a database""+    summary=""An overview about how to configure relational databases""+    includedOptions=""db db-*"">++In this guide, you are going to understand how to configure the server to store data using different relational databases. You should also learn+what are the databases supported by the server and how to proceed when using a unsupported database version.++== Querying the list of supported databases++The server has built-in support for different databases. You should be able to query the available databases by looking at the expected values+for the `db` configuration option.++The list of supported databases and their corresponding versions are:++|===+|Database | Version++|mariadb| 10.3+|mssql| 2016+|mysql| 8+|oracle| 12c+|postgres| 10+|===++[NOTE]+The server is opinionated about the databases and their respective versions. If you need support for a different database, there are some+advanced configuration options to override the default configuration (e.g.: JDBC driver, Hibernate ORM Dialect, disable XA, etc). In this case, please help us by creating an issue to discuss+the possibility to support additional databases.","I would remove this section, as we will not support any relational database vendor out there, now or in the future. Some more thoughts on this:* We should update our testing more regularly with more recent versions of the databases, but if we just change it to `Tested version` it leaves it open for folks to open an issue against newer versions if they don't work. We don't need to specify that in the docs though (as otherwise we'd have mentions like this everywhere)* Cloud vendor specific versions like AWS RDS, we need to prioritise which we want to test/support, and when we do should cover this directly without extra config. I could be open for a section at the end mentioning some instructions on things to configure/tune to try to get it to work with various variants, but I'd leave that for later, and only if we have some instructions to provide",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9559,796541209,2022-02-01T12:22:28Z,docs/guides/src/main/server/configuring-database.adoc,"@@ -0,0 +1,126 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+    title=""Configuring a database""+    summary=""An overview about how to configure relational databases""+    includedOptions=""db db-*"">++In this guide, you are going to understand how to configure the server to store data using different relational databases. You should also learn+what are the databases supported by the server and how to proceed when using a unsupported database version.++== Querying the list of supported databases++The server has built-in support for different databases. You should be able to query the available databases by looking at the expected values+for the `db` configuration option.++The list of supported databases and their corresponding versions are:++|===+|Database | Version++|mariadb| 10.3+|mssql| 2016+|mysql| 8+|oracle| 12c+|postgres| 10+|===++[NOTE]+The server is opinionated about the databases and their respective versions. If you need support for a different database, there are some+advanced configuration options to override the default configuration (e.g.: JDBC driver, Hibernate ORM Dialect, disable XA, etc). In this case, please help us by creating an issue to discuss+the possibility to support additional databases.++By default, the server uses the `h2-file` database. This is the default database that the server will use to persist data and+really only exists so that you can run the authentication server out of the box. We highly recommend that you replace it with a more production ready external database. The `h2-file` database is not very viable in high concurrency situations and should not be used in a cluster either.","```suggestiononly exists for development use-cases. The `h2-file` database is not suitable for production use-cases, and must be replaced before deploying to production.```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9559,796542361,2022-02-01T12:23:59Z,docs/guides/src/main/server/configuring-database.adoc,"@@ -0,0 +1,126 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+    title=""Configuring a database""+    summary=""An overview about how to configure relational databases""+    includedOptions=""db db-*"">++In this guide, you are going to understand how to configure the server to store data using different relational databases. You should also learn+what are the databases supported by the server and how to proceed when using a unsupported database version.++== Querying the list of supported databases++The server has built-in support for different databases. You should be able to query the available databases by looking at the expected values+for the `db` configuration option.++The list of supported databases and their corresponding versions are:++|===+|Database | Version++|mariadb| 10.3+|mssql| 2016+|mysql| 8+|oracle| 12c+|postgres| 10+|===++[NOTE]+The server is opinionated about the databases and their respective versions. If you need support for a different database, there are some+advanced configuration options to override the default configuration (e.g.: JDBC driver, Hibernate ORM Dialect, disable XA, etc). In this case, please help us by creating an issue to discuss+the possibility to support additional databases.++By default, the server uses the `h2-file` database. This is the default database that the server will use to persist data and+really only exists so that you can run the authentication server out of the box. We highly recommend that you replace it with a more production ready external database. The `h2-file` database is not very viable in high concurrency situations and should not be used in a cluster either.++== Configuring a database++For each supported database, the server provides some opinionated defaults to make it simpler to configure a database. The defaults allow+you to easily configure a database by just providing some key settings like the database host and credentials.++To configure a database, run the `build` command to build a server image using the `db` build option to configure the server for specific database:","```suggestionTo configure the database vendor, run the `build` command to build a server image using the `db` build option to configure the server for specific database:```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9478,796546537,2022-02-01T12:29:31Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,177 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>","can be removed, unused",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9478,796549746,2022-02-01T12:33:39Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,177 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+server options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Understanding Server Options++All the server options can be found by using the `help` option for individual commands:++<@kc.all parameters=""--help""/>","Still not sure about the ""all"" macro here. I would remove it, and instead say that the options are command-specific. e.g. ```suggestionIn the CLI, you can show options using the help command. The shown options are command specific:<@kc.build parameters=""--help""/>shows only build options.<@kc.start parameters=""--help""/>shows only configuration which can be applied directly when starting the server.```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9478,796549973,2022-02-01T12:33:54Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,177 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+server options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Understanding Server Options++All the server options can be found by using the `help` option for individual commands:++<@kc.all parameters=""--help""/>++You can instead look at all the server options at <@links.server id=""all-config""/>.++Server options are loaded from different sources in a specific order and they use different formats:++|===+|*Source* | *Format*++|CLI+|--db-url-host=<value>++|Environment Variable+|KC_DB_URL_HOST++|`conf/keycloak.conf`+|db-url-host=<value>+|===++Given the `db-url-host` option as an example, you would set this property as follows:++.Command-line argument+<@kc.start parameters=""--db-url-host=mykeycloakdb""/>++.Environment variable+```+export KC_DB_URL_HOST=mykeycloakdb+```++.`conf/keycloak.conf`+```+db-url-host=mykeycloakdb+```++The configuration source and the corresponding format you should use is use-case specific. That decision depends on the platform the server is deployed to+as well as on the optimizations you can get for an optimal runtime. For instance, when deploying the server into Kubernetes you would probably rely+on environment variables to configure the server. However, you are not limited to use a single configuration source and format.++== Configuring the server++The server options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and is related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++Configuration is basically done in two stages:++* Before starting the server in order to build an optimized server image for an optimal runtime+* When starting the server++The first stage involves running the `build` command and set any **build option** available from this command to configure the server.++By looking at the individual configuration options at <@links.server id=""all-config""/>, you notice+that some options are marked with an icon to indicate they are a build option. In other words, they can only be set and only take effect when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++The `build` command is responsible for producing an immutable and optimized server image, which is similar to building a container image. In addition to persisting+any build option you have set, this command also performs a series of optimizations to deliver the best runtime when starting and running the server. As a result,+a lot of processing that would usually happen when starting and running the server is no longer necessary and the server can start and run faster.++Some optimizations performed by the `build` command are:++* Closed-world assumption about installed providers, which means that no need to re-create the registry every time the server starts+* Configuration files are pre-parsed to reduce IO when starting the server+* Database specific resources are configured and prepared to run against a specific database vendor+* By persisting build options into the server image, the server does not perform any additional step to interpret configuration options and (re)configure itself++Once you run the `build` command, you won't need to set the same build options again when starting the server.++.First stage, run the `build` command to set any build option+<@kc.build parameters=""--db=postgres""/>++The second stage involves starting the server using any **configuration option** available from the `start` command.++.Second stage, run the `start` command to set any configuration option when starting the server+<@kc.start parameters=""--db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++At this stage, you are free to set any value you want to any of the configuration options.++== Configuring the server for an optimal startup time++In addition to the optimizations performed when you run the `build` command, you might want to avoid using CLI options when running the+`start` command in favor of using environment variables or configuration options from the `conf/keycloak.conf` file.++.Set any build option+<@kc.build parameters=""--db=postgres""/>++.Set any configuration option to `conf/keycloak.conf`+```+db-url-host=keycloak-postgres+db-username=keycloak+db-password=change_me+hostname mykeycloak.acme.com+```++.Start the server+<@kc.start/>++By following that approach, the server is going to skip some steps at startup and start faster.","This section doesn't make any sense to me as it is suggesting properties in `conf/keycloak.conf` are somehow optimised compared to environment variables and configuration options, which is not the case. You've already previously mentioned that people can mix/match what config source they want, as well as the build stuff, so I would just remove this section completely as it's just duplication.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9478,796569081,2022-02-01T12:57:08Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,177 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+server options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Understanding Server Options++All the server options can be found by using the `help` option for individual commands:++<@kc.all parameters=""--help""/>++You can instead look at all the server options at <@links.server id=""all-config""/>.++Server options are loaded from different sources in a specific order and they use different formats:","I agree, it's not quite explicit if it's first in the list, or last in the list that takes precendence. I would assume it's first, but could also misinterpret that",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9866,796579732,2022-02-01T13:09:58Z,docs/guides/src/main/server/outgoinghttp.adoc,"@@ -0,0 +1,147 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+title=""Configure outgoing HTTP requests""+summary=""How to configure Keycloak's HTTP client for outgoing requests.""+includedOptions="""">++Keycloak often needs to make requests to the applications and services it secures. Keycloak manages these outgoing connections using an HTTP client. This guide shows how to configure the client, it's connection pool, proxy environment settings, timeouts and more.++== Usage+To configure Keycloak's outgoing Http client, use:++<@kc.start parameters=""--spi-connections-http-client-default-<configurationoption>=<value>""/>++Please see <<Outgoing Http Client Configuration Options>> for the available configuration options.++== Outgoing Http Client Configuration Options++The Http client Keycloak uses for outgoing communication is highly configurable. The available options are:++*establish-connection-timeout-millis*::+Maximum time in milliseconds until a connection approach times out. Default: Not set.++*socket-timeout-millis*::+Maximum time of inactivity between two data packets until a socket connection times out, in milliseconds. Default: 5000ms++*connection-pool-size*::+Size of the connection pool for outgoing connections. Default: 128.++*max-pooled-per-route*::+How many connections can be pooled per host. Default: 64.++*connection-ttl-millis*::+Maximum connection time to live in milliseconds. Default: Not set.++*max-connection-idle-time-millis*::+Maximum time an idle connection stays in the connection pool, in milliseconds. Idle connections will be removed from the pool by a background cleaner thread. Set to -1 to disable this check. Default: 900000.++*disable-cookies*::+Enable or disable caching of cookies. Default: true.","I don't know why, I just looked at https://github.com/keycloak/keycloak/blob/main/services/src/main/java/org/keycloak/connections/httpclient/DefaultHttpClientFactory.java#L143-L157 for the defaults and added them. @pedroigor wdyt, change this?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/9478,796592458,2022-02-01T13:25:42Z,docs/guides/src/main/server/configuration_overview.adoc,"@@ -0,0 +1,177 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Configuring Keycloak""+summary=""An overview of the server configuration"">++In this guide, you will learn the core concepts around the server configuration and how to configure the server using the different+server options available. You will also learn how to properly configure the server to achieve an optimal runtime for faster+startup and low memory footprint.++== Understanding Server Options++All the server options can be found by using the `help` option for individual commands:++<@kc.all parameters=""--help""/>++You can instead look at all the server options at <@links.server id=""all-config""/>.++Server options are loaded from different sources in a specific order and they use different formats:++|===+|*Source* | *Format*++|CLI+|--db-url-host=<value>++|Environment Variable+|KC_DB_URL_HOST++|`conf/keycloak.conf`+|db-url-host=<value>+|===++Given the `db-url-host` option as an example, you would set this property as follows:++.Command-line argument+<@kc.start parameters=""--db-url-host=mykeycloakdb""/>++.Environment variable+```+export KC_DB_URL_HOST=mykeycloakdb+```++.`conf/keycloak.conf`+```+db-url-host=mykeycloakdb+```++The configuration source and the corresponding format you should use is use-case specific. That decision depends on the platform the server is deployed to+as well as on the optimizations you can get for an optimal runtime. For instance, when deploying the server into Kubernetes you would probably rely+on environment variables to configure the server. However, you are not limited to use a single configuration source and format.++== Configuring the server++The server options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects+of the server configuration and is related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.++Configuration is basically done in two stages:++* Before starting the server in order to build an optimized server image for an optimal runtime+* When starting the server++The first stage involves running the `build` command and set any **build option** available from this command to configure the server.++By looking at the individual configuration options at <@links.server id=""all-config""/>, you notice+that some options are marked with an icon to indicate they are a build option. In other words, they can only be set and only take effect when running the `build` command.+You can also check all the options that require a build by looking at the `help` message of the `build` command:++<@kc.build parameters=""--help""/>++The `build` command is responsible for producing an immutable and optimized server image, which is similar to building a container image. In addition to persisting+any build option you have set, this command also performs a series of optimizations to deliver the best runtime when starting and running the server. As a result,+a lot of processing that would usually happen when starting and running the server is no longer necessary and the server can start and run faster.++Some optimizations performed by the `build` command are:++* Closed-world assumption about installed providers, which means that no need to re-create the registry every time the server starts+* Configuration files are pre-parsed to reduce IO when starting the server+* Database specific resources are configured and prepared to run against a specific database vendor+* By persisting build options into the server image, the server does not perform any additional step to interpret configuration options and (re)configure itself++Once you run the `build` command, you won't need to set the same build options again when starting the server.++.First stage, run the `build` command to set any build option+<@kc.build parameters=""--db=postgres""/>++The second stage involves starting the server using any **configuration option** available from the `start` command.++.Second stage, run the `start` command to set any configuration option when starting the server+<@kc.start parameters=""--db-url-host=keycloak-postgres --db-username=keycloak --db-password=change_me --hostname mykeycloak.acme.com""/>++At this stage, you are free to set any value you want to any of the configuration options.++== Configuring the server for an optimal startup time++In addition to the optimizations performed when you run the `build` command, you might want to avoid using CLI options when running the+`start` command in favor of using environment variables or configuration options from the `conf/keycloak.conf` file.++.Set any build option+<@kc.build parameters=""--db=postgres""/>++.Set any configuration option to `conf/keycloak.conf`+```+db-url-host=keycloak-postgres+db-username=keycloak+db-password=change_me+hostname mykeycloak.acme.com+```++.Start the server+<@kc.start/>++By following that approach, the server is going to skip some steps at startup and start faster.++== Using the `auto-build` option when starting the server++The `auto-build` option allows you to perform the two configuration stages using a single command. Under certain circumstances, you might want to sacrifice the server startup time and update the values of build options when starting the server.++For that, you can start the server as follows:++.Using the `auto-build` option+<@kc.start parameters=""--auto-build --db postgres --db-url-host keycloak-postgres --db-username keycloak --db-password change_me --hostname mykeycloak.acme.com""/>++By using this option, the server is going to calculate the build options that have changed and automatically run the `build` command, if necessary, before actually starting the server.++== Configuring the server using configuration files++By default, the server is going to always fetch any configuration option you set from the `conf/keycloak.conf` file. When you are using a fresh distribution,+this file holds only the recommended settings for running in production, which are initially commented out.++You can also specify a different configuration file by using the `[-cf|--config-file] option as follows:++<@kc.all rootParameters=""-cf myconfig.conf""/>++Changes to any *build option* defined in the `keycloak.conf` file that is targeted for the `build` command is ignored+if the value differs from the value used to previously run the `build` command. In this case, make sure you run the `build` command again so that+any build option is updated accordingly.++== Using placeholders++You are able to use placeholders to dynamically change the value of configuration options when starting the server.++For that purpose, you use the following format when defining the value of an option:++```+db.username=${r""${my.db.user}""}+```++By using a placeholder such as in the example above, the server is going to try to resolve the `my.db.user` variable from:++* A system property using the same key+* An environment variable by replacing dots with `_`++You should not use placeholders for build options. The reason is that these options+can not change once they are persisted into the server image. Prefer using placeholders only for the configurations options available to+the `start` command.++=== Understanding the default profiles","that would mean there are / may be multiple production modes / development modes as far as i can tell. @andymunro I am not sure about this, though. Want to avoid ambiguity, there are exactly 2 modes, development and production. wdyt, as a native speaker? ;)1) ""Understanding development mode and production mode""2) ""Understanding development and production mode""3) ""Understanding development and production modes""4) ""Understanding development- and production mode""5) ""Understanding development- and production modes"" These are the options floating through my head, but not sure what is exactly right english tbh  ",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/9746,796613886,2022-02-01T13:50:11Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/clientscope/entity/JpaClientScopeMetadata.java,"@@ -0,0 +1,43 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.clientscope.entity;++import java.io.Serializable;+import org.keycloak.models.map.clientscope.MapClientScopeEntityImpl;+import org.keycloak.models.map.common.DeepCloner;++public class JpaClientScopeMetadata extends MapClientScopeEntityImpl implements Serializable {","Ok, makes sense. If we decide to refactor the Jpa*Metadata classes in the future we can do that as part of a different PR. Resolved, thanks!",
39348110,schereradi,https://api.github.com/repos/keycloak/keycloak/pulls/8950,796728970,2022-02-01T15:43:54Z,services/src/main/java/org/keycloak/forms/login/freemarker/model/PasswordPolicyBean.java,"@@ -0,0 +1,44 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.forms.login.freemarker.model;++import java.util.Set;++import org.keycloak.models.RealmModel;++/**+ * @author <a href=""mailto:scherer.adi@gmail.com"">Adrian Scherer</a>+ */+public class PasswordPolicyBean {++    private final RealmModel realm;++    public PasswordPolicyBean(final RealmModel realmModel) {++        this.realm = realmModel;+    }++    public Set<String> getPolicies() {","Hey, no worries, the method is a getter. The `Set` is just the returned collection that contains no duplicate elements.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9478,797632690,2022-02-02T13:58:28Z,docs/guides/src/main/templates/kc.adoc,"@@ -1,14 +1,14 @@-<#macro build parameters>+<#macro build rootParameters="""" parameters=""""> [source,bash] -----bin/kc.[sh|bat] build ${parameters}+bin/kc.[sh|bat] ${rootParameters} build ${parameters}",```suggestionbin/kc.[sh|bat]<#if rootParameters?has_content> ${rootParameters}</#if> build<#if parameters?has_content> ${parameters}</#if>```,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9478,797633211,2022-02-02T13:59:02Z,docs/guides/src/main/templates/kc.adoc,"@@ -1,14 +1,14 @@-<#macro build parameters>+<#macro build rootParameters="""" parameters=""""> [source,bash] -----bin/kc.[sh|bat] build ${parameters}+bin/kc.[sh|bat] ${rootParameters} build ${parameters} ---- </#macro> -<#macro start parameters>+<#macro start rootParameters="""" parameters=""""> [source,bash] -----bin/kc.[sh|bat] start ${parameters}+bin/kc.[sh|bat] ${rootParameters} start ${parameters}",```suggestionbin/kc.[sh|bat]<#if rootParameters?has_content> ${rootParameters}</#if> start<#if parameters?has_content> ${parameters}</#if>```,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/9786,797981911,2022-02-02T20:21:20Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/hibernate/listeners/JpaEntityVersionListener.java,"@@ -0,0 +1,69 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.jpa.hibernate.listeners;++import org.hibernate.HibernateException;+import org.hibernate.event.spi.PreDeleteEvent;+import org.hibernate.event.spi.PreDeleteEventListener;+import org.hibernate.event.spi.PreInsertEvent;+import org.hibernate.event.spi.PreInsertEventListener;+import org.hibernate.event.spi.PreUpdateEvent;+import org.hibernate.event.spi.PreUpdateEventListener;+import org.keycloak.models.map.storage.jpa.JpaChildEntity;+import org.keycloak.models.map.storage.jpa.JpaRootEntity;++/**+ * Listen on changes on child- and root entities and updates the current entity version of the root.+ *+ * This support a multiple level parent-child relationship, where only the upmost parent is locked.+ */+public class JpaEntityVersionListener implements PreInsertEventListener, PreDeleteEventListener, PreUpdateEventListener {++    public static final JpaEntityVersionListener INSTANCE = new JpaEntityVersionListener();++    /**+     * Check if the entity is a child with a parent and force optimistic locking increment on the upmost parent.",nitpick: this javadoc was prob copied over from the other listener and doesn't correspond to what the method does.,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/9903,798521225,2022-02-03T12:38:10Z,docs/guides/src/main/server/caching.adoc,"@@ -0,0 +1,126 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>++<@tmpl.guide+title=""Configure distributed caches""+summary=""Understand how to configure the caching layer""+includedOptions=""cache cache-*"">++Keycloak is designed for high availability and multi-node clustered setups. The current distributed cache implementation is built on top of https://infinispan.org[Infinispan], a high-performance, distributable in-memory data grid.++All available cache options are build options, so they need to be applied to a `build` of Keycloak before starting.++== Enable distributed caching+Caching is enabled per default when you start Keycloak in production mode, using the `start` command. This will automatically discover other Keycloak nodes in your network. To explicitly enable distributed infinispan caching, use:++<@kc.build parameters=""--cache=ispn""/>++When you start Keycloak in development mode, using the `start-dev` command, Keycloak defaults to only use local caches using `--cache=local` instead. Using the `local` cache mode is intended only for development and testing purposes.++== Configure Caches+Keycloak provides a cache configuration file with sensible defaults located at `conf/cache-ispn.xml`.++The cache configuration is a regular https://infinispan.org/docs/stable/titles/configuring/configuring.html[Infinispan] configuration file.++=== Overview: Cache types and Defaults++.Local caches+Keycloak caches persistent data locally to avoid unnecessary database requests. The caches used are:++* realms+* users+* authorization+* keys++.Invalidation of local caches+Local caching improves performance, but adds a challenge in multi-node setups: When one Keycloak node updates data in the shared database, all other nodes need to be aware of it, so they invalidate that data from their caches. The `work` cache is used for sending these invalidation messages.++.Authentication sessions+Authentication sessions are started when an unauthenticated user or service tries to login to Keycloak. The `authenticationSessions` distributed cache is used to save data during authentication of particular user.++.User sessions+There are four distributed caches for sessions of authenticated users and services:++* sessions+* clientSessions+* offlineSessions+* offlineClientSessions++These caches are used to save data about user sessions, which are valid for the length of a users browser session.","Offline sessions are valid beyond the user's browser session, so just simplyfing this to:```suggestionThese caches are used to save data about user sessions, and clients attached to the sessions.```",
534516,mfdewit,https://api.github.com/repos/keycloak/keycloak/pulls/8260,798887875,2022-02-03T19:12:09Z,services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java,"@@ -788,6 +788,11 @@ public Response handleBrowserException(Exception failure) {                 event.error(Errors.INVALID_USER_CREDENTIALS);                 if (e.getResponse() != null) return e.getResponse();                 return ErrorPage.error(session, authenticationSession, Response.Status.BAD_REQUEST, Messages.CREDENTIAL_SETUP_REQUIRED);+            } else if (e.getError() == AuthenticationFlowError.SESSION_LIMIT_EXCEEDED) {","Yes, I agree a generic error would be beneficial in the long run. I think I've implemented it the way you intended. Could you please verify?",
534516,mfdewit,https://api.github.com/repos/keycloak/keycloak/pulls/8260,798890242,2022-02-03T19:15:14Z,services/src/main/java/org/keycloak/authentication/authenticators/sessionlimits/RealmSessionLimitsAuthenticator.java,"@@ -0,0 +1,52 @@+package org.keycloak.authentication.authenticators.sessionlimits;++import org.jboss.logging.Logger;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.KeycloakSession;++import java.util.Map;+import java.util.Optional;+import javax.ws.rs.core.Response;+import org.keycloak.events.Errors;+import org.keycloak.services.messages.Messages;++public class RealmSessionLimitsAuthenticator extends AbstractSessionLimitsAuthenticator {",I've double checked with my client who requested the limiting feature and they are not using the Realm limitation either. So it seems you were correct questioning its usefulness. Less code is always better :) It has been removed and the abstract class is merged with the UserSessionLimitsAuthenticator.,
534516,mfdewit,https://api.github.com/repos/keycloak/keycloak/pulls/8260,798895793,2022-02-03T19:22:46Z,services/src/main/java/org/keycloak/authentication/authenticators/sessionlimits/UserSessionLimitsAuthenticator.java,"@@ -0,0 +1,102 @@+package org.keycloak.authentication.authenticators.sessionlimits;++import org.jboss.logging.Logger;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.models.AuthenticatorConfigModel;+import org.keycloak.models.ClientModel;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.UserSessionModel;+import org.keycloak.services.managers.AuthenticationManager;++import java.util.Comparator;+import java.util.List;+import java.util.Map;+import java.util.Optional;+import java.util.stream.Collectors;+import javax.ws.rs.core.Response;+import org.keycloak.events.Errors;+import org.keycloak.services.messages.Messages;++public class UserSessionLimitsAuthenticator extends AbstractSessionLimitsAuthenticator {++    private static Logger logger = Logger.getLogger(UserSessionLimitsAuthenticator.class);++    String behavior;++    public UserSessionLimitsAuthenticator(KeycloakSession session) {+        this.session = session;+    }++    @Override+    public void authenticate(AuthenticationFlowContext context) {+        AuthenticatorConfigModel authenticatorConfig = context.getAuthenticatorConfig();+        Map<String, String> config = authenticatorConfig.getConfig();++        // Get the configuration for this authenticator+        behavior = config.get(UserSessionLimitsAuthenticatorFactory.BEHAVIOR);+        int userRealmLimit = getIntConfigProperty(UserSessionLimitsAuthenticatorFactory.USER_REALM_LIMIT, config);+        int userClientLimit = getIntConfigProperty(UserSessionLimitsAuthenticatorFactory.USER_CLIENT_LIMIT, config);++        if (context.getRealm() != null && context.getUser() != null) {++            // Get the session count in this realm for this specific user+            List<UserSessionModel> userSessionsForRealm = session.sessions().getUserSessions(context.getRealm(), context.getUser());+            int userSessionCountForRealm = userSessionsForRealm.size();++            // Get the session count related to the current client for this user+            ClientModel currentClient = context.getAuthenticationSession().getClient();+            logger.debugf(""session-limiter's current keycloak clientId: %s"", currentClient.getClientId());++            List<UserSessionModel> userSessionsForClient = userSessionsForRealm.stream().filter(session -> session.getAuthenticatedClientSessionByClient(currentClient.getId()) != null).collect(Collectors.toList());","Yes, good point! It is now called conditionally.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8553,799125982,2022-02-04T02:49:06Z,server-spi-private/src/main/java/org/keycloak/models/utils/DefaultKeyProviders.java,"@@ -114,25 +114,53 @@ protected static boolean hasProvider(RealmModel realm, String providerId) {      public static void createProviders(RealmModel realm, String privateKeyPem, String certificatePem) {         if (!hasProvider(realm, ""rsa"")) {-            ComponentModel rsa = new ComponentModel();-            rsa.setName(""rsa"");-            rsa.setParentId(realm.getId());-            rsa.setProviderId(""rsa"");-            rsa.setProviderType(KeyProvider.class.getName());--            MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();-            config.putSingle(""priority"", ""100"");-            config.putSingle(""privateKey"", privateKeyPem);-            if (certificatePem != null) {-                config.putSingle(""certificate"", certificatePem);-            }-            rsa.setConfig(config);--            realm.addComponentModel(rsa);+            importRsaKEyProvider(""rsa"", realm, privateKeyPem, certificatePem);+        }++        if (!hasProvider(realm, ""rsa-enc"")) {+            importRsaEncKEyProvider(""rsa-enc"", realm, privateKeyPem, certificatePem);         }          createSecretProvider(realm);         createAesProvider(realm);     } +    private static void importRsaKEyProvider(String name, RealmModel realm, String privateKeyPem, String certificatePem) {+        ComponentModel rsa = new ComponentModel();+        rsa.setName(name);+        rsa.setParentId(realm.getId());+        rsa.setProviderId(""rsa"");+        rsa.setProviderType(KeyProvider.class.getName());++        MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();+        config.putSingle(""priority"", ""100"");+        config.putSingle(""keyUse"", KeyUse.SIG.name());+        config.putSingle(""privateKey"", privateKeyPem);+        if (certificatePem != null) {+            config.putSingle(""certificate"", certificatePem);+        }+        rsa.setConfig(config);++        realm.addComponentModel(rsa);+    }++    private static void importRsaEncKEyProvider(String name, RealmModel realm, String privateKeyPem, String certificatePem) {+        ComponentModel rsa = new ComponentModel();+        rsa.setName(name);+        rsa.setParentId(realm.getId());+        rsa.setProviderId(""rsa-enc"");+        rsa.setProviderType(KeyProvider.class.getName());++        MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();+        config.putSingle(""priority"", ""100"");+        config.putSingle(""keyUse"", KeyUse.ENC.name());+        config.putSingle(""privateKey"", privateKeyPem);","It might be appropriate to put some default algorithm for ENC.For example,```        config.putSingle(""algorithm"", JWEConstants.RSA_OAEP);```The reason is as follows.`GeneratedRsaKeyProviderFactory.create`, `GeneratedRsaEncKeyProviderFactory.create`, `ImportedRsaKeyProviderFactory.create`, `ImportedRsaEncKeyProviderFactory.create` instantiate `ImportedRsaKeyProvider` and call a constructor of its superclass `AbstractRsaKeyProvider`.In the constructor, ```    public AbstractRsaKeyProvider(RealmModel realm, ComponentModel model) {        this.model = model;        this.status = KeyStatus.from(model.get(Attributes.ACTIVE_KEY, true), model.get(Attributes.ENABLED_KEY, true));        this.algorithm = model.get(Attributes.ALGORITHM_KEY, Algorithm.RS256);```It means that if the ComponentModel does not contain an algorithm value with key ""algorithm"", the instantiated key provider's algorithm becomes RS256.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8553,799131398,2022-02-04T03:06:34Z,server-spi-private/src/main/java/org/keycloak/models/utils/DefaultKeyProviders.java,"@@ -114,25 +114,53 @@ protected static boolean hasProvider(RealmModel realm, String providerId) {      public static void createProviders(RealmModel realm, String privateKeyPem, String certificatePem) {         if (!hasProvider(realm, ""rsa"")) {-            ComponentModel rsa = new ComponentModel();-            rsa.setName(""rsa"");-            rsa.setParentId(realm.getId());-            rsa.setProviderId(""rsa"");-            rsa.setProviderType(KeyProvider.class.getName());--            MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();-            config.putSingle(""priority"", ""100"");-            config.putSingle(""privateKey"", privateKeyPem);-            if (certificatePem != null) {-                config.putSingle(""certificate"", certificatePem);-            }-            rsa.setConfig(config);--            realm.addComponentModel(rsa);+            importRsaKEyProvider(""rsa"", realm, privateKeyPem, certificatePem);+        }++        if (!hasProvider(realm, ""rsa-enc"")) {","I think that these codes are not needed because- Both RSA key provider for signature and RSA key provider for encryption are created by using the same private key and certificate of a realm. Generally, it might not be appropriate to use the same key for several usage.- This method is only called when importing a realm and the realm has its private key, public key and certificate. A realm's private key, public key and certificate are deprecated so that this method might be rarely called.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10000,799450736,2022-02-04T13:09:32Z,docs/guides/src/main/server/production-readiness.adoc,"@@ -0,0 +1,39 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Configuring Keycloak for production""+summary=""Learn how to make Keycloak ready for production.""+includedOptions="""">++Keycloak is used in various production environments, from on-premise deployments spanning only a few thousand users to deployments serving millions of users with secure authentication and authorization.++This guide walks you through the general aspects of setting up a production ready Keycloak environment. It focusses on the main concepts and aspects instead of the actual implementation, which depends on your actual environment, be it containerized, on-premise, GitOps or Ansible. The key aspects covered in this guide apply to all of these environments.++== Enabling TLS+Keycloak exchanges sensitive data all the time, so all communication from and to Keycloak needs to be done through a secure communication channel. For that, you must enable HTTP over TLS, or HTTPS, to prevent several attack vectors.++The <@links.server id=""enabletls""/> and <@links.server id=""outgoinghttp""/> guides will show you the appropriate configuration to set up secure communication channels for Keycloak.++== Setting the hostname for Keycloak+Keycloak instances in production usually run in a private network, but Keycloak needs to expose different public facing endpoints to communicate with applications that will be secured.++Learn in the <@links.server id=""hostname""/> guide what the different endpoint categories are and how to configure the public hostname for them, depending on your specific environment.++== Configure a reverse proxy+Apart from <<Setting the hostname for Keycloak>>, production environments usually use a reverse proxy / load balancer component to separate and unify access to the companies network. Using such a component is recommended for Keycloak production deployments.++In the <@links.server id=""reverseproxy""/> guide you can find the available proxy communication modes in Keycloak and how to configure them. There's also a recommendation which paths should not be exposed to the public at all, and which Paths need to be exposed for Keycloak to be able to secure your applications.++== Configure a production grade database+The used database for Keycloak is crucial for the overall performance, avilability, reliability and integrity of Keycloak. In the <@links.server id=""db""/> guide you can find the supported database vendors and how to configure Keycloak to use them.","```suggestionThe database used by Keycloak is crucial for the overall performance, availability, reliability and integrity of Keycloak. In the <@links.server id=""db""/> guide you can find the supported database vendors and how to configure Keycloak to use them.```",
339706,fbrissi,https://api.github.com/repos/keycloak/keycloak/pulls/8553,799749067,2022-02-04T19:20:35Z,server-spi-private/src/main/java/org/keycloak/models/utils/DefaultKeyProviders.java,"@@ -114,25 +114,53 @@ protected static boolean hasProvider(RealmModel realm, String providerId) {      public static void createProviders(RealmModel realm, String privateKeyPem, String certificatePem) {         if (!hasProvider(realm, ""rsa"")) {-            ComponentModel rsa = new ComponentModel();-            rsa.setName(""rsa"");-            rsa.setParentId(realm.getId());-            rsa.setProviderId(""rsa"");-            rsa.setProviderType(KeyProvider.class.getName());--            MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();-            config.putSingle(""priority"", ""100"");-            config.putSingle(""privateKey"", privateKeyPem);-            if (certificatePem != null) {-                config.putSingle(""certificate"", certificatePem);-            }-            rsa.setConfig(config);--            realm.addComponentModel(rsa);+            importRsaKEyProvider(""rsa"", realm, privateKeyPem, certificatePem);+        }++        if (!hasProvider(realm, ""rsa-enc"")) {","Okay, I see where this method is calling, it's fine to me, it seems right.But I have a question.In the case of generated keys, it is creating for 2 rsa and encrypted rsa, see the link below. In this case it's right, because it generates another key and it's not the same key, right?https://github.com/keycloak/keycloak/blob/7948d8d6e49a8588ff7389f5e52ee9e0bd4e827a/server-spi-private/src/main/java/org/keycloak/models/utils/DefaultKeyProviders.java#L35-L46",
339706,fbrissi,https://api.github.com/repos/keycloak/keycloak/pulls/8553,800178667,2022-02-06T13:15:08Z,server-spi-private/src/main/java/org/keycloak/models/utils/DefaultKeyProviders.java,"@@ -114,25 +114,53 @@ protected static boolean hasProvider(RealmModel realm, String providerId) {      public static void createProviders(RealmModel realm, String privateKeyPem, String certificatePem) {         if (!hasProvider(realm, ""rsa"")) {-            ComponentModel rsa = new ComponentModel();-            rsa.setName(""rsa"");-            rsa.setParentId(realm.getId());-            rsa.setProviderId(""rsa"");-            rsa.setProviderType(KeyProvider.class.getName());--            MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();-            config.putSingle(""priority"", ""100"");-            config.putSingle(""privateKey"", privateKeyPem);-            if (certificatePem != null) {-                config.putSingle(""certificate"", certificatePem);-            }-            rsa.setConfig(config);--            realm.addComponentModel(rsa);+            importRsaKEyProvider(""rsa"", realm, privateKeyPem, certificatePem);+        }++        if (!hasProvider(realm, ""rsa-enc"")) {","Thanks for your review. His comments were very well explained.I managed to do tests with imports and even see that in addition to being rare in the import I had done, the privateKey attribute is deprecated.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/8553,800265006,2022-02-07T01:23:40Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/keys/ImportedRsaKeyProviderTest.java,"@@ -69,13 +70,22 @@ public void addTestRealms(List<RealmRepresentation> testRealms) {     }      @Test-    public void privateKeyOnly() throws Exception {+    public void privateKeyOnlyForSig() throws Exception {+        privateKeyOnly(ImportedRsaKeyProviderFactory.ID, KeyUse.SIG);+    }++    @Test+    public void privateKeyOnlyForEnc() throws Exception {+        privateKeyOnly(ImportedRsaEncKeyProviderFactory.ID, KeyUse.ENC);","I'm afraid this test method does not check what we want to confirm.In `private void privateKeyOnly(String providerId, KeyUse keyUse)`,```        assertEquals(kid, keys.getActive().get(Algorithm.RS256));```It is appropriate for an imported rsa key provider, but it is not appropriate for an imported rsa enc key provider.For example, the following might be expected.```        assertEquals(kid, keys.getActive().get(Algorithm.RSA-OAEP));```However, as mentioned on other review comment, AbstractRsaKeyProvider's constructor set RS256 if a component model does not include an algorithm explicitly.```    public AbstractRsaKeyProvider(RealmModel realm, ComponentModel model) {        this.model = model;        this.status = KeyStatus.from(model.get(Attributes.ACTIVE_KEY, true), model.get(Attributes.ENABLED_KEY, true));        this.algorithm = model.get(Attributes.ALGORITHM_KEY, Algorithm.RS256);```which means that an algorithm of an imported rsa enc key provider without setting its algorithm explicitly becomes RS256. It is not appropriate.Therefore, how about modifying AbstractRsaKeyProvider's constructor as follows?```    public AbstractRsaKeyProvider(RealmModel realm, ComponentModel model) {        this.model = model;        this.status = KeyStatus.from(model.get(Attributes.ACTIVE_KEY, true), model.get(Attributes.ENABLED_KEY, true));        String keyUse = Optional.ofNullable(model.get(Attributes.KEY_USE)).orElse(KeyUse.SIG.name());        if (keyUse.equals(KeyUse.ENC.name())) {            this.algorithm = model.get(Attributes.ALGORITHM_KEY, JWEConstants.RSA_OAEP);        } else {            this.algorithm = model.get(Attributes.ALGORITHM_KEY, Algorithm.RS256);        }...```",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/9477,800780453,2022-02-07T15:34:50Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/liquibase/connection/DefaultLiquibaseConnectionProvider.java,"@@ -53,35 +45,8 @@      private static final Logger logger = Logger.getLogger(DefaultLiquibaseConnectionProvider.class); -    private static final AtomicBoolean INITIALIZED = new AtomicBoolean(false);-+    @SuppressWarnings(""unused"")     public DefaultLiquibaseConnectionProvider(final KeycloakSession session) {-        if (! INITIALIZED.get()) {-            // TODO: all liquibase providers should probably synchronize on the same object.-            synchronized (INITIALIZED) {-                if (! INITIALIZED.get()) {-                    initializeLiquibase();-                    INITIALIZED.set(true);-                }-            }-        }",I can see that similar piece of code remains in `org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider.create(session)`. I wonder why this change was removed here and not from the class above.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/9477,800797888,2022-02-07T15:51:58Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/LiquibaseJpaUpdaterProvider.java,"@@ -152,8 +153,8 @@ protected void updateChangeSet(Liquibase liquibase, Connection connection, Write                 statementsToExecute.add(new SetNullableStatement(database.getLiquibaseCatalogName(), database.getLiquibaseSchemaName(),                         changelogTable.getName(), DEPLOYMENT_ID_COLUMN, ""VARCHAR(10)"", false)); -                ExecutorService executorService = ExecutorService.getInstance();-                Executor executor = executorService.getExecutor(liquibase.getDatabase());+                ExecutorService executorService = Scope.getCurrentScope().getSingleton(ExecutorService.class);+                Executor executor = executorService.getExecutor(""jdbc"", liquibase.getDatabase());","This is because `getExecutor(Database)` is deprecated and the API says we should use this version that takes the executor name, in our case `jdbc`. I can for sure turn this into a constant.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/9477,800804408,2022-02-07T15:58:04Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/liquibase/connection/DefaultLiquibaseConnectionProvider.java,"@@ -53,35 +45,8 @@      private static final Logger logger = Logger.getLogger(DefaultLiquibaseConnectionProvider.class); -    private static final AtomicBoolean INITIALIZED = new AtomicBoolean(false);-+    @SuppressWarnings(""unused"")     public DefaultLiquibaseConnectionProvider(final KeycloakSession session) {-        if (! INITIALIZED.get()) {-            // TODO: all liquibase providers should probably synchronize on the same object.-            synchronized (INITIALIZED) {-                if (! INITIALIZED.get()) {-                    initializeLiquibase();-                    INITIALIZED.set(true);-                }-            }-        }",In that class the initialization code remains because I had to make the provider initialize Liquibase's `Scope` object. Liquibase uses the thread context classloader by default and that was problematic in WildFly because the context classloader is the keycloak module classloader that offers no visibility to the Liquibase classes. [In the GHI](https://github.com/keycloak/keycloak/issues/9476) I've added some context about why this is needed.Because the map storage is currently an optional feature I couldn't rely on the map-jpa `DefaultLiquibaseConnectionProvider` to do this initialization.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9997,801515317,2022-02-08T11:08:38Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/entity/JpaGroupAttributeEntity.java,"@@ -0,0 +1,108 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group.entity;++import java.util.Objects;+import java.util.UUID;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.GeneratedValue;+import javax.persistence.Id;+import javax.persistence.JoinColumn;+import javax.persistence.ManyToOne;+import javax.persistence.Table;+import org.hibernate.annotations.Nationalized;+import org.keycloak.models.map.storage.jpa.JpaChildEntity;++@Entity+@Table(name = ""group_attribute"")+public class JpaGroupAttributeEntity implements JpaChildEntity<JpaGroupEntity> {","The structure seems always the same. If we rather than `fk_group` used some neutral name like `fk_area` (similarly for setter / getter), one could introduce a parent `JpaAttributeEntity<E> extends JpaChildEntity<E>` that would contain all the logic and the descendant would be like this```java@Entity@Table(name = ""group_attribute"")public class JpaGroupAttributeEntity extends JpaAttributeEntity<JpaGroupAttributeEntity> {}```Note the empty class body",
1836434,jonathanvila,https://api.github.com/repos/keycloak/keycloak/pulls/9849,801693443,2022-02-08T14:31:39Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakRealmImportStatusCondition.java,"@@ -0,0 +1,68 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.v2alpha1.crds;++import java.util.Objects;+",Could this class be generalised ? I mean all the XXXXXStatusCondition are going to be the same apparently.,
1836434,jonathanvila,https://api.github.com/repos/keycloak/keycloak/pulls/9849,801694333,2022-02-08T14:32:28Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakRealmImportStatusBuilder.java,"@@ -0,0 +1,86 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.v2alpha1.crds;++import java.util.ArrayList;+import java.util.List;++public class KeycloakRealmImportStatusBuilder {",Could this class be generalised ? I assume all the XXXXStatus classes are going to be the same,
1836434,jonathanvila,https://api.github.com/repos/keycloak/keycloak/pulls/9849,801694575,2022-02-08T14:32:41Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakRealmImportStatus.java,"@@ -0,0 +1,54 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1.crds;++import java.util.List;+import java.util.Objects;++import static org.keycloak.operator.v2alpha1.crds.KeycloakRealmImportStatusCondition.DONE;++public class KeycloakRealmImportStatus {",Could this class be generalised ? I assume all the XXXXStatus classes are going to be the same,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9849,801707270,2022-02-08T14:42:46Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakRealmImportStatusCondition.java,"@@ -0,0 +1,68 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.v2alpha1.crds;++import java.util.Objects;++public class KeycloakRealmImportStatusCondition {+    public static final String DONE = ""Done"";","Those are ""string representation of an enum"", having them in the relevant class makes it somehow more clear I believe.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9849,801708120,2022-02-08T14:43:35Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakRealmImportStatusCondition.java,"@@ -0,0 +1,68 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.v2alpha1.crds;++import java.util.Objects;+",The classes are actually not the same and are exposing a different API.,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9849,801708190,2022-02-08T14:43:40Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakRealmImportStatusBuilder.java,"@@ -0,0 +1,86 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.v2alpha1.crds;++import java.util.ArrayList;+import java.util.List;++public class KeycloakRealmImportStatusBuilder {",The classes are actually not the same and are exposing a different API.,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/9849,801708938,2022-02-08T14:44:17Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakRealmImportStatus.java,"@@ -0,0 +1,54 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1.crds;++import java.util.List;+import java.util.Objects;++import static org.keycloak.operator.v2alpha1.crds.KeycloakRealmImportStatusCondition.DONE;++public class KeycloakRealmImportStatus {",The classes are actually not the same and are exposing a different API.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10053,801749658,2022-02-08T15:20:59Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/ClusterConfigDistTest.java,"@@ -66,11 +69,12 @@ void testExplicitCacheConfigFile(LaunchResult result) {     }      @Test-    @Launch({ ""start"", ""--http-enabled=true"", ""--hostname-strict false"" })+    @Launch({ ""start"", ""--auto-build"", ""--http-enabled=true"", ""--hostname-strict false"" })","why is autobuild added here if I may ask? If not accidentally, perhaps also change the name of the testmethod to reflect the change?",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10072,801798218,2022-02-08T16:03:29Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaAttributeEntity.java,"@@ -0,0 +1,101 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++import java.util.Objects;+import java.util.UUID;+import javax.persistence.Column;+import javax.persistence.FetchType;+import javax.persistence.GeneratedValue;+import javax.persistence.Id;+import javax.persistence.JoinColumn;+import javax.persistence.ManyToOne;+import javax.persistence.MappedSuperclass;+import org.hibernate.annotations.Nationalized;++@MappedSuperclass+public abstract class JpaAttributeEntity<E> implements JpaChildEntity<E> {++    @Id+    @Column+    @GeneratedValue+    private UUID id;++    @ManyToOne(fetch = FetchType.LAZY)+    @JoinColumn(name=""fk_root"")+    private E root;++    @Column+    private String name;++    @Nationalized+    @Column+    private String value;++    public JpaAttributeEntity() {+    }++    public JpaAttributeEntity(E root, String name, String value) {+        this.root = root;+        this.name = name;+        this.value = value;+    }++    public UUID getId() {+        return id;+    }++    public String getName() {+        return name;+    }++    public void setName(String name) {+        this.name = name;+    }++    public String getValue() {+        return value;+    }++    public void setValue(String value) {+        this.value = value;+    }+ +    @Override+    public E getParent() {+        return root;+    }++    public void setParent(E root) {+        this.root = root;+    }++    @Override+    public int hashCode() {+        return getClass().hashCode();+    }++    @Override+    public boolean equals(Object obj) {+        if (this == obj) return true;+        if (!(obj instanceof JpaAttributeEntity)) return false;+        JpaAttributeEntity that = (JpaAttributeEntity) obj;","The following avoids a warning in my IDE about ""Raw use of parameterized class 'JpaAttributeEntity' ""```suggestion        JpaAttributeEntity<?> that = (JpaAttributeEntity<?>) obj;```",
1836434,jonathanvila,https://api.github.com/repos/keycloak/keycloak/pulls/9849,801912433,2022-02-08T17:57:13Z,operator/src/test/java/org/keycloak/operator/RealmImportE2EIT.java,"@@ -0,0 +1,169 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.Pod;+import io.fabric8.kubernetes.api.model.ServiceBuilder;+import io.fabric8.kubernetes.client.KubernetesClientException;+import io.fabric8.kubernetes.client.extended.run.RunConfigBuilder;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealmImport;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealmImportStatusCondition;++import java.util.List;+import java.util.Map;++import static java.util.concurrent.TimeUnit.MINUTES;+import static java.util.concurrent.TimeUnit.SECONDS;+import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.v2alpha1.crds.KeycloakRealmImportStatusCondition.DONE;+import static org.keycloak.operator.v2alpha1.crds.KeycloakRealmImportStatusCondition.STARTED;+import static org.keycloak.operator.v2alpha1.crds.KeycloakRealmImportStatusCondition.HAS_ERRORS;++@QuarkusTest+public class RealmImportE2EIT extends ClusterOperatorTest {++    final static String KEYCLOAK_SERVICE_NAME = ""example-keycloak"";+    final static int KEYCLOAK_PORT = 8080;++    private KeycloakRealmImportStatusCondition getCondition(List<KeycloakRealmImportStatusCondition> conditions, String type) {+        return conditions+                .stream()+                .filter(c -> c.getType().equals(type))+                .findFirst()+                .get();+    }++    @Test+    public void testWorkingRealmImport() {+        Log.info(((operatorDeployment == OperatorDeployment.remote) ? ""Remote "" : ""Local "") + ""Run Test :"" + namespace);+        // Arrange+        k8sclient.load(getClass().getResourceAsStream(""/example-postgres.yaml"")).inNamespace(namespace).createOrReplace();+        k8sclient.load(getClass().getResourceAsStream(""/example-keycloak.yml"")).inNamespace(namespace).createOrReplace();++        k8sclient.services().inNamespace(namespace).create(+                new ServiceBuilder()+                        .withNewMetadata()+                        .withName(KEYCLOAK_SERVICE_NAME)+                        .withNamespace(namespace)+                        .endMetadata()+                        .withNewSpec()+                        .withSelector(Map.of(""app"", ""keycloak""))+                        .addNewPort()+                        .withPort(KEYCLOAK_PORT)+                        .endPort()+                        .endSpec()+                        .build()+        );++        // Act+        k8sclient.load(getClass().getResourceAsStream(""/example-realm.yaml"")).inNamespace(namespace).createOrReplace();++        // Assert+        var crSelector = k8sclient+                .resources(KeycloakRealmImport.class)+                .inNamespace(namespace)+                .withName(""example-count0-kc"");+        Awaitility.await()+                .atMost(3, MINUTES)+                .pollDelay(5, SECONDS)+                .ignoreExceptions()+                .untilAsserted(() -> {+                    var conditions = crSelector+                            .get()+                            .getStatus()+                            .getConditions();++                    assertThat(getCondition(conditions, DONE).getStatus()).isFalse();+                    assertThat(getCondition(conditions, STARTED).getStatus()).isTrue();+                    assertThat(getCondition(conditions, HAS_ERRORS).getStatus()).isFalse();+                });++        Awaitility.await()+                .atMost(3, MINUTES)+                .pollDelay(5, SECONDS)+                .ignoreExceptions()+                .untilAsserted(() -> {+                    var conditions = crSelector+                            .get()+                            .getStatus()+                            .getConditions();++                    assertThat(getCondition(conditions, DONE).getStatus()).isTrue();+                    assertThat(getCondition(conditions, STARTED).getStatus()).isFalse();+                    assertThat(getCondition(conditions, HAS_ERRORS).getStatus()).isFalse();+                });++        String url =+                ""http://"" + KEYCLOAK_SERVICE_NAME + ""."" + namespace + "":"" + KEYCLOAK_PORT + ""/realms/count0"";++        Awaitility.await().atMost(5, MINUTES).untilAsserted(() -> {+            try {+                Log.info(""Starting curl Pod to test if the realm is available"");++                Pod curlPod = k8sclient.run().inNamespace(namespace)","In fact it works....at least locally , with Minikube.Tunnels are only needed for LoadBalancers :https://minikube.sigs.k8s.io/docs/handbook/accessing/#using-minikube-tunnel$ kubectl run --image=vad1mo/hello-world-rest --port=5050 hello2 -nyournamespace$ kubectl apply -f myservice.yaml -n yournamespacemyservice.yaml ---------------------------kind: ServiceapiVersion: v1metadata:name: my-servicespec:ports:- protocol: TCPport: 5050targetPort: 5050nodePort: 30007selector:run: hello3type: NodePort curl $(minikube ip):30007/ - Hello World! Host:hello3/172.17.0.7% minikube profile list|----------|-----------|---------|--------------|------|---------|---------|-------|| Profile | VM Driver | Runtime | IP | Port | Version | Status| Nodes ||----------|-----------|---------|--------------|------|---------|---------|-------|| minikube | docker | docker | 192.168.58.2 | 8443 | v1.22.3 | Running| 1 ||----------|-----------|---------|--------------|------|---------|---------|-------|",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9997,802582422,2022-02-09T11:53:22Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/client/entity/JpaClientEntity.java,"@@ -537,9 +537,9 @@ public void setSurrogateAuthRequired(Boolean surrogateAuthRequired) {     @Override     public void removeAttribute(String name) {         for (Iterator<JpaClientAttributeEntity> iterator = attributes.iterator(); iterator.hasNext();) {-            JpaClientAttributeEntity attr = iterator.next();-            if (Objects.equals(attr.getName(), name)) {+            if (Objects.equals(iterator.next().getName(), name)) {                 iterator.remove();+                return;","The new code will remove the first entry it finds in the attributes that matches the name. As the Set here is ""flattened"", and allows for multi-value entries, this would only remove the first entry. You can see that this is no longer symmetric to setAttribute, that will add all entries that have been provides as values. ```    public void setAttribute(String name, List<String> values) {        removeAttribute(name);        for (String value : values) {            JpaClientAttributeEntity attribute = new JpaClientAttributeEntity(this, name, value);            attributes.add(attribute);        }    }``` If you want to shorten the code to remove all entries with a given name, consider the following: ``` attributes.removeIf(i -> Objects.equals(i.getName(), name));`` This would apply to all removeAttribute() instances changed in the PR / inside this storage. ",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9997,802614739,2022-02-09T12:35:22Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/JpaGroupModelCriteriaBuilder.java,"@@ -0,0 +1,141 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collection;+import java.util.Collections;+import java.util.HashSet;+import java.util.Objects;+import java.util.UUID;+import java.util.function.BiFunction;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.GroupModel;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.jpa.group.entity.JpaGroupEntity;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.storage.SearchableModelField;++public class JpaGroupModelCriteriaBuilder extends JpaModelCriteriaBuilder<JpaGroupEntity, GroupModel, JpaGroupModelCriteriaBuilder> {++    public JpaGroupModelCriteriaBuilder() {+        super(JpaGroupModelCriteriaBuilder::new);+    }++    private JpaGroupModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaGroupEntity>, Predicate> predicateFunc) {+        super(JpaGroupModelCriteriaBuilder::new, predicateFunc);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public JpaGroupModelCriteriaBuilder compare(SearchableModelField<? super GroupModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(GroupModel.SearchableFields.REALM_ID) ||+                    modelField.equals(GroupModel.SearchableFields.NAME)) {+                    validateValue(value, modelField, op, String.class);","Seeing all the validateValue() instances around here, I wonder if this should be done on the logical level / one level up. If SearchableModelField would receive a second generic type parameter for the fieldClass, it could be possible to create a type safe API where the query is constructed and it can be check at compile time. As this would affect a lot of classes, it should be a separate issue. ```public class SearchableModelField<M, T> {    private final String name;    private final Class<T> fieldClass;    public SearchableModelField(String name, Class<T> fieldClass) {        /* ... */    }    /* ... */}``` As modelField always contains the class, I wonder if there is really the need to pass on the class; it might be enough to pass on the number of expected arguments. This also would call for a separate issue. Please comment what you think is more appropriate here or if this has been discussed before. As this can be quite a big task, it also needs a decision when this should be done. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9997,802670328,2022-02-09T13:39:16Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/entity/JpaGroupEntity.java,"@@ -0,0 +1,265 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group.entity;++import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import javax.persistence.UniqueConstraint;+import javax.persistence.Version;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.group.MapGroupEntity.AbstractGroupEntity;+import static org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_GROUP;+import org.keycloak.models.map.storage.jpa.JpaRootEntity;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++/**+ * There are some fields marked by {@code @Column(insertable = false, updatable = false)}.+ * Those fields are automatically generated by database from json field,+ * therefore marked as non-insertable and non-updatable to instruct hibernate.+ */+@Entity+@Table(name = ""\""group\"""", uniqueConstraints = {@UniqueConstraint(columnNames = {""realmId"", ""name"", ""parentId""})})","Could a non-keyword be used for the table name, e.g. `KC_GROUP`? This would be less error prone both in liquibase scripts and potential migrations, and also could help the administrators who would be querying the database directly. Perhaps applies to roles as well?",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9997,802875854,2022-02-09T16:46:09Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/entity/JpaGroupEntity.java,"@@ -0,0 +1,265 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group.entity;++import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import javax.persistence.UniqueConstraint;+import javax.persistence.Version;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.group.MapGroupEntity.AbstractGroupEntity;+import static org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_GROUP;+import org.keycloak.models.map.storage.jpa.JpaRootEntity;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++/**+ * There are some fields marked by {@code @Column(insertable = false, updatable = false)}.+ * Those fields are automatically generated by database from json field,+ * therefore marked as non-insertable and non-updatable to instruct hibernate.+ */+@Entity+@Table(name = ""\""group\"""", uniqueConstraints = {@UniqueConstraint(columnNames = {""realmId"", ""name"", ""parentId""})})",":shrug: I also saw `GROUPS` on SO as a suggestion, didn't think it would fit here for the same reason you mentioned. Also [replacing some characters with unicode characters](https://stackoverflow.com/questions/19391153/mysql-table-name-with-utf-characters) that look like `GROUPS` or add nice pictures wouldn't be much help and would be bad for everyone's karma.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9997,802998962,2022-02-09T19:05:34Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/entity/JpaGroupEntity.java,"@@ -0,0 +1,265 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group.entity;++import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;+import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import javax.persistence.UniqueConstraint;+import javax.persistence.Version;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.group.MapGroupEntity.AbstractGroupEntity;+import static org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_GROUP;+import org.keycloak.models.map.storage.jpa.JpaRootEntity;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++/**+ * There are some fields marked by {@code @Column(insertable = false, updatable = false)}.+ * Those fields are automatically generated by database from json field,+ * therefore marked as non-insertable and non-updatable to instruct hibernate.+ */+@Entity+@Table(name = ""\""group\"""", uniqueConstraints = {@UniqueConstraint(columnNames = {""realmId"", ""name"", ""parentId""})})","Let's then use `KC_` prefix everywhere - its short, and it seems that not only in my experience [singular is preferred](https://stackoverflow.com/questions/338156/table-naming-dilemma-singular-vs-plural-names).It also has the benefit for clearly distinguishing keycloak tables from custom tables, should there be any.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9997,803003369,2022-02-09T19:11:19Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/JpaGroupModelCriteriaBuilder.java,"@@ -0,0 +1,141 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collection;+import java.util.Collections;+import java.util.HashSet;+import java.util.Objects;+import java.util.UUID;+import java.util.function.BiFunction;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.GroupModel;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.jpa.group.entity.JpaGroupEntity;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.storage.SearchableModelField;++public class JpaGroupModelCriteriaBuilder extends JpaModelCriteriaBuilder<JpaGroupEntity, GroupModel, JpaGroupModelCriteriaBuilder> {++    public JpaGroupModelCriteriaBuilder() {+        super(JpaGroupModelCriteriaBuilder::new);+    }++    private JpaGroupModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaGroupEntity>, Predicate> predicateFunc) {+        super(JpaGroupModelCriteriaBuilder::new, predicateFunc);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public JpaGroupModelCriteriaBuilder compare(SearchableModelField<? super GroupModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(GroupModel.SearchableFields.REALM_ID) ||+                    modelField.equals(GroupModel.SearchableFields.NAME)) {+                    validateValue(value, modelField, op, String.class);","A map storage implementation can choose what it would implement and can choose to implement only a proper subset of available field / operator / parameter combinations, and no such limitation could be caught by a validation on logical level. Thus the `validateValue` is placed appropriately here.",
13701445,dteleguin,https://api.github.com/repos/keycloak/keycloak/pulls/8895,803208262,2022-02-10T00:41:38Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java,"@@ -489,6 +519,18 @@ private void checkMtlsHoKToken(TokenManager.AccessTokenResponseBuilder responseB         }     } +    private void checkDPoPToken(TokenManager.AccessTokenResponseBuilder responseBuilder, boolean useRefreshToken) {+        // KEYCLOAK-15169 OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP)+        // https://tools.ietf.org/id/draft-ietf-oauth-dpop-04.html#section-6+        if (clientConfig.isDPoPEnabled()) {+            DPoPUtil.bindToken(responseBuilder.getAccessToken(), dPoP);+            // TODO do not bind refresh tokens issued to confidential clients, see 5. DPoP Access Token Request","This one turned out to be particularly tricky. In `TokenManager#refreshAccessToken()`, we're copying the `cnf` section from the refresh token to the newly issued access token. This won't work if the refresh token doesn't contain `cnf` anymore, e.g. in case of confidential client. Thus, we'll need to recompute the bindings anew. To keep the code aligned, I've moved recomputation to `TokenEndpoint#refreshTokenGrant()`, similar to what we're doing for authorization code and ROPC. I've also removed `TokenManager.RefreshResult`, which seems to be an ad-hoc class used only once. Instead, I've made `TokenManager#refreshAccessToken()` return a mutable `AccessTokenResponseBuilder`.Please let me know if you think it would be better to remove `TokenManager.RefreshResult` via a separate PR.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803416398,2022-02-10T08:32:21Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -0,0 +1,138 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.utils.CRAssert;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++import java.time.Duration;+import java.util.List;+import java.util.Map;++import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.utils.K8sUtils.deployKeycloak;+import static org.keycloak.operator.utils.K8sUtils.getDefaultKeycloakDeployment;+import static org.keycloak.operator.utils.K8sUtils.waitForKeycloakToBeReady;++@QuarkusTest+public class KeycloakDeploymentE2EIT extends ClusterOperatorTest {+    @Test+    public void given_ClusterAndOperatorRunning_when_KeycloakCRCreated_Then_KeycloakStructureIsDeployedAndStatusIsOK() {+        try {+            // CR+            Log.info(""Creating new Keycloak CR example"");+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            // Check Operator has deployed Keycloak+            Log.info(""Checking Operator has deployed Keycloak deployment"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNotNull();++            // Check Keycloak has correct replicas+            Log.info(""Checking Keycloak pod has ready replicas == 1"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get().getStatus().getReadyReplicas()).isEqualTo(1);++            // Delete CR+            Log.info(""Deleting Keycloak CR and watching cleanup"");+            k8sclient.resources(Keycloak.class).delete(kc);+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNull());+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testImageChange() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            kc.getSpec().setImage(""quay.io/keycloak/non-existing-keycloak"");++            deployKeycloak(k8sclient, kc, false);+            waitForKcToFail(kc);+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testServerConfiguration() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            kc.getSpec().getServerConfiguration().put(""KC_DB_PASSWORD"", ""Ay Caramba!"");++            deployKeycloak(k8sclient, kc, false);+            waitForKcToFail(kc);+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testDeploymentDurability() throws InterruptedException {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            Log.info(""Trying to delete deployment"");+            assertThat(k8sclient.apps().deployments().withName(deploymentName).delete()).isTrue();+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().withName(deploymentName).get()).isNotNull());++            waitForKeycloakToBeReady(k8sclient, kc); // wait for reconciler to calm down to avoid race condititon++            Log.info(""Trying to modify deployment"");++            var deployment = k8sclient.apps().deployments().withName(deploymentName).get();+            var labels = Map.of(""address"", ""EvergreenTerrace742"");+            var flandersEnvVar = new EnvVarBuilder().withName(""NEIGHBOR"").withValue(""Stupid Flanders!"").build();+            var origSpecs = deployment.getSpec();++            deployment.getMetadata().getLabels().putAll(labels);+            deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setEnv(List.of(flandersEnvVar));+            k8sclient.apps().deployments().createOrReplace(deployment);++            Awaitility.await()+                    .untilAsserted(() -> {+                        var d = k8sclient.apps().deployments().withName(deploymentName).get();+                        assertThat(d.getMetadata().getLabels().entrySet().containsAll(labels.entrySet())).isTrue(); // additional labels should not be overwritten+                        assertThat(d.getSpec()).isEqualTo(origSpecs); // specs should be reconciled back to original values+                    });+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    // TODO Test HasErrors condition; ReplicaFailure is not easily reproducible++    private void waitForKcToFail(Keycloak kc) {+        Awaitility.await()+                .ignoreExceptions()+                .pollDelay(Duration.ofSeconds(60)) // just to be sure the cluster had enough time to deploy KC+                .untilAsserted(() -> {+                    var currentKc = k8sclient.resources(Keycloak.class).withName(kc.getMetadata().getName()).get();+                    CRAssert.assertKeycloakStatusCondition(currentKc, KeycloakStatusCondition.READY, false);","I don't think this is quite enough, this test will succeed even in pretty standard conditions, such as: - waiting for the probes - any transient issue",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803418173,2022-02-10T08:34:32Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -0,0 +1,138 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.utils.CRAssert;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++import java.time.Duration;+import java.util.List;+import java.util.Map;++import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.utils.K8sUtils.deployKeycloak;+import static org.keycloak.operator.utils.K8sUtils.getDefaultKeycloakDeployment;+import static org.keycloak.operator.utils.K8sUtils.waitForKeycloakToBeReady;++@QuarkusTest+public class KeycloakDeploymentE2EIT extends ClusterOperatorTest {+    @Test+    public void given_ClusterAndOperatorRunning_when_KeycloakCRCreated_Then_KeycloakStructureIsDeployedAndStatusIsOK() {+        try {+            // CR+            Log.info(""Creating new Keycloak CR example"");+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            // Check Operator has deployed Keycloak+            Log.info(""Checking Operator has deployed Keycloak deployment"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNotNull();++            // Check Keycloak has correct replicas+            Log.info(""Checking Keycloak pod has ready replicas == 1"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get().getStatus().getReadyReplicas()).isEqualTo(1);++            // Delete CR+            Log.info(""Deleting Keycloak CR and watching cleanup"");+            k8sclient.resources(Keycloak.class).delete(kc);+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNull());+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testImageChange() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            kc.getSpec().setImage(""quay.io/keycloak/non-existing-keycloak"");++            deployKeycloak(k8sclient, kc, false);+            waitForKcToFail(kc);","This check is not quite enough to tell that it's failing for `ImagePullBackoff`, either: - remove the test at all and tackle it in https://github.com/keycloak/keycloak/issues/10099 - check for the specific condition",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803419289,2022-02-10T08:35:55Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -0,0 +1,138 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.utils.CRAssert;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++import java.time.Duration;+import java.util.List;+import java.util.Map;++import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.utils.K8sUtils.deployKeycloak;+import static org.keycloak.operator.utils.K8sUtils.getDefaultKeycloakDeployment;+import static org.keycloak.operator.utils.K8sUtils.waitForKeycloakToBeReady;++@QuarkusTest+public class KeycloakDeploymentE2EIT extends ClusterOperatorTest {+    @Test+    public void given_ClusterAndOperatorRunning_when_KeycloakCRCreated_Then_KeycloakStructureIsDeployedAndStatusIsOK() {+        try {+            // CR+            Log.info(""Creating new Keycloak CR example"");+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            // Check Operator has deployed Keycloak+            Log.info(""Checking Operator has deployed Keycloak deployment"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNotNull();++            // Check Keycloak has correct replicas+            Log.info(""Checking Keycloak pod has ready replicas == 1"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get().getStatus().getReadyReplicas()).isEqualTo(1);++            // Delete CR+            Log.info(""Deleting Keycloak CR and watching cleanup"");+            k8sclient.resources(Keycloak.class).delete(kc);+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNull());+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testImageChange() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            kc.getSpec().setImage(""quay.io/keycloak/non-existing-keycloak"");++            deployKeycloak(k8sclient, kc, false);+            waitForKcToFail(kc);+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testServerConfiguration() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            kc.getSpec().getServerConfiguration().put(""KC_DB_PASSWORD"", ""Ay Caramba!"");++            deployKeycloak(k8sclient, kc, false);+            waitForKcToFail(kc);","Waiting for ""Fail"" is not enough, here you should check the pod logs to detect database connection issues.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803425920,2022-02-10T08:43:52Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -122,6 +137,41 @@ private static void calculateNamespace() {     namespace = ""keycloak-test-"" + UUID.randomUUID();   } +  protected static void deployDB() {+    // DB+    Log.info(""Creating new PostgreSQL deployment"");+    k8sclient.load(KeycloakDeploymentE2EIT.class.getResourceAsStream(""/example-postgres.yaml"")).inNamespace(namespace).createOrReplace();++    // Check DB has deployed and ready+    Log.info(""Checking Postgres is running"");+    Awaitility.await()+            .untilAsserted(() -> assertThat(k8sclient.apps().statefulSets().inNamespace(namespace).withName(""postgresql-db"").get().getStatus().getReadyReplicas()).isEqualTo(1));+  }++  // TODO improve this (preferably move to JOSDK)+  protected void savePodLogs() {","this forces us to enclose all the tests in big `try ... catch` blocks, it will also increase the technical debt(already pretty high) of the tests.Since this is not related to the scope of this PR, can you please exclude from the current PR and open a relevant ticket?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803427637,2022-02-10T08:45:53Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -0,0 +1,138 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.utils.CRAssert;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++import java.time.Duration;+import java.util.List;+import java.util.Map;++import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.utils.K8sUtils.deployKeycloak;+import static org.keycloak.operator.utils.K8sUtils.getDefaultKeycloakDeployment;+import static org.keycloak.operator.utils.K8sUtils.waitForKeycloakToBeReady;++@QuarkusTest+public class KeycloakDeploymentE2EIT extends ClusterOperatorTest {+    @Test+    public void given_ClusterAndOperatorRunning_when_KeycloakCRCreated_Then_KeycloakStructureIsDeployedAndStatusIsOK() {+        try {+            // CR+            Log.info(""Creating new Keycloak CR example"");+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            // Check Operator has deployed Keycloak+            Log.info(""Checking Operator has deployed Keycloak deployment"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNotNull();++            // Check Keycloak has correct replicas+            Log.info(""Checking Keycloak pod has ready replicas == 1"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get().getStatus().getReadyReplicas()).isEqualTo(1);++            // Delete CR+            Log.info(""Deleting Keycloak CR and watching cleanup"");+            k8sclient.resources(Keycloak.class).delete(kc);+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNull());+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testImageChange() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            kc.getSpec().setImage(""quay.io/keycloak/non-existing-keycloak"");++            deployKeycloak(k8sclient, kc, false);+            waitForKcToFail(kc);+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testServerConfiguration() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            kc.getSpec().getServerConfiguration().put(""KC_DB_PASSWORD"", ""Ay Caramba!"");++            deployKeycloak(k8sclient, kc, false);+            waitForKcToFail(kc);+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testDeploymentDurability() throws InterruptedException {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            Log.info(""Trying to delete deployment"");+            assertThat(k8sclient.apps().deployments().withName(deploymentName).delete()).isTrue();+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().withName(deploymentName).get()).isNotNull());++            waitForKeycloakToBeReady(k8sclient, kc); // wait for reconciler to calm down to avoid race condititon++            Log.info(""Trying to modify deployment"");++            var deployment = k8sclient.apps().deployments().withName(deploymentName).get();+            var labels = Map.of(""address"", ""EvergreenTerrace742"");+            var flandersEnvVar = new EnvVarBuilder().withName(""NEIGHBOR"").withValue(""Stupid Flanders!"").build();+            var origSpecs = deployment.getSpec();++            deployment.getMetadata().getLabels().putAll(labels);+            deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setEnv(List.of(flandersEnvVar));+            k8sclient.apps().deployments().createOrReplace(deployment);++            Awaitility.await()+                    .untilAsserted(() -> {+                        var d = k8sclient.apps().deployments().withName(deploymentName).get();+                        assertThat(d.getMetadata().getLabels().entrySet().containsAll(labels.entrySet())).isTrue(); // additional labels should not be overwritten+                        assertThat(d.getSpec()).isEqualTo(origSpecs); // specs should be reconciled back to original values+                    });+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    // TODO Test HasErrors condition; ReplicaFailure is not easily reproducible","Given this comment, should we iterate over this logic? (in a separate ticket)https://github.com/keycloak/keycloak/blob/011d108fff1554e1784e0b9c70552e45ded7ec50/operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java#L144-L150",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803430497,2022-02-10T08:49:07Z,operator/src/test/java/org/keycloak/operator/utils/K8sUtils.java,"@@ -0,0 +1,56 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.utils;++import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.awaitility.Awaitility;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++/**+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public final class K8sUtils {+    public static Keycloak getDefaultKeycloakDeployment(KubernetesClient client) {+        return (Keycloak) client.load(K8sUtils.class.getResourceAsStream(""/example-keycloak.yml"")).get().get(0);","you don't even need the client at all, something on those lines (ping me if it doesn't work for any reason):```javaSerialization.unmarshal(K8sUtils.class.getResourceAsStream(""/example-keycloak.yml""), Keycloak.class)```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10106,803487875,2022-02-10T09:50:18Z,docs/guides/src/main/server/configuration.adoc,"@@ -52,57 +50,53 @@ export KC_DB_URL_HOST=mykeycloakdb db-url-host=mykeycloakdb ``` -The configuration source and the corresponding format you should use is use-case specific. That decision depends on the platform the server is deployed to-as well as on the optimizations you can get for an optimal runtime. For instance, when deploying the server into Kubernetes you would probably rely-on environment variables to configure the server. However, you are not limited to use a single configuration source and format.+The configuration source and the corresponding format you should use is use-case specific. That decision depends on the platform where the server is deployed and the runtime optimizations you are seeking. For instance, if you deploy the server into Kubernetes, you would probably rely+on environment variables to configure the server. However, you are not limited to a single configuration source or format. -== Configuring the server+== Configuration commands and stages -The server options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects-of the server configuration and is related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.+The server options are narrowed to a specific command or configuration stage. The goal is to perform a series of optimizations in a specific order to achieve optimal startup and runtime performance. This configuration occurs in two stages: -Configuration is basically done in two stages:+First stage:: Configuration performed before starting the server in order to build an optimized server image for use at runtime+Second stage:: Configuration performed as part of starting the server -* Before starting the server in order to build an optimized server image for an optimal runtime-* When starting the server+[discrete]","We're not using discrete headings anywhere else, so i'd suggest not to start here. there are multiple layers of parsing (freemarker -> asciidoc -> html/css at website) so we try to keep the amount of complexity low by not using too many asciidoc attributes when possible.Also, these sub-headlines are perfectly valid in general and when i understand correctly would not show up in the ToC each guide will have on the website when discrete is used.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10106,803494873,2022-02-10T09:57:37Z,docs/guides/src/main/server/configuration.adoc,"@@ -52,57 +50,53 @@ export KC_DB_URL_HOST=mykeycloakdb db-url-host=mykeycloakdb ``` -The configuration source and the corresponding format you should use is use-case specific. That decision depends on the platform the server is deployed to-as well as on the optimizations you can get for an optimal runtime. For instance, when deploying the server into Kubernetes you would probably rely-on environment variables to configure the server. However, you are not limited to use a single configuration source and format.+The configuration source and the corresponding format you should use is use-case specific. That decision depends on the platform where the server is deployed and the runtime optimizations you are seeking. For instance, if you deploy the server into Kubernetes, you would probably rely+on environment variables to configure the server. However, you are not limited to a single configuration source or format. -== Configuring the server+== Configuration commands and stages -The server options are narrowed to a specific command or configuration stage. This clear separation is one of the key aspects-of the server configuration and is related to a series of optimizations that are done in order to deliver the best runtime when starting and running the server.+The server options are narrowed to a specific command or configuration stage. The goal is to perform a series of optimizations in a specific order to achieve optimal startup and runtime performance. This configuration occurs in two stages: -Configuration is basically done in two stages:+First stage:: Configuration performed before starting the server in order to build an optimized server image for use at runtime+Second stage:: Configuration performed as part of starting the server -* Before starting the server in order to build an optimized server image for an optimal runtime-* When starting the server+[discrete]+=== The first stage -The first stage involves running the `build` command and set any **build option** available from this command to configure the server.+The first stage involves running the `build` command and setting any **build option** available from this command to configure the server. -By looking at the individual configuration options at <@links.server id=""all-config""/>, you notice-that some options are marked with an icon to indicate they are a build option. In other words, they can only be set and only take effect when running the `build` command.-You can also check all the options that require a build by looking at the `help` message of the `build` command:+The configuration options at <@links.server id=""all-config""/> includes options that are marked with an icon. Those options are build options; they only take effect when you run the `build` command.+You can also check which options require a build by looking at the `help` message of the `build` command:  <@kc.build parameters=""--help""/> -The `build` command is responsible for producing an immutable and optimized server image, which is similar to building a container image. In addition to persisting-any build option you have set, this command also performs a series of optimizations to deliver the best runtime when starting and running the server. As a result,-a lot of processing that would usually happen when starting and running the server is no longer necessary and the server can start and run faster.+The `build` command can produce an immutable and optimized server image, which is similar to building a container image. In addition to persisting build options, this command also performs optimizations for the best startup and runtime performance. The result is that much processing for starting and running the server is eliminated so that the server starts and runs faster.","```suggestionThe `build` command can produce an immutable and optimized server image, which is similar to building a container image. In addition to persisting build options, this command also performs optimizations for the best startup and runtime performance. The result is that much processing for starting and running the server is done before starting Keycloak, so Keycloak is able to start up and run faster later on.```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10106,803516345,2022-02-10T10:21:15Z,docs/guides/src/main/server/configuration.adoc,"@@ -118,25 +112,25 @@ hostname mykeycloak.acme.com .Start the server <@kc.start/> -By following that approach, the server is going to skip some steps at startup and start faster.+By using the `keycloak.conf` file, the server can omit some steps at startup. As a result, the server starts faster. -== Using the `auto-build` option when starting the server+== Two configuration stages from one command","I'd like to leave the ""auto-build"" in the headline. This will be the searchterm everybody will search for who really wants to use this, as it is mentioned everywhere form CLI help to blog entries etc.Suggestion: Leave as is, or something like ""Using the `auto-build` option to automatically detect when the server needs a build"" (which is too long imo)",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9997,803522388,2022-02-10T10:27:56Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/JpaGroupModelCriteriaBuilder.java,"@@ -0,0 +1,141 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collection;+import java.util.Collections;+import java.util.HashSet;+import java.util.Objects;+import java.util.UUID;+import java.util.function.BiFunction;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.GroupModel;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.jpa.group.entity.JpaGroupEntity;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.storage.SearchableModelField;++public class JpaGroupModelCriteriaBuilder extends JpaModelCriteriaBuilder<JpaGroupEntity, GroupModel, JpaGroupModelCriteriaBuilder> {++    public JpaGroupModelCriteriaBuilder() {+        super(JpaGroupModelCriteriaBuilder::new);+    }++    private JpaGroupModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaGroupEntity>, Predicate> predicateFunc) {+        super(JpaGroupModelCriteriaBuilder::new, predicateFunc);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public JpaGroupModelCriteriaBuilder compare(SearchableModelField<? super GroupModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(GroupModel.SearchableFields.REALM_ID) ||+                    modelField.equals(GroupModel.SearchableFields.NAME)) {+                    validateValue(value, modelField, op, String.class);","Hi @hmlnarik - I understand that an implementation can limit the fields and operations, and potentially also parameter combinations although I don't have an example for the latter at hand. Given the situation above, I would assume that even the logical layer could validate that EQ mandates for exactly one parameter. When the compare() is called for REALM_ID and NAME, both specify String as their fieldClass. Would it be allowed on a logical level to pass an integer, or would we assume/require on a logical level to pass as the parameter only a type that matches the type of the field?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10106,803529145,2022-02-10T10:35:29Z,docs/guides/src/main/server/configuration.adoc,"@@ -145,38 +139,35 @@ You can also specify a different configuration file by using the `[-cf|--config- <@kc.start rootParameters=""-cf myconfig.conf""/>  Changes to any *build option* defined in the `keycloak.conf` file that is targeted for the `build` command are ignored-if the value differs from the value used to previously run the `build` command. In this case, make sure you run the `build` command again so that+if the value differs from the value for the last `build` command. In this case, make sure you run the `build` command again so that any build option is updated accordingly. -=== Understanding the development and production modes--By default, the server defines two main operating modes:+=== Development versus production mode -* Development-* Production+The server supports the following operating modes: -The development mode is activated every time you run the `start-dev` command. In this mode, some key configuration options are set to make it possible to start the+Development mode:: This mode is activated every time you run the `start-dev` command. In this mode, some key configuration options are set to make it possible to start the server for development purposes without the burden of having to define additional settings that are mandatory for production. -The production mode is activated by default when you run the `build` or the `start` command. Use this mode to set any configuration option that+Production mode:: This mode is activated by default when you run the `build` or the `start` command. Use this mode to set any configuration option that is needed for deploying Keycloak in production. -By default, the configurations options for the production mode are commented out in the `conf/keycloak.conf`. These examples- are meant to give you an idea about the main settings that needs to be considered when running in production.+By default, the configuration options for the production mode are commented out in the `conf/keycloak.conf`. These examples+ are meant to give you an idea about the main settings to consider when running in production. -== Using unsupported server options+== Unsupported server options -Most of the time the available options from the server configuration should be enough to configure the server.-However, you might need to use properties directly from Quarkus in order to enable a specific behavior or capability that is missing from the server configuration.+In most cases, the available options from the server configuration should suffice to configure the server.+However, you might need to use properties directly from Quarkus to enable a specific behavior or capability that is missing from the server configuration. -You should avoid as much as possible using properties directly from Quarkus. If you really need to, consider opening an https://github.com/keycloak/keycloak/issues/new?assignees=&labels=kind%2Fenhancement%2Cstatus%2Ftriage&template=enhancement.yml[issue] first and help us+As much as possible, avoid using properties directly from Quarkus. If your need is essential, consider opening an https://github.com/keycloak/keycloak/issues/new?assignees=&labels=kind%2Fenhancement%2Cstatus%2Ftriage&template=enhancement.yml[issue] first and help us to improve the server configuration. -To configure the server using Quarkus properties you should follow these steps:+To configure the server using Quarkus properties, perform the following steps: -* Create a `conf/quarkus.properties` file and define any property you need-* Run the `build` command to apply the settings to the server+. Create a `conf/quarkus.properties` file and define any property you need.","Not 100% sure, but shouldn't these stay bullet points of an unordered list? (a `*`)",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9997,803548736,2022-02-10T10:58:06Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/JpaGroupModelCriteriaBuilder.java,"@@ -0,0 +1,141 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collection;+import java.util.Collections;+import java.util.HashSet;+import java.util.Objects;+import java.util.UUID;+import java.util.function.BiFunction;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.GroupModel;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.jpa.group.entity.JpaGroupEntity;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.storage.SearchableModelField;++public class JpaGroupModelCriteriaBuilder extends JpaModelCriteriaBuilder<JpaGroupEntity, GroupModel, JpaGroupModelCriteriaBuilder> {++    public JpaGroupModelCriteriaBuilder() {+        super(JpaGroupModelCriteriaBuilder::new);+    }++    private JpaGroupModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaGroupEntity>, Predicate> predicateFunc) {+        super(JpaGroupModelCriteriaBuilder::new, predicateFunc);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public JpaGroupModelCriteriaBuilder compare(SearchableModelField<? super GroupModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(GroupModel.SearchableFields.REALM_ID) ||+                    modelField.equals(GroupModel.SearchableFields.NAME)) {+                    validateValue(value, modelField, op, String.class);","I would like to have such an enhancement in. It would then be able to keep the source code tidier.Yet I think there is a case that may be very tricky to handle in Java type system: While `EQ` is a straightforward example where such validation would work, problems arise with collection-like parameters, e.g. `IN`. Parameters of those operators might be collections, arrays as well as streams. How would this be handled?As for the example for multiple values - attribute searchable fields require two parameters: parameter name and value. Since java has no varags support for type variables, I suspect the solution would be a bit hacky involving number of warnings, though I'm happy to be convinced otherwise.I'm open for suggestions how to handle those, as long as the solution would be straightforward.As a side note: I'm not convinced the `fieldClass` should remain amongst properties the searchable fields. I don't think it's ever used and while introduced with a good intention similar to the suggestion here, it turned out to be impractical to leverage it.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9997,803709600,2022-02-10T14:07:11Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/group/JpaGroupModelCriteriaBuilder.java,"@@ -0,0 +1,141 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ * + * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ * + * http://www.apache.org/licenses/LICENSE-2.0+ * + * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.group;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.Collection;+import java.util.Collections;+import java.util.HashSet;+import java.util.Objects;+import java.util.UUID;+import java.util.function.BiFunction;+import java.util.stream.Collectors;+import java.util.stream.Stream;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;+import org.keycloak.models.GroupModel;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.jpa.group.entity.JpaGroupEntity;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.storage.SearchableModelField;++public class JpaGroupModelCriteriaBuilder extends JpaModelCriteriaBuilder<JpaGroupEntity, GroupModel, JpaGroupModelCriteriaBuilder> {++    public JpaGroupModelCriteriaBuilder() {+        super(JpaGroupModelCriteriaBuilder::new);+    }++    private JpaGroupModelCriteriaBuilder(BiFunction<CriteriaBuilder, Root<JpaGroupEntity>, Predicate> predicateFunc) {+        super(JpaGroupModelCriteriaBuilder::new, predicateFunc);+    }++    @Override+    @SuppressWarnings(""unchecked"")+    public JpaGroupModelCriteriaBuilder compare(SearchableModelField<? super GroupModel> modelField, Operator op, Object... value) {+        switch (op) {+            case EQ:+                if (modelField.equals(GroupModel.SearchableFields.REALM_ID) ||+                    modelField.equals(GroupModel.SearchableFields.NAME)) {+                    validateValue(value, modelField, op, String.class);","> A short comment on priorities would be nice [...]Priority-wise I don't see this as a priority. This is certainly a nice-to-have rather than must-have for functionalit:- During runtime, such a check would only be able to throw an exception which is the situation we're in already.- It would be useful if it could be used for testing during compile time.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803878499,2022-02-10T16:44:55Z,operator/src/test/java/org/keycloak/operator/utils/K8sUtils.java,"@@ -0,0 +1,56 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.utils;++import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.awaitility.Awaitility;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++/**+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public final class K8sUtils {+    public static Keycloak getDefaultKeycloakDeployment(KubernetesClient client) {+        return (Keycloak) client.load(K8sUtils.class.getResourceAsStream(""/example-keycloak.yml"")).get().get(0);+    }++    public static void deployKeycloak(KubernetesClient client, Keycloak kc, boolean waitUntilReady) {+        client.resources(Keycloak.class).createOrReplace(kc);",Here:https://github.com/keycloak/keycloak/blob/0fcf13406093b9a5a7fb2e252314548d203d8f19/operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java#L84It's the default namespace for the client.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803878678,2022-02-10T16:45:03Z,operator/src/test/java/org/keycloak/operator/utils/K8sUtils.java,"@@ -0,0 +1,56 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.utils;++import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.awaitility.Awaitility;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++/**+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public final class K8sUtils {+    public static Keycloak getDefaultKeycloakDeployment(KubernetesClient client) {+        return (Keycloak) client.load(K8sUtils.class.getResourceAsStream(""/example-keycloak.yml"")).get().get(0);+    }++    public static void deployKeycloak(KubernetesClient client, Keycloak kc, boolean waitUntilReady) {+        client.resources(Keycloak.class).createOrReplace(kc);++        if (waitUntilReady) {+            waitForKeycloakToBeReady(client, kc);+        }+    }++    public static void deployDefaultKeycloak(KubernetesClient client) {+        deployKeycloak(client, getDefaultKeycloakDeployment(client), true);+    }++    public static void waitForKeycloakToBeReady(KubernetesClient client, Keycloak kc) {+        Log.infof(""Waiting for Keycloak \""%s\"""", kc.getMetadata().getName());+        Awaitility.await()+                .ignoreExceptions()+                .untilAsserted(() -> {+                    var currentKc = client.resources(Keycloak.class).withName(kc.getMetadata().getName()).get();",Here:https://github.com/keycloak/keycloak/blob/0fcf13406093b9a5a7fb2e252314548d203d8f19/operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java#L84It's the default namespace for the client.,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10102,803925561,2022-02-10T17:25:19Z,operator/src/test/java/org/keycloak/operator/utils/K8sUtils.java,"@@ -0,0 +1,56 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.utils;++import io.fabric8.kubernetes.client.KubernetesClient;+import io.quarkus.logging.Log;+import org.awaitility.Awaitility;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++/**+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public final class K8sUtils {+    public static Keycloak getDefaultKeycloakDeployment(KubernetesClient client) {+        return (Keycloak) client.load(K8sUtils.class.getResourceAsStream(""/example-keycloak.yml"")).get().get(0);","```javareturn ((List<HasMetadata>) Serialization.unmarshal(K8sUtils.class.getResourceAsStream(""/example-keycloak.yml""), Collections.emptyMap())).get(0)```should work ...",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10102,804428761,2022-02-11T08:11:58Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -0,0 +1,125 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.utils.CRAssert;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++import java.time.Duration;+import java.util.List;+import java.util.Map;++import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.utils.K8sUtils.deployKeycloak;+import static org.keycloak.operator.utils.K8sUtils.getDefaultKeycloakDeployment;+import static org.keycloak.operator.utils.K8sUtils.waitForKeycloakToBeReady;++@QuarkusTest+public class KeycloakDeploymentE2EIT extends ClusterOperatorTest {+    @Test+    public void testBasicKeycloakDeploymentAndDeletion() {+        try {+            // CR+            Log.info(""Creating new Keycloak CR example"");+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            // Check Operator has deployed Keycloak+            Log.info(""Checking Operator has deployed Keycloak deployment"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNotNull();++            // Check Keycloak has correct replicas+            Log.info(""Checking Keycloak pod has ready replicas == 1"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get().getStatus().getReadyReplicas()).isEqualTo(1);++            // Delete CR+            Log.info(""Deleting Keycloak CR and watching cleanup"");+            k8sclient.resources(Keycloak.class).delete(kc);+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNull());+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testCRFields() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            kc.getSpec().setImage(""quay.io/keycloak/non-existing-keycloak"");+            kc.getSpec().getServerConfiguration().put(""KC_DB_PASSWORD"", ""Ay Caramba!"");+            deployKeycloak(k8sclient, kc, false);++            Awaitility.await()+                    .during(Duration.ofSeconds(15)) // check if the Deployment is stable+                    .untilAsserted(() -> {+                        var c = k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()+                                .getSpec().getTemplate().getSpec().getContainers().get(0);+                        assertThat(c.getImage()).isEqualTo(""quay.io/keycloak/non-existing-keycloak"");+                        assertThat(c.getEnv().stream()+                                .anyMatch(e -> e.getName().equals(""KC_DB_PASSWORD"") && e.getValue().equals(""Ay Caramba!"")))+                                .isTrue();+                    });++        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testDeploymentDurability() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            Log.info(""Trying to delete deployment"");+            assertThat(k8sclient.apps().deployments().withName(deploymentName).delete()).isTrue();+            Awaitility.await()",https://github.com/keycloak/keycloak/blob/0fcf13406093b9a5a7fb2e252314548d203d8f19/operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java#L172,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10102,804428833,2022-02-11T08:12:04Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -0,0 +1,125 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.utils.CRAssert;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++import java.time.Duration;+import java.util.List;+import java.util.Map;++import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.utils.K8sUtils.deployKeycloak;+import static org.keycloak.operator.utils.K8sUtils.getDefaultKeycloakDeployment;+import static org.keycloak.operator.utils.K8sUtils.waitForKeycloakToBeReady;++@QuarkusTest+public class KeycloakDeploymentE2EIT extends ClusterOperatorTest {+    @Test+    public void testBasicKeycloakDeploymentAndDeletion() {+        try {+            // CR+            Log.info(""Creating new Keycloak CR example"");+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            // Check Operator has deployed Keycloak+            Log.info(""Checking Operator has deployed Keycloak deployment"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNotNull();++            // Check Keycloak has correct replicas+            Log.info(""Checking Keycloak pod has ready replicas == 1"");+            assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get().getStatus().getReadyReplicas()).isEqualTo(1);++            // Delete CR+            Log.info(""Deleting Keycloak CR and watching cleanup"");+            k8sclient.resources(Keycloak.class).delete(kc);+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()).isNull());+        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testCRFields() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            kc.getSpec().setImage(""quay.io/keycloak/non-existing-keycloak"");+            kc.getSpec().getServerConfiguration().put(""KC_DB_PASSWORD"", ""Ay Caramba!"");+            deployKeycloak(k8sclient, kc, false);++            Awaitility.await()+                    .during(Duration.ofSeconds(15)) // check if the Deployment is stable+                    .untilAsserted(() -> {+                        var c = k8sclient.apps().deployments().inNamespace(namespace).withName(deploymentName).get()+                                .getSpec().getTemplate().getSpec().getContainers().get(0);+                        assertThat(c.getImage()).isEqualTo(""quay.io/keycloak/non-existing-keycloak"");+                        assertThat(c.getEnv().stream()+                                .anyMatch(e -> e.getName().equals(""KC_DB_PASSWORD"") && e.getValue().equals(""Ay Caramba!"")))+                                .isTrue();+                    });++        } catch (Exception e) {+            savePodLogs();+            throw e;+        }+    }++    @Test+    public void testDeploymentDurability() {+        try {+            var kc = getDefaultKeycloakDeployment(k8sclient);+            var deploymentName = kc.getMetadata().getName();+            deployKeycloak(k8sclient, kc, true);++            Log.info(""Trying to delete deployment"");+            assertThat(k8sclient.apps().deployments().withName(deploymentName).delete()).isTrue();+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments().withName(deploymentName).get()).isNotNull());++            waitForKeycloakToBeReady(k8sclient, kc); // wait for reconciler to calm down to avoid race condititon++            Log.info(""Trying to modify deployment"");++            var deployment = k8sclient.apps().deployments().withName(deploymentName).get();+            var labels = Map.of(""address"", ""EvergreenTerrace742"");+            var flandersEnvVar = new EnvVarBuilder().withName(""NEIGHBOR"").withValue(""Stupid Flanders!"").build();+            var origSpecs = deployment.getSpec();++            deployment.getMetadata().getLabels().putAll(labels);+            deployment.getSpec().getTemplate().getSpec().getContainers().get(0).setEnv(List.of(flandersEnvVar));+            k8sclient.apps().deployments().createOrReplace(deployment);++            Awaitility.await()+                    .untilAsserted(() -> {",https://github.com/keycloak/keycloak/blob/0fcf13406093b9a5a7fb2e252314548d203d8f19/operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java#L172,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10095,804447070,2022-02-11T08:41:39Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/role/HotRodRoleEntity.java,"@@ -0,0 +1,112 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.hotRod.role;++import org.infinispan.protostream.annotations.ProtoDoc;+import org.infinispan.protostream.annotations.ProtoField;+import org.keycloak.models.map.annotations.GenerateHotRodEntityImplementation;+import org.keycloak.models.map.role.MapRoleEntity;+import org.keycloak.models.map.storage.hotRod.common.AbstractHotRodEntity;+import org.keycloak.models.map.storage.hotRod.common.HotRodAttributeEntityNonIndexed;+import org.keycloak.models.map.storage.hotRod.common.UpdatableHotRodEntityDelegateImpl;++import java.util.Objects;+import java.util.Set;++@GenerateHotRodEntityImplementation(+        implementInterface = ""org.keycloak.models.map.role.MapRoleEntity"",+        inherits = ""org.keycloak.models.map.storage.hotRod.role.HotRodRoleEntity.AbstractHotRodRoleEntityDelegate""+)+@ProtoDoc(""@Indexed"")+public class HotRodRoleEntity extends AbstractHotRodEntity {++    public static abstract class AbstractHotRodRoleEntityDelegate extends UpdatableHotRodEntityDelegateImpl<HotRodRoleEntity> implements MapRoleEntity {++        @Override+        public String getId() {+            return getHotRodEntity().id;+        }++        @Override+        public void setId(String id) {+            HotRodRoleEntity entity = getHotRodEntity();+            if (entity.id != null) throw new IllegalStateException(""Id cannot be changed"");+            entity.id = id;+            entity.updated |= id != null;+        }++        @Override+        public void setName(String name) {+            HotRodRoleEntity entity = getHotRodEntity();+            entity.updated |= ! Objects.equals(entity.name, name);+            entity.name = name;+            entity.nameLowercase = name == null ? null : name.toLowerCase();+        }+    }++    @ProtoField(number = 1, required = true)+    public int entityVersion = 1;++    @ProtoDoc(""@Field(index = Index.YES, store = Store.YES)"")+    @ProtoField(number = 2, required = true)+    public String id;++    @ProtoDoc(""@Field(index = Index.YES, store = Store.YES)"")+    @ProtoField(number = 3)+    public String realmId;++    // TODO because of ISPN-13702 bug the index has to be removed, see https://github.com/keycloak/keycloak/issues/10090",Why is this not falling for other entities? Can we temporarily set `maxResults` to `Integer.MAX_VALUE` instead of -1/`null`?Maybe the issue has a similar cause as this: https://github.com/keycloak/keycloak/blob/main/model/jpa/src/main/java/org/keycloak/models/jpa/PaginationUtils.java#L32,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10078,804503032,2022-02-11T09:58:59Z,docs/guides/src/main/server/outgoinghttp.adoc,"@@ -109,39 +112,43 @@ The special value NO_PROXY for the proxy-uri can be used to indicate that no pro .*;http://fallback:8080 ---- -== Outgoing HTTPS request truststore-When Keycloak calls remote HTTPS endpoints, it has to validate the remote server's certificate in order to ensure it is connecting to a trusted server. This is necessary in order to prevent man-in-the-middle attacks.  The certificates of these remote servers or the CA that signed these certificates must be put in a truststore.+In this example, the following occurs: -This truststore is used to securely connect e.g. to identity brokers, LDAP identity providers, when sending emails, and for backchannel communication with client applications.+* The special value NO_PROXY for the proxy-uri is used, which means that no proxy  is used for hosts matching the associated hostname pattern.","```suggestion* The special value NO_PROXY for the proxy-uri is used, which means that no proxy is used for hosts matching the associated hostname pattern.```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10078,804546965,2022-02-11T10:59:23Z,docs/guides/src/main/server/outgoinghttp.adoc,"@@ -109,39 +112,43 @@ The special value NO_PROXY for the proxy-uri can be used to indicate that no pro .*;http://fallback:8080 ---- -== Outgoing HTTPS request truststore-When Keycloak calls remote HTTPS endpoints, it has to validate the remote server's certificate in order to ensure it is connecting to a trusted server. This is necessary in order to prevent man-in-the-middle attacks.  The certificates of these remote servers or the CA that signed these certificates must be put in a truststore.+In this example, the following occurs: -This truststore is used to securely connect e.g. to identity brokers, LDAP identity providers, when sending emails, and for backchannel communication with client applications.+* The special value NO_PROXY for the proxy-uri is used, which means that no proxy  is used for hosts matching the associated hostname pattern.+* A catch-all pattern ends the proxy-mappings, providing a default proxy for all outgoing requests. -When no truststore is configured, outgoing https connection will use the standard java truststore configuration by default. When no trust can be established, outgoing HTTPS requests will fail.+== Outgoing HTTPS request truststore+When Keycloak calls remote HTTPS endpoints, it has to validate the remote server's certificate to ensure it is connecting to a trusted server. This validation is necessary to prevent man-in-the-middle attacks.  The certificates of these remote servers or the CA that signed these certificates must be put in a truststore.","```suggestionWhen Keycloak calls remote HTTPS endpoints, it has to validate the remote server's certificate to ensure it is connecting to a trusted server. This validation is necessary to prevent man-in-the-middle attacks. The certificates of these remote servers or the CA that signed these certificates must be put in a truststore.```",
4205291,marcelomrwin,https://api.github.com/repos/keycloak/keycloak/pulls/10088,804642460,2022-02-11T13:22:59Z,services/src/main/java/org/keycloak/authentication/DefaultAuthenticationFlow.java,"@@ -48,7 +49,7 @@     private final List<AuthenticationExecutionModel> executions;     private final AuthenticationProcessor processor;     private final AuthenticationFlowModel flow;-    private boolean successful;+    private boolean successful = false;","It seems fine to me, just following some guides to avoid constants. But not any problem or technical need.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10150,804658210,2022-02-11T13:39:47Z,.github/workflows/operator-ci.yml,"@@ -41,9 +41,12 @@ jobs:           kubernetes version: v1.22.3           github token: ${{ secrets.GITHUB_TOKEN }}           driver: docker+      - name: Test operator with minikube","I'd unify the naming of the two test phases. Something like ""Test operator running locally"" and ""Test operator running in cluster"" maybe?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10098,804788045,2022-02-11T16:00:42Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakSpec.java,"@@ -16,13 +16,28 @@  */ package org.keycloak.operator.v2alpha1.crds; +import com.fasterxml.jackson.annotation.JsonPropertyDescription;+import org.keycloak.operator.v2alpha1.crds.keycloakspec.Unsupported;+ import java.util.Map;  public class KeycloakSpec {      private int instances = 1;     private String image;     private Map<String, String> serverConfiguration;+    @JsonPropertyDescription(+            ""In this section you can configure advanced features, not production-ready, and not supported settings.\n"" ++            ""Use at your own risk and open an issue with your use-case if you don't find an alternative way."")+    private Unsupported unsupported;","@jonathanvila The `unsupported` gate is for features that we really don't plan to support ever. It is mean for features that we want to provide, if someone really needs it, but with no guarantees it will work properly and with limited support from our side.But we can discuss different naming for this.",
1836434,jonathanvila,https://api.github.com/repos/keycloak/keycloak/pulls/10098,804788377,2022-02-11T16:01:06Z,operator/src/test/java/org/keycloak/operator/PodTemplateE2EIT.java,"@@ -0,0 +1,110 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.client.KubernetesClientException;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import static java.util.concurrent.TimeUnit.MINUTES;+import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition.HAS_ERRORS;+import static org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition.READY;++@QuarkusTest+public class PodTemplateE2EIT extends ClusterOperatorTest {++    @AfterEach+    void afterEach() {+        k8sclient+                .resources(Keycloak.class)+                .inNamespace(namespace)+                .list()+                .getItems()+                .forEach(k -> k8sclient.resources(Keycloak.class).delete());",what's the usage of this stream ? you are not using the `k` element.you can replace all with : client.resources(Keycloak.class).delete(),
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10098,804832791,2022-02-11T16:50:57Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -87,9 +98,293 @@ private Deployment fetchExistingDeployment() {                 .get();     } +    public void validatePodTemplate(KeycloakStatusBuilder status) {+        if (keycloakCR.getSpec() == null ||+                keycloakCR.getSpec().getUnsupported() == null ||+                keycloakCR.getSpec().getUnsupported().getPodTemplate() == null) {+            return;+        }+        var overlayTemplate = this.keycloakCR.getSpec().getUnsupported().getPodTemplate();++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getName() != null) {+            status.addWarningMessage(""The name of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getNamespace() != null) {+            status.addWarningMessage(""The namespace of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getSpec() != null &&+            overlayTemplate.getSpec().getContainers() != null &&+            overlayTemplate.getSpec().getContainers().get(0) != null &&+            overlayTemplate.getSpec().getContainers().get(0).getName() != null) {+            status.addWarningMessage(""The name of the keycloak container cannot be modified"");+        }+    }++    private void mergePodTemplate(PodTemplateSpec baseTemplate) {","The proposed approach would be nice, but it still involves logic to merge lists (that is most of the code the rest are just `null` checks) and it just move the problem around for the rest. > It feels very error prone, hard to testThere are very few patterns applied systematically: - straight values: implemented with null check + set - lists: implemented by merging With exactly one exception that is the container 0 (aka Keycloak) that is implemented merging (with the rules above)  the corresponding container 0s.Most of the code have been done using multiline copy-paste and insertion in the editor.If you prefer I can add a test for each field (I tried so far to include at least one of each ""type""), I have no problem with it, is not hard at all (just boring   ).I still believe in this approach as it's a one time effort as opposed to running after requests, it also helps us validate configurations and features before implementing them.This is a POC, we can decide to include this ""feature"" or not in the final operator after we have experimented with it in action for a while.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9997,805575187,2022-02-14T07:49:42Z,model/map-jpa/src/main/resources/META-INF/groups/jpa-groups-changelog-1.xml,"@@ -0,0 +1,74 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: groups-${org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_GROUP} -->+    <changeSet author=""keycloak"" id=""groups-1"">++        <createTable tableName=""kc_group"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""version"" type=""INTEGER"" defaultValueNumeric=""0"">+                <constraints nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""kc_group"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""realmid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fRealmId""/>+            <ext:column name=""name"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fName""/>+            <ext:column name=""parentid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fParentId""/>+        </ext:addGeneratedColumn>+        <createIndex tableName=""kc_group"" indexName=""group_entityVersion"">+            <column name=""entityversion""/>+        </createIndex>+        <createIndex tableName=""kc_group"" indexName=""group_realmId_name_parentId"" unique=""true"">+            <column name=""realmid""/>+            <column name=""name""/>+            <column name=""parentid""/>+        </createIndex>","I'm sorry that I missed that earlier: This index should be IMHO split:* one unique index to ensure that realmid + name of the group are unique * another non-unique index for the parentId so that the foreign key is indexed and simple to look up when traversing the tree upwards. The index for parentId doesn't need to contain the group name and also doesn't need to contain the realmId as parentId is unique across realms ... at least technically, I don't know what query the criteria API constructs here. ",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/9997,805627269,2022-02-14T09:02:26Z,model/map-jpa/src/main/resources/META-INF/groups/jpa-groups-changelog-1.xml,"@@ -0,0 +1,74 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: groups-${org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_GROUP} -->+    <changeSet author=""keycloak"" id=""groups-1"">++        <createTable tableName=""kc_group"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""version"" type=""INTEGER"" defaultValueNumeric=""0"">+                <constraints nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""kc_group"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""realmid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fRealmId""/>+            <ext:column name=""name"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fName""/>+            <ext:column name=""parentid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fParentId""/>+        </ext:addGeneratedColumn>+        <createIndex tableName=""kc_group"" indexName=""group_entityVersion"">+            <column name=""entityversion""/>+        </createIndex>+        <createIndex tableName=""kc_group"" indexName=""group_realmId_name_parentId"" unique=""true"">+            <column name=""realmid""/>+            <column name=""name""/>+            <column name=""parentid""/>+        </createIndex>","> * one unique index to ensure that realmid + name of the group are uniqueThis would not be sufficient: The name needs to be unique within parent. For example, it must be possible to create a group ""students"" inside a group ""2021"" as well as the group ""students"" inside ""2020"".> * another non-unique index for the parentId so that the foreign key is indexed and simple to look up when traversing the tree upwards. The index for parentId doesn't need to contain the group name and also doesn't need to contain the realmId as parentId is unique across realms ... at least technically, I don't know what query the criteria API constructs here.Is there any supporting use case for this index?",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/9997,805642816,2022-02-14T09:21:10Z,model/map-jpa/src/main/resources/META-INF/groups/jpa-groups-changelog-1.xml,"@@ -0,0 +1,74 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: groups-${org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_GROUP} -->+    <changeSet author=""keycloak"" id=""groups-1"">++        <createTable tableName=""kc_group"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""version"" type=""INTEGER"" defaultValueNumeric=""0"">+                <constraints nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""kc_group"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""realmid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fRealmId""/>+            <ext:column name=""name"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fName""/>+            <ext:column name=""parentid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fParentId""/>+        </ext:addGeneratedColumn>+        <createIndex tableName=""kc_group"" indexName=""group_entityVersion"">+            <column name=""entityversion""/>+        </createIndex>+        <createIndex tableName=""kc_group"" indexName=""group_realmId_name_parentId"" unique=""true"">+            <column name=""realmid""/>+            <column name=""name""/>+            <column name=""parentid""/>+        </createIndex>","Thanks for noting why the index needs to have three columns, I stand corrected. I didn't know the same name could appear in separate branches of the group tree. To be able to query by parentId, I see the following use cases:* to validate the foreign key (group is referencing itself) - looking at the columns again, I don't see that foreign key in the schema, there is only a foreign key in the attributes. A foreign key constraint could ensure that the parent exists, and could also delete cascade children.* to search the leafs of a groups by parent ID (the getSubGroupsStream method as in classic JPA) ... now looking more closely in MapGroupAdapter, this is could be quite inefficient as it streams all groups from the database and then filters :-( Still, one could leave that for a future optimization and create a criteria query in MapGroupAdapter.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/8730,805760345,2022-02-14T11:43:30Z,services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidateRecoveryAuthnCode.java,"@@ -0,0 +1,142 @@+package org.keycloak.authentication.authenticators.directgrant;++import org.apache.commons.lang.StringUtils;+import org.keycloak.authentication.AuthenticationFlowContext;+import org.keycloak.authentication.AuthenticationFlowError;+import org.keycloak.authentication.CredentialValidator;+import org.keycloak.credential.RecoveryAuthnCodesCredentialProvider;+import org.keycloak.credential.RecoveryAuthnCodesCredentialProviderFactory;+import org.keycloak.credential.CredentialProvider;+import org.keycloak.events.Errors;+import org.keycloak.models.*;+import org.keycloak.models.credential.RecoveryAuthnCodesCredentialModel;+import org.keycloak.models.utils.RecoveryAuthnCodesUtils;+import org.keycloak.provider.ProviderConfigProperty;++import javax.ws.rs.core.MultivaluedMap;+import javax.ws.rs.core.Response;+import java.util.LinkedList;+import java.util.List;++public class ValidateRecoveryAuthnCode extends AbstractDirectGrantAuthenticator","""Direct grant"" is deprecated and should not be used, so I would not even consider it for new authenticators. As a general thing a recovery code makes no sense in a direct grant scenario either, so we should not have a direct grant recovery code authenticator, although still support password+otp with direct grant until we eventually completely remove that flow.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/8730,805761060,2022-02-14T11:44:35Z,themes/src/main/resources/theme/base/account/messages/messages_en.properties,"@@ -337,15 +337,15 @@ sendVerficationCode=Send Verification Code enterYourVerficationCode=Enter your verification code  #Authenticator - backup Code setup-authenticatorBackupCodesSetupTitle=Backup Codes Setup-backupcodesIntroMessage=If you lose access to your phone, you can still log into your account through backup codes. Keep them somewhere safe and accessible.+authenticatorBackupCodesSetupTitle=Recovery Authentication Codes Setup+backupcodesIntroMessage=If you lose access to your phone, you can still log into your account through recovery codes. Keep them somewhere safe and accessible.",Either remove them not or not update them. I suspect these where used by OTP a long time ago.,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/9964,805765877,2022-02-14T11:51:02Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/keycloak-service/keycloak.service.ts,"@@ -14,10 +14,10 @@  * See the License for the specific language governing permissions and  * limitations under the License.  */-import {KeycloakLoginOptions} from ""../../../../../../../../../../adapters/oidc/js"";+import Keycloak, { KeycloakLoginOptions } from ""../../../../../../../../../../adapters/oidc/js"";","Yes, the types for the definitions of the instance have changed. We're no longer exporting a `KeycloakInstance` or `KeycloakAuthorizationInstance` type. These have been replaced with the `Keycloak` and `KeycloakAuthorization` classes, which can be used directly as a type.I could alias these types so that they can still be imported by the user and mark them as deprecated. For example:```ts/** * @deprecated Instead of importing 'KeycloakInstance' you can import 'Keycloak' directly as a type. */export type KeycloakInstance = Keycloak;```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10088,805859618,2022-02-14T13:48:52Z,services/src/main/java/org/keycloak/authentication/DefaultAuthenticationFlow.java,"@@ -48,7 +49,7 @@     private final List<AuthenticationExecutionModel> executions;     private final AuthenticationProcessor processor;     private final AuthenticationFlowModel flow;-    private boolean successful;+    private boolean successful = false;","Thanks for clarification. I consider constants makes sense especially for strings and numbers. Also for example when I want to specify for example default value or when I want to search for the usage. Pretty much most of the use-cases like used for example in class `org.keycloak.models.Constants` . For this particular use-case, I don't see much value of using `Boolean.FALSE` instead of `false` . But thanks for bringing this.",
91681638,stelewis-redhat,https://api.github.com/repos/keycloak/keycloak/pulls/8730,806059972,2022-02-14T17:07:37Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -249,7 +259,32 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta      private credentialRowCells(credential: UserCredential, type: string): React.ReactNode[] {         const credRowCells: React.ReactNode[] = [];-        credRowCells.push(<DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>{credential.userLabel}</DataListCell>);+        const credData: CredData = JSON.parse(credential.credentialData!);+        credRowCells.push(+            <DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>+                {credential.userLabel}+                {credData.remainingCodes && credData.totalCodes &&+                    <div>{credData.totalCodes - credData.remainingCodes}/{credData.totalCodes} recovery codes used</div>+                }+                {credData.remainingCodes && credData.remainingCodes < 4 &&+                    <>+                        <br />+                        <div className=""pf-c-alert pf-m-warning pf-m-inline"" aria-label=""Success alert"">+                            <div className=""pf-c-alert__icon"">+                                <i className=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+                            </div>+                            <h4 className=""pf-c-alert__title"">","Right now, CredentialModel contains credentialData. Are you saying we should add credentialMetadata to CredentialModel? Or add credentialModel to CredentialMetadata and then return instances of CredentialMetadata via JSON? @mposolda ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,806828812,2022-02-15T13:27:08Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -249,7 +259,32 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta      private credentialRowCells(credential: UserCredential, type: string): React.ReactNode[] {         const credRowCells: React.ReactNode[] = [];-        credRowCells.push(<DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>{credential.userLabel}</DataListCell>);+        const credData: CredData = JSON.parse(credential.credentialData!);+        credRowCells.push(+            <DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>+                {credential.userLabel}+                {credData.remainingCodes && credData.totalCodes &&+                    <div>{credData.totalCodes - credData.remainingCodes}/{credData.totalCodes} recovery codes used</div>+                }+                {credData.remainingCodes && credData.remainingCodes < 4 &&+                    <>+                        <br />+                        <div className=""pf-c-alert pf-m-warning pf-m-inline"" aria-label=""Success alert"">+                            <div className=""pf-c-alert__icon"">+                                <i className=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+                            </div>+                            <h4 className=""pf-c-alert__title"">","@stelewis-redhat Yes, the second thing you mentioned. I am thinking about CredentialMetadata as separate object, which will contain ""CredentialModel"" as one of the fields. See my comment above.The main motivation is that `SigningInPage.tsx` doesn't need to contain any if/else blocks or other hacks specific to `Recovery-code` credential. As it will be ideal that customers, who potentially implement their own credentials/authenticators don't need to change UI classes, but SPI is good enough so they can add their own info/warning labels shown alongside their credential just by implementing this method on `CredentialProvider` interface.",
91681638,stelewis-redhat,https://api.github.com/repos/keycloak/keycloak/pulls/8730,806999185,2022-02-15T15:53:57Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -249,7 +259,32 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta      private credentialRowCells(credential: UserCredential, type: string): React.ReactNode[] {         const credRowCells: React.ReactNode[] = [];-        credRowCells.push(<DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>{credential.userLabel}</DataListCell>);+        const credData: CredData = JSON.parse(credential.credentialData!);+        credRowCells.push(+            <DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>+                {credential.userLabel}+                {credData.remainingCodes && credData.totalCodes &&+                    <div>{credData.totalCodes - credData.remainingCodes}/{credData.totalCodes} recovery codes used</div>+                }+                {credData.remainingCodes && credData.remainingCodes < 4 &&+                    <>+                        <br />+                        <div className=""pf-c-alert pf-m-warning pf-m-inline"" aria-label=""Success alert"">+                            <div className=""pf-c-alert__icon"">+                                <i className=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+                            </div>+                            <h4 className=""pf-c-alert__title"">","@mposolda Is it possible to revisit making CredentialMetadata contain CredentialModel, after we do the account console redesign? We're a bit worried about the merge/rebasing issues with these two initiatives going on at once.Here's what I currently have working, for reference: https://github.com/rh-iatanaso/keycloak/pull/14 not final, work in progress.Here's the discussion for the console redesign: https://github.com/keycloak/keycloak/discussions/9923",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10206,807105578,2022-02-15T17:22:40Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","I think the test should not unconditionally expect 500 for a long name, rather it should check that if 201 (CREATED), the component is really created with that long name, and if 500 then it indeed is not. This would cover both storages that support and do not support long names.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/10206,807178618,2022-02-15T18:39:55Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","The problem is that the component is not persisted even when 201 is returned due to constraint validation errors when committing the transaction. And this response is inconsistent with the Wildfly distribution because of the new request lifecycle. Which is also different between Wildfly and Quarkus. In fact, we have also a difference between the old and the map store here. Using a database should always fail with 500 but with the map store, it always succeeds because there is no constraint/validation for the component name.Looks like you are saying that the map store behavior is expected and we should just consider both behaviors to fix the failing test? But yeah, we never caught this before because we don't have tests covering this specific aspect.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10206,807191115,2022-02-15T18:47:16Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","Let's take a step back and clarify two things:What is the expected behaviour? Is it the following or something different?- When component is created, return 201- When component is not created, return 500> Using a database should always fail with 500Why?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/10206,807213146,2022-02-15T19:06:39Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","The behavior I expect is a proper input validation and return 400 instead. But considering how it works today, that is the behavior. I'm not changing this here.The database should always fail because of the constraints we have in tables. See the issue for the stack trace.Is the map store enforcing the same constraints ?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10206,807239238,2022-02-15T19:31:43Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","Thanks, now it makes sense.Map store is an abstraction so actual constraints are not imposed by map storage itself, but according to the map storage implementation being effective during that run.In the case of this GHA undertow-map, `ConcurrentHashMap` implementation is used which has no constraints at all, and that is the reason why the component is correctly created and 200 is returned. If a JPA / map would be used, the constraints on component names would probably not be there since the component definitions would be part of a realm JSON, so it would also pass. There might be some storages that would limit component names in the future, these would fail to save such a component.Hence I think the test checking the (non)existence of a component per 201 / 500 status being the best what can be done at this moment. WDYT?",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/10206,807253915,2022-02-15T19:42:32Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }",Thanks. And that is why I asked you before if we could just ignore that particular test method for the map store.Or even add a condition to cover both behaviors (expected and map store).,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10206,807596699,2022-02-16T06:41:27Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","The issue as far as I understand it is to fix the difference in behaviour between quarkus and wildfly response operating on the same data store. Wildfly with map store / CHM would also return 201 and create the component correctly. It thus cannot be conditioned on map store or other store, but can be on the response code (201 or 4xx / 5xx) and checking the existence of the component.@DGuhr Store implementation can be constrained by the technology which is the case of the legacy database. Ideal behaviour would be to allow strings of any length. 255 characters are often picked not only due to indexing but also for RDBMS storage savings since then the string length fits one byte. I thus don't follow the argument about ""against `ConcurrentHashMap`"". The argument would go that CHM behaves better than RDBMS that is limited in the component name length.",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10206,807869112,2022-02-16T12:04:06Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/integration/web/QuarkusRequestFilter.java,"@@ -90,6 +93,10 @@ private void configureEndHandler(RoutingContext context, Promise<Object> promise                 close(session);             } catch (Throwable cause) {                 promise.fail(cause);+                context.response().headers().clear();+                context.response().putHeader(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.TEXT_PLAIN);+                context.response().putHeader(HttpHeaderNames.CONTENT_LENGTH, ""0"");+                context.response().setStatusCode(HttpResponseStatus.INTERNAL_SERVER_ERROR.code());","Would it not be better to throw this to let the ErrorHandler handle it since that has loads of login on how to handle different exceptions, and return correct response if it should be html or json?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10267,808319814,2022-02-16T18:13:15Z,themes/pom.xml,"@@ -131,6 +86,72 @@     </build>      <profiles>+        <profile>+            <id>account2</id>+            <activation>+                <!-- 'activeByDefault' will not work here as other profiles in this POM are always active, so we need to have a workaround to activate this profile. -->+                <file>",Use properties to activate this like this:https://github.com/keycloak/keycloak/blob/bbe9ab38bc6afeaac95c995efd0e081aeb9b0e06/pom.xml#L2038,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10206,808737032,2022-02-17T07:17:48Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","Ok - @hmlnarik @pedroigor Let me try to explain:I thought about expectations and surprises here when changing the dev db to map.Context: e.g. in the testsuite, when using the IDELauncher and with devmode itself invoking it from the cli we run `start-dev` under the covers. Changing the default Database now from h2 (with the constraints) to map (without constraints) would cause some surprises i guess, when you accidentally violate a constraint for, say, postgres, but you won't notice until it's run with an actual postgres, or a db that has these constraints. So imo it's at least discussable to have a non-constrained datastore as default for these contexts, as this could cause surprises and rework very late in the flow of developing, and our testsuite being ""green"" but not green for most db vendors.@stianst Do we have a discussion around moving dev-file from h2 to...? I think this here is not exactly the place to discuss this topic, nevertheless should be discussed ;)",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8121,808745543,2022-02-17T07:32:04Z,services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java,"@@ -566,6 +566,9 @@ public void recurseExecutions(AuthenticationFlowModel flow, List<AuthenticationE             } else {                 String providerId = execution.getAuthenticator();                 ConfigurableAuthenticatorFactory factory = CredentialHelper.getConfigurableAuthenticatorFactory(session, providerId);+                if (factory == null) {+                    throw new NotFoundException(""Could not find authenticator provider"");","Minor: Will it be possible to add `logger.warnf(""Cannot find authentication provider implementation with provider ID '%s'"", providerId);` right before throwing the exception?That can help so the admin is aware of what the missing authenticator is.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/8431,808810080,2022-02-17T08:56:42Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/UserSessionPersisterProviderTest.java,"@@ -508,6 +513,82 @@ public void testExpiredSessions() {         });     } +    @Test+    @RequireProvider(ClientStorageProvider.class)+    public void testPersistenceWithLoadWithExternalClientStorage() {+        try {+            inComittedTransaction(session -> {+                setupClientStorageComponents(session, session.realms().getRealm(realmId));+            });++            int started = Time.currentTime();++            UserSessionModel origSession = inComittedTransaction(session -> {+                // Create session in infinispan+                RealmModel realm = session.realms().getRealm(realmId);++                UserSessionModel userSession = session.sessions().createUserSession(realm, session.users().getUserByUsername(realm, ""user1""), ""user1"", ""127.0.0.1"", ""form"", true, null, null);+                createClientSession(session, realmId, realm.getClientByClientId(""test-app""), userSession, ""http://redirect"", ""state"");+                createClientSession(session, realmId, realm.getClientByClientId(""external-storage-client""), userSession, ""http://redirect"", ""state"");++                return userSession;+            });++            inComittedTransaction(session -> {+                // Persist created userSession and clientSessions as offline+                persistUserSession(session, origSession, true);+            });++            inComittedTransaction(session -> {+                // Persist online session",In Keycloak we don't persist online session to a database so this part can be removed.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10206,809157250,2022-02-17T15:12:57Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }",+1 for a separate discussion.Short note: that this is by no means different from current state where [some database surprised us](https://issues.redhat.com/browse/KEYCLOAK-4122) late in the cycle due to their specifics.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10206,809161445,2022-02-17T15:16:41Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","note on your note: we added database tests using testcontainers in the new dist testsuite, exactly for that reason ;) see https://github.com/keycloak/keycloak/tree/main/quarkus/tests/integration/src/test/java/org/keycloak/it/storage/database",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/10265,809772450,2022-02-18T08:28:24Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCWellKnownProvider.java,"@@ -253,6 +258,18 @@ public void close() {         return getSupportedAlgorithms(ContentEncryptionProvider.class, false);     } +    private List<String> getAcrValuesSupported(RealmModel realm) {+        // Values explicitly set on the realm mapping+        Map<String, Integer> realmAcrLoaMap = AcrUtils.getAcrLoaMap(realm);+        List<String> result = new ArrayList<>(realmAcrLoaMap.keySet());++        // Add LoA levels configured in authentication flow in addition to the realm values+        result.addAll(AuthenticatorUtil.getLoAConfiguredInRealmBrowserFlow(realm)",How about removing duplicates?The current keycloak accepts the following `acr-to-loa` mapping.ACR : 0 -> LOA : 0ACR : 1 -> LOA : 0I think it is a very subtle problem so that we might need not to consider it too much.,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10336,810868079,2022-02-21T08:15:08Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/OIDCProtocolMappersTest.java,"@@ -594,6 +594,51 @@ public void testRolesAndAllowedOriginsRemovedFromAccessToken() throws Exception         }     } +    /**+     * Chris Nurse 20-Feb-2022+     * +     * PR-4205 serialised single values as an array. This is not desired when the Multivalued options is set to false.+     * +     * This test ensures singular values are not wrapped as an array.+     * +     * The subsequent test for PR-4205 will continue to test functionality where multivalued = true","Instead of naming a PR and a relative position, use the name of the test, as positions in a file may change over time.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10249,811056892,2022-02-21T11:57:46Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -82,6 +80,9 @@         kcDeployment.updateStatus(statusBuilder);         kcDeployment.createOrUpdateReconciled(); +        new KeycloakService(client, kc).createOrUpdateReconciled();+        new KeycloakDiscoveryService(client, kc).createOrUpdateReconciled();","We should probably reflect this in the CR's status. I'd probably call `addNotReadyMessage` if a service is not found, similarly to:https://github.com/keycloak/keycloak/blob/8ea60bb71a7e0f8f39d98997fc468b646239f20c/operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java#L148-L152",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10249,811332208,2022-02-21T17:36:11Z,operator/src/test/java/org/keycloak/operator/ClusteringE2EIT.java,"@@ -0,0 +1,79 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.Service;+import io.fabric8.kubernetes.api.model.ServiceBuilder;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.BeforeEach;+import org.junit.jupiter.api.Disabled;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.net.URI;+import java.net.URISyntaxException;+import java.time.Duration;+import java.util.concurrent.TimeUnit;++import static io.restassured.RestAssured.given;+import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.utils.K8sUtils.deployKeycloak;+import static org.keycloak.operator.utils.K8sUtils.getDefaultKeycloakDeployment;++@QuarkusTest+public class ClusteringE2EIT extends ClusterOperatorTest {+    @BeforeEach+    public void cleanResources() {+        k8sclient.resources(Keycloak.class).inNamespace(namespace).delete();+    }++    @Test+    public void given_ClusterAndOperatorRunning_when_KeycloakCRScaled_Then_PodsAreReady() throws URISyntaxException {+        // given+        var kc = getDefaultKeycloakDeployment();+        var deploymentName = kc.getMetadata().getName();+        deployKeycloak(k8sclient, kc, true);++        Keycloak keycloak = k8sclient.resources(Keycloak.class)+                .inNamespace(namespace)+                .list().getItems().get(0);++        // when scale it to 10+        keycloak.getSpec().setInstances(10);+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloak);+        Awaitility.await()+                .atMost(Duration.ofSeconds(5))+                .untilAsserted(() -> assertThat(k8sclient.pods().inNamespace(namespace).withLabel(""app"", ""keycloak"").list().getItems().size()).isEqualTo(10));++        // when scale it down to 2+        keycloak.getSpec().setInstances(2);+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloak);+        Awaitility.await()+                .atMost(Duration.ofSeconds(180))+                .untilAsserted(() -> assertThat(k8sclient.pods().inNamespace(namespace).withLabel(""app"", ""keycloak"").list().getItems().size()).isEqualTo(2));++        // get the service+        Service service = k8sclient.services().inNamespace(namespace).withName(keycloak.getMetadata().getName() + ""-service"").get();++        // clone the service but NodePort+        Service nodeportTestService = new ServiceBuilder(service).build();+        nodeportTestService.getMetadata().setName(keycloak.getMetadata().getName()+ ""-servicenodeport"");+        nodeportTestService.getSpec().getPorts().get(0).setNodePort(31999);+        nodeportTestService.getSpec().setType(""NodePort"");+        nodeportTestService.getSpec().setClusterIP(null);+        nodeportTestService.getSpec().setClusterIPs(null);+        k8sclient.services().inNamespace(namespace).createOrReplace(nodeportTestService);++        // check we can reach Keycloak+        URI uri = new URI(k8sclient.getConfiguration()+                    .getMasterUrl()+                    .replace(""8443"", ""31999"")+                    .replace(""https"", ""http"") + ""realms/master"")+                    ;+        Awaitility.await()+                .atMost(10, TimeUnit.SECONDS)+                .until(() -> given().when().relaxedHTTPSValidation().get(uri).then().extract().statusCode() == 200);",Cant we use similar approach as [here](https://github.com/keycloak/keycloak/blob/d2e1aaa840a6f33fe3eb9ae12fc57e1ec415720d/operator/src/test/java/org/keycloak/operator/RealmImportE2EIT.java#L107)? That test should also be updated not to explicitlty create a [service](https://github.com/keycloak/keycloak/blob/d2e1aaa840a6f33fe3eb9ae12fc57e1ec415720d/operator/src/test/java/org/keycloak/operator/RealmImportE2EIT.java#L51-L64).,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/10364,811526112,2022-02-22T02:16:40Z,services/src/main/java/org/keycloak/validation/DefaultClientValidationProvider.java,"@@ -264,4 +269,20 @@ private void validateJwks(ValidationContext<ClientModel> context) {             context.addError(""jwksUrl"", ""Illegal to use both jwks_uri and jwks_string"", ""duplicatedJwksSettings"");         }     }++    private void validateDefaultAcrValues(ValidationContext<ClientModel> context) {+        ClientModel client = context.getObjectToValidate();+        List<String> defaultAcrValues = AcrUtils.getDefaultAcrValues(client);+        for (String configuredAcr : defaultAcrValues) {+            Map<String, Integer> acrToLoaMap = AcrUtils.getAcrLoaMap(client);+            if (acrToLoaMap.isEmpty()) {+                acrToLoaMap = AcrUtils.getAcrLoaMap(client.getRealm());",There is an another option that it ignores client's acr to loa mapping the same as done in https://github.com/keycloak/keycloak/pull/10265 .Server metadata `acr_values_supported ` does not contain client's acr to loa mapping.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10364,811588290,2022-02-22T05:28:08Z,services/src/main/java/org/keycloak/validation/DefaultClientValidationProvider.java,"@@ -264,4 +269,20 @@ private void validateJwks(ValidationContext<ClientModel> context) {             context.addError(""jwksUrl"", ""Illegal to use both jwks_uri and jwks_string"", ""duplicatedJwksSettings"");         }     }++    private void validateDefaultAcrValues(ValidationContext<ClientModel> context) {+        ClientModel client = context.getObjectToValidate();+        List<String> defaultAcrValues = AcrUtils.getDefaultAcrValues(client);+        for (String configuredAcr : defaultAcrValues) {+            Map<String, Integer> acrToLoaMap = AcrUtils.getAcrLoaMap(client);+            if (acrToLoaMap.isEmpty()) {+                acrToLoaMap = AcrUtils.getAcrLoaMap(client.getRealm());","I believe that this should not ignore client's acr-to-loa mapping TBH. IMO the `default_acr_values` available of client should allow same values like allowed in the `acr_values` (or `claims`) parameter sent to the client.For example in case that client acr-to-loa mapping contains mappings like `silver -> 1`, then it is valid for client to send `acr_values` parameter with value `silver` in OIDC request. Similarly I consider it appropriate for the client to use `silver` as one of the values in the `default acr values` .",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10152,811717064,2022-02-22T09:03:35Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/clientscope/HotRodClientScopeEntity.java,"@@ -0,0 +1,111 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.hotRod.clientscope;++import org.infinispan.protostream.annotations.ProtoDoc;+import org.infinispan.protostream.annotations.ProtoField;+import org.keycloak.models.map.annotations.GenerateHotRodEntityImplementation;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import org.keycloak.models.map.clientscope.MapClientScopeEntity;+import org.keycloak.models.map.storage.hotRod.client.HotRodProtocolMapperEntity;+import org.keycloak.models.map.storage.hotRod.common.AbstractHotRodEntity;+import org.keycloak.models.map.storage.hotRod.common.HotRodAttributeEntityNonIndexed;+import org.keycloak.models.map.storage.hotRod.common.UpdatableHotRodEntityDelegateImpl;++import java.util.Collection;+import java.util.LinkedHashSet;+import java.util.Objects;+import java.util.Optional;+import java.util.Set;++@GenerateHotRodEntityImplementation(+        implementInterface = ""org.keycloak.models.map.clientscope.MapClientScopeEntity"",+        inherits = ""org.keycloak.models.map.storage.hotRod.clientscope.HotRodClientScopeEntity.AbstractHotRodClientScopeEntityDelegate""+)+@ProtoDoc(""@Indexed"")+public class HotRodClientScopeEntity extends AbstractHotRodEntity  {++    @ProtoField(number = 1, required = true)+    public int entityVersion = 1;++    @ProtoField(number = 2, required = true)+    public String id;++    @ProtoDoc(""@Field(index = Index.YES, store = Store.YES)"")+    @ProtoField(number = 3)+    public String realmId;++    @ProtoDoc(""@Field(index = Index.YES, store = Store.YES)"")+    @ProtoField(number = 4)+    public String name;++    @ProtoField(number = 5)+    public String protocol;++    @ProtoField(number = 6)+    public String description;++    @ProtoField(number = 7, collectionImplementation = LinkedHashSet.class)",Do we need to have this ordered? Why don't we use Set? @vramik Why do we use Collection in [`MapClientScopeEntity`](https://github.com/keycloak/keycloak/blob/main/model/map/src/main/java/org/keycloak/models/map/clientscope/MapClientScopeEntity.java#L90)? It seems that the generator chose `LinkedList` as the default collection. Do we need to order scope mappings?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10373,811779410,2022-02-22T10:10:15Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/LdapMapStorageProvider.java,"@@ -0,0 +1,62 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap;++import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;+import org.keycloak.models.map.storage.MapStorageProviderFactory.Flag;+import org.keycloak.models.map.storage.ldap.role.LdapRoleMapKeycloakTransaction;++public class LdapMapStorageProvider implements MapStorageProvider {++    private final String SESSION_TX_PREFIX = ""ldap-map-tx-"";++    private final LdapMapStorageProviderFactory factory;++    @Deprecated+    private final MapStorageProvider delegate;++    public LdapMapStorageProvider(LdapMapStorageProviderFactory factory,+                                  MapStorageProvider delegate) {+        this.factory = factory;+        this.delegate = delegate;","This has to vanish. For this to be possible, you might need to leverage [EntityFieldDelegate](https://github.com/keycloak/keycloak/blob/b26a1a4803424dc2fd6c4d9fa413e96760bcd51e/model/map/src/main/java/org/keycloak/models/map/common/delegate/EntityFieldDelegate.java).",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10373,811780957,2022-02-22T10:12:00Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/LdapModelCriteriaBuilder.java,"@@ -0,0 +1,82 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap;++import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.ldap.condition.AndCondition;+import org.keycloak.models.map.storage.ldap.condition.NoopCondition;+import org.keycloak.models.map.storage.ldap.condition.NotCondition;+import org.keycloak.models.map.storage.ldap.condition.OrCondition;+import org.keycloak.storage.ldap.idm.query.Condition;+import org.keycloak.storage.ldap.mappers.membership.role.RoleMapperConfig;++import java.util.function.Function;+import java.util.stream.Stream;++/**+ * Abstract class containing methods common to all Ldap*ModelCriteriaBuilder implementations+ * + * @param <E> Entity+ * @param <M> Model+ * @param <Self> specific implementation of this class+ */+public abstract class LdapModelCriteriaBuilder<E, M, Self extends LdapModelCriteriaBuilder<E, M, Self>> implements ModelCriteriaBuilder<M, Self> {++    private final Function<Function<RoleMapperConfig, Condition>, Self> instantiator;+    private Function<RoleMapperConfig, Condition> predicateFunc = null;++    public LdapModelCriteriaBuilder(Function<Function<RoleMapperConfig, Condition>, Self> instantiator) {+        this.instantiator = instantiator;+    }++    @SafeVarargs+    @Override+    public final Self and(Self... builders) {+        return instantiator.apply((config) -> {+            Condition[] conditions = Stream.of(builders).map(b -> b.getPredicateFunc().apply(config)).filter(condition -> !(condition instanceof NoopCondition)).toArray(Condition[]::new);+            return conditions.length > 0 ? new AndCondition(conditions) : new NoopCondition();+        });+    }++    @SafeVarargs+    @Override+    public final Self or(Self... builders) {+        return instantiator.apply((config) -> {+            Condition[] conditions = Stream.of(builders).map(b -> b.getPredicateFunc().apply(config)).filter(condition -> !(condition instanceof NoopCondition)).toArray(Condition[]::new);+            return conditions.length > 0 ? new OrCondition(conditions) : new NoopCondition();+        });+    }++    @Override+    public Self not(Self builder) {+        return instantiator.apply((config) -> {+            Condition condition = builder.getPredicateFunc().apply(config);+            return condition instanceof NoopCondition ? condition : new NotCondition(condition);+        });+    }+",These should be extracted in a parent class.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10373,811781998,2022-02-22T10:13:08Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/LdapModelCriteriaBuilderForClientId.java,"@@ -0,0 +1,80 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap;++import org.keycloak.models.RoleModel;+import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.storage.SearchableModelField;++import java.util.function.Function;+import java.util.function.Supplier;+import java.util.stream.Stream;++/**+ * Abstract class containing methods common to all Ldap*ModelCriteriaBuilder implementations+ * + * @param <E> Entity+ * @param <M> Model+ * @param <Self> specific implementation of this class+ */+public class LdapModelCriteriaBuilderForClientId<E, M, Self extends LdapModelCriteriaBuilderForClientId<E, M, Self>> implements ModelCriteriaBuilder<M, Self> {","The name/package should indicate that this is role-specific, or the class should not be role-specific.Same applies to other `LdapModelCriteriaBuilderFor*` classes",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10373,811789958,2022-02-22T10:21:49Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/LdapRoleModelCriteriaBuilderForClientId.java,"@@ -0,0 +1,37 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role;++import org.keycloak.models.RoleModel;+import org.keycloak.models.map.storage.ldap.LdapModelCriteriaBuilderForClientId;+import org.keycloak.models.map.storage.ldap.LdapModelCriteriaBuilderForRealm;+import org.keycloak.models.map.storage.ldap.role.entity.LdapRoleEntity;++import java.util.function.Supplier;+import java.util.stream.Stream;++public class LdapRoleModelCriteriaBuilderForClientId extends LdapModelCriteriaBuilderForClientId<LdapRoleEntity, RoleModel, LdapRoleModelCriteriaBuilderForClientId> {",What is the purpose of this class?,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10373,811849942,2022-02-22T11:33:05Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/LdapRoleMapKeycloakTransaction.java,"@@ -0,0 +1,509 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelException;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.role.MapRoleEntity;++import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.MapFieldPredicates;+import org.keycloak.models.map.storage.chm.MapModelCriteriaBuilder;+import org.keycloak.models.map.storage.ldap.LdapConfig;+import org.keycloak.models.map.storage.ldap.LdapMapKeycloakTransaction;+import org.keycloak.models.map.storage.ldap.LdapRoleMapperConfig;+import org.keycloak.models.map.storage.ldap.condition.CustomLDAPFilter;+import org.keycloak.models.map.storage.ldap.condition.EqualCondition;+import org.keycloak.models.map.storage.ldap.condition.NoopCondition;+import org.keycloak.models.map.storage.ldap.role.entity.LdapRoleEntity;+import org.keycloak.storage.ldap.idm.model.LDAPDn;+import org.keycloak.storage.ldap.idm.model.LDAPObject;+import org.keycloak.storage.ldap.idm.query.Condition;+import org.keycloak.storage.ldap.idm.query.EscapeStrategy;+import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;+import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;++import javax.naming.NamingException;+import java.util.Arrays;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;+import java.util.stream.Collectors;+import java.util.stream.Stream;++public class LdapRoleMapKeycloakTransaction extends LdapMapKeycloakTransaction<LdapRoleEntity, MapRoleEntity, RoleModel> {++    private final KeycloakSession session;+    private final Config.Scope config;+    private final StringKeyConvertor<String> keyConverter = new StringKeyConvertor.StringKey();+    private final List<String> deletedKeys = new LinkedList<>();++    /* at the moment there is no way to figure out the realm when an entity is read by ID.+       For now, memorize the realm for a previous search.+     */+    @Deprecated+    private static String realm;++    public LdapRoleMapKeycloakTransaction(KeycloakSession session, Config.Scope config, MapKeycloakTransaction<MapRoleEntity, RoleModel> delegate) {+        super(session, config);+        this.session = session;+        this.config = config;+    }++    // interface matching the constructor of this class+    public interface LdapRoleMapKeycloakTransactionFunction<A, B, C, R> {+        R apply(A a, B b, C c);+    }++    // TODO: entries might get stale if a DN of an entry changes due to changes in the entity in the same transaction+    private final Map<String, String> dns = new HashMap<>();++    public String readIdByDn(String realmId, String dn) {+        // TODO: this might not be necessary if the LDAP server would support an extended OID+        // https://ldapwiki.com/wiki/LDAP_SERVER_EXTENDED_DN_OID++        String id = dns.get(dn);+        if (id == null) {+            for (Map.Entry<EntityKey, LdapRoleEntity> entry : entities.entrySet()) {+                if (entry.getValue().getLdapObject().getUuid().equals(dn)) {+                    id = entry.getValue().getLdapObject().getUuid();+                    break;+                }+            }+        }+        if (id != null) {+            return id;+        }++        LdapConfig ldapConfig = new LdapConfig(config, realmId);++        LDAPQuery ldapQuery = new LDAPQuery(null);+        LdapRoleMapperConfig roleMapperConfig = new LdapRoleMapperConfig(config, realmId, false, null);++        // For now, use same search scope, which is configured ""globally"" and used for user's search.+        ldapQuery.setSearchScope(ldapConfig.getSearchScope());+        ldapQuery.setSearchDn(config.get(""roles.dn.common""));++        // TODO: read them properly to be able to store them in the transaction so they are cached?!+        Collection<String> roleObjectClasses = ldapConfig.getRoleObjectClasses();+        ldapQuery.addObjectClasses(roleObjectClasses);++        String rolesRdnAttr = roleMapperConfig.getRoleNameLdapAttribute();++        String customFilter = roleMapperConfig.getCustomLdapFilter();+        if (customFilter != null && customFilter.trim().length() > 0) {+            Condition customFilterCondition = new CustomLDAPFilter(customFilter);+            ldapQuery.addWhereCondition(customFilterCondition);+        }++        ldapQuery.addReturningLdapAttribute(rolesRdnAttr);++        LDAPIdentityStore identityStore = new LDAPIdentityStore(session, ldapConfig);++        LDAPDn.RDN rdn = LDAPDn.fromString(dn).getFirstRdn();+        String key = rdn.getAllKeys().get(0);+        String value = rdn.getAttrValue(key);+        ldapQuery.addWhereCondition(new EqualCondition(key, value, EscapeStrategy.DEFAULT));++        List<LDAPObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+        if (ldapObjects.size() == 1) {+            dns.put(dn, ldapObjects.get(0).getUuid());+            return ldapObjects.get(0).getUuid();+        }+        return null;+    }++    private MapModelCriteriaBuilder<String, LdapRoleEntity, RoleModel> createCriteriaBuilderMap() {+        return new MapModelCriteriaBuilder<>(keyConverter, MapFieldPredicates.getPredicates(RoleModel.class));+    }++    @Override+    public MapRoleEntity create(MapRoleEntity value) {+        this.realm = value.getRealmId();+        LdapRoleMapperConfig roleMapperConfig = new LdapRoleMapperConfig(config, value.getRealmId(), value.getClientId() != null, value.getClientId());+        LdapConfig ldapConfig = new LdapConfig(config, value.getRealmId());+        LDAPIdentityStore identityStore = new LDAPIdentityStore(session, ldapConfig);++        DeepCloner CLONER = new DeepCloner.Builder()+                .constructor(MapRoleEntity.class, cloner -> new LdapRoleEntity(cloner, roleMapperConfig, this))+                .build();++        LdapRoleEntity mapped = (LdapRoleEntity) CLONER.from(value);+        // LDAP should never use the UUID provided by the caller, as UUID is generated+        mapped.setId(null);+        // Roles as groups need to have at least one member on most directories. Add ourselves as a member as a dummy.+        if (mapped.getLdapObject().getUuid() == null && mapped.getLdapObject().getAttributeAsSet(roleMapperConfig.getMembershipLdapAttribute()) == null) {+            // insert our own name as dummy member of this role to avoid a schema conflict in LDAP+            mapped.getLdapObject().setAttribute(roleMapperConfig.getMembershipLdapAttribute(), Stream.of(mapped.getLdapObject().getDn().toString()).collect(Collectors.toSet()));+        }++        try {+            // in order to get the ID, we need to write it to LDAP+            identityStore.add(mapped.getLdapObject());+        } catch (ModelException ex) {+            if (value.isClientRole() && ex.getCause() instanceof NamingException) {+                // the client hasn't been created, therefore adding it here+                LDAPObject client = new LDAPObject();+                client.setObjectClasses(Arrays.asList(""top"", ""organizationalUnit""));+                client.setRdnAttributeName(""ou"");+                client.setDn(LDAPDn.fromString(roleMapperConfig.getRolesDn()));+                client.setSingleAttribute(""ou"", mapped.getClientId());+                identityStore.add(client);++                tasksOnRollback.add(new DeleteOperation(mapped) {+                    @Override+                    public void execute() {+                        identityStore.remove(client);+                    }+                });++                // retry creation of client role+                identityStore.add(mapped.getLdapObject());+            }+        }++        entities.put(new EntityKey(mapped.getRealmId(), mapped.getId()), mapped);++        tasksOnRollback.add(new DeleteOperation(mapped) {+            @Override+            public void execute() {+                identityStore.remove(mapped.getLdapObject());+                entities.remove(new EntityKey(mapped.getRealmId(), mapped.getId()));+            }+        });++        return mapped;+    }++    @Override+    public boolean delete(String key) {+        LdapRoleEntity read = read(key);+        if (read == null) {+            throw new ModelException(""unable to read entity with key "" + key);+        }+        deletedKeys.add(key);+        tasksOnCommit.add(new DeleteOperation(read) {+            @Override+            public void execute() {+                LdapConfig ldapConfig = new LdapConfig(config, entity.getRealmId());+                LDAPIdentityStore identityStore = new LDAPIdentityStore(session, ldapConfig);+                identityStore.remove(entity.getLdapObject());+            }+        });+        return true;+    }++    @Override+    public LdapRoleEntity read(String key) {+        // for now, only support one realm, don't make realm part of the key+        // https://github.com/keycloak/keycloak/discussions/10045+        String realm = this.realm;+        @SuppressWarnings(""UnnecessaryLocalVariable"") String id = key;++        if (deletedKeys.contains(key)) {+            return null;+        }++        // reuse an existing live entity+        LdapRoleEntity val = entities.get(new EntityKey(realm, id));++        if (val == null) {+            LdapConfig ldapConfig = new LdapConfig(config, realm);++            // try to look it up as a realm role+            val = lookupEntityById(realm, id, ldapConfig, null);++            if (val == null) {+                // try to look it up using a client role+                // currently the API doesn't allow to get a list of all keys, therefore we need a separate attribute+                // also, getArray is broken as it doesn't look up the parent's values if an entry is empty+                String clientsToSearch = config.scope(""clients"").get(""clientsToSearch"");+                if (clientsToSearch != null) {+                    String[] clientIds = clientsToSearch.split(""\\s*,\\s*"");+                    for (String clientId : clientIds) {+                        val = lookupEntityById(realm, id, ldapConfig, clientId);+                        if (val != null) {+                            break;+                        }+                    }+                }+            }++            if (val == null) {+                // try to find out the client ID+                LDAPQuery ldapQuery = new LDAPQuery(null);++                // For now, use same search scope, which is configured ""globally"" and used for user's search.+                ldapQuery.setSearchScope(ldapConfig.getSearchScope());++                // remove prefix with placeholder to allow for a broad search+                String sdn = config.scope(""clients"").get(""roles.dn"");+                ldapQuery.setSearchDn(sdn.replaceAll("".*\\{0},"", """"));++                ldapQuery.addWhereCondition(new EqualCondition(ldapConfig.getUuidLDAPAttributeName(), id, EscapeStrategy.DEFAULT));++                LDAPIdentityStore identityStore = new LDAPIdentityStore(session, ldapConfig);++                List<LDAPObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+                if (ldapObjects.size() == 1) {+                    // as the client ID is now known, search again with the specific configuration+                    String clientId = ldapObjects.get(0).getDn().getParentDn().getFirstRdn().getAttrValue(""ou"");+                    // TODO: re-use the ldapObject to create the entity instead of querying again+                    val = lookupEntityById(realm, id, ldapConfig, clientId);+                }+            }++            if (val != null) {+                entities.put(new EntityKey(val.getRealmId(), val.getId()), val);+            }++        }+        return val;+    }++    private LdapRoleEntity lookupEntityById(String realm, String id, LdapConfig ldapConfig, String clientId) {+        LdapRoleMapperConfig roleMapperConfig = new LdapRoleMapperConfig(config, realm, clientId != null, clientId);","Nit:```suggestion        LdapRoleMapperConfig roleMapperConfig = new LdapRoleMapperConfig(config, realm, clientId != null, clientId);```Is `clientId != null` parameter necessary?",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/10152,811905514,2022-02-22T12:43:39Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/HotRodMapStorageProviderFactory.java,"@@ -81,6 +86,16 @@                         HotRodClientEntity.class,                         HotRodClientEntityDelegate::new)); +        ENTITY_DESCRIPTOR_MAP.put(ClientScopeModel.class,+                new HotRodEntityDescriptor<HotRodClientScopeEntity, HotRodClientScopeEntityDelegate>(ClientScopeModel.class,+                        HotRodClientScopeEntity.class,+                        HotRodClientScopeEntityDelegate::new) {+                            @Override+                            public String getCacheName() {+                                return ""clientScopes"";","We can use defaults in `MODEL_TO_NAME` map. I guess, I was trying to be consistent with the ""Spi name + s"" pattern. I didn't realize that `MODEL_TO_NAME` map is dedicated for this purpose only. ",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10152,811907546,2022-02-22T12:46:01Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/common/HotRodTypesUtils.java,"@@ -38,7 +39,7 @@     }      public static <MapKey, MapValue, SetValue> Map<MapKey, MapValue> migrateSetToMap(Set<SetValue> set, Function<SetValue, MapKey> keyProducer, Function<SetValue, MapValue> valueProducer) {-        return set == null ? null : set.stream().collect(Collectors.toMap(keyProducer, valueProducer));+        return set == null ? null : set.stream().collect(HashMap::new, (m, v) -> m.put(keyProducer.apply(v), valueProducer.apply(v)), HashMap::putAll);","Not for me. In my case, the third parameter makes it not checking the value for `null`. Anyway, this probably depends on Java implementation and it seems to be a [known bug](https://bugs.openjdk.java.net/browse/JDK-8148463) in OpenJDK. I would say, it is safer to use your approach even though the lambda is not ideal.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/10152,812062800,2022-02-22T15:23:51Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -1312,7 +1312,7 @@ public boolean removeClientScope(RealmModel realm, String id) {      @Override     public void removeClientScopes(RealmModel realm) {-        realm.getClientScopesStream().map(ClientScopeModel::getId).forEach(id -> removeClientScope(realm, id));+        getRealmDelegate().getClientScopesStream(realm).map(ClientScopeModel::getId).forEach(id -> removeClientScope(realm, id));","So problem with `realm.getClientScopesStream()` is that it looks into the cache which is empty, so nothing is removed eventually. So I dug into why the cache is empty and I see the client scopes are populated into `CachedRealm` only when `RealmCacheSession#getRealm` is called for the first time [1]. The method is called for the first time from `KeycloakModelTest#withRealm` when there are no client scopes created yet. Is there a flaw in model tests?Second question is whether `removeClientScopes` should look only into cache and delete only what is cached. This might not work in cases when something is gone from the cache but still present in a storage. [1] https://github.com/keycloak/keycloak/blob/eae29422e4980dd6b3b725aa96dff12be873da01/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java#L414",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10288,812173664,2022-02-22T17:12:15Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/OfflineSessionPersistenceTest.java,"@@ -130,6 +131,7 @@ public void testPersistenceSingleNode() {     }      @Test(timeout = 90 * 1000)+    @Ignore(""test currently fails as offline sessions are not loaded by default any more?!"")","@martin-kanis - I've been updating inIndependentFactories() so that any assert wrapped inside it will make the test fail. Due to this change, the following code now fails when ""keycloak.model.parameters=Infinispan,Jpa"" are set.I now wonder: is this due to offline sessions no longer being loaded by default, one of the PR's that went through your hands lately?```inIndependentFactories(4, 30, () -> assertOfflineSessionsExist(realmId, clientSessionIds.keySet()));``` ",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10288,812177330,2022-02-22T17:16:18Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/OfflineSessionPersistenceTest.java,"@@ -164,6 +166,8 @@ public void testPersistenceMultipleNodesClientSessionAtSameNode() throws Interru     }      @Test(timeout = 90 * 1000)+    @RequireProvider(UserSessionPersisterProvider.class)+    @RequireProvider(value = UserSessionProvider.class, only = InfinispanUserSessionProviderFactory.PROVIDER_ID)","@martin-kanis - this test failed in ""map"" and ""hot-rod"" profile, with an exception like the following. I wonder what a sensible condition would apply here, I tried those two `@RequireProvider` here. If I would understand better what the testing is doing, I might make a better choice here. Thanks!```Caused by: com.fasterxml.jackson.databind.exc.MismatchedInputException: No content to map due to end-of-input  at [Source: (File); line: 1, column: 0] 	at com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:59) 	at com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:4688) 	at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4586) 	at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3453) 	at org.keycloak.models.map.storage.chm.ConcurrentHashMapStorageProviderFactory.loadMap(ConcurrentHashMapStorageProviderFactory.java:231)``` ",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10221,812199112,2022-02-22T17:38:59Z,adapters/oidc/js/src/keycloak.js,"@@ -445,6 +445,11 @@ function Keycloak (config) {             url += '&ui_locales=' + encodeURIComponent(options.locale);         } +        if (options && options.acr) {+            var claimsParameter = new ClaimsBuilder().acr(options.acr).build();","I don't see why this needs to use a class, can we make this a function instead?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/10152,812265306,2022-02-22T18:59:57Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/clientscope/HotRodClientScopeEntity.java,"@@ -0,0 +1,111 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.hotRod.clientscope;++import org.infinispan.protostream.annotations.ProtoDoc;+import org.infinispan.protostream.annotations.ProtoField;+import org.keycloak.models.map.annotations.GenerateHotRodEntityImplementation;+import org.keycloak.models.map.client.MapProtocolMapperEntity;+import org.keycloak.models.map.clientscope.MapClientScopeEntity;+import org.keycloak.models.map.storage.hotRod.client.HotRodProtocolMapperEntity;+import org.keycloak.models.map.storage.hotRod.common.AbstractHotRodEntity;+import org.keycloak.models.map.storage.hotRod.common.HotRodAttributeEntityNonIndexed;+import org.keycloak.models.map.storage.hotRod.common.UpdatableHotRodEntityDelegateImpl;++import java.util.Collection;+import java.util.LinkedHashSet;+import java.util.Objects;+import java.util.Optional;+import java.util.Set;++@GenerateHotRodEntityImplementation(+        implementInterface = ""org.keycloak.models.map.clientscope.MapClientScopeEntity"",+        inherits = ""org.keycloak.models.map.storage.hotRod.clientscope.HotRodClientScopeEntity.AbstractHotRodClientScopeEntityDelegate""+)+@ProtoDoc(""@Indexed"")+public class HotRodClientScopeEntity extends AbstractHotRodEntity  {++    @ProtoField(number = 1, required = true)+    public int entityVersion = 1;++    @ProtoField(number = 2, required = true)+    public String id;++    @ProtoDoc(""@Field(index = Index.YES, store = Store.YES)"")+    @ProtoField(number = 3)+    public String realmId;++    @ProtoDoc(""@Field(index = Index.YES, store = Store.YES)"")+    @ProtoField(number = 4)+    public String name;++    @ProtoField(number = 5)+    public String protocol;++    @ProtoField(number = 6)+    public String description;++    @ProtoField(number = 7, collectionImplementation = LinkedHashSet.class)",There is `Collection` used to be consistent with [`MapClientEntity`](https://github.com/keycloak/keycloak/blob/main/model/map/src/main/java/org/keycloak/models/map/client/MapClientEntity.java#L83). I don't think we need ordering here.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10221,812621143,2022-02-23T07:39:39Z,adapters/oidc/js/src/keycloak.js,"@@ -445,6 +445,11 @@ function Keycloak (config) {             url += '&ui_locales=' + encodeURIComponent(options.locale);         } +        if (options && options.acr) {+            var claimsParameter = new ClaimsBuilder().acr(options.acr).build();","@jonkoops I see your point.My motivation was that OIDC specification has parameter called ""claims"", which is JSON structure, which can be sent from client application. See the details here: https://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter .This PR contains just support for ""acr"" claim, but I was thinking that in the future, if we want to add better support for the ""claims"" parameter, we will just be able to re-use the ClaimsBuilder structure.So that was motivation for introducing ClaimsBuilder, but at the same time, I don't have strong need to introduce it now in this PR. So if you prefer, I can remove `ClaimsBuilder` and use simple function for now, and then later, we can revisit and introduce some mechanism for more flexible adding of `claims` parameter.WDYT? Are you ok to keep it like in the PR or do you prefer to simplify it and eventually re-add something for `claims` in some future PRs?",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10373,812628800,2022-02-23T07:53:16Z,federation/ldap/src/main/java/org/keycloak/storage/ldap/idm/store/ldap/LDAPOperationManager.java,"@@ -279,7 +279,8 @@ public String toString() {              });         } catch (NamingException e) {-            logger.errorf(e, ""Could not query server using DN [%s] and filter [%s]"", baseDN, filter);+            // do not log and throw!","After moving over the classes to the LDAP map module, this change has been reverted.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10373,812685210,2022-02-23T09:11:56Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/LdapMapStorageProvider.java,"@@ -0,0 +1,62 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap;++import org.keycloak.models.KeycloakSession;+import org.keycloak.models.map.common.AbstractEntity;+import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.MapStorage;+import org.keycloak.models.map.storage.MapStorageProvider;+import org.keycloak.models.map.storage.MapStorageProviderFactory.Flag;+import org.keycloak.models.map.storage.ldap.role.LdapRoleMapKeycloakTransaction;++public class LdapMapStorageProvider implements MapStorageProvider {++    private final String SESSION_TX_PREFIX = ""ldap-map-tx-"";++    private final LdapMapStorageProviderFactory factory;++    @Deprecated+    private final MapStorageProvider delegate;++    public LdapMapStorageProvider(LdapMapStorageProviderFactory factory,+                                  MapStorageProvider delegate) {+        this.factory = factory;+        this.delegate = delegate;","As seen yesterday, there delegate was not used for the roles any more, I kept it for future temporary use for users.With the latest commits, LdapRoleEntity now implements EntityFieldDelegate<MapRoleEntity>, and uses this for the field ""description"". Let's discuss if I'm on the right track here in our next call, and then I'll continue. ",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/10288,812714649,2022-02-23T09:47:03Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/infinispan/CacheExpirationTest.java,"@@ -71,12 +74,16 @@ public void testCacheExpiration() throws Exception {         // Ensure that instance counting works as expected, there should be at least two instances in memory now.         // Infinispan server is decoding the client request before processing the request at the cache level,         // therefore there are sometimes three instances of AuthenticationSessionAuthNoteUpdateEvent class in the memory","I discussed this problem with Ryan from Infinispan team. His exact explanation was:""This is just a transient use of the class when the server is decoding the client request before processing the request at the cache level, hence why you only see it sometimes. I don't think this is anything to be concerned about.""I have a screenshot from heap dump which showing the references of this instance, if you are interested. So I don't think we need to worry about it in the test. ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10206,812785403,2022-02-23T11:12:49Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ComponentsTest.java,"@@ -172,6 +172,25 @@ public void testCreateWithGivenId() {         assertEquals(""fixed-id"", id);     } +    @Test+    public void failCreateWithLongName() {+        StringBuilder name = new StringBuilder();++        while (name.length() < 300) {+            name.append(""invalid"");+        }++        ComponentRepresentation rep = createComponentRepresentation(name.toString());++        rep.getConfig().addFirst(""required"", ""foo"");++        ComponentsResource components = realm.components();++        try (Response response = components.add(rep)) {+            assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());+        }","The expected status codes is whatever HTTP specs say. We often result in 500's today due to invalid request, which is just not correct. Reason for this is often down to missing validation, but also in terms of when the error comes from the DB we're not able to map the SQL exceptions properly to a proper status code. Part of the solution to that is better validation, which I believe has to be a thing done by the new store, as there is some validation that can be done upfront, but then there's also store-specific limitations/validations I presume.The point about map store not being a good fit as a replacement for dev-file/mem as it doesn't verify if a particular database can store it is not a valid argument at all. Testing with H2 in dev, does not give you any guarantees that it will work with PostgreSQL in production. Besides, the plan is also to offer static store as an option in production as well.I'd suggest we separate this into a discussion around validation, and expected status codes to be returned under different situations. Now, as no-one is going to start working on that right now I would suggest we table this discussion a little bit until we have identified what team should work on validation (hint: I will push hard on extending/unifying our validation after the new store is ready).",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10396,812805333,2022-02-23T11:40:23Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/MetricsDistTest.java,"@@ -28,6 +28,35 @@ @DistributionTest(keepAlive =true) public class MetricsDistTest {",perhaps then also have a dedicated test class?,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10396,812840422,2022-02-23T12:27:35Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/MetricsDistTest.java,"@@ -28,6 +28,35 @@ @DistributionTest(keepAlive =true) public class MetricsDistTest {","separated the test class but left the ""negative tests""",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/10288,812877631,2022-02-23T13:13:58Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/OfflineSessionPersistenceTest.java,"@@ -164,6 +166,8 @@ public void testPersistenceMultipleNodesClientSessionAtSameNode() throws Interru     }      @Test(timeout = 90 * 1000)+    @RequireProvider(UserSessionPersisterProvider.class)+    @RequireProvider(value = UserSessionProvider.class, only = InfinispanUserSessionProviderFactory.PROVIDER_ID)","This is weird one. There's something wrong with map-[realms|user-sessions|client-sessions]-mapStorage-f:ROOT:concurrenthashmap.json file where corresponding storages are serialized. There's probably something missing and I guess it has something to do with concurrency. Problem can be reproduced by running `mvn test -f testsuite/model/pom.xml -Phot-rod -Dkeycloak.logging.level=debug -Dtest=OfflineSessionPersistenceTest#testPersistenceMultipleNodesClientSessionsAtRandomNode -Dmaven.surefire.debug` with breakpoint at `ConcurrentHashMapStorageProviderFactory.java:234````Caused by: java.lang.RuntimeException: com.fasterxml.jackson.databind.JsonMappingException: Unexpected end-of-input within/between Object entries at [Source: (File); line: 12846, column: 26] (through reference chain: java.util.LinkedList[637])	at org.keycloak.models.map.storage.chm.ConcurrentHashMapStorageProviderFactory.loadMap(ConcurrentHashMapStorageProviderFactory.java:234)	at org.keycloak.models.map.storage.chm.ConcurrentHashMapStorageProviderFactory.lambda$getStorage$1(ConcurrentHashMapStorageProviderFactory.java:263)	at java.base/java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705)	at org.keycloak.models.map.storage.chm.ConcurrentHashMapStorageProviderFactory.getStorage(ConcurrentHashMapStorageProviderFactory.java:263)	at org.keycloak.models.map.storage.chm.ConcurrentHashMapStorageProvider.getStorage(ConcurrentHashMapStorageProvider.java:43)	at org.keycloak.models.map.userSession.MapUserSessionProviderFactory.create(MapUserSessionProviderFactory.java:86)	at org.keycloak.models.map.userSession.MapUserSessionProviderFactory.create(MapUserSessionProviderFactory.java:43)	at org.keycloak.services.DefaultKeycloakSession.getProvider(DefaultKeycloakSession.java:316)	at org.keycloak.services.DefaultKeycloakSession.sessions(DefaultKeycloakSession.java:455)	at org.keycloak.testsuite.model.session.OfflineSessionPersistenceTest.lambda$createOfflineClientSession$28(OfflineSessionPersistenceTest.java:282)	at org.keycloak.testsuite.model.KeycloakModelTest.lambda$withRealm$13(KeycloakModelTest.java:598)	at org.keycloak.testsuite.model.KeycloakModelTest.lambda$inComittedTransaction$11(KeycloakModelTest.java:563)	at org.keycloak.testsuite.model.KeycloakModelTest.lambda$inComittedTransaction$12(KeycloakModelTest.java:580)	at org.keycloak.models.utils.KeycloakModelUtils.runJobInTransaction(KeycloakModelUtils.java:239)	at org.keycloak.testsuite.model.KeycloakModelTest.inComittedTransaction(KeycloakModelTest.java:568)	at org.keycloak.testsuite.model.KeycloakModelTest.inComittedTransaction(KeycloakModelTest.java:563)	at org.keycloak.testsuite.model.KeycloakModelTest.withRealm(KeycloakModelTest.java:595)	at org.keycloak.testsuite.model.session.OfflineSessionPersistenceTest.createOfflineClientSession(OfflineSessionPersistenceTest.java:281)	at org.keycloak.testsuite.model.session.OfflineSessionPersistenceTest.lambda$testPersistenceMultipleNodesClientSessionsAtRandomNode$19(OfflineSessionPersistenceTest.java:192)	at org.keycloak.testsuite.model.KeycloakModelTest.lambda$inIndependentFactories$4(KeycloakModelTest.java:373)	at org.keycloak.testsuite.model.KeycloakModelTest.inIndependentFactory(KeycloakModelTest.java:472)```",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/10288,812909694,2022-02-23T13:49:55Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/OfflineSessionPersistenceTest.java,"@@ -164,6 +166,8 @@ public void testPersistenceMultipleNodesClientSessionAtSameNode() throws Interru     }      @Test(timeout = 90 * 1000)+    @RequireProvider(UserSessionPersisterProvider.class)+    @RequireProvider(value = UserSessionProvider.class, only = InfinispanUserSessionProviderFactory.PROVIDER_ID)",That might be the case but I'm not sure why we see it only in `testPersistenceMultipleNodesClientSessionAtSameNode` and `testPersistenceMultipleNodesClientSessionsAtRandomNode` tests and not in other tests that use `inIndependentFactories`. I'm also curious about @hmlnarik's view on this.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10288,812940038,2022-02-23T14:20:35Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/OfflineSessionPersistenceTest.java,"@@ -164,6 +166,8 @@ public void testPersistenceMultipleNodesClientSessionAtSameNode() throws Interru     }      @Test(timeout = 90 * 1000)+    @RequireProvider(UserSessionPersisterProvider.class)+    @RequireProvider(value = UserSessionProvider.class, only = InfinispanUserSessionProviderFactory.PROVIDER_ID)","> Could it be that each simulated Keycloak instance, the CHM stores should point at is own set of files, but at the moment in this case of concurrent tests they all try to read and write the same file?I believe this is the case. Would this vanish with synchronizing the `loadMap` / `storeMap` methods on `ConcurrentHashMapStorageProviderFactory.class`?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10152,812948574,2022-02-23T14:28:20Z,model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java,"@@ -1312,7 +1312,7 @@ public boolean removeClientScope(RealmModel realm, String id) {      @Override     public void removeClientScopes(RealmModel realm) {-        realm.getClientScopesStream().map(ClientScopeModel::getId).forEach(id -> removeClientScope(realm, id));+        getRealmDelegate().getClientScopesStream(realm).map(ClientScopeModel::getId).forEach(id -> removeClientScope(realm, id));","I would say the test is correct. Also, it seems the line you identified is indeed wrong, however, I am not sure the fix is the right one.The way I understand it is that we are caching ids of all clientsScopes for each realm. When changing some client scope (addition/removal) we [invalidate realm](https://github.com/keycloak/keycloak/blob/main/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java#L1286-L1296). The problem of the method you identified is, that it is not checking invalidation and therefore in the test case you added to model tests it fails.The way it is fixed here is that you removed looking into the cache at all, and we are just looking into the store directly.I would say this is not necessary, we can  use the data in the cache if they are not stale, therefore  we need to use a method that is checking for invalidations, I think something like this should be sufficient:```suggestion        getClientScopesStream(realm).map(ClientScopeModel::getId).forEach(id -> removeClientScope(realm, id));```@vramik Could you please double-check?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10396,813094309,2022-02-23T16:42:44Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/MetricsDistTest.java,"@@ -28,6 +28,13 @@ @DistributionTest(keepAlive =true) public class MetricsDistTest { +    @Test+    @Launch({ ""start-dev"" })+    void testMetricsEndpointNotEnabled() {+        when().get(""/metrics"").then()+                .statusCode(404);+    }+     @Test     @Launch({ ""start-dev"", ""--metrics-enabled=true"" })     void testMetricsEndpoint() {",Perhaps we could test that it's really independent of the health endpoint?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10387,813121940,2022-02-23T17:09:57Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDiscoveryService.java,"@@ -0,0 +1,94 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.IntOrString;+import io.fabric8.kubernetes.api.model.Service;+import io.fabric8.kubernetes.api.model.ServiceBuilder;+import io.fabric8.kubernetes.api.model.ServiceSpec;+import io.fabric8.kubernetes.api.model.ServiceSpecBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.StatusUpdater;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;++import java.util.Optional;++public class KeycloakDiscoveryService extends OperatorManagedResource implements StatusUpdater<KeycloakStatusBuilder> {++    private Service existingService;++    public KeycloakDiscoveryService(KubernetesClient client, Keycloak keycloakCR) {+        super(client, keycloakCR);+        fetchExistingService().ifPresent(s -> this.existingService = s);+    }++    private ServiceSpec getServiceSpec() {+      return new ServiceSpecBuilder()+              .addNewPort()+              .withPort(Constants.KEYCLOAK_DISCOVERY_SERVICE_PORT)+              .endPort()+              .withSelector(Constants.DEFAULT_LABELS)+              .withClusterIP(""None"")+              .build();+    }++    @Override+    protected Optional<HasMetadata> getReconciledResource() {+        return Optional.of(+                Optional.ofNullable(existingService)+                    .map(a -> {+                            a.setSpec(getServiceSpec());+                            return a;+                            })+                .orElse(newService()));","Again, feels a bit overengineered and hard to read. I know we had something similar in the [original PR](https://github.com/keycloak/keycloak/pull/10249/files#diff-5adccfca8d062a51830e0c5b2e61ef1ccb1f9f81f0aebe17a24734f2d7d2adeeR51-R56) but this is even more complicated.But just a nit pick, not a blocker.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10387,813129836,2022-02-23T17:18:26Z,operator/src/test/java/org/keycloak/operator/ClusteringE2EIT.java,"@@ -0,0 +1,102 @@+package org.keycloak.operator;++import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.BeforeEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.KeycloakService;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;+import org.keycloak.operator.utils.K8sUtils;++import java.time.Duration;+import java.util.List;++import static java.util.concurrent.TimeUnit.MINUTES;+import static java.util.concurrent.TimeUnit.SECONDS;+import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.Constants.KEYCLOAK_DISCOVERY_SERVICE_PORT;+import static org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition.READY;++@QuarkusTest+public class ClusteringE2EIT extends ClusterOperatorTest {++    private KeycloakStatusCondition getCondition(List<KeycloakStatusCondition> conditions, String type) {+        return conditions+                .stream()+                .filter(c -> c.getType().equals(type))+                .findFirst()+                .get();+    }++    @Test+    public void testKeycloakScaleAsExpected() {+        // given+        var kc = K8sUtils.getDefaultKeycloakDeployment();+        var crSelector = k8sclient+                .resources(Keycloak.class)+                .inNamespace(kc.getMetadata().getNamespace())+                .withName(kc.getMetadata().getName());+        K8sUtils.deployKeycloak(k8sclient, kc, true);++        var kcPodsSelector = k8sclient.pods().inNamespace(namespace).withLabel(""app"", ""keycloak"");++        Keycloak keycloak = k8sclient.resources(Keycloak.class)+                .inNamespace(namespace)+                .list().getItems().get(0);++        // when scale it to 10+        keycloak.getSpec().setInstances(10);+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloak);++        Awaitility.await()+                .atMost(2, MINUTES)+                .pollDelay(5, SECONDS)+                .ignoreExceptions()+                .untilAsserted(() -> {+                    var conditions = crSelector+                            .get()+                            .getStatus()+                            .getConditions();++                    assertThat(getCondition(conditions, READY).getStatus()).isFalse();",Please use:https://github.com/keycloak/keycloak/blob/55315c18b146086fe2e0d1b290dd0106f5206ada/operator/src/test/java/org/keycloak/operator/utils/CRAssert.java#L28,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10387,813130335,2022-02-23T17:18:57Z,operator/src/test/java/org/keycloak/operator/ClusteringE2EIT.java,"@@ -0,0 +1,102 @@+package org.keycloak.operator;++import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.BeforeEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.KeycloakService;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;+import org.keycloak.operator.utils.K8sUtils;++import java.time.Duration;+import java.util.List;++import static java.util.concurrent.TimeUnit.MINUTES;+import static java.util.concurrent.TimeUnit.SECONDS;+import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.Constants.KEYCLOAK_DISCOVERY_SERVICE_PORT;+import static org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition.READY;++@QuarkusTest+public class ClusteringE2EIT extends ClusterOperatorTest {++    private KeycloakStatusCondition getCondition(List<KeycloakStatusCondition> conditions, String type) {+        return conditions+                .stream()+                .filter(c -> c.getType().equals(type))+                .findFirst()+                .get();+    }++    @Test+    public void testKeycloakScaleAsExpected() {+        // given+        var kc = K8sUtils.getDefaultKeycloakDeployment();+        var crSelector = k8sclient+                .resources(Keycloak.class)+                .inNamespace(kc.getMetadata().getNamespace())+                .withName(kc.getMetadata().getName());+        K8sUtils.deployKeycloak(k8sclient, kc, true);++        var kcPodsSelector = k8sclient.pods().inNamespace(namespace).withLabel(""app"", ""keycloak"");++        Keycloak keycloak = k8sclient.resources(Keycloak.class)+                .inNamespace(namespace)+                .list().getItems().get(0);++        // when scale it to 10+        keycloak.getSpec().setInstances(10);+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloak);++        Awaitility.await()+                .atMost(2, MINUTES)+                .pollDelay(5, SECONDS)+                .ignoreExceptions()+                .untilAsserted(() -> {+                    var conditions = crSelector+                            .get()+                            .getStatus()+                            .getConditions();++                    assertThat(getCondition(conditions, READY).getStatus()).isFalse();+                });+        Awaitility.await()+                .atMost(Duration.ofSeconds(5))+                .untilAsserted(() -> assertThat(kcPodsSelector.list().getItems().size()).isEqualTo(10));++        // when scale it down to 2+        keycloak.getSpec().setInstances(2);+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloak);+        Awaitility.await()+                .atMost(Duration.ofSeconds(180))+                .untilAsserted(() -> assertThat(kcPodsSelector.list().getItems().size()).isEqualTo(2));++        Awaitility.await()+                .atMost(2, MINUTES)+                .pollDelay(5, SECONDS)+                .ignoreExceptions()+                .untilAsserted(() -> {+                    var conditions = crSelector+                            .get()+                            .getStatus()+                            .getConditions();++                    assertThat(getCondition(conditions, READY).getStatus()).isTrue();",Please use:https://github.com/keycloak/keycloak/blob/55315c18b146086fe2e0d1b290dd0106f5206ada/operator/src/test/java/org/keycloak/operator/utils/CRAssert.java#L28,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10387,813153946,2022-02-23T17:45:05Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDiscoveryService.java,"@@ -0,0 +1,94 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.IntOrString;+import io.fabric8.kubernetes.api.model.Service;+import io.fabric8.kubernetes.api.model.ServiceBuilder;+import io.fabric8.kubernetes.api.model.ServiceSpec;+import io.fabric8.kubernetes.api.model.ServiceSpecBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.StatusUpdater;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;++import java.util.Optional;++public class KeycloakDiscoveryService extends OperatorManagedResource implements StatusUpdater<KeycloakStatusBuilder> {++    private Service existingService;++    public KeycloakDiscoveryService(KubernetesClient client, Keycloak keycloakCR) {+        super(client, keycloakCR);+        fetchExistingService().ifPresent(s -> this.existingService = s);","I do find the original implementation as completely legit usage of plain standard library, e.g. we are not adding unnecessary abstractions or strange stuffs ...but not fussy on it done.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10429,813460710,2022-02-24T01:01:53Z,core/pom.xml,"@@ -32,8 +32,8 @@     <description/>      <properties>-        <maven.compiler.target>1.7</maven.compiler.target>-        <maven.compiler.source>1.7</maven.compiler.source>+        <maven.compiler.target>1.8</maven.compiler.target>+        <maven.compiler.source>1.8</maven.compiler.source>","Can we remove these 1.7 compiler limitations? If not it is not a big deal, really, but it would be awesome if we could get rid of those as there are several features, such as default methods, that have been introduced in later JDK versions and that are not available in 1.7.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10429,813461648,2022-02-24T01:03:56Z,server-spi-private/src/main/java/org/keycloak/component/ProfileEnabledProviderFactory.java,"@@ -0,0 +1,23 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.component;++/**+ * Marker interface to identify provider factories that support multiple configuration profiles.+ */+public interface ProfileEnabledProviderFactory {","I propose the introduction of this interface to allow the code that is initializing the instantiated factories to handle profiles only if the factory supports them, for efficiency reasons. But, of course, this can be changed.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10429,813462011,2022-02-24T01:04:51Z,server-spi-private/src/main/java/org/keycloak/models/utils/KeycloakModelUtils.java,"@@ -318,17 +319,20 @@ public static ComponentModel getComponentModel(KeycloakSessionFactory factory, S         private final String componentId;         private final String providerId;         private final String providerType;+        private final String providerProfile;         private final String realmId;         private final Scope config; -        public ScopeComponentModel(Class<?> providerClass, Scope baseConfiguration, String spiName, String realmId) {+        public ScopeComponentModel(final Class<?> providerClass, final Scope baseConfiguration, final String spiName, final String realmId,+                                   final String modelName) {             final String pr = baseConfiguration.get(""provider"", Config.getProvider(spiName));-             this.providerId = pr == null ? ""default"" : pr;+            this.providerType = providerClass.getName();+            this.providerProfile = getProviderProfile(baseConfiguration, spiName, providerId);             this.config = baseConfiguration.scope(this.providerId);-            this.componentId = spiName + ""- "" + (realmId == null ? """" : ""f:"" + realmId + "":"") + this.providerId;+            this.componentId = spiName + ""-"" + (realmId == null ? """" : ""f:"" + realmId + "":"") + this.providerId + "":"" ++                    (this.config.isEmpty()? this.providerProfile : modelName + ""-inline"");","If the ""inline"" config is not empty, we assume it is trying to override one of the profiles with some area-specific needs, and thus we craft a componentId that conveys that.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10078,813629006,2022-02-24T07:59:39Z,docs/guides/src/main/server/outgoinghttp.adoc,"@@ -109,39 +112,43 @@ The special value NO_PROXY for the proxy-uri can be used to indicate that no pro .*;http://fallback:8080 ---- -== Outgoing HTTPS request truststore-When Keycloak calls remote HTTPS endpoints, it has to validate the remote server's certificate in order to ensure it is connecting to a trusted server. This is necessary in order to prevent man-in-the-middle attacks.  The certificates of these remote servers or the CA that signed these certificates must be put in a truststore.+In this example, the following occurs: -This truststore is used to securely connect e.g. to identity brokers, LDAP identity providers, when sending emails, and for backchannel communication with client applications.+* The special value NO_PROXY for the proxy-uri is used, which means that no proxy is used for hosts matching the associated hostname pattern.+* A catch-all pattern ends the proxy-mappings, providing a default proxy for all outgoing requests. -When no truststore is configured, outgoing https connection will use the standard java truststore configuration by default. When no trust can be established, outgoing HTTPS requests will fail.+== Outgoing HTTPS request truststore+When Keycloak calls remote HTTPS endpoints, it has to validate the remote server's certificate to ensure it is connecting to a trusted server. This validation is necessary to prevent man-in-the-middle attacks. The certificates of these remote servers or the CA that signed these certificates must be put in a truststore.++This truststore is used to securely connect to identity brokers, LDAP identity providers, when sending emails, and for backchannel communication with client applications. When no truststore is configured, outgoing HTTPS connections use the standard java truststore configuration by default. When no trust can be established, outgoing HTTPS requests fail. -You can add your truststore configuration by using:+You can add your truststore configuration by entering this command:  <@kc.start parameters=""--spi-truststore-file-file=myTrustStore.jks --spi-truststore-file-password=password --spi-truststore-file-hostname-verification-policy=ANY""/> -Possible configuration options for this setting are:+The following are possible configuration options for this setting:  file:: The path to a Java keystore file.-HTTPS requests need a way to verify the host of the server they are talking to.-This is what the trustore does.+HTTPS requests need a way to verify the host of the server to which they are talking.+This is what the truststore does. The keystore contains one or more trusted host certificates or certificate authorities. This truststore file should only contain public certificates of your secured hosts. This is _REQUIRED_ if any of these properties are defined.  password:: Password of the keystore.-This is _REQUIRED_ if any of these properties are defined.+This option is _REQUIRED_ if any of these properties are defined.  hostname-verification-policy::-For HTTPS requests, this verifies the hostname of the server's certificate.-`ANY` means that the hostname is not verified. `WILDCARD` Allows wildcards in subdomain names, e.g.-*.foo.com. When using `STRICT`, the Common Name (CN) must match the hostname exactly. Default: `WILDCARD`+For HTTPS requests, this option verifies the hostname of the server's certificate. Default: `WILDCARD`+* `ANY` means that the hostname is not verified.+* `WILDCARD` allows wildcards in subdomain names, such as *.foo.com.+* When using `STRICT`, the Common Name (CN) must match the hostname exactly. -.Example-An example configuration for a truststore that allows you to create trustful connections to all `mycompany.org` domains and it's subdomains is shown below:+.Example of a truststore configuration+The following is an example configuration for a truststore that allows you to create trustful connections to all `mycompany.org` domains and its subdomains:  <kc.start parameters=""--spi-truststore-file-file=path/to/truststore.jks --spi-truststore-file-password=change_me --spi-truststore-file-hostname-verification-policy=WILDCARD""/>","could you please add a `@` sign after the `<`? So it's `<@kc.start parameters=...`? Typo, leading to not parsing the example right, see https://www.keycloak.org/server/outgoinghttp (bottom). Would be nice to have it fixed together with your changes :) ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,813649687,2022-02-24T08:29:57Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -249,7 +259,32 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta      private credentialRowCells(credential: UserCredential, type: string): React.ReactNode[] {         const credRowCells: React.ReactNode[] = [];-        credRowCells.push(<DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>{credential.userLabel}</DataListCell>);+        const credData: CredData = JSON.parse(credential.credentialData!);+        credRowCells.push(+            <DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>+                {credential.userLabel}+                {credData.remainingCodes && credData.totalCodes &&+                    <div>{credData.totalCodes - credData.remainingCodes}/{credData.totalCodes} recovery codes used</div>+                }+                {credData.remainingCodes && credData.remainingCodes < 4 &&+                    <>+                        <br />+                        <div className=""pf-c-alert pf-m-warning pf-m-inline"" aria-label=""Success alert"">+                            <div className=""pf-c-alert__icon"">+                                <i className=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+                            </div>+                            <h4 className=""pf-c-alert__title"">","I vote to avoid doing changes in `CredentialModel` and `CredentialRepresentation` classes and rather do it the other way around.The problem with changing `CredentialModel` is, that the class is part of public SPI and part of the model. This mean that if we change anything in it, it will become part of ""public SPI"" and it is a pain to remove/change it later. So ideal would be if the initial commit already is done in a way that `CredentialModel` does not need to be changed.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10365,813650276,2022-02-24T08:30:45Z,docs/guides/src/main/server/logging.adoc,"@@ -7,90 +7,100 @@ title=""Configuring logging"" summary=""Learn how to configure Logging"" includedOptions=""log-*""> -Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level, or for more specific categories like `org.hibernate` or `org.keycloak`. In this guide, you will learn how to configure the log level and format.+Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level or for more specific categories such as `org.hibernate` or `org.keycloak`. This guide describes how to configure the log level and the log format.  == Log level-The available log levels are listed in the following Table:+The following table describes the available log levels.  |==== |Level|Description-|FATAL|critical failures / complete inability to serve requests of any kind.-|ERROR|significant error or problem leading to the inability to process requests.-|WARN|A non-critical error or problem that may not require immediate correction.+|FATAL|Critical failures with complete inability to serve any kind of request.+|ERROR|A significant error or problem leading to the inability to process requests.+|WARN|A non-critical error or problem that might not require immediate correction. |INFO|Keycloak lifecycle events or important information. Low frequency.-|DEBUG|More detailed information for debugging purposes, including e.g. database logs. Higher frequency.+|DEBUG|More detailed information for debugging purposes, such as database logs. Higher frequency. |TRACE|Most detailed debugging information. Very high frequency.-|ALL|Special level for all log messages-|OFF|Special level to turn logging off entirely (not recommended)+|ALL|Special level for all log messages.+|OFF|Special level to turn logging off entirely (not recommended). |==== -=== Configuring the root log level-The root loggers log level can be set using the following command:+=== Root log level configuration+When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used. -<@kc.start parameters=""--log-level=<root-level>""/>+You set the root log level by using the following command: -using one of the levels mentioned in the table above. When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used.+<@kc.start parameters=""--log-level=<root-level>""/> -Setting the log level is case-insensitive, so you could either use for example `DEBUG` or `debug`.+Use these guidelines for this command: -When you accidentally set the log level twice, for example when you invoke `--log-level=info,...,debug,...` the last occurence in the list will be used as the log level, so for the example the root logger would be set to `DEBUG`.+* For `_<root-level>_`, supply a level defined in the preceding table.+* The log level is case-insensitive. For example, you could either use `DEBUG` or `debug`.+* If you were to accidentally set the log level twice, the last occurrence in the list becomes the log level. For example, if you included the syntax `--log-level=info,...,DEBUG,...`, the root logger would be `DEBUG`. -=== Configuring category-specific log levels-It is possible to set a different log level for specific areas in Keycloak. To enable category-specific logging, provide a comma-separated list containing the categories you want another log level than for the root category to the `--log-level` configuration:+=== Category-specific log level configuration+You can set different log levels for specific areas in Keycloak. Use this command to provide a comma-separated list of categories for which you want a different log level:  <@kc.start parameters=""--log-level=<root-level>,<org.category1>:<org.category1-level>""/> -A configuration that applies to a category also applies to all sub-categories of that category, unless a more specific matching sub-category configuration is provided in the list.+A configuration that applies to a category also applies to its sub-categories unless you include a more specific matching sub-category.  .Example <@kc.start parameters=""--log-level=INFO,org.hibernate:debug,org.hibernate.hql.internal.ast:info""/>-The example above sets the root log level for all loggers to INFO, and the hibernate log level in general to debug. But as we don't want SQL abstract syntax trees to make the log output verbose, we set the more specific sub category `org.hibernate.hql.internal.ast` to info, so the SQL abstract syntax trees, which would be shown at `debug` level, don't show up anymore. -== Configuring the logging format-Keycloak uses a pattern-based logging formatter that generates human-readable text logs by default.+This example sets the following log levels: -The logging format template for these lines can be applied at the root level.+* Root log level for all loggers is set to INFO.+* The hibernate log level in general is set to debug.+* To keep SQL abstract syntax trees from creating verbose log output, the specific subcategory `org.hibernate.hql.internal.ast` is set to info. As a result, the SQL abstract syntax trees are omitted instead of appearing at the `debug` level. -The default format template is:+== Logging format configuration+Keycloak uses a pattern-based logging formatter that generates human-readable text logs. The logging format template for these lines can be applied at the root level. The default format template is:  * `%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n` -The format string supports the following symbols:+The format string supports the symbols in the following table:  |==== |Symbol|Summary|Description |%%|%|Renders a simple % character. |%c|Category|Renders the log category name. |%d{xxx}|Date|Renders a date with the given date format string.String syntax defined by `java.text.SimpleDateFormat`-|%e|Exception|Renders the thrown exception, if any.+|%e|Exception|Renders any thrown exception that exists.",```suggestion|%e|Exception|Renders a thrown exception```,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10365,813651492,2022-02-24T08:32:29Z,docs/guides/src/main/server/logging.adoc,"@@ -7,90 +7,100 @@ title=""Configuring logging"" summary=""Learn how to configure Logging"" includedOptions=""log-*""> -Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level, or for more specific categories like `org.hibernate` or `org.keycloak`. In this guide, you will learn how to configure the log level and format.+Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level or for more specific categories such as `org.hibernate` or `org.keycloak`. This guide describes how to configure the log level and the log format.  == Log level-The available log levels are listed in the following Table:+The following table describes the available log levels.  |==== |Level|Description-|FATAL|critical failures / complete inability to serve requests of any kind.-|ERROR|significant error or problem leading to the inability to process requests.-|WARN|A non-critical error or problem that may not require immediate correction.+|FATAL|Critical failures with complete inability to serve any kind of request.+|ERROR|A significant error or problem leading to the inability to process requests.+|WARN|A non-critical error or problem that might not require immediate correction. |INFO|Keycloak lifecycle events or important information. Low frequency.-|DEBUG|More detailed information for debugging purposes, including e.g. database logs. Higher frequency.+|DEBUG|More detailed information for debugging purposes, such as database logs. Higher frequency. |TRACE|Most detailed debugging information. Very high frequency.-|ALL|Special level for all log messages-|OFF|Special level to turn logging off entirely (not recommended)+|ALL|Special level for all log messages.+|OFF|Special level to turn logging off entirely (not recommended). |==== -=== Configuring the root log level-The root loggers log level can be set using the following command:+=== Root log level configuration+When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used. -<@kc.start parameters=""--log-level=<root-level>""/>+You set the root log level by using the following command: -using one of the levels mentioned in the table above. When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used.+<@kc.start parameters=""--log-level=<root-level>""/> -Setting the log level is case-insensitive, so you could either use for example `DEBUG` or `debug`.+Use these guidelines for this command: -When you accidentally set the log level twice, for example when you invoke `--log-level=info,...,debug,...` the last occurence in the list will be used as the log level, so for the example the root logger would be set to `DEBUG`.+* For `_<root-level>_`, supply a level defined in the preceding table.+* The log level is case-insensitive. For example, you could either use `DEBUG` or `debug`.+* If you were to accidentally set the log level twice, the last occurrence in the list becomes the log level. For example, if you included the syntax `--log-level=info,...,DEBUG,...`, the root logger would be `DEBUG`. -=== Configuring category-specific log levels-It is possible to set a different log level for specific areas in Keycloak. To enable category-specific logging, provide a comma-separated list containing the categories you want another log level than for the root category to the `--log-level` configuration:+=== Category-specific log level configuration+You can set different log levels for specific areas in Keycloak. Use this command to provide a comma-separated list of categories for which you want a different log level:  <@kc.start parameters=""--log-level=<root-level>,<org.category1>:<org.category1-level>""/> -A configuration that applies to a category also applies to all sub-categories of that category, unless a more specific matching sub-category configuration is provided in the list.+A configuration that applies to a category also applies to its sub-categories unless you include a more specific matching sub-category.  .Example <@kc.start parameters=""--log-level=INFO,org.hibernate:debug,org.hibernate.hql.internal.ast:info""/>-The example above sets the root log level for all loggers to INFO, and the hibernate log level in general to debug. But as we don't want SQL abstract syntax trees to make the log output verbose, we set the more specific sub category `org.hibernate.hql.internal.ast` to info, so the SQL abstract syntax trees, which would be shown at `debug` level, don't show up anymore. -== Configuring the logging format-Keycloak uses a pattern-based logging formatter that generates human-readable text logs by default.+This example sets the following log levels: -The logging format template for these lines can be applied at the root level.+* Root log level for all loggers is set to INFO.+* The hibernate log level in general is set to debug.+* To keep SQL abstract syntax trees from creating verbose log output, the specific subcategory `org.hibernate.hql.internal.ast` is set to info. As a result, the SQL abstract syntax trees are omitted instead of appearing at the `debug` level. -The default format template is:+== Logging format configuration+Keycloak uses a pattern-based logging formatter that generates human-readable text logs. The logging format template for these lines can be applied at the root level. The default format template is:  * `%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n` -The format string supports the following symbols:+The format string supports the symbols in the following table:  |==== |Symbol|Summary|Description |%%|%|Renders a simple % character. |%c|Category|Renders the log category name. |%d{xxx}|Date|Renders a date with the given date format string.String syntax defined by `java.text.SimpleDateFormat`-|%e|Exception|Renders the thrown exception, if any.+|%e|Exception|Renders any thrown exception that exists.","It does not necessarily throw every exception, but only the explicit exception thrown, so perhaps just stick with the suggestion here?",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10365,813652049,2022-02-24T08:33:15Z,docs/guides/src/main/server/logging.adoc,"@@ -7,90 +7,100 @@ title=""Configuring logging"" summary=""Learn how to configure Logging"" includedOptions=""log-*""> -Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level, or for more specific categories like `org.hibernate` or `org.keycloak`. In this guide, you will learn how to configure the log level and format.+Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level or for more specific categories such as `org.hibernate` or `org.keycloak`. This guide describes how to configure the log level and the log format.  == Log level-The available log levels are listed in the following Table:+The following table describes the available log levels.  |==== |Level|Description-|FATAL|critical failures / complete inability to serve requests of any kind.-|ERROR|significant error or problem leading to the inability to process requests.-|WARN|A non-critical error or problem that may not require immediate correction.+|FATAL|Critical failures with complete inability to serve any kind of request.+|ERROR|A significant error or problem leading to the inability to process requests.+|WARN|A non-critical error or problem that might not require immediate correction. |INFO|Keycloak lifecycle events or important information. Low frequency.-|DEBUG|More detailed information for debugging purposes, including e.g. database logs. Higher frequency.+|DEBUG|More detailed information for debugging purposes, such as database logs. Higher frequency. |TRACE|Most detailed debugging information. Very high frequency.-|ALL|Special level for all log messages-|OFF|Special level to turn logging off entirely (not recommended)+|ALL|Special level for all log messages.+|OFF|Special level to turn logging off entirely (not recommended). |==== -=== Configuring the root log level-The root loggers log level can be set using the following command:+=== Root log level configuration+When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used. -<@kc.start parameters=""--log-level=<root-level>""/>+You set the root log level by using the following command: -using one of the levels mentioned in the table above. When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used.+<@kc.start parameters=""--log-level=<root-level>""/> -Setting the log level is case-insensitive, so you could either use for example `DEBUG` or `debug`.+Use these guidelines for this command: -When you accidentally set the log level twice, for example when you invoke `--log-level=info,...,debug,...` the last occurence in the list will be used as the log level, so for the example the root logger would be set to `DEBUG`.+* For `_<root-level>_`, supply a level defined in the preceding table.+* The log level is case-insensitive. For example, you could either use `DEBUG` or `debug`.+* If you were to accidentally set the log level twice, the last occurrence in the list becomes the log level. For example, if you included the syntax `--log-level=info,...,DEBUG,...`, the root logger would be `DEBUG`. -=== Configuring category-specific log levels-It is possible to set a different log level for specific areas in Keycloak. To enable category-specific logging, provide a comma-separated list containing the categories you want another log level than for the root category to the `--log-level` configuration:+=== Category-specific log level configuration+You can set different log levels for specific areas in Keycloak. Use this command to provide a comma-separated list of categories for which you want a different log level:  <@kc.start parameters=""--log-level=<root-level>,<org.category1>:<org.category1-level>""/> -A configuration that applies to a category also applies to all sub-categories of that category, unless a more specific matching sub-category configuration is provided in the list.+A configuration that applies to a category also applies to its sub-categories unless you include a more specific matching sub-category.  .Example <@kc.start parameters=""--log-level=INFO,org.hibernate:debug,org.hibernate.hql.internal.ast:info""/>-The example above sets the root log level for all loggers to INFO, and the hibernate log level in general to debug. But as we don't want SQL abstract syntax trees to make the log output verbose, we set the more specific sub category `org.hibernate.hql.internal.ast` to info, so the SQL abstract syntax trees, which would be shown at `debug` level, don't show up anymore. -== Configuring the logging format-Keycloak uses a pattern-based logging formatter that generates human-readable text logs by default.+This example sets the following log levels: -The logging format template for these lines can be applied at the root level.+* Root log level for all loggers is set to INFO.+* The hibernate log level in general is set to debug.+* To keep SQL abstract syntax trees from creating verbose log output, the specific subcategory `org.hibernate.hql.internal.ast` is set to info. As a result, the SQL abstract syntax trees are omitted instead of appearing at the `debug` level. -The default format template is:+== Logging format configuration+Keycloak uses a pattern-based logging formatter that generates human-readable text logs. The logging format template for these lines can be applied at the root level. The default format template is:  * `%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n` -The format string supports the following symbols:+The format string supports the symbols in the following table:  |==== |Symbol|Summary|Description |%%|%|Renders a simple % character. |%c|Category|Renders the log category name. |%d{xxx}|Date|Renders a date with the given date format string.String syntax defined by `java.text.SimpleDateFormat`-|%e|Exception|Renders the thrown exception, if any.+|%e|Exception|Renders any thrown exception that exists. |%h|Hostname|Renders the simple host name. |%H|Qualified host name|Renders the fully qualified hostname, which may be the same as the simple host name, depending on the OS configuration. |%i|Process ID|Renders the current process PID.-|%m|Full Message|Renders the log message plus exception (if any).+|%m|Full Message|Renders the log message plus any exception that exists.","```suggestion|%m|Full Message|Renders the log message and an exception, if thrown.```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10365,813653003,2022-02-24T08:34:37Z,docs/guides/src/main/server/logging.adoc,"@@ -7,90 +7,100 @@ title=""Configuring logging"" summary=""Learn how to configure Logging"" includedOptions=""log-*""> -Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level, or for more specific categories like `org.hibernate` or `org.keycloak`. In this guide, you will learn how to configure the log level and format.+Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level or for more specific categories such as `org.hibernate` or `org.keycloak`. This guide describes how to configure the log level and the log format.  == Log level-The available log levels are listed in the following Table:+The following table describes the available log levels.  |==== |Level|Description-|FATAL|critical failures / complete inability to serve requests of any kind.-|ERROR|significant error or problem leading to the inability to process requests.-|WARN|A non-critical error or problem that may not require immediate correction.+|FATAL|Critical failures with complete inability to serve any kind of request.+|ERROR|A significant error or problem leading to the inability to process requests.+|WARN|A non-critical error or problem that might not require immediate correction. |INFO|Keycloak lifecycle events or important information. Low frequency.-|DEBUG|More detailed information for debugging purposes, including e.g. database logs. Higher frequency.+|DEBUG|More detailed information for debugging purposes, such as database logs. Higher frequency. |TRACE|Most detailed debugging information. Very high frequency.-|ALL|Special level for all log messages-|OFF|Special level to turn logging off entirely (not recommended)+|ALL|Special level for all log messages.+|OFF|Special level to turn logging off entirely (not recommended). |==== -=== Configuring the root log level-The root loggers log level can be set using the following command:+=== Root log level configuration+When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used. -<@kc.start parameters=""--log-level=<root-level>""/>+You set the root log level by using the following command: -using one of the levels mentioned in the table above. When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used.+<@kc.start parameters=""--log-level=<root-level>""/> -Setting the log level is case-insensitive, so you could either use for example `DEBUG` or `debug`.+Use these guidelines for this command: -When you accidentally set the log level twice, for example when you invoke `--log-level=info,...,debug,...` the last occurence in the list will be used as the log level, so for the example the root logger would be set to `DEBUG`.+* For `_<root-level>_`, supply a level defined in the preceding table.+* The log level is case-insensitive. For example, you could either use `DEBUG` or `debug`.+* If you were to accidentally set the log level twice, the last occurrence in the list becomes the log level. For example, if you included the syntax `--log-level=info,...,DEBUG,...`, the root logger would be `DEBUG`. -=== Configuring category-specific log levels-It is possible to set a different log level for specific areas in Keycloak. To enable category-specific logging, provide a comma-separated list containing the categories you want another log level than for the root category to the `--log-level` configuration:+=== Category-specific log level configuration+You can set different log levels for specific areas in Keycloak. Use this command to provide a comma-separated list of categories for which you want a different log level:  <@kc.start parameters=""--log-level=<root-level>,<org.category1>:<org.category1-level>""/> -A configuration that applies to a category also applies to all sub-categories of that category, unless a more specific matching sub-category configuration is provided in the list.+A configuration that applies to a category also applies to its sub-categories unless you include a more specific matching sub-category.  .Example <@kc.start parameters=""--log-level=INFO,org.hibernate:debug,org.hibernate.hql.internal.ast:info""/>-The example above sets the root log level for all loggers to INFO, and the hibernate log level in general to debug. But as we don't want SQL abstract syntax trees to make the log output verbose, we set the more specific sub category `org.hibernate.hql.internal.ast` to info, so the SQL abstract syntax trees, which would be shown at `debug` level, don't show up anymore. -== Configuring the logging format-Keycloak uses a pattern-based logging formatter that generates human-readable text logs by default.+This example sets the following log levels: -The logging format template for these lines can be applied at the root level.+* Root log level for all loggers is set to INFO.+* The hibernate log level in general is set to debug.+* To keep SQL abstract syntax trees from creating verbose log output, the specific subcategory `org.hibernate.hql.internal.ast` is set to info. As a result, the SQL abstract syntax trees are omitted instead of appearing at the `debug` level. -The default format template is:+== Logging format configuration+Keycloak uses a pattern-based logging formatter that generates human-readable text logs. The logging format template for these lines can be applied at the root level. The default format template is:  * `%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n` -The format string supports the following symbols:+The format string supports the symbols in the following table:  |==== |Symbol|Summary|Description |%%|%|Renders a simple % character. |%c|Category|Renders the log category name. |%d{xxx}|Date|Renders a date with the given date format string.String syntax defined by `java.text.SimpleDateFormat`-|%e|Exception|Renders the thrown exception, if any.+|%e|Exception|Renders any thrown exception that exists. |%h|Hostname|Renders the simple host name. |%H|Qualified host name|Renders the fully qualified hostname, which may be the same as the simple host name, depending on the OS configuration. |%i|Process ID|Renders the current process PID.-|%m|Full Message|Renders the log message plus exception (if any).+|%m|Full Message|Renders the log message plus any exception that exists.","see above. ""any that exists"" is not true. One line of log contains one exception. There may be more, e.g. when you set log to trace there are actually exceptions right now. These would not be printed, but ""any...that exists"" suggests so imo.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10365,813658102,2022-02-24T08:41:20Z,docs/guides/src/main/server/logging.adoc,"@@ -7,90 +7,100 @@ title=""Configuring logging"" summary=""Learn how to configure Logging"" includedOptions=""log-*""> -Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level, or for more specific categories like `org.hibernate` or `org.keycloak`. In this guide, you will learn how to configure the log level and format.+Logging is done on a per-category basis in Keycloak. You can configure logging for the root log level or for more specific categories such as `org.hibernate` or `org.keycloak`. This guide describes how to configure the log level and the log format.  == Log level-The available log levels are listed in the following Table:+The following table describes the available log levels.  |==== |Level|Description-|FATAL|critical failures / complete inability to serve requests of any kind.-|ERROR|significant error or problem leading to the inability to process requests.-|WARN|A non-critical error or problem that may not require immediate correction.+|FATAL|Critical failures with complete inability to serve any kind of request.+|ERROR|A significant error or problem leading to the inability to process requests.+|WARN|A non-critical error or problem that might not require immediate correction. |INFO|Keycloak lifecycle events or important information. Low frequency.-|DEBUG|More detailed information for debugging purposes, including e.g. database logs. Higher frequency.+|DEBUG|More detailed information for debugging purposes, such as database logs. Higher frequency. |TRACE|Most detailed debugging information. Very high frequency.-|ALL|Special level for all log messages-|OFF|Special level to turn logging off entirely (not recommended)+|ALL|Special level for all log messages.+|OFF|Special level to turn logging off entirely (not recommended). |==== -=== Configuring the root log level-The root loggers log level can be set using the following command:+=== Root log level configuration+When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used. -<@kc.start parameters=""--log-level=<root-level>""/>+You set the root log level by using the following command: -using one of the levels mentioned in the table above. When no log level configuration exists for a more specific category logger, the enclosing category is used instead. When there is no enclosing category, the root logger level is used.+<@kc.start parameters=""--log-level=<root-level>""/> -Setting the log level is case-insensitive, so you could either use for example `DEBUG` or `debug`.+Use these guidelines for this command: -When you accidentally set the log level twice, for example when you invoke `--log-level=info,...,debug,...` the last occurence in the list will be used as the log level, so for the example the root logger would be set to `DEBUG`.+* For `_<root-level>_`, supply a level defined in the preceding table.+* The log level is case-insensitive. For example, you could either use `DEBUG` or `debug`.+* If you were to accidentally set the log level twice, the last occurrence in the list becomes the log level. For example, if you included the syntax `--log-level=info,...,DEBUG,...`, the root logger would be `DEBUG`. -=== Configuring category-specific log levels-It is possible to set a different log level for specific areas in Keycloak. To enable category-specific logging, provide a comma-separated list containing the categories you want another log level than for the root category to the `--log-level` configuration:+=== Category-specific log level configuration+You can set different log levels for specific areas in Keycloak. Use this command to provide a comma-separated list of categories for which you want a different log level:  <@kc.start parameters=""--log-level=<root-level>,<org.category1>:<org.category1-level>""/> -A configuration that applies to a category also applies to all sub-categories of that category, unless a more specific matching sub-category configuration is provided in the list.+A configuration that applies to a category also applies to its sub-categories unless you include a more specific matching sub-category.  .Example <@kc.start parameters=""--log-level=INFO,org.hibernate:debug,org.hibernate.hql.internal.ast:info""/>-The example above sets the root log level for all loggers to INFO, and the hibernate log level in general to debug. But as we don't want SQL abstract syntax trees to make the log output verbose, we set the more specific sub category `org.hibernate.hql.internal.ast` to info, so the SQL abstract syntax trees, which would be shown at `debug` level, don't show up anymore. -== Configuring the logging format-Keycloak uses a pattern-based logging formatter that generates human-readable text logs by default.+This example sets the following log levels: -The logging format template for these lines can be applied at the root level.+* Root log level for all loggers is set to INFO.+* The hibernate log level in general is set to debug.+* To keep SQL abstract syntax trees from creating verbose log output, the specific subcategory `org.hibernate.hql.internal.ast` is set to info. As a result, the SQL abstract syntax trees are omitted instead of appearing at the `debug` level. -The default format template is:+== Logging format configuration+Keycloak uses a pattern-based logging formatter that generates human-readable text logs. The logging format template for these lines can be applied at the root level. The default format template is:  * `%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n` -The format string supports the following symbols:+The format string supports the symbols in the following table:  |==== |Symbol|Summary|Description |%%|%|Renders a simple % character. |%c|Category|Renders the log category name. |%d{xxx}|Date|Renders a date with the given date format string.String syntax defined by `java.text.SimpleDateFormat`-|%e|Exception|Renders the thrown exception, if any.+|%e|Exception|Renders any thrown exception that exists. |%h|Hostname|Renders the simple host name. |%H|Qualified host name|Renders the fully qualified hostname, which may be the same as the simple host name, depending on the OS configuration. |%i|Process ID|Renders the current process PID.-|%m|Full Message|Renders the log message plus exception (if any).+|%m|Full Message|Renders the log message plus any exception that exists. |%n |Newline|Renders the platform-specific line separator string. |%N|Process name|Renders the name of the current process. |%p|Level|Renders the log level of the message. |%r|Relative time|Render the time in milliseconds since the start of the application log.-|%s|Simple message|Renders only the log message, without exception trace.+|%s|Simple message|Renders only the log message without exception trace. |%t|Thread name|Renders the thread name. |%t{id}|Thread ID|Render the thread ID.-|%z{<zone name>}|Time zone|Set the time zone of log output to <zone name>.+|%z{<zone name>}|Time zone|Sets the time zone of log output to <zone name>. |==== -=== Set the logging format-To set the logging format for a logged line, build your desired format template using the table above and run the following command:+=== Setting the logging format+To set the logging format for a logged line, perform these steps:++. Build your desired format template using the table above+. Enter the following command:++ <@kc.start parameters=""--log-format=\""\'<format>\'\""""/>-Be aware that you need to escape characters when invoking commands containing special shell characters such as `;` using the CLI, so you might want to set it in the configuration file instead.++Note that you need to escape characters when invoking commands containing special shell characters such as `;` using the CLI. Therefore, consider setting it in the configuration file instead.  .Example: Abbreviate the fully qualified category name+ <@kc.start parameters=""\""\'%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) %s%e%n\'\""""/>+ The example above abbreviates the category name, which could get rather long in some cases, to three characters by setting `[%c{3.}]` in the template instead of the default `[%c]`. -== Configuring raw quarkus logging properties-At the time of writing, the logging features of the quarkus based Keycloak are basic, yet powerful. Nevertheless, expect more to come and feel free to join the https://github.com/keycloak/keycloak/discussions/8870[discussion] at GitHub.+== Raw quarkus logging properties+At publication time for this guide, the logging features of the Quarkus-based Keycloak are basic, yet powerful. Nevertheless, expect more to come and feel free to join the https://github.com/keycloak/keycloak/discussions/8870[discussion] at GitHub. -When you need a temporary solution, e.g. for logging to a file or using syslog isntead of console, you can check out the https://github.com/keycloak/keycloak/discussions/8870[Quarkus logging guide]. It is possible to use all properties mentioned there, as long as no other than the base logging dependency is involved. For example it is possible to set the log handler to file, but not to use json output, yet, as you would need to provide another dependency for json output to work.+If you need a temporary solution, such as for logging to a file or using syslog instead of the console, you can check out the https://github.com/keycloak/keycloak/discussions/8870[Quarkus logging guide]. You might be able to use all properties mentioned there as long as no other than the base logging dependency is involved. For example, you might be able to set the log handler to file, but not to use JSON output yet. You would need to provide another dependency for JSON output to work.","```suggestionIf you need a temporary solution, such as for logging to a file or using syslog instead of the console, you can check out the https://quarkus.io/guides/logging[Quarkus logging guide]. You are able to use all properties mentioned in the guide as long as no other than the base logging dependency is involved. For example, you are able to set the log handler to file or syslog, but not to use JSON output yet. You would need to provide another dependency for JSON output to work.```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10455,814052456,2022-02-24T16:25:41Z,services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java,"@@ -168,6 +168,7 @@ public Response createResponse(UserModel.RequiredAction action) {                 page = LoginFormsPages.LOGIN_UPDATE_PASSWORD;                 break;             case VERIFY_EMAIL:+                this.attributes.put(""verifiedEmail"",user.getEmail());","One small note: When looking at the sources, I wonder that instead of `verifiedEmail`, it may be slightly better to use something like:```UpdateProfileContext userBasedContext = new UserUpdateProfileContext(realm, user);attributes.put(""user"", new ProfileBean(userCtx, formData));```And then in the FTL template, you can use maybe something like:``` <p class=""instruction"">${msg(""emailVerifyInstruction1"", user.email)}</p> ```The reason why proposing this is, that this might be useful in case that administrators want to use other informations of user in their FTL template. For example something like: ""Hello John Doe, the message was sent to your email johndoe@gmail.com""  .In other words, administrators won't be restricted to use only email as in theory, they may want to use other attributes of the user.",
91681638,stelewis-redhat,https://api.github.com/repos/keycloak/keycloak/pulls/8730,815275417,2022-02-26T06:18:48Z,services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java,"@@ -180,29 +182,41 @@ public CredentialTypeMetadata getMetadata() {                     .build(session);             CredentialTypeMetadata metadata = credentialProvider.getCredentialTypeMetadata(ctx); -            List<CredentialRepresentation> userCredentialModels = null;+            List<CredentialMetadataRepresentation> userCredentialMetadataModels = null;+             if (includeUserCredentials) {-                userCredentialModels = models.stream()+                List<CredentialModel> modelsOfType = models.stream()                         .filter(credentialModel -> credentialProvider.getType().equals(credentialModel.getType()))-                        .map(ModelToRepresentation::toRepresentation)                         .collect(Collectors.toList()); -                if (userCredentialModels.isEmpty() &&++                List<CredentialMetadata> credentialMetadataList = modelsOfType.stream()+                        .map(m -> {+                            return credentialProvider.getCredentialMetadata(+                                    credentialProvider.getCredentialFromModel(m), metadata","I don't love having to go get the data again here, but I think that's necessary, at least with what I understand right now.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10373,815802344,2022-02-28T11:28:22Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/LdapRoleMapKeycloakTransaction.java,"@@ -0,0 +1,509 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelException;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.role.MapRoleEntity;++import org.keycloak.models.map.storage.MapKeycloakTransaction;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.MapFieldPredicates;+import org.keycloak.models.map.storage.chm.MapModelCriteriaBuilder;+import org.keycloak.models.map.storage.ldap.LdapConfig;+import org.keycloak.models.map.storage.ldap.LdapMapKeycloakTransaction;+import org.keycloak.models.map.storage.ldap.LdapRoleMapperConfig;+import org.keycloak.models.map.storage.ldap.condition.CustomLDAPFilter;+import org.keycloak.models.map.storage.ldap.condition.EqualCondition;+import org.keycloak.models.map.storage.ldap.condition.NoopCondition;+import org.keycloak.models.map.storage.ldap.role.entity.LdapRoleEntity;+import org.keycloak.storage.ldap.idm.model.LDAPDn;+import org.keycloak.storage.ldap.idm.model.LDAPObject;+import org.keycloak.storage.ldap.idm.query.Condition;+import org.keycloak.storage.ldap.idm.query.EscapeStrategy;+import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;+import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;++import javax.naming.NamingException;+import java.util.Arrays;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;+import java.util.stream.Collectors;+import java.util.stream.Stream;++public class LdapRoleMapKeycloakTransaction extends LdapMapKeycloakTransaction<LdapRoleEntity, MapRoleEntity, RoleModel> {++    private final KeycloakSession session;+    private final Config.Scope config;+    private final StringKeyConvertor<String> keyConverter = new StringKeyConvertor.StringKey();+    private final List<String> deletedKeys = new LinkedList<>();++    /* at the moment there is no way to figure out the realm when an entity is read by ID.+       For now, memorize the realm for a previous search.+     */+    @Deprecated+    private static String realm;++    public LdapRoleMapKeycloakTransaction(KeycloakSession session, Config.Scope config, MapKeycloakTransaction<MapRoleEntity, RoleModel> delegate) {+        super(session, config);+        this.session = session;+        this.config = config;+    }++    // interface matching the constructor of this class+    public interface LdapRoleMapKeycloakTransactionFunction<A, B, C, R> {+        R apply(A a, B b, C c);+    }++    // TODO: entries might get stale if a DN of an entry changes due to changes in the entity in the same transaction+    private final Map<String, String> dns = new HashMap<>();++    public String readIdByDn(String realmId, String dn) {+        // TODO: this might not be necessary if the LDAP server would support an extended OID+        // https://ldapwiki.com/wiki/LDAP_SERVER_EXTENDED_DN_OID++        String id = dns.get(dn);+        if (id == null) {+            for (Map.Entry<EntityKey, LdapRoleEntity> entry : entities.entrySet()) {+                if (entry.getValue().getLdapObject().getUuid().equals(dn)) {+                    id = entry.getValue().getLdapObject().getUuid();+                    break;+                }+            }+        }+        if (id != null) {+            return id;+        }++        LdapConfig ldapConfig = new LdapConfig(config, realmId);++        LDAPQuery ldapQuery = new LDAPQuery(null);+        LdapRoleMapperConfig roleMapperConfig = new LdapRoleMapperConfig(config, realmId, false, null);++        // For now, use same search scope, which is configured ""globally"" and used for user's search.+        ldapQuery.setSearchScope(ldapConfig.getSearchScope());+        ldapQuery.setSearchDn(config.get(""roles.dn.common""));++        // TODO: read them properly to be able to store them in the transaction so they are cached?!+        Collection<String> roleObjectClasses = ldapConfig.getRoleObjectClasses();+        ldapQuery.addObjectClasses(roleObjectClasses);++        String rolesRdnAttr = roleMapperConfig.getRoleNameLdapAttribute();++        String customFilter = roleMapperConfig.getCustomLdapFilter();+        if (customFilter != null && customFilter.trim().length() > 0) {+            Condition customFilterCondition = new CustomLDAPFilter(customFilter);+            ldapQuery.addWhereCondition(customFilterCondition);+        }++        ldapQuery.addReturningLdapAttribute(rolesRdnAttr);++        LDAPIdentityStore identityStore = new LDAPIdentityStore(session, ldapConfig);++        LDAPDn.RDN rdn = LDAPDn.fromString(dn).getFirstRdn();+        String key = rdn.getAllKeys().get(0);+        String value = rdn.getAttrValue(key);+        ldapQuery.addWhereCondition(new EqualCondition(key, value, EscapeStrategy.DEFAULT));++        List<LDAPObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+        if (ldapObjects.size() == 1) {+            dns.put(dn, ldapObjects.get(0).getUuid());+            return ldapObjects.get(0).getUuid();+        }+        return null;+    }++    private MapModelCriteriaBuilder<String, LdapRoleEntity, RoleModel> createCriteriaBuilderMap() {+        return new MapModelCriteriaBuilder<>(keyConverter, MapFieldPredicates.getPredicates(RoleModel.class));+    }++    @Override+    public MapRoleEntity create(MapRoleEntity value) {+        this.realm = value.getRealmId();+        LdapRoleMapperConfig roleMapperConfig = new LdapRoleMapperConfig(config, value.getRealmId(), value.getClientId() != null, value.getClientId());+        LdapConfig ldapConfig = new LdapConfig(config, value.getRealmId());+        LDAPIdentityStore identityStore = new LDAPIdentityStore(session, ldapConfig);++        DeepCloner CLONER = new DeepCloner.Builder()+                .constructor(MapRoleEntity.class, cloner -> new LdapRoleEntity(cloner, roleMapperConfig, this))+                .build();++        LdapRoleEntity mapped = (LdapRoleEntity) CLONER.from(value);+        // LDAP should never use the UUID provided by the caller, as UUID is generated+        mapped.setId(null);+        // Roles as groups need to have at least one member on most directories. Add ourselves as a member as a dummy.+        if (mapped.getLdapObject().getUuid() == null && mapped.getLdapObject().getAttributeAsSet(roleMapperConfig.getMembershipLdapAttribute()) == null) {+            // insert our own name as dummy member of this role to avoid a schema conflict in LDAP+            mapped.getLdapObject().setAttribute(roleMapperConfig.getMembershipLdapAttribute(), Stream.of(mapped.getLdapObject().getDn().toString()).collect(Collectors.toSet()));+        }++        try {+            // in order to get the ID, we need to write it to LDAP+            identityStore.add(mapped.getLdapObject());+        } catch (ModelException ex) {+            if (value.isClientRole() && ex.getCause() instanceof NamingException) {+                // the client hasn't been created, therefore adding it here+                LDAPObject client = new LDAPObject();+                client.setObjectClasses(Arrays.asList(""top"", ""organizationalUnit""));+                client.setRdnAttributeName(""ou"");+                client.setDn(LDAPDn.fromString(roleMapperConfig.getRolesDn()));+                client.setSingleAttribute(""ou"", mapped.getClientId());+                identityStore.add(client);++                tasksOnRollback.add(new DeleteOperation(mapped) {+                    @Override+                    public void execute() {+                        identityStore.remove(client);+                    }+                });++                // retry creation of client role+                identityStore.add(mapped.getLdapObject());+            }+        }++        entities.put(new EntityKey(mapped.getRealmId(), mapped.getId()), mapped);++        tasksOnRollback.add(new DeleteOperation(mapped) {+            @Override+            public void execute() {+                identityStore.remove(mapped.getLdapObject());+                entities.remove(new EntityKey(mapped.getRealmId(), mapped.getId()));+            }+        });++        return mapped;+    }++    @Override+    public boolean delete(String key) {+        LdapRoleEntity read = read(key);+        if (read == null) {+            throw new ModelException(""unable to read entity with key "" + key);+        }+        deletedKeys.add(key);+        tasksOnCommit.add(new DeleteOperation(read) {+            @Override+            public void execute() {+                LdapConfig ldapConfig = new LdapConfig(config, entity.getRealmId());+                LDAPIdentityStore identityStore = new LDAPIdentityStore(session, ldapConfig);+                identityStore.remove(entity.getLdapObject());+            }+        });+        return true;+    }++    @Override+    public LdapRoleEntity read(String key) {+        // for now, only support one realm, don't make realm part of the key+        // https://github.com/keycloak/keycloak/discussions/10045+        String realm = this.realm;+        @SuppressWarnings(""UnnecessaryLocalVariable"") String id = key;++        if (deletedKeys.contains(key)) {+            return null;+        }++        // reuse an existing live entity+        LdapRoleEntity val = entities.get(new EntityKey(realm, id));++        if (val == null) {+            LdapConfig ldapConfig = new LdapConfig(config, realm);++            // try to look it up as a realm role+            val = lookupEntityById(realm, id, ldapConfig, null);++            if (val == null) {+                // try to look it up using a client role+                // currently the API doesn't allow to get a list of all keys, therefore we need a separate attribute+                // also, getArray is broken as it doesn't look up the parent's values if an entry is empty+                String clientsToSearch = config.scope(""clients"").get(""clientsToSearch"");+                if (clientsToSearch != null) {+                    String[] clientIds = clientsToSearch.split(""\\s*,\\s*"");+                    for (String clientId : clientIds) {+                        val = lookupEntityById(realm, id, ldapConfig, clientId);+                        if (val != null) {+                            break;+                        }+                    }+                }+            }++            if (val == null) {+                // try to find out the client ID+                LDAPQuery ldapQuery = new LDAPQuery(null);++                // For now, use same search scope, which is configured ""globally"" and used for user's search.+                ldapQuery.setSearchScope(ldapConfig.getSearchScope());++                // remove prefix with placeholder to allow for a broad search+                String sdn = config.scope(""clients"").get(""roles.dn"");+                ldapQuery.setSearchDn(sdn.replaceAll("".*\\{0},"", """"));++                ldapQuery.addWhereCondition(new EqualCondition(ldapConfig.getUuidLDAPAttributeName(), id, EscapeStrategy.DEFAULT));++                LDAPIdentityStore identityStore = new LDAPIdentityStore(session, ldapConfig);++                List<LDAPObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+                if (ldapObjects.size() == 1) {+                    // as the client ID is now known, search again with the specific configuration+                    String clientId = ldapObjects.get(0).getDn().getParentDn().getFirstRdn().getAttrValue(""ou"");+                    // TODO: re-use the ldapObject to create the entity instead of querying again+                    val = lookupEntityById(realm, id, ldapConfig, clientId);+                }+            }++            if (val != null) {+                entities.put(new EntityKey(val.getRealmId(), val.getId()), val);+            }++        }+        return val;+    }++    private LdapRoleEntity lookupEntityById(String realm, String id, LdapConfig ldapConfig, String clientId) {+        LdapRoleMapperConfig roleMapperConfig = new LdapRoleMapperConfig(config, realm, clientId != null, clientId);","simplified, doesn't apply any more. Now only realmId/isClientRole/clientId are extracted from AND conditions where they are always true.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816092760,2022-02-28T17:16:58Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -146,9 +151,206 @@ private void addInitContainer(Deployment baseDeployment, List<String> extensions         baseDeployment.getSpec().getTemplate().getSpec().setInitContainers(Collections.singletonList(initContainer));     } +    public void validatePodTemplate(KeycloakStatusBuilder status) {+        if (keycloakCR.getSpec() == null ||+                keycloakCR.getSpec().getUnsupported() == null ||+                keycloakCR.getSpec().getUnsupported().getPodTemplate() == null) {+            return;+        }+        var overlayTemplate = this.keycloakCR.getSpec().getUnsupported().getPodTemplate();++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getName() != null) {+            status.addWarningMessage(""The name of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getNamespace() != null) {+            status.addWarningMessage(""The namespace of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getSpec() != null &&+            overlayTemplate.getSpec().getContainers() != null &&+            overlayTemplate.getSpec().getContainers().get(0) != null &&+            overlayTemplate.getSpec().getContainers().get(0).getName() != null) {+            status.addWarningMessage(""The name of the keycloak container cannot be modified"");+        }+    }++    private <T, V> void mergeMaps(Map<T, V> map1, Map<T, V> map2, Consumer<Map<T, V>> consumer) {+        var map = new HashMap<T, V>();+        Optional.ofNullable(map1).ifPresent(e -> map.putAll(e));+        Optional.ofNullable(map2).ifPresent(e -> map.putAll(e));+        consumer.accept(map);+    }++    private <T> void mergeLists(List<T> list1, List<T> list2, Consumer<List<T>> consumer) {+        var list = new ArrayList<T>();+        Optional.ofNullable(list1).ifPresent(e -> list.addAll(e));+        Optional.ofNullable(list2).ifPresent(e -> list.addAll(e));+        consumer.accept(list);+    }++    private <T> void mergeField(T value, Consumer<T> consumer) {+        Optional.ofNullable(value).ifPresent(v -> {+            if (v != null && (!(v instanceof List) || (v instanceof List && ((List<?>) v).size() > 0))) {",Do we really care about lists? Are there any implications if we set an empty list? We don't care in `mergeLists`.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816101342,2022-02-28T17:27:28Z,operator/src/test/java/org/keycloak/operator/PodTemplateE2EIT.java,"@@ -0,0 +1,175 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.PodTemplateSpecBuilder;+import io.fabric8.kubernetes.client.utils.Serialization;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import static java.util.concurrent.TimeUnit.MINUTES;+import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition.HAS_ERRORS;++@QuarkusTest+public class PodTemplateE2EIT extends ClusterOperatorTest {++    private Keycloak getEmptyPodTemplateKeycloak() {+        return Serialization.unmarshal(getClass().getResourceAsStream(""/empty-podtemplate-keycloak.yml""), Keycloak.class);+    }++    @Test+    public void testPodTemplateIsMerged() {+        // Arrange+        var keycloakWithPodTemplate = k8sclient+                .load(getClass().getResourceAsStream(""/correct-podtemplate-keycloak.yml""));++        // Act+        keycloakWithPodTemplate.createOrReplace();++        // Assert+        Awaitility+                .await()+                .ignoreExceptions()+                .atMost(3, MINUTES).untilAsserted(() -> {+            Log.info(""Getting logs from Keycloak"");++            var keycloakPod = k8sclient+                    .pods()+                    .inNamespace(namespace)+                    .withLabel(""app"", ""keycloak"")+                    .list()+                    .getItems()+                    .get(0);++            var logs = k8sclient+                    .pods()+                    .inNamespace(namespace)+                    .withName(keycloakPod.getMetadata().getName())+                    .getLog();++            Log.info(""Full logs are:\n"" + logs);+            assertThat(logs).contains(""Hello World"");+            assertThat(keycloakPod.getMetadata().getLabels().get(""foo"")).isEqualTo(""bar"");+        });+    }++    @Test+    public void testPodTemplateIncorrectName() {+        // Arrange+        var plainKc = getEmptyPodTemplateKeycloak();+        var podTemplate = new PodTemplateSpecBuilder()+                .withNewMetadata()+                .withName(""foo"")+                .endMetadata()+                .build();+        plainKc.getSpec().getUnsupported().setPodTeplate(podTemplate);++        // Act+        k8sclient.resource(plainKc).createOrReplace();++        // Assert+        Log.info(""Getting status of Keycloak"");+        Awaitility+                .await()+                .ignoreExceptions()+                .atMost(3, MINUTES).untilAsserted(() -> {+                    var message = k8sclient+                            .resources(Keycloak.class)+                            .inNamespace(namespace)+                            .withName(""example-podtemplate"")+                            .get()+                            .getStatus()+                            .getConditions()+                            .stream()+                            .filter(c -> c.getType().equals(HAS_ERRORS))+                            .findFirst()+                            .get()+                            .getMessage();++                    Log.info(""Resource error message is:"" + message);+                    assertThat(message).contains(""cannot be modified"");","Maybe we could create a re-usable util method for this, similar to `assertKeycloakStatusCondition`? This might be useful for other tests too.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816130664,2022-02-28T18:06:56Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -146,9 +151,206 @@ private void addInitContainer(Deployment baseDeployment, List<String> extensions         baseDeployment.getSpec().getTemplate().getSpec().setInitContainers(Collections.singletonList(initContainer));     } +    public void validatePodTemplate(KeycloakStatusBuilder status) {+        if (keycloakCR.getSpec() == null ||+                keycloakCR.getSpec().getUnsupported() == null ||+                keycloakCR.getSpec().getUnsupported().getPodTemplate() == null) {+            return;+        }+        var overlayTemplate = this.keycloakCR.getSpec().getUnsupported().getPodTemplate();++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getName() != null) {+            status.addWarningMessage(""The name of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getNamespace() != null) {+            status.addWarningMessage(""The namespace of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getSpec() != null &&+            overlayTemplate.getSpec().getContainers() != null &&+            overlayTemplate.getSpec().getContainers().get(0) != null &&+            overlayTemplate.getSpec().getContainers().get(0).getName() != null) {+            status.addWarningMessage(""The name of the keycloak container cannot be modified"");+        }+    }++    private <T, V> void mergeMaps(Map<T, V> map1, Map<T, V> map2, Consumer<Map<T, V>> consumer) {+        var map = new HashMap<T, V>();+        Optional.ofNullable(map1).ifPresent(e -> map.putAll(e));+        Optional.ofNullable(map2).ifPresent(e -> map.putAll(e));","Let's remember to discuss this point offline.I do believe that this is perfectly idiomatic Java 11 code and I don't find it hard to read at all.On the contrary keeping `null` checks around should be considered bad practice.Over-engineering is about using higher level and un-needed abstractions, not for using Standard library constructs for their intended purpose.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816131912,2022-02-28T18:08:50Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -146,9 +151,206 @@ private void addInitContainer(Deployment baseDeployment, List<String> extensions         baseDeployment.getSpec().getTemplate().getSpec().setInitContainers(Collections.singletonList(initContainer));     } +    public void validatePodTemplate(KeycloakStatusBuilder status) {+        if (keycloakCR.getSpec() == null ||+                keycloakCR.getSpec().getUnsupported() == null ||+                keycloakCR.getSpec().getUnsupported().getPodTemplate() == null) {+            return;+        }+        var overlayTemplate = this.keycloakCR.getSpec().getUnsupported().getPodTemplate();++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getName() != null) {+            status.addWarningMessage(""The name of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getNamespace() != null) {+            status.addWarningMessage(""The namespace of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getSpec() != null &&+            overlayTemplate.getSpec().getContainers() != null &&+            overlayTemplate.getSpec().getContainers().get(0) != null &&+            overlayTemplate.getSpec().getContainers().get(0).getName() != null) {+            status.addWarningMessage(""The name of the keycloak container cannot be modified"");+        }+    }++    private <T, V> void mergeMaps(Map<T, V> map1, Map<T, V> map2, Consumer<Map<T, V>> consumer) {+        var map = new HashMap<T, V>();+        Optional.ofNullable(map1).ifPresent(e -> map.putAll(e));+        Optional.ofNullable(map2).ifPresent(e -> map.putAll(e));+        consumer.accept(map);+    }++    private <T> void mergeLists(List<T> list1, List<T> list2, Consumer<List<T>> consumer) {+        var list = new ArrayList<T>();+        Optional.ofNullable(list1).ifPresent(e -> list.addAll(e));+        Optional.ofNullable(list2).ifPresent(e -> list.addAll(e));+        consumer.accept(list);+    }++    private <T> void mergeField(T value, Consumer<T> consumer) {+        Optional.ofNullable(value).ifPresent(v -> {+            if (v != null && (!(v instanceof List) || (v instanceof List && ((List<?>) v).size() > 0))) {","Yes, in this case we do, for correctly merging fields like `command` or `args` using as logic:if it's defined in `podTemplate` should override the entire list (as opposed to merging it).",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816136247,2022-02-28T18:15:06Z,operator/src/test/java/org/keycloak/operator/PodTemplateTest.java,"@@ -0,0 +1,224 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.IntOrString;+import io.fabric8.kubernetes.api.model.PodTemplateSpec;+import io.fabric8.kubernetes.api.model.PodTemplateSpecBuilder;+import io.fabric8.kubernetes.api.model.ProbeBuilder;+import io.fabric8.kubernetes.api.model.apps.Deployment;+import io.quarkus.test.junit.QuarkusTest;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.KeycloakDeployment;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakSpec;+import org.keycloak.operator.v2alpha1.crds.keycloakspec.Unsupported;++import java.net.URL;++import static org.junit.jupiter.api.Assertions.assertEquals;+import static org.junit.jupiter.api.Assertions.assertTrue;++@QuarkusTest+public class PodTemplateTest {++    Deployment getDeployment(PodTemplateSpec podTemplate) {+        var config = new Config(){+            @Override+            public Keycloak keycloak() {+                return new Keycloak() {+                    @Override+                    public String image() {+                        return ""dummy-image"";+                    }+                    @Override+                    public String imagePullPolicy() {+                        return ""Never"";+                    }+                    @Override+                    public String initContainerImage() { return ""quay.io/keycloak/keycloak-init-container:legacy""; }+                    @Override+                    public String initContainerImagePullPolicy() { return ""Always""; }+                };+            }+        };+        var kc = new Keycloak();+        var spec = new KeycloakSpec();+        spec.setUnsupported(new Unsupported(podTemplate));+        kc.setSpec(spec);+        var deployment = new KeycloakDeployment(null, config, kc, new Deployment());+        return (Deployment) deployment.getReconciledResource().get();+    }++    @Test+    void testEmpty() {","Using access modifiers in tests is useless (even more in a module that will not be published as a `jar`), @vmuzikar can I read about this convention anywhere as it doesn't look to be a shared pattern in the [Keycloak codebase](https://github.com/keycloak/keycloak/blob/main/quarkus/tests/integration/src/test/java/org/keycloak/it/cli/HelpCommandTest.java)? Or. am I missing any reasoning?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816152965,2022-02-28T18:38:12Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -146,9 +151,206 @@ private void addInitContainer(Deployment baseDeployment, List<String> extensions         baseDeployment.getSpec().getTemplate().getSpec().setInitContainers(Collections.singletonList(initContainer));     } +    public void validatePodTemplate(KeycloakStatusBuilder status) {"," - `image` -> is a top level feature and is not overridden by the `podTemplate` but added to the validation - `replicas` -> is a property of the ""Deployment""Am I missing any other field?Do you want to emit a warning even for fields that are appropriately merged? This would become hard to maintain for no big UX advantage I believe. ",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816155531,2022-02-28T18:40:58Z,operator/src/test/java/org/keycloak/operator/PodTemplateE2EIT.java,"@@ -0,0 +1,175 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.PodTemplateSpecBuilder;+import io.fabric8.kubernetes.client.utils.Serialization;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.AfterEach;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import static java.util.concurrent.TimeUnit.MINUTES;+import static org.assertj.core.api.Assertions.assertThat;+import static org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition.HAS_ERRORS;++@QuarkusTest+public class PodTemplateE2EIT extends ClusterOperatorTest {++    private Keycloak getEmptyPodTemplateKeycloak() {+        return Serialization.unmarshal(getClass().getResourceAsStream(""/empty-podtemplate-keycloak.yml""), Keycloak.class);+    }++    @Test+    public void testPodTemplateIsMerged() {+        // Arrange+        var keycloakWithPodTemplate = k8sclient+                .load(getClass().getResourceAsStream(""/correct-podtemplate-keycloak.yml""));++        // Act+        keycloakWithPodTemplate.createOrReplace();++        // Assert+        Awaitility+                .await()+                .ignoreExceptions()+                .atMost(3, MINUTES).untilAsserted(() -> {+            Log.info(""Getting logs from Keycloak"");++            var keycloakPod = k8sclient+                    .pods()+                    .inNamespace(namespace)+                    .withLabel(""app"", ""keycloak"")+                    .list()+                    .getItems()+                    .get(0);++            var logs = k8sclient+                    .pods()+                    .inNamespace(namespace)+                    .withName(keycloakPod.getMetadata().getName())+                    .getLog();++            Log.info(""Full logs are:\n"" + logs);+            assertThat(logs).contains(""Hello World"");+            assertThat(keycloakPod.getMetadata().getLabels().get(""foo"")).isEqualTo(""bar"");+        });+    }++    @Test+    public void testPodTemplateIncorrectName() {+        // Arrange+        var plainKc = getEmptyPodTemplateKeycloak();+        var podTemplate = new PodTemplateSpecBuilder()+                .withNewMetadata()+                .withName(""foo"")+                .endMetadata()+                .build();+        plainKc.getSpec().getUnsupported().setPodTeplate(podTemplate);++        // Act+        k8sclient.resource(plainKc).createOrReplace();++        // Assert+        Log.info(""Getting status of Keycloak"");+        Awaitility+                .await()+                .ignoreExceptions()+                .atMost(3, MINUTES).untilAsserted(() -> {+                    var message = k8sclient+                            .resources(Keycloak.class)+                            .inNamespace(namespace)+                            .withName(""example-podtemplate"")+                            .get()+                            .getStatus()+                            .getConditions()+                            .stream()+                            .filter(c -> c.getType().equals(HAS_ERRORS))+                            .findFirst()+                            .get()+                            .getMessage();++                    Log.info(""Resource error message is:"" + message);+                    assertThat(message).contains(""cannot be modified"");",changed `assertKeycloakStatusCondition` to return the message of the matched condition.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816617644,2022-03-01T09:58:37Z,operator/src/test/java/org/keycloak/operator/utils/CRAssert.java,"@@ -25,8 +25,12 @@  * @author Vaclav Muzikar <vmuzikar@redhat.com>  */ public final class CRAssert {-    public static void assertKeycloakStatusCondition(Keycloak kc, String condition, boolean status) {-        assertThat(kc.getStatus().getConditions().stream()-                .anyMatch(c -> c.getType().equals(condition) && c.getStatus() == status)).isTrue();+    public static String assertKeycloakStatusCondition(Keycloak kc, String condition, boolean status) {","I don't think this is how asserts should work returning a value that needs to be asserted later.Maybe we could introduce a new assert, something like `assertKeycloakStatusCondition(Keycloak kc, String condition, boolean status, String containsMessage)`. WDYT?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816629277,2022-03-01T10:13:18Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -146,9 +151,206 @@ private void addInitContainer(Deployment baseDeployment, List<String> extensions         baseDeployment.getSpec().getTemplate().getSpec().setInitContainers(Collections.singletonList(initContainer));     } +    public void validatePodTemplate(KeycloakStatusBuilder status) {+        if (keycloakCR.getSpec() == null ||+                keycloakCR.getSpec().getUnsupported() == null ||+                keycloakCR.getSpec().getUnsupported().getPodTemplate() == null) {+            return;+        }+        var overlayTemplate = this.keycloakCR.getSpec().getUnsupported().getPodTemplate();++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getName() != null) {+            status.addWarningMessage(""The name of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getNamespace() != null) {+            status.addWarningMessage(""The namespace of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getSpec() != null &&+            overlayTemplate.getSpec().getContainers() != null &&+            overlayTemplate.getSpec().getContainers().get(0) != null &&+            overlayTemplate.getSpec().getContainers().get(0).getName() != null) {+            status.addWarningMessage(""The name of the keycloak container cannot be modified"");+        }+    }++    private <T, V> void mergeMaps(Map<T, V> map1, Map<T, V> map2, Consumer<Map<T, V>> consumer) {+        var map = new HashMap<T, V>();+        Optional.ofNullable(map1).ifPresent(e -> map.putAll(e));+        Optional.ofNullable(map2).ifPresent(e -> map.putAll(e));","Per my understanding, over-engineering is a [synonym for unnecessarily complicated](https://www.collinsdictionary.com/dictionary/english/over-engineered). Yes, this is truly a Standard library construct and it certainly has its place when e.g. designing contracts. And yes, relying on `null` checks in contracts is considered a bad practice  I agree.However, in this specific case we are really over-using it. We're not designing a contract here. We're replacing a super simple `if` with a more complex structure with lambda, which I see zero benefit in. It almost feels like we're using shiny new-ish features just for the sake of using it. As I said, no big deal here. But I'd like to avoid over-engineering/over-complicating (however you want to call it) stuff in future PRs.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816637252,2022-03-01T10:23:31Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -146,9 +151,213 @@ private void addInitContainer(Deployment baseDeployment, List<String> extensions         baseDeployment.getSpec().getTemplate().getSpec().setInitContainers(Collections.singletonList(initContainer));     } +    public void validatePodTemplate(KeycloakStatusBuilder status) {+        if (keycloakCR.getSpec() == null ||+                keycloakCR.getSpec().getUnsupported() == null ||+                keycloakCR.getSpec().getUnsupported().getPodTemplate() == null) {+            return;+        }+        var overlayTemplate = this.keycloakCR.getSpec().getUnsupported().getPodTemplate();++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getName() != null) {+            status.addWarningMessage(""The name of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getNamespace() != null) {+            status.addWarningMessage(""The namespace of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getSpec() != null &&+            overlayTemplate.getSpec().getContainers() != null &&+            overlayTemplate.getSpec().getContainers().get(0) != null &&+            overlayTemplate.getSpec().getContainers().get(0).getName() != null) {+            status.addWarningMessage(""The name of the keycloak container cannot be modified"");+        }++        if (overlayTemplate.getSpec() != null &&+            overlayTemplate.getSpec().getContainers() != null &&+            overlayTemplate.getSpec().getContainers().get(0) != null &&+            overlayTemplate.getSpec().getContainers().get(0).getImage() != null) {+            status.addWarningMessage(""The image of the keycloak container cannot be modified using podTemplate"");+        }+    }++    private <T, V> void mergeMaps(Map<T, V> map1, Map<T, V> map2, Consumer<Map<T, V>> consumer) {+        var map = new HashMap<T, V>();+        Optional.ofNullable(map1).ifPresent(e -> map.putAll(e));+        Optional.ofNullable(map2).ifPresent(e -> map.putAll(e));+        consumer.accept(map);+    }++    private <T> void mergeLists(List<T> list1, List<T> list2, Consumer<List<T>> consumer) {+        var list = new ArrayList<T>();+        Optional.ofNullable(list1).ifPresent(e -> list.addAll(e));+        Optional.ofNullable(list2).ifPresent(e -> list.addAll(e));+        consumer.accept(list);+    }++    private <T> void mergeField(T value, Consumer<T> consumer) {+        Optional.ofNullable(value).ifPresent(v -> {+            if (v != null && (!(v instanceof List) || (v instanceof List && ((List<?>) v).size() > 0))) {+                consumer.accept(v);+            }+        });","BTW, just noticed this could be also simplified as the if we have there is enough, no need for `Optional`. We can even omit some redundant conditions.```suggestion        if (value != null && (!(value instanceof List) || ((List<?>) value).size() > 0)) {            consumer.accept(value);        }```",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10098,816709606,2022-03-01T12:04:53Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -146,9 +151,206 @@ private void addInitContainer(Deployment baseDeployment, List<String> extensions         baseDeployment.getSpec().getTemplate().getSpec().setInitContainers(Collections.singletonList(initContainer));     } +    public void validatePodTemplate(KeycloakStatusBuilder status) {+        if (keycloakCR.getSpec() == null ||+                keycloakCR.getSpec().getUnsupported() == null ||+                keycloakCR.getSpec().getUnsupported().getPodTemplate() == null) {+            return;+        }+        var overlayTemplate = this.keycloakCR.getSpec().getUnsupported().getPodTemplate();++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getName() != null) {+            status.addWarningMessage(""The name of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getMetadata() != null &&+            overlayTemplate.getMetadata().getNamespace() != null) {+            status.addWarningMessage(""The namespace of the podTemplate cannot be modified"");+        }++        if (overlayTemplate.getSpec() != null &&+            overlayTemplate.getSpec().getContainers() != null &&+            overlayTemplate.getSpec().getContainers().get(0) != null &&+            overlayTemplate.getSpec().getContainers().get(0).getName() != null) {+            status.addWarningMessage(""The name of the keycloak container cannot be modified"");+        }+    }++    private <T, V> void mergeMaps(Map<T, V> map1, Map<T, V> map2, Consumer<Map<T, V>> consumer) {+        var map = new HashMap<T, V>();+        Optional.ofNullable(map1).ifPresent(e -> map.putAll(e));+        Optional.ofNullable(map2).ifPresent(e -> map.putAll(e));","In this context using `Optional` is simply a safe and elegant expression for mapping the underlying concept  .I would like to know more regarding confining `Optional` to contracts and the reasoning behind this practice, never heard about it.I do not agree that a lambda expression is more ""complex"" than imperative code in any sense, it might be less ""familiar"" to you, but that's a completely different story.> But I'd like to avoid over-engineering/over-complicating (however you want to call it) stuff in future PRs.I do believe that we should agree on a common style __as a team__.",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/8730,816945983,2022-03-01T16:39:08Z,server-spi/src/main/java/org/keycloak/models/credential/RecoveryAuthnCodesCredentialModel.java,"@@ -0,0 +1,106 @@+package org.keycloak.models.credential;++import java.util.stream.Collectors;+import java.util.stream.IntStream;++import org.keycloak.credential.CredentialMetadata;+import org.keycloak.credential.CredentialModel;+import org.keycloak.models.credential.dto.RecoveryAuthnCodeRepresentation;+import org.keycloak.models.credential.dto.RecoveryAuthnCodesCredentialData;+import org.keycloak.models.credential.dto.RecoveryAuthnCodesSecretData;+import org.keycloak.models.utils.RecoveryAuthnCodesUtils;+import org.keycloak.util.JsonSerialization;++import java.io.IOException;+import java.util.List;++public class RecoveryAuthnCodesCredentialModel extends CredentialModel {++    public static final String TYPE = ""recovery-authn-codes"";++    public static final String RECOVERY_CODES_NUMBER_USED = ""recovery-codes-number-used"";+    public static final String RECOVERY_CODES_NUMBER_REMAINING = ""recovery-codes-number-remaining"";+    public static final String RECOVERY_CODES_GENERATE_NEW_CODES = ""recovery-codes-generate-new-codes"";++    private final RecoveryAuthnCodesCredentialData credentialData;+    private final RecoveryAuthnCodesSecretData secretData;+    private final CredentialMetadata credentialMetadata = null;","This seems to be unused, remove?",
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/8730,816947463,2022-03-01T16:40:30Z,server-spi/src/main/java/org/keycloak/models/credential/RecoveryAuthnCodesCredentialModel.java,"@@ -0,0 +1,106 @@+package org.keycloak.models.credential;++import java.util.stream.Collectors;+import java.util.stream.IntStream;++import org.keycloak.credential.CredentialMetadata;+import org.keycloak.credential.CredentialModel;+import org.keycloak.models.credential.dto.RecoveryAuthnCodeRepresentation;+import org.keycloak.models.credential.dto.RecoveryAuthnCodesCredentialData;+import org.keycloak.models.credential.dto.RecoveryAuthnCodesSecretData;+import org.keycloak.models.utils.RecoveryAuthnCodesUtils;+import org.keycloak.util.JsonSerialization;++import java.io.IOException;+import java.util.List;++public class RecoveryAuthnCodesCredentialModel extends CredentialModel {++    public static final String TYPE = ""recovery-authn-codes"";++    public static final String RECOVERY_CODES_NUMBER_USED = ""recovery-codes-number-used"";+    public static final String RECOVERY_CODES_NUMBER_REMAINING = ""recovery-codes-number-remaining"";+    public static final String RECOVERY_CODES_GENERATE_NEW_CODES = ""recovery-codes-generate-new-codes"";++    private final RecoveryAuthnCodesCredentialData credentialData;+    private final RecoveryAuthnCodesSecretData secretData;+    private final CredentialMetadata credentialMetadata = null;++    private RecoveryAuthnCodesCredentialModel(RecoveryAuthnCodesCredentialData credentialData,+            RecoveryAuthnCodesSecretData secretData) {+        this.credentialData = credentialData;+        this.secretData = secretData;+    }++    public RecoveryAuthnCodeRepresentation getNextRecoveryAuthnCode() {+        return this.secretData.getCodes().get(0);+    }++    public boolean allCodesUsed() {+        return this.secretData.getCodes().isEmpty();+    }++    public void removeRecoveryAuthnCode() {+        try {+            this.secretData.removeNextBackupCode();+            this.credentialData.setRemainingCodes(this.secretData.getCodes().size());+            this.setSecretData(JsonSerialization.writeValueAsString(this.secretData));+            this.setCredentialData(JsonSerialization.writeValueAsString(this.credentialData));+        } catch (IOException e) {+            throw new RuntimeException(e);+        }+    }++    public static RecoveryAuthnCodesCredentialModel createFromValues(List<String> originalGeneratedCodes, long generatedAt,+            String userLabel) {+        RecoveryAuthnCodesSecretData secretData;+        RecoveryAuthnCodesCredentialData credentialData;+        RecoveryAuthnCodesCredentialModel model;++        try {+            List<RecoveryAuthnCodeRepresentation> recoveryCodes = IntStream.range(0, originalGeneratedCodes.size())+                    .mapToObj(i -> new RecoveryAuthnCodeRepresentation(i + 1,+                            RecoveryAuthnCodesUtils.hashRawCode(originalGeneratedCodes.get(i))))+                    .collect(Collectors.toList());+            secretData = new RecoveryAuthnCodesSecretData(recoveryCodes);+            credentialData = new RecoveryAuthnCodesCredentialData(RecoveryAuthnCodesUtils.NUM_HASH_ITERATIONS,+                    RecoveryAuthnCodesUtils.NOM_ALGORITHM_TO_HASH, recoveryCodes.size(), recoveryCodes.size());+            model = new RecoveryAuthnCodesCredentialModel(credentialData, secretData);+            model.setCredentialData(JsonSerialization.writeValueAsString(credentialData));+            model.setSecretData(JsonSerialization.writeValueAsString(secretData));+            model.setCreatedDate(generatedAt);+            model.setType(TYPE);++            if (userLabel != null) {+                model.setUserLabel(userLabel);+            }+            return model;+        } catch (IOException e) {+            throw new RuntimeException(e);+        }+    }++    public static RecoveryAuthnCodesCredentialModel createFromCredentialModel(CredentialModel credentialModel) {+        RecoveryAuthnCodesCredentialData credentialData;+        RecoveryAuthnCodesSecretData secretData = null;+        RecoveryAuthnCodesCredentialModel newModel;+        try {+            credentialData = JsonSerialization.readValue(credentialModel.getCredentialData(),+                    RecoveryAuthnCodesCredentialData.class);+            if (credentialModel.getSecretData() != null) {",This pattern seems to be used multiple times - perhaps a common helper method could help to remove some code duplication.,
314690,thomasdarimont,https://api.github.com/repos/keycloak/keycloak/pulls/8730,817071041,2022-03-01T19:21:33Z,server-spi/src/main/java/org/keycloak/models/credential/RecoveryAuthnCodesCredentialModel.java,"@@ -0,0 +1,106 @@+package org.keycloak.models.credential;++import java.util.stream.Collectors;+import java.util.stream.IntStream;++import org.keycloak.credential.CredentialMetadata;+import org.keycloak.credential.CredentialModel;+import org.keycloak.models.credential.dto.RecoveryAuthnCodeRepresentation;+import org.keycloak.models.credential.dto.RecoveryAuthnCodesCredentialData;+import org.keycloak.models.credential.dto.RecoveryAuthnCodesSecretData;+import org.keycloak.models.utils.RecoveryAuthnCodesUtils;+import org.keycloak.util.JsonSerialization;++import java.io.IOException;+import java.util.List;++public class RecoveryAuthnCodesCredentialModel extends CredentialModel {++    public static final String TYPE = ""recovery-authn-codes"";++    public static final String RECOVERY_CODES_NUMBER_USED = ""recovery-codes-number-used"";+    public static final String RECOVERY_CODES_NUMBER_REMAINING = ""recovery-codes-number-remaining"";+    public static final String RECOVERY_CODES_GENERATE_NEW_CODES = ""recovery-codes-generate-new-codes"";++    private final RecoveryAuthnCodesCredentialData credentialData;+    private final RecoveryAuthnCodesSecretData secretData;+    private final CredentialMetadata credentialMetadata = null;++    private RecoveryAuthnCodesCredentialModel(RecoveryAuthnCodesCredentialData credentialData,+            RecoveryAuthnCodesSecretData secretData) {+        this.credentialData = credentialData;+        this.secretData = secretData;+    }++    public RecoveryAuthnCodeRepresentation getNextRecoveryAuthnCode() {+        return this.secretData.getCodes().get(0);","If getCodes() retruns an empty list, ArrayIndexOutOfBoundsException will be thrown. We could wrap the return in an `Optional` or simply return `null`.Is the idea to require users always call `allCodesUsed()` before caling `getNextRecoveryAuthnCode()`?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/8730,817393437,2022-03-02T06:49:59Z,server-spi/src/main/java/org/keycloak/models/credential/PasswordCredentialModel.java,"@@ -44,8 +44,10 @@ public static PasswordCredentialModel createFromCredentialModel(CredentialModel         try {             PasswordCredentialData credentialData = JsonSerialization.readValue(credentialModel.getCredentialData(),                     PasswordCredentialData.class);-            PasswordSecretData secretData = JsonSerialization.readValue(credentialModel.getSecretData(), PasswordSecretData.class);-+            PasswordSecretData secretData = null;+            if (credentialModel.getSecretData() != null) {","How would it have been removed for security reasons? Why does this PR have any impact on this? Also, why would only the secret data be removed? ",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,817412652,2022-03-02T07:27:22Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -60,12 +60,27 @@ type CredType = string; type CredTypeMap = Map<CredType, CredentialContainer>; type CredContainerMap = Map<CredCategory, CredTypeMap>; +interface CredData {","This interface `CredData` still contains some metadata specific to ""recovery codes"" credential. However it seems to me that this interface is not needed? Is it possible to remove this interface definition and also remove definition of `        const credData: CredData = JSON.parse(credential.credentialData!);` from line 271? It seems to me this won't break anything as `credData` defined on line 271 is not used anywhere?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,817422305,2022-03-02T07:44:01Z,core/src/main/java/org/keycloak/representations/idm/CredentialMetadataRepresentation.java,"@@ -0,0 +1,43 @@+package org.keycloak.representations.idm;++public class CredentialMetadataRepresentation {",Minor: IMO it will be slightly better to move this class into package `org.keycloak.representations.account` as it's main usage is for account REST API and account console right now,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/8730,817434702,2022-03-02T08:03:29Z,server-spi/src/main/java/org/keycloak/models/credential/OTPCredentialModel.java,"@@ -59,7 +59,10 @@ public static OTPCredentialModel createFromPolicy(RealmModel realm, String secre     public static OTPCredentialModel createFromCredentialModel(CredentialModel credentialModel) {         try {             OTPCredentialData credentialData = JsonSerialization.readValue(credentialModel.getCredentialData(), OTPCredentialData.class);-            OTPSecretData secretData = JsonSerialization.readValue(credentialModel.getSecretData(), OTPSecretData.class);+            OTPSecretData secretData = null;+            if (credentialModel.getSecretData() != null) {",I believe same applies here like @stianst mentioned in the class PasswordCredentialModel. I hope this PR does not need to change anything in classes like OTPCredentialModel or PasswordCredentialModel?,
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/10387,817740240,2022-03-02T14:24:51Z,.github/workflows/operator-ci.yml,"@@ -61,7 +61,7 @@ jobs:       - name: Test operator running in cluster         working-directory: operator         run: |-          eval $(minikube -p minikube docker-env) +          eval $(minikube -p minikube docker-env)","@andreaTP no big deal, but I'm curious. Is this change necessary?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10387,817952318,2022-03-02T17:55:04Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakService.java,"@@ -0,0 +1,94 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.IntOrString;+import io.fabric8.kubernetes.api.model.Service;+import io.fabric8.kubernetes.api.model.ServiceBuilder;+import io.fabric8.kubernetes.api.model.ServiceSpec;+import io.fabric8.kubernetes.api.model.ServiceSpecBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.StatusUpdater;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;++import java.util.Optional;++public class KeycloakService extends OperatorManagedResource implements StatusUpdater<KeycloakStatusBuilder> {++    private Service existingService;++    public KeycloakService(KubernetesClient client, Keycloak keycloakCR) {+        super(client, keycloakCR);+        this.existingService = fetchExistingService();+    }++    private ServiceSpec getServiceSpec() {+      return new ServiceSpecBuilder()+              .addNewPort()+              .withPort(Constants.KEYCLOAK_SERVICE_PORT)+              .withProtocol(Constants.KEYCLOAK_SERVICE_PROTOCOL)+              .endPort()+              .withSelector(Constants.DEFAULT_LABELS)","Two answers: - re: supporting multiple instances in the same namespace I think that we should have this as a separate task, review all the resources that are created, and have proper testing in place to not break it by accident.- re: this specific caseWhat would you suggest? Should we add a more specific label to the main deployment and propagate it to the Service? Or we can do it as a follow up for supporting multiple instances in one namespace (as this PR is already big enough)?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10387,817963565,2022-03-02T18:05:30Z,operator/src/test/java/org/keycloak/operator/ClusteringE2EIT.java,"@@ -0,0 +1,201 @@+package org.keycloak.operator;++import com.fasterxml.jackson.databind.JsonNode;+import io.fabric8.kubernetes.client.utils.Serialization;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import io.restassured.RestAssured;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.utils.CRAssert;+import org.keycloak.operator.v2alpha1.KeycloakService;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.utils.K8sUtils;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealmImport;+import org.keycloak.operator.v2alpha1.crds.KeycloakRealmImportStatusCondition;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusCondition;++import java.time.Duration;++import static java.util.concurrent.TimeUnit.MINUTES;+import static java.util.concurrent.TimeUnit.SECONDS;+import static org.assertj.core.api.Assertions.assertThat;+++@QuarkusTest+public class ClusteringE2EIT extends ClusterOperatorTest {++    @Test+    public void testKeycloakScaleAsExpected() {+        // given+        var kc = K8sUtils.getDefaultKeycloakDeployment();+        var crSelector = k8sclient+                .resources(Keycloak.class)+                .inNamespace(kc.getMetadata().getNamespace())+                .withName(kc.getMetadata().getName());+        K8sUtils.deployKeycloak(k8sclient, kc, true);++        var kcPodsSelector = k8sclient.pods().inNamespace(namespace).withLabel(""app"", ""keycloak"");++        Keycloak keycloak = k8sclient.resources(Keycloak.class)+                .inNamespace(namespace)+                .list().getItems().get(0);++        // when scale it to 10+        keycloak.getSpec().setInstances(10);+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloak);++        Awaitility.await()+                .atMost(1, MINUTES)+                .pollDelay(1, SECONDS)+                .ignoreExceptions()+                .untilAsserted(() -> CRAssert.assertKeycloakStatusCondition(crSelector.get(), KeycloakStatusCondition.READY, false));++        Awaitility.await()+                .atMost(Duration.ofSeconds(5))+                .untilAsserted(() -> assertThat(kcPodsSelector.list().getItems().size()).isEqualTo(10));++        // when scale it down to 2+        keycloak.getSpec().setInstances(2);+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(keycloak);+        Awaitility.await()+                .atMost(Duration.ofSeconds(180))+                .untilAsserted(() -> assertThat(kcPodsSelector.list().getItems().size()).isEqualTo(2));++        Awaitility.await()+                .atMost(2, MINUTES)+                .pollDelay(5, SECONDS)+                .ignoreExceptions()+                .untilAsserted(() -> CRAssert.assertKeycloakStatusCondition(crSelector.get(), KeycloakStatusCondition.READY, true));++        // get the service+        var service = new KeycloakService(k8sclient, kc);+        String url = ""http://"" + service.getName() + ""."" + namespace + "":"" + Constants.KEYCLOAK_SERVICE_PORT;++        Awaitility.await().atMost(5, MINUTES).untilAsserted(() -> {+            Log.info(""Starting curl Pod to test if the realm is available"");+            Log.info(""Url: '"" + url + ""'"");+            String curlOutput = K8sUtils.inClusterCurl(k8sclient, namespace, url);+            Log.info(""Output from curl: '"" + curlOutput + ""'"");+            assertThat(curlOutput).isEqualTo(""200"");+        });+    }++    // local debug commands:+    //    export TOKEN=$(curl --data ""grant_type=password&client_id=token-test-client&username=test&password=test"" http://localhost:8080/realms/token-test/protocol/openid-connect/token | jq -r '.access_token')+    //+    //    curl http://localhost:8080/realms/token-test/protocol/openid-connect/userinfo -H ""Authorization: bearer $TOKEN""+    //+    //    example good answer:+    //    {""sub"":""b660eec6-a93b-46fd-abb2-e9fbdff67a63"",""email_verified"":false,""preferred_username"":""test""}+    //    example error answer:+    //    {""error"":""invalid_request"",""error_description"":""Token not provided""}+    @Test+    public void testKeycloakCacheIsConnected() {+        // given+        Log.info(""Setup"");+        var kc = K8sUtils.getDefaultKeycloakDeployment();+        var crSelector = k8sclient+                .resources(Keycloak.class)+                .inNamespace(kc.getMetadata().getNamespace())+                .withName(kc.getMetadata().getName());+        var targetInstances = 3;+        kc.getSpec().setInstances(targetInstances);+        k8sclient.resources(Keycloak.class).inNamespace(namespace).createOrReplace(kc);+        var realm = k8sclient.resources(KeycloakRealmImport.class).inNamespace(namespace).load(getClass().getResourceAsStream(""/token-test-realm.yaml""));+        var realmImportSelector = k8sclient.resources(KeycloakRealmImport.class).inNamespace(namespace).withName(""example-token-test-kc"");+        realm.createOrReplace();++        Log.info(""Waiting for a stable Keycloak Cluster"");+        Awaitility.await()+                .atMost(10, MINUTES)+                .pollDelay(5, SECONDS)+                .ignoreExceptions()+                .untilAsserted(() -> {+                    Log.info(""Checking realm import has finished."");+                    CRAssert.assertKeycloakRealmImportStatusCondition(realmImportSelector.get(), KeycloakRealmImportStatusCondition.DONE, true);+                    Log.info(""Checking Keycloak is stable."");+                    CRAssert.assertKeycloakStatusCondition(crSelector.get(), KeycloakStatusCondition.READY, true);+                });++        Log.info(""Testing the Keycloak Cluster"");+        Awaitility.await().atMost(5, MINUTES).ignoreExceptions().untilAsserted(() -> {",This CI will give us some data:https://github.com/andreaTP/keycloak/runs/5396139803?check_suite_focus=true,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10373,817991142,2022-03-02T18:38:57Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/LdapRoleMapKeycloakTransaction.java,"@@ -0,0 +1,441 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelException;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.StreamUtils;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.role.MapRoleEntity;++import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.MapFieldPredicates;+import org.keycloak.models.map.storage.chm.MapModelCriteriaBuilder;+import org.keycloak.models.map.storage.ldap.role.entity.LdapMapRoleEntityFieldDelegate;+import org.keycloak.models.map.storage.ldap.store.LdapMapIdentityStore;+import org.keycloak.models.map.storage.ldap.config.LdapMapConfig;+import org.keycloak.models.map.storage.ldap.LdapMapKeycloakTransaction;+import org.keycloak.models.map.storage.ldap.model.LdapMapDn;+import org.keycloak.models.map.storage.ldap.model.LdapMapObject;+import org.keycloak.models.map.storage.ldap.model.LdapMapQuery;+import org.keycloak.models.map.storage.ldap.role.config.LdapMapRoleMapperConfig;+import org.keycloak.models.map.storage.ldap.role.entity.LdapRoleEntity;++import javax.naming.NamingException;+import java.util.Arrays;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.stream.Collectors;+import java.util.stream.Stream;++public class LdapRoleMapKeycloakTransaction extends LdapMapKeycloakTransaction<LdapMapRoleEntityFieldDelegate, MapRoleEntity, RoleModel> {++    private final KeycloakSession session;+    private final Config.Scope config;+    private final StringKeyConvertor<String> keyConverter = new StringKeyConvertor.StringKey();+    private final List<String> deletedKeys = new LinkedList<>();+    private final LdapMapRoleMapperConfig roleMapperConfig;+    private final LdapMapConfig ldapMapConfig;++    public LdapRoleMapKeycloakTransaction(KeycloakSession session, Config.Scope config) {+        this.session = session;+        this.config = config;+        this.roleMapperConfig = new LdapMapRoleMapperConfig(config);+        this.ldapMapConfig = new LdapMapConfig(config);+    }++    // interface matching the constructor of this class+    public interface LdapRoleMapKeycloakTransactionFunction<A, B, R> {+        R apply(A a, B b);+    }++    // TODO: entries might get stale if a DN of an entry changes due to changes in the entity in the same transaction+    private final Map<String, String> dns = new HashMap<>();++    public String readIdByDn(String dn) {+        // TODO: this might not be necessary if the LDAP server would support an extended OID+        // https://ldapwiki.com/wiki/LDAP_SERVER_EXTENDED_DN_OID++        String id = dns.get(dn);+        if (id == null) {+            for (Map.Entry<String, LdapMapRoleEntityFieldDelegate> entry : entities.entrySet()) {+                LdapMapObject ldap = entry.getValue().getLdapMapObject();+                if (ldap.getDn().toString().equals(dn)) {+                    id = ldap.getId();+                    break;+                }+            }+        }+        if (id != null) {+            return id;+        }++        LdapMapQuery ldapQuery = new LdapMapQuery();++        // For now, use same search scope, which is configured ""globally"" and used for user's search.+        ldapQuery.setSearchScope(ldapMapConfig.getSearchScope());+        ldapQuery.setSearchDn(config.get(""roles.dn.common""));++        // TODO: read them properly to be able to store them in the transaction so they are cached?!+        Collection<String> roleObjectClasses = ldapMapConfig.getRoleObjectClasses();+        ldapQuery.addObjectClasses(roleObjectClasses);++        String rolesRdnAttr = roleMapperConfig.getRoleNameLdapAttribute();++        ldapQuery.addReturningLdapAttribute(rolesRdnAttr);++        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        LdapMapDn.RDN rdn = LdapMapDn.fromString(dn).getFirstRdn();+        String key = rdn.getAllKeys().get(0);+        String value = rdn.getAttrValue(key);++        LdapRoleModelCriteriaBuilder mcb =+                new LdapRoleModelCriteriaBuilder(roleMapperConfig).compare(RoleModel.SearchableFields.NAME, ModelCriteriaBuilder.Operator.EQ, value);+        mcb = mcb.withCustomFilter(roleMapperConfig.getCustomLdapFilter());+        ldapQuery.setModelCriteriaBuilder(mcb);++        List<LdapMapObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+        if (ldapObjects.size() == 1) {+            dns.put(dn, ldapObjects.get(0).getId());+            return ldapObjects.get(0).getId();+        }+        return null;+    }++    private MapModelCriteriaBuilder<String, MapRoleEntity, RoleModel> createCriteriaBuilderMap() {+        return new MapModelCriteriaBuilder<>(keyConverter, MapFieldPredicates.getPredicates(RoleModel.class));+    }++    @Override+    public LdapMapRoleEntityFieldDelegate create(MapRoleEntity value) {+        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        DeepCloner CLONER = new DeepCloner.Builder()+                .constructor(MapRoleEntity.class, cloner -> new LdapMapRoleEntityFieldDelegate(new LdapRoleEntity(cloner, roleMapperConfig, this, value.getRealmId(), value.getClientId())))+                .build();++        LdapMapRoleEntityFieldDelegate mapped = (LdapMapRoleEntityFieldDelegate) CLONER.from(value);++        // LDAP should never use the UUID provided by the caller, as UUID is generated by the LDAP directory+        mapped.setId(null);+        // Roles as groups need to have at least one member on most directories. Add ourselves as a member as a dummy.+        if (mapped.getLdapMapObject().getId() == null && mapped.getLdapMapObject().getAttributeAsSet(roleMapperConfig.getMembershipLdapAttribute()) == null) {+            // insert our own name as dummy member of this role to avoid a schema conflict in LDAP+            mapped.getLdapMapObject().setAttribute(roleMapperConfig.getMembershipLdapAttribute(), Stream.of(mapped.getLdapMapObject().getDn().toString()).collect(Collectors.toSet()));+        }++        try {+            // in order to get the ID, we need to write it to LDAP+            identityStore.add(mapped.getLdapMapObject());+        } catch (ModelException ex) {+            if (value.isClientRole() && ex.getCause() instanceof NamingException) {+                // the client hasn't been created, therefore adding it here+                LdapMapObject client = new LdapMapObject();+                client.setObjectClasses(Arrays.asList(""top"", ""organizationalUnit""));+                client.setRdnAttributeName(""ou"");+                client.setDn(LdapMapDn.fromString(roleMapperConfig.getRolesDn(mapped.isClientRole(), mapped.getClientId())));+                client.setSingleAttribute(""ou"", mapped.getClientId());+                identityStore.add(client);++                tasksOnRollback.add(new DeleteOperation() {+                    @Override+                    public void execute() {+                        identityStore.remove(client);+                    }+                });++                // retry creation of client role+                identityStore.add(mapped.getLdapMapObject());+            }+        }++        entities.put(mapped.getId(), mapped);++        tasksOnRollback.add(new DeleteOperation() {+            @Override+            public void execute() {+                identityStore.remove(mapped.getLdapMapObject());+                entities.remove(mapped.getId());+            }+        });++        return mapped;+    }++    @Override+    public boolean delete(String key) {+        LdapMapRoleEntityFieldDelegate read = read(key);+        if (read == null) {+            throw new ModelException(""unable to read entity with key "" + key);+        }+        deletedKeys.add(key);+        tasksOnCommit.add(new DeleteOperation() {+            @Override+            public void execute() {+                LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);+                identityStore.remove(read.getLdapMapObject());+            }+        });+        return true;+    }++    public LdapRoleEntity readLdap(String key) {+        LdapMapRoleEntityFieldDelegate read = read(key);+        if (read == null) {+            return null;+        } else {+            return read.getEntityFieldDelegate();+        }+    }++    @Override+    public LdapMapRoleEntityFieldDelegate read(String key) {+        if (deletedKeys.contains(key)) {+            return null;+        }++        // reuse an existing live entity+        LdapMapRoleEntityFieldDelegate val = entities.get(key);++        if (val == null) {++            // try to look it up as a realm role+            val = lookupEntityById(key, null);++            if (val == null) {+                // try to look it up using a client role+                // currently the API doesn't allow to get a list of all keys, therefore we need a separate attribute+                // also, getArray is broken as it doesn't look up the parent's values if an entry is empty+                String clientsToSearch = config.scope(""clients"").get(""clientsToSearch"");+                if (clientsToSearch != null) {+                    String[] clientIds = clientsToSearch.split(""\\s*,\\s*"");+                    for (String clientId : clientIds) {+                        val = lookupEntityById(key, clientId);+                        if (val != null) {+                            break;+                        }+                    }+                }+            }",How would the `clients` config be maintained in runtime? Who would be responsible for maintaining the `clientsToSearch` list? How would it react to changes in additions / removals of client ?Side note: transaction should get a pre-processed config rather than using a `Config.scope()` methods - those are high-level ones and belong to `ProviderFactory`.,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10373,818381698,2022-03-03T07:31:37Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/LdapRoleMapKeycloakTransaction.java,"@@ -0,0 +1,441 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelException;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.StreamUtils;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.role.MapRoleEntity;++import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.MapFieldPredicates;+import org.keycloak.models.map.storage.chm.MapModelCriteriaBuilder;+import org.keycloak.models.map.storage.ldap.role.entity.LdapMapRoleEntityFieldDelegate;+import org.keycloak.models.map.storage.ldap.store.LdapMapIdentityStore;+import org.keycloak.models.map.storage.ldap.config.LdapMapConfig;+import org.keycloak.models.map.storage.ldap.LdapMapKeycloakTransaction;+import org.keycloak.models.map.storage.ldap.model.LdapMapDn;+import org.keycloak.models.map.storage.ldap.model.LdapMapObject;+import org.keycloak.models.map.storage.ldap.model.LdapMapQuery;+import org.keycloak.models.map.storage.ldap.role.config.LdapMapRoleMapperConfig;+import org.keycloak.models.map.storage.ldap.role.entity.LdapRoleEntity;++import javax.naming.NamingException;+import java.util.Arrays;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.stream.Collectors;+import java.util.stream.Stream;++public class LdapRoleMapKeycloakTransaction extends LdapMapKeycloakTransaction<LdapMapRoleEntityFieldDelegate, MapRoleEntity, RoleModel> {++    private final KeycloakSession session;+    private final Config.Scope config;+    private final StringKeyConvertor<String> keyConverter = new StringKeyConvertor.StringKey();+    private final List<String> deletedKeys = new LinkedList<>();+    private final LdapMapRoleMapperConfig roleMapperConfig;+    private final LdapMapConfig ldapMapConfig;++    public LdapRoleMapKeycloakTransaction(KeycloakSession session, Config.Scope config) {+        this.session = session;+        this.config = config;+        this.roleMapperConfig = new LdapMapRoleMapperConfig(config);+        this.ldapMapConfig = new LdapMapConfig(config);+    }++    // interface matching the constructor of this class+    public interface LdapRoleMapKeycloakTransactionFunction<A, B, R> {+        R apply(A a, B b);+    }++    // TODO: entries might get stale if a DN of an entry changes due to changes in the entity in the same transaction+    private final Map<String, String> dns = new HashMap<>();++    public String readIdByDn(String dn) {+        // TODO: this might not be necessary if the LDAP server would support an extended OID+        // https://ldapwiki.com/wiki/LDAP_SERVER_EXTENDED_DN_OID++        String id = dns.get(dn);+        if (id == null) {+            for (Map.Entry<String, LdapMapRoleEntityFieldDelegate> entry : entities.entrySet()) {+                LdapMapObject ldap = entry.getValue().getLdapMapObject();+                if (ldap.getDn().toString().equals(dn)) {+                    id = ldap.getId();+                    break;+                }+            }+        }+        if (id != null) {+            return id;+        }++        LdapMapQuery ldapQuery = new LdapMapQuery();++        // For now, use same search scope, which is configured ""globally"" and used for user's search.+        ldapQuery.setSearchScope(ldapMapConfig.getSearchScope());+        ldapQuery.setSearchDn(config.get(""roles.dn.common""));++        // TODO: read them properly to be able to store them in the transaction so they are cached?!+        Collection<String> roleObjectClasses = ldapMapConfig.getRoleObjectClasses();+        ldapQuery.addObjectClasses(roleObjectClasses);++        String rolesRdnAttr = roleMapperConfig.getRoleNameLdapAttribute();++        ldapQuery.addReturningLdapAttribute(rolesRdnAttr);++        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        LdapMapDn.RDN rdn = LdapMapDn.fromString(dn).getFirstRdn();+        String key = rdn.getAllKeys().get(0);+        String value = rdn.getAttrValue(key);++        LdapRoleModelCriteriaBuilder mcb =+                new LdapRoleModelCriteriaBuilder(roleMapperConfig).compare(RoleModel.SearchableFields.NAME, ModelCriteriaBuilder.Operator.EQ, value);+        mcb = mcb.withCustomFilter(roleMapperConfig.getCustomLdapFilter());+        ldapQuery.setModelCriteriaBuilder(mcb);++        List<LdapMapObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+        if (ldapObjects.size() == 1) {+            dns.put(dn, ldapObjects.get(0).getId());+            return ldapObjects.get(0).getId();+        }+        return null;+    }++    private MapModelCriteriaBuilder<String, MapRoleEntity, RoleModel> createCriteriaBuilderMap() {+        return new MapModelCriteriaBuilder<>(keyConverter, MapFieldPredicates.getPredicates(RoleModel.class));+    }++    @Override+    public LdapMapRoleEntityFieldDelegate create(MapRoleEntity value) {+        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        DeepCloner CLONER = new DeepCloner.Builder()+                .constructor(MapRoleEntity.class, cloner -> new LdapMapRoleEntityFieldDelegate(new LdapRoleEntity(cloner, roleMapperConfig, this, value.getRealmId(), value.getClientId())))+                .build();++        LdapMapRoleEntityFieldDelegate mapped = (LdapMapRoleEntityFieldDelegate) CLONER.from(value);++        // LDAP should never use the UUID provided by the caller, as UUID is generated by the LDAP directory+        mapped.setId(null);+        // Roles as groups need to have at least one member on most directories. Add ourselves as a member as a dummy.+        if (mapped.getLdapMapObject().getId() == null && mapped.getLdapMapObject().getAttributeAsSet(roleMapperConfig.getMembershipLdapAttribute()) == null) {+            // insert our own name as dummy member of this role to avoid a schema conflict in LDAP+            mapped.getLdapMapObject().setAttribute(roleMapperConfig.getMembershipLdapAttribute(), Stream.of(mapped.getLdapMapObject().getDn().toString()).collect(Collectors.toSet()));+        }++        try {+            // in order to get the ID, we need to write it to LDAP+            identityStore.add(mapped.getLdapMapObject());+        } catch (ModelException ex) {+            if (value.isClientRole() && ex.getCause() instanceof NamingException) {+                // the client hasn't been created, therefore adding it here+                LdapMapObject client = new LdapMapObject();+                client.setObjectClasses(Arrays.asList(""top"", ""organizationalUnit""));+                client.setRdnAttributeName(""ou"");+                client.setDn(LdapMapDn.fromString(roleMapperConfig.getRolesDn(mapped.isClientRole(), mapped.getClientId())));+                client.setSingleAttribute(""ou"", mapped.getClientId());+                identityStore.add(client);++                tasksOnRollback.add(new DeleteOperation() {+                    @Override+                    public void execute() {+                        identityStore.remove(client);+                    }+                });++                // retry creation of client role+                identityStore.add(mapped.getLdapMapObject());+            }+        }++        entities.put(mapped.getId(), mapped);++        tasksOnRollback.add(new DeleteOperation() {+            @Override+            public void execute() {+                identityStore.remove(mapped.getLdapMapObject());+                entities.remove(mapped.getId());+            }+        });++        return mapped;+    }++    @Override+    public boolean delete(String key) {+        LdapMapRoleEntityFieldDelegate read = read(key);+        if (read == null) {+            throw new ModelException(""unable to read entity with key "" + key);+        }+        deletedKeys.add(key);+        tasksOnCommit.add(new DeleteOperation() {+            @Override+            public void execute() {+                LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);+                identityStore.remove(read.getLdapMapObject());+            }+        });+        return true;+    }++    public LdapRoleEntity readLdap(String key) {+        LdapMapRoleEntityFieldDelegate read = read(key);+        if (read == null) {+            return null;+        } else {+            return read.getEntityFieldDelegate();+        }+    }++    @Override+    public LdapMapRoleEntityFieldDelegate read(String key) {+        if (deletedKeys.contains(key)) {+            return null;+        }++        // reuse an existing live entity+        LdapMapRoleEntityFieldDelegate val = entities.get(key);++        if (val == null) {++            // try to look it up as a realm role+            val = lookupEntityById(key, null);++            if (val == null) {+                // try to look it up using a client role+                // currently the API doesn't allow to get a list of all keys, therefore we need a separate attribute+                // also, getArray is broken as it doesn't look up the parent's values if an entry is empty+                String clientsToSearch = config.scope(""clients"").get(""clientsToSearch"");+                if (clientsToSearch != null) {+                    String[] clientIds = clientsToSearch.split(""\\s*,\\s*"");+                    for (String clientId : clientIds) {+                        val = lookupEntityById(key, clientId);+                        if (val != null) {+                            break;+                        }+                    }+                }+            }","The clientsToSearch list is here as not all configurations allowed to iterate over their keys via `getPropertyNames()`. It needs to be maintained in sync with the client nodes, what is not ideal. An improvement is IMHO outside of the scope of this issue.I'll keep the side note in mind for future PRs in this area.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10373,818385675,2022-03-03T07:38:40Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/LdapRoleMapKeycloakTransaction.java,"@@ -0,0 +1,441 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelException;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.StreamUtils;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.role.MapRoleEntity;++import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.MapFieldPredicates;+import org.keycloak.models.map.storage.chm.MapModelCriteriaBuilder;+import org.keycloak.models.map.storage.ldap.role.entity.LdapMapRoleEntityFieldDelegate;+import org.keycloak.models.map.storage.ldap.store.LdapMapIdentityStore;+import org.keycloak.models.map.storage.ldap.config.LdapMapConfig;+import org.keycloak.models.map.storage.ldap.LdapMapKeycloakTransaction;+import org.keycloak.models.map.storage.ldap.model.LdapMapDn;+import org.keycloak.models.map.storage.ldap.model.LdapMapObject;+import org.keycloak.models.map.storage.ldap.model.LdapMapQuery;+import org.keycloak.models.map.storage.ldap.role.config.LdapMapRoleMapperConfig;+import org.keycloak.models.map.storage.ldap.role.entity.LdapRoleEntity;++import javax.naming.NamingException;+import java.util.Arrays;+import java.util.Collection;+import java.util.HashMap;+import java.util.Iterator;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.stream.Collectors;+import java.util.stream.Stream;++public class LdapRoleMapKeycloakTransaction extends LdapMapKeycloakTransaction<LdapMapRoleEntityFieldDelegate, MapRoleEntity, RoleModel> {++    private final KeycloakSession session;+    private final Config.Scope config;+    private final StringKeyConvertor<String> keyConverter = new StringKeyConvertor.StringKey();+    private final List<String> deletedKeys = new LinkedList<>();+    private final LdapMapRoleMapperConfig roleMapperConfig;+    private final LdapMapConfig ldapMapConfig;++    public LdapRoleMapKeycloakTransaction(KeycloakSession session, Config.Scope config) {+        this.session = session;+        this.config = config;+        this.roleMapperConfig = new LdapMapRoleMapperConfig(config);+        this.ldapMapConfig = new LdapMapConfig(config);+    }++    // interface matching the constructor of this class+    public interface LdapRoleMapKeycloakTransactionFunction<A, B, R> {+        R apply(A a, B b);+    }++    // TODO: entries might get stale if a DN of an entry changes due to changes in the entity in the same transaction+    private final Map<String, String> dns = new HashMap<>();++    public String readIdByDn(String dn) {+        // TODO: this might not be necessary if the LDAP server would support an extended OID+        // https://ldapwiki.com/wiki/LDAP_SERVER_EXTENDED_DN_OID++        String id = dns.get(dn);+        if (id == null) {+            for (Map.Entry<String, LdapMapRoleEntityFieldDelegate> entry : entities.entrySet()) {+                LdapMapObject ldap = entry.getValue().getLdapMapObject();+                if (ldap.getDn().toString().equals(dn)) {+                    id = ldap.getId();+                    break;+                }+            }+        }+        if (id != null) {+            return id;+        }++        LdapMapQuery ldapQuery = new LdapMapQuery();++        // For now, use same search scope, which is configured ""globally"" and used for user's search.+        ldapQuery.setSearchScope(ldapMapConfig.getSearchScope());+        ldapQuery.setSearchDn(config.get(""roles.dn.common""));++        // TODO: read them properly to be able to store them in the transaction so they are cached?!+        Collection<String> roleObjectClasses = ldapMapConfig.getRoleObjectClasses();+        ldapQuery.addObjectClasses(roleObjectClasses);++        String rolesRdnAttr = roleMapperConfig.getRoleNameLdapAttribute();++        ldapQuery.addReturningLdapAttribute(rolesRdnAttr);++        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        LdapMapDn.RDN rdn = LdapMapDn.fromString(dn).getFirstRdn();+        String key = rdn.getAllKeys().get(0);+        String value = rdn.getAttrValue(key);++        LdapRoleModelCriteriaBuilder mcb =+                new LdapRoleModelCriteriaBuilder(roleMapperConfig).compare(RoleModel.SearchableFields.NAME, ModelCriteriaBuilder.Operator.EQ, value);+        mcb = mcb.withCustomFilter(roleMapperConfig.getCustomLdapFilter());+        ldapQuery.setModelCriteriaBuilder(mcb);++        List<LdapMapObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+        if (ldapObjects.size() == 1) {+            dns.put(dn, ldapObjects.get(0).getId());+            return ldapObjects.get(0).getId();+        }+        return null;+    }++    private MapModelCriteriaBuilder<String, MapRoleEntity, RoleModel> createCriteriaBuilderMap() {+        return new MapModelCriteriaBuilder<>(keyConverter, MapFieldPredicates.getPredicates(RoleModel.class));","@hmlnarik - that's an interesting idea. In order for that to work I'd need to pass in an instantiator to create new instances, as currently it creates only instances of MapModelCriteriaBuilder() in the tree created. All instances in the tree would need to be of the new type to ensure that they all handle the EQ operator differently.",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/10288,818410877,2022-03-03T08:17:47Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/infinispan/CacheExpirationTest.java,"@@ -54,6 +53,9 @@     @Test     public void testCacheExpiration() throws Exception { +        log.debug(""Check if previous instances of the class exist on the heap"");+        getNumberOfInstancesOfClass(AuthenticationSessionAuthNoteUpdateEvent.class);","I see. Maybe put the `getNumberOfInstancesOfClass` directly into log.debug like `log.debugf(""Number of previous instances of the class on the heap:  %d"", getNumberOfInstancesOfClass(AuthenticationSessionAuthNoteUpdateEvent.class));`?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10387,818418413,2022-03-03T08:28:11Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakService.java,"@@ -0,0 +1,94 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.IntOrString;+import io.fabric8.kubernetes.api.model.Service;+import io.fabric8.kubernetes.api.model.ServiceBuilder;+import io.fabric8.kubernetes.api.model.ServiceSpec;+import io.fabric8.kubernetes.api.model.ServiceSpecBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.StatusUpdater;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;++import java.util.Optional;++public class KeycloakService extends OperatorManagedResource implements StatusUpdater<KeycloakStatusBuilder> {++    private Service existingService;++    public KeycloakService(KubernetesClient client, Keycloak keycloakCR) {+        super(client, keycloakCR);+        this.existingService = fetchExistingService();+    }++    private ServiceSpec getServiceSpec() {+      return new ServiceSpecBuilder()+              .addNewPort()+              .withPort(Constants.KEYCLOAK_SERVICE_PORT)+              .withProtocol(Constants.KEYCLOAK_SERVICE_PROTOCOL)+              .endPort()+              .withSelector(Constants.DEFAULT_LABELS)","Ok, deal.   This is most probably a bigger task, let's address it separately in #10562.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/7860,818453203,2022-03-03T09:11:43Z,services/src/main/java/org/keycloak/authentication/AuthenticationSelectionResolver.java,"@@ -91,11 +92,24 @@                         .map(credentialType -> new AuthenticationSelectionOption(processor.getSession(), typeAuthExecMap.get(credentialType)))                         .collect(Collectors.toList());             }+            else {+                // No user associated with session. Check if this flow contains executions linked to authenticators that don't require a user+                typeAuthExecMap.forEach((key, value) -> {+                    AuthenticatorFactory credbasedAuthenticatorFactory = (AuthenticatorFactory) processor.getSession().getKeycloakSessionFactory().getProviderFactory(Authenticator.class, value.getAuthenticator());","I was wondering if it's a proper solution to obtain `sessionFactory` in each iteration as the session (AFAIK) should be the same for the whole method. However, as one of the main purposes of the `AuthenticationProcessor` class is to manage the state of the authentication process and there are no other calls to dynamically changing objects, I don't consider this as a blocker for this PR. Just wanted to take it into consideration.",
48237552,vanrar68,https://api.github.com/repos/keycloak/keycloak/pulls/7860,818711027,2022-03-03T14:29:29Z,services/src/main/java/org/keycloak/authentication/AuthenticationSelectionResolver.java,"@@ -91,11 +92,24 @@                         .map(credentialType -> new AuthenticationSelectionOption(processor.getSession(), typeAuthExecMap.get(credentialType)))                         .collect(Collectors.toList());             }+            else {+                // No user associated with session. Check if this flow contains executions linked to authenticators that don't require a user+                typeAuthExecMap.forEach((key, value) -> {+                    AuthenticatorFactory credbasedAuthenticatorFactory = (AuthenticatorFactory) processor.getSession().getKeycloakSessionFactory().getProviderFactory(Authenticator.class, value.getAuthenticator());","@mabartos  Something like this ? :```  KeycloakSessionFactory sessionFactory = processor.getSession().getKeycloakSessionFactory();  typeAuthExecMap.forEach((key, value) -> {      AuthenticatorFactory credbasedAuthenticatorFactory = (AuthenticatorFactory) sessionFactory.getProviderFactory(Authenticator.class, value.getAuthenticator());      Authenticator credbasedAuthenticator = credbasedAuthenticatorFactory.create(processor.getSession());      if (!credbasedAuthenticator.requiresUser()) {          userlessCredBasedAuthenticationSelectionList.add(new AuthenticationSelectionOption(processor.getSession(), value));      }  });```",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10507,818805540,2022-03-03T16:02:12Z,model/map/src/main/java/org/keycloak/models/map/authSession/MapAuthenticationSessionEntity.java,"@@ -16,129 +16,77 @@  */ package org.keycloak.models.map.authSession; +import org.keycloak.models.map.annotations.GenerateEntityImplementations;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.UpdatableEntity; import org.keycloak.sessions.AuthenticationSessionModel; -import java.util.HashSet;+import java.util.HashMap; import java.util.Map;+import java.util.Objects; import java.util.Set;-import java.util.concurrent.ConcurrentHashMap;  /**  * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>  */-public class MapAuthenticationSessionEntity {+@GenerateEntityImplementations(+        inherits = ""org.keycloak.models.map.authSession.MapAuthenticationSessionEntity.AbstractAuthenticationSessionEntity""+)+@DeepCloner.Root+public interface MapAuthenticationSessionEntity extends UpdatableEntity { -    private String clientUUID;+    public abstract class AbstractAuthenticationSessionEntity extends UpdatableEntity.Impl implements MapAuthenticationSessionEntity { -    private String authUserId;--    private int timestamp;--    private String redirectUri;-    private String action;-    private Set<String> clientScopes = new HashSet<>();--    private Map<String, AuthenticationSessionModel.ExecutionStatus> executionStatus = new ConcurrentHashMap<>();-    private String protocol;--    private Map<String, String> clientNotes= new ConcurrentHashMap<>();;-    private Map<String, String> authNotes = new ConcurrentHashMap<>();;-    private Set<String> requiredActions = new HashSet<>();-    private Map<String, String> userSessionNotes = new ConcurrentHashMap<>();--    public Map<String, String> getUserSessionNotes() {-        return userSessionNotes;+        @Override+        public void addExecutionStatus(String authenticator, AuthenticationSessionModel.ExecutionStatus status) {","This method can be generated, the methods have to be renamed to comply with naming conventions see: https://github.com/mhajas/keycloak/commit/f24312cb313a3efd99079d53b28cdd3a30a2c7a6",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10507,818814826,2022-03-03T16:12:01Z,model/map/src/main/java/org/keycloak/models/map/authSession/MapRootAuthenticationSessionEntity.java,"@@ -16,89 +16,71 @@  */ package org.keycloak.models.map.authSession; +import org.keycloak.models.map.annotations.GenerateEntityImplementations; import org.keycloak.models.map.common.AbstractEntity; +import org.keycloak.models.map.common.DeepCloner; import org.keycloak.models.map.common.UpdatableEntity;++import java.util.Collections; import java.util.Map;-import java.util.Objects;-import java.util.concurrent.ConcurrentHashMap;+import java.util.Optional;  /**  * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>  */-public class MapRootAuthenticationSessionEntity extends UpdatableEntity.Impl implements AbstractEntity {--    private String id;-    private String realmId;--    /**-     * Flag signalizing that any of the setters has been meaningfully used.-     */-    private int timestamp;-    private Map<String, MapAuthenticationSessionEntity> authenticationSessions = new ConcurrentHashMap<>();--    public MapRootAuthenticationSessionEntity() {}--    public MapRootAuthenticationSessionEntity(String id, String realmId) {-        this.id = id;-        this.realmId = realmId;-    }--    @Override-    public String getId() {-        return this.id;-    }--    @Override-    public void setId(String id) {-        if (this.id != null) throw new IllegalStateException(""Id cannot be changed"");-        this.id = id;-        this.updated |= id != null;-    }--    public String getRealmId() {-        return realmId;-    }--    public void setRealmId(String realmId) {-        this.updated |= !Objects.equals(this.realmId, realmId);-        this.realmId = realmId;+@GenerateEntityImplementations(+        inherits = ""org.keycloak.models.map.authSession.MapRootAuthenticationSessionEntity.AbstractRootAuthenticationSessionEntity""+)+@DeepCloner.Root+public interface MapRootAuthenticationSessionEntity extends AbstractEntity, UpdatableEntity {++    public abstract class AbstractRootAuthenticationSessionEntity extends UpdatableEntity.Impl implements MapRootAuthenticationSessionEntity {++        private String id;++        @Override+        public String getId() {+            return this.id;+        }++        @Override+        public void setId(String id) {+            if (this.id != null) throw new IllegalStateException(""Id cannot be changed"");+            this.id = id;+            this.updated |= id != null;+        }++        @Override+        public MapAuthenticationSessionEntity removeAuthenticationSession(String tabId) {","Just one more thing here, we need to count with a possibility the returned Boolean is `null`. In that case, we need to decide what the default boolean option is the correct one, probably `true`. We are doing something similar here:https://github.com/keycloak/keycloak/blob/92f6c753281079624c08583bd91dba3c474d833f/model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java#L148-L157",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10576,819559090,2022-03-04T13:14:02Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/LoggingPropertyMappers.java,"@@ -2,23 +2,38 @@  import static org.keycloak.quarkus.runtime.integration.QuarkusPlatform.addInitializationException; +import java.io.File;+import java.util.List; import java.util.Locale;+import java.util.Objects; import java.util.function.BiFunction; import java.util.logging.Level;  import org.jboss.logmanager.LogContext;+import org.keycloak.quarkus.runtime.Environment; import org.keycloak.quarkus.runtime.Messages;  import io.smallrye.config.ConfigSourceInterceptorContext;  final class LoggingPropertyMappers {      private static final String DEFAULT_LOG_LEVEL = ""info"";+    private static final String DEFAULT_LOG_HANDLER = ""console"";+    private static final String DEFAULT_LOG_FILENAME = ""keycloak.log"";+    private static final String DEFAULT_LOG_PATH = ""data/log/""+DEFAULT_LOG_FILENAME;+    private static final List<String> AVAILABLE_LOG_HANDLERS = List.of(DEFAULT_LOG_HANDLER,""file"");+    private static final String DEFAULT_CONSOLE_OUTPUT = ""plain"";      private LoggingPropertyMappers(){}      public static PropertyMapper[] getMappers() {         return new PropertyMapper[] {+                builder().from(""log"")+                        .defaultValue(DEFAULT_LOG_HANDLER)+                        .description(""Enable one or more log handlers in a comma-separated list. Available log handlers are: "" + String.join("","", AVAILABLE_LOG_HANDLERS))+                        .paramLabel(""<handler>"")+                        .expectedValues(""console"",""file"",""console,file"",""file,console"")","actually not, it's either ""console"" alone, ""file"" alone, or a combination of these two. This could get messy when we'd have more than 2 options, but for now this leads to the server not even starting with a wrong combination entered from CLI. Problem adding it in the transformer instead was for me that the `throwinitializationexception` threw the error more than once, i think because it's a `mapFrom` config property. Also I like to ""fail fast"" here, now when you do e.g. `kc.sh log=` or `kc.sh log=foo` or `kc.sh log=console,foo` quarkus would not even start but an error is shown instead.In the future we should really rely on types in the cli, and not handle everything as string. when you'd have a `List<KcLogConfig` as type, we could add the arity for picocli for exactly this type, and also the split. (arity 1...*, split="","") and make this more convenient. See also: https://github.com/DGuhr/keycloak/tree/PoC_Typed_Converters_For_CLI_Valueshttps://picocli.info/#_arityhttps://picocli.info/#_split_regex",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10373,819620885,2022-03-04T14:33:59Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/LdapRoleMapKeycloakTransaction.java,"@@ -0,0 +1,424 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelException;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.StreamUtils;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.role.MapRoleEntity;++import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.MapFieldPredicates;+import org.keycloak.models.map.storage.chm.MapModelCriteriaBuilder;+import org.keycloak.models.map.storage.ldap.role.entity.LdapMapRoleEntityFieldDelegate;+import org.keycloak.models.map.storage.ldap.store.LdapMapIdentityStore;+import org.keycloak.models.map.storage.ldap.config.LdapMapConfig;+import org.keycloak.models.map.storage.ldap.LdapMapKeycloakTransaction;+import org.keycloak.models.map.storage.ldap.model.LdapMapDn;+import org.keycloak.models.map.storage.ldap.model.LdapMapObject;+import org.keycloak.models.map.storage.ldap.model.LdapMapQuery;+import org.keycloak.models.map.storage.ldap.role.config.LdapMapRoleMapperConfig;+import org.keycloak.models.map.storage.ldap.role.entity.LdapRoleEntity;++import javax.naming.NamingException;+import java.util.Arrays;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;++public class LdapRoleMapKeycloakTransaction extends LdapMapKeycloakTransaction<LdapMapRoleEntityFieldDelegate, MapRoleEntity, RoleModel> {++    private final KeycloakSession session;+    private final StringKeyConvertor<String> keyConverter = new StringKeyConvertor.StringKey();+    private final Set<String> deletedKeys = new HashSet<>();+    private final LdapMapRoleMapperConfig roleMapperConfig;+    private final LdapMapConfig ldapMapConfig;++    public LdapRoleMapKeycloakTransaction(KeycloakSession session, Config.Scope config) {+        this.session = session;+        this.roleMapperConfig = new LdapMapRoleMapperConfig(config);+        this.ldapMapConfig = new LdapMapConfig(config);+    }++    // interface matching the constructor of this class+    public interface LdapRoleMapKeycloakTransactionFunction<A, B, R> {+        R apply(A a, B b);+    }++    // TODO: entries might get stale if a DN of an entry changes due to changes in the entity in the same transaction+    private final Map<String, String> dns = new HashMap<>();++    public String readIdByDn(String dn) {+        // TODO: this might not be necessary if the LDAP server would support an extended OID+        // https://ldapwiki.com/wiki/LDAP_SERVER_EXTENDED_DN_OID++        String id = dns.get(dn);+        if (id == null) {+            for (Map.Entry<String, LdapMapRoleEntityFieldDelegate> entry : entities.entrySet()) {+                LdapMapObject ldap = entry.getValue().getLdapMapObject();+                if (ldap.getDn().toString().equals(dn)) {+                    id = ldap.getId();+                    break;+                }+            }+        }+        if (id != null) {+            return id;+        }++        LdapMapQuery ldapQuery = new LdapMapQuery();++        // For now, use same search scope, which is configured ""globally"" and used for user's search.+        ldapQuery.setSearchScope(ldapMapConfig.getSearchScope());+        ldapQuery.setSearchDn(roleMapperConfig.getCommonRolesDn());++        // TODO: read them properly to be able to store them in the transaction so they are cached?!+        Collection<String> roleObjectClasses = ldapMapConfig.getRoleObjectClasses();+        ldapQuery.addObjectClasses(roleObjectClasses);++        String rolesRdnAttr = roleMapperConfig.getRoleNameLdapAttribute();++        ldapQuery.addReturningLdapAttribute(rolesRdnAttr);++        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        LdapMapDn.RDN rdn = LdapMapDn.fromString(dn).getFirstRdn();+        String key = rdn.getAllKeys().get(0);+        String value = rdn.getAttrValue(key);++        LdapRoleModelCriteriaBuilder mcb =+                new LdapRoleModelCriteriaBuilder(roleMapperConfig).compare(RoleModel.SearchableFields.NAME, ModelCriteriaBuilder.Operator.EQ, value);+        mcb = mcb.withCustomFilter(roleMapperConfig.getCustomLdapFilter());+        ldapQuery.setModelCriteriaBuilder(mcb);++        List<LdapMapObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+        if (ldapObjects.size() == 1) {+            dns.put(dn, ldapObjects.get(0).getId());+            return ldapObjects.get(0).getId();+        }+        return null;+    }++    private MapModelCriteriaBuilder<String, MapRoleEntity, RoleModel> createCriteriaBuilderMap() {+        return new MapModelCriteriaBuilder<>(keyConverter, MapFieldPredicates.getPredicates(RoleModel.class));+    }++    @Override+    public LdapMapRoleEntityFieldDelegate create(MapRoleEntity value) {+        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        DeepCloner CLONER = new DeepCloner.Builder()+                .constructor(MapRoleEntity.class, cloner -> new LdapMapRoleEntityFieldDelegate(new LdapRoleEntity(cloner, roleMapperConfig, this, value.getRealmId(), value.getClientId())))+                .build();++        LdapMapRoleEntityFieldDelegate mapped = (LdapMapRoleEntityFieldDelegate) CLONER.from(value);++        // LDAP should never use the UUID provided by the caller, as UUID is generated by the LDAP directory+        mapped.setId(null);+        // Roles as groups need to have at least one member on most directories. Add ourselves as a member as a dummy.+        if (mapped.getLdapMapObject().getId() == null && mapped.getLdapMapObject().getAttributeAsSet(roleMapperConfig.getMembershipLdapAttribute()) == null) {+            // insert our own name as dummy member of this role to avoid a schema conflict in LDAP+            mapped.getLdapMapObject().setAttribute(roleMapperConfig.getMembershipLdapAttribute(), Stream.of(mapped.getLdapMapObject().getDn().toString()).collect(Collectors.toSet()));+        }++        try {+            // in order to get the ID, we need to write it to LDAP+            identityStore.add(mapped.getLdapMapObject());+        } catch (ModelException ex) {+            if (value.isClientRole() && ex.getCause() instanceof NamingException) {","This is here to create a new `ou` for each client when the first client role is created. However, realm roles have own `ou` as well (RealmRoles). Where is this `ou` created? I am not able to find it. I would expect something similar as below for `ou=RealmRoles`.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10508,819633827,2022-03-04T14:48:56Z,services/src/main/java/org/keycloak/authorization/authorization/AuthorizationTokenService.java,"@@ -517,7 +516,7 @@ private void resolvePreviousGrantedPermissions(PermissionTicketToken ticket,                             break;                         } -                        Resource resource = resourceStore.findById(grantedPermission.getResourceId(), ticket.getIssuedFor());","`issuedFor` is `client.clientId` not `client.id` [1]. It worked because `findById` methods in cache and jpa don't check `resourceServerId` when querying. However, the new storage does so no Resource is found in storage. The method works only if the Resource with id is present in the cache.[1] https://github.com/keycloak/keycloak/blob/main/services/src/main/java/org/keycloak/authorization/admin/PolicyEvaluationService.java#L293",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10508,819638637,2022-03-04T14:54:14Z,model/map/src/main/java/org/keycloak/models/map/authorization/adapter/MapResourceAdapter.java,"@@ -129,6 +132,25 @@ public void setOwnerManagedAccess(boolean ownerManagedAccess) {     @Override     public void updateScopes(Set<Scope> scopes) {         throwExceptionIfReadonly();++        PermissionTicketStore permissionStore = storeFactory.getPermissionTicketStore();","Removing permissions could be done in a single step, we would need something like `removeByScope` or `removeByAttributes` similarly as we do [searching](https://github.com/keycloak/keycloak/blob/main/model/map/src/main/java/org/keycloak/models/map/authorization/MapPermissionTicketStore.java#L186).However, I am not sure about the policies as they need to be updated, not removed.Anyway, this would be out of scope for this PR as it is about disabling caching. I will create an issue for addressing this.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10576,820497597,2022-03-07T09:00:10Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/LoggingPropertyMappers.java,"@@ -64,15 +78,96 @@ public String apply(String value, ConfigSourceInterceptorContext configSourceInt                         .description(""The log level of the root category or a comma-separated list of individual categories and their levels. For the root category, you don't need to specify a category."")                         .paramLabel(""category:level"")                         .build(),-                builder().from(""log-format"")+                builder().from(""log-console-output"")+                        .to(""quarkus.log.console.json"")+                        .defaultValue(DEFAULT_CONSOLE_OUTPUT)+                        .description(""Set the log output to JSON or plain unstructured logging."")+                        .paramLabel(""plain|json"")+                        .expectedValues(DEFAULT_CONSOLE_OUTPUT,""json"")+                        .transformer((value, context) -> {+                            if(value.equals(DEFAULT_CONSOLE_OUTPUT)) {+                                return Boolean.FALSE.toString();+                            }+                            return Boolean.TRUE.toString();+                        })+                        .build(),+                builder().from(""log-console-format"")                         .to(""quarkus.log.console.format"")                         .defaultValue(""%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n"")-                        .description(""The format of log entries. If the format has spaces in it, you need to escape the value such as \""<format>\""."")+                        .description(""The format of plain console log entries. If the format has spaces in it, escape the value using \""<format>\""."")                         .paramLabel(""format"")+                        .build(),+                builder().from(""log-console-color"")+                        .to(""quarkus.log.console.color"")+                        .defaultValue(Boolean.TRUE.toString())+                        .description(""Enable or disable colors when logging to console."")+                        .paramLabel(Boolean.TRUE + ""|"" + Boolean.FALSE)+                        .build(),+                builder().from(""log-console-enabled"")+                        .mapFrom(""log"")+                        .to(""quarkus.log.console.enable"")+                        .hidden(true)+                        .transformer(resolveLogHandler(DEFAULT_LOG_HANDLER))+                        .build(),+                builder().from(""log-file-enabled"")+                        .mapFrom(""log"")+                        .to(""quarkus.log.file.enable"")+                        .hidden(true)+                        .transformer(resolveLogHandler(""file""))+                        .build(),+                builder().from(""log-file"")+                        .to(""quarkus.log.file.path"")+                        .defaultValue(DEFAULT_LOG_PATH)+                        .description(""Set the log file path and filename."")+                        .paramLabel(""<path>/<file-name>.log"")+                        .transformer(LoggingPropertyMappers::resolveFileLogLocation)+                        .build(),+                builder().from(""log-file-format"")+                        .to(""quarkus.log.file.format"")+                        .defaultValue(""%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n"")+                        .description(""Set a format specific to file log entries."")+                        .paramLabel(""<format>"")                         .build()         };     } +    private static BiFunction<String, ConfigSourceInterceptorContext, String> resolveLogHandler(String handler) {+        return (parentValue, context) -> {++            //we want to fall back to console to not have nothing shown up when wrong values are set.+            String consoleDependantErrorResult = handler.equals(DEFAULT_LOG_HANDLER) ? Boolean.TRUE.toString() : Boolean.FALSE.toString();++            if(parentValue.isBlank()) {+                addInitializationException(Messages.emptyValueForKey(""log""));+                return consoleDependantErrorResult;+            }++            String[] logHandlerValues = parentValue.split("","");++            if (!AVAILABLE_LOG_HANDLERS.containsAll(List.of(logHandlerValues))) {+                addInitializationException(Messages.notRecognizedValueInList(""log"", parentValue, String.join("","", AVAILABLE_LOG_HANDLERS)));+                return consoleDependantErrorResult;+            }++            for (String handlerInput : logHandlerValues) {",isn't this condition redundant given the check at line 147?,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10576,820502300,2022-03-07T09:06:21Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/QuarkusPropertiesAutoBuildDistTest.java,"@@ -68,19 +68,19 @@ void testReAugAfterChangingProperty(LaunchResult result) {         assertTrue(cliResult.getOutput().contains(""INFO  [io.quarkus]""));     } -    public static class DisableConsoleLogHandler implements Consumer<KeycloakDistribution> {+    public static class updateConsoleLogLevelToWarn implements Consumer<KeycloakDistribution> {",a class name starting with a lowercase letter?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10373,820506613,2022-03-07T09:11:50Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/LdapRoleMapKeycloakTransaction.java,"@@ -0,0 +1,412 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role;++import org.keycloak.Config;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ModelException;+import org.keycloak.models.RoleModel;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.StreamUtils;+import org.keycloak.models.map.common.StringKeyConvertor;+import org.keycloak.models.map.role.MapRoleEntity;++import org.keycloak.models.map.storage.ModelCriteriaBuilder;+import org.keycloak.models.map.storage.QueryParameters;+import org.keycloak.models.map.storage.chm.MapFieldPredicates;+import org.keycloak.models.map.storage.chm.MapModelCriteriaBuilder;+import org.keycloak.models.map.storage.ldap.MapModelCriteriaBuilderAssumingEqualForField;+import org.keycloak.models.map.storage.ldap.role.entity.LdapMapRoleEntityFieldDelegate;+import org.keycloak.models.map.storage.ldap.store.LdapMapIdentityStore;+import org.keycloak.models.map.storage.ldap.config.LdapMapConfig;+import org.keycloak.models.map.storage.ldap.LdapMapKeycloakTransaction;+import org.keycloak.models.map.storage.ldap.model.LdapMapDn;+import org.keycloak.models.map.storage.ldap.model.LdapMapObject;+import org.keycloak.models.map.storage.ldap.model.LdapMapQuery;+import org.keycloak.models.map.storage.ldap.role.config.LdapMapRoleMapperConfig;+import org.keycloak.models.map.storage.ldap.role.entity.LdapRoleEntity;++import javax.naming.NamingException;+import java.util.Arrays;+import java.util.Collection;+import java.util.HashMap;+import java.util.HashSet;+import java.util.Iterator;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.stream.Collectors;+import java.util.stream.Stream;++public class LdapRoleMapKeycloakTransaction extends LdapMapKeycloakTransaction<LdapMapRoleEntityFieldDelegate, MapRoleEntity, RoleModel> {++    private final KeycloakSession session;+    private final StringKeyConvertor<String> keyConverter = new StringKeyConvertor.StringKey();+    private final Set<String> deletedKeys = new HashSet<>();+    private final LdapMapRoleMapperConfig roleMapperConfig;+    private final LdapMapConfig ldapMapConfig;++    public LdapRoleMapKeycloakTransaction(KeycloakSession session, Config.Scope config) {+        this.session = session;+        this.roleMapperConfig = new LdapMapRoleMapperConfig(config);+        this.ldapMapConfig = new LdapMapConfig(config);+    }++    // interface matching the constructor of this class+    public interface LdapRoleMapKeycloakTransactionFunction<A, B, R> {+        R apply(A a, B b);+    }++    // TODO: entries might get stale if a DN of an entry changes due to changes in the entity in the same transaction+    private final Map<String, String> dns = new HashMap<>();++    public String readIdByDn(String dn) {+        // TODO: this might not be necessary if the LDAP server would support an extended OID+        // https://ldapwiki.com/wiki/LDAP_SERVER_EXTENDED_DN_OID++        String id = dns.get(dn);+        if (id == null) {+            for (Map.Entry<String, LdapMapRoleEntityFieldDelegate> entry : entities.entrySet()) {+                LdapMapObject ldap = entry.getValue().getLdapMapObject();+                if (ldap.getDn().toString().equals(dn)) {+                    id = ldap.getId();+                    break;+                }+            }+        }+        if (id != null) {+            return id;+        }++        LdapMapQuery ldapQuery = new LdapMapQuery();++        // For now, use same search scope, which is configured ""globally"" and used for user's search.+        ldapQuery.setSearchScope(ldapMapConfig.getSearchScope());+        ldapQuery.setSearchDn(roleMapperConfig.getCommonRolesDn());++        // TODO: read them properly to be able to store them in the transaction so they are cached?!+        Collection<String> roleObjectClasses = ldapMapConfig.getRoleObjectClasses();+        ldapQuery.addObjectClasses(roleObjectClasses);++        String rolesRdnAttr = roleMapperConfig.getRoleNameLdapAttribute();++        ldapQuery.addReturningLdapAttribute(rolesRdnAttr);++        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        LdapMapDn.RDN rdn = LdapMapDn.fromString(dn).getFirstRdn();+        String key = rdn.getAllKeys().get(0);+        String value = rdn.getAttrValue(key);++        LdapRoleModelCriteriaBuilder mcb =+                new LdapRoleModelCriteriaBuilder(roleMapperConfig).compare(RoleModel.SearchableFields.NAME, ModelCriteriaBuilder.Operator.EQ, value);+        mcb = mcb.withCustomFilter(roleMapperConfig.getCustomLdapFilter());+        ldapQuery.setModelCriteriaBuilder(mcb);++        List<LdapMapObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);+        if (ldapObjects.size() == 1) {+            dns.put(dn, ldapObjects.get(0).getId());+            return ldapObjects.get(0).getId();+        }+        return null;+    }++    private MapModelCriteriaBuilder<String, MapRoleEntity, RoleModel> createCriteriaBuilderMap() {+        // The realmId might not be set of instances retrieved by read(id) and we're still sure that they belong to the realm being searched.+        // Therefore, ignore the field realmId when searching the instances that are stored within the transaction.+        return new MapModelCriteriaBuilderAssumingEqualForField<>(keyConverter, MapFieldPredicates.getPredicates(RoleModel.class), RoleModel.SearchableFields.REALM_ID);+    }++    @Override+    public LdapMapRoleEntityFieldDelegate create(MapRoleEntity value) {+        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        DeepCloner CLONER = new DeepCloner.Builder()+                .constructor(MapRoleEntity.class, cloner -> new LdapMapRoleEntityFieldDelegate(new LdapRoleEntity(cloner, roleMapperConfig, this, value.getClientId())))+                .build();++        LdapMapRoleEntityFieldDelegate mapped = (LdapMapRoleEntityFieldDelegate) CLONER.from(value);++        // LDAP should never use the UUID provided by the caller, as UUID is generated by the LDAP directory+        mapped.setId(null);+        // Roles as groups need to have at least one member on most directories. Add ourselves as a member as a dummy.+        if (mapped.getLdapMapObject().getId() == null && mapped.getLdapMapObject().getAttributeAsSet(roleMapperConfig.getMembershipLdapAttribute()) == null) {+            // insert our own name as dummy member of this role to avoid a schema conflict in LDAP+            mapped.getLdapMapObject().setAttribute(roleMapperConfig.getMembershipLdapAttribute(), Stream.of(mapped.getLdapMapObject().getDn().toString()).collect(Collectors.toSet()));+        }++        try {+            // in order to get the ID, we need to write it to LDAP+            identityStore.add(mapped.getLdapMapObject());+        } catch (ModelException ex) {+            if (value.isClientRole() && ex.getCause() instanceof NamingException) {+                // the client hasn't been created, therefore adding it here+                LdapMapObject client = new LdapMapObject();+                client.setObjectClasses(Arrays.asList(""top"", ""organizationalUnit""));+                client.setRdnAttributeName(""ou"");+                client.setDn(LdapMapDn.fromString(roleMapperConfig.getRolesDn(mapped.isClientRole(), mapped.getClientId())));+                client.setSingleAttribute(""ou"", mapped.getClientId());+                identityStore.add(client);++                tasksOnRollback.add(new DeleteOperation() {+                    @Override+                    public void execute() {+                        identityStore.remove(client);+                    }+                });++                // retry creation of client role+                identityStore.add(mapped.getLdapMapObject());+            }+        }++        entities.put(mapped.getId(), mapped);++        tasksOnRollback.add(new DeleteOperation() {+            @Override+            public void execute() {+                identityStore.remove(mapped.getLdapMapObject());+                entities.remove(mapped.getId());+            }+        });++        return mapped;+    }++    @Override+    public boolean delete(String key) {+        LdapMapRoleEntityFieldDelegate read = read(key);+        if (read == null) {+            throw new ModelException(""unable to read entity with key "" + key);+        }+        deletedKeys.add(key);+        tasksOnCommit.add(new DeleteOperation() {+            @Override+            public void execute() {+                LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);+                identityStore.remove(read.getLdapMapObject());+            }+        });+        return true;+    }++    public LdapRoleEntity readLdap(String key) {+        LdapMapRoleEntityFieldDelegate read = read(key);+        if (read == null) {+            return null;+        } else {+            return read.getEntityFieldDelegate();+        }+    }++    @Override+    public LdapMapRoleEntityFieldDelegate read(String key) {+        if (deletedKeys.contains(key)) {+            return null;+        }++        // reuse an existing live entity+        LdapMapRoleEntityFieldDelegate val = entities.get(key);++        if (val == null) {++            // try to look it up as a realm role+            val = lookupEntityById(key, null);++            if (val == null) {+                // try to find out the client ID+                LdapMapQuery ldapQuery = new LdapMapQuery();++                // For now, use same search scope, which is configured ""globally"" and used for user's search.+                ldapQuery.setSearchScope(ldapMapConfig.getSearchScope());++                // remove prefix with placeholder to allow for a broad search+                String sdn = roleMapperConfig.getClientRolesDn();+                ldapQuery.setSearchDn(sdn.replaceAll("".*\\{0},"", """"));++                LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++                LdapMapObject ldapObject = identityStore.fetchById(key, ldapQuery);+                if (ldapObject != null) {+                    // as the client ID is now known, search again with the specific configuration+                    LdapMapDn.RDN firstRdn = ldapObject.getDn().getParentDn().getFirstRdn();+                    String clientId = firstRdn.getAttrValue(firstRdn.getAllKeys().get(0));+                    // lookup with clientId, as the search above might have been broader than a restricted search+                    val = lookupEntityById(key, clientId);+                }+            }++            if (val != null) {+                entities.put(key, val);+            }++        }+        return val;+    }++    private LdapMapRoleEntityFieldDelegate lookupEntityById(String id, String clientId) {+        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        LdapMapQuery ldapQuery = getLdapQuery(clientId != null, clientId);++        LdapMapObject ldapObject = identityStore.fetchById(id, ldapQuery);+        if (ldapObject != null) {+            return new LdapMapRoleEntityFieldDelegate(new LdapRoleEntity(ldapObject, roleMapperConfig, this, clientId));+        }+        return null;+    }++    @Override+    public Stream<MapRoleEntity> read(QueryParameters<RoleModel> queryParameters) {+        LdapRoleModelCriteriaBuilder mcb = queryParameters.getModelCriteriaBuilder()+                .flashToModelCriteriaBuilder(createLdapModelCriteriaBuilder());++        Boolean isClientRole = mcb.isClientRole();+        String clientId = mcb.getClientId();++        LdapMapIdentityStore identityStore = new LdapMapIdentityStore(session, ldapMapConfig);++        LdapMapQuery ldapQuery = getLdapQuery(isClientRole, clientId);++        mcb = mcb.withCustomFilter(roleMapperConfig.getCustomLdapFilter());+        ldapQuery.setModelCriteriaBuilder(mcb);++        Stream<MapRoleEntity> ldapStream;++        MapModelCriteriaBuilder<String,MapRoleEntity,RoleModel> mapMcb = queryParameters.getModelCriteriaBuilder().flashToModelCriteriaBuilder(createCriteriaBuilderMap());++        Stream<LdapMapRoleEntityFieldDelegate> existingEntities = entities.entrySet().stream()+                .filter(me -> mapMcb.getKeyFilter().test(keyConverter.fromString(me.getKey())) || deletedKeys.contains(me.getKey()))+                .map(Map.Entry::getValue)+                .filter(mapMcb.getEntityFilter())+                // snapshot list+                .collect(Collectors.toList()).stream();++        try {+            List<LdapMapObject> ldapObjects = identityStore.fetchQueryResults(ldapQuery);++            ldapStream = ldapObjects.stream().map(ldapMapObject -> {+                    // we might have fetch client and realm roles at the same time, now try to decode what is what+                    StreamUtils.Pair<Boolean, String> client = getClientId(ldapMapObject.getDn());+                    if (client == null) {+                        return null;+                    }+                    LdapMapRoleEntityFieldDelegate entity = new LdapMapRoleEntityFieldDelegate(new LdapRoleEntity(ldapMapObject, roleMapperConfig, this, client.getV()));+                    LdapMapRoleEntityFieldDelegate existingEntry = entities.get(entity.getId());+                    if (existingEntry != null) {+                        // this entry will be part of the existing entities","I want to make sure I understand this correctly. Is it true, that `entities` list contains all roles that were removed in this transaction? If yes this line also filters out all removed roles because all removed roles returned by ldap query will be turned into `null`.Example:We have roles: role1, role2. Both were created in this transaction so both are present in the `entities` list.role1 is also removed in this transaction (id of role1 is added to `deletedKeys` list). Then, there is a query that both role1 and role2 fulfill. The read method will work like this:1. it creates a list `existingEntities` that contains role2 (role1 is omitted because it doesn't pass the condition `&& !deletedKeys.contains(me.getKey())`)2. There is an LDAPQuery executed that returns both role1 and role23. Both role1 and role2 is turned into null because `entities` list contains both4. `ldapStream` is empty and `existingEntities` contains role25. The result is role2Do I understand it correctly?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10576,820509910,2022-03-07T09:15:57Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/QuarkusPropertiesDistTest.java,"@@ -84,20 +84,20 @@ void testIgnoreQuarkusPropertyFromKeycloakConf(LaunchResult result) {         cliResult.assertBuild();     } -    public static class DisableConsoleLogHandler implements Consumer<KeycloakDistribution> {+    public static class UpdateConsoleLogLevelToWarn implements Consumer<KeycloakDistribution> {",Isn't this code duplicated from `QuarkusPropertiesAutoBuildDistTest.java` should it go to an `abstract` common ancestor?,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10373,820632918,2022-03-07T11:52:21Z,model/map-ldap/src/main/java/org/keycloak/models/map/storage/ldap/role/entity/LdapRoleEntity.java,"@@ -0,0 +1,335 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.ldap.role.entity;++import java.util.ArrayList;+import java.util.Arrays;+import java.util.EnumMap;+import java.util.HashMap;+import java.util.HashSet;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.function.BiConsumer;+import java.util.function.BiFunction;+import java.util.function.Function;++import org.apache.commons.lang.NotImplementedException;+import org.keycloak.models.ModelException;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.EntityField;+import org.keycloak.models.map.common.UpdatableEntity;+import org.keycloak.models.map.common.delegate.EntityFieldDelegate;+import org.keycloak.models.map.role.MapRoleEntity;+import org.keycloak.models.map.role.MapRoleEntityFields;+import org.keycloak.models.map.storage.ldap.model.LdapMapDn;+import org.keycloak.models.map.storage.ldap.model.LdapMapObject;+import org.keycloak.models.map.storage.ldap.role.config.LdapMapRoleMapperConfig;+import org.keycloak.models.map.storage.ldap.role.LdapRoleMapKeycloakTransaction;++public class LdapRoleEntity extends UpdatableEntity.Impl implements EntityFieldDelegate<MapRoleEntity> {","@hmlnarik asked for for this support, AFAIK as this pattern will work well with the TreeStore later, and will be needed when implementing users when we don't support all the fields.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10603,820735425,2022-03-07T14:05:48Z,server-spi/src/main/java/org/keycloak/models/ClientSecretConfig.java,"@@ -0,0 +1,16 @@+package org.keycloak.models;+/**+ * @author <a href=""mailto:masales@redhat.com"">Marcelo Sales</a>+ */+public class ClientSecretConfig extends AbstractConfig{","Few points to this class:- Will it be possible to rename this class to `ClientSecretConstants` ?- Also is it possible to move to ""keycloak-server-spi-private"" module to make sure that it is not part of the public SPI? For example similar to class `org.keycloak.models.Constants` .- Finally, is it possible to remove inheritance from `AbstractConfig` class? As it seems to me that this class contains only constants and there is no reason for it to inherit from AbstractConfig unless I am missing something?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10603,820741171,2022-03-07T14:12:06Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCClientConfigWrapper.java,"@@ -0,0 +1,246 @@+package org.keycloak.protocol.oidc;++import static org.keycloak.models.ClientSecretConfig.CLIENT_ROTATED_SECRET;+import static org.keycloak.models.ClientSecretConfig.CLIENT_ROTATED_SECRET_CREATION_TIME;+import static org.keycloak.models.ClientSecretConfig.CLIENT_ROTATED_SECRET_EXPIRATION_TIME;+import static org.keycloak.models.ClientSecretConfig.CLIENT_SECRET_CREATION_TIME;+import static org.keycloak.models.ClientSecretConfig.CLIENT_SECRET_EXPIRATION;+import static org.keycloak.models.ClientSecretConfig.CLIENT_SECRET_ROTATION_ENABLED;++import java.security.MessageDigest;+import java.util.HashMap;+import org.keycloak.common.util.Time;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientSecretConfig;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.utils.StringUtil;++/**+ * @author <a href=""mailto:masales@redhat.com"">Marcelo Sales</a>+ */+public class OIDCClientConfigWrapper {","Few points to this class:- Is it possible to rename this class to something like `OIDCClientSecretConfigWrapper` or something like this?- It seems methods for CRUD attributes (EG. setAttribute, getAttribute etc) are similar/same to methods in class `OIDCAdvancedConfigWrapper` . Is it possible if you create new abstract class like `AbstractClientConfigWrapper` and add methods for CRUD client attributes to this class? Maybe also constructor etc. Then both `OIDCAdvancedConfigWrapper and this new class `OIDCClientSecretConfigWrapper` will inherit from this new class. WDYT?- Is it possible to remove some methods from this class, which are not related to client secret? For example `getName`, `getDescription`, `getId`, `getProtocol` and maybe more. I've checked that none of them is used from any place in the codebase.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10603,820756048,2022-03-07T14:27:46Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientAccessTypeCondition.java,"@@ -74,6 +74,8 @@ public ClientPolicyVote applyPolicy(ClientPolicyContext context) throws ClientPo             case TOKEN_INTROSPECT:             case USERINFO_REQUEST:             case LOGOUT_REQUEST:+            case UPDATED:","Note: Is it possible to update also some other conditions to make sure tthey are able to ""listen"" to REGISTERED and UPDATED events, so it is possible to evaluate them during client secret rotation cases (EG. when ""Re-generate secret"" is pressed in the admin console)?For example at least `ClientRolesCondition` policy as it can be common use-case to enable client secret rotation just for the clients with some special ""marker"" client role like `client-secret-rotation-role` .I think same applies for other conditioons like `ClientUpdaterContextCondition` , `ClientUpdaterSourceGroupsCondition` and `ClientUpdaterSourceHostsCondition` . As i can imagine the use-cases like:-- Enable client secret rotation for all OIDC dynamicly registered clients (but not for clients managed by ""important-admin"" user through admin console)-- Enable client secret rotation for the clients, which are managed by ""admin-joe"" (That is user in some special group ""power-admin-groups"" etc.I know this is limitation of client policies design as we discussed, but hopefully updating the conditions will be just fine for this PR IMO.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10603,820768543,2022-03-07T14:40:24Z,services/src/main/java/org/keycloak/services/resources/admin/ClientResource.java,"@@ -665,6 +691,59 @@ public ManagementPermissionReference setManagementPermissionsEnabled(ManagementP         }     } +    /**+     * Invalidate the rotated secret for the client+     *+     * @return+     */+    @Path(""client-secret/rotated"")+    @DELETE+    @Produces(MediaType.APPLICATION_JSON)+    @Consumes(MediaType.APPLICATION_JSON)+    public Response invalidateRotatedSecret() {","It will be good to add this method also to the admin client (class `org.keycloak.admin.client.resource.ClientResource`) and add some automated test of this method.IMO it will be fine to add the test inside the new test class, which you already created or create new class for testing admin REST API and validation of admin REST API. I am leaving to you.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10603,820770128,2022-03-07T14:41:59Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientSecretTest.java,"@@ -0,0 +1,716 @@+package org.keycloak.testsuite.client;++import static org.hamcrest.MatcherAssert.assertThat;+import static org.hamcrest.Matchers.equalTo;+import static org.hamcrest.Matchers.greaterThan;+import static org.hamcrest.Matchers.greaterThanOrEqualTo;+import static org.hamcrest.Matchers.is;+import static org.hamcrest.Matchers.not;+import static org.hamcrest.Matchers.notNullValue;+import static org.junit.Assert.assertEquals;+import static org.junit.Assert.fail;+import static org.keycloak.testsuite.admin.AbstractAdminTest.loadJson;++import com.fasterxml.jackson.core.JsonProcessingException;+import com.fasterxml.jackson.databind.ObjectMapper;+import java.io.IOException;+import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.List;+import java.util.Map;+import java.util.UUID;+import java.util.concurrent.TimeUnit;+import javax.ws.rs.BadRequestException;+import javax.ws.rs.core.Response;+import javax.ws.rs.core.Response.Status;+import org.jboss.logging.Logger;+import org.jetbrains.annotations.NotNull;+import org.junit.After;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.OAuth2Constants;+import org.keycloak.admin.client.resource.ClientResource;+import org.keycloak.authentication.authenticators.client.ClientIdAndSecretAuthenticator;+import org.keycloak.common.Profile.Feature;+import org.keycloak.common.util.Time;+import org.keycloak.events.Details;+import org.keycloak.models.AdminRoles;+import org.keycloak.models.ClientSecretConfig;+import org.keycloak.models.utils.KeycloakModelUtils;+import org.keycloak.protocol.oidc.OIDCClientConfigWrapper;+import org.keycloak.representations.idm.ClientPoliciesRepresentation;+import org.keycloak.representations.idm.ClientProfileRepresentation;+import org.keycloak.representations.idm.ClientProfilesRepresentation;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyException;+import org.keycloak.services.clientpolicy.condition.ClientAccessTypeCondition.Configuration;+import org.keycloak.services.clientpolicy.condition.ClientAccessTypeConditionFactory;+import org.keycloak.services.clientpolicy.executor.ClientSecretRotationExecutor;+import org.keycloak.services.clientpolicy.executor.ClientSecretRotationExecutorFactory;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.account.AbstractRestServiceTest;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer;+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;+import org.keycloak.testsuite.util.ClientPoliciesUtil.ClientPoliciesBuilder;+import org.keycloak.testsuite.util.ClientPoliciesUtil.ClientPolicyBuilder;+import org.keycloak.testsuite.util.ClientPoliciesUtil.ClientProfileBuilder;+import org.keycloak.testsuite.util.ClientPoliciesUtil.ClientProfilesBuilder;+import org.keycloak.testsuite.util.OAuthClient;+import org.keycloak.testsuite.util.OAuthClient.AuthorizationEndpointResponse;+import org.keycloak.testsuite.util.ServerURLs;+import org.keycloak.testsuite.util.UserBuilder;+import org.keycloak.util.JsonSerialization;++/**+ * @author <a href=""mailto:masales@redhat.com"">Marcelo Sales</a>+ */+@AuthServerContainerExclude(AuthServer.REMOTE)+@EnableFeature(value = Feature.CLIENT_SECRET_ROTATION)+public class ClientSecretTest extends AbstractRestServiceTest {",Minor: How about rename this test class to `ClientSecretRotationTest` to better reflect what it is about?,
4205291,marcelomrwin,https://api.github.com/repos/keycloak/keycloak/pulls/10603,820894853,2022-03-07T16:44:52Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCClientConfigWrapper.java,"@@ -0,0 +1,246 @@+package org.keycloak.protocol.oidc;++import static org.keycloak.models.ClientSecretConfig.CLIENT_ROTATED_SECRET;+import static org.keycloak.models.ClientSecretConfig.CLIENT_ROTATED_SECRET_CREATION_TIME;+import static org.keycloak.models.ClientSecretConfig.CLIENT_ROTATED_SECRET_EXPIRATION_TIME;+import static org.keycloak.models.ClientSecretConfig.CLIENT_SECRET_CREATION_TIME;+import static org.keycloak.models.ClientSecretConfig.CLIENT_SECRET_EXPIRATION;+import static org.keycloak.models.ClientSecretConfig.CLIENT_SECRET_ROTATION_ENABLED;++import java.security.MessageDigest;+import java.util.HashMap;+import org.keycloak.common.util.Time;+import org.keycloak.models.ClientModel;+import org.keycloak.models.ClientSecretConfig;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.utils.StringUtil;++/**+ * @author <a href=""mailto:masales@redhat.com"">Marcelo Sales</a>+ */+public class OIDCClientConfigWrapper {","There were more methods that were created while designing the solution. After the solution is definitely found, cleaning of unused methods must be carried out.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10605,820946515,2022-03-07T17:41:10Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -181,7 +181,7 @@ protected void savePodLogs() {    private static void setDefaultAwaitilityTimings() {     Awaitility.setDefaultPollInterval(Duration.ofSeconds(1));-    Awaitility.setDefaultTimeout(Duration.ofSeconds(240));+    Awaitility.setDefaultTimeout(Duration.ofSeconds(360));","I haven't identified any specific ""root cause"", but I noticed some bigger output regarding distributed cache syncing etc.Adding TLS to every connection does add some serious load to the server though.Spoke with @pedroigor about, not much we can action at the moment (I guess), let's keep this monitored.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10603,821407963,2022-03-08T07:59:54Z,services/src/main/java/org/keycloak/protocol/oidc/AbstractClientConfigWrapper.java,"@@ -0,0 +1,73 @@+package org.keycloak.protocol.oidc;++import java.util.Arrays;+import java.util.Collections;+import java.util.HashMap;+import java.util.List;+import org.keycloak.models.ClientModel;+import org.keycloak.models.Constants;+import org.keycloak.representations.idm.ClientRepresentation;++public abstract class AbstractClientConfigWrapper {",Minor: Formatting of this class should use 4 space indentation instead of 2.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10603,821408206,2022-03-08T08:00:16Z,services/src/main/java/org/keycloak/services/clientpolicy/context/ClientSecretRotationContext.java,"@@ -0,0 +1,31 @@+package org.keycloak.services.clientpolicy.context;++import org.keycloak.models.ClientModel;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.services.clientpolicy.ClientPolicyEvent;+import org.keycloak.services.resources.admin.AdminAuth;+import org.keycloak.utils.StringUtil;++public class ClientSecretRotationContext extends AdminClientUpdateContext {",Minor: Formatting of this class should use 4 space indentation instead of 2.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10581,821412420,2022-03-08T08:06:35Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/storage/database/jpa/AbstractJpaConnectionProviderFactory.java,"@@ -0,0 +1,115 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.storage.database.jpa;++import java.lang.annotation.Annotation;+import java.sql.Connection;+import java.sql.SQLException;+import java.util.Optional;+import javax.enterprise.inject.Instance;+import javax.persistence.EntityManager;+import javax.persistence.EntityManagerFactory;+import javax.persistence.EntityTransaction;",unused,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10581,821412603,2022-03-08T08:06:53Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/storage/database/jpa/AbstractJpaConnectionProviderFactory.java,"@@ -0,0 +1,115 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.storage.database.jpa;++import java.lang.annotation.Annotation;+import java.sql.Connection;+import java.sql.SQLException;+import java.util.Optional;+import javax.enterprise.inject.Instance;+import javax.persistence.EntityManager;+import javax.persistence.EntityManagerFactory;+import javax.persistence.EntityTransaction;+import javax.persistence.SynchronizationType;+import org.hibernate.internal.SessionFactoryImpl;+import org.keycloak.Config;+import org.keycloak.connections.jpa.JpaConnectionProviderFactory;+import org.keycloak.connections.jpa.JpaKeycloakTransaction;",unused,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10603,821417387,2022-03-08T08:13:26Z,services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientAccessTypeCondition.java,"@@ -74,6 +74,8 @@ public ClientPolicyVote applyPolicy(ClientPolicyContext context) throws ClientPo             case TOKEN_INTROSPECT:             case USERINFO_REQUEST:             case LOGOUT_REQUEST:+            case UPDATED:","I think it is completely fine for now to just stick with `ClientRolesCondition` . We can possibly wait for more feedback or add as a followup to handle use-cases like for example ""Use client secret rotation for all clients handled only by OIDC dynamic client registration"", but no strong need for this IMO.FYI. You can take a look at sources of the condition classes or https://www.keycloak.org/docs/latest/server_admin/index.html#conditionSo I am fine with resolve this comment and just leave it as you did in this PR.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10629,821725374,2022-03-08T14:37:29Z,model/jpa/src/main/resources/META-INF/jpa-changelog-18.0.0.xml,"@@ -0,0 +1,27 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2022 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->+<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++    <changeSet author=""keycloak"" id=""18.0.0-KEYCLOAK-10625-IDX_ADMIN_EVENT_TIME"">+        <!-- improve loading time of admin event list -->+        <createIndex tableName=""ADMIN_EVENT_ENTITY"" indexName=""IDX_ADMIN_EVENT_TIME"">+            <column name=""ADMIN_EVENT_TIME"" type=""DESC""/>","This index only indexes the column ADMIN_EVENT_TIME, and when I compare it with for example EVENT_ENTITY a similar index indexes also the REALM_ID. ```create or replace index IDX_EVENT_TIME    on keycloak.EVENT_ENTITY (REALM_ID, EVENT_TIME);``` Did you consider adding the REALM_ID as a first column to the index like for the other table?",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10572,821749766,2022-03-08T15:01:05Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/lock/LiquibaseDBLockProviderFactory.java,"@@ -74,4 +77,14 @@ public String getId() {     public int order() {         return PROVIDER_PRIORITY;     }++    @Override+    public List<ProviderConfigProperty> getConfigMetadata() {+        return ProviderConfigurationBuilder.create()+                .property()+                .name(""openid-configuration-override"")+                .type(""string"")+                .helpText(""The file path from where the metadata should be loaded from. You can use an absolute file path or, if the file is in the server classpath, use the 'classpath:' prefix to load the file from the classpath."")","```suggestion                .name(""lockWaitTimeout"")                .type(""int"")                .helpText(""The maximum time to wait when waiting to release a database lock."")```",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10572,821761878,2022-03-08T15:12:18Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCWellKnownProviderFactory.java,"@@ -88,6 +91,24 @@ public int getPriority() {         return 100;     } +    @Override+    public List<ProviderConfigProperty> getConfigMetadata() {+        return ProviderConfigurationBuilder.create()+                .property()+                .name(""lockWaitTimeout"")+                .type(""long"")+                .helpText(""The maximum time to wait when waiting to release a database lock."")+                .defaultValue(900L)","```suggestion                .name(""openid-configuration-override"")                .type(""string"")                .helpText(""The file path from where the metadata should be loaded from. You can use an absolute file path or, if the file is in the server classpath, use the 'classpath:' prefix to load the file from the classpath."")```",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10653,821896629,2022-03-08T17:24:08Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -41,11 +41,13 @@ import javax.inject.Inject; import java.util.List; import java.util.Optional;+import java.util.concurrent.TimeUnit;  import static io.javaoperatorsdk.operator.api.reconciler.Constants.NO_FINALIZER; import static io.javaoperatorsdk.operator.api.reconciler.Constants.WATCH_CURRENT_NAMESPACE; -@ControllerConfiguration(namespaces = WATCH_CURRENT_NAMESPACE, finalizerName = NO_FINALIZER)+// TODO: remove ""generationAwareEventProcessing = false"" when the race condition is fixed+@ControllerConfiguration(namespaces = WATCH_CURRENT_NAMESPACE, finalizerName = NO_FINALIZER, generationAwareEventProcessing = false)","This is the key change, disabling `generationAwareEventProcessing` workaround the race condition we found.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10653,821964688,2022-03-08T18:45:15Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -84,26 +86,35 @@         // TODO use caches in secondary resources; this is a workaround for https://github.com/java-operator-sdk/java-operator-sdk/issues/830         // KeycloakDeployment deployment = new KeycloakDeployment(client, config, kc, context.getSecondaryResource(Deployment.class).orElse(null));         var kcDeployment = new KeycloakDeployment(client, config, kc, null);-        kcDeployment.updateStatus(statusBuilder);+        var deploymentReady = kcDeployment.updateStatus(statusBuilder);         kcDeployment.createOrUpdateReconciled();          var kcService = new KeycloakService(client, kc);-        kcService.updateStatus(statusBuilder);+        var serviceReady = kcService.updateStatus(statusBuilder);         kcService.createOrUpdateReconciled();         var kcDiscoveryService = new KeycloakDiscoveryService(client, kc);-        kcDiscoveryService.updateStatus(statusBuilder);+        var discoveryServiceReady = kcDiscoveryService.updateStatus(statusBuilder);         kcDiscoveryService.createOrUpdateReconciled();          var status = statusBuilder.build();          Log.info(""--- Reconciliation finished successfully"");+        var ready = deploymentReady && serviceReady && discoveryServiceReady;          if (status.equals(kc.getStatus())) {-            return UpdateControl.noUpdate();+            if (ready) {+                return UpdateControl.noUpdate();+            } else {+                return UpdateControl.<Keycloak>noUpdate().rescheduleAfter(10, TimeUnit.SECONDS);+            }         }         else {             kc.setStatus(status);-            return UpdateControl.updateStatus(kc);+            if (ready) {+                return UpdateControl.updateStatus(kc);+            } else {+                return UpdateControl.updateStatus(kc).rescheduleAfter(10, TimeUnit.SECONDS);+            }","> I presume we need these ugly ifs because of `generationAwareEventProcessing = false`. Correct?No, this is just hardening the logic for retrying the reconciliation.> So we're effectively managing the reconciliation loop and relying on time checks instead of events? That means the CRs are not watched any more?No, this change simply means: ""if we know that there is additional processing to be done from the operator we install a fail-safe temporal fallback"".You can read more about [here](https://javaoperatorsdk.io/docs/features) in the section ""Retry and Rescheduling and Event Handling Common Behavior""> What if the deployment fails suddenly? The operator would not know.We should keep relying on events, and we can possibly remove those safe-nets later on in the development.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10589,822379377,2022-03-09T08:05:39Z,model/infinispan/src/main/java/org/keycloak/cluster/infinispan/InfinispanClusterProviderFactory.java,"@@ -196,6 +195,12 @@ public String getId() {          @ViewChanged         public void viewChanged(ViewChangedEvent event) {+            if (localExecutor.isShutdown()) {",Should we check this also before this line?https://github.com/keycloak/keycloak/blob/7335abaf08915d364f16667733237aa8ac8a3b0f/model/infinispan/src/main/java/org/keycloak/cluster/infinispan/InfinispanClusterProvider.java#L112,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10429,822700324,2022-03-09T14:23:17Z,model/map/src/main/java/org/keycloak/models/map/authorization/MapAuthorizationStoreFactory.java,"@@ -54,7 +55,7 @@     @Override     public StoreFactory create(KeycloakSession session) {         MapStorageProviderFactory storageProviderFactory = (MapStorageProviderFactory) getComponentFactory(session.getKeycloakSessionFactory(),-          MapStorageProvider.class, storageConfigScope, MapStorageSpi.NAME);+          MapStorageProvider.class, storageConfigScope, MapStorageSpi.NAME, ""authorizationPersister"");","Right now it is coming from the [SPI](https://github.com/keycloak/keycloak/blob/main/server-spi-private%2Fsrc%2Fmain%2Fjava%2Forg%2Fkeycloak%2Fauthorization%2Fstore%2FStoreFactorySpi.java#L31) name. For authorization the different areas are not currently separated, they are all initialized to use the same storage factory. I don't know if we will change that in the future so that the different authz models will be configurable independently with respect to the storage factory, but for now they all share the same so I decided to use the SPI name.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/10648,823346326,2022-03-10T04:52:38Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/AcrProtocolMapper.java,"@@ -0,0 +1,132 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ *+ */++package org.keycloak.protocol.oidc.mappers;++import java.util.ArrayList;+import java.util.HashMap;+import java.util.List;+import java.util.Map;++import org.jboss.logging.Logger;+import org.keycloak.authentication.authenticators.util.LoAUtil;+import org.keycloak.common.Profile;+import org.keycloak.models.AuthenticatedClientSessionModel;+import org.keycloak.models.ClientSessionContext;+import org.keycloak.models.Constants;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ProtocolMapperModel;+import org.keycloak.models.UserSessionModel;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.utils.AcrUtils;+import org.keycloak.provider.EnvironmentDependentProviderFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.representations.IDToken;+import org.keycloak.services.managers.AuthenticationManager;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class AcrProtocolMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper, OIDCIDTokenMapper, EnvironmentDependentProviderFactory {++    private static final Logger logger = Logger.getLogger(AcrProtocolMapper.class);++    private static final List<ProviderConfigProperty> configProperties = new ArrayList<>();++    static {+        OIDCAttributeMapperHelper.addIncludeInTokensConfig(configProperties, AcrProtocolMapper.class);+    }++    public static final String PROVIDER_ID = ""oidc-acr-mapper"";+++    public List<ProviderConfigProperty> getConfigProperties() {+        return configProperties;+    }++    @Override+    public String getId() {+        return PROVIDER_ID;+    }++    @Override+    public String getDisplayType() {+        return ""Authentication Context Class Reference (ACR)"";+    }++    @Override+    public String getDisplayCategory() {+        return TOKEN_MAPPER_CATEGORY;+    }++    @Override+    public String getHelpText() {+        return ""Maps the achieved LoA (Level of Authentication) to the 'acr' claim of the token"";+    }++    @Override+    protected void setClaim(IDToken token, ProtocolMapperModel mappingModel, UserSessionModel userSession, KeycloakSession keycloakSession,+                            ClientSessionContext clientSessionCtx) {+        AuthenticatedClientSessionModel clientSession = clientSessionCtx.getClientSession();+        String acr = getAcr(clientSession);+        token.setAcr(acr);+    }++    public static ProtocolMapperModel create(String name, boolean accessToken, boolean idToken) {+        ProtocolMapperModel mapper = new ProtocolMapperModel();+        mapper.setName(name);+        mapper.setProtocolMapper(PROVIDER_ID);+        mapper.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);+        Map<String, String> config = new HashMap<>();+        if (accessToken) config.put(OIDCAttributeMapperHelper.INCLUDE_IN_ACCESS_TOKEN, ""true"");+        if (idToken) config.put(OIDCAttributeMapperHelper.INCLUDE_IN_ID_TOKEN, ""true"");+        mapper.setConfig(config);+        return mapper;+    }++    protected String getAcr(AuthenticatedClientSessionModel clientSession) {+        int loa = LoAUtil.getCurrentLevelOfAuthentication(clientSession);+        logger.tracef(""Loa level when authenticated to client %s: %d"", clientSession.getClient().getClientId(), loa);+        if (loa < Constants.MINIMUM_LOA) {+            loa = AuthenticationManager.isSSOAuthentication(clientSession) ? 0 : 1;+        }++        Map<String, Integer> acrLoaMap = AcrUtils.getAcrLoaMap(clientSession.getClient());+        String acr = AcrUtils.mapLoaToAcr(loa, acrLoaMap, AcrUtils.getRequiredAcrValues(+                clientSession.getNote(OIDCLoginProtocol.CLAIMS_PARAM)));+        if (acr == null) {+            acr = AcrUtils.mapLoaToAcr(loa, acrLoaMap, AcrUtils.getAcrValues(+                    clientSession.getNote(OIDCLoginProtocol.CLAIMS_PARAM),+                    clientSession.getNote(OIDCLoginProtocol.ACR_PARAM), clientSession.getClient()));+            if (acr == null) {+                acr = AcrUtils.mapLoaToAcr(loa, acrLoaMap, acrLoaMap.keySet());+                if (acr == null) {+                    acr = String.valueOf(loa);+                }+            }+        }+","L112-L122 can be rewritten as follows but I'm not sure which is better.```        // some comments        if (acr == null) {            acr = AcrUtils.mapLoaToAcr(loa, acrLoaMap, AcrUtils.getAcrValues(                    clientSession.getNote(OIDCLoginProtocol.CLAIMS_PARAM),                    clientSession.getNote(OIDCLoginProtocol.ACR_PARAM), clientSession.getClient()));        }        // some comments        if (acr == null) {                acr = AcrUtils.mapLoaToAcr(loa, acrLoaMap, acrLoaMap.keySet());        }        // some comments        if (acr == null) {                acr = String.valueOf(loa);        }```Or by using Optional.ofNullable().orElse() chain.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10661,823425703,2022-03-10T07:43:04Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakAdminSecret.java,"@@ -0,0 +1,57 @@+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.Secret;+import io.fabric8.kubernetes.api.model.SecretBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.utils.KubernetesResourceUtil;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.nio.charset.StandardCharsets;+import java.util.Base64;+import java.util.Optional;+import java.util.UUID;++public class KeycloakAdminSecret extends OperatorManagedResource {++    private final Keycloak kc;+    private final String secretName;+    private final Base64.Encoder base64Encoder = Base64.getEncoder();++    public KeycloakAdminSecret(KubernetesClient client, Keycloak keycloak) {+        super(client, keycloak);+        this.kc = keycloak;+        this.secretName = KubernetesResourceUtil.sanitizeName(getName() + ""-admin"");","```suggestion        this.secretName = KubernetesResourceUtil.sanitizeName(kc.getMetadata().getName() + ""-initial-admin"");```",
43614225,ioemat,https://api.github.com/repos/keycloak/keycloak/pulls/10629,823448623,2022-03-10T08:13:06Z,model/jpa/src/main/resources/META-INF/jpa-changelog-18.0.0.xml,"@@ -0,0 +1,27 @@+<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>+<!--+  ~ * Copyright 2022 Red Hat, Inc. and/or its affiliates+  ~ * and other contributors as indicated by the @author tags.+  ~ *+  ~ * Licensed under the Apache License, Version 2.0 (the ""License"");+  ~ * you may not use this file except in compliance with the License.+  ~ * You may obtain a copy of the License at+  ~ *+  ~ * http://www.apache.org/licenses/LICENSE-2.0+  ~ *+  ~ * Unless required by applicable law or agreed to in writing, software+  ~ * distributed under the License is distributed on an ""AS IS"" BASIS,+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+  ~ * See the License for the specific language governing permissions and+  ~ * limitations under the License.+  -->+<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd"">++    <changeSet author=""keycloak"" id=""18.0.0-KEYCLOAK-10625-IDX_ADMIN_EVENT_TIME"">+        <!-- improve loading time of admin event list -->+        <createIndex tableName=""ADMIN_EVENT_ENTITY"" indexName=""IDX_ADMIN_EVENT_TIME"">+            <column name=""ADMIN_EVENT_TIME"" type=""DESC""/>","You're right, it makes totally sense to add the realm as well, I added it.I also changed the index to make it as similar as possible to the index in `IDX_EVENT_TIME`",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10683,823822053,2022-03-10T15:09:04Z,.github/workflows/release-container.yml,"@@ -0,0 +1,45 @@+  name: Release Keycloak container+  on:+    workflow_dispatch:+    push:+      tags:+        - '[0-9]+.[0-9]+.[0-9]+'+  jobs:+    publish:+      if: github.repository == 'keycloak/keycloak'+      runs-on: ubuntu-latest+      steps:+      - name: Checkout+        uses: actions/checkout@v2++      - name: Set up QEMU+        uses: docker/setup-qemu-action@v1+        +      - name: Set up Docker Buildx+        uses: docker/setup-buildx-action@v1+        +      - name: Container metadata","Didn't knew about this `metadata-action` but looks great!Talking about the implementation, from what I understand from the [documentation](https://github.com/docker/metadata-action#typesemver), this assumes a tag to be in the form: `v1.2.3` and not `1.2.3`, have you tested it without the `v` prefix already?If this is the case you might want to tune the filtering regexp [here](https://github.com/keycloak/keycloak/pull/10683/files#diff-69a4610cce35bf32d579cc8d14aa59de81d80d23f0269d80861bceb81f57b176R6).",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10648,823842161,2022-03-10T15:27:11Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCLoginProtocolFactory.java,"@@ -191,6 +194,9 @@ public LoginProtocol create(KeycloakSession session) {          model = UserRealmRoleMappingMapper.create(null, GROUPS, GROUPS, true, true, true);         builtins.put(GROUPS, model);++        model = AcrProtocolMapper.create(ACR, true, true);","Good point.Currently the protocol mapper is hidden in the UI when the feature is disabled. However the client scope cannot be easily hidden (assuming that it was already created) as there is no way to conditionally hide any client scope when some feature is enabled/disabled and I don't think it is possible to easily do it without any hacks...What I can do is, that when new realm is going to be created (or during migration) and ""acr"" feature is disabled, then the ""acr"" client scope (including protocol mapper) won't be created. This means that when administrator later decides to enable the feature, he will need to create client scope (and protocol mapper) manually. This is something, which will need to be documented (I can change the docs PR for this as well).However the opposite case (when feature is first enabled and then disabled) still means that ""acr"" client scope will be created and visible. So for example scenario like this:- Feature is enabled- New realm is created. This will create ""acr"" client scope with protocol mapper- Administrator decides to disable the feature and restart server- Now the ""acr"" client scope will still be visible to administrator. But protocol mapper is not visible to the administrator (due the provider is disabled). So administrator will need to delete the ""acr"" client scope if he wants this completely removed.I am slightly towards to change it in a way that at the time of the creation, the ""acr"" client scope will be created based on whether the feature is enabled or disabled at the time of the creation. WDYT?",
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/10680,824458073,2022-03-11T07:40:39Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -230,138 +302,260 @@ class SigningInPage extends React.Component<SigningInPageProps, SigningInPageSta         }          return (-            <React.Fragment key='userCredentials'> {-                userCredentials.map(credential => (-                    <DataListItem id={`${SigningInPage.credElementId(type, credential.id, 'row')}`} key={'credential-list-item-' + credential.id} aria-labelledby={'credential-list-item-' + credential.userLabel}>-                        <DataListItemRow key={'userCredentialRow-' + credential.id}>-                            <DataListItemCells dataListCells={this.credentialRowCells(credential, type)}/>--                            <CredentialAction credential={credential}-                                              removeable={removeable}-                                              updateAction={updateAIA}-                                              credRemover={this.handleRemove}/>-                        </DataListItemRow>-                    </DataListItem>-                ))+            <React.Fragment key='userCredentialMetadatas'>+              {"" ""}+              {userCredentialMetadatas.map(credentialMetadata => (+                <DataList aria-label={'credential-list-item-' + credentialMetadata.credential.userLabel}>+                  <DataListItem id={`${SigningInPage.credElementId(type, credentialMetadata.credential.id, 'row')}`} key={'credential-list-item-' + credentialMetadata.credential.id} aria-labelledby={'credential-list-item-' + credentialMetadata.credential.userLabel}>+                      <DataListItemRow key={'userCredentialRow-' + credentialMetadata.credential.id} className=""pf-u-align-items-center"">+                          <DataListItemCells dataListCells={this.credentialRowCells(credentialMetadata, type)}/>+                          <CredentialAction+                              credential={credentialMetadata.credential}+                              removeable={removeable}+                              updateAction={updateAIA}+                              credRemover={this.handleRemove}+                          />+                      </DataListItemRow>+                  </DataListItem>+                </DataList>+              ))             }             </React.Fragment>)     } -    private credentialRowCells(credential: UserCredential, type: string): React.ReactNode[] {+    private credentialRowCells(credMetadata: CredMetadata, type: string): React.ReactNode[] {         const credRowCells: React.ReactNode[] = [];-        credRowCells.push(<DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id}>{credential.userLabel}</DataListCell>);+        const credential = credMetadata.credential;+        const infoMessage = credMetadata.infoMessage ? JSON.parse(credMetadata.infoMessage) : null;+        const warningMessageTitle = credMetadata.warningMessageTitle ? JSON.parse(credMetadata.warningMessageTitle) : null;+        const warningMessageDescription = credMetadata.warningMessageDescription ? JSON.parse(credMetadata.warningMessageDescription) : null;+        let maxWidth = { ""--pf-u-max-width--MaxWidth"": ""300px"" } as React.CSSProperties;+        credRowCells.push(+            <DataListCell id={`${SigningInPage.credElementId(type, credential.id, 'label')}`} key={'userLabel-' + credential.id} className=""pf-u-max-width"" style={maxWidth}>+                {credential.userLabel}+                {infoMessage &&+                    <div>{Msg.localize(infoMessage.key, infoMessage.parameters)}</div>+                }+                {warningMessageTitle &&+                    <>+                        <br />+                        <div className=""pf-c-alert pf-m-warning pf-m-inline"" aria-label=""Success alert"">+                            <div className=""pf-c-alert__icon"">+                                <i className=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+                            </div>+                            <h4 className=""pf-c-alert__title"">+                                <span className=""pf-screen-reader"">Warning alert:</span>+                                {Msg.localize(warningMessageTitle.key, warningMessageTitle.parameters)}+                            </h4>+                            {credMetadata.warningMessageDescription &&+                                <div className=""pf-c-alert__description"">+                                    {Msg.localize(warningMessageDescription.key, warningMessageDescription.parameters)}+                                </div>+                            }+                        </div>",Why not use a patternfly react Alert component here?,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10683,824586288,2022-03-11T10:31:19Z,.github/workflows/release-container.yml,"@@ -0,0 +1,47 @@+  name: Release Keycloak container+  on:+    workflow_dispatch:+    push:+      tags:+        - '[0-9]+.[0-9]+.[0-9]+'+  concurrency: keycloak-container-release++  jobs:+    publish:+      if: github.repository == 'keycloak/keycloak'+      runs-on: ubuntu-latest+      steps:+      - name: Checkout+        uses: actions/checkout@v2++      - name: Set up QEMU+        uses: docker/setup-qemu-action@v1+        +      - name: Set up Docker Buildx+        uses: docker/setup-buildx-action@v1+        +      - name: Container metadata+        id: meta+        uses: docker/metadata-action@v3+        with:+          images: quay.io/keycloak/keycloak+          tags: |+            type=ref,event=branch+            type=semver,pattern={{version}}+            type=semver,pattern={{major}}.{{minor}}++      - name: Login to Quay+        uses: docker/login-action@v1+        with:+          registry: quay.io+          username: ${{ secrets.QUAY_USERNAME }}+          password: ${{ secrets.QUAY_TOKEN }}++      - name: Build and push+        uses: docker/build-push-action@v2+        with:+          context: quarkus/container+          platforms: linux/amd64,linux/arm64+          push: ${{ github.event_name != 'pull_request' }}",This condition is always `true` do you see any usage of this Job from PRs?,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10680,824626767,2022-03-11T11:26:02Z,themes/src/main/resources/theme/base/login/login-recovery-authn-code-config.ftl,"@@ -0,0 +1,184 @@+<#import ""template.ftl"" as layout>+<@layout.registrationLayout; section>++<#if section = ""header"">+    ${msg(""recovery-code-config-header"")}+<#elseif section = ""form"">+    <!-- warning -->+    <div class=""pf-c-alert pf-m-warning pf-m-inline ${properties.kcRecoveryCodesWarning}"" aria-label=""Warning alert"">+        <div class=""pf-c-alert__icon"">+            <i class=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+        </div>+        <h4 class=""pf-c-alert__title"">+            <span class=""pf-screen-reader"">Warning alert:</span>+            ${msg(""recovery-code-config-warning-title"")}+        </h4>+        <div class=""pf-c-alert__description"">+            <p>${msg(""recovery-code-config-warning-message"")}</p>+        </div>+    </div>++    <ol id=""kc-recovery-codes-list"" class=""${properties.kcRecoveryCodesList!}"">+        <#list recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesList as code>+            <li><span>${code?counter}:</span> ${code[0..3]}-${code[4..7]}-${code[8..]}</li>+        </#list>+    </ol>++    <!-- actions -->+    <div class=""${properties.kcRecoveryCodesActions}"">+        <button id=""printRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-print""></i> ${msg(""recovery-codes-print"")}+        </button>+        <button id=""downloadRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-save""></i> ${msg(""recovery-codes-download"")}+        </button>+        <button id=""copyRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-blueprint""></i> ${msg(""recovery-codes-copy"")}+        </button>+    </div>++    <!-- confirmation checkbox -->+    <div class=""${properties.kcCheckClass} ${properties.kcRecoveryCodesConfirmation}"">+        <input class=""${properties.kcCheckInputClass}"" type=""checkbox"" id=""kcRecoveryCodesConfirmationCheck"" name=""kcRecoveryCodesConfirmationCheck"" +        onchange=""document.getElementById('saveRecoveryAuthnCodesBtn').disabled = !this.checked;""+        />+        <label class=""${properties.kcCheckLabelClass}"" for=""kcRecoveryCodesConfirmationCheck"">${msg(""recovery-codes-confirmation-message"")}</label>+    </div>++    <form action=""${url.loginAction}"" class=""${properties.kcFormClass!}"" id=""kc-recovery-codes-settings-form"" method=""post"">+        <input type=""hidden"" name=""generatedRecoveryAuthnCodes"" value=""${recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesAsString}"" />+        <input type=""hidden"" name=""generatedAt"" value=""${recoveryAuthnCodesConfigBean.generatedAt?c}"" />+        <input type=""hidden"" name=""userLabel"" value="" "" />++        <#if isAppInitiatedAction??>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+            <button type=""submit""+                class=""${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!} ${properties.kcButtonLargeClass!}""+                id=""cancelRecoveryAuthnCodesBtn"" name=""cancel-aia"" value=""true"" />${msg(""recovery-codes-action-cancel"")}+            </button>+        <#else>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+        </#if>+    </form>++    <script>+        /* copy recovery codes  */+        function copyRecoveryCodes() {+            var tmpTextarea = document.createElement(""textarea"");+            var codes = document.getElementById(""kc-recovery-codes-list"").getElementsByTagName(""li"");+            for (i = 0; i < codes.length; i++) {+                tmpTextarea.value = tmpTextarea.value + codes[i].innerText + ""\n"";+            }+            document.body.appendChild(tmpTextarea);+            tmpTextarea.select();+            document.execCommand(""copy"");+            document.body.removeChild(tmpTextarea);+        }",The `execCommand()` method is [deprecated](https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand) and should not be used and should not be used any longer. Instead you can use the newer [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API).Since this action can also fail due to lack of the correct permissions to access the clipboard (or the user denying these permission) you should also notify the user somehow that copying to the clipboard was successful or not.It also looks like there is already a function called `parseRecoveryCodeList()` that you can re-use to get the text value.Putting that all together:```jsasync function copyRecoveryCodes() {  const text = parseRecoveryCodeList();  try {    await navigator.clipboard.writeText(text);    // TODO: Notify user that copying was successful.  } catch (error) {    // TODO: Notify user that copying was unsuccessful.  }}```,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10680,824630741,2022-03-11T11:31:40Z,themes/src/main/resources/theme/base/login/login-recovery-authn-code-config.ftl,"@@ -0,0 +1,184 @@+<#import ""template.ftl"" as layout>+<@layout.registrationLayout; section>++<#if section = ""header"">+    ${msg(""recovery-code-config-header"")}+<#elseif section = ""form"">+    <!-- warning -->+    <div class=""pf-c-alert pf-m-warning pf-m-inline ${properties.kcRecoveryCodesWarning}"" aria-label=""Warning alert"">+        <div class=""pf-c-alert__icon"">+            <i class=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+        </div>+        <h4 class=""pf-c-alert__title"">+            <span class=""pf-screen-reader"">Warning alert:</span>+            ${msg(""recovery-code-config-warning-title"")}+        </h4>+        <div class=""pf-c-alert__description"">+            <p>${msg(""recovery-code-config-warning-message"")}</p>+        </div>+    </div>++    <ol id=""kc-recovery-codes-list"" class=""${properties.kcRecoveryCodesList!}"">+        <#list recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesList as code>+            <li><span>${code?counter}:</span> ${code[0..3]}-${code[4..7]}-${code[8..]}</li>+        </#list>+    </ol>++    <!-- actions -->+    <div class=""${properties.kcRecoveryCodesActions}"">+        <button id=""printRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-print""></i> ${msg(""recovery-codes-print"")}+        </button>+        <button id=""downloadRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-save""></i> ${msg(""recovery-codes-download"")}+        </button>+        <button id=""copyRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-blueprint""></i> ${msg(""recovery-codes-copy"")}+        </button>+    </div>++    <!-- confirmation checkbox -->+    <div class=""${properties.kcCheckClass} ${properties.kcRecoveryCodesConfirmation}"">+        <input class=""${properties.kcCheckInputClass}"" type=""checkbox"" id=""kcRecoveryCodesConfirmationCheck"" name=""kcRecoveryCodesConfirmationCheck"" +        onchange=""document.getElementById('saveRecoveryAuthnCodesBtn').disabled = !this.checked;""+        />+        <label class=""${properties.kcCheckLabelClass}"" for=""kcRecoveryCodesConfirmationCheck"">${msg(""recovery-codes-confirmation-message"")}</label>+    </div>++    <form action=""${url.loginAction}"" class=""${properties.kcFormClass!}"" id=""kc-recovery-codes-settings-form"" method=""post"">+        <input type=""hidden"" name=""generatedRecoveryAuthnCodes"" value=""${recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesAsString}"" />+        <input type=""hidden"" name=""generatedAt"" value=""${recoveryAuthnCodesConfigBean.generatedAt?c}"" />+        <input type=""hidden"" name=""userLabel"" value="" "" />++        <#if isAppInitiatedAction??>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+            <button type=""submit""+                class=""${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!} ${properties.kcButtonLargeClass!}""+                id=""cancelRecoveryAuthnCodesBtn"" name=""cancel-aia"" value=""true"" />${msg(""recovery-codes-action-cancel"")}+            </button>+        <#else>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+        </#if>+    </form>++    <script>+        /* copy recovery codes  */+        function copyRecoveryCodes() {+            var tmpTextarea = document.createElement(""textarea"");+            var codes = document.getElementById(""kc-recovery-codes-list"").getElementsByTagName(""li"");+            for (i = 0; i < codes.length; i++) {+                tmpTextarea.value = tmpTextarea.value + codes[i].innerText + ""\n"";+            }+            document.body.appendChild(tmpTextarea);+            tmpTextarea.select();+            document.execCommand(""copy"");+            document.body.removeChild(tmpTextarea);+        }++        var copyButton = document.getElementById(""copyRecoveryCodes"");+        copyButton && copyButton.addEventListener(""click"", function () {+            copyRecoveryCodes();+        });",Why do we need to do defensive coding here? I don't see under which conditions this element would not be found as it's defined in the same document.,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10680,824639153,2022-03-11T11:44:55Z,themes/src/main/resources/theme/base/login/login-recovery-authn-code-config.ftl,"@@ -0,0 +1,184 @@+<#import ""template.ftl"" as layout>+<@layout.registrationLayout; section>++<#if section = ""header"">+    ${msg(""recovery-code-config-header"")}+<#elseif section = ""form"">+    <!-- warning -->+    <div class=""pf-c-alert pf-m-warning pf-m-inline ${properties.kcRecoveryCodesWarning}"" aria-label=""Warning alert"">+        <div class=""pf-c-alert__icon"">+            <i class=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+        </div>+        <h4 class=""pf-c-alert__title"">+            <span class=""pf-screen-reader"">Warning alert:</span>+            ${msg(""recovery-code-config-warning-title"")}+        </h4>+        <div class=""pf-c-alert__description"">+            <p>${msg(""recovery-code-config-warning-message"")}</p>+        </div>+    </div>++    <ol id=""kc-recovery-codes-list"" class=""${properties.kcRecoveryCodesList!}"">+        <#list recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesList as code>+            <li><span>${code?counter}:</span> ${code[0..3]}-${code[4..7]}-${code[8..]}</li>+        </#list>+    </ol>++    <!-- actions -->+    <div class=""${properties.kcRecoveryCodesActions}"">+        <button id=""printRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-print""></i> ${msg(""recovery-codes-print"")}+        </button>+        <button id=""downloadRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-save""></i> ${msg(""recovery-codes-download"")}+        </button>+        <button id=""copyRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-blueprint""></i> ${msg(""recovery-codes-copy"")}+        </button>+    </div>++    <!-- confirmation checkbox -->+    <div class=""${properties.kcCheckClass} ${properties.kcRecoveryCodesConfirmation}"">+        <input class=""${properties.kcCheckInputClass}"" type=""checkbox"" id=""kcRecoveryCodesConfirmationCheck"" name=""kcRecoveryCodesConfirmationCheck"" +        onchange=""document.getElementById('saveRecoveryAuthnCodesBtn').disabled = !this.checked;""+        />+        <label class=""${properties.kcCheckLabelClass}"" for=""kcRecoveryCodesConfirmationCheck"">${msg(""recovery-codes-confirmation-message"")}</label>+    </div>++    <form action=""${url.loginAction}"" class=""${properties.kcFormClass!}"" id=""kc-recovery-codes-settings-form"" method=""post"">+        <input type=""hidden"" name=""generatedRecoveryAuthnCodes"" value=""${recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesAsString}"" />+        <input type=""hidden"" name=""generatedAt"" value=""${recoveryAuthnCodesConfigBean.generatedAt?c}"" />+        <input type=""hidden"" name=""userLabel"" value="" "" />++        <#if isAppInitiatedAction??>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+            <button type=""submit""+                class=""${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!} ${properties.kcButtonLargeClass!}""+                id=""cancelRecoveryAuthnCodesBtn"" name=""cancel-aia"" value=""true"" />${msg(""recovery-codes-action-cancel"")}+            </button>+        <#else>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+        </#if>+    </form>++    <script>+        /* copy recovery codes  */+        function copyRecoveryCodes() {+            var tmpTextarea = document.createElement(""textarea"");+            var codes = document.getElementById(""kc-recovery-codes-list"").getElementsByTagName(""li"");+            for (i = 0; i < codes.length; i++) {+                tmpTextarea.value = tmpTextarea.value + codes[i].innerText + ""\n"";+            }+            document.body.appendChild(tmpTextarea);+            tmpTextarea.select();+            document.execCommand(""copy"");+            document.body.removeChild(tmpTextarea);+        }++        var copyButton = document.getElementById(""copyRecoveryCodes"");+        copyButton && copyButton.addEventListener(""click"", function () {+            copyRecoveryCodes();+        });++        /* download recovery codes  */+        function formatCurrentDateTime() {+            var dt = new Date();+            var options = {+                month: 'long',+                day: 'numeric',+                year: 'numeric',+                hour: 'numeric',+                minute: 'numeric',+                timeZoneName: 'short'+            };++            return dt.toLocaleString('en-US', options);+        }","This could be shortened this a bit by removing the intermediary variables.```jsfunction formatCurrentDateTime() {    return new Date().toLocaleString('en-US', {        month: 'long',        day: 'numeric',        year: 'numeric',        hour: 'numeric',        minute: 'numeric',        timeZoneName: 'short'    });}```We cannot assume that the user is in the United States so we should be formatting this date according to the configured locale. Perhaps we can use a Freemarker variable to do so? Something like:```js.toLocaleString('${user.peferedLocale}', { ... });```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10680,824647960,2022-03-11T11:55:46Z,themes/src/main/resources/theme/base/login/login-recovery-authn-code-config.ftl,"@@ -0,0 +1,184 @@+<#import ""template.ftl"" as layout>+<@layout.registrationLayout; section>++<#if section = ""header"">+    ${msg(""recovery-code-config-header"")}+<#elseif section = ""form"">+    <!-- warning -->+    <div class=""pf-c-alert pf-m-warning pf-m-inline ${properties.kcRecoveryCodesWarning}"" aria-label=""Warning alert"">+        <div class=""pf-c-alert__icon"">+            <i class=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+        </div>+        <h4 class=""pf-c-alert__title"">+            <span class=""pf-screen-reader"">Warning alert:</span>+            ${msg(""recovery-code-config-warning-title"")}+        </h4>+        <div class=""pf-c-alert__description"">+            <p>${msg(""recovery-code-config-warning-message"")}</p>+        </div>+    </div>++    <ol id=""kc-recovery-codes-list"" class=""${properties.kcRecoveryCodesList!}"">+        <#list recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesList as code>+            <li><span>${code?counter}:</span> ${code[0..3]}-${code[4..7]}-${code[8..]}</li>+        </#list>+    </ol>++    <!-- actions -->+    <div class=""${properties.kcRecoveryCodesActions}"">+        <button id=""printRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-print""></i> ${msg(""recovery-codes-print"")}+        </button>+        <button id=""downloadRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-save""></i> ${msg(""recovery-codes-download"")}+        </button>+        <button id=""copyRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-blueprint""></i> ${msg(""recovery-codes-copy"")}+        </button>+    </div>++    <!-- confirmation checkbox -->+    <div class=""${properties.kcCheckClass} ${properties.kcRecoveryCodesConfirmation}"">+        <input class=""${properties.kcCheckInputClass}"" type=""checkbox"" id=""kcRecoveryCodesConfirmationCheck"" name=""kcRecoveryCodesConfirmationCheck"" +        onchange=""document.getElementById('saveRecoveryAuthnCodesBtn').disabled = !this.checked;""+        />+        <label class=""${properties.kcCheckLabelClass}"" for=""kcRecoveryCodesConfirmationCheck"">${msg(""recovery-codes-confirmation-message"")}</label>+    </div>++    <form action=""${url.loginAction}"" class=""${properties.kcFormClass!}"" id=""kc-recovery-codes-settings-form"" method=""post"">+        <input type=""hidden"" name=""generatedRecoveryAuthnCodes"" value=""${recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesAsString}"" />+        <input type=""hidden"" name=""generatedAt"" value=""${recoveryAuthnCodesConfigBean.generatedAt?c}"" />+        <input type=""hidden"" name=""userLabel"" value="" "" />++        <#if isAppInitiatedAction??>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+            <button type=""submit""+                class=""${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!} ${properties.kcButtonLargeClass!}""+                id=""cancelRecoveryAuthnCodesBtn"" name=""cancel-aia"" value=""true"" />${msg(""recovery-codes-action-cancel"")}+            </button>+        <#else>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+        </#if>+    </form>++    <script>+        /* copy recovery codes  */+        function copyRecoveryCodes() {+            var tmpTextarea = document.createElement(""textarea"");+            var codes = document.getElementById(""kc-recovery-codes-list"").getElementsByTagName(""li"");+            for (i = 0; i < codes.length; i++) {+                tmpTextarea.value = tmpTextarea.value + codes[i].innerText + ""\n"";+            }+            document.body.appendChild(tmpTextarea);+            tmpTextarea.select();+            document.execCommand(""copy"");+            document.body.removeChild(tmpTextarea);+        }++        var copyButton = document.getElementById(""copyRecoveryCodes"");+        copyButton && copyButton.addEventListener(""click"", function () {+            copyRecoveryCodes();+        });++        /* download recovery codes  */+        function formatCurrentDateTime() {+            var dt = new Date();+            var options = {+                month: 'long',+                day: 'numeric',+                year: 'numeric',+                hour: 'numeric',+                minute: 'numeric',+                timeZoneName: 'short'+            };++            return dt.toLocaleString('en-US', options);+        }++        function parseRecoveryCodeList() {+            var recoveryCodes = document.querySelectorAll("".kc-recovery-codes-list li"");+            var recoveryCodeList = """";++            for (var i = 0; i < recoveryCodes.length; i++) {+                var recoveryCodeLiElement = recoveryCodes[i].innerText;+                recoveryCodeList += recoveryCodeLiElement + ""\r\n"";+            }++            return recoveryCodeList;+        }","You can shorten this function by using a `map()` and `join()` operation.```suggestion        function parseRecoveryCodeList() {            const recoveryCodes = document.querySelectorAll("".kc-recovery-codes-list li"");            return recoveryCodes.map((code) => code.innerText).join(""\r\n"");        }```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10680,824662839,2022-03-11T12:18:07Z,themes/src/main/resources/theme/base/login/login-recovery-authn-code-config.ftl,"@@ -0,0 +1,184 @@+<#import ""template.ftl"" as layout>+<@layout.registrationLayout; section>++<#if section = ""header"">+    ${msg(""recovery-code-config-header"")}+<#elseif section = ""form"">+    <!-- warning -->+    <div class=""pf-c-alert pf-m-warning pf-m-inline ${properties.kcRecoveryCodesWarning}"" aria-label=""Warning alert"">+        <div class=""pf-c-alert__icon"">+            <i class=""pficon-warning-triangle-o"" aria-hidden=""true""></i>+        </div>+        <h4 class=""pf-c-alert__title"">+            <span class=""pf-screen-reader"">Warning alert:</span>+            ${msg(""recovery-code-config-warning-title"")}+        </h4>+        <div class=""pf-c-alert__description"">+            <p>${msg(""recovery-code-config-warning-message"")}</p>+        </div>+    </div>++    <ol id=""kc-recovery-codes-list"" class=""${properties.kcRecoveryCodesList!}"">+        <#list recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesList as code>+            <li><span>${code?counter}:</span> ${code[0..3]}-${code[4..7]}-${code[8..]}</li>+        </#list>+    </ol>++    <!-- actions -->+    <div class=""${properties.kcRecoveryCodesActions}"">+        <button id=""printRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-print""></i> ${msg(""recovery-codes-print"")}+        </button>+        <button id=""downloadRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-save""></i> ${msg(""recovery-codes-download"")}+        </button>+        <button id=""copyRecoveryCodes"" class=""pf-c-button pf-m-link"" type=""button"">+            <i class=""pficon-blueprint""></i> ${msg(""recovery-codes-copy"")}+        </button>+    </div>++    <!-- confirmation checkbox -->+    <div class=""${properties.kcCheckClass} ${properties.kcRecoveryCodesConfirmation}"">+        <input class=""${properties.kcCheckInputClass}"" type=""checkbox"" id=""kcRecoveryCodesConfirmationCheck"" name=""kcRecoveryCodesConfirmationCheck"" +        onchange=""document.getElementById('saveRecoveryAuthnCodesBtn').disabled = !this.checked;""+        />+        <label class=""${properties.kcCheckLabelClass}"" for=""kcRecoveryCodesConfirmationCheck"">${msg(""recovery-codes-confirmation-message"")}</label>+    </div>++    <form action=""${url.loginAction}"" class=""${properties.kcFormClass!}"" id=""kc-recovery-codes-settings-form"" method=""post"">+        <input type=""hidden"" name=""generatedRecoveryAuthnCodes"" value=""${recoveryAuthnCodesConfigBean.generatedRecoveryAuthnCodesAsString}"" />+        <input type=""hidden"" name=""generatedAt"" value=""${recoveryAuthnCodesConfigBean.generatedAt?c}"" />+        <input type=""hidden"" name=""userLabel"" value="" "" />++        <#if isAppInitiatedAction??>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+            <button type=""submit""+                class=""${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!} ${properties.kcButtonLargeClass!}""+                id=""cancelRecoveryAuthnCodesBtn"" name=""cancel-aia"" value=""true"" />${msg(""recovery-codes-action-cancel"")}+            </button>+        <#else>+            <input type=""submit""+            class=""${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}""+            id=""saveRecoveryAuthnCodesBtn"" value=""${msg(""recovery-codes-action-complete"")}""+            disabled+            />+        </#if>+    </form>++    <script>+        /* copy recovery codes  */+        function copyRecoveryCodes() {+            var tmpTextarea = document.createElement(""textarea"");+            var codes = document.getElementById(""kc-recovery-codes-list"").getElementsByTagName(""li"");+            for (i = 0; i < codes.length; i++) {+                tmpTextarea.value = tmpTextarea.value + codes[i].innerText + ""\n"";+            }+            document.body.appendChild(tmpTextarea);+            tmpTextarea.select();+            document.execCommand(""copy"");+            document.body.removeChild(tmpTextarea);+        }++        var copyButton = document.getElementById(""copyRecoveryCodes"");+        copyButton && copyButton.addEventListener(""click"", function () {+            copyRecoveryCodes();+        });++        /* download recovery codes  */+        function formatCurrentDateTime() {+            var dt = new Date();+            var options = {+                month: 'long',+                day: 'numeric',+                year: 'numeric',+                hour: 'numeric',+                minute: 'numeric',+                timeZoneName: 'short'+            };++            return dt.toLocaleString('en-US', options);+        }++        function parseRecoveryCodeList() {+            var recoveryCodes = document.querySelectorAll("".kc-recovery-codes-list li"");+            var recoveryCodeList = """";++            for (var i = 0; i < recoveryCodes.length; i++) {+                var recoveryCodeLiElement = recoveryCodes[i].innerText;+                recoveryCodeList += recoveryCodeLiElement + ""\r\n"";+            }++            return recoveryCodeList;+        }++        function buildDownloadContent() {+            var recoveryCodeList = parseRecoveryCodeList();+            var dt = new Date();+            var options = {+                month: 'long',+                day: 'numeric',+                year: 'numeric',+                hour: 'numeric',+                minute: 'numeric',+                timeZoneName: 'short'+            };++            return fileBodyContent =+                ""${msg(""recovery-codes-download-file-header"")}\n\n"" ++                recoveryCodeList + ""\n"" ++                ""${msg(""recovery-codes-download-file-description"")}\n\n"" ++                ""${msg(""recovery-codes-download-file-date"")} "" + formatCurrentDateTime();+        }++        function setUpDownloadLinkAndDownload(filename, text) {+            var el = document.createElement('a');+            el.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));+            el.setAttribute('download', filename);+            el.style.display = 'none';+            document.body.appendChild(el);+            el.click();+            document.body.removeChild(el);+        }++        function downloadRecoveryCodes() {+            setUpDownloadLinkAndDownload('kc-download-recovery-codes.txt', buildDownloadContent());+        }++        var downloadButton = document.getElementById(""downloadRecoveryCodes"");+        downloadButton && downloadButton.addEventListener(""click"", downloadRecoveryCodes);++        /* print recovery codes */+        function buildPrintContent() {+            var recoveryCodeListHTML = document.getElementById('kc-recovery-codes-list').innerHTML;+            var styles =",This can be constant as well.```suggestion            const recoveryCodeListHTML = document.getElementById('kc-recovery-codes-list').innerHTML;            const styles =```,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10680,824786836,2022-03-11T14:53:36Z,themes/src/main/resources/theme/keycloak.v2/account/resources/public/patternfly-addons.css,"@@ -0,0 +1,9006 @@+.pf-u-screen-reader {",Is this file supposed to checked in? It is rather large so I feel like this is probably a dependency that should be included from a package.,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10680,824798856,2022-03-11T15:02:36Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/PageHeaderTool.tsx,"@@ -0,0 +1,27 @@+import * as React from 'react';++import {PageHeaderTools} from '@patternfly/react-core';+import {ReferrerLink} from './widgets/ReferrerLink';+import {LogoutButton} from './widgets/Logout';++declare const referrerName: string;++export class PageHeaderTool extends React.Component {","Class style components are on the way out, can you refactor this to a function component? See the [React documentation](https://reactjs.org/docs/components-and-props.html).",
402301,cescoffier,https://api.github.com/repos/keycloak/keycloak/pulls/10714,824871380,2022-03-11T16:22:11Z,integration/admin-client/src/main/java/org/keycloak/admin/client/Keycloak.java,"@@ -41,10 +42,27 @@  * @see KeycloakBuilder  */ public class Keycloak implements AutoCloseable {++    private static final ResteasyClientProvider CLIENT_PROVIDER;++    static {+        Iterator<ResteasyClientProvider> iterator = ServiceLoader.load(ResteasyClientProvider.class).iterator();","How is it intended to work as you have a declaration in this module? If we have a second provider on the classpath, it will fail (there is a check).If we exclude RESTEasy Classic from the classpath, it will fail to instantiate it.One solution would be to move the declaration to its own module. ",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10661,824963660,2022-03-11T18:20:19Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -246,4 +251,75 @@ public void testHostnameStrictDisabled() {         }     } +    // Reference curl command:+    // curl --insecure --data ""grant_type=password&client_id=admin-cli&username=admin&password=adminPassword"" https://localhost:8443/realms/master/protocol/openid-connect/token+    @Test+    public void testInitialAdminUser() {+        try {+            // Recreating the database to keep this test isolated+            deleteDB();+            deployDB();+            var kc = getDefaultKeycloakDeployment();+            deployKeycloak(k8sclient, kc, true);++            var decoder = Base64.getDecoder();+            var service = new KeycloakService(k8sclient, kc);+            var kcAdminSecret = new KeycloakAdminSecret(k8sclient, kc);++            AtomicReference<String> adminUsername = new AtomicReference<>();+            AtomicReference<String> adminPassword = new AtomicReference<>();+            Awaitility.await()+                    .ignoreExceptions()+                    .untilAsserted(() -> {+                        Log.info(""Checking secret, ns: "" + namespace + "", name: "" + kcAdminSecret.getName());+                        var adminSecret = k8sclient+                                .secrets()+                                .inNamespace(namespace)+                                .withName(kcAdminSecret.getName())+                                .get();++                        adminUsername.set(new String(decoder.decode(adminSecret.getData().get(""username"").getBytes(StandardCharsets.UTF_8))));+                        adminPassword.set(new String(decoder.decode(adminSecret.getData().get(""password"").getBytes(StandardCharsets.UTF_8))));++                        String url = ""https://"" + service.getName() + ""."" + namespace + "":"" + Constants.KEYCLOAK_HTTPS_PORT + ""/realms/master/protocol/openid-connect/token"";+                        Log.info(""Checking url: "" + url);++                        var curlOutput = K8sUtils.inClusterCurl(k8sclient, namespace, ""--insecure"", ""-s"", ""--data"", ""grant_type=password&client_id=admin-cli&username="" + adminUsername.get() + ""&password="" + adminPassword.get(), url);+                        Log.info(""Curl Output: "" + curlOutput);++                        assertTrue(curlOutput.contains(""\""access_token\""""));+                        assertTrue(curlOutput.contains(""\""token_type\"":\""Bearer\""""));+                    });++            // Redeploy the same Keycloak without redeploying the Database+            k8sclient.resource(kc).delete();",This `assertNotEquals` was intended to check for this condition:https://github.com/keycloak/keycloak/pull/10661/files#diff-6c9bb3849a00b8bf0ad94a582971f6335e9cefadd546187ac395cace155b2ecaR317do you feel is enough?,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10677,824968284,2022-03-11T18:27:18Z,operator/src/test/java/org/keycloak/operator/ClusterOperatorTest.java,"@@ -39,6 +39,7 @@   public static final String QUARKUS_KUBERNETES_DEPLOYMENT_TARGET = ""quarkus.kubernetes.deployment-target"";   public static final String OPERATOR_DEPLOYMENT_PROP = ""test.operator.deployment"";   public static final String TARGET_KUBERNETES_GENERATED_YML_FOLDER = ""target/kubernetes/"";+  public static final String QUARKUS_KUBERNETES_IP = ""quarkus.kubernetes.ip"";",Renaming it to `test.operator.kubernetes.ip`,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10677,824972853,2022-03-11T18:33:40Z,operator/src/test/java/org/keycloak/operator/KeycloakIngressE2EIT.java,"@@ -0,0 +1,71 @@+package org.keycloak.operator;++import io.fabric8.kubernetes.api.model.EnvVarBuilder;+import io.fabric8.kubernetes.api.model.apps.DeploymentSpecBuilder;+import io.quarkus.logging.Log;+import io.quarkus.test.junit.QuarkusTest;+import io.restassured.RestAssured;+import io.restassured.http.ContentType;+import org.awaitility.Awaitility;+import org.junit.jupiter.api.BeforeAll;+import org.junit.jupiter.api.Test;+import org.keycloak.operator.utils.K8sUtils;+import org.keycloak.operator.v2alpha1.KeycloakService;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.io.FileNotFoundException;+import java.time.Duration;+import java.util.Collections;+import java.util.List;+import java.util.Map;++import static org.assertj.core.api.Assertions.assertThat;+import static org.junit.jupiter.api.Assertions.assertEquals;+import static org.junit.jupiter.api.Assertions.assertTrue;+import static org.keycloak.operator.Constants.DEFAULT_LABELS;+import static org.keycloak.operator.utils.K8sUtils.*;++@QuarkusTest+public class KeycloakIngressE2EIT extends ClusterOperatorTest {",I do believe that is already tested here in the main `Deployment`:https://github.com/keycloak/keycloak/blob/ad865e75c14f048e2de6748bab6af6c3b495de33/operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java#L200-L247,
4374975,geoand,https://api.github.com/repos/keycloak/keycloak/pulls/10714,825803789,2022-03-14T10:36:16Z,integration/admin-client/src/main/java/org/keycloak/admin/client/Keycloak.java,"@@ -41,10 +42,27 @@  * @see KeycloakBuilder  */ public class Keycloak implements AutoCloseable {++    private static final ResteasyClientProvider CLIENT_PROVIDER;++    static {+        Iterator<ResteasyClientProvider> iterator = ServiceLoader.load(ResteasyClientProvider.class).iterator();","In Quarkus, we can exclude a classpath resource (in this case the service file), so this should work",
402301,cescoffier,https://api.github.com/repos/keycloak/keycloak/pulls/10714,825806474,2022-03-14T10:39:21Z,integration/admin-client/src/main/java/org/keycloak/admin/client/Keycloak.java,"@@ -41,10 +42,27 @@  * @see KeycloakBuilder  */ public class Keycloak implements AutoCloseable {++    private static final ResteasyClientProvider CLIENT_PROVIDER;++    static {+        Iterator<ResteasyClientProvider> iterator = ServiceLoader.load(ResteasyClientProvider.class).iterator();","Well, yes, but that's clearly a hack and we would also need to strip all the dependencies of that implementation.It would be so much better to fix it correctly here but move the provider into its own module.If you do not want to break, just declare an optional dependency on it, and we can exclude that dependency in Quarkus. It would be much better than removing a service file. ",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10716,826013954,2022-03-14T14:32:15Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -87,8 +92,15 @@         // TODO use caches in secondary resources; this is a workaround for https://github.com/java-operator-sdk/java-operator-sdk/issues/830         // KeycloakDeployment deployment = new KeycloakDeployment(client, config, kc, context.getSecondaryResource(Deployment.class).orElse(null));         var kcDeployment = new KeycloakDeployment(client, config, kc, null);-        kcDeployment.updateStatus(statusBuilder);+        var watchedSecrets = new WatchedSecretsStore(kcDeployment.getConfigSecretsNames(), client, kc);+         kcDeployment.createOrUpdateReconciled();+        if (watchedSecrets.changesDetected()) {","this can be a little bit more generic and not bound to the `WatchedSecretsStore`:- add a ""Waiting for rolling restart"" (or something alike) in the Status- read it before setting the new status- apply it if necessarySince this PR is already big enough we can eventually tackle this in a follow up PR.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10716,826018386,2022-03-14T14:36:11Z,operator/src/main/java/org/keycloak/operator/Constants.java,"@@ -26,6 +26,7 @@     public static final String PLURAL_NAME = ""keycloaks"";     public static final String MANAGED_BY_LABEL = ""app.kubernetes.io/managed-by"";     public static final String MANAGED_BY_VALUE = ""keycloak-operator"";+    public static final String TYPE_LABEL = Constants.CRDS_GROUP + ""/type"";","Reading through the PR I'm confused about what this `type` stands for, what do you think about re-using some default kubernetes labels, [e.g.](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/):```app.kubernetes.io/component```or even `part-of` for the watched secrets:```app.kubernetes.io/part-of```",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10716,826026804,2022-03-14T14:43:36Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -451,44 +464,40 @@ private Deployment createBaseDeployment() {         addInitContainer(baseDeployment, keycloakCR.getSpec().getExtensions());         mergePodTemplate(baseDeployment.getSpec().getTemplate()); -//        Set<String> configSecretsNames = new HashSet<>();-//        List<EnvVar> configEnvVars = serverConfig.entrySet().stream()-//                .map(e -> {-//                    EnvVarBuilder builder = new EnvVarBuilder().withName(e.getKey());-//                    Matcher matcher = CONFIG_SECRET_PATTERN.matcher(e.getValue());-//                    // check if given config var is actually a secret reference-//                    if (matcher.matches()) {-//                        builder.withValueFrom(-//                                new EnvVarSourceBuilder()-//                                        .withNewSecretKeyRef(matcher.group(2), matcher.group(1), false)-//                                        .build());-//                        configSecretsNames.add(matcher.group(1)); // for watching it later-//                    } else {-//                        builder.withValue(e.getValue());-//                    }-//                    builder.withValue(e.getValue());-//                    return builder.build();-//                })-//                .collect(Collectors.toList());-//        container.setEnv(configEnvVars);-//        this.configSecretsNames = Collections.unmodifiableSet(configSecretsNames);-//        Log.infof(""Found config secrets names: %s"", configSecretsNames);-         return baseDeployment;     }      private List<EnvVar> getEnvVars() {-        var serverConfig = new HashMap<>(Constants.DEFAULT_DIST_CONFIG);-        serverConfig.put(""jgroups.dns.query"", getName() + Constants.KEYCLOAK_DISCOVERY_SERVICE_SUFFIX +""."" + getNamespace());+        // default config values+        Map<String, ValueOrSecret> serverConfig = Constants.DEFAULT_DIST_CONFIG.entrySet().stream()+                .collect(Collectors.toMap(Map.Entry::getKey, e -> new ValueOrSecret(e.getValue())));+        serverConfig.put(""jgroups.dns.query"",+                new ValueOrSecret(getName() + Constants.KEYCLOAK_DISCOVERY_SERVICE_SUFFIX +""."" + getNamespace()));++        // merge with the CR         if (keycloakCR.getSpec().getServerConfiguration() != null) {             serverConfig.putAll(keycloakCR.getSpec().getServerConfiguration());         }-        return serverConfig.entrySet().stream()-                .map(e -> new EnvVarBuilder()-                        .withName(e.getKey())-                        .withValue(e.getValue())-                        .build())++        // set env vars+        serverConfigSecretsNames = new HashSet<>();+        List<EnvVar> envVars = serverConfig.entrySet().stream()+                .map(e -> {+                    var envBuilder = new EnvVarBuilder().withName(e.getKey());+                    if (e.getValue().getSecret() != null) {+                        envBuilder.withValueFrom(+                                new EnvVarSourceBuilder().withSecretKeyRef(e.getValue().getSecret()).build());+                        serverConfigSecretsNames.add(e.getValue().getSecret().getName()); // for watching it later+                    }","nitpick, this is the second time that I see this formatting of `if / else`, in Java, the ""idiomatic"" syntax places `else` [right after the closing bracket](https://www.w3schools.com/java/java_conditions.asp).",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10716,826030248,2022-03-14T14:46:34Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -510,13 +519,27 @@ public void updateStatus(KeycloakStatusBuilder status) {                 || existingDeployment.getStatus().getReadyReplicas() == null                 || existingDeployment.getStatus().getReadyReplicas() < keycloakCR.getSpec().getInstances()) {             status.addNotReadyMessage(""Waiting for more replicas"");-            return;","this `NotReady` condition can be overridden by the following ""Progressing""?if that's the case can you move this block above and return early?",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10716,826060126,2022-03-14T15:12:42Z,operator/src/main/java/org/keycloak/operator/v2alpha1/WatchedSecretsStore.java,"@@ -0,0 +1,237 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.Secret;+import io.fabric8.kubernetes.api.model.SecretBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.informers.SharedIndexInformer;+import io.fabric8.kubernetes.client.utils.Serialization;+import io.javaoperatorsdk.operator.processing.event.ResourceID;+import io.javaoperatorsdk.operator.processing.event.source.EventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.InformerEventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.Mappers;+import io.quarkus.logging.Log;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.math.BigInteger;+import java.nio.charset.StandardCharsets;+import java.security.MessageDigest;+import java.security.NoSuchAlgorithmException;+import java.util.Base64;+import java.util.Collections;+import java.util.List;+import java.util.Map;+import java.util.Optional;+import java.util.Set;+import java.util.stream.Collectors;++/**+ * Represents a version store of Secrets that are watched by a CR but is not owned by it. E.g. Secrets with+ * credentials provided by user.+ *+ * It is backed by a Secret which holds a list of watched Secrets together with their last observed version. It marks+ * all the watched Secrets with a label indicating which CRs are watching that resource.+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public class WatchedSecretsStore extends OperatorManagedResource {+    public static final String TYPE = ""secrets-store"";+    public static final String TYPE_WATCHED = ""watched-secret"";+    public static final String STORE_SUFFIX = ""-"" + TYPE;++    private final Secret existingStore; // a Secret to store the last observed versions++    // key is name of the secret+    private final Map<String, String> lastObservedVersions;+    private final Map<String, String> currentVersions;+    private final Set<Secret> currentSecrets;++    public WatchedSecretsStore(Set<String> desiredWatchedSecretsNames, KubernetesClient client, Keycloak kc) {+        super(client, kc);+        existingStore = fetchExistingStore();+        lastObservedVersions = getNewLastObservedVersions();+        currentSecrets = fetchCurrentSecrets(desiredWatchedSecretsNames);+        currentVersions = getNewCurrentVersions();+    }++    /**+     * @return true if any of the watched Secrets was changed, false otherwise (incl. if it's a newly watched Secret)+     */+    public boolean changesDetected() {+        return currentVersions.entrySet().stream().anyMatch(e -> {+            String prevVersion = lastObservedVersions.get(e.getKey());+            return prevVersion != null && !prevVersion.equals(e.getValue());+        });+    }++    @Override+    protected Optional<HasMetadata> getReconciledResource() {+        Secret secret = existingStore != null ? existingStore : getNewStore();+        secret.setData(null);+        secret.setStringData(currentVersions);++        return Optional.of(secret);+    }++    @Override+    protected void setDefaultLabels(HasMetadata resource) {+        super.setDefaultLabels(resource);+        resource.getMetadata().getLabels().put(Constants.TYPE_LABEL, TYPE);+    }++    @Override+    public void createOrUpdateReconciled() {+        super.createOrUpdateReconciled();+        addLabelsToWatchedSecrets();+    }++    public void addLabelsToWatchedSecrets() {+        for (Secret secret : currentSecrets) {+            if (secret.getMetadata() == null+                    || secret.getMetadata().getLabels() == null+                    || !secret.getMetadata().getLabels().containsKey(Constants.TYPE_LABEL)) {++                Log.infof(""Adding label to Secret \""%s\"""", secret.getMetadata().getName());++                secret = new SecretBuilder(secret)+                        .editMetadata()+                        .addToLabels(Constants.TYPE_LABEL, TYPE_WATCHED)+                        .endMetadata()+                        .build();++                client.secrets().patch(secret);+            }+        }+    }++    private Secret fetchExistingStore() {+        return client.secrets().inNamespace(getNamespace()).withName(getName()).get();+    }++    private Secret getNewStore() {+        return new SecretBuilder()+                .withNewMetadata()+                    .withName(getName())+                    .withNamespace(getNamespace())+                .endMetadata()+                .build();+    }++    private Map<String, String> getNewLastObservedVersions() {+        if (existingStore != null && existingStore.getData() != null) {+            return existingStore.getData().entrySet().stream()+                    .collect(Collectors.toMap(+                            Map.Entry::getKey,+                            e -> new String(Base64.getDecoder().decode(e.getValue()))+                    ));+        }+        else {+            return Collections.emptyMap();+        }+    }++    private Map<String, String> getNewCurrentVersions() {+        return currentSecrets.stream()+                .collect(Collectors.toMap(s -> s.getMetadata().getName(), this::getSecretVersion));+    }++    private String getSecretVersion(Secret secret) {+        String serializedData = Serialization.asYaml(secret.getData());+        try {+            // using hashes as it's more robust than resource versions that can change e.g. just when adding a label+            byte[] bytes = MessageDigest.getInstance(""MD5"").digest(serializedData.getBytes(StandardCharsets.UTF_8));+            return new BigInteger(1, bytes).toString(16);+        }+        catch (NoSuchAlgorithmException e) {+            throw new RuntimeException(e);+        }+    }++    private Set<Secret> fetchCurrentSecrets(Set<String> secretsNames) {+        return secretsNames.stream()+                .map(n -> {+                    Secret secret = client.secrets().inNamespace(getNamespace()).withName(n).get();+                    if (secret == null) {+                        throw new IllegalStateException(""Secret "" + n + "" not found"");+                    }+                    return secret;+                })+                .collect(Collectors.toSet());+    }++    @Override+    public String getName() {+        return cr.getMetadata().getName() + STORE_SUFFIX;+    }++    public static EventSource getStoreEventSource(KubernetesClient client, String namespace) {+        SharedIndexInformer<Secret> informer =+                client.secrets()+                        .inNamespace(namespace)+                        .withLabel(Constants.TYPE_LABEL, TYPE)+                        .runnableInformer(0);++        return new InformerEventSource<>(informer, Mappers.fromOwnerReference()) {+            @Override+            public String name() {+                return ""watchedResourcesStoreEventSource"";+            }+        };+    }++    public static EventSource getWatchedSecretsEventSource(KubernetesClient client, String namespace) {+        SharedIndexInformer<Secret> informer =+                client.secrets()+                        .inNamespace(namespace)+                        .withLabel(Constants.TYPE_LABEL, TYPE_WATCHED)+                        .runnableInformer(0);++        return new InformerEventSource<>(informer, secret -> {+            // get all stores+            List<Secret> stores = client.secrets().inNamespace(namespace).withLabel(Constants.TYPE_LABEL, TYPE).list().getItems();++            // find all CR names that are watching this Secret+            var ret = stores.stream()+                    // check if any of the stores tracks this secret+                    .filter(store -> store.getData().containsKey(secret.getMetadata().getName()))+                    .map(store -> {+                        String crName = store.getMetadata().getName().split(STORE_SUFFIX)[0];+                        return new ResourceID(crName, namespace);+                    })+                    .collect(Collectors.toSet());++            if (ret.isEmpty()) {","I understand why you did it here, and the implementation is straightforward, but I need to ask you to separate this functionality from the informer computation, something on those lines:```javapublic static void cleanObsoleteLabels() {  client    .secrets()    .inNamespace(namespace)    .withLabel(Constants.TYPE_LABEL, TYPE)    .list()    .getItems()    .filter(store -> client.resources(Keycloak.class).inNamespace(namespace).withName(store.getMetadata().getName().split(STORE_SUFFIX)[0]).get() == null)    .forEach(s -> {... remove the label ...})}```",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10716,826061334,2022-03-14T15:13:51Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -87,8 +92,15 @@         // TODO use caches in secondary resources; this is a workaround for https://github.com/java-operator-sdk/java-operator-sdk/issues/830         // KeycloakDeployment deployment = new KeycloakDeployment(client, config, kc, context.getSecondaryResource(Deployment.class).orElse(null));         var kcDeployment = new KeycloakDeployment(client, config, kc, null);-        kcDeployment.updateStatus(statusBuilder);+        var watchedSecrets = new WatchedSecretsStore(kcDeployment.getConfigSecretsNames(), client, kc);+         kcDeployment.createOrUpdateReconciled();+        if (watchedSecrets.changesDetected()) {","Found out that we already have a separate condition: `rollingUpdate`, so please rely on it  ",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10716,826069258,2022-03-14T15:20:54Z,operator/src/main/java/org/keycloak/operator/v2alpha1/crds/KeycloakSpec.java,"@@ -29,7 +29,7 @@      private int instances = 1;     private String image;-    private Map<String, String> serverConfiguration;+    private Map<String, ValueOrSecret> serverConfiguration;","The expected `yaml` signature (to be aligned with other standard kubernetes resources) should be:```yaml- name: MYKEY  value: MYVALUE```and not:```yaml- MYKEY:    value: MYVALUE```This encoding will look more aligned to [env-vars](https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/#define-an-environment-variable-for-a-container), [secrets, volume mounts](https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod) and more.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10716,826077198,2022-03-14T15:27:46Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -246,4 +259,154 @@ public void testHostnameStrictDisabled() {         }     } +    @Test+    public void testConfigSecretsAreWatched() {+        try {+            // deploy single kc+            var kc1 = getDefaultKeycloakDeployment();+            kc1.getMetadata().setName(kc1.getMetadata().getName() + ""-1"");+            var kc2 = getDefaultKeycloakDeployment();+            kc2.getMetadata().setName(kc2.getMetadata().getName() + ""-2"");++            deployKeycloak(k8sclient, kc1, true);++            Log.info(""Checking labels on Secrets"");+            Secret dbSecret = getDbSecret();+            Secret tlsSecret = getTlsSecret();+            assertThat(dbSecret.getMetadata().getLabels()).containsEntry(Constants.TYPE_LABEL, WatchedSecretsStore.TYPE_WATCHED);+            assertThat(tlsSecret.getMetadata().getLabels()).containsEntry(Constants.TYPE_LABEL, WatchedSecretsStore.TYPE_WATCHED);++            Log.info(""Updating DB Secret, expecting restart"");+            testDeploymentRestarted(Set.of(kc1), Set.of(), () -> {+                dbSecret.getData().put(UUID.randomUUID().toString(), ""YmxhaGJsYWg="");+                k8sclient.secrets().createOrReplace(dbSecret);+            });++            Log.info(""Updating TLS Secret, expecting restart"");+            testDeploymentRestarted(Set.of(kc1), Set.of(), () -> {+                tlsSecret.getData().put(UUID.randomUUID().toString(), ""YmxhaGJsYWg="");+                k8sclient.secrets().createOrReplace(tlsSecret);+            });++            Log.info(""Updating DB Secret metadata, NOT expecting restart"");+            testDeploymentRestarted(Set.of(), Set.of(kc1), () -> {+                dbSecret.getMetadata().getLabels().put(UUID.randomUUID().toString(), ""YmxhaGJsYWg"");+                k8sclient.secrets().createOrReplace(dbSecret);+            });++            Log.info(""Deploying second KC"");+            deployKeycloak(k8sclient, kc2, true);++            Log.info(""Updating DB Secret, expecting restart of both KCs"");+            testDeploymentRestarted(Set.of(kc1, kc2), Set.of(), () -> {+                dbSecret.getData().put(UUID.randomUUID().toString(), ""YmxhaGJsYWg="");+                k8sclient.secrets().createOrReplace(dbSecret);+            });++            Log.info(""Updating KC1 to not to rely on DB Secret"");+            kc1.getSpec().getServerConfiguration().put(""KC_DB_USERNAME"", new ValueOrSecret(""postgres""));+            kc1.getSpec().getServerConfiguration().put(""KC_DB_PASSWORD"", new ValueOrSecret(""testpassword""));+            testDeploymentRestarted(Set.of(kc1), Set.of(kc2), () -> {+                deployKeycloak(k8sclient, kc1, false, false);+            });++            Log.info(""Updating DB Secret, expecting restart of just KC2"");+            testDeploymentRestarted(Set.of(kc2), Set.of(kc1), () -> {+                dbSecret.getData().put(UUID.randomUUID().toString(), ""YmxhaGJsYWg="");+                k8sclient.secrets().createOrReplace(dbSecret);+            });++            Log.info(""Deleting KC2"");+            k8sclient.resources(Keycloak.class).inNamespace(namespace).delete(kc2);+            Awaitility.await()+                    .untilAsserted(() -> assertThat(k8sclient.apps().deployments()+                            .inNamespace(namespace)+                            .withName(kc2.getMetadata().getName())+                            .get()).isNull());++            Log.info(""Trying to update DB Secret that is no longer needed by any CR"");+            testDeploymentRestarted(Set.of(), Set.of(kc1), () -> {+                dbSecret.getData().put(UUID.randomUUID().toString(), ""YmxhaGJsYWg="");+                k8sclient.secrets().createOrReplace(dbSecret);+            });++            Awaitility.await().untilAsserted(() -> {","This condition doesn't depend on the action right above, e.g. this should already be the case without the last DB secret update.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10677,826163339,2022-03-14T16:42:45Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakIngress.java,"@@ -0,0 +1,140 @@+/*+ * Copyright 2021 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.networking.v1.IngressBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.api.model.networking.v1.Ingress;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.StatusUpdater;+import org.keycloak.operator.v2alpha1.crds.Keycloak;+import org.keycloak.operator.v2alpha1.crds.KeycloakStatusBuilder;++import java.util.Optional;+import java.util.function.Function;++public class KeycloakIngress extends OperatorManagedResource implements StatusUpdater<KeycloakStatusBuilder> {++    private Ingress existingIngress;+    private final Keycloak keycloak;++    public KeycloakIngress(KubernetesClient client, Keycloak keycloakCR) {+        super(client, keycloakCR);+        this.keycloak = keycloakCR;+        this.existingIngress = fetchExistingIngress();+    }++    private <T> boolean checkField(Ingress ingress1, Ingress ingress2, Function<Ingress, T> selector) {+        try {+            return selector.apply(ingress1).equals(selector.apply(ingress2));+        } catch (NullPointerException npe) {+            return false;+        }+    }++    @Override+    protected Optional<HasMetadata> getReconciledResource() {+        var defaultIngress =newIngress();+        if (keycloak.getSpec().isDefaultIngressDisabled() && existingIngress != null) {+            client.network().v1().ingresses().delete(existingIngress);+            return Optional.empty();+        } else if (existingIngress == null) {+            return Optional.of(defaultIngress);+        } else if (+                !checkField(existingIngress, defaultIngress, i -> i.getMetadata().getAnnotations().get(""nginx.ingress.kubernetes.io/backend-protocol"")) ||+                !checkField(existingIngress, defaultIngress, i -> i.getSpec().getDefaultBackend().getService().getPort().getNumber()) ||+                !checkField(existingIngress, defaultIngress, i -> i.getSpec().getRules().get(0).getHttp().getPaths().get(0).getBackend().getService().getPort().getNumber()) ||+                !checkField(existingIngress, defaultIngress, i -> i.getSpec().getRules().get(0).getHost()) ||+                !checkField(existingIngress, defaultIngress, i -> i.getSpec().getRules().get(0).getHttp().getPaths().get(0).getBackend().getService().getName()) ||+                !checkField(existingIngress, defaultIngress, i -> i.getSpec().getDefaultBackend().getService().getName())+        ) {+            existingIngress.getMetadata().getAnnotations().putAll(existingIngress.getMetadata().getAnnotations());",Shouldn't it be:```suggestion            existingIngress.getMetadata().getAnnotations().putAll(defaultIngress.getMetadata().getAnnotations());```,
80815286,giacomoa,https://api.github.com/repos/keycloak/keycloak/pulls/10519,826684588,2022-03-15T08:10:22Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/UserInfoEndpoint.java,"@@ -25,14 +25,17 @@ import org.keycloak.common.ClientConnection; import org.keycloak.common.VerificationException; import org.keycloak.common.constants.ServiceAccountConstants;-import org.keycloak.crypto.SignatureProvider;-import org.keycloak.crypto.SignatureSignerContext;-import org.keycloak.crypto.SignatureVerifierContext;+import org.keycloak.crypto.*;","Hello @tnorimat, thanks for your feedback.My IDE (IntelliJ IDEA) seems to include wildcard automatically when imported class for a package is >=  5, I see there are other wildcard in the project with same convention (e.g org.keycloak.models.* in org.keycloak.models.cache.infinispan.RealmAdapter, java.util.* in org.keycloak.storage.ldap.idm.query.internal.LDAPQuery).Let me know if I need to provide a fix anyway or if you have further considerations. ",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10719,826764553,2022-03-15T09:40:51Z,.github/workflows/release-operator-container.yml,"@@ -0,0 +1,63 @@+name: Release Keycloak Operator container++on:+  workflow_dispatch:+  push:+    tags:+      - '[0-9]+.[0-9]+.[0-9]+'+concurrency: keycloak-operator-container-release++env:+  JDK_VERSION: 11++jobs:+  publish:+    if: github.repository == 'keycloak/keycloak'+    runs-on: ubuntu-latest+    steps:+      - name: Checkout+        uses: actions/checkout@v2+        +      - name: Container metadata+        id: meta+        uses: docker/metadata-action@v3+        with:+          images: quay.io/keycloak/keycloak-operator+          tags: |+            type=ref,event=branch+            type=semver,pattern={{version}}+            type=semver,pattern={{major}}.{{minor}}++      - name: Login to Quay+        uses: docker/login-action@v1+        with:+          registry: quay.io+          username: ${{ secrets.QUAY_USERNAME }}+          password: ${{ secrets.QUAY_TOKEN }}++      - uses: actions/setup-java@v1+        with:+          java-version: ${{ env.JDK_VERSION }}++      - name: Cache Maven packages+        id: cache+        uses: actions/cache@v2+        with:+          path: |+            ~/.m2/repository+          key: cache-1-${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}+          restore-keys: cache-1-${{ runner.os }}-m2++      - name: Build locally Keycloak artifacts to avoid depending on Maven+        run: |+          mvn clean install -DskipTests -DskipExamples -DskipTestsuite","Would prefer to just pull the actually released artefacts rather than building here. We could pull those directly from https://s01.oss.sonatype.org/ instead of Maven Central as they will be available there straight away. Since this is just a temporary solution until we move to the new release process I'm okay with this for now. However, building the whole of Keycloak just because you need keycloak-common is quite pointless. If you build the Operator with:`mvn -P operator -pl operator -am clean package`That should take care of building the Operator and the dependencies it needs.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10332,826956582,2022-03-15T13:13:34Z,model/map/src/main/java/org/keycloak/models/map/common/AbstractMapProviderFactory.java,"@@ -78,4 +78,8 @@ public void init(Scope config) {     public boolean isSupported() {         return Profile.isFeatureEnabled(Profile.Feature.MAP_STORAGE);     }++    public Scope getStorageConfigScope() {+        return storageConfigScope;+    }","I'm not sure this is the correct `scope` we would want to use. This only contains the `storage` config that is found inside the particular areas (`client`, `group`, etc). The final storage factory that is instantiated actually gets a `scope` that is broader than this - it combines the this area-specific config with the root config found in the `mapStorage` configuration (i.e. it falls back to the root config if a property is not defined in the area config). Also, if we go forward with multiple `profile`s for a particular storage, that would have to be taken into consideration as well.So wouldn't we want to use the actual scope that was used to init the storage factory instead?",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10748,826994845,2022-03-15T13:49:18Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/widgets/EmptyMessageState.tsx,"@@ -20,15 +20,14 @@ import {     EmptyStateVariant,     Title,     EmptyStateIcon,-    TitleLevel,     EmptyStateBody,-    IconProps, } from '@patternfly/react-core'  import { Msg } from './Msg';+import {SVGIconProps} from '@patternfly/react-icons/dist/esm/createIcon';  export interface EmptyMessageStateProps {-    icon: React.FunctionComponent<IconProps>;+    icon: React.ComponentClass<SVGIconProps>;",I think there is a type that describes both class and function components.```suggestion    icon: React.ComponentType<SVGIconProps>;```,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10748,827014973,2022-03-15T14:06:50Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/PageHeaderTool.tsx,"@@ -0,0 +1,27 @@+import * as React from 'react';++import {PageHeaderTools} from '@patternfly/react-core';+import {ReferrerLink} from './widgets/ReferrerLink';+import {LogoutButton} from './widgets/Logout';++declare const referrerName: string;++export class PageHeaderTool extends React.Component {","This could be a function component instead, class components are on the way out.",
507202,ssilvert,https://api.github.com/repos/keycloak/keycloak/pulls/8189,827493349,2022-03-15T23:21:22Z,themes/src/main/resources/theme/base/admin/resources/js/authz/authz-controller.js,"@@ -1213,90 +1213,129 @@ module.controller('ResourceServerPolicyScopeDetailCtrl', function($scope, $route                     });                 }             }+            $scope.applyToResourceType = function() {+                if ($scope.applyToResourceTypeFlag) {+                    $scope.selectedResource = null;+                } else {+                    $scope.policy.resourceType = null;+                }+                $scope.selectedScopes = [];+                $scope.changed = true;+            }         },          onInitUpdate : function(policy) {-            ResourceServerPolicy.resources({-                realm : $route.current.params.realm,-                client : client.id,-                id : policy.id-            }, function(resources) {-                if (resources.length > 0) {-                    for (i = 0; i < resources.length; i++) {-                        ResourceServerResource.get({-                            realm: $route.current.params.realm,-                            client: client.id,-                            rsrid: resources[0]._id,-                        }, function (resource) {-                            ResourceServerResource.query({+            if (!policy.resourceType) {","Instead of adding a long if-then-else clause, please break this code up into at least two new functions:```if (!policy.resourceType) {   functionA();} else {   functionB();}```",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10709,827781955,2022-03-16T09:14:30Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/authSession/HotRodRootAuthenticationSessionEntity.java,"@@ -0,0 +1,119 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.hotRod.authSession;++import org.infinispan.protostream.annotations.ProtoDoc;+import org.infinispan.protostream.annotations.ProtoField;+import org.keycloak.models.map.annotations.GenerateHotRodEntityImplementation;+import org.keycloak.models.map.authSession.MapAuthenticationSessionEntity;+import org.keycloak.models.map.authSession.MapRootAuthenticationSessionEntity;+import org.keycloak.models.map.common.UpdatableEntity;+import org.keycloak.models.map.storage.hotRod.common.AbstractHotRodEntity;+import org.keycloak.models.map.storage.hotRod.common.UpdatableHotRodEntityDelegateImpl;++import java.util.Collections;+import java.util.Objects;+import java.util.Optional;+import java.util.Set;++@GenerateHotRodEntityImplementation(+        implementInterface = ""org.keycloak.models.map.authSession.MapRootAuthenticationSessionEntity"",+        inherits = ""org.keycloak.models.map.storage.hotRod.authSession.HotRodRootAuthenticationSessionEntity.AbstractHotRodRootAuthenticationSessionEntityDelegate""+)+@ProtoDoc(""@Indexed"")+public class HotRodRootAuthenticationSessionEntity extends AbstractHotRodEntity {++    @ProtoField(number = 1, required = true)+    public int entityVersion = 1;++    @ProtoField(number = 2, required = true)+    public String id;++    @ProtoDoc(""@Field(index = Index.YES, store = Store.YES)"")+    @ProtoField(number = 3)+    public String realmId;++    @ProtoDoc(""@Field(index = Index.YES, store = Store.YES)"")+    @ProtoField(number = 4)+    public Integer timestamp;++    @ProtoField(number = 5)+    public Set<HotRodAuthenticationSessionEntity> authenticationSessions;++    public static abstract class AbstractHotRodRootAuthenticationSessionEntityDelegate extends UpdatableHotRodEntityDelegateImpl<HotRodRootAuthenticationSessionEntity> implements MapRootAuthenticationSessionEntity {++        @Override+        public String getId() {+            return getHotRodEntity().id;+        }++        @Override+        public void setId(String id) {+            HotRodRootAuthenticationSessionEntity entity = getHotRodEntity();+            if (entity.id != null) throw new IllegalStateException(""Id cannot be changed"");+            entity.id = id;+            entity.updated |= id != null;+        }++        @Override+        public Optional<MapAuthenticationSessionEntity> getAuthenticationSession(String tabId) {+            HotRodRootAuthenticationSessionEntity rootAuthSession = getHotRodEntity();+            if (rootAuthSession.authenticationSessions == null || rootAuthSession.authenticationSessions.isEmpty()) return Optional.empty();++            return rootAuthSession.authenticationSessions.stream()+                    .filter(as -> Objects.equals(as.tabId, tabId))+                    .findFirst()+                    .map(HotRodAuthenticationSessionEntityDelegate::new);+        }++        @Override+        public Boolean removeAuthenticationSession(String tabId) {+            HotRodRootAuthenticationSessionEntity rootAuthSession = getHotRodEntity();+            boolean removed = rootAuthSession.authenticationSessions != null &&+                    rootAuthSession.authenticationSessions.removeIf(c -> Objects.equals(c.tabId, tabId));+            rootAuthSession.updated |= removed;+            return removed;+        }++        @Override+        public boolean isUpdated() {+            HotRodRootAuthenticationSessionEntity rootAuthSession = getHotRodEntity();+            return rootAuthSession.updated ||+                    Optional.ofNullable(getAuthenticationSessions()).orElseGet(Collections::emptySet).stream().anyMatch(MapAuthenticationSessionEntity::isUpdated);+        }++        @Override+        public void clearUpdatedFlag() {+            HotRodRootAuthenticationSessionEntity rootAuthSession = getHotRodEntity();+            rootAuthSession.updated = false;+            Optional.ofNullable(getAuthenticationSessions()).orElseGet(Collections::emptySet).forEach(UpdatableEntity::clearUpdatedFlag);+        }++        abstract public <V> V deepClone(V obj);",This seems to be unused,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10709,827785053,2022-03-16T09:17:48Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/common/HotRodTypesUtils.java,"@@ -110,4 +112,14 @@ public static String getKey(HotRodUserConsentEntity hotRodUserConsentEntity) {     public static <T, V> Set<V> migrateSet(Set<T> p0, Function<T, V> migrator) {         return p0 == null ? null : p0.stream().map(migrator).collect(Collectors.toSet());     }++    public static HotRodAuthenticationSessionEntity createHotRodAuthenticationSessionEntityFromMapEntry(Map.Entry<String, MapAuthenticationSessionEntity> entry) {",This is unused after the change in `MapRootAuthenticationSession` Interface (`Map` -> `Set`).,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10770,828154374,2022-03-16T15:33:10Z,model/build-processor/src/main/java/org/keycloak/models/map/processor/AbstractGenerateEntityImplementationsProcessor.java,"@@ -215,6 +215,25 @@ protected String deepClone(TypeMirror fieldType, String parameterName) {         return ""deepClone("" + parameterName + "")"";     } +    protected String removeUndefined(TypeMirror fieldType, String parameterName) {+        TypeElement typeElement = elements.getTypeElement(types.erasure(fieldType).toString());+        boolean isMapType = isMapType(typeElement);+        TypeMirror collectionItemTypeMirror = getGenericsDeclaration(fieldType).get(isMapType ? 1 : 0);++        return parameterName + (isMapType ? "".values()"" : """") + "".removeIf(item -> "" + isUndefined(collectionItemTypeMirror, ""item"") + "")"";+    }++    protected String isUndefined(TypeMirror fieldType, String parameterName) {+        TypeElement typeElement = elements.getTypeElement(types.erasure(fieldType).toString());+        return parameterName  + "" == null"" + (+                isCollection(fieldType)+                ? "" || "" + parameterName + "".isEmpty()"" + (+                        !isMapType(typeElement)+                        ? "" || "" + parameterName + "".stream().allMatch(e -> "" + isUndefined(getGenericsDeclaration(fieldType).get(0), ""e"") + "")""+                        : """")+                : """");","It would be possible. We can even do it similarly as we do it within HotRod generator. We can have some util class with overloaded `isUndefined` method. This way we could even specify class specific undefined conditions e.g. `"""".equals(stringParameter.trim())`.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10716,828192396,2022-03-16T16:06:11Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -510,13 +519,27 @@ public void updateStatus(KeycloakStatusBuilder status) {                 || existingDeployment.getStatus().getReadyReplicas() == null                 || existingDeployment.getStatus().getReadyReplicas() < keycloakCR.getSpec().getInstances()) {             status.addNotReadyMessage(""Waiting for more replicas"");-            return;","IMO `NotReady` and `RollingUpdate` are not mutually exclusive. We can be rolling update regardless if the deployment is ready. At the same time, we are technically rolling update in new deployments that are waiting for more replicas.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10716,828202368,2022-03-16T16:15:04Z,operator/src/main/java/org/keycloak/operator/v2alpha1/WatchedSecretsStore.java,"@@ -0,0 +1,237 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.Secret;+import io.fabric8.kubernetes.api.model.SecretBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.informers.SharedIndexInformer;+import io.fabric8.kubernetes.client.utils.Serialization;+import io.javaoperatorsdk.operator.processing.event.ResourceID;+import io.javaoperatorsdk.operator.processing.event.source.EventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.InformerEventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.Mappers;+import io.quarkus.logging.Log;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.math.BigInteger;+import java.nio.charset.StandardCharsets;+import java.security.MessageDigest;+import java.security.NoSuchAlgorithmException;+import java.util.Base64;+import java.util.Collections;+import java.util.List;+import java.util.Map;+import java.util.Optional;+import java.util.Set;+import java.util.stream.Collectors;++/**+ * Represents a version store of Secrets that are watched by a CR but is not owned by it. E.g. Secrets with+ * credentials provided by user.+ *+ * It is backed by a Secret which holds a list of watched Secrets together with their last observed version. It marks+ * all the watched Secrets with a label indicating which CRs are watching that resource.+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public class WatchedSecretsStore extends OperatorManagedResource {+    public static final String TYPE = ""secrets-store"";+    public static final String TYPE_WATCHED = ""watched-secret"";+    public static final String STORE_SUFFIX = ""-"" + TYPE;++    private final Secret existingStore; // a Secret to store the last observed versions++    // key is name of the secret+    private final Map<String, String> lastObservedVersions;","For me as a non-native speaker is `lastObserverVersions` really most describing.   I'm not sure  to what current implementation are you referring. We're really observing versions (individually for each CR), even though technically hashes.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10716,828225219,2022-03-16T16:37:00Z,operator/src/main/java/org/keycloak/operator/Constants.java,"@@ -26,6 +26,7 @@     public static final String PLURAL_NAME = ""keycloaks"";     public static final String MANAGED_BY_LABEL = ""app.kubernetes.io/managed-by"";     public static final String MANAGED_BY_VALUE = ""keycloak-operator"";+    public static final String TYPE_LABEL = Constants.CRDS_GROUP + ""/type"";",+1 for using `app.kubernetes.io/component` for the store. But I believe the watched secrets should use a label unique to the KC operator not to interfere with other apps that might be using the same Secret.,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10770,828822666,2022-03-17T07:30:01Z,model/map/src/main/java/org/keycloak/models/map/common/UndefinedValuesUtils.java,"@@ -0,0 +1,50 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.common;++import java.util.Collection;+import java.util.Map;++public class UndefinedValuesUtils {","Given that this is a class in map.common package, this class and its methods deserve javadoc",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10716,829174346,2022-03-17T14:50:04Z,operator/src/main/java/org/keycloak/operator/v2alpha1/WatchedSecretsStore.java,"@@ -0,0 +1,237 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.operator.v2alpha1;++import io.fabric8.kubernetes.api.model.HasMetadata;+import io.fabric8.kubernetes.api.model.Secret;+import io.fabric8.kubernetes.api.model.SecretBuilder;+import io.fabric8.kubernetes.client.KubernetesClient;+import io.fabric8.kubernetes.client.informers.SharedIndexInformer;+import io.fabric8.kubernetes.client.utils.Serialization;+import io.javaoperatorsdk.operator.processing.event.ResourceID;+import io.javaoperatorsdk.operator.processing.event.source.EventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.InformerEventSource;+import io.javaoperatorsdk.operator.processing.event.source.informer.Mappers;+import io.quarkus.logging.Log;+import org.keycloak.operator.Constants;+import org.keycloak.operator.OperatorManagedResource;+import org.keycloak.operator.v2alpha1.crds.Keycloak;++import java.math.BigInteger;+import java.nio.charset.StandardCharsets;+import java.security.MessageDigest;+import java.security.NoSuchAlgorithmException;+import java.util.Base64;+import java.util.Collections;+import java.util.List;+import java.util.Map;+import java.util.Optional;+import java.util.Set;+import java.util.stream.Collectors;++/**+ * Represents a version store of Secrets that are watched by a CR but is not owned by it. E.g. Secrets with+ * credentials provided by user.+ *+ * It is backed by a Secret which holds a list of watched Secrets together with their last observed version. It marks+ * all the watched Secrets with a label indicating which CRs are watching that resource.+ *+ * @author Vaclav Muzikar <vmuzikar@redhat.com>+ */+public class WatchedSecretsStore extends OperatorManagedResource {+    public static final String TYPE = ""secrets-store"";+    public static final String TYPE_WATCHED = ""watched-secret"";+    public static final String STORE_SUFFIX = ""-"" + TYPE;++    private final Secret existingStore; // a Secret to store the last observed versions++    // key is name of the secret+    private final Map<String, String> lastObservedVersions;+    private final Map<String, String> currentVersions;+    private final Set<Secret> currentSecrets;++    public WatchedSecretsStore(Set<String> desiredWatchedSecretsNames, KubernetesClient client, Keycloak kc) {+        super(client, kc);+        existingStore = fetchExistingStore();+        lastObservedVersions = getNewLastObservedVersions();+        currentSecrets = fetchCurrentSecrets(desiredWatchedSecretsNames);+        currentVersions = getNewCurrentVersions();+    }++    /**+     * @return true if any of the watched Secrets was changed, false otherwise (incl. if it's a newly watched Secret)+     */+    public boolean changesDetected() {+        return currentVersions.entrySet().stream().anyMatch(e -> {","If `currentVersions.size() != lastObservedVersions.size()` that means that the user either used a Secret in the config that was not used before, or the opposite  removed a Secret from the config. In any case that means the config was changed (not the Secret itself). If the config was changed, the Deployment restart is implicitly done by K8s as the env vars list was changes.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10054,829742710,2022-03-18T07:15:21Z,docs/guides/src/main/server/db.adoc,"@@ -73,57 +72,66 @@ Database schema only accounts for Unicode strings in the following special field  * Descriptions of objects -Otherwise, characters are limited to those contained in database encoding which is often 8-bit. However, for some database systems, it is possible to enable UTF-8 encoding of Unicode characters and use full Unicode character set in all text fields. Often, this is counterbalanced by shorter maximum length of the strings than in case of 8-bit encodings.+Otherwise, characters are limited to those contained in database encoding, which is often 8-bit. However, for some database systems, you can enable UTF-8 encoding of Unicode characters and use the full Unicode character set in all text fields. For a given database, this choice might result in a shorter string length than the maximum string length supported by 8-bit encodings.","```suggestionOtherwise, characters are limited to those contained in database encoding, which is often 8-bit. However, for some database systems, you can enable UTF-8 encoding of Unicode characters and use the full Unicode character set in all text fields. For a given database, this choice might result in a shorter maximum string length than the maximum string length supported by 8-bit encodings.```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10054,829744063,2022-03-18T07:18:17Z,docs/guides/src/main/server/db.adoc,"@@ -73,57 +72,66 @@ Database schema only accounts for Unicode strings in the following special field  * Descriptions of objects -Otherwise, characters are limited to those contained in database encoding which is often 8-bit. However, for some database systems, it is possible to enable UTF-8 encoding of Unicode characters and use full Unicode character set in all text fields. Often, this is counterbalanced by shorter maximum length of the strings than in case of 8-bit encodings.+Otherwise, characters are limited to those contained in database encoding, which is often 8-bit. However, for some database systems, you can enable UTF-8 encoding of Unicode characters and use the full Unicode character set in all text fields. For a given database, this choice might result in a shorter string length than the maximum string length supported by 8-bit encodings. -Some of the databases require special settings to database and/or JDBC driver to be able to handle Unicode characters. Please find the settings for your database below. Note that if a database is listed here, it can still work properly provided it handles UTF-8 encoding properly both on the level of database and JDBC driver.+=== Configuring Unicode support for an Oracle database -Technically, the key criterion for Unicode support for all fields is whether the database allows setting of Unicode character set for VARCHAR and CHAR fields. If yes, there is a high chance that Unicode will be plausible, usually at the expense of field length. If it only supports Unicode in NVARCHAR and NCHAR fields, Unicode support for all text fields is unlikely as the server schema uses VARCHAR and CHAR fields extensively.+Unicode characters are supported in an Oracle database if the database was created with Unicode support in the VARCHAR and CHAR fields. For example, you configured AL32UTF8 as the database character set. In this case, the JDBC driver requires no special settings. -=== Oracle database+If the database character set was not created with Unicode support, you need to configure the JDBC driver to support Unicode characters in the special fields. You configure two properties. Note that you can configure these properties as system properties or as connection properties. -Unicode characters are properly handled provided the database was created with Unicode support in VARCHAR and CHAR fields (e.g. by using AL32UTF8 character set as the database character set). No special settings is needed for JDBC driver.+. Set `oracle.jdbc.defaultNChar` to `true`.+++[NOTE]+====+Setting this property might negatively impact performance. For more information, see the Oracle JDBC driver configuration documentation.+==== -If the database character set is not Unicode, then to use Unicode characters in the special fields, the JDBC driver needs to be configured with the connection property oracle.jdbc.defaultNChar set to true. It might be wise, though not strictly necessary, to also set the oracle.jdbc.convertNcharLiterals connection property to true. These properties can be set either as system properties or as connection properties. Please note that setting oracle.jdbc.defaultNChar may have negative impact on performance. For details, please refer to Oracle JDBC driver configuration documentation.+. Optionally, set `oracle.jdbc.convertNcharLiterals` to `true`. -=== Microsoft SQL Server database+=== Unicode support for a Microsoft SQL Server database -Unicode characters are properly handled only for the special fields. No special settings of JDBC driver or database is necessary.+Unicode characters are supported only for the special fields for a Microsoft SQL Server database. The JDBC driver and database require no special settings. -=== MySQL database+=== Configuring Unicode support for a MySQL database","Is the difference between > **Configuring** Unicode support for a MySQL databasehere and> Unicode support for a Microsoft SQL Server databasea few lines above intentional (note the missing ""Configuring"")?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10054,829749255,2022-03-18T07:29:17Z,docs/guides/src/main/server/db.adoc,"@@ -73,57 +72,66 @@ Database schema only accounts for Unicode strings in the following special field  * Descriptions of objects -Otherwise, characters are limited to those contained in database encoding which is often 8-bit. However, for some database systems, it is possible to enable UTF-8 encoding of Unicode characters and use full Unicode character set in all text fields. Often, this is counterbalanced by shorter maximum length of the strings than in case of 8-bit encodings.+Otherwise, characters are limited to those contained in database encoding, which is often 8-bit. However, for some database systems, you can enable UTF-8 encoding of Unicode characters and use the full Unicode character set in all text fields. For a given database, this choice might result in a shorter string length than the maximum string length supported by 8-bit encodings. -Some of the databases require special settings to database and/or JDBC driver to be able to handle Unicode characters. Please find the settings for your database below. Note that if a database is listed here, it can still work properly provided it handles UTF-8 encoding properly both on the level of database and JDBC driver.+=== Configuring Unicode support for an Oracle database -Technically, the key criterion for Unicode support for all fields is whether the database allows setting of Unicode character set for VARCHAR and CHAR fields. If yes, there is a high chance that Unicode will be plausible, usually at the expense of field length. If it only supports Unicode in NVARCHAR and NCHAR fields, Unicode support for all text fields is unlikely as the server schema uses VARCHAR and CHAR fields extensively.+Unicode characters are supported in an Oracle database if the database was created with Unicode support in the VARCHAR and CHAR fields. For example, you configured AL32UTF8 as the database character set. In this case, the JDBC driver requires no special settings. -=== Oracle database+If the database character set was not created with Unicode support, you need to configure the JDBC driver to support Unicode characters in the special fields. You configure two properties. Note that you can configure these properties as system properties or as connection properties.","It is the database, not character set, that needs to support Unicode.```suggestionIf the database was not created with Unicode support, you need to configure the JDBC driver to support Unicode characters in the special fields. You configure two properties. Note that you can configure these properties as system properties or as connection properties.```",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10054,829754341,2022-03-18T07:39:42Z,docs/guides/src/main/server/db.adoc,"@@ -73,57 +72,66 @@ Database schema only accounts for Unicode strings in the following special field  * Descriptions of objects -Otherwise, characters are limited to those contained in database encoding which is often 8-bit. However, for some database systems, it is possible to enable UTF-8 encoding of Unicode characters and use full Unicode character set in all text fields. Often, this is counterbalanced by shorter maximum length of the strings than in case of 8-bit encodings.+Otherwise, characters are limited to those contained in database encoding, which is often 8-bit. However, for some database systems, you can enable UTF-8 encoding of Unicode characters and use the full Unicode character set in all text fields. For a given database, this choice might result in a shorter string length than the maximum string length supported by 8-bit encodings. -Some of the databases require special settings to database and/or JDBC driver to be able to handle Unicode characters. Please find the settings for your database below. Note that if a database is listed here, it can still work properly provided it handles UTF-8 encoding properly both on the level of database and JDBC driver.+=== Configuring Unicode support for an Oracle database -Technically, the key criterion for Unicode support for all fields is whether the database allows setting of Unicode character set for VARCHAR and CHAR fields. If yes, there is a high chance that Unicode will be plausible, usually at the expense of field length. If it only supports Unicode in NVARCHAR and NCHAR fields, Unicode support for all text fields is unlikely as the server schema uses VARCHAR and CHAR fields extensively.+Unicode characters are supported in an Oracle database if the database was created with Unicode support in the VARCHAR and CHAR fields. For example, you configured AL32UTF8 as the database character set. In this case, the JDBC driver requires no special settings. -=== Oracle database+If the database character set was not created with Unicode support, you need to configure the JDBC driver to support Unicode characters in the special fields. You configure two properties. Note that you can configure these properties as system properties or as connection properties. -Unicode characters are properly handled provided the database was created with Unicode support in VARCHAR and CHAR fields (e.g. by using AL32UTF8 character set as the database character set). No special settings is needed for JDBC driver.+. Set `oracle.jdbc.defaultNChar` to `true`.+++[NOTE]+====+Setting this property might negatively impact performance. For more information, see the Oracle JDBC driver configuration documentation.+==== -If the database character set is not Unicode, then to use Unicode characters in the special fields, the JDBC driver needs to be configured with the connection property oracle.jdbc.defaultNChar set to true. It might be wise, though not strictly necessary, to also set the oracle.jdbc.convertNcharLiterals connection property to true. These properties can be set either as system properties or as connection properties. Please note that setting oracle.jdbc.defaultNChar may have negative impact on performance. For details, please refer to Oracle JDBC driver configuration documentation.+. Optionally, set `oracle.jdbc.convertNcharLiterals` to `true`. -=== Microsoft SQL Server database+=== Unicode support for a Microsoft SQL Server database -Unicode characters are properly handled only for the special fields. No special settings of JDBC driver or database is necessary.+Unicode characters are supported only for the special fields for a Microsoft SQL Server database. The JDBC driver and database require no special settings. -=== MySQL database+=== Configuring Unicode support for a MySQL database -Unicode characters are properly handled provided the database was created with Unicode support in VARCHAR and CHAR fields in the CREATE DATABASE command (e.g. by using utf8 character set as the default database character set in MySQL 5.5. Please note that utf8mb4 character set does not work due to different storage requirements to utf8 character set [1]). Note that in this case, length restriction to non-special fields does not apply because columns are created to accommodate given amount of characters, not bytes. If the database default character set does not allow storing Unicode, only the special fields allow storing Unicode values.+Unicode characters are supported in a MySQL database if the database was created with Unicode support in the VARCHAR and CHAR fields when using the CREATE DATABASE command. In other words, `utf8` was selected as the default database character set in MySQL 5.5.","This rewording is misleading. `utf8` is just one of the options for Unicode support in MSSQL, and while still valid, it is deprecated now. Also the version 5.5 is an example of MySQL version, not the one that is in any way suggested to be used, and now is rather old. That was the reason for the ""e.g."" in the original text.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10054,829756816,2022-03-18T07:44:20Z,docs/guides/src/main/server/db.adoc,"@@ -73,57 +72,66 @@ Database schema only accounts for Unicode strings in the following special field  * Descriptions of objects -Otherwise, characters are limited to those contained in database encoding which is often 8-bit. However, for some database systems, it is possible to enable UTF-8 encoding of Unicode characters and use full Unicode character set in all text fields. Often, this is counterbalanced by shorter maximum length of the strings than in case of 8-bit encodings.+Otherwise, characters are limited to those contained in database encoding, which is often 8-bit. However, for some database systems, you can enable UTF-8 encoding of Unicode characters and use the full Unicode character set in all text fields. For a given database, this choice might result in a shorter string length than the maximum string length supported by 8-bit encodings. -Some of the databases require special settings to database and/or JDBC driver to be able to handle Unicode characters. Please find the settings for your database below. Note that if a database is listed here, it can still work properly provided it handles UTF-8 encoding properly both on the level of database and JDBC driver.+=== Configuring Unicode support for an Oracle database -Technically, the key criterion for Unicode support for all fields is whether the database allows setting of Unicode character set for VARCHAR and CHAR fields. If yes, there is a high chance that Unicode will be plausible, usually at the expense of field length. If it only supports Unicode in NVARCHAR and NCHAR fields, Unicode support for all text fields is unlikely as the server schema uses VARCHAR and CHAR fields extensively.+Unicode characters are supported in an Oracle database if the database was created with Unicode support in the VARCHAR and CHAR fields. For example, you configured AL32UTF8 as the database character set. In this case, the JDBC driver requires no special settings. -=== Oracle database+If the database character set was not created with Unicode support, you need to configure the JDBC driver to support Unicode characters in the special fields. You configure two properties. Note that you can configure these properties as system properties or as connection properties. -Unicode characters are properly handled provided the database was created with Unicode support in VARCHAR and CHAR fields (e.g. by using AL32UTF8 character set as the database character set). No special settings is needed for JDBC driver.+. Set `oracle.jdbc.defaultNChar` to `true`.+++[NOTE]+====+Setting this property might negatively impact performance. For more information, see the Oracle JDBC driver configuration documentation.+==== -If the database character set is not Unicode, then to use Unicode characters in the special fields, the JDBC driver needs to be configured with the connection property oracle.jdbc.defaultNChar set to true. It might be wise, though not strictly necessary, to also set the oracle.jdbc.convertNcharLiterals connection property to true. These properties can be set either as system properties or as connection properties. Please note that setting oracle.jdbc.defaultNChar may have negative impact on performance. For details, please refer to Oracle JDBC driver configuration documentation.+. Optionally, set `oracle.jdbc.convertNcharLiterals` to `true`. -=== Microsoft SQL Server database+=== Unicode support for a Microsoft SQL Server database -Unicode characters are properly handled only for the special fields. No special settings of JDBC driver or database is necessary.+Unicode characters are supported only for the special fields for a Microsoft SQL Server database. The JDBC driver and database require no special settings. -=== MySQL database+=== Configuring Unicode support for a MySQL database -Unicode characters are properly handled provided the database was created with Unicode support in VARCHAR and CHAR fields in the CREATE DATABASE command (e.g. by using utf8 character set as the default database character set in MySQL 5.5. Please note that utf8mb4 character set does not work due to different storage requirements to utf8 character set [1]). Note that in this case, length restriction to non-special fields does not apply because columns are created to accommodate given amount of characters, not bytes. If the database default character set does not allow storing Unicode, only the special fields allow storing Unicode values.+Unicode characters are supported in a MySQL database if the database was created with Unicode support in the VARCHAR and CHAR fields when using the CREATE DATABASE command. In other words, `utf8` was selected as the default database character set in MySQL 5.5. -At the side of JDBC driver settings, it is necessary to add a connection property characterEncoding=UTF-8 to the JDBC connection settings.+The utf8mb4 character set is not supported due to different storage requirements for the utf8 character set [1]). In that situation, the length restriction on non-special fields does not apply because columns are created to accommodate the number of characters, not bytes.  If the database default character set does not allow Unicode storage, only the special fields allow storing Unicode values.","What does the [1] mean? Is it https://dev.mysql.com/doc/refman/8.0/en/alter-table.html#alter-table-character-set or https://issues.jboss.org/browse/KEYCLOAK-3873 that was [in the original text](https://github.com/keycloak/keycloak-documentation/blob/567ca00fe12dbfd22915e85f0cb7f6d53d67cbd9/topics/database/unicode-considerations.adoc)?```suggestionThe utf8mb4 character set is not supported due to different storage requirements for the utf8 character set, see MySQL documentation for details. In that situation, the length restriction on non-special fields does not apply because columns are created to accommodate the number of characters, not bytes.  If the database default character set does not allow Unicode storage, only the special fields allow storing Unicode values.```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10754,829846000,2022-03-18T09:51:40Z,docs/guides/src/main/server/importExport.adoc,"@@ -0,0 +1,101 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+    title=""Importing and Exporting Realms""+    summary=""An overview about how to import and export realms"">++In this guide, you are going to understand the different approaches for importing and exporting realms using JSON files.++== Exporting a Realm to a Directory++To export a realm, you can use the `export` command.++<@kc.export parameters=""--help""/>++To export a realm to a directory, you can use the `--dir <dir>` option.++<@kc.export parameters=""--dir <dir>""/>++When exporting realms to a directory, the server is going to create separate files for each realm being exported.++You are also able to configure how users are going to be exported by setting the `--users <strategy>` option. The values available for this+option are:++* *different_files*: Users export into different files subject to the maximum number of users per file. This is the default value for this option.++* *skip*: {project_name} skips exporting users.++* *realm_file*:  Users export to the same file with the realm settings. The file is similar to ""foo-realm.json"" with realm data and users.++* *same_file*:  Users export to the same file but different from the realm file. The result is similar to ""foo-realm.json"" with realm data and ""foo-users.json"" with users.","```suggestion* *same_file*:  All users are exported to one explicit file `<realm>-users.json`.  For a realm named ""foo"", you will get two files, ""foo-realm.json"" with realm data and ""foo-users.json"" with users.```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10754,829846562,2022-03-18T09:52:24Z,docs/guides/src/main/server/importExport.adoc,"@@ -0,0 +1,101 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+    title=""Importing and Exporting Realms""+    summary=""An overview about how to import and export realms"">++In this guide, you are going to understand the different approaches for importing and exporting realms using JSON files.++== Exporting a Realm to a Directory++To export a realm, you can use the `export` command.++<@kc.export parameters=""--help""/>++To export a realm to a directory, you can use the `--dir <dir>` option.++<@kc.export parameters=""--dir <dir>""/>++When exporting realms to a directory, the server is going to create separate files for each realm being exported.++You are also able to configure how users are going to be exported by setting the `--users <strategy>` option. The values available for this+option are:++* *different_files*: Users export into different files subject to the maximum number of users per file. This is the default value for this option.++* *skip*: {project_name} skips exporting users.++* *realm_file*:  Users export to the same file with the realm settings. The file is similar to ""foo-realm.json"" with realm data and users.","```suggestion* *realm_file*:  Users will be exported to the same file as the realm settings. For a realm named ""foo"", this would be ""foo-realm.json"" with realm data and users.```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10754,829920675,2022-03-18T11:38:06Z,docs/guides/src/main/server/importExport.adoc,"@@ -0,0 +1,101 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>++<@tmpl.guide+    title=""Importing and Exporting Realms""+    summary=""An overview about how to import and export realms"">++In this guide, you are going to understand the different approaches for importing and exporting realms using JSON files.++== Exporting a Realm to a Directory++To export a realm, you can use the `export` command.++<@kc.export parameters=""--help""/>++To export a realm to a directory, you can use the `--dir <dir>` option.++<@kc.export parameters=""--dir <dir>""/>++When exporting realms to a directory, the server is going to create separate files for each realm being exported.++You are also able to configure how users are going to be exported by setting the `--users <strategy>` option. The values available for this+option are:++* *different_files*: Users export into different files subject to the maximum number of users per file. This is the default value for this option.++* *skip*: {project_name} skips exporting users.++* *realm_file*:  Users export to the same file with the realm settings. The file is similar to ""foo-realm.json"" with realm data and users.++* *same_file*:  Users export to the same file but different from the realm file. The result is similar to ""foo-realm.json"" with realm data and ""foo-users.json"" with users.++If you are exporting users using the `different_files` strategy, you should also be able to set how many users per file you want by setting the `users-per-file` option. If not specified, the default value is `50`.++<@kc.export parameters=""--dir <dir> --users different_files --users-per-file 100""/>++== Exporting a Realm to a File++To export a realm to a file, you can use the `--file <file>` option.++<@kc.export parameters=""--file <file>""/>++When exporting realms to a file, the server is going to use the same file to store the configuration for all the realms being exported.","```suggestionWhen exporting realms to a file, keycloak will use the specified file to store all data for realms and users being exported.```",
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/10054,829934769,2022-03-18T12:00:40Z,docs/guides/src/main/server/db.adoc,"@@ -73,57 +72,66 @@ Database schema only accounts for Unicode strings in the following special field  * Descriptions of objects -Otherwise, characters are limited to those contained in database encoding which is often 8-bit. However, for some database systems, it is possible to enable UTF-8 encoding of Unicode characters and use full Unicode character set in all text fields. Often, this is counterbalanced by shorter maximum length of the strings than in case of 8-bit encodings.+Otherwise, characters are limited to those contained in database encoding, which is often 8-bit. However, for some database systems, you can enable UTF-8 encoding of Unicode characters and use the full Unicode character set in all text fields. For a given database, this choice might result in a shorter string length than the maximum string length supported by 8-bit encodings. -Some of the databases require special settings to database and/or JDBC driver to be able to handle Unicode characters. Please find the settings for your database below. Note that if a database is listed here, it can still work properly provided it handles UTF-8 encoding properly both on the level of database and JDBC driver.+=== Configuring Unicode support for an Oracle database -Technically, the key criterion for Unicode support for all fields is whether the database allows setting of Unicode character set for VARCHAR and CHAR fields. If yes, there is a high chance that Unicode will be plausible, usually at the expense of field length. If it only supports Unicode in NVARCHAR and NCHAR fields, Unicode support for all text fields is unlikely as the server schema uses VARCHAR and CHAR fields extensively.+Unicode characters are supported in an Oracle database if the database was created with Unicode support in the VARCHAR and CHAR fields. For example, you configured AL32UTF8 as the database character set. In this case, the JDBC driver requires no special settings. -=== Oracle database+If the database character set was not created with Unicode support, you need to configure the JDBC driver to support Unicode characters in the special fields. You configure two properties. Note that you can configure these properties as system properties or as connection properties. -Unicode characters are properly handled provided the database was created with Unicode support in VARCHAR and CHAR fields (e.g. by using AL32UTF8 character set as the database character set). No special settings is needed for JDBC driver.+. Set `oracle.jdbc.defaultNChar` to `true`.+++[NOTE]+====+Setting this property might negatively impact performance. For more information, see the Oracle JDBC driver configuration documentation.+==== -If the database character set is not Unicode, then to use Unicode characters in the special fields, the JDBC driver needs to be configured with the connection property oracle.jdbc.defaultNChar set to true. It might be wise, though not strictly necessary, to also set the oracle.jdbc.convertNcharLiterals connection property to true. These properties can be set either as system properties or as connection properties. Please note that setting oracle.jdbc.defaultNChar may have negative impact on performance. For details, please refer to Oracle JDBC driver configuration documentation.+. Optionally, set `oracle.jdbc.convertNcharLiterals` to `true`. -=== Microsoft SQL Server database+=== Unicode support for a Microsoft SQL Server database -Unicode characters are properly handled only for the special fields. No special settings of JDBC driver or database is necessary.+Unicode characters are supported only for the special fields for a Microsoft SQL Server database. The JDBC driver and database require no special settings. -=== MySQL database+=== Configuring Unicode support for a MySQL database","@hmlnarik  I agree the headings are inconsistent, but the goal is to be consistent with topic.  ""Configuring"" Unicode support would not match the topic, Microsoft SQL Server database, where configuring does not apply.  However, am I missing your point somehow?",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10589,831899730,2022-03-22T08:39:53Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/OfflineSessionPersistenceTest.java,"@@ -189,7 +218,27 @@ public void testPersistenceMultipleNodesClientSessionsAtRandomNode() throws Inte                 int oid = index % offlineSessionIds.size();                 String offlineSessionId = offlineSessionIds.get(oid);                 int cid = index % clientIds.size();-                String clientSessionId = createOfflineClientSession(offlineSessionId, clientIds.get(cid));+                String clientSessionId;+                while (true) {+                    try {+                        clientSessionId = createOfflineClientSession(offlineSessionId, clientIds.get(cid));+                        break;+                    } catch (RuntimeException ex) {+                        // invocation can fail when remote cache is stopping, this is actually part of this test:+                        // ""ISPN000217: Received exception from node-8, see cause for remote stack trace+                        // IllegalLifecycleStateException: ISPN000324: Cache 'clientSessions' is in 'STOPPING' state and this is an invocation not belonging to an+                        // on-going transaction, so it does not accept new invocations.""+                        if (ex.getMessage().contains(""ISPN000217"")) {",Should this target `ISPN000324` rather than `ISPN000217`? It seems that the current code could mask even valid exceptions.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10848,832025186,2022-03-22T10:42:42Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -101,60 +99,6 @@ private Deployment fetchExistingDeployment() {                 .get();     } -    private void addInitContainer(Deployment baseDeployment, List<String> extensions) {-        var skipExtensions = Optional-                .ofNullable(extensions)-                .map(e -> e.isEmpty())-                .orElse(true);--        if (skipExtensions) {-            return;-        }--        // Add emptyDir Volume-        var volumes = baseDeployment.getSpec().getTemplate().getSpec().getVolumes();--        var extensionVolume = new VolumeBuilder()-                .withName(Constants.EXTENSIONS_VOLUME_NAME)-                .withNewEmptyDir()-                .endEmptyDir()-                .build();--        volumes.add(extensionVolume);-        baseDeployment.getSpec().getTemplate().getSpec().setVolumes(volumes);--        // Add the main deployment Volume Mount-        var container = baseDeployment.getSpec().getTemplate().getSpec().getContainers().get(0);-        var containerVolumeMounts = container.getVolumeMounts();--        var extensionVM = new VolumeMountBuilder()-                .withName(Constants.EXTENSIONS_VOLUME_NAME)-                .withMountPath(Constants.KEYCLOAK_PROVIDERS_FOLDER)",Please remove the unused constants as well:https://github.com/keycloak/keycloak/blob/1f10a4feb2dfea88bb62e76e314c4e999ef75cc9/operator/src/main/java/org/keycloak/operator/Constants.java#L41-L46,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10848,832027110,2022-03-22T10:44:50Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakDeployment.java,"@@ -101,60 +99,6 @@ private Deployment fetchExistingDeployment() {                 .get();     } -    private void addInitContainer(Deployment baseDeployment, List<String> extensions) {-        var skipExtensions = Optional-                .ofNullable(extensions)-                .map(e -> e.isEmpty())-                .orElse(true);--        if (skipExtensions) {-            return;-        }--        // Add emptyDir Volume-        var volumes = baseDeployment.getSpec().getTemplate().getSpec().getVolumes();--        var extensionVolume = new VolumeBuilder()-                .withName(Constants.EXTENSIONS_VOLUME_NAME)-                .withNewEmptyDir()-                .endEmptyDir()-                .build();--        volumes.add(extensionVolume);-        baseDeployment.getSpec().getTemplate().getSpec().setVolumes(volumes);--        // Add the main deployment Volume Mount-        var container = baseDeployment.getSpec().getTemplate().getSpec().getContainers().get(0);-        var containerVolumeMounts = container.getVolumeMounts();--        var extensionVM = new VolumeMountBuilder()-                .withName(Constants.EXTENSIONS_VOLUME_NAME)-                .withMountPath(Constants.KEYCLOAK_PROVIDERS_FOLDER)-                .withReadOnly(true)-                .build();-        containerVolumeMounts.add(extensionVM);--        container.setVolumeMounts(containerVolumeMounts);--        // Add the Extensions downloader init container-        var extensionsValue = extensions.stream().collect(Collectors.joining("",""));-        var initContainer = new ContainerBuilder()-                .withName(Constants.INIT_CONTAINER_NAME)-                .withImage(config.keycloak().initContainerImage())-                .withImagePullPolicy(config.keycloak().initContainerImagePullPolicy())",Please remove also the unused config options:https://github.com/keycloak/keycloak/blob/1f10a4feb2dfea88bb62e76e314c4e999ef75cc9/operator/src/main/resources/application.properties#L11-L12,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10589,832049318,2022-03-22T11:10:25Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/OfflineSessionPersistenceTest.java,"@@ -189,7 +218,27 @@ public void testPersistenceMultipleNodesClientSessionsAtRandomNode() throws Inte                 int oid = index % offlineSessionIds.size();                 String offlineSessionId = offlineSessionIds.get(oid);                 int cid = index % clientIds.size();-                String clientSessionId = createOfflineClientSession(offlineSessionId, clientIds.get(cid));+                String clientSessionId;+                while (true) {+                    try {+                        clientSessionId = createOfflineClientSession(offlineSessionId, clientIds.get(cid));+                        break;+                    } catch (RuntimeException ex) {+                        // invocation can fail when remote cache is stopping, this is actually part of this test:+                        // ""ISPN000217: Received exception from node-8, see cause for remote stack trace+                        // IllegalLifecycleStateException: ISPN000324: Cache 'clientSessions' is in 'STOPPING' state and this is an invocation not belonging to an+                        // on-going transaction, so it does not accept new invocations.""+                        if (ex.getMessage().contains(""ISPN000217"")) {",I changed the code to look in the nested exception with the `ISPN000324`. Please re-review.,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10589,832050496,2022-03-22T11:11:53Z,testsuite/model/src/test/java/org/keycloak/testsuite/model/session/OfflineSessionPersistenceTest.java,"@@ -160,6 +163,32 @@ public void testPersistenceMultipleNodesClientSessionAtSameNode() throws Interru                 }).forEach(userSessionModel -> clientSessionIds.add(userSessionModel.getId())));                 return null;             });++            // ensure that all session have been created on all nodes+            intermediate.countDown();+            try {+                intermediate.await();+            } catch (InterruptedException e) {+                Thread.currentThread().interrupt();+                throw new RuntimeException(e);+            }++            // defer the shutdown and check if all sessions exist to ensure that they replicate across the different nodes+            // this should avoid an ""org.infinispan.remoting.transport.jgroups.SuspectException: ISPN000400: Node node-XX was suspected""+            while (true) {","This is already wrapped in a timeout for the `inIndependentFactories`. I'd rather let this timeout catch this, so that the result shows in the stacktrace where it timed out. This allows me to keep the code simpler. Please confirm.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10851,832054187,2022-03-22T11:16:15Z,.github/workflows/operator-ci.yml,"@@ -51,14 +51,21 @@ jobs:           eval $(minikube -p minikube docker-env)           docker build --build-arg KEYCLOAK_DIST=$(ls keycloak-*.tar.gz) . -t keycloak:${GITHUB_SHA} +      - name: Build a custom pre-augmented Keycloak Docker image+        run: |+          echo -e ""FROM keycloak:${GITHUB_SHA}\nRUN /opt/keycloak/bin/kc.sh build --db=postgres --health-enabled=true"" > Dockerfile+          eval $(minikube -p minikube docker-env)+          docker build . -t custom-keycloak:${GITHUB_SHA}","Since this is now a vital part of one test (it directly depends on it), wonder if we should make it more independent of GHA to be able to run it locally (and in the QE pipelines in the future) too. Maybe a shell script?",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10853,832055135,2022-03-22T11:17:25Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCClientSecretConfigWrapper.java,"@@ -214,4 +214,203 @@ public String toJson() {             return """";         }     }++    public ReadOnlyRotatedSecretClientModel toRotatedClientModel() {+        return new ReadOnlyRotatedSecretClientModel();+    }++    /**+     * Representation of a client model that passes information from a rotated secret. The goal is to act as a decorator/DTO just providing information and not updating objects persistently.+     */+    public class ReadOnlyRotatedSecretClientModel extends AbstractReadOnlyClientStorageAdapter {",Is it possible to rather inherit from the class `org.keycloak.models.delegate.ClientModelLazyDelegate`? This will help to avoid so much overriden methods. I guess only `getSecret` method would need to be overriden in that case.,
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10851,832064295,2022-03-22T11:28:35Z,operator/src/test/java/org/keycloak/operator/KeycloakDeploymentE2EIT.java,"@@ -322,4 +322,16 @@ public void testInitialAdminUser() {         }     } +    @Test+    public void testCustomImage() {","I'm not really happy in ignoring a test if a property is not set as it can be easily accidentally skipped.An alternative would be to push a valid custom image to a public, personal Docker registry ( something like: `docker.io/andreatp/augmented-testing-keycloak`) and fallback to it, wdyt?",
4205291,marcelomrwin,https://api.github.com/repos/keycloak/keycloak/pulls/10853,832150679,2022-03-22T13:04:21Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCClientSecretConfigWrapper.java,"@@ -214,4 +214,203 @@ public String toJson() {             return """";         }     }++    public ReadOnlyRotatedSecretClientModel toRotatedClientModel() {+        return new ReadOnlyRotatedSecretClientModel();+    }++    /**+     * Representation of a client model that passes information from a rotated secret. The goal is to act as a decorator/DTO just providing information and not updating objects persistently.+     */+    public class ReadOnlyRotatedSecretClientModel extends AbstractReadOnlyClientStorageAdapter {","Perfect, it was exactly the class I was looking for. As the ClientModel interface has several implementations, the one I found closest to what I would like was exactly the one I used. Your suggestion is exactly what I needed. Thanks.",
1888256,tyandor,https://api.github.com/repos/keycloak/keycloak/pulls/10748,832670537,2022-03-22T22:12:15Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/signingin-page/SigningInPage.tsx,"@@ -383,29 +496,44 @@ class CredentialAction extends React.Component<CredentialActionProps> {     render(): React.ReactNode {         if (this.props.updateAction) {             return (-                <DataListAction aria-labelledby='foo' aria-label='foo action' id={'updateAction-' + this.props.credential.id}>-                    <Button id={`${SigningInPage.credElementId(this.props.credential.type, this.props.credential.id, 'update')}`} variant='primary'onClick={()=> this.props.updateAction.execute()}><Msg msgKey='update'/></Button>+                <DataListAction+                    aria-labelledby=""foo""+                    aria-label=""foo action""","So oddly both are required on the DataListAction in the DataList component from PF. In which case, yeah the `labeledby` will take precedence. I've updated all these to be translatable, screen reader readable, strings. ",
1888256,tyandor,https://api.github.com/repos/keycloak/keycloak/pulls/10748,832832678,2022-03-23T04:17:48Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/my-resources-page/EditTheResource.tsx,"@@ -45,7 +46,7 @@ interface EditTheResourceState { }  export class EditTheResource extends React.Component<EditTheResourceProps, EditTheResourceState> {-    protected static defaultProps = { permissions: [] };+    protected static defaultProps:any = { permissions: [] };","That didn't do the trick, but adding a new type for Permissions I was able to fix this and another similar instance. ",
1888256,tyandor,https://api.github.com/repos/keycloak/keycloak/pulls/10748,832834427,2022-03-23T04:22:30Z,themes/src/main/resources/theme/keycloak.v2/account/src/app/content/my-resources-page/ShareTheResource.tsx,"@@ -208,14 +208,12 @@ export class ShareTheResource extends React.Component<ShareTheResourceProps, Sha                                         </GalleryItem>                                  </Gallery>-                                <ChipGroup withToolbar>-                                    <ChipGroupToolbarItem key='users-selected' categoryName='Share with '>+                                <ChipGroup categoryName='Share with '>","Resolved, along with a few other aria labels on this page. ",
8360369,azilentech,https://api.github.com/repos/keycloak/keycloak/pulls/8189,832974593,2022-03-23T08:17:55Z,themes/src/main/resources/theme/base/admin/resources/js/authz/authz-controller.js,"@@ -1213,90 +1213,129 @@ module.controller('ResourceServerPolicyScopeDetailCtrl', function($scope, $route                     });                 }             }+            $scope.applyToResourceType = function() {+                if ($scope.applyToResourceTypeFlag) {+                    $scope.selectedResource = null;+                } else {+                    $scope.policy.resourceType = null;+                }+                $scope.selectedScopes = [];+                $scope.changed = true;+            }         },          onInitUpdate : function(policy) {-            ResourceServerPolicy.resources({-                realm : $route.current.params.realm,-                client : client.id,-                id : policy.id-            }, function(resources) {-                if (resources.length > 0) {-                    for (i = 0; i < resources.length; i++) {-                        ResourceServerResource.get({-                            realm: $route.current.params.realm,-                            client: client.id,-                            rsrid: resources[0]._id,-                        }, function (resource) {-                            ResourceServerResource.query({+            if (!policy.resourceType) {","> Instead of adding a long if-then-else clause, please break this code up into at least two new functions:> > ```> if (!policy.resourceType) {>    functionA();> } else {>    functionB();> }> ```Now, this is really interesting one.  I have created common method (ResourceServerPolicyCommonHandler) to use between ""ResourceServerPolicyResourceDetailCtrl"" and ""ResourceServerPolicyScopeDetailCtrl"". This way, significant code has been reduced.To review the code effectively, I would suggest that instead of PR review (where proper block changes are not displayed), please compare ResourceServerPolicyCommonHandler method code with existing ResourceServerPolicyResourceDetailCtrl and ResourceServerPolicyScopeDetailCtrl.Pointers about ResourceServerPolicyCommonHandler:1. Instead of ResourceServerPolicy, have used ResourceServerPermission, as permission class is derived from policy only in backend and from a usage point of view, that is consistent.2. For scope-based permission, ResourceServerScope will be passed otherwise null. In the code, wherever scope needs to be handled, checking for ResourceServerScope is used.3. In UI, resource-server-policy-scope-detail.html file, instead of using two different controls for selectedScope, now single control is used.4. As single control is used for selected scopes now, to handle scenarios about getting scopes from scopes of the selected resource (resourceScope), logic is added in $scope.scopesUiSelect5. Due to this change, code for onInitUpdate is simple now, where earlier ""scopes[i].id"" was pushed in $scope.selectedScopes in some cases and sometimes ""scopes[i]"" was pushed.6. This way, one more issue is solved that exists in the current code. (Explained Below)The issue which is fixed now: On changing of resource, scopes are cleared in models but display is not updated.1. Open ""Scope"" Permission.2. Select Resource ""Resource A"".3. Select Scope ""Scope1"".4. Clear the resource.5. Scope will be cleared.6. Select Resource ""Resource B"". (Here assume that ""Scope1"" is not mapped with ""Resource B"").7. Still ""Scope1"" will be displayed. It looks like ""select2"" refresh issue.8. While trying to save this, it will give an error. It means, internally it uses proper data model only where selectedScopes are empty.I understand that it is a major change from a UI perspective now, but I thought this is a good opportunity to clean up the code and it has brought consistency for both types of permissions handling.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/10808,833245587,2022-03-23T13:10:52Z,.github/workflows/snyk.yml,"@@ -0,0 +1,67 @@+name: ""Snyk""++on:+  # Please uncomment the push event for testing purposes+  #push:+  #  branches: [main]+  # Run the job at the end of every day+  schedule:+    - cron: ""0 0 * * *""++env:+  # Please check how to create an access token here https://docs.snyk.io/tutorials/amazon-web-services/aws-code-suite/snyk-security/create-account-and-obtain-a-token+  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}+  DEFAULT_JDK_VERSION: 11++jobs:+  quarkus:+    name: Quarkus+    runs-on: ubuntu-latest+    steps:+      - name: Checkout repository+        uses: actions/checkout@v2++      - uses: actions/setup-java@v1+        with:+          java-version: ""${{ env.DEFAULT_JDK_VERSION }}""+      +      - name: Build Keycloak+        run: mvn clean install -nsu -B -e -Pdistribution -Dmaven.test.skip -DskipQuarkus -DskipTestsuite -DskipExamples -DskipTests++      - uses: snyk/actions/setup@master+      - name: Check for vulnerabilities+        run: snyk test --policy-path=.snyk --all-projects --prune-repeated-subdependencies --exclude=tests --sarif-file-output=quarkus-report.sarif quarkus+        continue-on-error: true+        env:+          SNYK_TOKEN: ""${{ env.SNYK_TOKEN }}""++      - name: Upload scanner results to GitHub+        uses: github/codeql-action/upload-sarif@v1+        with:+          sarif_file: quarkus-report.sarif++  operator:+    name: Operator+    runs-on: ubuntu-latest+    steps:+      - name: Checkout repository+        uses: actions/checkout@v2++      - uses: actions/setup-java@v1+        with:+          java-version: ""${{ env.DEFAULT_JDK_VERSION }}""+      +      - name: Build Keycloak+        run: mvn clean install -nsu -B -e -Pdistribution -Dmaven.test.skip -DskipQuarkus -DskipTestsuite -DskipExamples -DskipTests","I tried to reuse the build steps and failed. After looking at https://github.com/keycloak/keycloak/blob/main/.github/workflows/ci.yml I noticed that we don't do anything different there. But if you have a solution, I will be more than happy to incorporate the changes here.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/10895,833486795,2022-03-23T16:38:39Z,adapters/oidc/wildfly-elytron/src/main/java/org/keycloak/adapters/elytron/ElytronHttpFacade.java,"@@ -77,6 +83,30 @@     private SecurityIdentity securityIdentity;     private boolean restored;     private final Map<String, String> headers = new HashMap<>();+    protected MultivaluedHashMap<String, String> queryParameters;++    static {+        boolean bogus = false;+        String prop = System.getProperty(""org.keycloak.adapters.elytronweb.forceBogus"");+        if (prop != null) {+            bogus = Boolean.parseBoolean(prop);+            log.tracef(""Forcing value for bogus version of elytron-web %b"", bogus);+        } else {+            try {+                Class clazz = ElytronHttpFacade.class.getClassLoader().loadClass(""org.wildfly.elytron.web.undertow.server.ElytronHttpExchange"");",@rmartinc Just out of curiosity. What's the difference with using this instead of `ElytronHttpExchange.class.getPackage().getImplementationVersion();` ?,
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/10895,833507490,2022-03-23T16:58:55Z,adapters/oidc/wildfly-elytron/src/main/java/org/keycloak/adapters/elytron/ElytronHttpFacade.java,"@@ -77,6 +83,30 @@     private SecurityIdentity securityIdentity;     private boolean restored;     private final Map<String, String> headers = new HashMap<>();+    protected MultivaluedHashMap<String, String> queryParameters;++    static {+        boolean bogus = false;+        String prop = System.getProperty(""org.keycloak.adapters.elytronweb.forceBogus"");+        if (prop != null) {+            bogus = Boolean.parseBoolean(prop);+            log.tracef(""Forcing value for bogus version of elytron-web %b"", bogus);+        } else {+            try {+                Class clazz = ElytronHttpFacade.class.getClassLoader().loadClass(""org.wildfly.elytron.web.undertow.server.ElytronHttpExchange"");",Not depending in the elytron-web module. If for whatever reason the module or class disappear we set the bogus property to false. I declared the module optional too in the module.xml.,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/10917,834301850,2022-03-24T13:23:33Z,testsuite/model/pom.xml,"@@ -35,6 +35,12 @@             <artifactId>junit</artifactId>             <scope>compile</scope>         </dependency>+        <dependency>+            <groupId>net.jcip</groupId>+            <artifactId>jcip-annotations</artifactId>",The version is the same as the transitive dependency in `resteasy-jaxrs`. But not sure if we actually need or want to have the properties in the parent pom.,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/10903,835126371,2022-03-25T10:07:18Z,model/map/src/main/java/org/keycloak/models/map/loginFailure/MapUserLoginFailureAdapter.java,"@@ -49,7 +51,7 @@ public void setFailedLoginNotBefore(int notBefore) {      @Override     public int getNumFailures() {-        return entity.getNumFailures();+        return Optional.ofNullable(entity.getNumFailures()).orElse(0);",I don't have any particular reason for it. Replaced with traditional condition.,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/10901,835203649,2022-03-25T11:56:40Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/realm/entity/JpaRealmEntity.java,"@@ -0,0 +1,978 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.realm.entity;++import java.util.HashMap;+import java.util.HashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;++import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import javax.persistence.UniqueConstraint;+import javax.persistence.Version;++import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.realm.MapRealmEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationExecutionEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationFlowEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticatorConfigEntity;+import org.keycloak.models.map.realm.entity.MapClientInitialAccessEntity;+import org.keycloak.models.map.realm.entity.MapComponentEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderMapperEntity;+import org.keycloak.models.map.realm.entity.MapOTPPolicyEntity;+import org.keycloak.models.map.realm.entity.MapRequiredActionProviderEntity;+import org.keycloak.models.map.realm.entity.MapRequiredCredentialEntity;+import org.keycloak.models.map.realm.entity.MapWebAuthnPolicyEntity;+import org.keycloak.models.map.storage.jpa.JpaRootEntity;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++import static org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_REALM;++@Entity+@Table(name = ""kc_realm"",+    uniqueConstraints = {+        @UniqueConstraint(+                columnNames = {""name""}+        )+})+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaRealmEntity extends MapRealmEntity.AbstractRealmEntity implements JpaRootEntity {++    @Id+    @Column+    private UUID id;++    //used for implicit optimistic locking+    @Version+    @Column+    private int version;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaRealmMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String name;++    @OneToMany(mappedBy = ""root"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaRealmAttributeEntity> attributes = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaRealmEntity() {+        this.metadata = new JpaRealmMetadata();+    }++    public JpaRealmEntity(final DeepCloner cloner) {+        this.metadata = new JpaRealmMetadata(cloner);+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select realm without metadata(json) field.+     */+    public JpaRealmEntity(final UUID id, final int version, final Integer entityVersion, final String name) {+        this.id = id;+        this.version = version;+        this.entityVersion = entityVersion;+        this.name = name;+        this.metadata = null;","Shoudln't we also make `displayName`, `displayNameHtml` and `enabled` fields generated? It seems it could make sense when looking at [`ModelToRepresentation.toBriefRepresentation(RealmModel)`](https://github.com/keycloak/keycloak/blob/main/server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java#L323-L331) wdyt?",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/10942,835250325,2022-03-25T13:04:26Z,.github/workflows/operator-ci.yml,"@@ -1,6 +1,13 @@ name: Keycloak Operator CI -on: [push, pull_request]+on:+  push:+    branches-ignore: [main]+  pull_request:+    # paths-ignore:","@DGuhr by removing those comments I mean, deleting those lines. We don't have any plans to use those lines. My apologies, bad wording :)",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10942,835258628,2022-03-25T13:15:12Z,.github/workflows/ci.yml,"@@ -1,6 +1,13 @@ name: Keycloak CI -on: [push, pull_request]+on:","@abstractj if I understand your comment correctly there is no behavioural difference from the two signatures in GH Action, as they are simply separate elements in an array:```yamlon:  push:  schedule:  pull:```vs:```yamlon:  pull:  schedule:  push:```e.g. each element of the array is independent from the others.reference docs: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#using-multiple-events",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/10808,835292144,2022-03-25T13:53:58Z,.github/workflows/snyk.yml,"@@ -0,0 +1,67 @@+name: ""Snyk""++on:+  # Please uncomment the push event for testing purposes+  #push:+  #  branches: [main]+  # Run the job at the end of every day+  schedule:+    - cron: ""0 0 * * *""++env:+  # Please check how to create an access token here https://docs.snyk.io/tutorials/amazon-web-services/aws-code-suite/snyk-security/create-account-and-obtain-a-token+  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}",@jonkoops Quarkus and Operator jobs need to make use of this variable. Could you please elaborate more on the security reasons? Do you see any way to a bad actor to hijack the token?,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10943,835338061,2022-03-25T14:43:51Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaRootVersionedEntity.java,"@@ -0,0 +1,29 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa;++/**+ * Interface for all root entities which implements optimistic locking","Adding a dot at the end to complete the sentence. The first sentence shows as the summary of the class in JavaDoc.  Applies basically to all JavaDoc, didn't add this for other newly added JavaDoc. ```suggestion * Interface for all root entities which implements optimistic locking.```",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10943,835341385,2022-03-25T14:47:21Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/authSession/entity/JpaAuthenticationSessionEntity.java,"@@ -0,0 +1,283 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.authSession.entity;++import java.util.Map;+import java.util.Objects;+import java.util.Set;+import java.util.UUID;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.GeneratedValue;+import javax.persistence.Id;+import javax.persistence.JoinColumn;+import javax.persistence.ManyToOne;+import javax.persistence.Table;+import javax.persistence.Version;+import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.authSession.MapAuthenticationSessionEntity;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.UpdatableEntity;+import static org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_AUTH_SESSION;+import org.keycloak.models.map.storage.jpa.JpaRootEntity;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.sessions.CommonClientSessionModel;++@Entity","Please add some JavaDoc here. The first sentence should describe what the class is about. A second sentence should then describe why this class doesn't implement JpaRootVersionedEntity, as future visitors of the class will not know about the reasons otherwise. UPDATE: this class for the same reasons also doesn't implement JpaChildEntity - that's also worth nothing IMHO.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/10808,835367773,2022-03-25T15:16:06Z,.github/workflows/snyk.yml,"@@ -0,0 +1,67 @@+name: ""Snyk""++on:+  # Please uncomment the push event for testing purposes+  #push:+  #  branches: [main]+  # Run the job at the end of every day+  schedule:+    - cron: ""0 0 * * *""++env:+  # Please check how to create an access token here https://docs.snyk.io/tutorials/amazon-web-services/aws-code-suite/snyk-security/create-account-and-obtain-a-token+  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}","It's already being passed locally here: https://github.com/keycloak/keycloak/blob/61255ab2e373b7079afddd6efe277273bfa6d621/.github/workflows/snyk.yml#L60This code makes no sense, as this environment variable is already exposed at the root of the workflow file here:https://github.com/keycloak/keycloak/blob/61255ab2e373b7079afddd6efe277273bfa6d621/.github/workflows/snyk.yml#L9Instead this should be passed explicitly locally so that only the steps that need this token have access to it:```yamlSNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}```Or globally so that all steps have access to it (but less secure)",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10943,835367954,2022-03-25T15:16:17Z,model/map-jpa/src/main/resources/META-INF/auth-sessions/jpa-auth-sessions-changelog-1.xml,"@@ -0,0 +1,65 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: auth-sessions-${org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_AUTH_SESSION} -->+    <changeSet author=""keycloak"" id=""auth-sessions-1"">++        <createTable tableName=""kc_auth_root_session"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""kc_auth_root_session"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""realmid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fRealmId""/>+            <ext:column name=""timestamp"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""fTimestamp""/>+            <ext:column name=""expiration"" type=""BIGINT"" jsonColumn=""metadata"" jsonProperty=""fExpiration""/>","I see that ""timestamp"" is an integer (as it is also within Keycloak's logical layer), and there is ""expiration"" (with is AFAIK also a timestamp, but as a long). I wonder if we should treat both as long within the map storage (across all modules) to make this consistent. I also wonder if we should place it into the database as a timestamp, although I know having timestamps in databases has also its issues with regards to time zones.",
36283247,SecKatie,https://api.github.com/repos/keycloak/keycloak/pulls/10808,835388413,2022-03-25T15:38:53Z,.github/workflows/snyk.yml,"@@ -0,0 +1,67 @@+name: ""Snyk""++on:+  # Please uncomment the push event for testing purposes+  #push:+  #  branches: [main]+  # Run the job at the end of every day+  schedule:+    - cron: ""0 0 * * *""++env:+  # Please check how to create an access token here https://docs.snyk.io/tutorials/amazon-web-services/aws-code-suite/snyk-security/create-account-and-obtain-a-token+  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}","@jonkoops makes a great point about restricting the token only to the steps that need it.I am not sure if there is an exploitable condition (i.e., a new code change steals our token during a build), but it is a good practice to stick with the principle of least access.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10808,835429656,2022-03-25T16:27:45Z,.github/workflows/snyk.yml,"@@ -0,0 +1,67 @@+name: ""Snyk""++on:+  # Please uncomment the push event for testing purposes+  #push:+  #  branches: [main]+  # Run the job at the end of every day+  schedule:+    - cron: ""0 0 * * *""++env:+  # Please check how to create an access token here https://docs.snyk.io/tutorials/amazon-web-services/aws-code-suite/snyk-security/create-account-and-obtain-a-token+  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}+  DEFAULT_JDK_VERSION: 11++jobs:+  quarkus:+    name: Quarkus+    runs-on: ubuntu-latest+    steps:+      - name: Checkout repository+        uses: actions/checkout@v2++      - uses: actions/setup-java@v1+        with:+          java-version: ""${{ env.DEFAULT_JDK_VERSION }}""+      +      - name: Build Keycloak+        run: mvn clean install -nsu -B -e -Pdistribution -Dmaven.test.skip -DskipQuarkus -DskipTestsuite -DskipExamples -DskipTests++      - uses: snyk/actions/setup@master+      - name: Check for vulnerabilities+        run: snyk test --policy-path=.snyk --all-projects --prune-repeated-subdependencies --exclude=tests --sarif-file-output=quarkus-report.sarif quarkus+        continue-on-error: true+        env:+          SNYK_TOKEN: ""${{ env.SNYK_TOKEN }}""++      - name: Upload scanner results to GitHub+        uses: github/codeql-action/upload-sarif@v1+        with:+          sarif_file: quarkus-report.sarif++  operator:+    name: Operator+    runs-on: ubuntu-latest+    steps:+      - name: Checkout repository+        uses: actions/checkout@v2++      - uses: actions/setup-java@v1+        with:+          java-version: ""${{ env.DEFAULT_JDK_VERSION }}""+      +      - name: Build Keycloak+        run: mvn clean install -nsu -B -e -Pdistribution -Dmaven.test.skip -DskipQuarkus -DskipTestsuite -DskipExamples -DskipTests",This won't build the operator artifacts as the `operator` module is excluded unless the [corresponding profile](https://github.com/keycloak/keycloak/blob/19e19c9ddad64d23a29bb2eb3ec740187edc13c6/pom.xml#L2046-L2057) is enabled.Confirmed by executing:```$ mvn clean install -nsu -B -e -Pdistribution -Dmaven.test.skip -DskipQuarkus -DskipTestsuite -DskipExamples -DskipTests... maven build ...$ cd operator/targetcd: no such file or directory: operator/target```I believe this has to be something like:```suggestion        run: mvn clean install -nsu -B -e -Poperator -Dmaven.test.skip -DskipQuarkus -DskipTestsuite -DskipExamples -DskipTests```,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10808,835431714,2022-03-25T16:30:12Z,.github/workflows/snyk.yml,"@@ -0,0 +1,67 @@+name: ""Snyk""++on:+  # Please uncomment the push event for testing purposes+  #push:+  #  branches: [main]+  # Run the job at the end of every day+  schedule:+    - cron: ""0 0 * * *""++env:+  # Please check how to create an access token here https://docs.snyk.io/tutorials/amazon-web-services/aws-code-suite/snyk-security/create-account-and-obtain-a-token+  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}+  DEFAULT_JDK_VERSION: 11++jobs:+  quarkus:+    name: Quarkus+    runs-on: ubuntu-latest+    steps:+      - name: Checkout repository+        uses: actions/checkout@v2++      - uses: actions/setup-java@v1+        with:+          java-version: ""${{ env.DEFAULT_JDK_VERSION }}""+      +      - name: Build Keycloak+        run: mvn clean install -nsu -B -e -Pdistribution -Dmaven.test.skip -DskipQuarkus -DskipTestsuite -DskipExamples -DskipTests++      - uses: snyk/actions/setup@master+      - name: Check for vulnerabilities+        run: snyk test --policy-path=.snyk --all-projects --prune-repeated-subdependencies --exclude=tests --sarif-file-output=quarkus-report.sarif quarkus+        continue-on-error: true+        env:+          SNYK_TOKEN: ""${{ env.SNYK_TOKEN }}""++      - name: Upload scanner results to GitHub+        uses: github/codeql-action/upload-sarif@v1+        with:+          sarif_file: quarkus-report.sarif++  operator:+    name: Operator+    runs-on: ubuntu-latest+    steps:+      - name: Checkout repository+        uses: actions/checkout@v2++      - uses: actions/setup-java@v1+        with:+          java-version: ""${{ env.DEFAULT_JDK_VERSION }}""+      +      - name: Build Keycloak+        run: mvn clean install -nsu -B -e -Pdistribution -Dmaven.test.skip -DskipQuarkus -DskipTestsuite -DskipExamples -DskipTests",We could use the same trick as with tests  build KC in a separate job and archive the artifacts:https://github.com/keycloak/keycloak/blob/19e19c9ddad64d23a29bb2eb3ec740187edc13c6/.github/workflows/ci.yml#L13-L53,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10943,835454359,2022-03-25T16:58:35Z,model/map-jpa/src/main/resources/META-INF/auth-sessions/jpa-auth-sessions-changelog-1.xml,"@@ -0,0 +1,65 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: auth-sessions-${org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_AUTH_SESSION} -->+    <changeSet author=""keycloak"" id=""auth-sessions-1"">++        <createTable tableName=""kc_auth_root_session"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""kc_auth_root_session"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""realmid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fRealmId""/>+            <ext:column name=""timestamp"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""fTimestamp""/>+            <ext:column name=""expiration"" type=""BIGINT"" jsonColumn=""metadata"" jsonProperty=""fExpiration""/>","> I wonder if we should treat both as long within the map storage (across all modules) to make this consistent.Good catch. Yes, we should, could you please introduce a GHI for that?> I also wonder if we should place it into the database as a timestamp, although I know having timestamps in databases has also its issues with regards to time zones.I'd rather keep it as `BIGINT`, that corresponds to the usage of it within Keycloak. If a view of it should be needed by an admin, they can use DB functions for conversions in SELECTs",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10777,836583025,2022-03-28T15:50:03Z,.github/workflows/trivy-analysis.yml,"@@ -0,0 +1,67 @@+name: Trivy+on:+  workflow_dispatch:+  # Uncomment this for testing purposes+  #push:+  #  branches: [ main ]+  # Run the job twice a day  +  schedule:+    - cron: ""0 0,12 * * *""",Do we have an estimate on when/how often the security database are updated on Trivy side?,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10949,836583183,2022-03-28T15:50:13Z,.github/workflows/operator-ci.yml,"@@ -65,8 +65,79 @@ jobs:         run: |           eval $(minikube -p minikube docker-env)           mvn clean verify \-              -Dquarkus.container-image.build=true -Dquarkus.container-image.tag=test \+              -Dquarkus.container-image.build=true \+              -Dquarkus.container-image.labels.""\""quay.expires-after\""""=""20h"" \               -Dquarkus.kubernetes.deployment-target=kubernetes \               -Dquarkus.jib.jvm-arguments=""-Djava.util.logging.manager=org.jboss.logmanager.LogManager"",""-Doperator.keycloak.image=keycloak:${GITHUB_SHA}"",""-Doperator.keycloak.image-pull-policy=Never"" \               --no-transfer-progress -Dtest.operator.deployment=remote \               -Dtest.operator.kubernetes.ip=$(minikube ip)++      # DEBUG: instead of running the tests before testing on OLM uncomment the following steps+      # - name: Test operator running in cluster+      #   working-directory: operator+      #   run: |+      #     eval $(minikube -p minikube docker-env)+      #     mvn clean verify \+      #         -Dquarkus.container-image.build=true \+      #         -Dquarkus.container-image.labels.""\""quay.expires-after\""""=""20h"" \+      #         -Dquarkus.kubernetes.deployment-target=kubernetes \+      #         -Dquarkus.jib.jvm-arguments=""-Djava.util.logging.manager=org.jboss.logmanager.LogManager"",""-Doperator.keycloak.image=keycloak:${GITHUB_SHA}"",""-Doperator.keycloak.image-pull-policy=Never"" \+      #         -DskipTests+      # - name: Install the operator CRDs+      #   working-directory: operator+      #   run: |+      #     kubectl apply -f target/kubernetes/keycloaks.keycloak.org-v1.yml+      #     kubectl apply -f target/kubernetes/keycloakrealmimports.keycloak.org-v1.yml++      # Test the OLM bundle+      - name: Install OPM","I believe the OLM tests should be isolated into a separate job, i.e. a clean minikube instance. Re-using the cluster where there were the cluster tests running previously (that means CRD installed etc.) could affect the OLM results. We could even run it in parallel with other operator tests, we would just need to push the operator and KC images before running tests.An alternative solution would be to purge the running cluster after the cluster tests, before running the OLM tests. We can't be 100% sure what was left there. Preferably, re-create the minikube cluster.",
5792097,andreaTP,https://api.github.com/repos/keycloak/keycloak/pulls/10777,836584204,2022-03-28T15:51:04Z,.github/workflows/trivy-analysis.yml,"@@ -0,0 +1,67 @@+name: Trivy+on:+  workflow_dispatch:+  # Uncomment this for testing purposes+  #push:+  #  branches: [ main ]+  # Run the job twice a day  +  schedule:+    - cron: ""0 0,12 * * *""++jobs:+  quarkus-dist:+    name: Vulnerability scanner for Quarkus distribution images+    runs-on: ""ubuntu-18.04""+    steps:+      - name: Run Trivy vulnerability scanner+        uses: aquasecurity/trivy-action@296212627a1e693efa09c00adc3e03b2ba8edf18+        with:+          image-ref: 'quay.io/keycloak/keycloak:nightly'",Should we run those actions right after the nightly builds?https://github.com/keycloak-rel/keycloak-rel/blob/main/.github/workflows/nightly.ymlcc. @stianst,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10949,836609067,2022-03-28T16:15:11Z,.github/workflows/operator-ci.yml,"@@ -65,8 +65,79 @@ jobs:         run: |           eval $(minikube -p minikube docker-env)           mvn clean verify \-              -Dquarkus.container-image.build=true -Dquarkus.container-image.tag=test \+              -Dquarkus.container-image.build=true \+              -Dquarkus.container-image.labels.""\""quay.expires-after\""""=""20h"" \               -Dquarkus.kubernetes.deployment-target=kubernetes \               -Dquarkus.jib.jvm-arguments=""-Djava.util.logging.manager=org.jboss.logmanager.LogManager"",""-Doperator.keycloak.image=keycloak:${GITHUB_SHA}"",""-Doperator.keycloak.image-pull-policy=Never"" \               --no-transfer-progress -Dtest.operator.deployment=remote \               -Dtest.operator.kubernetes.ip=$(minikube ip)++      # DEBUG: instead of running the tests before testing on OLM uncomment the following steps+      # - name: Test operator running in cluster+      #   working-directory: operator+      #   run: |+      #     eval $(minikube -p minikube docker-env)+      #     mvn clean verify \+      #         -Dquarkus.container-image.build=true \+      #         -Dquarkus.container-image.labels.""\""quay.expires-after\""""=""20h"" \+      #         -Dquarkus.kubernetes.deployment-target=kubernetes \+      #         -Dquarkus.jib.jvm-arguments=""-Djava.util.logging.manager=org.jboss.logmanager.LogManager"",""-Doperator.keycloak.image=keycloak:${GITHUB_SHA}"",""-Doperator.keycloak.image-pull-policy=Never"" \+      #         -DskipTests+      # - name: Install the operator CRDs+      #   working-directory: operator+      #   run: |+      #     kubectl apply -f target/kubernetes/keycloaks.keycloak.org-v1.yml+      #     kubectl apply -f target/kubernetes/keycloakrealmimports.keycloak.org-v1.yml++      # Test the OLM bundle+      - name: Install OPM+        uses: redhat-actions/openshift-tools-installer@v1+        with:+          source: ""github""+          opm: ""1.21.0""+          operator-sdk: ""1.18.1""","I don't think we're using the Go Operator SDK for anything else than installing the OLM, right? If that's the case, we can avoid installing yet another dependency by calling `install-olm.sh` that is present in this PR.",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/10777,836632716,2022-03-28T16:39:32Z,.github/workflows/trivy-analysis.yml,"@@ -0,0 +1,67 @@+name: Trivy+on:+  workflow_dispatch:+  # Uncomment this for testing purposes+  #push:+  #  branches: [ main ]+  # Run the job twice a day  +  schedule:+    - cron: ""0 0,12 * * *""","Trivy downloads its vulnerability database every 12 hours, according to [their documentation](https://aquasecurity.github.io/trivy/v0.17.0/examples/db/#:~:text=Vulnerability%20DB-,Skip%20update%20of%20vulnerability%20DB,the%20%2D%2Dskip%2Dupdate%20option.).",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10949,836637205,2022-03-28T16:44:34Z,.github/workflows/operator-ci.yml,"@@ -65,8 +65,79 @@ jobs:         run: |           eval $(minikube -p minikube docker-env)           mvn clean verify \-              -Dquarkus.container-image.build=true -Dquarkus.container-image.tag=test \+              -Dquarkus.container-image.build=true \+              -Dquarkus.container-image.labels.""\""quay.expires-after\""""=""20h"" \               -Dquarkus.kubernetes.deployment-target=kubernetes \               -Dquarkus.jib.jvm-arguments=""-Djava.util.logging.manager=org.jboss.logmanager.LogManager"",""-Doperator.keycloak.image=keycloak:${GITHUB_SHA}"",""-Doperator.keycloak.image-pull-policy=Never"" \               --no-transfer-progress -Dtest.operator.deployment=remote \               -Dtest.operator.kubernetes.ip=$(minikube ip)++      # DEBUG: instead of running the tests before testing on OLM uncomment the following steps+      # - name: Test operator running in cluster+      #   working-directory: operator+      #   run: |+      #     eval $(minikube -p minikube docker-env)+      #     mvn clean verify \+      #         -Dquarkus.container-image.build=true \+      #         -Dquarkus.container-image.labels.""\""quay.expires-after\""""=""20h"" \+      #         -Dquarkus.kubernetes.deployment-target=kubernetes \+      #         -Dquarkus.jib.jvm-arguments=""-Djava.util.logging.manager=org.jboss.logmanager.LogManager"",""-Doperator.keycloak.image=keycloak:${GITHUB_SHA}"",""-Doperator.keycloak.image-pull-policy=Never"" \+      #         -DskipTests+      # - name: Install the operator CRDs+      #   working-directory: operator+      #   run: |+      #     kubectl apply -f target/kubernetes/keycloaks.keycloak.org-v1.yml+      #     kubectl apply -f target/kubernetes/keycloakrealmimports.keycloak.org-v1.yml++      # Test the OLM bundle+      - name: Install OPM+        uses: redhat-actions/openshift-tools-installer@v1+        with:+          source: ""github""+          opm: ""1.21.0""+          operator-sdk: ""1.18.1""+      +      - name: Install Yq+        run: sudo snap install yq++      - name: Install Operator Lifecycle Manager using Operator SDK+        run: operator-sdk olm install++      - name: Login to docker registry+        uses: docker/login-action@v1.14.1+        with:+          registry: ${{ secrets.TEST_DOCKER_REGISTRY }}+          username: ${{ secrets.TEST_DOCKER_USERNAME }}+          password: ${{ secrets.TEST_DOCKER_TOKEN }}++      - name: Prepare resources for testing on OLM+        working-directory: operator+        run: |+          VERSION=0.0.1-${GITHUB_RUN_ID}+          eval $(minikube -p minikube docker-env)+          docker tag keycloak/keycloak-operator:999-SNAPSHOT ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }}/keycloak-operator:${VERSION}+          docker push ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }}/keycloak-operator:${VERSION}+          docker tag keycloak:${GITHUB_SHA} ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }}/keycloak:${VERSION}+          docker push ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }}/keycloak:${VERSION}++          ./scripts/prepare-olm-test.sh ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }} ${VERSION} 0.0.1++      # DEBUG+      # - name: Setup tmate session+      #   uses: mxschmitt/action-tmate@v3++      - name: Install the operator with OLM+        working-directory: operator+        run: ./scripts/install-keycloak-operator.sh++      - name: Deploy an example Keycloak and wait for it to be ready+        working-directory: operator+        run: |+          kubectl apply -f src/main/resources/example-postgres.yaml+          kubectl apply -f src/main/resources/example-keycloak.yml+          # Wait for the deployment to be created+          timeout 120 sh -c ""while ! kubectl get deployment/example-kc; do (sleep 1 && kubectl get pods); done""+          # Wait for the deployment to be available+          kubectl wait --for=condition=available --timeout=600s deployment/example-kc+          # Wait for the pods in the namespace to be ready+          kubectl wait --for=condition=Ready --timeout=600s pods -l app=keycloak",This smells like a test.  Wonder if we should move it into a separate shell script.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10949,836642889,2022-03-28T16:50:28Z,.github/workflows/operator-ci.yml,"@@ -65,8 +65,79 @@ jobs:         run: |           eval $(minikube -p minikube docker-env)           mvn clean verify \-              -Dquarkus.container-image.build=true -Dquarkus.container-image.tag=test \+              -Dquarkus.container-image.build=true \+              -Dquarkus.container-image.labels.""\""quay.expires-after\""""=""20h"" \               -Dquarkus.kubernetes.deployment-target=kubernetes \               -Dquarkus.jib.jvm-arguments=""-Djava.util.logging.manager=org.jboss.logmanager.LogManager"",""-Doperator.keycloak.image=keycloak:${GITHUB_SHA}"",""-Doperator.keycloak.image-pull-policy=Never"" \               --no-transfer-progress -Dtest.operator.deployment=remote \               -Dtest.operator.kubernetes.ip=$(minikube ip)++      # DEBUG: instead of running the tests before testing on OLM uncomment the following steps+      # - name: Test operator running in cluster+      #   working-directory: operator+      #   run: |+      #     eval $(minikube -p minikube docker-env)+      #     mvn clean verify \+      #         -Dquarkus.container-image.build=true \+      #         -Dquarkus.container-image.labels.""\""quay.expires-after\""""=""20h"" \+      #         -Dquarkus.kubernetes.deployment-target=kubernetes \+      #         -Dquarkus.jib.jvm-arguments=""-Djava.util.logging.manager=org.jboss.logmanager.LogManager"",""-Doperator.keycloak.image=keycloak:${GITHUB_SHA}"",""-Doperator.keycloak.image-pull-policy=Never"" \+      #         -DskipTests+      # - name: Install the operator CRDs+      #   working-directory: operator+      #   run: |+      #     kubectl apply -f target/kubernetes/keycloaks.keycloak.org-v1.yml+      #     kubectl apply -f target/kubernetes/keycloakrealmimports.keycloak.org-v1.yml++      # Test the OLM bundle+      - name: Install OPM+        uses: redhat-actions/openshift-tools-installer@v1+        with:+          source: ""github""+          opm: ""1.21.0""+          operator-sdk: ""1.18.1""+      +      - name: Install Yq+        run: sudo snap install yq++      - name: Install Operator Lifecycle Manager using Operator SDK+        run: operator-sdk olm install++      - name: Login to docker registry+        uses: docker/login-action@v1.14.1+        with:+          registry: ${{ secrets.TEST_DOCKER_REGISTRY }}+          username: ${{ secrets.TEST_DOCKER_USERNAME }}+          password: ${{ secrets.TEST_DOCKER_TOKEN }}++      - name: Prepare resources for testing on OLM+        working-directory: operator+        run: |+          VERSION=0.0.1-${GITHUB_RUN_ID}+          eval $(minikube -p minikube docker-env)+          docker tag keycloak/keycloak-operator:999-SNAPSHOT ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }}/keycloak-operator:${VERSION}+          docker push ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }}/keycloak-operator:${VERSION}+          docker tag keycloak:${GITHUB_SHA} ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }}/keycloak:${VERSION}+          docker push ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }}/keycloak:${VERSION}++          ./scripts/prepare-olm-test.sh ${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_USERNAME }} ${VERSION} 0.0.1++      # DEBUG+      # - name: Setup tmate session+      #   uses: mxschmitt/action-tmate@v3++      - name: Install the operator with OLM+        working-directory: operator+        run: ./scripts/install-keycloak-operator.sh++      - name: Deploy an example Keycloak and wait for it to be ready+        working-directory: operator+        run: |+          kubectl apply -f src/main/resources/example-postgres.yaml+          kubectl apply -f src/main/resources/example-keycloak.yml+          # Wait for the deployment to be created+          timeout 120 sh -c ""while ! kubectl get deployment/example-kc; do (sleep 1 && kubectl get pods); done""+          # Wait for the deployment to be available+          kubectl wait --for=condition=available --timeout=600s deployment/example-kc+          # Wait for the pods in the namespace to be ready+          kubectl wait --for=condition=Ready --timeout=600s pods -l app=keycloak","I believe we should also check the CRs' status itself. (Maybe only the CRs, no need to wait for the deployment and pods? Not fussy on this.)Unfortunately, `kubectl wait`'s JSONPath implementation is apparently incomplete, so this doesn't work:```kubectl wait --for=jsonpath=""{.status.conditions[?(@.type == 'Ready')].status}""=true --timeout=600s keycloaks/example-kc```But we can use something like:```while [[ $(kubectl get keycloaks/example-kc -o jsonpath=""{.status.conditions[?(@.type == 'Ready')].status}"") != ""true"" ]]; do echo ""waiting for example-kc status"" && sleep 1; done```",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10949,836658418,2022-03-28T17:08:46Z,operator/scripts/prepare-olm-test.sh,"@@ -0,0 +1,35 @@+#! /bin/bash+set -euxo pipefail++SCRIPT_DIR=$( cd -- ""$( dirname -- ""${BASH_SOURCE[0]}"" )"" &> /dev/null && pwd )++DOCKER_REGISTRY=""$1""++VERSION=""$2""+PREV_VERSION=""$3""++OPERATOR_IMAGE_NAME=""keycloak-operator""+OPERATOR_DOCKER_IMAGE=""$DOCKER_REGISTRY/$OPERATOR_IMAGE_NAME""++# Create OLM bundle+$SCRIPT_DIR/create-olm-bundle.sh $VERSION $PREV_VERSION $OPERATOR_DOCKER_IMAGE++# WARNING: This should be done ONLY for tests+$SCRIPT_DIR/inject-custom-image.sh $VERSION ""$DOCKER_REGISTRY/keycloak:$VERSION""","No need for this. Env vars can be directly specified in the `Subscription`, see https://github.com/operator-framework/operator-lifecycle-manager/blob/master/doc/design/subscription-config.md.",x
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10973,837226396,2022-03-29T08:53:39Z,operator/src/main/java/org/keycloak/operator/v2alpha1/WatchedSecretsStore.java,"@@ -118,7 +118,7 @@ public void addLabelsToWatchedSecrets() {                         .endMetadata()                         .build(); -                client.secrets().patch(secret);+                client.secrets().inNamespace(secret.getMetadata().getNamespace()).withName(secret.getMetadata().getName()).patch(secret);",Could you please elaborate why is this change necessary? The [`patch` impl](https://github.com/fabric8io/kubernetes-client/blob/1034e6cddc2ef2b37f199b06487d1ebf4f0da7d1/kubernetes-client/src/main/java/io/fabric8/kubernetes/client/dsl/internal/HasMetadataOperation.java#L210) seems to be taking the base object metadata (like name and namespace) from the provided object.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10973,837238867,2022-03-29T09:06:38Z,operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java,"@@ -48,8 +48,7 @@ import static io.javaoperatorsdk.operator.api.reconciler.Constants.NO_FINALIZER; import static io.javaoperatorsdk.operator.api.reconciler.Constants.WATCH_CURRENT_NAMESPACE; -// TODO: remove ""generationAwareEventProcessing = false"" when the race condition is fixed-@ControllerConfiguration(namespaces = WATCH_CURRENT_NAMESPACE, finalizerName = NO_FINALIZER, generationAwareEventProcessing = false)+@ControllerConfiguration(namespaces = WATCH_CURRENT_NAMESPACE, finalizerName = NO_FINALIZER)",This seems to be partially addressing #10658. Should we also remove the [fail over workarounds](https://github.com/andreaTP/keycloak/blob/99b032d9e5445a49528575593a1edae1d66a9e29/operator/src/main/java/org/keycloak/operator/v2alpha1/KeycloakController.java#L113-L116) then?,
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10942,837360857,2022-03-29T11:24:39Z,.github/workflows/ci.yml,"@@ -13,6 +18,7 @@ concurrency: jobs:   build:     name: Build+    if: ${{ ( github.event_name != 'schedule' ) || ( github.event_name == 'schedule' && github.repository == 'keycloak/keycloak' ) }}","I hate that this is the only way to do this. GitHub really should have a way to put conditions/filters on the events, not only on individual jobs, but it is what it is",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/10887,837474293,2022-03-29T13:27:00Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java,"@@ -141,34 +180,117 @@ public Response logout(@QueryParam(OIDCLoginProtocol.REDIRECT_URI_PARAM) String             } catch (OAuthErrorException | VerificationException e) {","To confirm an expired ID token, or one where there's no longer a session is still valid right? It looks like that's the case.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/10969,837521268,2022-03-29T14:06:49Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Picocli.java,"@@ -269,9 +274,65 @@ private static boolean hasConfigChanges() {             }         } +        //check for defined quarkus raw build properties for UserStorageProvider extensions+        if (QuarkusPropertiesConfigSource.getConfigurationFile() != null) {","IMO, we should not worry about dealing with this situation at this momment.As we discussed, ideally we should be able to query Quarkus if a property is a build time property. Including here a whitelist of build properties deserves a bit more discussion because. For instance, the possibility to add data sources is a capability we should support in order to deploy custom user providers. In this case, we should think about wrapping the data source config.",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/10969,837557156,2022-03-29T14:37:14Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Picocli.java,"@@ -269,9 +274,65 @@ private static boolean hasConfigChanges() {             }         } +        //check for defined quarkus raw build properties for UserStorageProvider extensions+        if (QuarkusPropertiesConfigSource.getConfigurationFile() != null) {","I have to disagree. I still think the behaviour we have here with the whitelist is better for testing purposes _for now_, as long as we don't have first-class configuration options. First-class options would open up the ""dependant options"" space again, so not trivial. ""Only allow/show options when the named additional datasource is there"" is something we can't do as of now. A possible starting point to look at: we could have e.g. a build option `db-external-names=foo,bar,...` and only show and map the right way options like e.g. `kc-db-foo=mysql`, `kc-db-bar=postgres"" and so on... so this is not trivial to achieve imo. at least not if we want to support the CLI with these and not have a ux issue on that matter. And for me definitely nothing for this ticket.So, without first class support, I consider a dev who runs start --auto-build often to try things out before creating an optimized image for prod (and this is done often it seems from various other issues). The devex while doing this without the whitelist would be ""start keycloak with autobuild, autobuild runs the build every time bc. it detects quarkus.properties even if only the username / url changed for the external datasource"" and thus far from good IMO. So at least until we support first class config for additional datasources, i think the whitelist approach is **good for now** and I am happy to change it when we either a) get sth from quarkus to check more fine-grained for build/runtime, or b) have first class support for additional datasources config on our side. Both approaches are some time down the road i guess, and it's not that hard to change the impl later on, so as a stop-gap solution I'd prefer keeping it that way. ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/10969,837739335,2022-03-29T17:38:53Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Picocli.java,"@@ -269,9 +274,65 @@ private static boolean hasConfigChanges() {             }         } +        //check for defined quarkus raw build properties for UserStorageProvider extensions+        if (QuarkusPropertiesConfigSource.getConfigurationFile() != null) {","I'm not hard on that if others are OK. Looks like the extension story keeps knocking on the door :)If we can avoid temporary code, better.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/10887,837811254,2022-03-29T19:01:11Z,services/src/main/java/org/keycloak/services/managers/AuthenticationManager.java,"@@ -154,7 +153,18 @@     // used solely to determine is user is logged in     public static final String KEYCLOAK_SESSION_COOKIE = ""KEYCLOAK_SESSION"";     public static final String KEYCLOAK_REMEMBER_ME = ""KEYCLOAK_REMEMBER_ME"";++    // ** Logout related notes **/+    // Flag in the logout session to specify if we use ""system"" client or real client+    public static final String LOGOUT_WITH_SYSTEM_CLIENT = ""LOGOUT_WITH_SYSTEM_CLIENT"";","I was thinking about removing this constant during the PR cleanup, will probably do that.The point of the ""system"" client is, that AuthenticationSessionModel always need to have client, which it is linked too. In normal OIDC/SAML login scenarios, authentication session always has client. But in some rare cases (ActionTokens, or now Logout) there is not dedicated client of the flow and hence the ""system"" client is used as a placeholder. The system client is currently ""account"" client.From the long term perspective, it may be better to remove the need of ""system client"" or use dedicated client just for that instead of the ""account"" client.In the case of the system client, the link ""Back to application"" should not be shown on the pages as it is not correct to show ""Back to application"" to point to account management in case that ""account"" was used only as a placeholder system client. Hence I've added the session note to differentiate between the cases when ""account"" was used as a ""system"" client or as real client during logout from account console. However session note is not needed as logout from account console is not a problem because:- New account console uses ""account-console"" client- Old account console uses ""account"" client, but user is immediately logged out when click to ""Logout""So I can remove the note and instead directly check if the client is the system client (account) to decide if the link ""Back to application"" should be shown.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10893,838664904,2022-03-30T15:12:56Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionEntity.java,"@@ -16,269 +16,97 @@  */ package org.keycloak.models.map.userSession; -import org.keycloak.common.util.Time;-import org.keycloak.models.RealmModel;-import org.keycloak.models.UserModel; import org.keycloak.models.UserSessionModel;+import org.keycloak.models.map.annotations.GenerateEntityImplementations; import org.keycloak.models.map.common.AbstractEntity; +import org.keycloak.models.map.common.DeepCloner; import org.keycloak.models.map.common.UpdatableEntity; import java.util.Map;-import java.util.Objects;-import java.util.concurrent.ConcurrentHashMap;  /**  * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>  */-public class MapUserSessionEntity extends UpdatableEntity.Impl implements AbstractEntity {-    private String id;+@GenerateEntityImplementations(+        inherits = ""org.keycloak.models.map.userSession.MapUserSessionEntity.AbstractUserSessionEntity""+)+@DeepCloner.Root+public interface MapUserSessionEntity extends AbstractEntity, UpdatableEntity { -    private String realmId;+    public abstract class AbstractUserSessionEntity extends UpdatableEntity.Impl implements MapUserSessionEntity { -    /**-     * Flag signalizing that any of the setters has been meaningfully used.-     */+        private String id; -    private String userId;+        @Override+        public String getId() {+            return this.id;+        } -    private String brokerSessionId;-    private String brokerUserId;+        @Override+        public void setId(String id) {+            if (this.id != null) throw new IllegalStateException(""Id cannot be changed"");+            this.id = id;+            this.updated |= id != null;+        } -    private String loginUsername;--    private String ipAddress;--    private String authMethod;--    private boolean rememberMe;--    private int started;--    private int lastSessionRefresh;--    private long expiration;--    private Map<String, String> notes = new ConcurrentHashMap<>();--    private UserSessionModel.State state;--    private UserSessionModel.SessionPersistenceState persistenceState = UserSessionModel.SessionPersistenceState.PERSISTENT;--    private Map<String, String> authenticatedClientSessions = new ConcurrentHashMap<>();--    private boolean offline;--    public MapUserSessionEntity() {}--    public MapUserSessionEntity(String id, String realmId) {-        this.id = id;-        this.realmId = realmId;-    }--    public MapUserSessionEntity(String id, RealmModel realm, UserModel user, String loginUsername, String ipAddress,-                                     String authMethod, boolean rememberMe, String brokerSessionId, String brokerUserId,-                                     boolean offline) {-        this.id = id;-        this.realmId = realm.getId();-        this.userId = user.getId();-        this.loginUsername = loginUsername;-        this.ipAddress = ipAddress;-        this.authMethod = authMethod;-        this.rememberMe = rememberMe;-        this.brokerSessionId = brokerSessionId;-        this.brokerUserId = brokerUserId;-        this.started = Time.currentTime();-        this.lastSessionRefresh = started;-        this.offline = offline;-    }--    @Override-    public String getId() {-        return this.id;-    }--    @Override-    public void setId(String id) {-        if (this.id != null) throw new IllegalStateException(""Id cannot be changed"");-        this.id = id;-        this.updated |= id != null;-    }--    public String getRealmId() {-        return realmId;-    }--    public void setRealmId(String realmId) {-        this.updated |= !Objects.equals(this.realmId, realmId);-        this.realmId = realmId;-    }--    public String getUserId() {-        return userId;-    }--    public void setUserId(String userId) {-        this.updated |= !Objects.equals(this.userId, userId);-        this.userId = userId;-    }--    public String getBrokerSessionId() {-        return brokerSessionId;-    }--    public void setBrokerSessionId(String brokerSessionId) {-        this.updated |= !Objects.equals(this.brokerSessionId, brokerSessionId);-        this.brokerSessionId = brokerSessionId;-    }--    public String getBrokerUserId() {-        return brokerUserId;-    }--    public void setBrokerUserId(String brokerUserId) {-        this.updated |= !Objects.equals(this.brokerUserId, brokerUserId);-        this.brokerUserId = brokerUserId;-    }--    public String getLoginUsername() {-        return loginUsername;-    }--    public void setLoginUsername(String loginUsername) {-        this.updated |= !Objects.equals(this.loginUsername, loginUsername);-        this.loginUsername = loginUsername;-    }--    public String getIpAddress() {-        return ipAddress;-    }--    public void setIpAddress(String ipAddress) {-        this.updated |= !Objects.equals(this.ipAddress, ipAddress);-        this.ipAddress = ipAddress;-    }--    public String getAuthMethod() {-        return authMethod;-    }--    public void setAuthMethod(String authMethod) {-        this.updated |= !Objects.equals(this.authMethod, authMethod);-        this.authMethod = authMethod;-    }--    public boolean isRememberMe() {-        return rememberMe;-    }--    public void setRememberMe(boolean rememberMe) {-        this.updated |= this.rememberMe != rememberMe;-        this.rememberMe = rememberMe;-    }--    public int getStarted() {-        return started;-    }--    public void setStarted(int started) {-        this.updated |= this.started != started;-        this.started = started;-    }--    public int getLastSessionRefresh() {-        return lastSessionRefresh;-    }--    public void setLastSessionRefresh(int lastSessionRefresh) {-        this.updated |= this.lastSessionRefresh != lastSessionRefresh;-        this.lastSessionRefresh = lastSessionRefresh;-    }--    public long getExpiration() {-        return expiration;+        @Override+        public String toString() {+            return String.format(""%s@%08x"", getId(), hashCode());+        }     } -    public void setExpiration(long expiration) {-        this.updated |= this.expiration != expiration;-        this.expiration = expiration;-    }+    String getRealmId();+    void setRealmId(String realmId); -    public Map<String, String> getNotes() {-        return notes;-    }--    public String getNote(String name) {-        return notes.get(name);-    }+    String getUserId();+    void setUserId(String userId); -    public void setNotes(Map<String, String> notes) {-        this.updated |= !Objects.equals(this.notes, notes);-        this.notes = notes;-    }+    String getBrokerSessionId();+    void setBrokerSessionId(String brokerSessionId); -    public String removeNote(String name) {-        String note = this.notes.remove(name);-        this.updated |= note != null;-        return note;-    }+    String getBrokerUserId();+    void setBrokerUserId(String brokerUserId); -    public void addNote(String name, String value) {-        this.updated |= !Objects.equals(this.notes.put(name, value), value);-    }+    String getLoginUsername();+    void setLoginUsername(String loginUsername); -    public UserSessionModel.State getState() {-        return state;-    }+    String getIpAddress();+    void setIpAddress(String ipAddress); -    public void setState(UserSessionModel.State state) {-        this.updated |= !Objects.equals(this.state, state);-        this.state = state;-    }+    String getAuthMethod();+    void setAuthMethod(String authMethod); -    public Map<String, String> getAuthenticatedClientSessions() {-        return authenticatedClientSessions;-    }+    Boolean isRememberMe();+    void setRememberMe(Boolean rememberMe); -    public void setAuthenticatedClientSessions(Map<String, String> authenticatedClientSessions) {-        this.updated |= !Objects.equals(this.authenticatedClientSessions, authenticatedClientSessions);-        this.authenticatedClientSessions = authenticatedClientSessions;-    }+    Integer getStarted();+    void setStarted(Integer started); -    public void addAuthenticatedClientSession(String clientId, String clientSessionId) {-        this.updated |= !Objects.equals(this.authenticatedClientSessions.put(clientId, clientSessionId), clientSessionId);-    }+    Integer getLastSessionRefresh(); -    public String removeAuthenticatedClientSession(String clientId) {-        String entity = this.authenticatedClientSessions.remove(clientId);-        this.updated |= entity != null;-        return entity;-    }+    void setLastSessionRefresh(Integer lastSessionRefresh); -    public void clearAuthenticatedClientSessions() {-        this.updated |= !authenticatedClientSessions.isEmpty();-        this.authenticatedClientSessions.clear();-    }+    Long getExpiration();+    void setExpiration(Long expiration); -    public boolean isOffline() {-        return offline;-    }+    Map<String, String> getNotes();+    String getNote(String name);+    void setNotes(Map<String, String> notes);+    Boolean removeNote(String name);+    void setNote(String name, String value); -    public void setOffline(boolean offline) {-        this.updated |= this.offline != offline;-        this.offline = offline;-    }+    UserSessionModel.State getState();+    void setState(UserSessionModel.State state); -    public UserSessionModel.SessionPersistenceState getPersistenceState() {-        return persistenceState;-    }+    Map<String, String> getAuthenticatedClientSessions();+    void setAuthenticatedClientSessions(Map<String, String> authenticatedClientSessions);+    String getAuthenticatedClientSession(String clientUUID);","Not sure it is applicable here, but in other entities when we have a similar method for getting from `Set` based on some identifier, we use `Optional` as the return value. Should we make it consistent?",x
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/11029,839718374,2022-03-31T15:03:00Z,docs/guides/src/main/operator/basic-deployment.adoc,"@@ -0,0 +1,174 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Basic Keycloak Deployment""+summary=""How to install Keycloak using the Operator on Kubernetes or OpenShift"">++== Basic Keycloak Deployment+In this guide we will show how to have a basic Keycloak Deployment on Kubernetes or OpenShift using the Operator.+We assume that the Operator is correctly installed and running in the cluster namespace.++=== Pre-requisites++* Database+* Hostname+* TLS Certificate and associated keys++==== Database++A database should be available and accessible from the cluster namespace where you want to install Keycloak.+Please refer to <@links.server id=""db""/> for the list of supported databases.+The Keycloak Operator does not manage the database and you need to provision it yourself, we suggest to verify your cloud provider offering or use a database Operator such as Crunchy[https://access.crunchydata.com/documentation/postgres-operator/latest/].","I noticed the link doesn't render correctly:![Screenshot 2022-03-31 at 17 01 19](https://user-images.githubusercontent.com/13906855/161086817-a6129f5c-88f8-4c6a-befc-6d371ab9fae7.png)We probably need something like:```suggestionThe Keycloak Operator does not manage the database and you need to provision it yourself, we suggest to verify your cloud provider offering or use a database Operator such as https://access.crunchydata.com/documentation/postgres-operator/latest/[Crunchy].```Ref.: https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,840644876,2022-04-01T14:31:46Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/realm/JpaRealmModelCriteriaBuilder.java,"@@ -0,0 +1,81 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.realm;++import java.util.function.BiFunction;++import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.Predicate;+import javax.persistence.criteria.Root;++import org.keycloak.models.RealmModel;+import org.keycloak.models.map.realm.entity.MapComponentEntity;+import org.keycloak.models.map.realm.entity.MapComponentEntityImpl;+import org.keycloak.models.map.storage.CriterionNotSupportedException;+import org.keycloak.models.map.storage.jpa.JpaModelCriteriaBuilder;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;+import org.keycloak.models.map.storage.jpa.realm.entity.JpaRealmEntity;+import org.keycloak.storage.SearchableModelField;++import static org.keycloak.models.map.storage.jpa.JpaMapStorageProviderFactory.CLONER;++public class JpaRealmModelCriteriaBuilder extends JpaModelCriteriaBuilder<JpaRealmEntity, RealmModel, JpaRealmModelCriteriaBuilder> {++    public JpaRealmModelCriteriaBuilder() {+        super(JpaRealmModelCriteriaBuilder::new);+    }++    private JpaRealmModelCriteriaBuilder(final BiFunction<CriteriaBuilder, Root<JpaRealmEntity>, Predicate> predicateFunc) {+        super(JpaRealmModelCriteriaBuilder::new, predicateFunc);+    }++    @Override+    public JpaRealmModelCriteriaBuilder compare(SearchableModelField<? super RealmModel> modelField, Operator op, Object... value) {+        switch(op) {+            case EQ:+                if (modelField.equals(RealmModel.SearchableFields.NAME)) {+                    validateValue(value, modelField, op, String.class);+                    return new JpaRealmModelCriteriaBuilder((cb, root) ->+                            cb.equal(root.get(modelField.getName()), value[0])+                    );+                } else if (modelField.equals(RealmModel.SearchableFields.COMPONENT_PROVIDER_TYPE)) {","Yes, inverted index was added for the components",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,840656431,2022-04-01T14:42:30Z,services/src/main/java/org/keycloak/services/managers/RealmManager.java,"@@ -93,11 +93,17 @@ public RealmModel getRealmByName(String name) {     }      public RealmModel createRealm(String name) {-        return createRealm(name, name);+        return createRealm(null, name);     }      public RealmModel createRealm(String id, String name) {-        if (id == null) {+        // map storage requires UUIDs+        if (Profile.isFeatureEnabled(Profile.Feature.MAP_STORAGE)) {+            if (!KeycloakModelUtils.isValidUUID(id)) {+                id = KeycloakModelUtils.generateId();+            }+        }","UUID ids are being enforced only when the map storage is enabled as it was not a requirement for the legacy storage. We need to decide if we simply convert non-conforming ids automatically as the code above is doing, or if we want to throw a validation error.Conversion is essential to be able to support importing legacy realms as those will come with the previously exported id, which can be a non-UUID string. We may, however, introduce a system property so that users can enforce UUIDs if they want to. Something like ""keycloak.map_storage.reject_invalid_ids"" which would be false by default, but can be turned on to make the above block throw an exception instead. Thoughts?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/10901,841619705,2022-04-04T11:09:08Z,services/src/main/java/org/keycloak/services/managers/RealmManager.java,"@@ -93,11 +93,17 @@ public RealmModel getRealmByName(String name) {     }      public RealmModel createRealm(String name) {-        return createRealm(name, name);+        return createRealm(null, name);     }      public RealmModel createRealm(String id, String name) {-        if (id == null) {+        // map storage requires UUIDs+        if (Profile.isFeatureEnabled(Profile.Feature.MAP_STORAGE)) {+            if (!KeycloakModelUtils.isValidUUID(id)) {+                id = KeycloakModelUtils.generateId();+            }+        }",I think the configuration option would be nice. I agree with the proposed solution to have it by default set to false and throw an exception when set to true. On top of that I think we should add a warning which would alert a user that the id of realm is going to be changed.,
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/11065,842525559,2022-04-05T08:41:12Z,docs/guides/src/main/operator/advanced-configuration.adoc,"@@ -0,0 +1,113 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Advanced configuration""+summary=""How to tune advanced aspects of the Keycloak CR"">++== Advanced Configuration+In this guide we will show how advanced concepts and options provided by Custom Resources (CR).++=== Server Configuration details++The `serverConfiguration` field of the Keycloak CR allow to pass to Keycloak any available configuration in the form of key-value pairs.+For all the available configuration options refer to <@links.server id=""all-config""/>.++The values can be expressed as plain text strings or Kubernetes Secret references.+e.g:++[source,yaml]+----+apiVersion: keycloak.org/v2alpha1+kind: Keycloak+metadata:+  name: example-kc+spec:+  ...+  serverConfiguration:+    - name: db+      value: postgres # plain text value+    - name: db-url-host+      value: postgres-db # plain text value+    - name: db-username+      secret: # Secret reference+        name: keycloak-db-secret # name of the Secret+        key: username # name of the Key in the Secret+    - name: db-password+      secret: # secret reference+        name: keycloak-db-secret # name of the Secret+        key: password # name of the Key in the Secret+----++=== Secret References++A Secret Reference can be either a value in `serverConfiguration` or the `tlsSecret`.++When specifying a Secret Reference you have to make sure that a Secret containing the referenced keys is present in the same namespace as the CR referencing it.+Along with the Keycloak Server Deployment the operator will add special labels to the referenced Secrets in order to watch for changes.","```suggestionAlong with the Keycloak Server Deployment, the operator adds special labels to the referenced Secrets in order to watch for changes.```",
89905860,DGuhr,https://api.github.com/repos/keycloak/keycloak/pulls/11065,842531141,2022-04-05T08:47:02Z,docs/guides/src/main/operator/advanced-configuration.adoc,"@@ -0,0 +1,113 @@+<#import ""/templates/guide.adoc"" as tmpl>+<#import ""/templates/kc.adoc"" as kc>+<#import ""/templates/options.adoc"" as opts>+<#import ""/templates/links.adoc"" as links>++<@tmpl.guide+title=""Advanced configuration""+summary=""How to tune advanced aspects of the Keycloak CR"">++== Advanced Configuration+In this guide we will show how advanced concepts and options provided by Custom Resources (CR).++=== Server Configuration details++The `serverConfiguration` field of the Keycloak CR allow to pass to Keycloak any available configuration in the form of key-value pairs.+For all the available configuration options refer to <@links.server id=""all-config""/>.++The values can be expressed as plain text strings or Kubernetes Secret references.+e.g:++[source,yaml]+----+apiVersion: keycloak.org/v2alpha1+kind: Keycloak+metadata:+  name: example-kc+spec:+  ...+  serverConfiguration:+    - name: db+      value: postgres # plain text value+    - name: db-url-host+      value: postgres-db # plain text value+    - name: db-username+      secret: # Secret reference+        name: keycloak-db-secret # name of the Secret+        key: username # name of the Key in the Secret+    - name: db-password+      secret: # secret reference+        name: keycloak-db-secret # name of the Secret+        key: password # name of the Key in the Secret+----++=== Secret References++A Secret Reference can be either a value in `serverConfiguration` or the `tlsSecret`.++When specifying a Secret Reference you have to make sure that a Secret containing the referenced keys is present in the same namespace as the CR referencing it.+Along with the Keycloak Server Deployment the operator will add special labels to the referenced Secrets in order to watch for changes.++When a referenced Secret is modified the operator will automatically perform a rolling restart of the Keycloak Deployment to pick up the changes.++=== Unsupported features++The `unsupported` field of the CR contains highly experimental configuration options that are not completely tested and supported.++==== Pod Template++Pod Template is a raw API representation that is used for the Kubernetes Deployment Template.++.Note:+[NOTE]+You should use this field as a temporary workaround if there is no officially supported field at the top level of the CR to cover your use-case.","When writing the kc17 docs, we tried to make nearly no use of "".Note"", as you could normally incorporate your ""Note"" into the normal text or give it its own sub-headline. Example for this one: ""Pod Template is a raw API representation that is used for the Kubernetes Deployment Template. This field is intended to be used as a temporary workaround if there is no officially supported field at the top level of the CR to cover your use-case. Please consider opening an issue on GitHub to help us make the experience better.""That said: not hard on this ;) @stianst suggested to not make heavy use of notes, so I tried not to.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,843154499,2022-04-05T18:48:33Z,model/map/src/main/java/org/keycloak/models/map/common/UuidValidator.java,"@@ -0,0 +1,101 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common;++import java.util.regex.Pattern;++import javax.ws.rs.BadRequestException;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.map.storage.MapStorageSpi;++/**+ * Utility class for validating and converting UUIDs.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class UuidValidator {++    protected static final Logger logger = Logger.getLogger(UuidValidator.class);++    protected static final Pattern UUID_REGEX_PATTERN = Pattern.compile(""^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$"");++    private UuidValidator() {}++    /**+     * Validates that the specified {@code id} is a {@code UUID}.+     *+     * @param id the {@code id} to be validated.+     * @return {@code true} if the {@code id} is a {@code UUID}; {@code false} otherwise.+     */+    public static boolean validate(final String id) {+        return (id == null) ? false : UUID_REGEX_PATTERN.matcher(id).matches();+    }++    /**+     * Validates that the specified {@code id} is a {@code UUID}. If it is, the {@code id} itself is returned. If the {@code id}+     * is {@code null}, a new {@code UUID} is generated and returned. If not, then the {@code mapStorage} configuration is checked+     * to determine whether the specified {@code id} should be rejected or if a new {@code UUID} should be created and returned+     * instead.+     *+     * @param id the {@code id} to be validated.+     * @param component the name of the component (e.g. realm, component) whose id is being validated.+     * @return the {@code id} itself if it is a valid {@code UUID}, or a new generated {@code UUID}.+     * @throws {@code InvalidUuidException} if the {@code id} is invalid and the {@code mapStorage} has been configured to+     * reject invalid ids.+     */+    public static String validateAndConvert(final String id, final String component) {+        boolean rejectInvalid = Boolean.parseBoolean(Config.scope(MapStorageSpi.NAME).get(""rejectInvalidIds""));+        return validateAndConvert(id, component, rejectInvalid);+    }",Just thinking a bit more about this validation/conversion of ids into UUIDs for the JPA storage.. using a config property from the `mapStorage` does feel a bit misplaced as other storage impls might not have this hard requirement of ids being UUIDs.Perhaps we should have this `rejectInvalidIds` config in the `jpa-map-storage` instead and inject its value into the created transactions. The transaction's `create` method can then run the `validateAndConvert` method using the flag that signals if an exception should be thrown or if the invalid id should be simply converted into an UUID.Thoughts?,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10901,843500068,2022-04-06T06:08:39Z,model/map/src/main/java/org/keycloak/models/map/realm/MapRealmProvider.java,"@@ -68,7 +76,9 @@ public RealmModel createRealm(String id, String name) {             throw new ModelDuplicateException(""Realm with given name exists: "" + name);         } -        if (id != null && tx.read(id) != null) {+        id = UuidValidator.validateAndConvert(id, ""realm"", Boolean.valueOf(","+1 for the javadoc. Actually I don't agree with the throwing an exception, it should always create a new one.",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/10901,843502528,2022-04-06T06:13:01Z,model/map/src/main/java/org/keycloak/models/map/common/UuidValidator.java,"@@ -0,0 +1,101 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common;++import java.util.regex.Pattern;++import javax.ws.rs.BadRequestException;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.map.storage.MapStorageSpi;++/**+ * Utility class for validating and converting UUIDs.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class UuidValidator {++    protected static final Logger logger = Logger.getLogger(UuidValidator.class);++    protected static final Pattern UUID_REGEX_PATTERN = Pattern.compile(""^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$"");++    private UuidValidator() {}++    /**+     * Validates that the specified {@code id} is a {@code UUID}.+     *+     * @param id the {@code id} to be validated.+     * @return {@code true} if the {@code id} is a {@code UUID}; {@code false} otherwise.+     */+    public static boolean validate(final String id) {+        return (id == null) ? false : UUID_REGEX_PATTERN.matcher(id).matches();+    }++    /**+     * Validates that the specified {@code id} is a {@code UUID}. If it is, the {@code id} itself is returned. If the {@code id}+     * is {@code null}, a new {@code UUID} is generated and returned. If not, then the {@code mapStorage} configuration is checked+     * to determine whether the specified {@code id} should be rejected or if a new {@code UUID} should be created and returned+     * instead.+     *+     * @param id the {@code id} to be validated.+     * @param component the name of the component (e.g. realm, component) whose id is being validated.+     * @return the {@code id} itself if it is a valid {@code UUID}, or a new generated {@code UUID}.+     * @throws {@code InvalidUuidException} if the {@code id} is invalid and the {@code mapStorage} has been configured to+     * reject invalid ids.+     */+    public static String validateAndConvert(final String id, final String component) {+        boolean rejectInvalid = Boolean.parseBoolean(Config.scope(MapStorageSpi.NAME).get(""rejectInvalidIds""));+        return validateAndConvert(id, component, rejectInvalid);+    }","Given the example of LDAP, the UUIDs are no requirement across all map storages. A store might decide to create IDs differently, and as long as they are a String they are fine to do so. Having a UUID might be default for Keycloak, and the only supported way for JPA, but this won't hold true for all map storages.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/10901,843579826,2022-04-06T07:37:15Z,model/map/src/main/java/org/keycloak/models/map/common/UuidValidator.java,"@@ -0,0 +1,101 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common;++import java.util.regex.Pattern;++import javax.ws.rs.BadRequestException;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.map.storage.MapStorageSpi;++/**+ * Utility class for validating and converting UUIDs.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class UuidValidator {++    protected static final Logger logger = Logger.getLogger(UuidValidator.class);++    protected static final Pattern UUID_REGEX_PATTERN = Pattern.compile(""^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$"");++    private UuidValidator() {}++    /**+     * Validates that the specified {@code id} is a {@code UUID}.+     *+     * @param id the {@code id} to be validated.+     * @return {@code true} if the {@code id} is a {@code UUID}; {@code false} otherwise.+     */+    public static boolean validate(final String id) {+        return (id == null) ? false : UUID_REGEX_PATTERN.matcher(id).matches();+    }++    /**+     * Validates that the specified {@code id} is a {@code UUID}. If it is, the {@code id} itself is returned. If the {@code id}+     * is {@code null}, a new {@code UUID} is generated and returned. If not, then the {@code mapStorage} configuration is checked+     * to determine whether the specified {@code id} should be rejected or if a new {@code UUID} should be created and returned+     * instead.+     *+     * @param id the {@code id} to be validated.+     * @param component the name of the component (e.g. realm, component) whose id is being validated.+     * @return the {@code id} itself if it is a valid {@code UUID}, or a new generated {@code UUID}.+     * @throws {@code InvalidUuidException} if the {@code id} is invalid and the {@code mapStorage} has been configured to+     * reject invalid ids.+     */+    public static String validateAndConvert(final String id, final String component) {+        boolean rejectInvalid = Boolean.parseBoolean(Config.scope(MapStorageSpi.NAME).get(""rejectInvalidIds""));+        return validateAndConvert(id, component, rejectInvalid);+    }",+1 to what @ahus1 wrote.Also: can `rejectInvalidIds` ever be false? Wouldn't passing in an invalid ID result in an exception from the store later upon saving the object?,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10893,843640012,2022-04-06T08:21:54Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapUserSessionProvider.java,"@@ -81,7 +81,8 @@ public MapUserSessionProvider(KeycloakSession session, MapStorage<MapUserSession     private Function<MapUserSessionEntity, UserSessionModel> userEntityToAdapterFunc(RealmModel realm) {         // Clone entity before returning back, to avoid giving away a reference to the live object to the caller         return (origEntity) -> {-            if (origEntity.getExpiration() <= Time.currentTime()) {+            long expiration = origEntity.getExpiration() != null ? origEntity.getExpiration() : 0l;+            if (expiration <= Time.currentTime()) {","Just out of curiosity, maybe we should start a discussion about this. Why are we doing this here? When we have the expiration field in store, should we just put this condition into MCB instead of manually checking it here?",x
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/11139,843791019,2022-04-06T10:40:41Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/HostnamePropertyMappers.java,"@@ -1,6 +1,14 @@ package org.keycloak.quarkus.runtime.configuration.mappers;  +import com.google.common.net.InternetDomainName;","I would avoid using Guava directly. Although it is available at runtime, we should avoid if possible a compile-time dependency.In the worst case, you should try using something from Apache libs as we are using it anyways.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/11139,843792758,2022-04-06T10:43:00Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/configuration/mappers/HostnamePropertyMappers.java,"@@ -44,6 +53,17 @@ private HostnamePropertyMappers(){}         };     } +    private static String getValidatedLowercaseHostname(String value, ConfigSourceInterceptorContext configSourceInterceptorContext) {++        String hostnameVal = value.toLowerCase(Locale.ROOT);","Are you sure the `Local.ROOT` local is the best here? IIRC, there are some languages that might not lower case some letters.Why not let it `user.language` dependent ?",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,843885286,2022-04-06T12:27:41Z,model/map/src/main/java/org/keycloak/models/map/realm/MapRealmProvider.java,"@@ -68,7 +76,9 @@ public RealmModel createRealm(String id, String name) {             throw new ModelDuplicateException(""Realm with given name exists: "" + name);         } -        if (id != null && tx.read(id) != null) {+        id = UuidValidator.validateAndConvert(id, ""realm"", Boolean.valueOf(",Based on the other comments I'll remove the exception part.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,843892359,2022-04-06T12:33:50Z,model/map/src/main/java/org/keycloak/models/map/common/UuidValidator.java,"@@ -0,0 +1,101 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common;++import java.util.regex.Pattern;++import javax.ws.rs.BadRequestException;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.map.storage.MapStorageSpi;++/**+ * Utility class for validating and converting UUIDs.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class UuidValidator {++    protected static final Logger logger = Logger.getLogger(UuidValidator.class);++    protected static final Pattern UUID_REGEX_PATTERN = Pattern.compile(""^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$"");++    private UuidValidator() {}++    /**+     * Validates that the specified {@code id} is a {@code UUID}.+     *+     * @param id the {@code id} to be validated.+     * @return {@code true} if the {@code id} is a {@code UUID}; {@code false} otherwise.+     */+    public static boolean validate(final String id) {+        return (id == null) ? false : UUID_REGEX_PATTERN.matcher(id).matches();+    }++    /**+     * Validates that the specified {@code id} is a {@code UUID}. If it is, the {@code id} itself is returned. If the {@code id}+     * is {@code null}, a new {@code UUID} is generated and returned. If not, then the {@code mapStorage} configuration is checked+     * to determine whether the specified {@code id} should be rejected or if a new {@code UUID} should be created and returned+     * instead.+     *+     * @param id the {@code id} to be validated.+     * @param component the name of the component (e.g. realm, component) whose id is being validated.+     * @return the {@code id} itself if it is a valid {@code UUID}, or a new generated {@code UUID}.+     * @throws {@code InvalidUuidException} if the {@code id} is invalid and the {@code mapStorage} has been configured to+     * reject invalid ids.+     */+    public static String validateAndConvert(final String id, final String component) {+        boolean rejectInvalid = Boolean.parseBoolean(Config.scope(MapStorageSpi.NAME).get(""rejectInvalidIds""));+        return validateAndConvert(id, component, rejectInvalid);+    }","@ahus1 @hmlnarik  Ok, so based on the discussion the conclusion is that the store has the freedom to convert ids at its own discretion, treating any supplied id as a suggestion. In that case, I should remove the id validation/conversion from the `MapRealmProvider` and `MapRealmAdapter` and move it to the JPA transaction `create` method. The reason being that converting at the logical layer is meaningless if other store, like LDAP, will have to convert it again.In JPA, once the store is invoked to create an entity it can validate if the incoming id is a UUID and convert if needed. I'll also remove the exception and log message. Can I proceed this way?",x
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,844112322,2022-04-06T15:50:56Z,services/src/main/java/org/keycloak/services/managers/RealmManager.java,"@@ -93,11 +93,17 @@ public RealmModel getRealmByName(String name) {     }      public RealmModel createRealm(String name) {-        return createRealm(name, name);+        return createRealm(null, name);     }      public RealmModel createRealm(String id, String name) {-        if (id == null) {+        // map storage requires UUIDs+        if (Profile.isFeatureEnabled(Profile.Feature.MAP_STORAGE)) {+            if (!KeycloakModelUtils.isValidUUID(id)) {+                id = KeycloakModelUtils.generateId();+            }+        }","That makes sense, @ahus1, thanks for sharing your thoughts. I've changed the code so no warning is printed and no exception is thrown, JPA store simply converts non-compliant ids into UUIDs.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,844113133,2022-04-06T15:51:42Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/BadRealmTest.java,"@@ -33,6 +35,10 @@ public void testBadRealmName(KeycloakSession session) {     @Test     @ModelTest     public void testBadRealmId(KeycloakSession session) {+        if (Profile.isFeatureEnabled(Profile.Feature.MAP_STORAGE)) {+            // when map storage is enabled, the id is always converted into a valid UUID.+            return;+        }",Leaving this piece as is - assumeFalse is throwing exception and failing the test instead of skipping it.,
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,844113583,2022-04-06T15:52:08Z,model/map/src/main/java/org/keycloak/models/map/common/UuidValidator.java,"@@ -0,0 +1,101 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.common;++import java.util.regex.Pattern;++import javax.ws.rs.BadRequestException;++import org.jboss.logging.Logger;+import org.keycloak.Config;+import org.keycloak.models.map.storage.MapStorageSpi;++/**+ * Utility class for validating and converting UUIDs.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class UuidValidator {++    protected static final Logger logger = Logger.getLogger(UuidValidator.class);++    protected static final Pattern UUID_REGEX_PATTERN = Pattern.compile(""^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$"");++    private UuidValidator() {}++    /**+     * Validates that the specified {@code id} is a {@code UUID}.+     *+     * @param id the {@code id} to be validated.+     * @return {@code true} if the {@code id} is a {@code UUID}; {@code false} otherwise.+     */+    public static boolean validate(final String id) {+        return (id == null) ? false : UUID_REGEX_PATTERN.matcher(id).matches();+    }++    /**+     * Validates that the specified {@code id} is a {@code UUID}. If it is, the {@code id} itself is returned. If the {@code id}+     * is {@code null}, a new {@code UUID} is generated and returned. If not, then the {@code mapStorage} configuration is checked+     * to determine whether the specified {@code id} should be rejected or if a new {@code UUID} should be created and returned+     * instead.+     *+     * @param id the {@code id} to be validated.+     * @param component the name of the component (e.g. realm, component) whose id is being validated.+     * @return the {@code id} itself if it is a valid {@code UUID}, or a new generated {@code UUID}.+     * @throws {@code InvalidUuidException} if the {@code id} is invalid and the {@code mapStorage} has been configured to+     * reject invalid ids.+     */+    public static String validateAndConvert(final String id, final String component) {+        boolean rejectInvalid = Boolean.parseBoolean(Config.scope(MapStorageSpi.NAME).get(""rejectInvalidIds""));+        return validateAndConvert(id, component, rejectInvalid);+    }","Done! All changes pushed based on the reviews. **EDIT:** still testing the best way to handle this, tx.create is not suitable for components as they are not created there but rather added to the realm-components relationship. Idea is to enforce the id conversion, if needed, in the JPA entities setId() method. Will update again once testing finishes.",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,844587836,2022-04-07T02:49:19Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/JpaMapKeycloakTransaction.java,"@@ -90,6 +89,7 @@ public E read(String key) {         CriteriaQuery<RE> query = cb.createQuery(entityType);         Root<RE> root = query.from(entityType);         query.select(selectCbConstruct(cb, root));+        if (mcb.isDistinct()) query.distinct(true);","Yes. The query that looks for realms that have a component of a type returns the same realm multiple times if the realm has multiple components of the same type. Then code [like this](https://github.com/keycloak/keycloak/blob/main/services/src/main/java/org/keycloak/services/managers/UserStorageSyncManager.java#L62) might end up processing the same realm more than once, which I think is not desirable.",x
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,844591322,2022-04-07T02:56:20Z,model/map/src/main/java/org/keycloak/models/map/realm/entity/MapAuthenticatorConfigEntity.java,"@@ -45,7 +45,9 @@ static AuthenticatorConfigModel toModel(MapAuthenticatorConfigEntity entity) {         AuthenticatorConfigModel model = new AuthenticatorConfigModel();         model.setId(entity.getId());         model.setAlias(entity.getAlias());-        model.setConfig(entity.getConfig());+        Map<String, String> config = new HashMap<>();+        if (entity.getConfig() != null) config.putAll(entity.getConfig());+        model.setConfig(config);","Ok, without this change this [test fails](https://github.com/keycloak/keycloak/blob/main/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/OwnerReplacementTest.java#L293) because the config is ""live"", meaning that changes to the config, like adding or removing properties end up being persisted.This change makes this entity consistent with other entities that also have a config map. (See the [MapComponentEntity](https://github.com/keycloak/keycloak/blob/main/model/map/src/main/java/org/keycloak/models/map/realm/entity/MapComponentEntity.java#L55))",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,844593620,2022-04-07T03:03:11Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/realm/delegate/JpaRealmDelegateProvider.java,"@@ -0,0 +1,81 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.realm.delegate;++import java.util.UUID;++import javax.persistence.EntityManager;+import javax.persistence.criteria.CriteriaBuilder;+import javax.persistence.criteria.CriteriaQuery;+import javax.persistence.criteria.JoinType;+import javax.persistence.criteria.Root;++import org.keycloak.models.map.common.EntityField;+import org.keycloak.models.map.common.delegate.DelegateProvider;+import org.keycloak.models.map.realm.MapRealmEntity;+import org.keycloak.models.map.realm.MapRealmEntityFields;+import org.keycloak.models.map.storage.jpa.JpaDelegateProvider;+import org.keycloak.models.map.storage.jpa.realm.entity.JpaRealmEntity;++/**+ * A {@link DelegateProvider} implementation for {@link JpaRealmEntity}.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+public class JpaRealmDelegateProvider extends JpaDelegateProvider<JpaRealmEntity> implements DelegateProvider<MapRealmEntity> {++    private final EntityManager em;++    public JpaRealmDelegateProvider(final JpaRealmEntity delegate, final EntityManager em) {+        super(delegate);+        this.em = em;+    }++    @Override+    public MapRealmEntity getDelegate(boolean isRead, Enum<? extends EntityField<MapRealmEntity>> field, Object... parameters) {+        if (getDelegate().isMetadataInitialized()) return getDelegate();+        if (isRead) {+            if (field instanceof MapRealmEntityFields) {+                switch ((MapRealmEntityFields) field) {+                    case ID:+                    case NAME:+                    case DISPLAY_NAME:+                    case DISPLAY_NAME_HTML:+                    case ENABLED:+                        return getDelegate();++                    case ATTRIBUTES:","I think so, and the impl would very very similar to the attributes. I'll add it.",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10893,844790723,2022-04-07T07:09:47Z,model/map/src/main/java/org/keycloak/models/map/userSession/MapAuthenticatedClientSessionEntity.java,"@@ -16,184 +16,80 @@  */ package org.keycloak.models.map.userSession; -import org.keycloak.common.util.Time;+import org.keycloak.models.map.annotations.GenerateEntityImplementations; import org.keycloak.models.map.common.AbstractEntity; +import org.keycloak.models.map.common.DeepCloner; import org.keycloak.models.map.common.UpdatableEntity; import java.util.Map;-import java.util.Objects;-import java.util.concurrent.ConcurrentHashMap;  /**  * @author <a href=""mailto:mkanis@redhat.com"">Martin Kanis</a>  */-public class MapAuthenticatedClientSessionEntity extends UpdatableEntity.Impl implements AbstractEntity {+@GenerateEntityImplementations(+        inherits = ""org.keycloak.models.map.userSession.MapAuthenticatedClientSessionEntity.AbstractAuthenticatedClientSessionEntity""+)+@DeepCloner.Root+public interface MapAuthenticatedClientSessionEntity extends AbstractEntity, UpdatableEntity { -    private String id;-    private String userSessionId;-    private String realmId;-    private String clientId;+    public abstract class AbstractAuthenticatedClientSessionEntity extends UpdatableEntity.Impl implements MapAuthenticatedClientSessionEntity { -    /**-     * Flag signalizing that any of the setters has been meaningfully used.-     */+        private String id; -    private String authMethod;-    private String redirectUri;-    private volatile int timestamp;-    private long expiration;-    private String action;+        @Override+        public String getId() {+            return this.id;+        } -    private Map<String, String> notes = new ConcurrentHashMap<>();+        @Override+        public void setId(String id) {+            if (this.id != null) throw new IllegalStateException(""Id cannot be changed"");+            this.id = id;+            this.updated |= id != null;+        } -    private String currentRefreshToken;-    private int currentRefreshTokenUseCount;--    private boolean offline;--    public MapAuthenticatedClientSessionEntity() {}--    public MapAuthenticatedClientSessionEntity(String id, String userSessionId, String realmId, String clientId, boolean offline) {-        this.id = id;-        this.userSessionId = userSessionId;-        this.realmId = realmId;-        this.clientId = clientId;-        this.offline = offline;-        this.timestamp = Time.currentTime();+        @Override+        public String toString() {","`toString` method is generated by our generator to something similar you use here. The advantage is, that with the generator we can change it in one place and it will be changed in each entity.See: https://github.com/keycloak/keycloak/blob/main/model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateEntityImplementationsProcessor.java#L336-L338And: https://github.com/keycloak/keycloak/blob/main/model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateHotRodEntityImplementationsProcessor.java#L212-L214",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/11077,844970300,2022-04-07T10:22:05Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientProviderFactory.java,"@@ -16,72 +16,55 @@  */ package org.keycloak.models.map.client; +import java.util.concurrent.ConcurrentHashMap;+import java.util.concurrent.ConcurrentMap; import org.keycloak.models.ClientModel; import org.keycloak.models.map.common.AbstractMapProviderFactory; import org.keycloak.models.ClientProvider; import org.keycloak.models.ClientProviderFactory; import org.keycloak.models.KeycloakSession;-import org.keycloak.models.KeycloakSessionFactory; import org.keycloak.models.RealmModel;-import org.keycloak.models.RoleContainerModel;-import org.keycloak.models.RoleContainerModel.RoleRemovedEvent; import org.keycloak.models.RoleModel;-import org.keycloak.provider.ProviderEvent;-import org.keycloak.provider.ProviderEventListener;-import java.util.concurrent.ConcurrentHashMap;-import java.util.concurrent.ConcurrentMap;+import org.keycloak.provider.InvalidationHandler;+import org.keycloak.provider.InvalidationHandler.InvalidableObjectType;++import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.CLIENT_AFTER_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.REALM_BEFORE_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.ROLE_BEFORE_REMOVE;  /**  *  * @author hmlnarik  */-public class MapClientProviderFactory extends AbstractMapProviderFactory<ClientProvider, MapClientEntity, ClientModel> implements ClientProviderFactory, ProviderEventListener {+public class MapClientProviderFactory extends AbstractMapProviderFactory<ClientProvider, MapClientEntity, ClientModel> implements ClientProviderFactory, InvalidationHandler {      private final ConcurrentHashMap<String, ConcurrentMap<String, Integer>> REGISTERED_NODES_STORE = new ConcurrentHashMap<>(); -    private Runnable onClose;-     public MapClientProviderFactory() {-        super(ClientModel.class);+        super(ClientModel.class, ClientProvider.class);     }      @Override-    public void postInit(KeycloakSessionFactory factory) {-        factory.register(this);-        onClose = () -> factory.unregister(this);-    }--    @Override-    public MapClientProvider create(KeycloakSession session) {+    public MapClientProvider createNew(KeycloakSession session) {         return new MapClientProvider(session, getStorage(session), REGISTERED_NODES_STORE);     } -    @Override-    public void close() {-        super.close();-        onClose.run();-    }-     @Override     public String getHelpText() {         return ""Client provider"";     }      @Override-    public void onEvent(ProviderEvent event) {-        if (event instanceof RoleContainerModel.RoleRemovedEvent) {-            RoleRemovedEvent e = (RoleContainerModel.RoleRemovedEvent) event;-            RoleModel role = e.getRole();-            RoleContainerModel container = role.getContainer();-            RealmModel realm;-            if (container instanceof RealmModel) {-                realm = (RealmModel) container;-            } else if (container instanceof ClientModel) {-                realm = ((ClientModel) container).getRealm();-            } else {-                return;-            }-            ((MapClientProvider) e.getKeycloakSession().getProvider(ClientProvider.class)).preRemove(realm, role);+    public void invalidate(KeycloakSession session, InvalidableObjectType type, Object... params) {+        if (type == REALM_BEFORE_REMOVE) {+            ((MapClientProvider) create(session)).preRemove((RealmModel) params[0]);","Should we check the number of parameters here? Also, is it possible there will be more realms removed (meaning there will be, for example, 10 realm ids in the params argument) with one invalidate call? ",x
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/11147,844983124,2022-04-07T10:37:33Z,model/map/src/main/java/org/keycloak/models/map/TimeAdapter.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map;",This class can by perhaps put into `org.keycloak.models.map.common` package?,
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/11147,844996883,2022-04-07T10:54:52Z,model/map/src/main/java/org/keycloak/models/map/TimeAdapter.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map;++import org.jboss.logging.Logger;++/**+ * Wrapper for adapters around handling time in seconds.+ *+ * Will be removed once <a href=""https://github.com/keycloak/keycloak/issues/11053"">#11053</a> has been implemented.++ * @author Alexander Schwartz+ */+public class TimeAdapter {+    private static final Logger LOG = Logger.getLogger(TimeAdapter.class);++    /**+     * Wrapper to all unsafe downgrading from a Long to an Integer while Keycloak core still handles all time seconds as integers.+     * This is safer to downgrade the in several place that might me missed once the Core starts to use longs as timestamps as well.+     * Simplify/remove once <a href=""https://github.com/keycloak/keycloak/issues/11053"">#11053</a> has been implemented..+     */++    public static int fromLongWithTimeInSecondsToLongWithTimeAsInSeconds(Long timestamp) {+        if (timestamp > Integer.MAX_VALUE) {+            LOG.warn(""Trimmed time value found in the map store; value to loarge and not supported in core"");","```suggestion            LOG.warn(""Trimmed time value found in the map store; value too large and not supported in core"");```",
3359545,martin-kanis,https://api.github.com/repos/keycloak/keycloak/pulls/11147,844997868,2022-04-07T10:56:07Z,model/map/src/main/java/org/keycloak/models/map/TimeAdapter.java,"@@ -0,0 +1,55 @@+/*+ * Copyright 2022. Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map;++import org.jboss.logging.Logger;++/**+ * Wrapper for adapters around handling time in seconds.+ *+ * Will be removed once <a href=""https://github.com/keycloak/keycloak/issues/11053"">#11053</a> has been implemented.++ * @author Alexander Schwartz+ */+public class TimeAdapter {+    private static final Logger LOG = Logger.getLogger(TimeAdapter.class);++    /**+     * Wrapper to all unsafe downgrading from a Long to an Integer while Keycloak core still handles all time seconds as integers.+     * This is safer to downgrade the in several place that might me missed once the Core starts to use longs as timestamps as well.",> This is safer to downgrade the in several place that might me missed once the Core starts to use longs as timestamps as wellPlease fix this sentence,
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/11077,845203767,2022-04-07T14:27:04Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientProviderFactory.java,"@@ -16,72 +16,55 @@  */ package org.keycloak.models.map.client; +import java.util.concurrent.ConcurrentHashMap;+import java.util.concurrent.ConcurrentMap; import org.keycloak.models.ClientModel; import org.keycloak.models.map.common.AbstractMapProviderFactory; import org.keycloak.models.ClientProvider; import org.keycloak.models.ClientProviderFactory; import org.keycloak.models.KeycloakSession;-import org.keycloak.models.KeycloakSessionFactory; import org.keycloak.models.RealmModel;-import org.keycloak.models.RoleContainerModel;-import org.keycloak.models.RoleContainerModel.RoleRemovedEvent; import org.keycloak.models.RoleModel;-import org.keycloak.provider.ProviderEvent;-import org.keycloak.provider.ProviderEventListener;-import java.util.concurrent.ConcurrentHashMap;-import java.util.concurrent.ConcurrentMap;+import org.keycloak.provider.InvalidationHandler;+import org.keycloak.provider.InvalidationHandler.InvalidableObjectType;++import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.CLIENT_AFTER_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.REALM_BEFORE_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.ROLE_BEFORE_REMOVE;  /**  *  * @author hmlnarik  */-public class MapClientProviderFactory extends AbstractMapProviderFactory<ClientProvider, MapClientEntity, ClientModel> implements ClientProviderFactory, ProviderEventListener {+public class MapClientProviderFactory extends AbstractMapProviderFactory<ClientProvider, MapClientEntity, ClientModel> implements ClientProviderFactory, InvalidationHandler {      private final ConcurrentHashMap<String, ConcurrentMap<String, Integer>> REGISTERED_NODES_STORE = new ConcurrentHashMap<>(); -    private Runnable onClose;-     public MapClientProviderFactory() {-        super(ClientModel.class);+        super(ClientModel.class, ClientProvider.class);     }      @Override-    public void postInit(KeycloakSessionFactory factory) {-        factory.register(this);-        onClose = () -> factory.unregister(this);-    }--    @Override-    public MapClientProvider create(KeycloakSession session) {+    public MapClientProvider createNew(KeycloakSession session) {         return new MapClientProvider(session, getStorage(session), REGISTERED_NODES_STORE);     } -    @Override-    public void close() {-        super.close();-        onClose.run();-    }-     @Override     public String getHelpText() {         return ""Client provider"";     }      @Override-    public void onEvent(ProviderEvent event) {-        if (event instanceof RoleContainerModel.RoleRemovedEvent) {-            RoleRemovedEvent e = (RoleContainerModel.RoleRemovedEvent) event;-            RoleModel role = e.getRole();-            RoleContainerModel container = role.getContainer();-            RealmModel realm;-            if (container instanceof RealmModel) {-                realm = (RealmModel) container;-            } else if (container instanceof ClientModel) {-                realm = ((ClientModel) container).getRealm();-            } else {-                return;-            }-            ((MapClientProvider) e.getKeycloakSession().getProvider(ClientProvider.class)).preRemove(realm, role);+    public void invalidate(KeycloakSession session, InvalidableObjectType type, Object... params) {+        if (type == REALM_BEFORE_REMOVE) {",It'd be incorrect call when we got `null` session in these cases. Do we want to throw exception in this case?,x
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/11077,845217430,2022-04-07T14:39:39Z,model/map/src/main/java/org/keycloak/models/map/group/MapGroupProviderFactory.java,"@@ -16,70 +16,59 @@  */ package org.keycloak.models.map.group; -import org.keycloak.models.ClientModel;+import java.util.stream.Collectors; import org.keycloak.models.GroupModel; import org.keycloak.models.GroupProvider; import org.keycloak.models.GroupProviderFactory; import org.keycloak.models.KeycloakSession;-import org.keycloak.models.KeycloakSessionFactory; import org.keycloak.models.RealmModel;-import org.keycloak.models.RoleContainerModel;-import org.keycloak.models.RoleContainerModel.RoleRemovedEvent; import org.keycloak.models.RoleModel;--import org.keycloak.provider.ProviderEvent;-import org.keycloak.provider.ProviderEventListener; import org.keycloak.models.map.common.AbstractMapProviderFactory;+import org.keycloak.provider.InvalidationHandler;++import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.GROUP_AFTER_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.GROUP_BEFORE_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.REALM_BEFORE_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.ROLE_BEFORE_REMOVE;  /**  *  * @author mhajas  */-public class MapGroupProviderFactory extends AbstractMapProviderFactory<GroupProvider, MapGroupEntity, GroupModel> implements GroupProviderFactory, ProviderEventListener {--    private Runnable onClose;+public class MapGroupProviderFactory extends AbstractMapProviderFactory<GroupProvider, MapGroupEntity, GroupModel> implements GroupProviderFactory, InvalidationHandler {      public MapGroupProviderFactory() {-        super(GroupModel.class);-    }--    @Override-    public void postInit(KeycloakSessionFactory factory) {-        factory.register(this);-        onClose = () -> factory.unregister(this);+        super(GroupModel.class, GroupProvider.class);     }      @Override-    public MapGroupProvider create(KeycloakSession session) {+    public MapGroupProvider createNew(KeycloakSession session) {         return new MapGroupProvider(session, getStorage(session));     } -    @Override-    public void close() {-        super.close();-        onClose.run();-    }-     @Override     public String getHelpText() {         return ""Group provider"";     }      @Override-    public void onEvent(ProviderEvent event) {-        if (event instanceof RoleContainerModel.RoleRemovedEvent) {-            RoleRemovedEvent e = (RoleContainerModel.RoleRemovedEvent) event;-            RoleModel role = e.getRole();-            RoleContainerModel container = role.getContainer();-            RealmModel realm;-            if (container instanceof RealmModel) {-                realm = (RealmModel) container;-            } else if (container instanceof ClientModel) {-                realm = ((ClientModel) container).getRealm();-            } else {-                return;-            }-            ((MapGroupProvider) e.getKeycloakSession().getProvider(GroupProvider.class)).preRemove(realm, role);+    public void invalidate(KeycloakSession session, InvalidableObjectType type, Object... params) {+        if (type == REALM_BEFORE_REMOVE) {+            ((MapGroupProvider) create(session)).preRemove((RealmModel) params[0]);","I was not able to find a way how to achieve it. Returning type of `create(session)` is `T`: ```public T create(KeycloakSession session)```where `T` is defined at: `AbstractMapProviderFactory<T extends Provider, V extends AbstractEntity, M>` MapGroupProvider is defined as:```public class MapGroupProviderFactory extends AbstractMapProviderFactory<GroupProvider, MapGroupEntity, GroupModel> ...```where `GroupProvider` is the `T`. I'm not able to replace it by `MapGroupProvider`.Could you please guide me how I can achieve it?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/10949,845357846,2022-04-07T16:39:49Z,.github/workflows/operator-ci.yml,"@@ -50,38 +78,121 @@ jobs:           driver: docker           start args: '--addons=ingress' -      - name: Build the Keycloak Docker image-        run: |-          cd quarkus-          cp dist/target/keycloak-*.tar.gz container/-          cd container-          eval $(minikube -p minikube docker-env)-          docker build --build-arg KEYCLOAK_DIST=$(ls keycloak-*.tar.gz) . -t keycloak:${GITHUB_SHA}--      - name: Build a custom pre-augmented Keycloak Docker image-        working-directory: operator-        run: |-          eval $(minikube -p minikube docker-env)-          ./scripts/build-testing-docker-images.sh ${GITHUB_SHA} keycloak-       - name: Test operator running locally         working-directory: operator         run: |           mvn clean verify \               -Dquarkus.kubernetes.deployment-target=kubernetes \-              -Doperator.keycloak.image=keycloak:${GITHUB_SHA} \-              -Doperator.keycloak.image-pull-policy=Never \-              -Dtest.operator.kubernetes.ip=$(minikube ip) \-              -Dtest.operator.custom.image=custom-keycloak:${GITHUB_SHA}+              -Doperator.keycloak.image=${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_REPOSITORY }}/keycloak:${{ steps.vars.outputs.version }} \+              -Dtest.operator.custom.image=${{ secrets.TEST_DOCKER_REGISTRY }}/${{ secrets.TEST_DOCKER_REPOSITORY }}/custom-keycloak:${{ steps.vars.outputs.version }} \+              -Dtest.operator.kubernetes.ip=$(minikube ip)++  test-remote:+    name: Test remote+    runs-on: ubuntu-latest+    needs: [build]+    steps:+      - uses: actions/checkout@v3+      - name: Set outputs+        id: vars+        run: echo ""::set-output name=version::0.0.1-$(git rev-parse --short HEAD)""+      - name: Update maven settings+        run: mkdir -p ~/.m2 ; cp .github/settings.xml ~/.m2/+      - uses: actions/setup-java@v2+        with:+          distribution: 'temurin'+          java-version: ${{ env.JDK_VERSION }}+          cache: 'maven'+      - name: Setup Minikube-Kubernetes+        uses: manusa/actions-setup-minikube@v2.4.3+        with:+          minikube version: v1.24.0+          kubernetes version: v1.22.3","Just a nitpick, we can handle this separately. We might want to move the versions to some env var as we install minikube three times now (similarly to `JDK_VERSION`).",
21758,abstractj,https://api.github.com/repos/keycloak/keycloak/pulls/11174,845414714,2022-04-07T17:47:55Z,operator/pom.xml,"@@ -22,8 +22,9 @@         -->         <resteasy.version>4.7.5.Final</resteasy.version>         <wildfly.common.version>1.5.4.Final-format-001</wildfly.common.version>-        <jackson.version>2.13.1</jackson.version>-        <kubernetes-client.version>5.12.1</kubernetes-client.version>+        <jackson.version>2.13.2</jackson.version>+        <jackson.databind.version>2.13.2.2</jackson.databind.version>","@andreaTP You can safely delete the line above from my understanding. We don't make the use of this property for the Keycloak Operator dependencies. Also, please correct me if I'm wrong, but from my understanding `jackson-databind` is a transitive dependency from `kubernetes-client`. I reached this conclusion after looking into the maven dependency tree:```$ cd keycloak/operator &&  mvn dependency:tree | grep -i jackson-databind[INFO] org.keycloak:keycloak-operator:jar:999-SNAPSHOT[INFO] +- io.fabric8:crd-generator-api:jar:5.12.1:compile[INFO] |  +- io.fabric8:kubernetes-client:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-core:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-rbac:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-admissionregistration:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-apps:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-autoscaling:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-apiextensions:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-batch:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-certificates:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-coordination:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-discovery:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-events:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-extensions:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-flowcontrol:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-networking:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-metrics:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-policy:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-scheduling:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-storageclass:jar:5.12.1:compile[INFO] |  |  +- io.fabric8:kubernetes-model-node:jar:5.12.1:compile[INFO] |  |  +- com.squareup.okhttp3:okhttp:jar:3.14.9:compile[INFO] |  |  |  \- com.squareup.okio:okio:jar:1.17.2:compile[INFO] |  |  +- com.squareup.okhttp3:logging-interceptor:jar:3.14.9:compile[INFO] |  |  +- org.slf4j:slf4j-api:jar:1.7.30:compile[INFO] |  |  +- com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:jar:2.13.1:compile[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.13.1:compile>>>> [INFO] |  |  +- com.fasterxml.jackson.core:jackson-databind:jar:2.13.1:compile<<<<[INFO] |  |  +- com.fasterxml.jackson.core:jackson-core:jar:2.13.1:compile```",x
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/10519,845634627,2022-04-07T23:41:31Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/UserInfoEndpoint.java,"@@ -25,14 +25,17 @@ import org.keycloak.common.ClientConnection; import org.keycloak.common.VerificationException; import org.keycloak.common.constants.ServiceAccountConstants;-import org.keycloak.crypto.SignatureProvider;-import org.keycloak.crypto.SignatureSignerContext;-import org.keycloak.crypto.SignatureVerifierContext;+import org.keycloak.crypto.*;","If possible, importing classes without wildcard is better.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/10519,845653072,2022-04-08T00:34:59Z,services/src/main/java/org/keycloak/protocol/oidc/OIDCAdvancedConfigWrapper.java,"@@ -68,6 +68,26 @@ public boolean isUserInfoSignatureRequired() {         return getUserInfoSignedResponseAlg() != null;     } +    public void setUserInfoEncryptedResponseAlg(String algorithm) {+        setAttribute(OIDCConfigAttributes.USER_INFO_ENCRYPTED_RESPONSE_ALG, algorithm);+    }++    public String getUserInfoEncryptedResponseAlg() {+        return getAttribute(OIDCConfigAttributes.USER_INFO_ENCRYPTED_RESPONSE_ALG);+    }++    public String getUserInfoEncryptedResponseEnc() {+        return getAttribute(OIDCConfigAttributes.USER_INFO_ENCRYPTED_RESPONSE_ENC);+    }++    public void setUserInfoEncryptedResponseEnc(String algorithm) {+        setAttribute(OIDCConfigAttributes.USER_INFO_ENCRYPTED_RESPONSE_ENC, algorithm);+    }++    public boolean isUserInfoEncryptionRequired() {","According to [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata), the following patterns can support encryption.1. both `userinfo_encrypted_response_alg` and `userinfo_encrypted_response_enc` are specified.2. `userinfo_encrypted_response_alg` is specifed while `userinfo_encrypted_response_enc` is not specified.For the pattern 2, the default value of `userinfo_encrypted_response_enc` is A128CBC-HS256.Considering this point, how about the following?```    public boolean isUserInfoEncryptionRequired() {        return getUserInfoEncryptedResponseAlg() != null;    }```If so, codes (maybe `UserInfoEndpoint`) calling this method are also needed to be modified.",
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/10519,845661462,2022-04-08T01:01:33Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/UserInfoEndpoint.java,"@@ -260,6 +278,35 @@ private Response issueUserInfo(String tokenString) {         return cors.builder(responseBuilder).build();     } +    private String jweFromContent(String content, String jweContentType) {+        String encryptedToken = null;++        String algAlgorithm = session.tokens().cekManagementAlgorithm(TokenCategory.USERINFO);+        String encAlgorithm = session.tokens().encryptAlgorithm(TokenCategory.USERINFO);++        CekManagementProvider cekManagementProvider = session.getProvider(CekManagementProvider.class, algAlgorithm);+        JWEAlgorithmProvider jweAlgorithmProvider = cekManagementProvider.jweAlgorithmProvider();++        ContentEncryptionProvider contentEncryptionProvider = session.getProvider(ContentEncryptionProvider.class, encAlgorithm);+        JWEEncryptionProvider jweEncryptionProvider = contentEncryptionProvider.jweEncryptionProvider();++        ClientModel client = session.getContext().getClient();++        KeyWrapper keyWrapper = PublicKeyStorageManager.getClientPublicKeyWrapper(session, client, JWK.Use.ENCRYPTION, algAlgorithm);+        if (keyWrapper == null) {+            throw new RuntimeException(""can not get encryption KEK"");",How about following the exception handling of `TokenEndpoint`'s ID token encryption?https://github.com/keycloak/keycloak/blob/9cb38087b48ac018129c218b6d37693dff8f1569/services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java#L455-L462,
25092005,tnorimat,https://api.github.com/repos/keycloak/keycloak/pulls/10519,845679175,2022-04-08T01:54:52Z,themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties,"@@ -404,6 +404,10 @@ id-token-encrypted-response-enc=ID Token Encryption Content Encryption Algorithm id-token-encrypted-response-enc.tooltip=JWA Algorithm used for content encryption in encrypting ID tokens. This option is needed just if you want encrypted ID tokens. If left empty, ID Tokens are just signed, but not encrypted. user-info-signed-response-alg=User Info Signed Response Algorithm user-info-signed-response-alg.tooltip=JWA algorithm used for signed User Info Endpoint response. If set to 'unsigned', User Info Response won't be signed and will be returned in application/json format.+user-info-encrypted-response-alg=User Info Response Encryption Key Management Algorithm+user-info-encrypted-response-alg.tooltip=JWA Algorithm used for key management in encrypting User Info Endpoint responses. This option is needed if you want encrypted User Info Endpoint responses. If left empty, User Info Endpoint responses are not encrypted.+user-info-encrypted-response-enc=User Info Response Encryption Content Encryption Algorithm+user-info-encrypted-response-enc.tooltip=JWA Algorithm used for content encryption in encrypting User Info Endpoint responses. This option is needed just if you want encrypted User Info Endpoint responses. If left empty, User Info Endpoint responses are not encrypted.","According to [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata), the following patterns can support encryption.1. both `userinfo_encrypted_response_alg` and `userinfo_encrypted_response_enc` are specified.2. `userinfo_encrypted_response_alg` is specifed while `userinfo_encrypted_response_enc` is not specified.For the pattern 2, the default value of `userinfo_encrypted_response_enc` is A128CBC-HS256.",
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/11077,846077412,2022-04-08T12:48:29Z,model/map/src/main/java/org/keycloak/models/map/user/MapUserProviderFactory.java,"@@ -43,4 +55,18 @@ public String getHelpText() {         return ""User provider"";     } +    @Override+    public void invalidate(KeycloakSession session, InvalidableObjectType type, Object... params) {+        if (type == REALM_BEFORE_REMOVE) {+            session.users().preRemove((RealmModel) params[0]);",We cannot allow that. It is either legacy or map. At least as long as the legacy store is not onboarded to the invalidation mechanism,
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/11077,846090820,2022-04-08T13:04:25Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientProviderFactory.java,"@@ -16,72 +16,55 @@  */ package org.keycloak.models.map.client; +import java.util.concurrent.ConcurrentHashMap;+import java.util.concurrent.ConcurrentMap; import org.keycloak.models.ClientModel; import org.keycloak.models.map.common.AbstractMapProviderFactory; import org.keycloak.models.ClientProvider; import org.keycloak.models.ClientProviderFactory; import org.keycloak.models.KeycloakSession;-import org.keycloak.models.KeycloakSessionFactory; import org.keycloak.models.RealmModel;-import org.keycloak.models.RoleContainerModel;-import org.keycloak.models.RoleContainerModel.RoleRemovedEvent; import org.keycloak.models.RoleModel;-import org.keycloak.provider.ProviderEvent;-import org.keycloak.provider.ProviderEventListener;-import java.util.concurrent.ConcurrentHashMap;-import java.util.concurrent.ConcurrentMap;+import org.keycloak.provider.InvalidationHandler;+import org.keycloak.provider.InvalidationHandler.InvalidableObjectType;++import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.CLIENT_AFTER_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.REALM_BEFORE_REMOVE;+import static org.keycloak.models.map.common.AbstractMapProviderFactory.MapProviderObjectType.ROLE_BEFORE_REMOVE;  /**  *  * @author hmlnarik  */-public class MapClientProviderFactory extends AbstractMapProviderFactory<ClientProvider, MapClientEntity, ClientModel> implements ClientProviderFactory, ProviderEventListener {+public class MapClientProviderFactory extends AbstractMapProviderFactory<ClientProvider, MapClientEntity, ClientModel> implements ClientProviderFactory, InvalidationHandler {      private final ConcurrentHashMap<String, ConcurrentMap<String, Integer>> REGISTERED_NODES_STORE = new ConcurrentHashMap<>(); -    private Runnable onClose;-     public MapClientProviderFactory() {-        super(ClientModel.class);+        super(ClientModel.class, ClientProvider.class);     }      @Override-    public void postInit(KeycloakSessionFactory factory) {-        factory.register(this);-        onClose = () -> factory.unregister(this);-    }--    @Override-    public MapClientProvider create(KeycloakSession session) {+    public MapClientProvider createNew(KeycloakSession session) {         return new MapClientProvider(session, getStorage(session), REGISTERED_NODES_STORE);     } -    @Override-    public void close() {-        super.close();-        onClose.run();-    }-     @Override     public String getHelpText() {         return ""Client provider"";     }      @Override-    public void onEvent(ProviderEvent event) {-        if (event instanceof RoleContainerModel.RoleRemovedEvent) {-            RoleRemovedEvent e = (RoleContainerModel.RoleRemovedEvent) event;-            RoleModel role = e.getRole();-            RoleContainerModel container = role.getContainer();-            RealmModel realm;-            if (container instanceof RealmModel) {-                realm = (RealmModel) container;-            } else if (container instanceof ClientModel) {-                realm = ((ClientModel) container).getRealm();-            } else {-                return;-            }-            ((MapClientProvider) e.getKeycloakSession().getProvider(ClientProvider.class)).preRemove(realm, role);+    public void invalidate(KeycloakSession session, InvalidableObjectType type, Object... params) {+        if (type == REALM_BEFORE_REMOVE) {",We can throw an exception in that case - session should be set for all invalidation events except those where it is clearly stated in javadoc that session is undefined.,
1269520,sonOfRa,https://api.github.com/repos/keycloak/keycloak/pulls/11202,846332071,2022-04-08T17:15:37Z,themes/src/main/resources/theme/base/login/template.ftl,"@@ -29,9 +29,19 @@             <script src=""${url.resourcesPath}/${script}"" type=""text/javascript""></script>         </#list>     </#if>+    <#if properties.asyncScripts?has_content>",This allows a theme extending base (or another theme that extends base) to add scripts that should be loaded with the async or defer parameters,
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10936,847056254,2022-04-11T08:11:15Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/IckleQueryWhereClauses.java,"@@ -154,4 +157,31 @@ private static String whereClauseForConsentClientFederationLink(String modelFiel         String providerId = new StorageId((String) values[0], """").getId();         return IckleQueryOperators.combineExpressions(ModelCriteriaBuilder.Operator.LIKE, getFieldName(UserModel.SearchableFields.CONSENT_FOR_CLIENT), new String[] {providerId + ""%""}, parameters);     }++    private static String whereClauseForUserSessionClientId(String modelFieldName, ModelCriteriaBuilder.Operator op, Object[] values, Map<String, Object> parameters) {","This method seems to be unnecessary. Can this be changed to:```INFINISPAN_NAME_OVERRIDES.put(UserSessionModel.SearchableFields.CLIENT_ID, ""authenticatedClientSessions.key"");```",x
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/10901,847728758,2022-04-11T20:55:36Z,model/map-jpa/src/main/java/org/keycloak/models/map/storage/jpa/realm/entity/JpaRealmEntity.java,"@@ -0,0 +1,1023 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.models.map.storage.jpa.realm.entity;++import java.util.HashMap;+import java.util.HashSet;+import java.util.LinkedList;+import java.util.List;+import java.util.Map;+import java.util.Objects;+import java.util.Optional;+import java.util.Set;+import java.util.UUID;+import java.util.stream.Collectors;++import javax.persistence.Basic;+import javax.persistence.CascadeType;+import javax.persistence.Column;+import javax.persistence.Entity;+import javax.persistence.FetchType;+import javax.persistence.Id;+import javax.persistence.OneToMany;+import javax.persistence.Table;+import javax.persistence.UniqueConstraint;+import javax.persistence.Version;++import org.hibernate.annotations.Type;+import org.hibernate.annotations.TypeDef;+import org.hibernate.annotations.TypeDefs;+import org.keycloak.models.map.common.DeepCloner;+import org.keycloak.models.map.common.UuidValidator;+import org.keycloak.models.map.realm.MapRealmEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationExecutionEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticationFlowEntity;+import org.keycloak.models.map.realm.entity.MapAuthenticatorConfigEntity;+import org.keycloak.models.map.realm.entity.MapClientInitialAccessEntity;+import org.keycloak.models.map.realm.entity.MapComponentEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderEntity;+import org.keycloak.models.map.realm.entity.MapIdentityProviderMapperEntity;+import org.keycloak.models.map.realm.entity.MapOTPPolicyEntity;+import org.keycloak.models.map.realm.entity.MapRequiredActionProviderEntity;+import org.keycloak.models.map.realm.entity.MapRequiredCredentialEntity;+import org.keycloak.models.map.realm.entity.MapWebAuthnPolicyEntity;+import org.keycloak.models.map.storage.jpa.JpaRootVersionedEntity;+import org.keycloak.models.map.storage.jpa.hibernate.jsonb.JsonbType;++import static org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_REALM;+import static org.keycloak.models.map.storage.jpa.JpaMapStorageProviderFactory.CLONER;++/**+ * JPA {@link MapRealmEntity} implementation. Some fields are annotated with {@code @Column(insertable = false, updatable = false)}+ * to indicate that they are automatically generated from json fields. As such, these fields are non-insertable and non-updatable.+ *+ * @author <a href=""mailto:sguilhen@redhat.com"">Stefan Guilhen</a>+ */+@Entity+@Table(name = ""kc_realm"",+    uniqueConstraints = {+        @UniqueConstraint(+                columnNames = {""name""}+        )+})+@TypeDefs({@TypeDef(name = ""jsonb"", typeClass = JsonbType.class)})+public class JpaRealmEntity extends MapRealmEntity.AbstractRealmEntity implements JpaRootVersionedEntity {++    @Id+    @Column+    private UUID id;++    //used for implicit optimistic locking+    @Version+    @Column+    private int version;++    @Type(type = ""jsonb"")+    @Column(columnDefinition = ""jsonb"")+    private final JpaRealmMetadata metadata;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Integer entityVersion;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String name;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String displayName;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private String displayNameHtml;++    @Column(insertable = false, updatable = false)+    @Basic(fetch = FetchType.LAZY)+    private Boolean enabled;++    @OneToMany(mappedBy = ""root"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaRealmAttributeEntity> attributes = new HashSet<>();++    @OneToMany(mappedBy = ""root"", cascade = CascadeType.PERSIST, orphanRemoval = true)+    private final Set<JpaComponentEntity> components = new HashSet<>();++    /**+     * No-argument constructor, used by hibernate to instantiate entities.+     */+    public JpaRealmEntity() {+        this.metadata = new JpaRealmMetadata();+    }++    public JpaRealmEntity(final DeepCloner cloner) {+        this.metadata = new JpaRealmMetadata(cloner);+    }++    /**+     * Used by hibernate when calling cb.construct from read(QueryParameters) method.+     * It is used to select realm without metadata(json) field.+     */+    public JpaRealmEntity(final UUID id, final int version, final Integer entityVersion, final String name,+                          final String displayName, final String displayNameHtml, final Boolean enabled) {+        this.id = id;+        this.version = version;+        this.entityVersion = entityVersion;+        this.name = name;+        this.displayName = displayName;+        this.displayNameHtml = displayNameHtml;+        this.enabled = enabled;+        this.metadata = null;+    }++    public boolean isMetadataInitialized() {+        return metadata != null;+    }++    @Override+    public Integer getEntityVersion() {+        if (isMetadataInitialized()) return metadata.getEntityVersion();+        return entityVersion;+    }++    @Override+    public void setEntityVersion(Integer entityVersion) {+        metadata.setEntityVersion(entityVersion);+    }++    @Override+    public Integer getCurrentSchemaVersion() {+        return CURRENT_SCHEMA_VERSION_REALM;+    }++    @Override+    public int getVersion() {+        return version;+    }++    @Override+    public String getId() {+        return id == null ? null : id.toString();+    }++    @Override+    public void setId(String id) {+        String validatedId = UuidValidator.validateAndConvert(id);","create wouldn't work for entities such as the ComponentEntity because its creation happens when it is added to the components relationship - i.e. components are not created via `tx.create`. I would indeed put this check in every entity's `setId(String id)` because this is always called, whether from the `tx.create` or when creating an entity by adding it to a relationship (such as components or auth sessions that are added to the root auth session).",x
5391360,hmlnarik,https://api.github.com/repos/keycloak/keycloak/pulls/11229,848274447,2022-04-12T10:28:42Z,model/map-jpa/src/main/resources/META-INF/user-login-failures/jpa-user-login-failures-changelog-1.xml,"@@ -0,0 +1,51 @@+<?xml version=""1.0"" encoding=""UTF-8""?>+<!--+Copyright 2022 Red Hat, Inc. and/or its affiliates+and other contributors as indicated by the @author tags.++Licensed under the Apache License, Version 2.0 (the ""License"");+you may not use this file except in compliance with the License.+You may obtain a copy of the License at++http://www.apache.org/licenses/LICENSE-2.0++Unless required by applicable law or agreed to in writing, software+distributed under the License is distributed on an ""AS IS"" BASIS,+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+See the License for the specific language governing permissions and+limitations under the License.+-->+++<databaseChangeLog xmlns=""http://www.liquibase.org/xml/ns/dbchangelog"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""+                   xmlns:ext=""http://www.liquibase.org/xml/ns/dbchangelog-ext""+                   xsi:schemaLocation=""http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd+                    http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd"">++    <!-- format of id of changeSet: user-login-failures-${org.keycloak.models.map.storage.jpa.Constants.CURRENT_SCHEMA_VERSION_USER_LOGIN_FAILURE} -->+    <changeSet author=""keycloak"" id=""user-login-failures-1"">++        <createTable tableName=""kc_user_login_failure"">+            <column name=""id"" type=""UUID"">+                <constraints primaryKey=""true"" nullable=""false""/>+            </column>+            <column name=""version"" type=""INTEGER"" defaultValueNumeric=""0"">+                <constraints nullable=""false""/>+            </column>+            <column name=""metadata"" type=""json""/>+        </createTable>+        <ext:addGeneratedColumn tableName=""kc_user_login_failure"">+            <ext:column name=""entityversion"" type=""INTEGER"" jsonColumn=""metadata"" jsonProperty=""entityVersion""/>+            <ext:column name=""realmid"" type=""VARCHAR(36)"" jsonColumn=""metadata"" jsonProperty=""fRealmId""/>","Realm ID is not necessarily a UUID, hence 36 characters might not suffice```suggestion            <ext:column name=""realmid"" type=""VARCHAR(255)"" jsonColumn=""metadata"" jsonProperty=""fRealmId""/>```",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/10936,848278576,2022-04-12T10:33:40Z,model/map-hot-rod/src/main/java/org/keycloak/models/map/storage/hotRod/userSession/HotRodSessionState.java,"@@ -0,0 +1,46 @@+/*+ * Copyright 2022 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.models.map.storage.hotRod.userSession;++import org.infinispan.protostream.annotations.ProtoEnumValue;++public class HotRodSessionState {++    enum State {+        @ProtoEnumValue(number = 0)+        LOGGED_IN,++        @ProtoEnumValue(number = 1)+        LOGGING_OUT,++        @ProtoEnumValue(number = 2)+        LOGGED_OUT,++        @ProtoEnumValue(number = 3)+        LOGGED_OUT_UNCONFIRMED+    }++    enum PersistenceState {","Hmm, I see. It is because of this: https://github.com/keycloak/keycloak/blob/main/model/build-processor/src/main/java/org/keycloak/models/map/processor/GenerateHotRodEntityImplementationsProcessor.java#L272-L283 Maybe we can move it somewhere else, or just remove it. The build would fail anyway if some field that doesn't exist is used.  ",x
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/11147,848410358,2022-04-12T13:03:06Z,model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java,"@@ -92,18 +95,25 @@ public void updateClient() {             /** This is runtime information and should have never been part of the adapter */             @Override             public Map<String, Integer> getRegisteredNodes() {-                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());+                return Collections.unmodifiableMap(getMapForEntity()","I wanted to make sure that no caller if this interface would use it as a modifiable map and would assume that the results would be stored in the original map.To see this in the tests and to avoid future confusion, I wrapped it as an unmodifiable Map, so that each modification would throw a runtime exception. ",x