user_id,user_login,pull_request_url,comment_id,created_at,path,diff_hunk,content,code_smell
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/17863,835766517,2022-03-26T13:42:22Z,src/mpack/conv.c,"@@ -327,8 +327,6 @@ static mpack_value_t mpack_pack_ieee754(double v, unsigned mantbits,   double mant;    if (v == 0) {-    rv.lo = 0;","> Can't say for certain since the PVS list updates the next day,You can run PVS locally, just like CI does. :)",
32371757,jwhite510,https://api.github.com/repos/neovim/neovim/pulls/14537,835781736,2022-03-26T16:18:11Z,src/nvim/diff.c,"@@ -2644,16 +3421,31 @@ void ex_diffgetput(exarg_T *eap)   dprev = NULL;    for (dp = curtab->tp_first_diff; dp != NULL;) {++    if (dp->is_linematched && !eap->addr_count) {+      // handle the case with overlapping diff blocks+      while (dp->is_linematched && dp->df_next && (dp->df_next->df_lnum[idx_cur] ==+            dp->df_lnum[idx_cur] + dp->df_count[idx_cur]) && dp->df_next->df_lnum[idx_cur] ==+          (eap->line1 + off + 1)) +      {+        dp = dp->df_next;+      }+    }+     if (dp->df_lnum[idx_cur] > eap->line2 + off) {       // past the range that was specified       break;     }     dfree = NULL;+     lnum = dp->df_lnum[idx_to];     count = dp->df_count[idx_to];      if ((dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off)         && (u_save(lnum - 1, lnum + count) != FAIL)) {+      if (dp->is_linematched && !eap->addr_count) {+        breakafteronehunk = 1;+      }",I just removed this. I found that this is actually redundant. The case which this would fix is also fixed by the while loop above the for loop that this is in.https://github.com/neovim/neovim/blob/9c31f950684d21bed3639e9effe967f46678ef9b/src/nvim/diff.c#L3429-L3438,X
32371757,jwhite510,https://api.github.com/repos/neovim/neovim/pulls/14537,835785714,2022-03-26T16:57:07Z,src/nvim/diff.c,"@@ -2212,6 +2975,10 @@ int diffopt_changed(void)       } else {         return FAIL;       }+    } else if ((STRNCMP(p, ""linematch:"", 10) == 0) && ascii_isdigit(p[11])) {","fixed, assuming this is what you meant:https://github.com/neovim/neovim/blob/ea46c57d8e21ec123e2665134592fa8ecd921d66/src/nvim/diff.c#L2982-L2989",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/17871,835866389,2022-03-27T07:45:25Z,src/nvim/shada.c,"@@ -1153,8 +1153,8 @@ static void shada_read(ShaDaReadDef *const sd_reader, const int flags)   }   HistoryMergerState hms[HIST_COUNT];   if (srni_flags & kSDReadHistory) {-    for (uint8_t i = 0; i < HIST_COUNT; i++) {-      hms_init(&hms[i], i, (size_t)p_hi, true, true);+    for (int i = 0; i < HIST_COUNT; i++) {+      hms_init(&hms[i], (uint8_t)i, (size_t)p_hi, true, true);","I think there might be a slightly bigger issue here:`HIST_COUNT` is an enum `HistoryType` which starts at index `-2`, but then we have `hms_init()` which assumes that `const uint8_t history_type````cstatic inline void hms_init(HistoryMergerState *const hms_p, const uint8_t history_type,                            const size_t num_elements, const bool do_merge, const bool reading)```we can't simply swap the argument in this function either because `HistoryMergerState` also uses `uint8_t` for history type.Either way, I think it's better to use the actual type for consistency```suggestion    for (HistoryType i = 0; i < HIST_COUNT; i++) {      hms_init(&hms[i], (uint8_t)i, (size_t)p_hi, true, true);```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/17078,836381912,2022-03-28T12:37:38Z,src/nvim/if_cscope.c,"@@ -32,13 +30,17 @@ #include ""nvim/quickfix.h"" #include ""nvim/strings.h"" #include ""nvim/tag.h""+#include ""nvim/window.h""++#include <sys/stat.h>+#include <sys/types.h> #if defined(UNIX)-# include <sys/wait.h>+#include <sys/wait.h> #endif #include ""nvim/if_cscope_defs.h""  #ifdef INCLUDE_GENERATED_DECLARATIONS-# include ""if_cscope.c.generated.h""+#include ""if_cscope.c.generated.h""","@justinmk, thanks for the heads-up! I've found the setting to tell clang-format to handle thishttps://github.com/neovim/neovim/blob/0cf56905d5328b09e8da2ee19435af563bcdbcb3/.clang-format#L48I've been trying to update the [rules in .clang-format](https://github.com/kylo252/neovim/blob/8b03456290d9d17824a0f45ac83692404d3bfbd6/.clang-format) to help get consistent headers sorting in this PR, according to the pattern used in other places in the code, (uncrustify's rules aren't consistent either sadly)But clang-format is re-using the same indent width, so I still ended up needing to use both tools on different lines... :(",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17905,837309503,2022-03-29T10:20:32Z,runtime/ftplugin/query.lua,"@@ -0,0 +1,5 @@+-- Neovim filetype plugin file+-- Language:	Tree-sitter query (Scheme)+-- Last Change:	2022 Mar 29++vim.bo.commentstring = ""; %s""",Should I just `!runtime ftplugin/lisp.vim`? (And similar for `indent/query.lua`?),
32371757,jwhite510,https://api.github.com/repos/neovim/neovim/pulls/14537,838045240,2022-03-30T01:50:36Z,src/nvim/diff.c,"@@ -358,7 +346,7 @@ static void diff_mark_adjust_tp(tabpage_T *tp, int idx, linenr_T line1, linenr_T     if (last >= line1 - 1) {       // 6. change below line2: only adjust for amount_after; also when       // ""deleted"" became zero when deleted all lines between two diffs.-      if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2) {+      if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2 - dp->is_linematched) {","yes, I'm effectively converting the greater than symbol to a greater than or equal to.This is what keeps the diff hunks intact when they are being adjusted in the middle of a diffput / diffget operation that spans multiple diff blocks. It would consider the diff block to be inside a change instead of below it.So for example you have a diff block on line 3 with a length of 3, and right above this block, 3 new lines get inserted during a 'diffget' operation. that diff block should now be on line 6 with a length of 3, but without that change, it would say the diff block is still on line 3, but now it has a length of 6. That breaks everything and makes the diff  blocks incorrect, so the wrong text would get put / obtained with the diffget / diffput commands. This is what was happening when the diffget / diffput operations were not working initially.",
32371757,jwhite510,https://api.github.com/repos/neovim/neovim/pulls/14537,838045660,2022-03-30T01:51:50Z,src/nvim/diff.c,"@@ -358,7 +346,7 @@ static void diff_mark_adjust_tp(tabpage_T *tp, int idx, linenr_T line1, linenr_T     if (last >= line1 - 1) {       // 6. change below line2: only adjust for amount_after; also when       // ""deleted"" became zero when deleted all lines between two diffs.-      if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2) {+      if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2 - dp->is_linematched) {","and I'm getting the boolean from the diff block because not all diff blocks are linematched. If they are too long, then they would not be linematched, and the diffget / diffput logic doesn't need to change.",
32371757,jwhite510,https://api.github.com/repos/neovim/neovim/pulls/14537,838052545,2022-03-30T02:10:29Z,src/nvim/diff.c,"@@ -2626,6 +2925,18 @@ void ex_diffgetput(exarg_T *eap)   diff_T *dprev = NULL;    for (dp = curtab->tp_first_diff; dp != NULL;) {++    if (dp->is_linematched && !eap->addr_count) {+      // handle the case with overlapping diff blocks","yeah, adjacent would be the better way to refer to it. I'm refering to an overlap as the same as adjacent in this case. But technically it is an overlap if you call the end of the diff **line number + count.**a diff on line 2 of count 2 ends on line (2 + 2 = 4), and if another diff starts on line 4, then they are overlapping. because they are both present on line 4. And that's where all the difficulty has been in getting this to work, handling these cases properly.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17905,840049748,2022-03-31T21:59:32Z,runtime/lua/vim/filetype.lua,"@@ -1424,6 +1424,8 @@ local pattern = {       return ""git""     end   end,+  -- Neovim only+  ["".*/queries/.*%.scm""] = ""query"", -- tree-sitter queries","The question answers itself: in every UI, documentation, and discussion about this filetype, it will always need to be disambiguated. No one knows what ""query"" refers to, it's too generic.What happens when this kind of choice is avoided by the software developer: everyone pays a tiny price forever, because the software developer avoided the choice once. The one-time choice is to think of an unambiguous name such as `tsquery`.> ""Query"" is what upstream calls them, at least.They also reused the `.scm` extension, which suggests they weren't thinking about this as a ""public"" (general audience) filetype. Similarly as above, they avoided a one-time choice which now forces all downstream products to make this decision.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17905,840057583,2022-03-31T22:11:14Z,runtime/lua/vim/filetype.lua,"@@ -1424,6 +1424,8 @@ local pattern = {       return ""git""     end   end,+  -- Neovim only+  ["".*/queries/.*%.scm""] = ""query"", -- tree-sitter queries","We have to make the decision or we're just foisting it on users. It's like if they named the format ""text"".> Is there precedent for that? CMakeLists.txt has a `.txt` extension but we don't named its filetype `text`.This also has a discoverability cost: ""query"" is hard to search for. And if there are other treesitter-related formats we want to add, using a common prefix helps users find all such related syntaxes.This applies to naming in pretty much all contexts across a programming project.If I have to type out this much every time we have a naming question, that doesn't scale. We need to use this judgement in all our naming choices.",X
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/17929,840183852,2022-04-01T02:29:28Z,src/nvim/autocmd.c,"@@ -2350,17 +2350,20 @@ int autocmd_delete_event(int group, event_T event, char_u *pat) /// Deletes an autocmd by ID. /// Only autocmds created via the API have IDs associated with them. There /// is no way to delete a specific autocmd created via :autocmd-void autocmd_delete_id(int64_t id)+bool autocmd_delete_id(int64_t id) {+  assert(id > 0);   FOR_ALL_AUEVENTS(event) {     FOR_ALL_AUPATS_IN_EVENT(event, ap) {       for (AutoCmd *ac = ap->cmds; ac != NULL; ac = ac->next) {         if (ac->id == id) {           aucmd_del(ac);+          return true;","(as in, multiple `ac` can be created by one call to `nvim_create_autocmd`, they just appear to be one autocmd to the user. the data structure is complicated)",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17957,840939961,2022-04-01T21:51:29Z,runtime/lua/vim/telemetry.lua,"@@ -0,0 +1 @@+print(""If you left an angry comment about this then womp womp"")","1. Missing documentation.2. Missing entry in `scripts/gen_vimdoc.py`.3. Missing entry in `runtime/lua/vim/_editor.lua`, as the user will definitely want this message to be printed on startup.4. In future this message may be changed to use single/double quotes, while it is less likely to contain double square brackets, so using long brackets here will make future modifications easier.5. Message is too hard to read. My suggestion to make it easier:```suggestionprint([[iF yOu lEfT An aNgRy cOmMeNt aBoUt tHiS ThEn wOmP WoMp]])```",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/11121,841003092,2022-04-02T03:49:06Z,src/nvim/ui_compositor.c,"@@ -535,6 +544,11 @@ static void ui_comp_raw_line(UI *ui, Integer grid, Integer row,   } else {     compose_debug(row, row+1, startcol, endcol, dbghl_normal, false);     compose_debug(row, row+1, endcol, clearcol, dbghl_clear, true);+#ifndef NDEBUG+    for (int i = 0; i < endcol-startcol; i++) {",@bfredl I wonder if https://github.com/neovim/neovim/issues/14637 is due to `i` possibly being out of bounds in `attrs`. Shouldn't `endcol-startcol` take into account the offset? I see that in https://github.com/neovim/neovim/blob/fce0d54eb2bcfff6903649ab093603dcd8f21f23/src/nvim/ui.c#L450 `attrs` is offset by `off`.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17884,841479083,2022-04-04T08:19:35Z,MAINTAIN.md,"@@ -76,6 +76,15 @@ These ""bundled"" dependencies can be updated by bumping their versions in `third-   - [lua-compat](https://github.com/keplerproject/lua-compat-5.3)   - [tree-sitter](https://github.com/tree-sitter/tree-sitter) +`scripts/bump-dep.sh` is a script that can automate this process for `LuaJIT`, `Luv`, `libuv` & `tree-sitter`. See usage guide:+  - Switch to a branch, with prefix `bump-`+  Use `./scripts/bump-deps.sh --branch foo` to create branch `bump-foo` from `master`","Can this be made automatic (i.e., on `--dep --version`)? It's OK to have an explicit option, but the real benefit is if it happens automatically.(The docs here can focus on the ""minimal"" case of bumping a single dependency without manual commits, so ideally two steps: `--dep --version` from `master`, followed by `--pr`.)",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/17884,841777310,2022-04-04T14:04:40Z,scripts/bump_deps.lua,"@@ -0,0 +1,378 @@+-- Usage:+--    # bump to version+--    nvim -es +""lua require('scripts.bump_deps').version(dependency, version_tag)""+--+--    # bump to commit+--    nvim -es +""lua require('scripts.bump_deps').commit(dependency, commit_hash)""+--+--    # bump to HEAD+--    nvim -es +""lua require('scripts.bump_deps').head(dependency)""+--+--    # submit PR+--    nvim -es +""lua require('scripts.bump_deps').submit_pr()""+--+--    # create branch+--    nvim -es +""lua require('scripts.bump_deps').create_branch()""","Can I suggest running this entire procedure as a github workflow? that way, it's a bit easier to modularize, and re-use prexisting components.1. check out repo https://github.com/neovim/neovim/blob/b08cf73be959397b5715395f1465fb76a76a6a05/.github/workflows/ci.yml#L332. run bump-deps (basically a trimmed down version of the current file)3. build third-partyhttps://github.com/neovim/neovim/blob/b08cf73be959397b5715395f1465fb76a76a6a05/.github/workflows/ci.yml#L79-L804. build and run tests https://github.com/neovim/neovim/blob/b08cf73be959397b5715395f1465fb76a76a6a05/.github/workflows/ci.yml#L82-L835. create a PR if the workflow has survived so farhttps://github.com/marketplace/actions/create-pull-request",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17884,841799118,2022-04-04T14:23:50Z,scripts/bump_deps.lua,"@@ -0,0 +1,378 @@+-- Usage:+--    # bump to version+--    nvim -es +""lua require('scripts.bump_deps').version(dependency, version_tag)""+--+--    # bump to commit+--    nvim -es +""lua require('scripts.bump_deps').commit(dependency, commit_hash)""+--+--    # bump to HEAD+--    nvim -es +""lua require('scripts.bump_deps').head(dependency)""+--+--    # submit PR+--    nvim -es +""lua require('scripts.bump_deps').submit_pr()""+--+--    # create branch+--    nvim -es +""lua require('scripts.bump_deps').create_branch()""","No, I want to be able to do this manually and locally, just like we don't run `./vim-patch.sh` as CI. (Not every dependency update is safe, and some require manual changes to build scripts or tests.)",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/17443,843614596,2022-04-06T08:03:35Z,src/nvim/shada.c,"@@ -3315,16 +3315,16 @@ static ShaDaReadResult msgpack_read_uint64(ShaDaReadDef *const sd_reader, const   RERR ""Error while reading ShaDa file: "" \   entry_name "" entry at position %"" PRIu64 "" "" \   error_desc-#define CHECK_KEY(key, expected) ( \-                                   key.via.str.size == sizeof(expected) - 1 \-                                   && STRNCMP(key.via.str.ptr, expected, sizeof(expected) - 1) == 0)+#define CHECK_KEY(key, expected) \+  ((key).via.str.size == (sizeof(expected) - 1) \+   && STRNCMP((key).via.str.ptr, expected, (sizeof(expected) - 1)) == 0)  // NOLINT","@zeertzjq, what do you think of this? I could never get clint happy, and if I use the complete rule name then the line is longer than 100 characters, and I can't disable a category either :(It's basically https://github.com/neovim/neovim/issues/17763",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/17443,843620331,2022-04-06T08:08:52Z,.clang-format,"@@ -38,3 +38,5 @@ BraceWrapping: PointerAlignment: Right SortIncludes: false Cpp11BracedListStyle: false+AlignConsecutiveMacros: AcrossEmptyLines+PPIndentWidth: 4",I actually had to revert that part again and use this instead https://github.com/kylo252/neovim/blob/d7cbb071218307722f5445374b54f4b47b63a4f1/.clang-format#L42,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17786,845119806,2022-04-07T13:13:33Z,src/nvim/autocmd.c,"@@ -2005,6 +2005,52 @@ void auto_next_pat(AutoPatCmd *apc, int stop_at_last)   } } +static bool call_autocmd_callback(const AutoCmd *ac, const AutoPatCmd *apc)+{+  bool ret = false;+  Callback callback = ac->exec.callable.cb;+  if (callback.type == kCallbackLua) {+    Dictionary data = ARRAY_DICT_INIT;+    PUT(data, ""match"", CSTR_TO_OBJ((char *)autocmd_match));","I think match is a fundamental property of the fired event, and weird to have stuffed away in a nested `""data""` dict",X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18023,845221085,2022-04-07T14:42:45Z,runtime/doc/options.txt,"@@ -1288,7 +1288,17 @@ A jump table for the options with a short description can be found at |Q_op|. 	matter, include the keyword both the uppercase and lowercase: 	""if,If,IF"". -						*'clipboard'* *'cb'*+						*'cinscopedecls'* *'cinsd'*+'cinscopedecls' 'cinsd'	string	(default ""public,protected,private"")+			local to buffer+			{not available when compiled without the |+cindent|+			feature}+	Keywords that are interpreted as a C++ scope declaration by |cino-g|.+	Useful e.g. for working with the Qt framework that defines additional+	scope declarations ""signals"", ""public slots"" and ""private slots"": >+		set cinscopedecls+=signals,public\ slots,private\ slots++<						*'clipboard'* *'cb'* 'clipboard' 'cb'	string	(default """") 			global 	This option is a list of comma separated names.",This was in the patch.```suggestion	This option is a list of comma-separated names.```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17390,846701702,2022-04-10T02:08:09Z,.github/workflows/notes.md,"@@ -6,8 +6,26 @@ ${NVIM_VERSION}  ### Windows -1. Extract **nvim-win64.zip**-2. Run `nvim-qt.exe`+#### Zip++1. Download **nvim-win64.zip**+2. Extract the zip.+3. Run `nvim-qt.exe`++#### MSI++1. Download **nvim-win64.msi**+2. Run the MSI+3. Add the Neovim location to your path.+   - Default location is `C:\Program Files\Neovim`+4. Search and run `nvim-qt.exe` or run `nvim.exe` on your CLI of choice.++#### NSIS",what's the use-case for having both NSIS and MSI? if there is not a strong case we should choose one. Giving users unnecessary choices is bad UI.,
19373652,RenFraser,https://api.github.com/repos/neovim/neovim/pulls/17390,846706381,2022-04-10T03:21:56Z,.github/workflows/notes.md,"@@ -6,8 +6,26 @@ ${NVIM_VERSION}  ### Windows -1. Extract **nvim-win64.zip**-2. Run `nvim-qt.exe`+#### Zip++1. Download **nvim-win64.zip**+2. Extract the zip.+3. Run `nvim-qt.exe`++#### MSI++1. Download **nvim-win64.msi**+2. Run the MSI+3. Add the Neovim location to your path.+   - Default location is `C:\Program Files\Neovim`+4. Search and run `nvim-qt.exe` or run `nvim.exe` on your CLI of choice.++#### NSIS","@justinmk thanks for the review and kind words. This PR's been merged already ����. Being that we haven't seen a release yet since this change and the general consensus is that multiple installations are bad, do you want to make a captain's call or discuss whether we should have only one installer? If we're going to rip one out, I'd rather not have to incur the cost to downstream consumers by making them switch to the other in the 0.8 release. I'm not sure when the freeze is on 0.7. Is there still time? @mjlbach do you have any thoughts on this?",
19373652,RenFraser,https://api.github.com/repos/neovim/neovim/pulls/17390,846709305,2022-04-10T04:07:14Z,.github/workflows/notes.md,"@@ -6,8 +6,26 @@ ${NVIM_VERSION}  ### Windows -1. Extract **nvim-win64.zip**-2. Run `nvim-qt.exe`+#### Zip++1. Download **nvim-win64.zip**+2. Extract the zip.+3. Run `nvim-qt.exe`++#### MSI++1. Download **nvim-win64.msi**+2. Run the MSI+3. Add the Neovim location to your path.+   - Default location is `C:\Program Files\Neovim`+4. Search and run `nvim-qt.exe` or run `nvim.exe` on your CLI of choice.++#### NSIS","Sure thing @mjlbach. @justinmk the NSIS installer is a nice out-of-the-box experience because of the path addition but if you think that the cost of implementing the patch file is worth it over the long term, I can rip the EXE out and leave the MSI. Unfortunately, CPack doesn't have MSIX support yet. I have no experience with MSIX, so can't really comment on it ����.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17390,846801063,2022-04-10T16:07:47Z,.github/workflows/notes.md,"@@ -6,8 +6,26 @@ ${NVIM_VERSION}  ### Windows -1. Extract **nvim-win64.zip**-2. Run `nvim-qt.exe`+#### Zip++1. Download **nvim-win64.zip**+2. Extract the zip.+3. Run `nvim-qt.exe`++#### MSI++1. Download **nvim-win64.msi**+2. Run the MSI+3. Add the Neovim location to your path.+   - Default location is `C:\Program Files\Neovim`+4. Search and run `nvim-qt.exe` or run `nvim.exe` on your CLI of choice.++#### NSIS","> NSIS installer is a nice out-of-the-box experience because of the path addition but if you think that the cost of implementing the patch file is worth it over the long term,I'm imagining the cost of the WIX patch to be 1 file and maybe a couple lines of configuration. If that's accurate then I'd say let's drive towards that. $PATH will have to wait until it bothers someone enough.> Unfortunately, CPack doesn't have MSIX support yetwaiting for cpack is totally reasonable (and preferable to a bunch of scripting)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18071,846885326,2022-04-11T01:21:52Z,runtime/doc/develop.txt,"@@ -242,13 +242,14 @@ If the function acts on an object then {thing} is the name of that object {thing} is usually omitted (but consider ""namespacing"" your global operations with a {thing} that groups functions under a common concept). -Use existing common {action} names if possible:-    add   Append to, or insert into, a collection-    del   Delete a thing (or group of things)-    exec  Execute code-    get   Get a thing (or group of things by query)-    list  Get all things-    set   Set a thing (or group of things)+Use existing common {action} names if possible. For example:","Let's try to keep this list up to date. That removes ambiguity. Thus we don't need ""for example"".```suggestionUse existing common {action} names if possible:```",X
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/17814,847021692,2022-04-11T07:27:56Z,runtime/lua/vim/lsp.lua,"@@ -960,27 +957,48 @@ function lsp.start_client(config)       client.workspace_folders = workspace_folders       -- TODO(mjlbach): Backwards compatibility, to be removed in 0.7       client.workspaceFolders = client.workspace_folders-      client.server_capabilities = assert(result.capabilities, ""initialize result doesn't contain capabilities"")+       -- These are the cleaned up capabilities we use for dynamically deciding       -- when to send certain events to clients.-      client.resolved_capabilities = protocol.resolve_capabilities(client.server_capabilities)+      client.server_capabilities = assert(result.capabilities, ""initialize result doesn't contain capabilities"")+      client.server_capabilities = protocol.resolve_capabilities(client.server_capabilities)++      -- Deprecation wrapper: this will be removed in 0.8+      local mt = {}+      mt.__index = function(table, key)+        if key == 'resolved_capabilities' then+          vim.notify_once(""[LSP] Accessing resolved_capabilities is deprecated, "" ..+          ""update your plugins or configuration to access server_capabilities instead."" ..+          ""The new key/value pairs in server_capabilities directly match those "" ..+          ""defined in the language server protocol"", vim.log.levels_warn)","Although this warning might still be too long, readability-wise. Maybe a link or a `:h client.server_capabilities` is a good replacement for that last part?```suggestion          ""update your plugins or configuration to use client.server_capabilities instead."" ..          ""The new key/value pairs in client.server_capabilities directly match those "" ..          ""defined in the language server protocol"", vim.log.levels.WARN)```",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18081,849172884,2022-04-13T07:37:54Z,src/nvim/normal.c,"@@ -4897,6 +4897,10 @@ static void nv_next(cmdarg_T *cap)     (void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);     cap->count1 -= 1;   }+  // Redraw old and new line to ensure that the highlighting of the current match+  // under the cursor as well as the old match both get properly updated.+  redrawWinline(curwin, old.lnum);+  redrawWinline(curwin, curwin->w_cursor.lnum);","It seems `curwin->w_last_cursorline` only gets updated when `cursorline_standout` is true so it wouldn't be very reliable to redraw that line, so I just removed the redraw for that line. I honestly don't see a case where the old match can change in the middle of using N or n, so I think we'd be fine even without a way to mitigate that. @zeertzjq can you think of a case where that might happen?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18081,849175069,2022-04-13T07:40:28Z,src/nvim/normal.c,"@@ -4897,6 +4897,10 @@ static void nv_next(cmdarg_T *cap)     (void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);     cap->count1 -= 1;   }+  // Redraw old and new line to ensure that the highlighting of the current match+  // under the cursor as well as the old match both get properly updated.+  redrawWinline(curwin, old.lnum);+  redrawWinline(curwin, curwin->w_cursor.lnum);","It can changewhen one pastes lines above cursor, but that not in the middle of using n/N.",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18081,849200218,2022-04-13T08:09:16Z,src/nvim/normal.c,"@@ -4897,6 +4897,10 @@ static void nv_next(cmdarg_T *cap)     (void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);     cap->count1 -= 1;   }+  // Redraw old and new line to ensure that the highlighting of the current match+  // under the cursor as well as the old match both get properly updated.+  redrawWinline(curwin, old.lnum);+  redrawWinline(curwin, curwin->w_cursor.lnum);","> It can change> when one pastes lines above cursor, but that not in the middle of using n/N.That means we don't need to consider that possibility since the value of old line is taken only after using n/N, so old match would have to change while `nv_next` is running, which seems impossible to me",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18110,851369967,2022-04-15T16:42:07Z,src/nvim/menu.c,"@@ -1294,34 +1294,34 @@ static char_u *popup_mode_name(char *name, int idx) ///             allocated. /// /// @return a pointer to allocated memory.-static char_u *menu_text(const char_u *str, int *mnemonic, char_u **actext)+static char *menu_text(const char *str, int *mnemonic, char **actext)   FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT   FUNC_ATTR_NONNULL_ARG(1) {-  char_u *p;-  char_u *text;+  char *p;+  char *text;    // Locate accelerator text, after the first TAB-  p = vim_strchr(str, TAB);+  p = (char *)vim_strchr((char_u *)str, TAB);   if (p != NULL) {     if (actext != NULL) {-      *actext = vim_strsave(p + 1);+      *actext = (char *)vim_strsave((char_u *)p + 1);     }     assert(p >= str);-    text = vim_strnsave(str, (size_t)(p - str));+    text = (char *)vim_strnsave((char_u *)str, (size_t)(p - str));","so they are not the same, as `vim_strnsave` guarantees that `len+1` bytes are allocated even if the valid data is shorter which `xstrndup` doesn't. ideally the latter should work but to be safe rather than sorry we might want a variant that preserves `vim_strnsave` behavior, so we can move forward with the delet char_u project without worry.",
620981,runiq,https://api.github.com/repos/neovim/neovim/pulls/18040,851431945,2022-04-15T18:45:03Z,runtime/lua/vim/lsp/handlers.lua,"@@ -53,7 +53,7 @@ local function progress_handler(_, result, ctx, _)       end     end   else-    table.insert(client.messages, {content = val, show_once = true, shown = 0})+    table.insert(client.messages.messages, {content = val, show_once = true, shown = 0})","So I just looked over the spec again and I'm not sure how a server could ever happen to send non-progress messages (i.e. ones without `kind`). That matches what I've seen with sumneko, rust-analyzer so far���the `messages.messages` table has always been empty.Do you know of any language servers which send non-progress messages via `$/progress`?Edit: Turns out those additional message types are taken directly from lsp-status's [clangd](https://github.com/nvim-lua/lsp-status.nvim/blob/master/lua/lsp-status/extensions/clangd.lua) and [pyls](https://github.com/nvim-lua/lsp-status.nvim/blob/master/lua/lsp-status/extensions/pyls_ms.lua) extensions, which aren't part of the LSP spec. Should I just remove them?",
5160701,seblj,https://api.github.com/repos/neovim/neovim/pulls/18151,851802328,2022-04-17T20:46:57Z,runtime/lua/vim/lsp/buf.lua,"@@ -296,11 +296,23 @@ function M.rename(new_name)       --       -- see https://microsoft.github.io/language-server-protocol/specification#textDocument_prepareRename       opts.default = vfn.expand('<cword>')-      if not new_name then npcall(vim.ui.input, opts, on_confirm) end+      if not new_name then npcall(vim.ui.input, opts, request_rename) end     end-    if new_name then on_confirm(new_name) end+    if new_name then request_rename(new_name) end+  end++  -- Only send prepareRename request if all servers attached to the buffer support it+  local supports_prepare_rename = true+  for _, client in pairs(vim.lsp.buf_get_clients()) do+    supports_prepare_rename = client.supports_method('textDocument/prepareRename')+  end++  if supports_prepare_rename then+    request('textDocument/prepareRename', util.make_position_params(), prepare_rename)+  else+    new_name = new_name or npcall(vfn.input, ""New Name: "", vfn.expand('<cword>'))",Any reason to not use `vim.ui.input`? Since it's used other places for renaming inside `request_rename`,X
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/18151,851810226,2022-04-17T22:19:38Z,runtime/lua/vim/lsp/buf.lua,"@@ -296,11 +296,23 @@ function M.rename(new_name)       --       -- see https://microsoft.github.io/language-server-protocol/specification#textDocument_prepareRename       opts.default = vfn.expand('<cword>')-      if not new_name then npcall(vim.ui.input, opts, on_confirm) end+      if not new_name then npcall(vim.ui.input, opts, request_rename) end     end-    if new_name then on_confirm(new_name) end+    if new_name then request_rename(new_name) end+  end++  -- Only send prepareRename request if all servers attached to the buffer support it+  local supports_prepare_rename = true+  for _, client in pairs(vim.lsp.buf_get_clients()) do+    supports_prepare_rename = client.supports_method('textDocument/prepareRename')+  end","Hmm, I haven't kept up with the recent changes, but wasn't it the opposite originally? We'd send prepareRename if at least one of the servers supported it, and then issue the rename on the callback for the specific client? Otherwise prepareRename will basically never work with multiple servers? (Sample setup: efm for formatting + full-fledged server that supports prepareRename for rename, in that case prepareRename would never get called?).On a side note, the comment doesn't match the code ����  the code will take whatever the last client in the list says (perhaps you're missing an `and` or a conditional `break`?).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18161,852157085,2022-04-18T14:30:37Z,runtime/lua/vim/ui.lua,"@@ -55,6 +55,90 @@ function M.select(items, opts, on_choice)   end end +--- Prompts the user to pick one or multiple items from a collection of entries+---+---@param items table Arbitrary items+---@param opts table Additional options+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Select from list or press return to confirm: `+---     - format_item (function item -> text)+---               Function to format an+---               individual item from `items`. Defaults to `tostring`.+---     - kind (string|nil)+---               Arbitrary hint string indicating the item shape.+---               Plugins reimplementing `vim.ui.select_many` may wish to+---               use this to infer the structure or semantics of+---               `items`, or the context in which select_many() was called.+---@param on_choices function ((chosen_items|nil, indexes|nil) -> ())+---               Called once the user made a choice.+---               `indexes` is a list of 1-based indexes of `chosen_items` within `items`.+---               `nil` if the user aborted the dialog without selecting any items.+---+---+--- Example:+--- <pre>+--- vim.ui.select_many({ 'cheese', 'pepperoni', 'anchovies' }, {+---     prompt = 'Select your toppings:',+---     format_item = function(item)+---         return ""some "" .. item+---     end,+--- }, function(choices)+---     if choices then+---         for _, item in ipairs(choices) do+---             -- add topping to pizza or whatever+---         end+---     end+--- end)+--- </pre>+function M.select_many(items, opts, on_choices)+  vim.validate {+    items = { items, 'table', false },+    on_choices = { on_choices, 'function', false },+  }+  opts = opts or {}+  local selected = {}+  local selected_indexes = {}+  local choices = {opts.prompt or 'Select from list or press return to confirm: '}",The `inputlist` output uses `<Enter>` so use that here too for consistency:```suggestion  local choices = {opts.prompt or 'Select from list or <Enter> to confirm: '}```,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18040,852206894,2022-04-18T15:40:41Z,runtime/lua/vim/lsp/handlers.lua,"@@ -53,7 +53,7 @@ local function progress_handler(_, result, ctx, _)       end     end   else-    table.insert(client.messages, {content = val, show_once = true, shown = 0})+    table.insert(client.messages.messages, {content = val, show_once = true, shown = 0})","The spec doesn't list any kind of payload structure at all, so whether they contain `kind` or not is undefined. But they should always contain a `token`:```type ProgressToken = integer | string;interface ProgressParams<T> {	/**	 * The progress token provided by the client or server.	 */	token: ProgressToken;	/**	 * The progress data.	 */	value: T;}```This is why I would add messages without kind to progress under the token with `done = true`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18177,853424468,2022-04-19T19:40:57Z,src/nvim/api/vim.c,"@@ -1597,7 +1597,7 @@ ArrayOf(Dictionary) nvim_get_keymap(uint64_t channel_id, String mode) ///               ""desc"" can be used to give a description to keymap. ///               When called from Lua, also accepts a ""callback"" key that takes ///               a Lua function to call when the mapping is executed.-///               Values are Booleans. Unknown key is an error.+///               Values are Booleans (default false). Unknown key is an error.","e.g. :      /// @param  opts  Optional parameters map. Keys are |:map-arguments|, values are booleans (default false). Accepts all |:map-arguments|",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18040,853438329,2022-04-19T19:58:27Z,runtime/lua/vim/lsp/handlers.lua,"@@ -33,7 +33,7 @@ local function progress_handler(_, result, ctx, _)   local val = result.value    -- unspecified yet   local token = result.token  -- string or number -+  if type(val) ~= 'table' then val = {val} end",```suggestion  if type(val) ~= 'table' then val = {content = val} end```Otherwise it is a list(?),
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18179,853470516,2022-04-19T20:43:16Z,src/nvim/api/autocmd.c,"@@ -346,6 +346,22 @@ Array nvim_get_autocmds(Dict(get_autocmds) *opts, Error *err) ///     }) /// </pre> ///+/// Lua functions receive a table with information about the autocmd event as argument, if you're+/// using a function which already takes another optional parameter, you have to wrap the function+/// in a lambda:","```suggestion/// Lua functions receive a table with information about the autocmd event as an argument. To use/// a function which itself accepts another (optional) parameter, wrap the function/// in a lambda:```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18194,854450691,2022-04-20T18:46:47Z,src/nvim/api/vim.c,"@@ -1542,9 +1542,11 @@ Object nvim_load_context(Dictionary dict) }  /// Gets the current mode. |mode()|-/// ""blocking"" is true if Nvim is waiting for input. ///-/// @returns Dictionary { ""mode"": String, ""blocking"": Boolean }+/// @return Dictionary with the following keys:+///       - mode: (string) Current mode+///       - blocking: (boolean) true if Neovim is waiting for input+///       - cmdpreview: (boolean) true if Neovim is previewing a command","A bit pedantic, but in the docs when referring to the program we usually call it `Nvim` rather than `Neovim`.```suggestion///       - blocking: (boolean) true if Nvim is waiting for input///       - cmdpreview: (boolean) true if Nvim is previewing a command```",
6705160,williamboman,https://api.github.com/repos/neovim/neovim/pulls/18193,854467991,2022-04-20T19:05:46Z,runtime/lua/vim/lsp/buf.lua,"@@ -143,6 +143,48 @@ local function select_client(method, on_choice)   end end +--- Formats the current buffer.+---@param opts table+---     formatting_options: table: Can be used to specify FormattingOptions.+---                                Some unspecified options will be automatically derived from the current+---                                Neovim options.+---                                @see https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting+---     timeout_ms: string+---     filter: function+---     ids: table+---     names: table+---     id: string+---     name: string++function M.format(opts)+  local bufnr = vim.api.nvim_get_current_buf()","Yeah it does feel a bit ""forced"". Reason I suggested it is that I've personally ran into multiple cases (with certain plugins) where it would've been nice to be able to provide a bufnr other than the current one. I could picture some use cases for programmatically formatting multiple buffers at once, based on some condition/trigger, like:```luafor _, bufnr in ipairs(vim.api.nvim_list_bufs()) do    local filetype = vim.api.nvim_buf_get_option(bufnr, ""filetype"")    if filetype == ""typescript"" then        vim.lsp.buf_format(bufnr, { name = ""eslint"" })    endend```I also just realized this method is under the `vim.lsp.buf.` table, for which it'd make sense not to accept a bufnr. If it were to remain a parameter, maybe it'd make sense to move the function to `vim.lsp.buf_format` with a slightly changed signature (e.g. `vim.lsp.buf_format(bufnr, { name = ""eslint"" })`).",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/18196,854640728,2022-04-20T23:17:27Z,src/nvim/normal.c,"@@ -1762,28 +1726,21 @@ bool do_mouse(oparg_T *oap, int c, int dir, long count, bool fixindent)             .v_lock = VAR_FIXED,             .v_type = VAR_NUMBER,             .vval = {-              .v_number = (((mod_mask & MOD_MASK_MULTI_CLICK)-                            == MOD_MASK_4CLICK)-                             ? 4-                             : ((mod_mask & MOD_MASK_MULTI_CLICK)-                                == MOD_MASK_3CLICK)-                             ? 3-                             : ((mod_mask & MOD_MASK_MULTI_CLICK)-                                == MOD_MASK_2CLICK)-                             ? 2-                             : 1)+              .v_number =+                (((mod_mask & MOD_MASK_MULTI_CLICK) ==+                  MOD_MASK_4CLICK) ? 4 : ((mod_mask & MOD_MASK_MULTI_CLICK) ==+                                          MOD_MASK_3CLICK) ? 3 : ((mod_mask &+                                                                   MOD_MASK_MULTI_CLICK) ==+                                                                  MOD_MASK_2CLICK) ? 2 : 1)","these nested ternaries are gnarly.not really too sure how best to deal with these, something like:```suggestion              .v_number = ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK                           ? 4                           : ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK                              ? 3                              : ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK                                 ? 2                                 : 1)))```seems to make clint happy, but it did require rearranging the brackets.or, if we don't care about aligning `?` with the conditions on the previous lines, clint will accept this with the old bracket placements:```c              .v_number = (((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)                           ? 4                           : ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)                           ? 3                           : ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)                           ? 2                           : 1)```could also consider collapsing some of these lines if it's preferred to save space :shrug:",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18194,854757260,2022-04-21T04:07:31Z,runtime/doc/map.txt,"@@ -1431,6 +1431,41 @@ Possible values are (second column is the short name used in listing):     -addr=other		  ?	other kind of range  +Incremental preview ~+                                                  *:command-preview*+It's possible to allow commands to be incrementally previewed when+'inccommand' is enabled by using the -preview command attribute. Possible use+cases are:+	-preview		Always preview+	-preview={func}		Preview only if {func} returns |TRUE|++The {func} part must be a function with the following signature: >++	:function {func}(CmdLine)++The function is only given one argument, which is the entire command line. The+function must return a boolean value which determines whether the command+preview should be triggered or not. If -preview is used by itself without any+arguments, the command is always previewed whenever the command line is+modified.++Note that every time a command needs to be previewed, Nvim executes the+command. It's possible to check if a command is being executed for+previewing by using the ""cmdpreview"" key of |nvim_get_mode()|.++Here is an example that uses the -preview attribute to preview a command that+trims leading whitespaces from lines: >++	function! PreviewFunc(cmd)+	    "" Preview when first argument equals 'enable' (case-insensitive)+	    let args = split(a:cmd, ' ')+	    return len(args) > 1 && args[1] ==? 'enable'+	endfunction++	command! -nargs=1 -preview=PreviewFunc -range=% -addr=lines","You mean the -preview attribute? I think we should make an exception in this case personally since it only has any effect when `inccommand`, a Neovim-specific feature is enabled, so it shouldn't conflict with Vim. But I'm free to make changes if required",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18194,854760324,2022-04-21T04:17:20Z,runtime/doc/api.txt,"@@ -733,8 +733,9 @@ nvim_create_user_command({name}, {command}, {*opts})                                |:command-complete|, the ""complete"" key also                                accepts a Lua function which works like the                                ""customlist"" completion mode-                               |:command-completion-customlist|. Additional-                               parameters:+                               |:command-completion-customlist|. The ""preview""+                               key may also take a Lua function instead of a+                               VimScript function name. Additional parameters:",```suggestion                               Vim script function name. Additional parameters:```,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18193,855380809,2022-04-21T16:34:21Z,runtime/lua/vim/lsp/buf.lua,"@@ -143,6 +143,79 @@ local function select_client(method, on_choice)   end end +--- Utility function to request formatting from attached language servers. Defaults to+--- requesting formatting from all servers attached to the current buffer.+---+--- @param opts table Optional table which holds the following optional fields:+---     - formatting_options (table):+---         Can be used to specify FormattingOptions. Some unspecified options will be+---         automatically derived from the current Neovim options.+---         @see https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting+---     - timeout_ms (integer, default 1000):+---         Time in milliseconds to block for formatting requests. Formatting requests are current+---         synchronous to prevent editing of the buffer.+---     - bufnr (number):+---         Restrict formatting to the clients attached to the given buffer, defaults to the current+---         buffer (0).+---     - filter (function):+---         Restrict formatting to client ids returned by this function. Takes as argument the+---         clients attached to the buffer (default to the current buffer) and returns a list+---         of client objects from which to request formatting.+---+---         Example:+---         <pre>+---         -- Never request typescript-language-server for formatting+---         vim.lsp.buf.format {+---           filter = function(clients)+---             return vim.tbl_filter(+---               function(client) return client.name ~= ""tsserver"" end,+---               clients+---             )+---           end",Or do you see a special use-case where receiving the full list and returning the list of clients would have an advantage?,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/18193,855395307,2022-04-21T16:51:48Z,runtime/lua/vim/lsp/buf.lua,"@@ -143,6 +143,79 @@ local function select_client(method, on_choice)   end end +--- Utility function to request formatting from attached language servers. Defaults to+--- requesting formatting from all servers attached to the current buffer.+---+--- @param opts table Optional table which holds the following optional fields:+---     - formatting_options (table):+---         Can be used to specify FormattingOptions. Some unspecified options will be+---         automatically derived from the current Neovim options.+---         @see https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting+---     - timeout_ms (integer, default 1000):+---         Time in milliseconds to block for formatting requests. Formatting requests are current+---         synchronous to prevent editing of the buffer.+---     - bufnr (number):+---         Restrict formatting to the clients attached to the given buffer, defaults to the current+---         buffer (0).+---     - filter (function):+---         Restrict formatting to client ids returned by this function. Takes as argument the+---         clients attached to the buffer (default to the current buffer) and returns a list+---         of client objects from which to request formatting.+---+---         Example:+---         <pre>+---         -- Never request typescript-language-server for formatting+---         vim.lsp.buf.format {+---           filter = function(clients)+---             return vim.tbl_filter(+---               function(client) return client.name ~= ""tsserver"" end,+---               clients+---             )+---           end","The only thing I was thinking of is if someone wants to have some weird conditional fallback logic internal to the filter, like if null-ls use x if not null-ls use y, I guess that could technically still be expressed",
54108223,jose-elias-alvarez,https://api.github.com/repos/neovim/neovim/pulls/18193,855693986,2022-04-22T01:07:13Z,runtime/lua/vim/lsp/buf.lua,"@@ -143,6 +143,79 @@ local function select_client(method, on_choice)   end end +--- Utility function to request formatting from attached language servers. Defaults to+--- requesting formatting from all servers attached to the current buffer.+---+--- @param opts table Optional table which holds the following optional fields:+---     - formatting_options (table):+---         Can be used to specify FormattingOptions. Some unspecified options will be+---         automatically derived from the current Neovim options.+---         @see https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting+---     - timeout_ms (integer, default 1000):+---         Time in milliseconds to block for formatting requests. Formatting requests are current+---         synchronous to prevent editing of the buffer.+---     - bufnr (number):+---         Restrict formatting to the clients attached to the given buffer, defaults to the current+---         buffer (0).+---     - filter (function):+---         Restrict formatting to client ids returned by this function. Takes as argument the+---         clients attached to the buffer (default to the current buffer) and returns a list+---         of client objects from which to request formatting.+---+---         Example:+---         <pre>+---         -- Never request typescript-language-server for formatting+---         vim.lsp.buf.format {+---           filter = function(clients)+---             return vim.tbl_filter(+---               function(client) return client.name ~= ""tsserver"" end,+---               clients+---             )+---           end","Having access to the full list of clients could be useful in cases where a user wants to choose a server based on whether another server is attached (for example, I might want to use `eslint` in projects that have it configured but fall back to `tsserver` otherwise). I don't mind this either way but wanted to mention a potential use case there. ",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/18193,855715692,2022-04-22T02:15:31Z,runtime/lua/vim/lsp/buf.lua,"@@ -143,6 +143,82 @@ local function select_client(method, on_choice)   end end +--- Formats a buffer using the attached (and optionally filtered) language+--- server clients.+---+--- @param opts table|nil Optional table which holds the following optional fields:+---     - formatting_options (table|nil):+---         Can be used to specify FormattingOptions. Some unspecified options will be+---         automatically derived from the current Neovim options.+---         @see https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting+---     - timeout_ms (integer|nil, default 1000):+---         Time in milliseconds to block for formatting requests. Formatting requests are current+---         synchronous to prevent editing of the buffer.+---     - bufnr (number|nil):+---         Restrict formatting to the clients attached to the given buffer, defaults to the current+---         buffer (0).+---     - filter (function|nil):+---         Predicate to filter clients used for formatting. Received a client+---         as argument and must return a boolean.+---+---         Example:+---         <pre>+---         -- Never request typescript-language-server for formatting+---         vim.lsp.buf.format {+---           filter = function(clients)+---             return vim.tbl_filter(+---               function(client) return client.name ~= ""tsserver"" end,+---               clients+---             )+---           end+---         }+---         </pre>+---+---     - id (number|nil):+---         Restrict formatting to the client with ID (client.id) matching this field.+---     - name (string|nil):+---         Restrict formatting to the client with name (client.name) matching this field.++function M.format(opts)+  opts = opts or {}+  local bufnr = opts.bufnr or vim.api.nvim_get_current_buf()+  local clients = vim.lsp.buf_get_clients(bufnr)++  if opts.filter then+    clients = opts.filter(clients)+  elseif opts.id then+    clients = vim.tbl_filter(+      function(client) return client.id == opts.id end,+      clients+    )+  elseif opts.name then+    clients = vim.tbl_filter(+      function(client) return client.name == opts.name end,+      clients+    )+  end++  clients = vim.tbl_filter(+    function(client) return client.supports_method(""textDocument/formatting"") end,+    clients+  )++  if #clients == 0 then+    vim.notify(""[LSP] Format request failed, no matching language servers."")+  end++  local timeout_ms =  opts.timeout_ms or 1000+  for _, client in pairs(clients) do+      local params = util.make_formatting_params(opts.formatting_options)+      local result, err = client.request_sync(""textDocument/formatting"", params, timeout_ms, bufnr)","This was a less dramatic attempt at https://github.com/neovim/neovim/pull/16206, I don't want to have a sync vs. async distinction. I would like to have chained async that blocks the neovim shutdown process so we can always use async, but lock the buffer while pending requests are out to prevent clobbering the buffer with wrong text edits (same issue currently with trying to request multiple servers asynvc",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18219,856244732,2022-04-22T13:45:22Z,runtime/lua/vim/filetype.lua,"@@ -49,8 +50,25 @@ local extension = {   art = ""art"",   asciidoc = ""asciidoc"",   adoc = ""asciidoc"",+  asa = function(path, bufnr)+    if vim.g.filetype_asa then+      return vim.g.filetype_asa+    else+      return ""aspvbs""+    end+  end,   [""asn1""] = ""asn"",   asn = ""asn"",+  asp = function(path, bufnr)+    if vim.g.filetype_asp then+      return vim.g.filetype_asp+    elseif getline(bufnr, 1):find(""perlscript"")+      or getline(bufnr, 2):find(""perlscript"")+      or getline(bufnr, 3):find(""perlscript"") then","That's indeed much nicer, especially for monstrosities like https://github.com/neovim/neovim/blob/f4f593b3331a29590355322884d5b89e8660e5e8/runtime/filetype.vim#L522",X
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/18219,856245021,2022-04-22T13:45:42Z,runtime/lua/vim/filetype.lua,"@@ -897,6 +897,12 @@ local extension = {       return ""text""     end   end,+  cmd = function (path, bufnr)+    if getline(bufnr, 1):match(""^/\\*"") then","Just lurking, but this is a valid pattern and matches the same text that that regex would match (a line starting  with `/` followed by zero or more `\`).The original regex is `^/\*` though, which should be translated to `^/%*` (a line starting with ""/*""). ",
12678167,kessejones,https://api.github.com/repos/neovim/neovim/pulls/18219,856753968,2022-04-23T01:42:34Z,runtime/lua/vim/filetype.lua,"@@ -49,8 +52,23 @@ local extension = {   art = ""art"",   asciidoc = ""asciidoc"",   adoc = ""asciidoc"",+  asa = function(path, bufnr)+    if vim.g.filetype_asa then+      return vim.g.filetype_asa+    else+      return ""aspvbs""+    end+  end,   [""asn1""] = ""asn"",   asn = ""asn"",+  asp = function(path, bufnr)+    if vim.g.filetype_asp then+      return vim.g.filetype_asp+    elseif getline(bufnr, 1, 3):find(""perlscript"") then",I think I accidentally removed it. I will fix it,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18219,856871505,2022-04-23T09:18:50Z,runtime/lua/vim/filetype.lua,"@@ -679,6 +697,16 @@ local extension = {   bbl = ""tex"",   latex = ""tex"",   sty = ""tex"",+  cls = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line[1] == ""%"" then","That was my bad! I was in a bit of a hurry with the ""seed PR""...(and same below)",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/18181,856873474,2022-04-23T09:42:48Z,src/nvim/tui/tui.c,"@@ -2078,10 +2117,7 @@ static void augment_terminfo(TUIData *data, const char *term, long vte_version,   data->unibi_ext.disable_extended_keys = unibi_find_ext_str(ut, ""Dseks"");   if (data->unibi_ext.enable_extended_keys == -1) {     if (!kitty && (vte_version == 0 || vte_version >= 5400)) {-      data->unibi_ext.enable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.enable_extended_keys"",-                                                                    ""\x1b[>4;2m"");-      data->unibi_ext.disable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.disable_extended_keys"",-                                                                     ""\x1b[>4m"");+      data->input.supports_modify_other_keys = true;     }   }","Shouldn't it be as follows?```C  if (!kitty && (vte_version == 0 || vte_version >= 5400)) {  if (data->unibi_ext.enable_extended_keys == -1) {    data->unibi_ext.enable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.enable_extended_keys"",                                                                  ""\x1b[>4;2m"");  }  if (data->unibi_ext.disable_extended_keys == -1) {    data->unibi_ext.disable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.disable_extended_keys"",                                                                   ""\x1b[>4m"");  }}```",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/18181,856874727,2022-04-23T09:57:12Z,src/nvim/tui/input.c,"@@ -344,6 +345,31 @@ static void tk_getkeys(TermInput *input, bool force)       forward_modified_utf8(input, &key);     } else if (key.type == TERMKEY_TYPE_MOUSE) {       forward_mouse_event(input, &key);+    } else if (key.type == TERMKEY_TYPE_UNKNOWN_CSI) {+      // There is no specified limit on the number of parameters a CSI sequence can contain, so just+      // allocate enough space for a large upper bound+      long args[16];+      size_t nargs = 16;+      unsigned long cmd;+      if (termkey_interpret_csi(input->tk, &key, args, &nargs, &cmd) == TERMKEY_RES_KEY) {+        uint8_t intermediate = (cmd >> 16) & 0xFF;+        uint8_t initial = (cmd >> 8) & 0xFF;+        uint8_t command = cmd & 0xFF;++        // Currently unused+        (void)intermediate;++        if (input->waiting_for_extkeys_response > 0) {+          if (initial == '?' && command == 'u') {+            input->supports_kitty_protocol = true;","If the following changes are made in conjunction with the changes to [r856873474](https://github.com/neovim/neovim/pull/18181/files#r856873474), the two variables `supports_kitty_protocol` and `supports_modify_other_keys` should not be needed.```Cdata->unibi_ext.enable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.enable_extended_keys"",                                                              ""\x1b[>1u"");data->unibi_ext.disable_extended_keys = (int)unibi_add_ext_str(ut,                                                               ""ext.disable_extended_keys"",                                                               ""\x1b[<1u"");```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18181,856892362,2022-04-23T13:24:09Z,src/nvim/tui/tui.c,"@@ -2078,10 +2117,7 @@ static void augment_terminfo(TUIData *data, const char *term, long vte_version,   data->unibi_ext.disable_extended_keys = unibi_find_ext_str(ut, ""Dseks"");   if (data->unibi_ext.enable_extended_keys == -1) {     if (!kitty && (vte_version == 0 || vte_version >= 5400)) {-      data->unibi_ext.enable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.enable_extended_keys"",-                                                                    ""\x1b[>4;2m"");-      data->unibi_ext.disable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.disable_extended_keys"",-                                                                     ""\x1b[>4m"");+      data->input.supports_modify_other_keys = true;     }   }","A terminal could still support the kitty keyboard protocol even if this `if` condition is true. For example foot and iTerm2 both support it, so we need to query regardless and we use the `modifyOtherKeys` sequence as a fallback.I guess we could set the `enable_extended_keys` sequences here as you suggest along with `waiting_for_extkeys_response`, and only emit the sequence in `terminfo_start` if `waiting_for_extkeys_response` is 0.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18234,856936818,2022-04-23T16:13:36Z,src/nvim/search.c,"@@ -6017,3 +6017,9 @@ bool search_was_last_used(void) {   return last_idx == 0; }++/// @return  true if 'hlsearch' highlight is currently in use.+bool hlsearch_used(void)","- if this is about current state, ""using"" is more intuitive.- An existing precedent is `using_script`, I guess it's worth being consistent there- search.c doesn't have  common prefix for function names, otherwise the name would be something like `search_using_hlsearch()`.- are there places where this can be used? I found e.g. https://github.com/justinmk/neovim/blob/356cff78ece597059133e33eceb955f72286a319/src/nvim/screen.c#L5986```suggestionbool using_hlsearch(void)```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18231,856942528,2022-04-23T17:22:11Z,runtime/doc/api.txt,"@@ -1350,6 +1350,27 @@ nvim_out_write({str})                                       *nvim_out_write()*                 Parameters: ~                     {str}  Message +nvim_parse_cmdline({str}, {opts})                       *nvim_parse_cmdline()*+                Parse command line.++                Doesn't check the validity of command arguments.++                Attributes: ~+                    {fast}++                Parameters: ~+                    {str}   Command line string to parse. Cannot contain ""\n"".+                    {opts}  Optional parameters. Reserved for future use.++                Return: ~+                    Dictionary containing command information, with these+                    keys:+                    ��� cmd: (string) command name.+                    ��� line1: (number) starting line of command range.+                    ��� line2: (number) final line of command range.+                    ��� force: (boolean) whether command contains a bang.+                    ��� args: (array) command arguments.","Even if we don't have full capability yet, we should also include fields such as:1. whether `%` is treated literally or expanded. The field could be called `magic` but probably it needs to be a list (not binary) because of the nonsensical variations possible with Vim commands. So `magic=[]` means ""literal"", `magic=['%']` means ""%"" is interpreted in the magic way, `magic=['%', '|']` means that `|` is non-literal, `magic=['%', '|', '""']` means that `""` is a comment2. `mods` , see `:help <mods>`3. `nargs`, see `:help :command-nargs`    - the explicitness is useful as command ""metadata"" even though the `args` list implies itThis knowledge might need to be maintained as a hacky list for now, but ultimately should be built into `src/nvim/ex_cmds.lua`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18231,856942791,2022-04-23T17:25:12Z,src/nvim/api/vim.c,"@@ -2451,3 +2451,71 @@ void nvim_del_user_command(String name, Error *err) {   nvim_buf_del_user_command(-1, name, err); }++/// Parse command line.+///+/// Doesn't check the validity of command arguments.+///+/// @param str       Command line string to parse. Cannot contain ""\n"".+/// @param opts      Optional parameters. Reserved for future use.+/// @param[out] err  Error details, if any.+/// @return Dictionary containing command information, with these keys:+///         - cmd: (string) command name.+///         - line1: (number) starting line of command range.+///         - line2: (number) final line of command range.+///         - force: (boolean) whether command contains a bang.+///         - args: (array) command arguments.+Dictionary nvim_parse_cmdline(String str, Dictionary opts, Error *err)","* Let's introduce ""cmd"" as an API noun and stick with it. This opens the door for `nvim_exec_cmd({list})`, then we can deprecate `nvim_command({string})` and maybe even `nvim_exec()`.* ""cmdline"" implies the UI for entering cmds, which isn't really the case here.```suggestionDictionary nvim_parse_cmd(String str, Dictionary opts, Error *err)```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18211,856947161,2022-04-23T17:56:04Z,runtime/lua/vim/inspect.lua,"@@ -1,7 +1,7 @@-local inspect ={-  _VERSION = 'inspect.lua 3.1.0',-  _URL     = 'http://github.com/kikito/inspect.lua',-  _DESCRIPTION = 'human-readable representations of tables',+local inspect = {+  _VERSION = ""inspect.lua 3.1.0"",","By upstream, yes. (https://github.com/kikito/inspect.lua/blob/9c8a68da3033f1393b84b498313572654af82b8f/inspect.lua#L20)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18181,856952625,2022-04-23T17:59:53Z,src/nvim/tui/input.h,"@@ -14,6 +15,8 @@ typedef struct term_input {   bool waiting;   bool ttimeout;   int8_t waiting_for_bg_response;+  int8_t waiting_for_extkeys_response;+  bool supports_kitty_protocol;","This might be more information than you bargained for, but:`modifyOtherKeys` is the name of the Xterm extension to disambiguate control sequence modifiers. This mode can be programmatically enabled via the XTMODKEYS sequence `\x1b[>4;2m`.""CSI u"" is the colloquial name given to [Leonerd's encoding scheme](http://www.leonerd.org.uk/hacks/fixterms/), which is distinct from Xterm's `modifyOtherKeys`. `libtermkey` (which Neovim uses) supports both.Kitty's keyboard protocol is yet another encoding scheme which is based off of Leonerd's CSI u. Kitty's protocol supports progressive enhancement so you can use different ""levels"" of the protocol; the base level (level 1, which this PR enables) is identical to CSI u.However, Leonerd's CSI u proposal does not provide any way of querying the terminal for support nor programmatically enabling or disabling that mode. Both of these are supported by kitty's keyboard protocol.Finally, tmux uses the term ""extended keys"" to refer to any encoding scheme that disambiguates control sequences (either `modifyOtherKeys` or CSI u). I've adopted that terminology to refer to the same thing.So here ""extended keys"" (extkeys) means *any* encoding scheme that enables us to distinguish between e.g. `<Tab>` and `<C-I>`. `modifyOtherKeys` is the Xterm scheme and kitty/CSI u is the one proposed by Leonerd.The terminology is kind of confusing and there isn't a super well established standard. As I said I'm open to suggestions on wording, but for now I will use the terms as outlined above.I'll also add a section to the docs outlining all of this.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18181,857027091,2022-04-23T19:19:39Z,src/nvim/tui/input.h,"@@ -14,6 +15,8 @@ typedef struct term_input {   bool waiting;   bool ttimeout;   int8_t waiting_for_bg_response;+  int8_t waiting_for_extkeys_response;+  bool supports_kitty_protocol;","> However, Leonerd's CSI u proposal does not provide any way of querying the terminal for support nor programmatically enabling or disabling that mode. Both of these are supported by kitty's keyboard protocol.Do we actually need that? Why not always try to enable it? > Finally, tmux uses the term ""extended keys"" to refer to any encoding scheme that disambiguates control sequences (either `modifyOtherKeys` or CSI u). I've adopted that terminology to refer to the same thing.����  good choice",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18181,857030847,2022-04-23T20:06:13Z,runtime/doc/map.txt,"@@ -889,6 +889,46 @@ or `unnamedplus`. The `mode()` function will return the state as it will be after applying the operator. +						*modifyOtherKeys* *csi-u*",- this probably belongs in term.txt.- Using the `tui-` prefix also helps user discovery.```suggestion						*tui-modifyOtherKeys* *tui-csiu*```,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18181,857031097,2022-04-23T20:09:38Z,src/nvim/tui/input.h,"@@ -15,8 +15,8 @@ typedef struct term_input {   bool waiting;   bool ttimeout;   int8_t waiting_for_bg_response;-  int8_t waiting_for_extkeys_response;-  bool supports_kitty_protocol;+  int8_t waiting_for_csi_u_response;+  bool supports_csi_u;","the space before the ""u"" seems kinda distracting. we just need a recognizable unambiguous nonce.```suggestion  bool supports_csiu;```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,857038968,2022-04-23T21:56:16Z,runtime/doc/map.txt,"@@ -1431,6 +1431,128 @@ Possible values are (second column is the short name used in listing):     -addr=other		  ?	other kind of range  +Incremental preview ~+                                                  *:command-preview* {nvim-api}+It's possible to allow commands to be incrementally previewed when+'inccommand' is enabled by using the preview command attribute. The preview+attribute may only be used through the API. (see |nvim_create_user_command()|)++The value of the preview attribute must be either a boolean value, the name of+a Vim script function or a Lua function callback. Here are some examples: >++	-- setting preview to a boolean value+	call nvim_create_user_command('foo', 'call Foo()',+		\ { 'preview': v:true })++	-- setting preview to a VimScript function+	function! PreviewFunc()+	    return v:true+	endfunction++	call nvim_create_user_command('bar', 'call Bar()',+		\ { 'preview': 'PreviewFunc' })++	-- setting preview to a Lua function callback+	lua << EOF+	local function PreviewFunc()+	    return true+	end++	vim.api.nvim_create_user_command('baz', 'call Baz()',+	                                 { preview = PreviewFunc })+	EOF+<++If preview is a boolean value and its value is |TRUE|, preview is always","There's more examples but I'll just mention this one and hope that the pattern is applied generally: don't use lots of words to say something that can be said clearly with fewer words. Let the reader save energy.""is a boolean and is TRUE"" is totally redundant. Just say ""is TRUE"".```suggestionIf preview is |TRUE|, preview is always```",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/18181,857074688,2022-04-24T06:35:52Z,src/nvim/tui/tui.c,"@@ -2078,10 +2117,7 @@ static void augment_terminfo(TUIData *data, const char *term, long vte_version,   data->unibi_ext.disable_extended_keys = unibi_find_ext_str(ut, ""Dseks"");   if (data->unibi_ext.enable_extended_keys == -1) {     if (!kitty && (vte_version == 0 || vte_version >= 5400)) {-      data->unibi_ext.enable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.enable_extended_keys"",-                                                                    ""\x1b[>4;2m"");-      data->unibi_ext.disable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.disable_extended_keys"",-                                                                     ""\x1b[>4m"");+      data->input.supports_modify_other_keys = true;     }   }","Sorry to keep changing my opinion, but how about using `enum` in the current implementation as follows?```diffcommit 81c10f57f970d6d76c998796a3e2911e04a1cb58Author: erw7 <erw7.github@gmail.com>Date:   Sun Apr 24 15:25:48 2022 +0900    refactor(tui): change to switch sequence by CSIuTypediff --git a/src/nvim/tui/input.c b/src/nvim/tui/input.cindex 696da7835..642214d67 100644--- a/src/nvim/tui/input.c+++ b/src/nvim/tui/input.c@@ -42,6 +42,7 @@ void tinput_init(TermInput *input, Loop *loop)   input->paste = 0;   input->in_fd = STDIN_FILENO;   input->waiting_for_bg_response = 0;+  input->csiu_type = kCSIuNone;   // The main thread is waiting for the UI thread to call CONTINUE, so it can   // safely access global variables.   input->ttimeout = (bool)p_ttimeout;@@ -361,7 +362,7 @@ static void tk_getkeys(TermInput *input, bool force)          if (input->waiting_for_csiu_response > 0) {           if (initial == '?' && command == 'u') {-            input->supports_csiu = true;+            input->csiu_type = kCSIuKitty;           } else if (initial == '?' && command == 'c') {             input->waiting_for_csiu_response = 0;             tui_enable_extkeys(input->tui_data);diff --git a/src/nvim/tui/input.h b/src/nvim/tui/input.hindex 7ddca0d0c..696344815 100644--- a/src/nvim/tui/input.h+++ b/src/nvim/tui/input.h@@ -8,6 +8,13 @@ #include ""nvim/event/time.h"" #include ""nvim/tui/tui.h"" +typedef enum {+  kCSIuNone,+  kCSIuKitty,+  kCSIuXterm,+} CSIuType;++ typedef struct term_input {   int in_fd;   // Phases: -1=all 0=disabled 1=first-chunk 2=continue 3=last-chunk@@ -16,7 +23,7 @@ typedef struct term_input {   bool ttimeout;   int8_t waiting_for_bg_response;   int8_t waiting_for_csiu_response;-  bool supports_csiu;+  CSIuType csiu_type;   long ttimeoutlen;   TermKey *tk; #if TERMKEY_VERSION_MAJOR > 0 || TERMKEY_VERSION_MINOR > 18diff --git a/src/nvim/tui/tui.c b/src/nvim/tui/tui.cindex e6fadd1dc..b404be22f 100644--- a/src/nvim/tui/tui.c+++ b/src/nvim/tui/tui.c@@ -186,11 +186,18 @@ void tui_enable_extkeys(TUIData *data)   unibi_term *ut = data->ut;   UI *ui = data->bridge->ui; -  if (input.supports_csiu) {+  if (input.csiu_type == kCSIuKitty) {     data->unibi_ext.enable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.enable_extended_keys"",                                                                   ""\x1b[>1u"");     data->unibi_ext.disable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.disable_extended_keys"",                                                                    ""\x1b[<1u"");+  } else if (input.csiu_type == kCSIuXterm) {+    // Fallback to modifyOtherKeys if terminal does not support CSI u+    data->unibi_ext.enable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.enable_extended_keys"",+                                                                  ""\x1b[>4;2m"");+    data->unibi_ext.disable_extended_keys = (int)unibi_add_ext_str(ut,+                                                                   ""ext.disable_extended_keys"",+                                                                   ""\x1b[>4;0m"");   }    unibi_out_ext(ui, data->unibi_ext.enable_extended_keys);@@ -2101,12 +2108,7 @@ static void augment_terminfo(TUIData *data, const char *term, long vte_version,   }    if (!kitty && (vte_version == 0 || vte_version >= 5400)) {-    // Fallback to modifyOtherKeys if terminal does not support CSI u-    data->unibi_ext.enable_extended_keys = (int)unibi_add_ext_str(ut, ""ext.enable_extended_keys"",-                                                                  ""\x1b[>4;2m"");-    data->unibi_ext.disable_extended_keys = (int)unibi_add_ext_str(ut,-                                                                   ""ext.disable_extended_keys"",-                                                                   ""\x1b[>4;0m"");+    data->input.csiu_type = kCSIuXterm;   } } ```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15674,857083536,2022-04-24T07:50:35Z,src/nvim/screen.c,"@@ -4297,9 +4319,15 @@ void draw_virt_text(buf_T *buf, int col_off, int *end_col, int max_col)     if (item->win_col < 0) {       continue;     }--    int col = draw_virt_text_item(buf, item->win_col, item->decor.virt_text,-                                  item->decor.hl_mode, max_col, item->win_col-col_off);+    int col;+    if (item->decor.ui_watched) {+      // don't draw watched decors, let ui handle that.+      col = item->win_col;+      win_extmarks_add(item->ns_id, item->mark_id, win_row, col);+    } else {","yes, otherwise the attribute `virt_text` is just ignored, and there is no need to do so any longer. if a plugin doesn't want this, they can just set `ui_watched` now.",
20684720,yatli,https://api.github.com/repos/neovim/neovim/pulls/15674,857146931,2022-04-24T15:58:39Z,src/nvim/api/ui_events.in.h,"@@ -123,6 +123,10 @@ void win_viewport(Integer grid, Window win, Integer topline,                   Integer line_count)   FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY; +void win_extmarks(Window win, Integer ns_id, Integer mark_id, Integer row,",Done. This accidentally fixed some multi-window same buf sync problems I mentioned earlier for fvim...,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,857196249,2022-04-25T00:19:53Z,src/nvim/ex_getln.c,"@@ -2349,11 +2349,21 @@ static int command_line_changed(CommandLineState *s)     //       - Update the screen while the effects are in place.     //       - Immediately undo the effects.     State |= CMDPREVIEW;-    emsg_silent++;  // Block error reporting as the command may be incomplete-    msg_silent++;   // Block messages, namely ones that prompt+    emsg_silent++;                 // Block error reporting as the command may be incomplete+    msg_silent++;                  // Block messages, namely ones that prompt+    block_autocmds();              // Block events+    garray_T save_view;+    win_size_save(&save_view);     // Save current window sizes+    save_search_patterns();        // Save search patterns+    State |= PREVIEW_EXEC;         // Set live preview execution state","does it work if you temporarily _unset_ `CMDPREVIEW` here? or is that insane?if not, can you at least rename `PREVIEW_EXEC` to `CMDPREVIEW_EXEC`. Use consistent patterns to give readers hints.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18234,857200038,2022-04-25T00:49:53Z,src/nvim/search.c,"@@ -6017,3 +6017,9 @@ bool search_was_last_used(void) {   return last_idx == 0; }++/// @return  true if 'hlsearch' highlight is currently in use.+bool hlsearch_used(void)","I don't think using this in `start_search_hl()` reduces much code, as it is still necessary to call `last_pat_prog()` to set `search_hl.rm.regprog = NULL` if there is no last pattern.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18247,857203675,2022-04-25T01:13:02Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,31 @@+local M = {}++-- This function checks the first 15 lines for appearance of 'FoamFile'+-- and then 'object' in a following line.+-- In that case, it's probably an OpenFOAM file+function M.foam()+  local foam_file = false+  for line = 1, 15 do+    local current_line = vim.fn.getline(line)","Use `vim.api.nvim_buf_get_lines(bufnr, 0, 15, true)` and then iterate over that with `ipairs()` instead of calling `vim.fn.getline` in each iteration. Also modify this function to accept a `bufnr` parameter and pass it in `filetype.lua`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17197,857220951,2022-04-25T02:31:23Z,test/functional/terminal/tui_spec.lua,"@@ -1529,119 +1529,44 @@ describe(""TUI"", function() end)  describe('TUI bg color', function()-  local screen--  local function setup()-    -- Only single integration test.-    -- See test/unit/tui_spec.lua for unit tests.-    clear()-    screen = thelpers.screen_setup(0, '[""'..nvim_prog-      ..'"", ""-u"", ""NONE"", ""-i"", ""NONE"", ""--cmd"", ""set noswapfile"", '-      ..'""-c"", ""autocmd OptionSet background echo \\""did OptionSet, yay!\\""""]')-  end--  before_each(setup)--  it('triggers OptionSet event on unsplit terminal-response', function()-    screen:expect([[-    {1: }                                                 |-    {4:~                                                 }|-    {4:~                                                 }|-    {4:~                                                 }|-    {5:[No Name]                       0,0-1          All}|-                                                      |-    {3:-- TERMINAL --}                                    |-    ]])-    feed_data('\027]11;rgb:ffff/ffff/ffff\007')-    screen:expect{any='did OptionSet, yay!'}--    feed_data(':echo ""new_bg="".&background\n')-    screen:expect{any='new_bg=light'}--    setup()-    screen:expect([[-    {1: }                                                 |-    {4:~                                                 }|-    {4:~                                                 }|-    {4:~                                                 }|-    {5:[No Name]                       0,0-1          All}|-                                                      |-    {3:-- TERMINAL --}                                    |-    ]])-    feed_data('\027]11;rgba:ffff/ffff/ffff/8000\027\\')-    screen:expect{any='did OptionSet, yay!'}+  before_each(clear) -    feed_data(':echo ""new_bg="".&background\n')-    screen:expect{any='new_bg=light'}+  it('is properly set in a nested Neovim instance when background=dark', function()+    command('set background=dark')  -- set outer Neovim background+    local screen = thelpers.screen_setup(0, string.format(+      '[""%s"", ""-u"", ""NONE"", ""-i"", ""NONE"", ""--cmd"", ""set noswapfile""]', nvim_prog))+    retry(nil, 30000, function()  -- wait for automatic background processing+      screen:sleep(20)+      feed_command('set background?')  -- check nested Neovim background+      screen:expect([[+      {1: }                                                 |+      {4:~                                                 }|+      {4:~                                                 }|+      {4:~                                                 }|+      {5:[No Name]                       0,0-1          All}|+        background=dark                                 |+      {3:-- TERMINAL --}                                    |+      ]])+    end)   end) -  it('triggers OptionSet event with split terminal-response', function()",why isn't OptionSet being tested now? is it no longer triggered?,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17197,857221289,2022-04-25T02:32:20Z,src/nvim/terminal.c,"@@ -172,6 +173,39 @@ void terminal_teardown(void)   pmap_init(ptr_t, &invalidated_terminals); } +static int on_osc_fallback(const char *command, size_t cmdlen, void *user)+{+  // Check for an OSC foreground/background color request, and respond+  // accordingly.+  if (cmdlen == 4) {+    bool fg_request = strncmp(command, ""10;?"", 4) == 0;+    bool bg_request = !fg_request && strncmp(command, ""11;?"", 4) == 0;+    if (fg_request || bg_request) {+      // WARN: This does not return the actual foreground/background color, but+      // rather returns:+      //   - fg=white/bg=black when Neovim option 'background' is 'dark'+      //   - fg=black/bg=white when Neovim option 'background' is 'light'+      char_u *bg_option;+      long dummy;+      get_option_value(""background"", &dummy, &bg_option, OPT_GLOBAL);+      bool bg_option_dark = STRNCMP(bg_option, ""dark"", 4) == 0;+      xfree(bg_option);+      Terminal *term = user;+      int red = 0x00, green = 0x00, blue = 0x00;+      if ((fg_request && bg_option_dark) || (bg_request && !bg_option_dark)) {+        red = green = blue = 0xff;+      }+      char data[25];+      snprintf(+          data, sizeof(data), ""\x1b]%.3srgb:%02x%02x/%02x%02x/%02x%02x\x07"",+          command, red, red, green, green, blue, blue);+      terminal_send(term, data, sizeof(data) - 1);  // excludes null byte","You can use the `S_LEN` macro here```suggestion      terminal_send(term, S_LEN(data));```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18165,857223180,2022-04-25T02:39:37Z,src/nvim/buffer.c,"@@ -357,6 +357,7 @@ void set_bufref(bufref_T *bufref, buf_T *buf) /// /// @param bufref Buffer reference to check for. bool bufref_valid(bufref_T *bufref)+  FUNC_ATTR_PURE","https://github.com/neovim/nvimdev.nvim should probably highlight this in orange or something. I always wonder if someone might accidentally change one of these functions to cause side effects, without removing the attr.",
11534587,glacambre,https://api.github.com/repos/neovim/neovim/pulls/17197,857269398,2022-04-25T05:33:06Z,src/nvim/terminal.c,"@@ -172,6 +173,39 @@ void terminal_teardown(void)   pmap_init(ptr_t, &invalidated_terminals); } +static int on_osc_fallback(const char *command, size_t cmdlen, void *user)","I would rename this function parse_osc in order to match the [name used by Vim](https://github.com/vim/vim/blob/af59e34f1bf214ec6f2d0304c1c5b11ecda25a83/src/terminal.c#L4466), which could potentially make porting future patches easier ",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18247,857392785,2022-04-25T08:44:33Z,runtime/lua/vim/filetype.lua,"@@ -929,10 +929,10 @@ local filename = {   [""exim.conf""] = ""exim"",   exports = ""exports"",   ["".fetchmailrc""] = ""fetchmail"",-  fvSchemes = function() vim.fn[""dist#ft#FTfoam""]() end,-  fvSolution = function() vim.fn[""dist#ft#FTfoam""]() end,-  fvConstraints = function() vim.fn[""dist#ft#FTfoam""]() end,-  fvModels = function() vim.fn[""dist#ft#FTfoam""]() end,+  fvSchemes = function(path, bufnr) return require(""vim.filetype.detect"").foam(bufnr) end,",Should I rename the unused `path` argument to `_`?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18247,857394102,2022-04-25T08:45:41Z,runtime/lua/vim/filetype.lua,"@@ -929,10 +929,10 @@ local filename = {   [""exim.conf""] = ""exim"",   exports = ""exports"",   ["".fetchmailrc""] = ""fetchmail"",-  fvSchemes = function() vim.fn[""dist#ft#FTfoam""]() end,-  fvSolution = function() vim.fn[""dist#ft#FTfoam""]() end,-  fvConstraints = function() vim.fn[""dist#ft#FTfoam""]() end,-  fvModels = function() vim.fn[""dist#ft#FTfoam""]() end,+  fvSchemes = function(path, bufnr) return require(""vim.filetype.detect"").foam(bufnr) end,",No; please keep to the patterns in `filetype.lua` -- things should be consistent; they can still be improved (en masse) afterwards.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,857483116,2022-04-25T10:30:24Z,runtime/doc/lua.txt,"@@ -830,6 +830,26 @@ vim.spell.check({str})                                      *vim.spell.check()*                 ""caps""  word should start with Capital             - The position in {str} where the word begins. +------------------------------------------------------------------------------+VIM.PREVIEW						 	 *lua-preview*++vim.preview.open_win({opts})			      *vim.preview.open_win()*","Not sure `vim.preview` is the right name. ""preview window"" has a long established meaning in Vim (`:help preview-windows`)I guess `vim.cmd_preview` might work, or `vim.inccommand`",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/16393,857569588,2022-04-25T12:25:49Z,config/config.h.in,"@@ -4,7 +4,10 @@ #cmakedefine DEBUG  #define SIZEOF_INT @SIZEOF_INT@+#define SIZEOF_INTMAX_T @SIZEOF_INTMAX_T@ #define SIZEOF_LONG @SIZEOF_LONG@+#define SIZEOF_LONG_LONG @SIZEOF_LONG_LONG@+#define SIZEOF_SIZE_T @SIZEOF_SIZE_T@","yeah this works as well, I opted to keep the longer version, `#cmakedefine SIZEOF_INT @SIZEOF_INT@`, hoping to avoid any potential problems, or do you think it's fine either way?refs: - https://cmake.org/cmake/help/v3.10/module/CheckTypeSize.htmlexternal example:- https://opensource.apple.com/source/curl/curl-121.100.3/curl/lib/curl_config.h.cmake",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18244,857615264,2022-04-25T13:17:00Z,runtime/lua/vim/filetype.lua,"@@ -851,7 +851,7 @@ local extension = {   stm = function() vim.fn[""dist#ft#FThtml""]() end,   tcsh = function() vim.fn[""dist#ft#SetFileTypeShell""](""tcsh"") end,   tex = function() vim.fn[""dist#ft#FTtex""]() end,-  tf = function() vim.fn[""dist#ft#FTtf""]() end,+  tf = function() return require'vim.filetype.detect'.tf() end,","Style nitpick. I don't really care about single or double quotes, as long as we're consistent throughout the file.I think we should also establish a precedent of always passing `path` and `bufnr` to the detection functions, even if they're not used.```suggestion  tf = function(path, bufnr) return require(""vim.filetype.detect"").tf(path, bufnr) end,```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18244,857644608,2022-04-25T13:45:00Z,runtime/lua/vim/filetype.lua,"@@ -851,7 +851,7 @@ local extension = {   stm = function() vim.fn[""dist#ft#FThtml""]() end,   tcsh = function() vim.fn[""dist#ft#SetFileTypeShell""](""tcsh"") end,   tex = function() vim.fn[""dist#ft#FTtex""]() end,-  tf = function() vim.fn[""dist#ft#FTtf""]() end,+  tf = function(path, bufnr) return require(""vim.filetype.detect"").tf(path, bufnr) end,","Sorry, but no -- this would evaluate the `require` unconditionally for _every_ filetype detection (i.e., when `filetype.lua` is sourced), which would have a noticeable performance regression.This exact pattern (wrap `require` in a function) is the closest Lua equivalent of Vimscript's `autoload`.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18247,857683148,2022-04-25T14:21:43Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,29 @@+local M = {}++-- This function checks the first 15 lines for appearance of 'FoamFile'+-- and then 'object' in a following line.+-- In that case, it's probably an OpenFOAM file+function M.foam(path, bufnr)+  local foam_file = false+  for _, line in ipairs(vim.api.nvim_get_lines(bufnr, 0, 15, true)) do+    if line:find(""^FoamFile"") then+      foam_file = true+    elseif foam_file and line:find(""^%s*object"") then+      return ""foam""+    end+  end+end++-- Determine if a *.tf file is TF mud client or terraform+function M.tf(path, bufnr)+  local number_of_lines = vim.fn.line(""$"")+  for line = 1, number_of_lines do+    local current_line = vim.fn.trim(vim.fn.getline(line))","Oh, nice, I did think that was too useful not to have as a standard library function ;)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18194,857799909,2022-04-25T16:10:42Z,runtime/doc/api.txt,"@@ -733,8 +733,10 @@ nvim_create_user_command({name}, {command}, {*opts})                                |:command-complete|, the ""complete"" key also                                accepts a Lua function which works like the                                ""customlist"" completion mode-                               |:command-completion-customlist|. Additional-                               parameters:+                               |:command-completion-customlist|. There is also+                               an additional ""preview"" key which allows+                               enabling |:command-preview| for 'inccommand'.+                               Additional parameters:","Sorry if this has already been hashed out elsewhere, but why put ""preview"" here and not with the rest of the `Additional parameters`?",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18194,857815774,2022-04-25T16:28:06Z,runtime/doc/map.txt,"@@ -1431,6 +1431,211 @@ Possible values are (second column is the short name used in listing):     -addr=other		  ?	other kind of range  +Incremental preview ~+                                                  *:command-preview* {nvim-api}+It's possible to allow commands to be incrementally previewed when+'inccommand' is enabled by using the preview command attribute. The preview+attribute may only be used through the API. (see |nvim_create_user_command()|)++The value of the preview attribute must be either a boolean value, the name of+a Vim script function or a |Lua| function callback. Here are some examples: >++	"" setting preview to a boolean value+	call nvim_create_user_command('foo', 'call Foo()',+		\ { 'preview': v:true })++	"" setting preview to a Vim script function+	function! PreviewFunc()+	    return v:true+	endfunction++	call nvim_create_user_command('bar', 'call Bar()',+		\ { 'preview': 'PreviewFunc' })++	-- setting preview to a Lua function callback+	lua << EOF+	local function PreviewFunc()+	    return true+	end++	vim.api.nvim_create_user_command('baz', 'call Baz()',+	                                 { preview = PreviewFunc })+	EOF+<++If preview is |TRUE|, preview is always triggered every time the command line+is modified. If it's not a boolean value, the Vim script or Lua function is+called and command preview is triggered only if the function returns |TRUE|.+The function may only take one argument, which is the contents of the command+line.++Every time a command needs to be previewed, Nvim executes the command. The+command itself must do the job of making appropriate changes to the buffer+and setting the appropriate highlights for previewing. It's possible to check+if a command is being executed for previewing by checking if current mode name+starts with ""cp"" (see |mode()|).++In order for command preview to work properly, the command must follow these+steps, in order, to implement the Nvim command preview ""protocol"".+    1. Make necessary buffer changes and highlighting for the preview.+    2. If 'inccommand' equals ""split"" and Nvim is in command preview mode,+       open preview window using |vim.cmd_preview.open_win()| and put the+       necessary text and highlighting on it. Otherwise, close preview window+       if it's open using |vim.cmd_preview.close_win()|.+    3. Trigger a |:redraw| of the window.+    4. Undo all changes made to the buffer in step 1, without keeping them+       in the undo history (see |:undo|).+    5. Clear all highlights set in step 1.+    6. If preview window was opened in step 2, switch back to main window to+       ensure that if the command is executed, it gets executed on the main+       window and not the preview window.++Here is an example written in |Lua| that uses the preview flag to preview a+command that trims trailing whitespaces from lines while following the+aforementioned steps: >++	-- Namespace for command preview highlights+	local namespace =+		vim.api.nvim_create_namespace('TrimTrailingWhitespaceNS')+	local preview_win = 0++	-- Function that determines whether command preview is triggered+	local function PreviewFunc(cmd)+	    -- Preview when first argument equals 'enable'+	    local args = vim.fn.split(cmd, ' ')+	    return #args > 1 and args[2] == 'enable'+	end++	local function TrimTrailingWhitespace(opts)+	    local line1 = opts.line1+	    local line2 = opts.line2+	    local curwin = vim.api.nvim_get_current_win()+	    local curbuf = vim.api.nvim_get_current_buf()+	    local lines = vim.api.nvim_buf_get_lines(curbuf, line1 - 1,+						     line2, 0)+	    local new_lines = {}++	    -- Check the first two letters of the mode string rather than the+	    -- whole mode string since more specific modes may be added+	    -- at any time+	    local cmdpreview = vim.api.nvim_get_mode().mode:sub(1, 2) == ""cp""+	    local incsplit = vim.opt.inccommand:get() == 'split'++	    -- If in command preview mode, temporarily unset 'cursorcolumn',+	    -- 'cursorline' and 'hlsearch' to not mess up highlights+	    local save_cursorcolumn = vim.o.cursorcolumn+	    local save_cursorline = vim.o.cursorline+	    local save_hlsearch = vim.o.hlsearch+	    vim.o.cursorcolumn = false+	    vim.o.cursorline = false+	    vim.o.hlsearch = false++	    -- If in command preview mode and inccommand=split,+	    -- open the preview window if it's not already opened+	    -- Otherwise close preview window+	    if cmdpreview and incsplit then+		if not (preview_win ~= 0+			and vim.fn.win_gettype(preview_win) ~= 'unknown')+		then+		    preview_win = vim.cmd_preview.open_win()+		end+	    else+		preview_win = 0+		vim.cmd_preview.close_win()+	    end++	    local preview_buf = vim.api.nvim_win_get_buf(preview_win)+	    local preview_buf_line = 0++	    for i = 0, #lines - 1 do","Ah nope. This function was translated from Vimscript to Lua since the original one was written in Vimscript, so I ended up translating that literally. My bad",
5426924,adrian5,https://api.github.com/repos/neovim/neovim/pulls/17933,857825711,2022-04-25T16:39:53Z,runtime/doc/lua.txt,"@@ -1415,14 +1415,14 @@ schedule_wrap({cb})                                      *vim.schedule_wrap()* deep_equal({a}, {b})                                        *vim.deep_equal()*                 Deep compare values for equality -                Tables are compared recursively unless they both provide the `eq` methamethod. All other types are compared using the equality `==` operator.+                Tables are compared recursively unless they both provide the `eq` metamethod. All other types are compared using the equality `==` operator.","Hmm, good question. I can definitely wrap that one.~While I'm at it, should I also maximize line length within the `78` char limit where it doesn't hurt readability, i.e. in the middle of a regular sentence? There are a few paragraphs that wrap earlier than needed, and could probably get rid of 1 extra line.~ Scratch that, I think this is done for visual reasons, 3 equally long lines may look nicer than 2 unequal ones.And two spaces after colons or one?",
19230067,qrasmont,https://api.github.com/repos/neovim/neovim/pulls/18232,857953713,2022-04-25T19:23:12Z,runtime/lua/vim/treesitter.lua,"@@ -137,4 +137,45 @@ function M.is_ancestor(dest, source)   return false end +--- Get the next node of the same parent+---+---@param node The start node+---@param opts table A table of optional arguments:+---                  - switch_parent: (boolean, default false) Allow to return the first node from+---                  the next parent if the start node is the last node of its parent.+---                  - return_next_parent: (boolean, default false) With switch_parent = true, allow+---                  to return the next parent as the next node if it has no children.+---+---@returns The next node+function M.get_next_node(node, opts)","I used an opts table here as it seems like something I see a lot in other APIs when a function has optional parameters, good or bad idea ?  ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18247,858553324,2022-04-26T10:30:55Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,362 @@+local M = {}++---@private+local function count_lines(bufnr)+  return vim.api.nvim_buf_line_count(bufnr)+end++---@private+local function get_lines(bufnr, start_lnum, end_lnum)+  end_lnum = end_lnum or start_lnum+  local lines = vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, end_lnum, false)+  return table.concat(lines) or """"+end++---@private+local function iter_lines(bufnr, start_lnum, end_lnum)+  end_lnum = end_lnum or start_lnum+  return ipairs(vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, end_lnum, false))+end++function M.asm()++end++function M.asm_syntax()++end++function M.bas()++end++function M.bindzone()++end++function M.btm(_, bufnr)+  if vim.g.dosbatch_syntax_for_btm ~= nil and vim.g.dosbatch_syntax_for_btm ~= 0 then+    vim.bo[bufnr].filetype = ""dosbatch""+  else+    vim.bo[bufnr].filetype = ""btm""+  end+end++function M.cfg()++end++function M.change()++end++function M.csh()++end++function M.dat()++end++function M.dep3patch()++end++function M.dtrace()++end++function M.e()++end++-- This function checks for valid cl syntax in the first five lines.+-- Look for either an opening comment, '#', or a block start, '{'.+-- If not found, assume SGML.+function M.ent(_, bufnr)+  for _, line in iter_lines(bufnr, 1, 5) do+    if line:find(""^%s*[#{]"") then+      vim.bo[bufnr].filetype = ""cl""+      return+    elseif not line:find(""^%s*$"") then+      -- Not a blank line, not a comment, and not a block start,+      -- so doesn't look like valid cl code.+      break+    end+  end+  vim.bo[bufnr].filetype = ""dtd""+end++function M.euphoria_check(_, bufnr)+  if vim.g.filetype_euphoria ~= nil then",```suggestion  if vim.g.filetype_euphoria then```(and similarly everywhere),
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/14046,858967795,2022-04-26T17:18:10Z,runtime/lua/vim/treesitter/query.lua,"@@ -278,7 +266,7 @@ local directive_handlers = {      -- If this produces an invalid range, we just skip it.     if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      metadata[pred[2]][key] = range+      metadata.content = {range}",Just looking at this PR in relation to https://github.com/nvim-treesitter/nvim-treesitter/pull/2850Why was this change made? Shouldn't offset only apply to the capture being passed in? The code before looked good. Now the offset metadata is non-capture specific.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18221,859108823,2022-04-26T20:17:08Z,runtime/lua/vim/lsp/buf.lua,"@@ -571,35 +581,48 @@ end --- Requests code actions from all clients and calls the handler exactly once --- with all aggregated results ---@private-local function code_action_request(params)+local function code_action_request(params, opts)   local bufnr = vim.api.nvim_get_current_buf()   local method = 'textDocument/codeAction'   vim.lsp.buf_request_all(bufnr, method, params, function(results)-    on_code_action_results(results, { bufnr = bufnr, method = method, params = params })+    ctx = { bufnr = bufnr, method = method, params = params, opts = opts}+    on_code_action_results(results, ctx)","the `ctx` is also passed along to client side commands, I'm not sure if it's good to add extra state that is then leaked out.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/15723,860035897,2022-04-27T16:56:23Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,137 @@+local M = {}++local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return math.floor((n / math.pow(2, k)) % 2)+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+---+--- This function can be configured with |vim.lsp.with()| with the following options for `config`+---+--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line             -- line number 0-based+---         start_char       -- start character 0-based+---         length           -- length in characters of this token+---         type             -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers        -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         offset_encoding  -- offset encoding used by the language server (see |lsp-sync|)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens+---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  active_requests[ctx.bufnr] = false+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  -- FIXME: this is should be done properly here and in the codelens implementation. Handlers should+  -- not be responsible of checking whether their responses are still valid.+  if err or not response or not config.on_token or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {+      line = line,+      start_char = start_char,+      length = data[i + 2],+      type = token_type,+      modifiers = modifiers,+      offset_encoding = client.offset_encoding,+    }++    if token_type and config and config.on_token then+      config.on_token(ctx, token)+    end+  end+end++--- |lsp-handler| for the method `textDocument/semanticTokens/refresh`+---+function M.on_refresh(err, _, ctx, _)+  if not err then+    for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(ctx.client_id)) do+      M.refresh(bufnr)+    end+  end+  return vim.NIL+end++---@private+function M._save_tick(bufnr)+  bufnr = bufnr or vim.api.nvim_get_current_buf()+  last_tick[bufnr] = vim.api.nvim_buf_get_changedtick(bufnr)+  active_requests[bufnr] = true+end++--- Refresh the semantic tokens for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- <pre>+---   autocmd BufEnter,CursorHold,InsertLeave <buffer> lua require 'vim.lsp.semantic_tokens'.refresh(vim.api.nvim_get_current_buf())+--- </pre>+---+--- @param bufnr number+function M.refresh(bufnr)","I'd still suggest:```lua  bufnr = bufnr or vim.api.nvim_get_current_buf()```All of the APIs in lsp.lua that take a bufnr argument wrap it in `resolve_bufnr()` which is basically the above with some validation (and allows using `0` to also mean the current buffer).Should `resolve_bufnr()` be exposed by the lsp module and used here directly? Either way, the comment above should also be updated to reflect that this will refresh semantic tokens for the given buffer (not necessarily current).",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15583,862203263,2022-04-29T22:09:28Z,runtime/doc/starting.txt,"@@ -1329,7 +1329,7 @@ paths. 						*base-directories* *xdg* The ""base"" (root) directories conform to the XDG Base Directory Specification. https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html-The $XDG_CONFIG_HOME and $XDG_DATA_HOME environment variables are used if they+The $XDG_CONFIG_HOME, $XDG_DATA_HOME and $XDG_STATE_HOME environment variables are used if they","```suggestionThe $XDG_CONFIG_HOME, $XDG_DATA_HOME and $XDG_STATE_HOME environment variablesare used if they exist, otherwise default values (listed below) are used.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18231,862307493,2022-04-30T05:45:10Z,src/nvim/ex_docmd.c,"@@ -1220,6 +1220,302 @@ static char_u *skip_colon_white(const char_u *p, bool skipleadingwhite)   return (char_u *)p; } +/// Set the addr type for command+///+/// @param p pointer to character after command name in cmdline+static void set_cmd_addr_type(exarg_T *eap, char_u *p)+{+  // ea.addr_type for user commands is set by find_ucmd+  if (!IS_USER_CMDIDX(eap->cmdidx)) {+    if (eap->cmdidx != CMD_SIZE) {+      eap->addr_type = cmdnames[(int)eap->cmdidx].cmd_addr_type;+    } else {+      eap->addr_type = ADDR_LINES;+    }+    // :wincmd range depends on the argument+    if (eap->cmdidx == CMD_wincmd && p != NULL) {+      get_wincmd_addr_type(skipwhite(p), eap);+    }+    // :.cc in quickfix window uses line number+    if ((eap->cmdidx == CMD_cc || eap->cmdidx == CMD_ll) && bt_quickfix(curbuf)) {+      eap->addr_type = ADDR_OTHER;+    }+  }+}++/// Set default command range based on the addr type of the command+static void set_cmd_default_range(exarg_T *eap)+{+  buf_T *buf;++  eap->line1 = 1;+  switch (eap->addr_type) {+  case ADDR_LINES:+  case ADDR_OTHER:+    eap->line2 = curbuf->b_ml.ml_line_count;+    break;+  case ADDR_LOADED_BUFFERS:+    buf = firstbuf;+    while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_next;+    }+    eap->line1 = buf->b_fnum;+    buf = lastbuf;+    while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_prev;+    }+    eap->line2 = buf->b_fnum;+    break;+  case ADDR_BUFFERS:+    eap->line1 = firstbuf->b_fnum;+    eap->line2 = lastbuf->b_fnum;+    break;+  case ADDR_WINDOWS:+    eap->line2 = LAST_WIN_NR;+    break;+  case ADDR_TABS:+    eap->line2 = LAST_TAB_NR;+    break;+  case ADDR_TABS_RELATIVE:+    eap->line2 = 1;+    break;+  case ADDR_ARGUMENTS:+    if (ARGCOUNT == 0) {+      eap->line1 = eap->line2 = 0;+    } else {+      eap->line2 = ARGCOUNT;+    }+    break;+  case ADDR_QUICKFIX_VALID:+    eap->line2 = (linenr_T)qf_get_valid_size(eap);+    if (eap->line2 == 0) {+      eap->line2 = 1;+    }+    break;+  case ADDR_NONE:+  case ADDR_UNSIGNED:+  case ADDR_QUICKFIX:+    iemsg(_(""INTERNAL: Cannot use EX_DFLALL ""+            ""with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX""));+    break;+  }+}++/// Check if command with ID handles '|' themselves+bool command_handles_bar(cmdidx_T cmdidx)",can this be generated from `ex_cmds.lua`? or it's a separate list (���� )?,
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18231,862308746,2022-04-30T06:01:56Z,src/nvim/ex_docmd.c,"@@ -1220,6 +1220,302 @@ static char_u *skip_colon_white(const char_u *p, bool skipleadingwhite)   return (char_u *)p; } +/// Set the addr type for command+///+/// @param p pointer to character after command name in cmdline+static void set_cmd_addr_type(exarg_T *eap, char_u *p)+{+  // ea.addr_type for user commands is set by find_ucmd+  if (!IS_USER_CMDIDX(eap->cmdidx)) {+    if (eap->cmdidx != CMD_SIZE) {+      eap->addr_type = cmdnames[(int)eap->cmdidx].cmd_addr_type;+    } else {+      eap->addr_type = ADDR_LINES;+    }+    // :wincmd range depends on the argument+    if (eap->cmdidx == CMD_wincmd && p != NULL) {+      get_wincmd_addr_type(skipwhite(p), eap);+    }+    // :.cc in quickfix window uses line number+    if ((eap->cmdidx == CMD_cc || eap->cmdidx == CMD_ll) && bt_quickfix(curbuf)) {+      eap->addr_type = ADDR_OTHER;+    }+  }+}++/// Set default command range based on the addr type of the command+static void set_cmd_default_range(exarg_T *eap)+{+  buf_T *buf;++  eap->line1 = 1;+  switch (eap->addr_type) {+  case ADDR_LINES:+  case ADDR_OTHER:+    eap->line2 = curbuf->b_ml.ml_line_count;+    break;+  case ADDR_LOADED_BUFFERS:+    buf = firstbuf;+    while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_next;+    }+    eap->line1 = buf->b_fnum;+    buf = lastbuf;+    while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_prev;+    }+    eap->line2 = buf->b_fnum;+    break;+  case ADDR_BUFFERS:+    eap->line1 = firstbuf->b_fnum;+    eap->line2 = lastbuf->b_fnum;+    break;+  case ADDR_WINDOWS:+    eap->line2 = LAST_WIN_NR;+    break;+  case ADDR_TABS:+    eap->line2 = LAST_TAB_NR;+    break;+  case ADDR_TABS_RELATIVE:+    eap->line2 = 1;+    break;+  case ADDR_ARGUMENTS:+    if (ARGCOUNT == 0) {+      eap->line1 = eap->line2 = 0;+    } else {+      eap->line2 = ARGCOUNT;+    }+    break;+  case ADDR_QUICKFIX_VALID:+    eap->line2 = (linenr_T)qf_get_valid_size(eap);+    if (eap->line2 == 0) {+      eap->line2 = 1;+    }+    break;+  case ADDR_NONE:+  case ADDR_UNSIGNED:+  case ADDR_QUICKFIX:+    iemsg(_(""INTERNAL: Cannot use EX_DFLALL ""+            ""with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX""));+    break;+  }+}++/// Check if command with ID handles '|' themselves+bool command_handles_bar(cmdidx_T cmdidx)","It's a list of commands that don't have the `-bar` attribute and handle the `|` character by themselves, I found it in the code responsible for parsing a command and moved it from there into its own function.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18288,862309451,2022-04-30T06:10:56Z,src/nvim/ex_cmds_defs.h,"@@ -176,7 +176,7 @@ enum { struct exarg {   char_u *arg;             ///< argument of the command   char_u *nextcmd;         ///< next command (NULL if none)-  char_u *cmd;             ///< the name of the command (except for :make)+  char *cmd;             ///< the name of the command (except for :make)","might as well keep this aligned. The entire list doesn't need to be updated, but least this line could stay aligned.",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18231,862310248,2022-04-30T06:20:08Z,src/nvim/ex_docmd.c,"@@ -1220,6 +1220,302 @@ static char_u *skip_colon_white(const char_u *p, bool skipleadingwhite)   return (char_u *)p; } +/// Set the addr type for command+///+/// @param p pointer to character after command name in cmdline+static void set_cmd_addr_type(exarg_T *eap, char_u *p)+{+  // ea.addr_type for user commands is set by find_ucmd+  if (!IS_USER_CMDIDX(eap->cmdidx)) {+    if (eap->cmdidx != CMD_SIZE) {+      eap->addr_type = cmdnames[(int)eap->cmdidx].cmd_addr_type;+    } else {+      eap->addr_type = ADDR_LINES;+    }+    // :wincmd range depends on the argument+    if (eap->cmdidx == CMD_wincmd && p != NULL) {+      get_wincmd_addr_type(skipwhite(p), eap);+    }+    // :.cc in quickfix window uses line number+    if ((eap->cmdidx == CMD_cc || eap->cmdidx == CMD_ll) && bt_quickfix(curbuf)) {+      eap->addr_type = ADDR_OTHER;+    }+  }+}++/// Set default command range based on the addr type of the command+static void set_cmd_default_range(exarg_T *eap)+{+  buf_T *buf;++  eap->line1 = 1;+  switch (eap->addr_type) {+  case ADDR_LINES:+  case ADDR_OTHER:+    eap->line2 = curbuf->b_ml.ml_line_count;+    break;+  case ADDR_LOADED_BUFFERS:+    buf = firstbuf;+    while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_next;+    }+    eap->line1 = buf->b_fnum;+    buf = lastbuf;+    while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_prev;+    }+    eap->line2 = buf->b_fnum;+    break;+  case ADDR_BUFFERS:+    eap->line1 = firstbuf->b_fnum;+    eap->line2 = lastbuf->b_fnum;+    break;+  case ADDR_WINDOWS:+    eap->line2 = LAST_WIN_NR;+    break;+  case ADDR_TABS:+    eap->line2 = LAST_TAB_NR;+    break;+  case ADDR_TABS_RELATIVE:+    eap->line2 = 1;+    break;+  case ADDR_ARGUMENTS:+    if (ARGCOUNT == 0) {+      eap->line1 = eap->line2 = 0;+    } else {+      eap->line2 = ARGCOUNT;+    }+    break;+  case ADDR_QUICKFIX_VALID:+    eap->line2 = (linenr_T)qf_get_valid_size(eap);+    if (eap->line2 == 0) {+      eap->line2 = 1;+    }+    break;+  case ADDR_NONE:+  case ADDR_UNSIGNED:+  case ADDR_QUICKFIX:+    iemsg(_(""INTERNAL: Cannot use EX_DFLALL ""+            ""with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX""));+    break;+  }+}++/// Check if command with ID handles '|' themselves+bool command_handles_bar(cmdidx_T cmdidx)",On second thought maybe we shouldn't rely on this list and just check if the command doesn't have the `-bar` attribute? Though I'm not sure if that'll work perfectly since I'm not sure if this list contains all commands without the `-bar` attribute,X
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18231,862310447,2022-04-30T06:22:28Z,src/nvim/ex_docmd.c,"@@ -1220,6 +1220,302 @@ static char_u *skip_colon_white(const char_u *p, bool skipleadingwhite)   return (char_u *)p; } +/// Set the addr type for command+///+/// @param p pointer to character after command name in cmdline+static void set_cmd_addr_type(exarg_T *eap, char_u *p)+{+  // ea.addr_type for user commands is set by find_ucmd+  if (!IS_USER_CMDIDX(eap->cmdidx)) {+    if (eap->cmdidx != CMD_SIZE) {+      eap->addr_type = cmdnames[(int)eap->cmdidx].cmd_addr_type;+    } else {+      eap->addr_type = ADDR_LINES;+    }+    // :wincmd range depends on the argument+    if (eap->cmdidx == CMD_wincmd && p != NULL) {+      get_wincmd_addr_type(skipwhite(p), eap);+    }+    // :.cc in quickfix window uses line number+    if ((eap->cmdidx == CMD_cc || eap->cmdidx == CMD_ll) && bt_quickfix(curbuf)) {+      eap->addr_type = ADDR_OTHER;+    }+  }+}++/// Set default command range based on the addr type of the command+static void set_cmd_default_range(exarg_T *eap)+{+  buf_T *buf;++  eap->line1 = 1;+  switch (eap->addr_type) {+  case ADDR_LINES:+  case ADDR_OTHER:+    eap->line2 = curbuf->b_ml.ml_line_count;+    break;+  case ADDR_LOADED_BUFFERS:+    buf = firstbuf;+    while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_next;+    }+    eap->line1 = buf->b_fnum;+    buf = lastbuf;+    while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_prev;+    }+    eap->line2 = buf->b_fnum;+    break;+  case ADDR_BUFFERS:+    eap->line1 = firstbuf->b_fnum;+    eap->line2 = lastbuf->b_fnum;+    break;+  case ADDR_WINDOWS:+    eap->line2 = LAST_WIN_NR;+    break;+  case ADDR_TABS:+    eap->line2 = LAST_TAB_NR;+    break;+  case ADDR_TABS_RELATIVE:+    eap->line2 = 1;+    break;+  case ADDR_ARGUMENTS:+    if (ARGCOUNT == 0) {+      eap->line1 = eap->line2 = 0;+    } else {+      eap->line2 = ARGCOUNT;+    }+    break;+  case ADDR_QUICKFIX_VALID:+    eap->line2 = (linenr_T)qf_get_valid_size(eap);+    if (eap->line2 == 0) {+      eap->line2 = 1;+    }+    break;+  case ADDR_NONE:+  case ADDR_UNSIGNED:+  case ADDR_QUICKFIX:+    iemsg(_(""INTERNAL: Cannot use EX_DFLALL ""+            ""with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX""));+    break;+  }+}++/// Check if command with ID handles '|' themselves+bool command_handles_bar(cmdidx_T cmdidx)","Okay so it seems that all commands that don't have the `-bar` attribute aren't in the list, and those that aren't in the list are commands that always treat `|` as their argument. So it depends on what meaning we want the `|` magic value to have? Do we want it to mean that `|` is treated as a command separator or do we want it to mean that `|` is treated as an argument. Currently it means that even though the command handles `|` by itself, it may still be treated as a command separator, which I personally think is the right behavior",X
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18231,862311496,2022-04-30T06:31:28Z,src/nvim/ex_docmd.c,"@@ -1220,6 +1220,302 @@ static char_u *skip_colon_white(const char_u *p, bool skipleadingwhite)   return (char_u *)p; } +/// Set the addr type for command+///+/// @param p pointer to character after command name in cmdline+static void set_cmd_addr_type(exarg_T *eap, char_u *p)+{+  // ea.addr_type for user commands is set by find_ucmd+  if (!IS_USER_CMDIDX(eap->cmdidx)) {+    if (eap->cmdidx != CMD_SIZE) {+      eap->addr_type = cmdnames[(int)eap->cmdidx].cmd_addr_type;+    } else {+      eap->addr_type = ADDR_LINES;+    }+    // :wincmd range depends on the argument+    if (eap->cmdidx == CMD_wincmd && p != NULL) {+      get_wincmd_addr_type(skipwhite(p), eap);+    }+    // :.cc in quickfix window uses line number+    if ((eap->cmdidx == CMD_cc || eap->cmdidx == CMD_ll) && bt_quickfix(curbuf)) {+      eap->addr_type = ADDR_OTHER;+    }+  }+}++/// Set default command range based on the addr type of the command+static void set_cmd_default_range(exarg_T *eap)+{+  buf_T *buf;++  eap->line1 = 1;+  switch (eap->addr_type) {+  case ADDR_LINES:+  case ADDR_OTHER:+    eap->line2 = curbuf->b_ml.ml_line_count;+    break;+  case ADDR_LOADED_BUFFERS:+    buf = firstbuf;+    while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_next;+    }+    eap->line1 = buf->b_fnum;+    buf = lastbuf;+    while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) {+      buf = buf->b_prev;+    }+    eap->line2 = buf->b_fnum;+    break;+  case ADDR_BUFFERS:+    eap->line1 = firstbuf->b_fnum;+    eap->line2 = lastbuf->b_fnum;+    break;+  case ADDR_WINDOWS:+    eap->line2 = LAST_WIN_NR;+    break;+  case ADDR_TABS:+    eap->line2 = LAST_TAB_NR;+    break;+  case ADDR_TABS_RELATIVE:+    eap->line2 = 1;+    break;+  case ADDR_ARGUMENTS:+    if (ARGCOUNT == 0) {+      eap->line1 = eap->line2 = 0;+    } else {+      eap->line2 = ARGCOUNT;+    }+    break;+  case ADDR_QUICKFIX_VALID:+    eap->line2 = (linenr_T)qf_get_valid_size(eap);+    if (eap->line2 == 0) {+      eap->line2 = 1;+    }+    break;+  case ADDR_NONE:+  case ADDR_UNSIGNED:+  case ADDR_QUICKFIX:+    iemsg(_(""INTERNAL: Cannot use EX_DFLALL ""+            ""with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX""));+    break;+  }+}++/// Check if command with ID handles '|' themselves+bool command_handles_bar(cmdidx_T cmdidx)","> > Do we want it to mean that `|` is treated as a command separator or do we want it to mean that `|` is treated as an argument.> > If it's treated as an arg, that's ""literal"". If it's a separator that's ""magic"".> > The purpose of `magic=[]` (i.e. _no magic_) is to say ""I want all args to be passed literally to the command"". Commands can, of course, interpret the args any way they want.In that case, I need to change the behavior a bit. But there's some commands where it's ambiguous whether `|` is treated literally or not, and it depends on the position of the `|`, so it's near impossible to get a fully accurate definitive list of which commands treat `|` specially. We could do the next best thing however and just put `|` as magic for all commands with the `-bar` attribute",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18219,862328039,2022-04-30T08:04:26Z,runtime/lua/vim/filetype.lua,"@@ -904,6 +904,12 @@ local extension = {     end     return ""dosbatch""   end,+  rul = function(path, bufnr)+    if getline(bufnr, 1, 6):lower():find(""installshield"") then+      return ""ishd""+    end+    return ""diva""","The `asp` and `xpm` extensions above, for example.Either way is fine with me, but I would prefer if the pattern was consistent throughout this file.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18231,862361700,2022-04-30T14:29:35Z,src/nvim/api/vim.c,"@@ -2450,3 +2451,203 @@ void nvim_del_user_command(String name, Error *err) {   nvim_buf_del_user_command(-1, name, err); }++/// Parse command line.+///+/// Doesn't check the validity of command arguments.+///+/// @param str       Command line string to parse. Cannot contain ""\n"".+/// @param opts      Optional parameters. Reserved for future use.+/// @param[out] err  Error details, if any.+/// @return Dictionary containing command information, with these keys:+///         - cmd: (string) Command name.+///         - line1: (number) Starting line of command range. Only applicable if command can take a+///                  range.+///         - line2: (number) Final line of command range. Only applicable if command can take a+///                  range.+///         - bang: (boolean) Whether command contains a bang (!) modifier.+///         - args: (array) Command arguments.+///         - addr: (string) Value of |:command-addr|. Uses short name.+///         - nargs: (string) Value of |:command-nargs|.+///         - nextcmd: (string) Next command if there are multiple commands separated by a |:bar|.+///                             Empty if there isn't a next command.+///         - magic: (dictionary) Which characters have special meaning in the command arguments.+///             - file: (boolean) The command expands filenames. Which means characters such as ""%"",+///                               ""#"" and wildcards are expanded.","����  If we find exceptions where wildcards are literal but `%`/`#` are magic, we can add variants later.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18320,862362379,2022-04-30T14:36:54Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -692,7 +730,9 @@ end -- send diagnostic information and the client will still process it. The -- diagnostics are simply not displayed to the user. function M.disable(bufnr, client_id)-  vim.notify_once('vim.lsp.diagnostic.disable is deprecated. See :h deprecated', vim.log.levels.WARN)+  local message = 'vim.lsp.diagnostic.disable is deprecated. See :h deprecated'+  message = message .. '\nThis function will be removed in version 0.8.'","We probably want a `vim.deprecate()` function that standardizes this pattern.```@param name of the deprecated thing@param alternative thing to use instead of `name`@param version Nvim that will remove `name`function deprecate(name, alternative, version)```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18331,862384208,2022-04-30T18:25:50Z,runtime/lua/vim/lsp/codelens.lua,"@@ -245,7 +244,10 @@ function M.refresh()     return   end   active_refreshes[bufnr] = true-  vim.lsp.buf_request(0, 'textDocument/codeLens', params)+  vim.lsp.buf_request(0, 'textDocument/codeLens', params, function (...)+    active_refreshes[bufnr] = nil",This would clear it too early in the success case - it should wait until the lenses are all resolved. `M.on_codelens` needs to be called always even in the error case and https://github.com/neovim/neovim/blob/cc27540560672c1586e17a9e39512074e770b005/runtime/lua/vim/lsp/codelens.lua#L217 needs to be adjusted.Could probably also use a test-case,
6705160,williamboman,https://api.github.com/repos/neovim/neovim/pulls/18331,862387787,2022-04-30T19:13:04Z,runtime/lua/vim/lsp/codelens.lua,"@@ -214,14 +215,19 @@ end --- |lsp-handler| for the method `textDocument/codeLens` --- function M.on_codelens(err, result, ctx, _)-  assert(not err, vim.inspect(err))+  if err then+    active_refreshes[ctx.bufnr] = nil+    local _ = log.error() and log.error(""codelens"", ctx.client_id, err)+    return+  end","I figured logging the error and silently returning would be more in-line with what I'd personally expect. I also think it improves the overall experience, for example `rust_analyzer` returns errors when trying to retrieve codelenses before its cargo metadata check has resolved. With the error + `vim.inspect` approach, this is pretty disruptive as it more or less hijacks the entire editor",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,862397266,2022-04-30T21:22:05Z,src/nvim/api/keysets.lua,"@@ -52,6 +52,7 @@ return {     ""force"";     ""keepscript"";     ""nargs"";+    ""preview"";","Let's name it `cmdpreview` here and everywhere. That allows unambiguous grepping, discussions, discoverability, etc..<!--Alternatively, if we plan to extend this ""preview buffer"" to be used by any arbitrary plugin purpose (beyond commands), perhaps we could name this concept `previewbuf`. So ""preview window"" (`:help preview-window`) is one thing, ""preview buffer"" is a rather different idea.-->",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18331,862397768,2022-04-30T21:29:00Z,runtime/lua/vim/lsp/codelens.lua,"@@ -245,7 +244,10 @@ function M.refresh()     return   end   active_refreshes[bufnr] = true-  vim.lsp.buf_request(0, 'textDocument/codeLens', params)+  vim.lsp.buf_request(0, 'textDocument/codeLens', params, function (...)+    active_refreshes[bufnr] = nil","See https://github.com/neovim/neovim/blob/039d60bd9c4468bb53958943196390673569bd7b/test/functional/plugin/lsp_spec.lua#L2784-L2836The test_name links to a fake-server implementation:https://github.com/neovim/neovim/blob/039d60bd9c4468bb53958943196390673569bd7b/test/functional/plugin/lsp_spec.lua#L2792https://github.com/neovim/neovim/blob/039d60bd9c4468bb53958943196390673569bd7b/test/functional/fixtures/fake-lsp-server.lua#L781-L793You can create a new one that uses `expect_request` to send an error response to the client. Similar to here, (except that it should return the error instead of a regular result) https://github.com/neovim/neovim/blob/039d60bd9c4468bb53958943196390673569bd7b/test/functional/fixtures/fake-lsp-server.lua#L773-L775",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/17781,862401311,2022-04-30T22:23:02Z,scripts/gen_vimdoc.py,"@@ -1096,8 +1115,9 @@ def main(config, args):             try:                 title, helptag, section_doc = sections.pop(filename)             except KeyError:-                msg(f'warning: empty docs, skipping (target={target}): {filename}')-                msg(f'    existing docs: {sections.keys()}')+                msgs.append(+                        f'warning: empty docs, skipping (target={target}): {filename}')+                msgs.append(f'    existing docs: {sections.keys()}')","No global variables, which in hindsight wasn't a big win :)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/17218,862444289,2022-05-01T08:51:51Z,runtime/lua/vim/lsp.lua,"@@ -1612,95 +1612,20 @@ function lsp.buf_notify(bufnr, method, params) end  ----@private-local function adjust_start_col(lnum, line, items, encoding)-  local min_start_char = nil-  for _, item in pairs(items) do-    if item.filterText == nil and item.textEdit and item.textEdit.range.start.line == lnum - 1 then-      if min_start_char and min_start_char ~= item.textEdit.range.start.character then-        return nil-      end-      min_start_char = item.textEdit.range.start.character-    end-  end-  if min_start_char then-    return util._str_byteindex_enc(line, min_start_char, encoding)-  else-    return nil-  end-end- --- Implements 'omnifunc' compatible LSP completion. --- ---@see |complete-functions| ---@see |complete-items| ---@see |CompleteDone| -------@param findstart 0 or 1, decides behavior----@param base If findstart=0, text to match against+---@param findstart number 0 or 1, decides behavior+---@param base number If findstart=0, text to match against --- ---@returns (number) Decided by {findstart}: --- - findstart=0: column where the completion starts, or -2 or -3 --- - findstart=1: list of matches (actually just calls |complete()|) function lsp.omnifunc(findstart, base)-  local _ = log.debug() and log.debug(""omnifunc.findstart"", { findstart = findstart, base = base })--  local bufnr = resolve_bufnr()-  local has_buffer_clients = not tbl_isempty(all_buffer_active_clients[bufnr] or {})-  if not has_buffer_clients then-    if findstart == 1 then-      return -1-    else-      return {}-    end-  end--  -- Then, perform standard completion request-  local _ = log.info() and log.info(""base "", base)--  local pos = vim.api.nvim_win_get_cursor(0)-  local line = vim.api.nvim_get_current_line()-  local line_to_cursor = line:sub(1, pos[2])-  local _ = log.trace() and log.trace(""omnifunc.line"", pos, line)--  -- Get the start position of the current keyword-  local textMatch = vim.fn.match(line_to_cursor, '\\k*$')--  local params = util.make_position_params()--  local items = {}-  lsp.buf_request(bufnr, 'textDocument/completion', params, function(err, result, ctx)-    if err or not result or vim.fn.mode() ~= ""i"" then return end--    -- Completion response items may be relative to a position different than `textMatch`.-    -- Concrete example, with sumneko/lua-language-server:-    ---    -- require('plenary.asy|-    --         ���       ���   ���-    --         ���       ���   ��������� cursor_pos: 20-    --         ���       ��������������������� textMatch: 17-    --         ��������������������������������������������� textEdit.range.start.character: 9-    --                                 .newText = 'plenary.async'-    --                  ^^^-    --                  prefix (We'd remove everything not starting with `asy`,-    --                  so we'd eliminate the `plenary.async` result-    ---    -- `adjust_start_col` is used to prefer the language server boundary.-    ---    local client = lsp.get_client_by_id(ctx.client_id)-    local encoding = client and client.offset_encoding or 'utf-16'-    local candidates = util.extract_completion_items(result)-    local startbyte = adjust_start_col(pos[1], line, candidates, encoding) or textMatch-    local prefix = line:sub(startbyte + 1, pos[2])-    local matches = util.text_document_completion_list_to_complete_items(result, prefix)-    -- TODO(ashkan): is this the best way to do this?-    vim.list_extend(items, matches)-    vim.fn.complete(startbyte + 1, items)-  end)--  -- Return -2 to signal that we should continue completion so that we can-  -- async complete.-  return -2+  return require('vim.lsp.completion').omnifunc(findstart, base)",Would you be okay if I moved the function and deprecated the old one? Part of the motivation was actually to reduce the API surface by having everything in one place instead of split across lsp.lua and util.lua. That makes it possible to work more easily with local functions. This is picking up on some earlier efforts:- https://github.com/neovim/neovim/pull/12874- https://github.com/neovim/neovim/pull/16205And preparation to continue on some of the pending features:- https://github.com/neovim/neovim/pull/16102- https://github.com/neovim/neovim/pull/16974- https://github.com/neovim/neovim/pull/16225My plan was to add one function that let's one generate a customised omnifunc to handle all of that and potentially also- https://github.com/neovim/neovim/issues/13199I was also torn on keeping the extract_completion_items function.  It's a trivial function and I'm tending to deprecate it even without replacement *Update*Thinking some more on this - if neovim supported something like `vim.(b)o.omnifunc = luafunc` there could be a single `create_omnifunc(opts)`. Although I guess that would make it a bit more difficult for vimL users to use.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18247,862464904,2022-05-01T12:05:53Z,runtime/lua/vim/filetype.lua,"@@ -780,19 +780,19 @@ local extension = {   zsh = ""zsh"",   vala = ""vala"",   E = function() vim.fn[""dist#ft#FTe""]() end,-  EU = function() vim.fn[""dist#ft#EuphoriaCheck""]() end,-  EW = function() vim.fn[""dist#ft#EuphoriaCheck""]() end,-  EX = function() vim.fn[""dist#ft#EuphoriaCheck""]() end,-  EXU = function() vim.fn[""dist#ft#EuphoriaCheck""]() end,-  EXW = function() vim.fn[""dist#ft#EuphoriaCheck""]() end,+  EU = function(_, bufnr) return require(""vim.filetype.detect"").euphoria(_, bufnr) end,","```suggestion  EU = function(path, bufnr) return require(""vim.filetype.detect"").euphoria(path, bufnr) end,```We want to keep this pattern consistent for now; can be refactored later when the porting is complete.One thing I don't like is to _pass_  the underscore. I'd prefer if the `detect` function did not take unused arguments at all; the pattern would then be `EU = function(path, bufnr) return detect.euphoria(bufnr) end`",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18320,862515228,2022-05-01T19:57:19Z,runtime/lua/vim/_editor.lua,"@@ -735,6 +735,19 @@ function vim._cs_remote(rcid, server_addr, connect_error, args)   } end +--- Display a deprecation notification to the user.+---+---@param name        string     Deprecated function.+---@param alternative string|nil Preferred alternative function.+---@param version     string     Neovim version in which the deprecated","I'll provide a counter argument. I don't think exposing a scope argument is worth it, for two reasons: 1) plugins may not want to use the same verbiage that `vim.deprecate` uses (how many plugins use versions anyway?), so they will end up writing their own function anyway (we could solve this by adding yet another `message` argument, but then it becomes generalized beyond the point of usefulness), and 2) writing a ""deprecated"" function is so easy I doubt making it extensible to plugins will even be that useful.So I'd vote for just keeping this Neovim specific. Just my 2 cents.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18320,862518558,2022-05-01T20:33:57Z,runtime/lua/vim/_editor.lua,"@@ -735,6 +735,19 @@ function vim._cs_remote(rcid, server_addr, connect_error, args)   } end +--- Display a deprecation notification to the user.+---+---@param name        string     Deprecated function.+---@param alternative string|nil Preferred alternative function.+---@param version     string     Neovim version in which the deprecated","I was on mobile, so that was a bit brief. My suggestion was to make this ```<scope>: <function> is deprecated and will be removed by <date>. <Alternative text if not nil>```(Neovim itself may want to use a different verbiage depending on the exact nature of deprecation -- it may not be a 1:1 function replacement.)In general, the same argument applies to Neovim as well: Is it worth adding a new function to the API for something that's effectively a very thin wrapper over `vim.notify_once`? I'd posit what's sauce for the goose is sauce for the gander.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18357,862757188,2022-05-02T11:00:35Z,runtime/doc/ui.txt,"@@ -140,6 +145,19 @@ procedure:    Inside this request handler, the UI can safely do any initialization before    entering normal mode, for example reading variables set by init.vim. +							   *ui-startup-stdin*+An UI can support the native read from stdin feature as invoked with+`command | nvim -` for the builtin TUI.+The embedding process can detect that its stdin is open to a file which+not is a terminal, just like nvim does. It then needs to forward this fd+to neovim. As fd=0 is already is used to send rpc data from the embedder",```suggestionto Nvim. As fd=0 is already is used to send rpc data from the embedder```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18353,862795138,2022-05-02T12:15:48Z,runtime/lua/vim/filetype.lua,"@@ -1550,7 +1560,7 @@ function M.add(filetypes)   end    for k, v in pairs(filetypes.pattern or {}) do-    pattern[normalize_path(k)] = v+    pattern[normalize_path(k, 1)] = v","Minor nit, otherwise LGTM```suggestion    pattern[normalize_path(k, true)] = v```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18353,862940403,2022-05-02T15:21:13Z,runtime/lua/vim/filetype.lua,"@@ -1480,8 +1480,18 @@ end local pattern_sorted = sort_by_priority(pattern)  ---@private-local function normalize_path(path)-  return (path:gsub(""\\"", ""/""):gsub(""^~"", vim.env.HOME))+local function normalize_path(path, as_pattern)+  local normal = path:gsub(""\\"", '/')+  if normal:find('^~') then+    if as_pattern then+      -- Escape Lua's metacharacters when $HOME is used in a pattern.+      -- The rest of path should already be properly escaped.+      normal = vim.env.HOME:gsub('[-^$()%%.%[%]+?]', '%%%0') .. normal:sub(2)",is `vim.pesc` useful here? https://github.com/neovim/neovim/blob/b470ff0091bbcce4f59fe6ef27d745d49a29c278/runtime/lua/vim/shared.lua#L507,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18320,863089123,2022-05-02T18:40:00Z,runtime/lua/vim/_editor.lua,"@@ -735,6 +735,19 @@ function vim._cs_remote(rcid, server_addr, connect_error, args)   } end +--- Display a deprecation notification to the user.+---+---@param name        string     Deprecated function.+---@param alternative string|nil Preferred alternative function.+---@param version     string     Neovim version in which the deprecated","> In general, the same argument applies to Neovim as well: Is it worth adding a new function to the API for something that's effectively a very thin wrapper over `vim.notify_once`?I think so, because I've seen poor wording and missing details in these messages many times over the years. Removing a bit of friction helps us be better about deprecating things and providing notices.> I don't think exposing a scope argument is worth it, for two reasons: 1) plugins may not want to use the same verbiage that `vim.deprecate` uses (how many plugins use versions anyway?),That's true but I bet they end up using it :) It's nice to have a standard mechanism because:1. it nudges authors towards clear messaging. 2. it enables us to log and collect cases, so that we could start reporting this    - later enhancement to add ""passive"" deprecation, which only warns and/or increments a counterThe scope arg can be an optional last one, or we can make this a ""kwargs""-style function (probably should be, given the number of params). We can remove it later.Lua API does not have a contract, yet.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18357,863215295,2022-05-02T21:50:08Z,runtime/doc/ui.txt,"@@ -52,6 +52,11 @@ with these (optional) keys: 	`term_name`		Sets the name of the terminal 'term'. 	`term_colors`		Sets the number of supported colors 't_Co'. 	`term_background`	Sets the default value of 'background'.+	`stdin_fd`		Read buffer from `fd` as if it was a stdin pipe","would `ext_stdin` make sense as the name? Seems like it would, since it's similar to the other ""ext_"" options in that it is a UI shim.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18379,863246296,2022-05-02T22:58:14Z,runtime/lua/vim/lsp/log.lua,"@@ -117,7 +126,7 @@ end ---@param level number log level ---@returns (bool) true if would log, false if not function log.should_log(level)-  return level >= current_log_level+  return current_log_level ~= -1 and level >= current_log_level","to simplify the logic everywhere, make OFF a really big number. then we don't need the special cases everywhere?",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/18379,863280094,2022-05-03T00:34:38Z,runtime/lua/vim/lsp/log.lua,"@@ -31,21 +31,37 @@ do     return logfilename   end -  vim.fn.mkdir(vim.fn.stdpath('cache'), ""p"")-  local logfile = assert(io.open(logfilename, ""a+""))--  local log_info = vim.loop.fs_stat(logfilename)-  if log_info and log_info.size > 1e9 then-    local warn_msg = string.format(-      ""LSP client log is large (%d MB): %s"",-      log_info.size / (1000 * 1000),-      logfilename-    )-    vim.notify(warn_msg)+  local logfile, openerr+  ---@private+  --- Opens log file. Returns true if file is open, false on error+  local function open_logfile()+    -- Try to open file only once+    if logfile then return true end+    if openerr then return false end++    vim.fn.mkdir(vim.fn.stdpath('cache'), ""p"")",```Error executing luv callback:...hi/data/github/neovim/neovim/runtime/lua/vim/lsp/log.lua:42: E5560: vimL function must not be called in a lua loop callback```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18247,863328200,2022-05-03T02:17:38Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,452 @@+local M = {}++---@private+local function count_lines(bufnr)+  return vim.api.nvim_buf_line_count(bufnr)+end++---@private+local function get_lines(bufnr, start_lnum, end_lnum, opts)+  if not end_lnum then+    -- Return a single line as a string+    return vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, start_lnum, false)[1]+  end++  local lines = vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, end_lnum, false)+  opts = opts or {}+  return opts.concat and (table.concat(lines) or """") or lines+end++function M.asm(path, bufnr)++end++function M.asm_syntax(path, bufnr)++end++function M.bas(path, bufnr)++end++function M.bindzone(path, bufnr)++end++function M.btm(bufnr)+  if vim.g.dosbatch_syntax_for_btm and vim.g.dosbatch_syntax_for_btm ~= 0 then+    vim.bo[bufnr].filetype = ""dosbatch""+  else+    vim.bo[bufnr].filetype = ""btm""+  end+end++function M.cfg(path, bufnr)+  if vim.g.filetype_cfg then+    vim.bo[bufnr].filetype = vim.g.filetype_cfg+  elseif M.is_rapid(path, bufnr) then+    vim.bo[bufnr].filetype = ""rapid""+  else+    vim.bo[bufnr].filetype = ""cfg""+  end+end++function M.change(path, bufnr)++end++function M.csh(path, bufnr)++end++function M.dat(path, bufnr)++end++function M.dep3patch(path, bufnr)++end++function M.dtrace(path, bufnr)++end++function M.e(path, bufnr)++end++-- This function checks for valid cl syntax in the first five lines.+-- Look for either an opening comment, '#', or a block start, '{'.+-- If not found, assume SGML.+function M.ent(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 5)) do+    if line:find(""^%s*[#{]"") then+      vim.bo[bufnr].filetype = ""cl""+      return+    elseif not line:find(""^%s*$"") then+      -- Not a blank line, not a comment, and not a block start,+      -- so doesn't look like valid cl code.+      break+    end+  end+  vim.bo[bufnr].filetype = ""dtd""+end++function M.euphoria(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    vim.bo[bufnr].filetype = ""euphoria3""+  end+end++function M.ex(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    for _, line in ipairs(get_lines(bufnr, 1, 100)) do+    -- TODO: in the Vim regex, \> is used to match the end of the word, can this be omitted?+      if line:find(""^%-%-"") or line:find(""^ifdef"") or line:find(""^include"")  then+        vim.bo[bufnr].filetype = ""euphoria3""+        return+      end+    end+    vim.bo[bufnr].filetype = ""elixir""+  end+end++-- This function checks the first 15 lines for appearance of 'FoamFile'+-- and then 'object' in a following line.+-- In that case, it's probably an OpenFOAM file+function M.foam(bufnr)+  local foam_file = false+  for _, line in ipairs(get_lines(bufnr, 1, 15)) do+    if line:find(""^FoamFile"") then+      foam_file = true+    elseif foam_file and line:find(""^%s*object"") then+      vim.bo[bufnr].filetype = ""foam""+      return+    end+  end+end++function M.frm(bufnr)+  if vim.g.filetype_frm then+    vim.bo[bufnr].filetype = vim.g.filetype_frm+  else+    -- Always ignore case+    local lines = get_lines(bufnr, 1, 5, { concat = true }):lower()+    if lines:find(""vb_name"") or lines:find(""begin vb%.form"") or lines:find(""begin vb%.mdiform"") or lines:find(""begin vb%.usercontrol"") then+        vim.bo[bufnr].filetype = ""vb""+      else+        vim.bo[bufnr].filetype = ""form""+      end+  end+end++function M.fs(path, bufnr)++end++function M.header(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 200)) do+    if line:find(""^@interface"") or line:find(""^@end"") or line:find(""^@class"") then+      if vim.g.c_syntax_for_h then+        vim.bo[bufnr].filetype = ""objc""+      else+        vim.bo[bufnr].filetype = ""objcpp""+      end+      return+    end+  end+  if vim.g.c_syntax_for_h then+      vim.bo[bufnr].filetype = ""c""+  elseif vim.g.ch_syntax_for_h then+      vim.bo[bufnr].filetype = ""ch""+  else+      vim.bo[bufnr].filetype = ""cpp""+  end+end++function M.idl(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 50)) do+    -- Always ignore case+    line = line:lower()+    if line:find('^%s*import%s+""unknwn""%.idl') or line:find('^%s*import%s+""objidl""%.idl') then+      vim.bo[bufnr].filetype = ""msidl""+      return+    end+  end+  vim.bo[bufnr].filetype = ""idl""+end++function M.inc(path, bufnr)++end++function M.inp(bufnr)+  if get_lines(bufnr, 1):find(""^%*"") then+    vim.bo[bufnr].filetype = ""abaqus""+  else+    for _, line in ipairs(get_lines(bufnr, 1, 500)) do+      if line:find(""^header surface data"") then","`dist#ft#Check_inp()` uses `=~?````suggestion      if line:lower():find(""^header surface data"") then```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18247,863330815,2022-05-03T02:30:14Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,452 @@+local M = {}++---@private+local function count_lines(bufnr)+  return vim.api.nvim_buf_line_count(bufnr)+end++---@private+local function get_lines(bufnr, start_lnum, end_lnum, opts)+  if not end_lnum then+    -- Return a single line as a string+    return vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, start_lnum, false)[1]+  end++  local lines = vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, end_lnum, false)+  opts = opts or {}+  return opts.concat and (table.concat(lines) or """") or lines+end++function M.asm(path, bufnr)++end++function M.asm_syntax(path, bufnr)++end++function M.bas(path, bufnr)++end++function M.bindzone(path, bufnr)++end++function M.btm(bufnr)+  if vim.g.dosbatch_syntax_for_btm and vim.g.dosbatch_syntax_for_btm ~= 0 then+    vim.bo[bufnr].filetype = ""dosbatch""+  else+    vim.bo[bufnr].filetype = ""btm""+  end+end++function M.cfg(path, bufnr)+  if vim.g.filetype_cfg then+    vim.bo[bufnr].filetype = vim.g.filetype_cfg+  elseif M.is_rapid(path, bufnr) then+    vim.bo[bufnr].filetype = ""rapid""+  else+    vim.bo[bufnr].filetype = ""cfg""+  end+end++function M.change(path, bufnr)++end++function M.csh(path, bufnr)++end++function M.dat(path, bufnr)++end++function M.dep3patch(path, bufnr)++end++function M.dtrace(path, bufnr)++end++function M.e(path, bufnr)++end++-- This function checks for valid cl syntax in the first five lines.+-- Look for either an opening comment, '#', or a block start, '{'.+-- If not found, assume SGML.+function M.ent(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 5)) do+    if line:find(""^%s*[#{]"") then+      vim.bo[bufnr].filetype = ""cl""+      return+    elseif not line:find(""^%s*$"") then+      -- Not a blank line, not a comment, and not a block start,+      -- so doesn't look like valid cl code.+      break+    end+  end+  vim.bo[bufnr].filetype = ""dtd""+end++function M.euphoria(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    vim.bo[bufnr].filetype = ""euphoria3""+  end+end++function M.ex(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    for _, line in ipairs(get_lines(bufnr, 1, 100)) do+    -- TODO: in the Vim regex, \> is used to match the end of the word, can this be omitted?+      if line:find(""^%-%-"") or line:find(""^ifdef"") or line:find(""^include"")  then+        vim.bo[bufnr].filetype = ""euphoria3""+        return+      end+    end+    vim.bo[bufnr].filetype = ""elixir""+  end+end++-- This function checks the first 15 lines for appearance of 'FoamFile'+-- and then 'object' in a following line.+-- In that case, it's probably an OpenFOAM file+function M.foam(bufnr)+  local foam_file = false+  for _, line in ipairs(get_lines(bufnr, 1, 15)) do+    if line:find(""^FoamFile"") then+      foam_file = true+    elseif foam_file and line:find(""^%s*object"") then+      vim.bo[bufnr].filetype = ""foam""+      return+    end+  end+end++function M.frm(bufnr)+  if vim.g.filetype_frm then+    vim.bo[bufnr].filetype = vim.g.filetype_frm+  else+    -- Always ignore case+    local lines = get_lines(bufnr, 1, 5, { concat = true }):lower()+    if lines:find(""vb_name"") or lines:find(""begin vb%.form"") or lines:find(""begin vb%.mdiform"") or lines:find(""begin vb%.usercontrol"") then+        vim.bo[bufnr].filetype = ""vb""+      else+        vim.bo[bufnr].filetype = ""form""+      end+  end+end++function M.fs(path, bufnr)++end++function M.header(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 200)) do+    if line:find(""^@interface"") or line:find(""^@end"") or line:find(""^@class"") then+      if vim.g.c_syntax_for_h then+        vim.bo[bufnr].filetype = ""objc""+      else+        vim.bo[bufnr].filetype = ""objcpp""+      end+      return+    end+  end+  if vim.g.c_syntax_for_h then+      vim.bo[bufnr].filetype = ""c""+  elseif vim.g.ch_syntax_for_h then+      vim.bo[bufnr].filetype = ""ch""+  else+      vim.bo[bufnr].filetype = ""cpp""+  end+end++function M.idl(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 50)) do+    -- Always ignore case+    line = line:lower()+    if line:find('^%s*import%s+""unknwn""%.idl') or line:find('^%s*import%s+""objidl""%.idl') then+      vim.bo[bufnr].filetype = ""msidl""+      return+    end+  end+  vim.bo[bufnr].filetype = ""idl""+end++function M.inc(path, bufnr)++end++function M.inp(bufnr)+  if get_lines(bufnr, 1):find(""^%*"") then+    vim.bo[bufnr].filetype = ""abaqus""+  else+    for _, line in ipairs(get_lines(bufnr, 1, 500)) do+      if line:find(""^header surface data"") then+        vim.bo[bufnr].filetype = ""trasys""+        return+      end+    end+  end+end++function M.is_rapid(path, bufnr)++end++function M.lpc(path, bufnr)++end++function M.lprolog(path, bufnr)++end++function M.m(path, bufnr)++end++-- Rely on the file to start with a comment.+-- MS message text files use ';', Sendmail files use '#' or 'dnl'+function M.mc(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 20)) do+    if line:find(""^%s*#"") or line:find(""^%s*[dD][nN][lL]"") then+      -- Sendmail .mc file+      vim.bo[bufnr].filetype = ""m4""+      return+    elseif line:find(""^%s*;"") then+      vim.bo[bufnr].filetype = ""msmessages""+      return+    end+  end+  -- Default: Sendmail .mc file+  vim.bo[bufnr].filetype = ""m4""+end++function M.mm(path, bufnr)++end++function M.mms(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 20)) do+    if line:find(""^%s*%%"") or line:find(""^%s*//"") or line:find(""^%*"") then+      vim.bo[bufnr].filetype = ""mmix""+      return+    elseif line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""make""+      return+    end+  end+  vim.bo[bufnr].filetype = ""mmix""+end++function M.mod(path, bufnr)++end++-- This function checks if one of the first five lines start with a dot. In+-- that case it is probably an nroff file: 'filetype' is set and 1 is returned.+function M.nroff(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 5)) do+    if line:find(""^%."") then+      vim.bo[bufnr].filetype = ""nroff""+      return 1+    end+  end+  return 0+end++function M.perl(path, bufnr)++end++function M.pl(path, bufnr)++end++function M.pp(path, bufnr)++end++function M.prg(path, bufnr)++end++function M.progress_asm(path, bufnr)++end++function M.progress_cweb(bufnr)+  if vim.g.filetype_w then+    vim.bo[bufnr].filetype = vim.g.filetype_w+  else+    if get_lines(bufnr, 1) == ""&ANALYZE"" or get_lines(bufnr, 3) == ""&GLOBAL-DEFINE"" then+      vim.bo[bufnr].filetype = ""progress""+    else+      vim.bo[bufnr].filetype = ""cweb""+    end+  end+end++function M.progress_pascal(path, bufnr)++end++function M.proto(path, bufnr)++end++function M.r(bufnr)+  local lines = get_lines(bufnr, 1, 50)+  -- TODO: \< / \> which match the beginning / end of a word+  -- Rebol is easy to recognize, check for that first+  if table.concat(lines):find(""[rR][eE][bB][oO][lL]"") then+    vim.bo[bufnr].filetype = ""rebol""+    return+  end++  for _, line in ipairs(lines) do+    -- R has # comments+    if line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""r""+      return+    end+    -- Rexx has /* comments */+    if line:find(""^%s*/%*"") then+      vim.bo[bufnr].filetype = ""rexx""+      return+    end+  end++  -- Nothing recognized, use user default or assume R+  if vim.g.filetype_r then+    vim.bo[bufnr].filetype = vim.g.filetype_r+  else+    -- Rexx used to be the default, but R appears to be much more popular.+    vim.bo[bufnr].filetype = ""r""+  end+end++function M.redif(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 5)) do+    -- TODO: maybe this is too expensive because a new string is created, any thoughts?+    -- However, it seems much more readable to me than ""^[tT][eE]...""+    if line:lower():find(""^template%-type:"") then+      vim.bo[bufnr].filetype = ""redif""+    end+  end+end++function M.rules(path, bufnr)++end++-- This function checks the first 25 lines of file extension ""sc"" to resolve+-- detection between scala and SuperCollider+function M.sc(bufnr)+  -- TODO: it still needs to be discussed if it's ok to use vim.regex in some cases+  local regex = vim.regex([[[A-Za-z0-9]*\s:\s[A-Za-z0-9]\|var\s<\|classvar\s<\|\^this.*\||\w*|\|+\s\w*\s{\|\*ar\s]])","Do we need regex for this?```lualine:find(""[A-Za-z0-9]*%s:%s[A-Za-z0-9]"") or line:find(""var%s<"") or line:find(""classvar%s<"") or line:find(""^this.*"") or line:find(""|%w*|"") or line:find(""%+%s%w*%s{"") or line:find(""%*ar%s"")```It may be handy to define a helper function for these kinds of patterns. Something like```lualocal function findany(s, pats)    for _, v in ipairs(pats) do        if s:find(v) then            return true        end    end    return falseend```and used like```luafindany(line, {""[A-Za-z0-9]*%s:%s[A-Za-z0-9]"", ""var%s<"", ""classvar%s<"", ""^this.*"", ""|%w*|"", ""%+%s%w*%s{"", ""%*ar%s""})```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18247,863331912,2022-05-03T02:36:10Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,452 @@+local M = {}++---@private+local function count_lines(bufnr)+  return vim.api.nvim_buf_line_count(bufnr)+end++---@private+local function get_lines(bufnr, start_lnum, end_lnum, opts)+  if not end_lnum then+    -- Return a single line as a string+    return vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, start_lnum, false)[1]+  end++  local lines = vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, end_lnum, false)+  opts = opts or {}+  return opts.concat and (table.concat(lines) or """") or lines+end++function M.asm(path, bufnr)++end++function M.asm_syntax(path, bufnr)++end++function M.bas(path, bufnr)++end++function M.bindzone(path, bufnr)++end++function M.btm(bufnr)+  if vim.g.dosbatch_syntax_for_btm and vim.g.dosbatch_syntax_for_btm ~= 0 then+    vim.bo[bufnr].filetype = ""dosbatch""+  else+    vim.bo[bufnr].filetype = ""btm""+  end+end++function M.cfg(path, bufnr)+  if vim.g.filetype_cfg then+    vim.bo[bufnr].filetype = vim.g.filetype_cfg+  elseif M.is_rapid(path, bufnr) then+    vim.bo[bufnr].filetype = ""rapid""+  else+    vim.bo[bufnr].filetype = ""cfg""+  end+end++function M.change(path, bufnr)++end++function M.csh(path, bufnr)++end++function M.dat(path, bufnr)++end++function M.dep3patch(path, bufnr)++end++function M.dtrace(path, bufnr)++end++function M.e(path, bufnr)++end++-- This function checks for valid cl syntax in the first five lines.+-- Look for either an opening comment, '#', or a block start, '{'.+-- If not found, assume SGML.+function M.ent(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 5)) do+    if line:find(""^%s*[#{]"") then+      vim.bo[bufnr].filetype = ""cl""+      return+    elseif not line:find(""^%s*$"") then+      -- Not a blank line, not a comment, and not a block start,+      -- so doesn't look like valid cl code.+      break+    end+  end+  vim.bo[bufnr].filetype = ""dtd""+end++function M.euphoria(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    vim.bo[bufnr].filetype = ""euphoria3""+  end+end++function M.ex(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    for _, line in ipairs(get_lines(bufnr, 1, 100)) do+    -- TODO: in the Vim regex, \> is used to match the end of the word, can this be omitted?+      if line:find(""^%-%-"") or line:find(""^ifdef"") or line:find(""^include"")  then+        vim.bo[bufnr].filetype = ""euphoria3""+        return+      end+    end+    vim.bo[bufnr].filetype = ""elixir""+  end+end++-- This function checks the first 15 lines for appearance of 'FoamFile'+-- and then 'object' in a following line.+-- In that case, it's probably an OpenFOAM file+function M.foam(bufnr)+  local foam_file = false+  for _, line in ipairs(get_lines(bufnr, 1, 15)) do+    if line:find(""^FoamFile"") then+      foam_file = true+    elseif foam_file and line:find(""^%s*object"") then+      vim.bo[bufnr].filetype = ""foam""+      return+    end+  end+end++function M.frm(bufnr)+  if vim.g.filetype_frm then+    vim.bo[bufnr].filetype = vim.g.filetype_frm+  else+    -- Always ignore case+    local lines = get_lines(bufnr, 1, 5, { concat = true }):lower()+    if lines:find(""vb_name"") or lines:find(""begin vb%.form"") or lines:find(""begin vb%.mdiform"") or lines:find(""begin vb%.usercontrol"") then+        vim.bo[bufnr].filetype = ""vb""+      else+        vim.bo[bufnr].filetype = ""form""+      end+  end+end++function M.fs(path, bufnr)++end++function M.header(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 200)) do+    if line:find(""^@interface"") or line:find(""^@end"") or line:find(""^@class"") then+      if vim.g.c_syntax_for_h then+        vim.bo[bufnr].filetype = ""objc""+      else+        vim.bo[bufnr].filetype = ""objcpp""+      end+      return+    end+  end+  if vim.g.c_syntax_for_h then+      vim.bo[bufnr].filetype = ""c""+  elseif vim.g.ch_syntax_for_h then+      vim.bo[bufnr].filetype = ""ch""+  else+      vim.bo[bufnr].filetype = ""cpp""+  end+end++function M.idl(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 50)) do+    -- Always ignore case+    line = line:lower()+    if line:find('^%s*import%s+""unknwn""%.idl') or line:find('^%s*import%s+""objidl""%.idl') then+      vim.bo[bufnr].filetype = ""msidl""+      return+    end+  end+  vim.bo[bufnr].filetype = ""idl""+end++function M.inc(path, bufnr)++end++function M.inp(bufnr)+  if get_lines(bufnr, 1):find(""^%*"") then+    vim.bo[bufnr].filetype = ""abaqus""+  else+    for _, line in ipairs(get_lines(bufnr, 1, 500)) do+      if line:find(""^header surface data"") then+        vim.bo[bufnr].filetype = ""trasys""+        return+      end+    end+  end+end++function M.is_rapid(path, bufnr)++end++function M.lpc(path, bufnr)++end++function M.lprolog(path, bufnr)++end++function M.m(path, bufnr)++end++-- Rely on the file to start with a comment.+-- MS message text files use ';', Sendmail files use '#' or 'dnl'+function M.mc(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 20)) do+    if line:find(""^%s*#"") or line:find(""^%s*[dD][nN][lL]"") then+      -- Sendmail .mc file+      vim.bo[bufnr].filetype = ""m4""+      return+    elseif line:find(""^%s*;"") then+      vim.bo[bufnr].filetype = ""msmessages""+      return+    end+  end+  -- Default: Sendmail .mc file+  vim.bo[bufnr].filetype = ""m4""+end++function M.mm(path, bufnr)++end++function M.mms(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 20)) do+    if line:find(""^%s*%%"") or line:find(""^%s*//"") or line:find(""^%*"") then+      vim.bo[bufnr].filetype = ""mmix""+      return+    elseif line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""make""+      return+    end+  end+  vim.bo[bufnr].filetype = ""mmix""+end++function M.mod(path, bufnr)++end++-- This function checks if one of the first five lines start with a dot. In+-- that case it is probably an nroff file: 'filetype' is set and 1 is returned.+function M.nroff(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 5)) do+    if line:find(""^%."") then+      vim.bo[bufnr].filetype = ""nroff""+      return 1+    end+  end+  return 0+end++function M.perl(path, bufnr)++end++function M.pl(path, bufnr)++end++function M.pp(path, bufnr)++end++function M.prg(path, bufnr)++end++function M.progress_asm(path, bufnr)++end++function M.progress_cweb(bufnr)+  if vim.g.filetype_w then+    vim.bo[bufnr].filetype = vim.g.filetype_w+  else+    if get_lines(bufnr, 1) == ""&ANALYZE"" or get_lines(bufnr, 3) == ""&GLOBAL-DEFINE"" then+      vim.bo[bufnr].filetype = ""progress""+    else+      vim.bo[bufnr].filetype = ""cweb""+    end+  end+end++function M.progress_pascal(path, bufnr)++end++function M.proto(path, bufnr)++end++function M.r(bufnr)+  local lines = get_lines(bufnr, 1, 50)+  -- TODO: \< / \> which match the beginning / end of a word+  -- Rebol is easy to recognize, check for that first+  if table.concat(lines):find(""[rR][eE][bB][oO][lL]"") then+    vim.bo[bufnr].filetype = ""rebol""+    return+  end++  for _, line in ipairs(lines) do+    -- R has # comments+    if line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""r""+      return+    end+    -- Rexx has /* comments */+    if line:find(""^%s*/%*"") then+      vim.bo[bufnr].filetype = ""rexx""+      return+    end+  end++  -- Nothing recognized, use user default or assume R+  if vim.g.filetype_r then+    vim.bo[bufnr].filetype = vim.g.filetype_r+  else+    -- Rexx used to be the default, but R appears to be much more popular.+    vim.bo[bufnr].filetype = ""r""+  end+end++function M.redif(bufnr)+  for _, line in ipairs(get_lines(bufnr, 1, 5)) do+    -- TODO: maybe this is too expensive because a new string is created, any thoughts?+    -- However, it seems much more readable to me than ""^[tT][eE]...""+    if line:lower():find(""^template%-type:"") then+      vim.bo[bufnr].filetype = ""redif""+    end+  end+end++function M.rules(path, bufnr)++end++-- This function checks the first 25 lines of file extension ""sc"" to resolve+-- detection between scala and SuperCollider+function M.sc(bufnr)+  -- TODO: it still needs to be discussed if it's ok to use vim.regex in some cases+  local regex = vim.regex([[[A-Za-z0-9]*\s:\s[A-Za-z0-9]\|var\s<\|classvar\s<\|\^this.*\||\w*|\|+\s\w*\s{\|\*ar\s]])+  for _, line in ipairs(get_lines(bufnr, 1, 25)) do+    if regex:match_str(line) then+      vim.bo[bufnr].filetype = ""supercollider""+      return+    end+  end+  vim.bo[bufnr].filetype = ""scala""+end++-- This function checks the first line of file extension ""scd"" to resolve+-- detection between scdoc and SuperCollider+function M.scd(bufnr)+  -- TODO: it still needs to be discussed if it's ok to use vim.regex in some cases+  local regex = vim.regex([[\%^\S\+(\d[0-9A-Za-z]*)\%(\s\+\""[^""]*\""\%(\s\+\""[^""]*\""\)\=\)\=$]])","This one's a bit ugly with Lua patterns as we have to repeat ourselves a few times, but it's technically possible.```lualocal first = ""^%S+%(%d[0-9A-Za-z]*%)""local opt = [[%s+""[^""]*""]]line:find(first .. ""$"") or line:find(first .. opt .. ""$"") or line:find(first .. opt .. opt .. ""$"")```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18247,863886121,2022-05-03T15:11:00Z,runtime/lua/vim/filetype/detect.lua,"@@ -43,10 +43,27 @@ function M.btm(bufnr)   end end -function M.cfg(path, bufnr)+-- Returns true if file content looks like RAPID+local function is_rapid(bufnr, extension)+  if extension == ""cfg"" then+    local line = getlines(bufnr, 1):lower()+    return findany(line, { ""eio:cfg"", ""mmc:cfg"", ""moc:cfg"", ""proc:cfg"", ""sio:cfg"", ""sys:cfg"" })+  end+  local first = ""^%s*module%s+%S+%s*""","This is tricky. `\k` might be too difficult to translate into pure Lua (*especially* because it is dependent on a user option), so this may be a case where `vim.regex` is warranted.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18247,863936635,2022-05-03T16:02:43Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,417 @@+local M = {}++---@private+local function countlines(bufnr)+  return vim.api.nvim_buf_line_count(bufnr)+end++---@private+local function getlines(bufnr, start_lnum, end_lnum, opts)+  if not end_lnum then+    -- Return a single line as a string+    return vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, start_lnum, false)[1]+  end++  local lines = vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, end_lnum, false)+  opts = opts or {}+  return opts.concat and (table.concat(lines) or """") or lines+end++---@private+local function findany(s, patterns)+  for _, v in ipairs(patterns) do+    if s:find(v) then+      return true+    end+  end+  return false+end++function M.asm(path, bufnr) end++function M.asm_syntax(path, bufnr) end++function M.bas(path, bufnr) end++function M.bindzone(path, bufnr) end++function M.btm(bufnr)+  if vim.g.dosbatch_syntax_for_btm and vim.g.dosbatch_syntax_for_btm ~= 0 then+    vim.bo[bufnr].filetype = ""dosbatch""+  else+    vim.bo[bufnr].filetype = ""btm""+  end+end++-- Returns true if file content looks like RAPID+local function is_rapid(bufnr, extension)+  if extension == ""cfg"" then+    local line = getlines(bufnr, 1):lower()+    return findany(line, { ""eio:cfg"", ""mmc:cfg"", ""moc:cfg"", ""proc:cfg"", ""sio:cfg"", ""sys:cfg"" })+  end+  local first = ""^%s*module%s+%S+%s*""+  -- Called from mod, prg or sys functions+  for _, line in ipairs(getlines(bufnr, 1, -1)) do+    if not line:find(""^%s*$"") then+      return findany(line:lower(), { ""^%s*%%%%%%"", first .. ""("", first .. ""$"" })+    end+  end+  -- Only found blank lines+  return false+end++function M.cfg(bufnr)+  if vim.g.filetype_cfg then+    vim.bo[bufnr].filetype = vim.g.filetype_cfg+  elseif is_rapid(bufnr, ""cfg"") then+    vim.bo[bufnr].filetype = ""rapid""+  else+    vim.bo[bufnr].filetype = ""cfg""+  end+end++function M.change(path, bufnr) end++function M.csh(path, bufnr) end++function M.dat(path, bufnr) end++function M.dep3patch(path, bufnr) end++function M.dtrace(path, bufnr) end++function M.e(path, bufnr) end++-- This function checks for valid cl syntax in the first five lines.+-- Look for either an opening comment, '#', or a block start, '{'.+-- If not found, assume SGML.+function M.ent(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:find(""^%s*[#{]"") then+      vim.bo[bufnr].filetype = ""cl""+      return+    elseif not line:find(""^%s*$"") then+      -- Not a blank line, not a comment, and not a block start,+      -- so doesn't look like valid cl code.+      break+    end+  end+  vim.bo[bufnr].filetype = ""dtd""+end++function M.euphoria(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    vim.bo[bufnr].filetype = ""euphoria3""+  end+end++function M.ex(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    for _, line in ipairs(getlines(bufnr, 1, 100)) do+      -- TODO: in the Vim regex, \> is used to match the end of the word, can this be omitted?+      if findany(line, { ""^%-%-"", ""^ifdef"", ""^include"" }) then+        vim.bo[bufnr].filetype = ""euphoria3""+        return+      end+    end+    vim.bo[bufnr].filetype = ""elixir""+  end+end++-- This function checks the first 15 lines for appearance of 'FoamFile'+-- and then 'object' in a following line.+-- In that case, it's probably an OpenFOAM file+function M.foam(bufnr)+  local foam_file = false+  for _, line in ipairs(getlines(bufnr, 1, 15)) do+    if line:find(""^FoamFile"") then+      foam_file = true+    elseif foam_file and line:find(""^%s*object"") then+      vim.bo[bufnr].filetype = ""foam""+      return+    end+  end+end++function M.frm(bufnr)+  if vim.g.filetype_frm then+    vim.bo[bufnr].filetype = vim.g.filetype_frm+  else+    -- Always ignore case+    local lines = getlines(bufnr, 1, 5, { concat = true }):lower()+    if findany(lines, { ""vb_name"", ""begin vb%.form"", ""begin vb%.mdiform"" }) then+      vim.bo[bufnr].filetype = ""vb""+    else+      vim.bo[bufnr].filetype = ""form""+    end+  end+end++function M.fs(path, bufnr) end++function M.header(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 200)) do+    if findany(line, { ""^@interface"", ""^@end"", ""^@class"" }) then+      if vim.g.c_syntax_for_h then+        vim.bo[bufnr].filetype = ""objc""+      else+        vim.bo[bufnr].filetype = ""objcpp""+      end+      return+    end+  end+  if vim.g.c_syntax_for_h then+    vim.bo[bufnr].filetype = ""c""+  elseif vim.g.ch_syntax_for_h then+    vim.bo[bufnr].filetype = ""ch""+  else+    vim.bo[bufnr].filetype = ""cpp""+  end+end++function M.idl(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 50)) do+    -- Always ignore case+    line = line:lower()+    if findany(line, { '^%s*import%s+""unknwn""%.idl', '^%s*import%s+""objidl""%.idl' }) then+      vim.bo[bufnr].filetype = ""msidl""+      return+    end+  end+  vim.bo[bufnr].filetype = ""idl""+end++function M.inc(path, bufnr) end++function M.inp(bufnr)+  if getlines(bufnr, 1):find(""^%*"") then+    vim.bo[bufnr].filetype = ""abaqus""+  else+    for _, line in ipairs(getlines(bufnr, 1, 500)) do+      if line:lower():find(""^header surface data"") then+        vim.bo[bufnr].filetype = ""trasys""+        return+      end+    end+  end+end++function M.lpc(path, bufnr) end++function M.lprolog(path, bufnr) end++function M.m(path, bufnr) end++-- Rely on the file to start with a comment.+-- MS message text files use ';', Sendmail files use '#' or 'dnl'+function M.mc(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 20)) do+    if findany(line:lower(), { ""^%s*#"", ""^%s*dnl"" }) then+      -- Sendmail .mc file+      vim.bo[bufnr].filetype = ""m4""+      return+    elseif line:find(""^%s*;"") then+      vim.bo[bufnr].filetype = ""msmessages""+      return+    end+  end+  -- Default: Sendmail .mc file+  vim.bo[bufnr].filetype = ""m4""+end++function M.mm(path, bufnr) end++function M.mms(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 20)) do+    if findany(line, { ""^%s*%%"", ""^%s*//"", ""^%*"" }) then+      vim.bo[bufnr].filetype = ""mmix""+      return+    elseif line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""make""+      return+    end+  end+  vim.bo[bufnr].filetype = ""mmix""+end++function M.mod(path, bufnr) end++-- This function checks if one of the first five lines start with a dot. In+-- that case it is probably an nroff file: 'filetype' is set and 1 is returned.+function M.nroff(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:find(""^%."") then+      vim.bo[bufnr].filetype = ""nroff""+      return 1+    end+  end+  return 0+end++function M.perl(path, bufnr) end++function M.pl(path, bufnr) end++function M.pp(path, bufnr) end++function M.prg(path, bufnr) end++function M.progress_asm(path, bufnr) end++function M.progress_cweb(bufnr)+  if vim.g.filetype_w then+    vim.bo[bufnr].filetype = vim.g.filetype_w+  else+    if getlines(bufnr, 1):find(""^&ANALYZE"") or getlines(bufnr, 3):find(""^&GLOBAL%-DEFINE"") then+      vim.bo[bufnr].filetype = ""progress""+    else+      vim.bo[bufnr].filetype = ""cweb""+    end+  end+end++function M.progress_pascal(path, bufnr) end++function M.proto(path, bufnr) end++function M.r(bufnr)+  local lines = getlines(bufnr, 1, 50)+  -- TODO: \< / \> which match the beginning / end of a word+  -- Rebol is easy to recognize, check for that first+  if table.concat(lines):lower():find(""rebol"") then+    vim.bo[bufnr].filetype = ""rebol""+    return+  end++  for _, line in ipairs(lines) do+    -- R has # comments+    if line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""r""+      return+    end+    -- Rexx has /* comments */+    if line:find(""^%s*/%*"") then+      vim.bo[bufnr].filetype = ""rexx""+      return+    end+  end++  -- Nothing recognized, use user default or assume R+  if vim.g.filetype_r then+    vim.bo[bufnr].filetype = vim.g.filetype_r+  else+    -- Rexx used to be the default, but R appears to be much more popular.+    vim.bo[bufnr].filetype = ""r""+  end+end++function M.redif(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:lower():find(""^template%-type:"") then+      vim.bo[bufnr].filetype = ""redif""+    end+  end+end++function M.rules(path, bufnr) end++-- This function checks the first 25 lines of file extension ""sc"" to resolve+-- detection between scala and SuperCollider+function M.sc(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 25)) do+    if+      findany(+        line,+        { ""[A-Za-z0-9]*%s:%s[A-Za-z0-9]"", ""var%s<"", ""classvar%s<"", ""^this.*"", ""|%w*|"", ""%+%s%w*%s{"", ""%*ar%s"" }",Test indicates that something here is not equivalent to the vim version; it's failing to recognize```// Query//Method^this {```as `supercollider`I think this is meant to be a _literal_ `^`? Note the `\^` in https://github.com/neovim/neovim/blob/4df11463b288a227a7052b7fd9c0a3f737a51c1e/runtime/autoload/dist/ft.vim#L780,
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18247,864034062,2022-05-03T17:47:22Z,runtime/lua/vim/filetype/detect.lua,"@@ -409,4 +407,7 @@ function M.y(bufnr)   vim.bo[bufnr].filetype = ""yacc"" end +-- luacheck: pop",Not sure if push / pop is necessary or if```-- luacheck: no unused args-- luacheck: ignore 122```would be enough.,
10258296,ranjithshegde,https://api.github.com/repos/neovim/neovim/pulls/18247,864225952,2022-05-03T20:40:12Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,413 @@+local M = {}++---@private+local function getlines(bufnr, start_lnum, end_lnum, opts)+  if not end_lnum then+    -- Return a single line as a string+    return vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, start_lnum, false)[1]+  end++  local lines = vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, end_lnum, false)+  opts = opts or {}+  return opts.concat and (table.concat(lines) or """") or lines+end++---@private+local function findany(s, patterns)+  for _, v in ipairs(patterns) do+    if s:find(v) then+      return true+    end+  end+  return false+end++-- luacheck: push no unused args+-- luacheck: push ignore 122++function M.asm(path, bufnr) end++function M.asm_syntax(path, bufnr) end++function M.bas(path, bufnr) end++function M.bindzone(path, bufnr) end++function M.btm(bufnr)+  if vim.g.dosbatch_syntax_for_btm and vim.g.dosbatch_syntax_for_btm ~= 0 then+    vim.bo[bufnr].filetype = ""dosbatch""+  else+    vim.bo[bufnr].filetype = ""btm""+  end+end++-- Returns true if file content looks like RAPID+local function is_rapid(bufnr, extension)+  if extension == ""cfg"" then+    local line = getlines(bufnr, 1):lower()+    return findany(line, { ""eio:cfg"", ""mmc:cfg"", ""moc:cfg"", ""proc:cfg"", ""sio:cfg"", ""sys:cfg"" })+  end+  local first = ""^%s*module%s+%S+%s*""+  -- Called from mod, prg or sys functions+  for _, line in ipairs(getlines(bufnr, 1, -1)) do+    if not line:find(""^%s*$"") then+      return findany(line:lower(), { ""^%s*%%%%%%"", first .. ""("", first .. ""$"" })+    end+  end+  -- Only found blank lines+  return false+end++function M.cfg(bufnr)+  if vim.g.filetype_cfg then+    vim.bo[bufnr].filetype = vim.g.filetype_cfg+  elseif is_rapid(bufnr, ""cfg"") then+    vim.bo[bufnr].filetype = ""rapid""+  else+    vim.bo[bufnr].filetype = ""cfg""+  end+end++function M.change(path, bufnr) end++function M.csh(path, bufnr) end++function M.dat(path, bufnr) end++function M.dep3patch(path, bufnr) end++function M.dtrace(path, bufnr) end++function M.e(path, bufnr) end++-- This function checks for valid cl syntax in the first five lines.+-- Look for either an opening comment, '#', or a block start, '{'.+-- If not found, assume SGML.+function M.ent(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:find(""^%s*[#{]"") then+      vim.bo[bufnr].filetype = ""cl""+      return+    elseif not line:find(""^%s*$"") then+      -- Not a blank line, not a comment, and not a block start,+      -- so doesn't look like valid cl code.+      break+    end+  end+  vim.bo[bufnr].filetype = ""dtd""+end++function M.euphoria(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    vim.bo[bufnr].filetype = ""euphoria3""+  end+end++function M.ex(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    for _, line in ipairs(getlines(bufnr, 1, 100)) do+      -- TODO: in the Vim regex, \> is used to match the end of the word, can this be omitted?+      if findany(line, { ""^%-%-"", ""^ifdef"", ""^include"" }) then+        vim.bo[bufnr].filetype = ""euphoria3""+        return+      end+    end+    vim.bo[bufnr].filetype = ""elixir""+  end+end++-- This function checks the first 15 lines for appearance of 'FoamFile'+-- and then 'object' in a following line.+-- In that case, it's probably an OpenFOAM file+function M.foam(bufnr)+  local foam_file = false+  for _, line in ipairs(getlines(bufnr, 1, 15)) do+    if line:find(""^FoamFile"") then+      foam_file = true+    elseif foam_file and line:find(""^%s*object"") then+      vim.bo[bufnr].filetype = ""foam""+      return+    end+  end+end++function M.frm(bufnr)+  if vim.g.filetype_frm then+    vim.bo[bufnr].filetype = vim.g.filetype_frm+  else+    -- Always ignore case+    local lines = getlines(bufnr, 1, 5, { concat = true }):lower()+    if findany(lines, { ""vb_name"", ""begin vb%.form"", ""begin vb%.mdiform"" }) then+      vim.bo[bufnr].filetype = ""vb""+    else+      vim.bo[bufnr].filetype = ""form""+    end+  end+end++function M.fs(path, bufnr) end++function M.header(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 200)) do+    if findany(line, { ""^@interface"", ""^@end"", ""^@class"" }) then+      if vim.g.c_syntax_for_h then+        vim.bo[bufnr].filetype = ""objc""+      else+        vim.bo[bufnr].filetype = ""objcpp""+      end+      return+    end+  end+  if vim.g.c_syntax_for_h then+    vim.bo[bufnr].filetype = ""c""+  elseif vim.g.ch_syntax_for_h then+    vim.bo[bufnr].filetype = ""ch""+  else+    vim.bo[bufnr].filetype = ""cpp""+  end+end++function M.idl(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 50)) do+    -- Always ignore case+    line = line:lower()+    if findany(line, { '^%s*import%s+""unknwn""%.idl', '^%s*import%s+""objidl""%.idl' }) then+      vim.bo[bufnr].filetype = ""msidl""+      return+    end+  end+  vim.bo[bufnr].filetype = ""idl""+end++function M.inc(path, bufnr) end++function M.inp(bufnr)+  if getlines(bufnr, 1):find(""^%*"") then+    vim.bo[bufnr].filetype = ""abaqus""+  else+    for _, line in ipairs(getlines(bufnr, 1, 500)) do+      if line:lower():find(""^header surface data"") then+        vim.bo[bufnr].filetype = ""trasys""+        return+      end+    end+  end+end++function M.lpc(path, bufnr) end++function M.lprolog(path, bufnr) end++function M.m(path, bufnr) end++-- Rely on the file to start with a comment.+-- MS message text files use ';', Sendmail files use '#' or 'dnl'+function M.mc(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 20)) do+    if findany(line:lower(), { ""^%s*#"", ""^%s*dnl"" }) then+      -- Sendmail .mc file+      vim.bo[bufnr].filetype = ""m4""+      return+    elseif line:find(""^%s*;"") then+      vim.bo[bufnr].filetype = ""msmessages""+      return+    end+  end+  -- Default: Sendmail .mc file+  vim.bo[bufnr].filetype = ""m4""+end++function M.mm(path, bufnr) end++function M.mms(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 20)) do+    if findany(line, { ""^%s*%%"", ""^%s*//"", ""^%*"" }) then+      vim.bo[bufnr].filetype = ""mmix""+      return+    elseif line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""make""+      return+    end+  end+  vim.bo[bufnr].filetype = ""mmix""+end++function M.mod(path, bufnr) end++-- This function checks if one of the first five lines start with a dot. In+-- that case it is probably an nroff file: 'filetype' is set and 1 is returned.+function M.nroff(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:find(""^%."") then+      vim.bo[bufnr].filetype = ""nroff""+      return 1+    end+  end+  return 0+end++function M.perl(path, bufnr) end++function M.pl(path, bufnr) end++function M.pp(path, bufnr) end++function M.prg(path, bufnr) end++function M.progress_asm(path, bufnr) end++function M.progress_cweb(bufnr)+  if vim.g.filetype_w then+    vim.bo[bufnr].filetype = vim.g.filetype_w+  else+    if getlines(bufnr, 1):find(""^&ANALYZE"") or getlines(bufnr, 3):find(""^&GLOBAL%-DEFINE"") then+      vim.bo[bufnr].filetype = ""progress""+    else+      vim.bo[bufnr].filetype = ""cweb""+    end+  end+end++function M.progress_pascal(path, bufnr) end++function M.proto(path, bufnr) end++function M.r(bufnr)+  local lines = getlines(bufnr, 1, 50)+  -- TODO: \< / \> which match the beginning / end of a word+  -- Rebol is easy to recognize, check for that first+  if table.concat(lines):lower():find(""rebol"") then+    vim.bo[bufnr].filetype = ""rebol""+    return+  end++  for _, line in ipairs(lines) do+    -- R has # comments+    if line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""r""+      return+    end+    -- Rexx has /* comments */+    if line:find(""^%s*/%*"") then+      vim.bo[bufnr].filetype = ""rexx""+      return+    end+  end++  -- Nothing recognized, use user default or assume R+  if vim.g.filetype_r then+    vim.bo[bufnr].filetype = vim.g.filetype_r+  else+    -- Rexx used to be the default, but R appears to be much more popular.+    vim.bo[bufnr].filetype = ""r""+  end+end++function M.redif(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:lower():find(""^template%-type:"") then+      vim.bo[bufnr].filetype = ""redif""+    end+  end+end++function M.rules(path, bufnr) end++-- This function checks the first 25 lines of file extension ""sc"" to resolve+-- detection between scala and SuperCollider+function M.sc(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 25)) do+    if findany(line, { ""[A-Za-z0-9]*%s:%s[A-Za-z0-9]"", ""var%s<"", ""classvar%s<"", ""%^this.*"", ""|%w*|"", ""%+%s%w*%s{"", ""%*ar%s"" }) then+      vim.bo[bufnr].filetype = ""supercollider""+      return+    end+  end+  vim.bo[bufnr].filetype = ""scala""+end++-- This function checks the first line of file extension ""scd"" to resolve+-- detection between scdoc and SuperCollider+function M.scd(bufnr)","For some reason it always defaults to scdoc even if the pattern is not a match or a blank file. never sets ""supercollider""Will reproduce with minimal init.lua and file an issue",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18247,864233295,2022-05-03T20:43:10Z,runtime/lua/vim/filetype/detect.lua,"@@ -0,0 +1,413 @@+local M = {}++---@private+local function getlines(bufnr, start_lnum, end_lnum, opts)+  if not end_lnum then+    -- Return a single line as a string+    return vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, start_lnum, false)[1]+  end++  local lines = vim.api.nvim_buf_get_lines(bufnr, start_lnum - 1, end_lnum, false)+  opts = opts or {}+  return opts.concat and (table.concat(lines) or """") or lines+end++---@private+local function findany(s, patterns)+  for _, v in ipairs(patterns) do+    if s:find(v) then+      return true+    end+  end+  return false+end++-- luacheck: push no unused args+-- luacheck: push ignore 122++function M.asm(path, bufnr) end++function M.asm_syntax(path, bufnr) end++function M.bas(path, bufnr) end++function M.bindzone(path, bufnr) end++function M.btm(bufnr)+  if vim.g.dosbatch_syntax_for_btm and vim.g.dosbatch_syntax_for_btm ~= 0 then+    vim.bo[bufnr].filetype = ""dosbatch""+  else+    vim.bo[bufnr].filetype = ""btm""+  end+end++-- Returns true if file content looks like RAPID+local function is_rapid(bufnr, extension)+  if extension == ""cfg"" then+    local line = getlines(bufnr, 1):lower()+    return findany(line, { ""eio:cfg"", ""mmc:cfg"", ""moc:cfg"", ""proc:cfg"", ""sio:cfg"", ""sys:cfg"" })+  end+  local first = ""^%s*module%s+%S+%s*""+  -- Called from mod, prg or sys functions+  for _, line in ipairs(getlines(bufnr, 1, -1)) do+    if not line:find(""^%s*$"") then+      return findany(line:lower(), { ""^%s*%%%%%%"", first .. ""("", first .. ""$"" })+    end+  end+  -- Only found blank lines+  return false+end++function M.cfg(bufnr)+  if vim.g.filetype_cfg then+    vim.bo[bufnr].filetype = vim.g.filetype_cfg+  elseif is_rapid(bufnr, ""cfg"") then+    vim.bo[bufnr].filetype = ""rapid""+  else+    vim.bo[bufnr].filetype = ""cfg""+  end+end++function M.change(path, bufnr) end++function M.csh(path, bufnr) end++function M.dat(path, bufnr) end++function M.dep3patch(path, bufnr) end++function M.dtrace(path, bufnr) end++function M.e(path, bufnr) end++-- This function checks for valid cl syntax in the first five lines.+-- Look for either an opening comment, '#', or a block start, '{'.+-- If not found, assume SGML.+function M.ent(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:find(""^%s*[#{]"") then+      vim.bo[bufnr].filetype = ""cl""+      return+    elseif not line:find(""^%s*$"") then+      -- Not a blank line, not a comment, and not a block start,+      -- so doesn't look like valid cl code.+      break+    end+  end+  vim.bo[bufnr].filetype = ""dtd""+end++function M.euphoria(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    vim.bo[bufnr].filetype = ""euphoria3""+  end+end++function M.ex(bufnr)+  if vim.g.filetype_euphoria then+    vim.bo[bufnr].filetype = vim.g.filetype_euphoria+  else+    for _, line in ipairs(getlines(bufnr, 1, 100)) do+      -- TODO: in the Vim regex, \> is used to match the end of the word, can this be omitted?+      if findany(line, { ""^%-%-"", ""^ifdef"", ""^include"" }) then+        vim.bo[bufnr].filetype = ""euphoria3""+        return+      end+    end+    vim.bo[bufnr].filetype = ""elixir""+  end+end++-- This function checks the first 15 lines for appearance of 'FoamFile'+-- and then 'object' in a following line.+-- In that case, it's probably an OpenFOAM file+function M.foam(bufnr)+  local foam_file = false+  for _, line in ipairs(getlines(bufnr, 1, 15)) do+    if line:find(""^FoamFile"") then+      foam_file = true+    elseif foam_file and line:find(""^%s*object"") then+      vim.bo[bufnr].filetype = ""foam""+      return+    end+  end+end++function M.frm(bufnr)+  if vim.g.filetype_frm then+    vim.bo[bufnr].filetype = vim.g.filetype_frm+  else+    -- Always ignore case+    local lines = getlines(bufnr, 1, 5, { concat = true }):lower()+    if findany(lines, { ""vb_name"", ""begin vb%.form"", ""begin vb%.mdiform"" }) then+      vim.bo[bufnr].filetype = ""vb""+    else+      vim.bo[bufnr].filetype = ""form""+    end+  end+end++function M.fs(path, bufnr) end++function M.header(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 200)) do+    if findany(line, { ""^@interface"", ""^@end"", ""^@class"" }) then+      if vim.g.c_syntax_for_h then+        vim.bo[bufnr].filetype = ""objc""+      else+        vim.bo[bufnr].filetype = ""objcpp""+      end+      return+    end+  end+  if vim.g.c_syntax_for_h then+    vim.bo[bufnr].filetype = ""c""+  elseif vim.g.ch_syntax_for_h then+    vim.bo[bufnr].filetype = ""ch""+  else+    vim.bo[bufnr].filetype = ""cpp""+  end+end++function M.idl(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 50)) do+    -- Always ignore case+    line = line:lower()+    if findany(line, { '^%s*import%s+""unknwn""%.idl', '^%s*import%s+""objidl""%.idl' }) then+      vim.bo[bufnr].filetype = ""msidl""+      return+    end+  end+  vim.bo[bufnr].filetype = ""idl""+end++function M.inc(path, bufnr) end++function M.inp(bufnr)+  if getlines(bufnr, 1):find(""^%*"") then+    vim.bo[bufnr].filetype = ""abaqus""+  else+    for _, line in ipairs(getlines(bufnr, 1, 500)) do+      if line:lower():find(""^header surface data"") then+        vim.bo[bufnr].filetype = ""trasys""+        return+      end+    end+  end+end++function M.lpc(path, bufnr) end++function M.lprolog(path, bufnr) end++function M.m(path, bufnr) end++-- Rely on the file to start with a comment.+-- MS message text files use ';', Sendmail files use '#' or 'dnl'+function M.mc(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 20)) do+    if findany(line:lower(), { ""^%s*#"", ""^%s*dnl"" }) then+      -- Sendmail .mc file+      vim.bo[bufnr].filetype = ""m4""+      return+    elseif line:find(""^%s*;"") then+      vim.bo[bufnr].filetype = ""msmessages""+      return+    end+  end+  -- Default: Sendmail .mc file+  vim.bo[bufnr].filetype = ""m4""+end++function M.mm(path, bufnr) end++function M.mms(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 20)) do+    if findany(line, { ""^%s*%%"", ""^%s*//"", ""^%*"" }) then+      vim.bo[bufnr].filetype = ""mmix""+      return+    elseif line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""make""+      return+    end+  end+  vim.bo[bufnr].filetype = ""mmix""+end++function M.mod(path, bufnr) end++-- This function checks if one of the first five lines start with a dot. In+-- that case it is probably an nroff file: 'filetype' is set and 1 is returned.+function M.nroff(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:find(""^%."") then+      vim.bo[bufnr].filetype = ""nroff""+      return 1+    end+  end+  return 0+end++function M.perl(path, bufnr) end++function M.pl(path, bufnr) end++function M.pp(path, bufnr) end++function M.prg(path, bufnr) end++function M.progress_asm(path, bufnr) end++function M.progress_cweb(bufnr)+  if vim.g.filetype_w then+    vim.bo[bufnr].filetype = vim.g.filetype_w+  else+    if getlines(bufnr, 1):find(""^&ANALYZE"") or getlines(bufnr, 3):find(""^&GLOBAL%-DEFINE"") then+      vim.bo[bufnr].filetype = ""progress""+    else+      vim.bo[bufnr].filetype = ""cweb""+    end+  end+end++function M.progress_pascal(path, bufnr) end++function M.proto(path, bufnr) end++function M.r(bufnr)+  local lines = getlines(bufnr, 1, 50)+  -- TODO: \< / \> which match the beginning / end of a word+  -- Rebol is easy to recognize, check for that first+  if table.concat(lines):lower():find(""rebol"") then+    vim.bo[bufnr].filetype = ""rebol""+    return+  end++  for _, line in ipairs(lines) do+    -- R has # comments+    if line:find(""^%s*#"") then+      vim.bo[bufnr].filetype = ""r""+      return+    end+    -- Rexx has /* comments */+    if line:find(""^%s*/%*"") then+      vim.bo[bufnr].filetype = ""rexx""+      return+    end+  end++  -- Nothing recognized, use user default or assume R+  if vim.g.filetype_r then+    vim.bo[bufnr].filetype = vim.g.filetype_r+  else+    -- Rexx used to be the default, but R appears to be much more popular.+    vim.bo[bufnr].filetype = ""r""+  end+end++function M.redif(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 5)) do+    if line:lower():find(""^template%-type:"") then+      vim.bo[bufnr].filetype = ""redif""+    end+  end+end++function M.rules(path, bufnr) end++-- This function checks the first 25 lines of file extension ""sc"" to resolve+-- detection between scala and SuperCollider+function M.sc(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 25)) do+    if findany(line, { ""[A-Za-z0-9]*%s:%s[A-Za-z0-9]"", ""var%s<"", ""classvar%s<"", ""%^this.*"", ""|%w*|"", ""%+%s%w*%s{"", ""%*ar%s"" }) then+      vim.bo[bufnr].filetype = ""supercollider""+      return+    end+  end+  vim.bo[bufnr].filetype = ""scala""+end++-- This function checks the first line of file extension ""scd"" to resolve+-- detection between scdoc and SuperCollider+function M.scd(bufnr)","Yes it looks like there is a bug in the `scd` detection:https://github.com/neovim/neovim/blob/9005ffbe7757eca8ad809c81db76aec930db8e68/runtime/lua/vim/filetype/detect.lua#L338The first entry `""$""` should be `first .. ""$""`.",
5308024,andmis,https://api.github.com/repos/neovim/neovim/pulls/18404,864319989,2022-05-03T23:01:25Z,src/nvim/api/buffer.c,"@@ -514,24 +514,25 @@ void nvim_buf_set_lines(uint64_t channel_id, Buffer buffer, Integer start, Integ  /// Sets (replaces) a range in the buffer ///-/// This is recommended over nvim_buf_set_lines when only modifying parts of a-/// line, as extmarks will be preserved on non-modified parts of the touched+/// This is recommended over |nvim_buf_set_lines()| when only modifying parts of+/// a line, as extmarks will be preserved on non-modified parts of the touched /// lines. ///-/// Indexing is zero-based and end-exclusive.+/// Row indices are zero-based and end-inclusive. Column indices are zero-based,+/// end-exclusive, and correspond to bytes, not display columns.","I am 100% open to revisiting the terminology and making it consistent with column naming elsewhere in the docs, I agree that's important. Do you object to any usage of the phrasing ""...bytes, not <some kind of> columns""? Because I do think as a user that something like this is helpful.",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18219,864688636,2022-05-04T10:39:08Z,runtime/lua/vim/filetype.lua,"@@ -863,6 +898,184 @@ local extension = {       return ""text""     end   end,+  cmd = function (path, bufnr)+    if getline(bufnr, 1):find(""^/%*"") then+      return ""rexx""+    end+    return ""dosbatch""+  end,+  rul = function(path, bufnr)+    if getline(bufnr, 1, 6):lower():find(""installshield"") then+      return ""ishd""+    end+    return ""diva""+  end,+  cpy = function(path, bufnr)+    if getline(bufnr, 1):find(""^##"") then+      return ""python""+    end+    return ""cobol""+  end,+  dsl = function(path, bufnr)+    if getline(bufnr, 1):find(""^%s*<!"") then+      return ""dsl""+    end+    return ""structurizr""+  end,+  edf = ""edif"",+  edfi = ""edif"",+  edo = ""edif"",+  edn = function(path, bufnr)+    if getline(bufnr, 1):find(""^%s*%(%s*edif>"") then+      return ""edif""+    end+    return ""clojure""+  end,+  smil = function(path, bufnr)+    if getline(bufnr, 1):find(""<?%s*xml.*?>"") then+      return ""xml""+    end+    return ""smil""+  end,+  smi = function(path, bufnr)+    if getline(bufnr, 1):find(""<smil>"") then+      return ""smil""+    end+    return ""mib""+  end,+  install = function(path, bufnr)+    if getline(bufnr, 1):find(""<%?php"") then+      return ""php""+    end+    vim.fn[""dist#ft#SetFileTypeSH""](""bash"")+  end,+  pm = function(path, bufnr)+    if getline(bufnr, 1):find(""XPM2"") then+      return ""xpm2""+    elseif getline(bufnr, 1):find(""XPM"") then+      return ""xpm""+    else+      return ""perl""+    end+  end,+  me = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, "":t"")+    if filename ~= ""read.me"" and filename ~= ""click.me"" then+      return ""nroff""+    end+  end,+  reg = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find(""^REGEDIT[0-9]*%s*$"") or line:find(""^Windows Registry Editor Version %d*%.%d*%s*$"") then+      return ""registry""+    end+  end,+  decl = function(path, bufnr)+    if getline(bufnr, 1, 3):lower():find(""^<!sgml"") then",This does not do what you are intending to do: `^` will only match the start of all concatenated lines (i.e. always line 1). There needs to be a loop iterating over the lines here. The same applies for all following occurences where more than one line is compared. (see https://github.com/neovim/neovim/blob/95b7851f620928b6a93dc0198be31959b16c53d9/runtime/lua/vim/filetype/detect.lua#L112 for an example). Maybe we should use [`getlines`](https://github.com/neovim/neovim/blob/95b7851f620928b6a93dc0198be31959b16c53d9/runtime/lua/vim/filetype/detect.lua#L4) from `detect.lua` here as well?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18219,864707378,2022-05-04T11:04:18Z,runtime/lua/vim/filetype.lua,"@@ -863,6 +898,184 @@ local extension = {       return ""text""     end   end,+  cmd = function (path, bufnr)+    if getline(bufnr, 1):find(""^/%*"") then+      return ""rexx""+    end+    return ""dosbatch""+  end,+  rul = function(path, bufnr)+    if getline(bufnr, 1, 6):lower():find(""installshield"") then+      return ""ishd""+    end+    return ""diva""+  end,+  cpy = function(path, bufnr)+    if getline(bufnr, 1):find(""^##"") then+      return ""python""+    end+    return ""cobol""+  end,+  dsl = function(path, bufnr)+    if getline(bufnr, 1):find(""^%s*<!"") then+      return ""dsl""+    end+    return ""structurizr""+  end,+  edf = ""edif"",+  edfi = ""edif"",+  edo = ""edif"",+  edn = function(path, bufnr)+    if getline(bufnr, 1):find(""^%s*%(%s*edif>"") then+      return ""edif""+    end+    return ""clojure""+  end,+  smil = function(path, bufnr)+    if getline(bufnr, 1):find(""<?%s*xml.*?>"") then+      return ""xml""+    end+    return ""smil""+  end,+  smi = function(path, bufnr)+    if getline(bufnr, 1):find(""<smil>"") then+      return ""smil""+    end+    return ""mib""+  end,+  install = function(path, bufnr)+    if getline(bufnr, 1):find(""<%?php"") then+      return ""php""+    end+    vim.fn[""dist#ft#SetFileTypeSH""](""bash"")+  end,+  pm = function(path, bufnr)+    if getline(bufnr, 1):find(""XPM2"") then+      return ""xpm2""+    elseif getline(bufnr, 1):find(""XPM"") then+      return ""xpm""+    else+      return ""perl""+    end+  end,+  me = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, "":t"")+    if filename ~= ""read.me"" and filename ~= ""click.me"" then+      return ""nroff""+    end+  end,+  reg = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find(""^REGEDIT[0-9]*%s*$"") or line:find(""^Windows Registry Editor Version %d*%.%d*%s*$"") then+      return ""registry""+    end+  end,+  decl = function(path, bufnr)+    if getline(bufnr, 1, 3):lower():find(""^<!sgml"") then",Or -- better -- move this check to `detect.lua`? Rule of thumb (for now) could be that any check that looks at more than the first line belongs in `detect.lua`.,
5308024,andmis,https://api.github.com/repos/neovim/neovim/pulls/18404,864715108,2022-05-04T11:14:22Z,src/nvim/api/buffer.c,"@@ -514,24 +514,25 @@ void nvim_buf_set_lines(uint64_t channel_id, Buffer buffer, Integer start, Integ  /// Sets (replaces) a range in the buffer ///-/// This is recommended over nvim_buf_set_lines when only modifying parts of a-/// line, as extmarks will be preserved on non-modified parts of the touched+/// This is recommended over |nvim_buf_set_lines()| when only modifying parts of+/// a line, as extmarks will be preserved on non-modified parts of the touched /// lines. ///-/// Indexing is zero-based and end-exclusive.+/// Row indices are zero-based and end-inclusive. Column indices are zero-based,+/// end-exclusive, and correspond to bytes, not display columns.","First, I think that given the number of types of columns there are, it would have been very bad to introduce a new term ""display column"" (which also does not appear anywhere else in the codebase). I probably shouldn't have used the term without more due diligence. Anyway thanks for commenting on this line.I've made a change in this paragraph in both places to use the term ""character column"", and additionally, I added references to `col()` and `charcol()`, which describe what these two column types actually are. My rationale is, this function `vim.api.nvim_buf_set_text` is very likely to be the first place that a new plugin author or hacker will land when editing text programmatically, especially someone not previously familiar with the Vim script interfaces -- speaking as someone who just went through this experience. The docs for `col()` and `charcol()` are never going away or changing, so there is no maintenance risk to linking them here. I think that in general it makes sense to be judicious including cross-refs in docs, but IMO it's very worth having something in the docs for `vim.api.nvim_buf_[get|set]_text` that points the user at a description of the difference between byte columns and character columns.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18219,864763189,2022-05-04T12:19:15Z,runtime/lua/vim/filetype.lua,"@@ -863,6 +898,184 @@ local extension = {       return ""text""     end   end,+  cmd = function (path, bufnr)+    if getline(bufnr, 1):find(""^/%*"") then+      return ""rexx""+    end+    return ""dosbatch""+  end,+  rul = function(path, bufnr)+    if getline(bufnr, 1, 6):lower():find(""installshield"") then+      return ""ishd""+    end+    return ""diva""+  end,+  cpy = function(path, bufnr)+    if getline(bufnr, 1):find(""^##"") then+      return ""python""+    end+    return ""cobol""+  end,+  dsl = function(path, bufnr)+    if getline(bufnr, 1):find(""^%s*<!"") then+      return ""dsl""+    end+    return ""structurizr""+  end,+  edf = ""edif"",+  edfi = ""edif"",+  edo = ""edif"",+  edn = function(path, bufnr)+    if getline(bufnr, 1):find(""^%s*%(%s*edif>"") then+      return ""edif""+    end+    return ""clojure""+  end,+  smil = function(path, bufnr)+    if getline(bufnr, 1):find(""<?%s*xml.*?>"") then+      return ""xml""+    end+    return ""smil""+  end,+  smi = function(path, bufnr)+    if getline(bufnr, 1):find(""<smil>"") then+      return ""smil""+    end+    return ""mib""+  end,+  install = function(path, bufnr)+    if getline(bufnr, 1):find(""<%?php"") then+      return ""php""+    end+    vim.fn[""dist#ft#SetFileTypeSH""](""bash"")+  end,+  pm = function(path, bufnr)+    if getline(bufnr, 1):find(""XPM2"") then+      return ""xpm2""+    elseif getline(bufnr, 1):find(""XPM"") then+      return ""xpm""+    else+      return ""perl""+    end+  end,+  me = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, "":t"")+    if filename ~= ""read.me"" and filename ~= ""click.me"" then+      return ""nroff""+    end+  end,+  reg = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find(""^REGEDIT[0-9]*%s*$"") or line:find(""^Windows Registry Editor Version %d*%.%d*%s*$"") then+      return ""registry""+    end+  end,+  decl = function(path, bufnr)+    if getline(bufnr, 1, 3):lower():find(""^<!sgml"") then+      return ""sgmldecl""+    end+  end,+  dcl = function(path, bufnr)+    if getline(bufnr, 1, 3):lower():find(""^<!sgml"") then+      return ""sgmldecl""+    end+    return ""clean""+  end,+  dec = function(path, bufnr)+    if getline(bufnr, 1, 3):lower():find(""^<!sgml"") then+      return ""sgmldecl""+    end+  end,+  web = function(path, bufnr)+    if getline(bufnr, 1, 5):find(""^%%"") then+      return ""web""+    end+    return ""winbatch""+  end,+  ttl = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find(""^@?prefix"") or line:find(""^@?base"") then+      return ""turtle""+    end+    return ""teraterm""+  end,+  am = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, "":t""):lower()+    if not filename:find(""makefile.am$"") then+      return ""elf""+    end+  end,+  [""m4""] = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, "":t""):lower()+    if not filename:find(""html.m4$"") and not filename:find(""fvwm2rc"") then+      return ""m4""+    end+  end,+  hw = function(path, bufnr)+    if getline(bufnr, 1):find(""<%?php"") then+      return ""php""+    end+    return ""virata""+  end,+  module = function(path, bufnr)+    if getline(bufnr, 1):find(""<%?php"") then+      return ""php""+    end+    return ""virata""+  end,+  pkg = function(path, bufnr)+    if getline(bufnr, 1):find(""<%?php"") then+      return ""php""+    end+    return ""virata""+  end,+  ms = function(path, bufnr)+    if vim.fn[""dist#ft#FTnroff""]() == 0 then+      return ""xmath""+    end+  end,+  t = function(path, bufnr)+    if vim.fn[""dist#ft#FTnroff""]() == 0 and vim.fn[""dist#ft#FTperl""]() == 0 then+      return ""tads""+    end+  end,+  class = function(path, bufnr)+    if not getline(bufnr, 1):find(""^\xca\xfe\xba\xbe"") then",Lua patterns can use `%x` for this purpose.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18416,865979895,2022-05-05T14:36:14Z,src/nvim/eval/funcs.c,"@@ -9139,9 +9137,9 @@ static void f_shellescape(typval_T *argvars, typval_T *rettv, FunPtr fptr) {   const bool do_special = non_zero_arg(&argvars[1]); -  rettv->vval.v_string = vim_strsave_shellescape((const char_u *)tv_get_string(-                                                                              &argvars[0]), do_special,-                                                 do_special);+  rettv->vval.v_string =+    (char *)vim_strsave_shellescape((const char_u *)+                                    tv_get_string(&argvars[0]), do_special, do_special);",avoid newline in middle of cast,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18425,867347488,2022-05-07T12:34:36Z,src/nvim/charset.c,"@@ -424,7 +424,7 @@ char_u *str_foldcase(char_u *str, int orglen, char_u *buf, int buflen)   int i;   int len = orglen; -#define GA_CHAR(i) ((char_u *)ga.ga_data)[i]+#define GA_CHAR(i) ((char *)ga.ga_data)[i]","hmm, is a bit weird to have this different type than `buf[i]` (though this entire function is a convoluted mess. all these macros can be eliminated by just setting `buf = ga.ga_data` , though that would be another PR)",
5308024,andmis,https://api.github.com/repos/neovim/neovim/pulls/18366,867522191,2022-05-08T17:46:00Z,runtime/doc/api.txt,"@@ -1711,6 +1711,23 @@ nvim_call_function({fn}, {args})                        *nvim_call_function()*                 Return: ~                     Result of the function call +nvim_cmd({*cmd}, {*opts})                                         *nvim_cmd()*",It's confusing to have two functions in the API called `nvim_cmd` and `nvim_command` that do very similar things. Should we at least say in the docs a little bit about why there are two functions for this and summarize the difference between them or when you should prefer one over the other?,X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18366,867522808,2022-05-08T17:52:36Z,runtime/doc/api.txt,"@@ -1711,6 +1711,23 @@ nvim_call_function({fn}, {args})                        *nvim_call_function()*                 Return: ~                     Result of the function call +nvim_cmd({*cmd}, {*opts})                                         *nvim_cmd()*","That's the way the API goes: functions that are added in a release cannot be removed (before 2.0). So some duplication is inevitable (and has happened before). No decision yet, but there's a strong argument for deprecating `nvim_command` in favor or `nvim_exec` and leaving `nvim_cmd` as _the_ function for executing a single command.",X
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18347,867527226,2022-05-08T18:35:05Z,src/nvim/api/vim.c,"@@ -2276,6 +2276,12 @@ Dictionary nvim_eval_statusline(String str, Dict(eval_statusline) *opts, Error *   bool use_tabline = false;   bool highlights = false; +  const char *const errmsg = check_stl_option((char_u *)str.data);+  if (errmsg) {+    api_set_error(err, kErrorTypeValidation, ""%s"", errmsg);+    return result;+  }+","You need to make an exception for when the string starts with `%!`, see:https://github.com/neovim/neovim/blob/df4bdba58fed4d88681fe71ce644c42d5578613d/src/nvim/option.c#L2944-L2945```suggestion  if (str.size < 2 || memcmp(str.data, ""%!"", 2)) {    const char *const errmsg = check_stl_option((char_u *)str.data);    if (errmsg) {      api_set_error(err, kErrorTypeValidation, ""%s"", errmsg);      return result;    }  }```",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/18487,868076939,2022-05-09T14:27:26Z,Makefile,"@@ -146,6 +146,9 @@ functionaltest: | nvim functionaltest-lua: | nvim 	+$(BUILD_TOOL) -C build functionaltest-lua +stylua:+	stylua --check runtime/+","`lualint` is optional, just that the check is done in Cmakelist.txt instead (don't ask why lol). `clint` is our own tool which is always available, so that shouldn't be a problem.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18366,868214474,2022-05-09T16:47:00Z,src/nvim/api/vimscript.c,"@@ -978,3 +988,377 @@ Dictionary nvim_parse_cmd(String str, Dictionary opts, Error *err)   xfree(cmdline);   return result; }++/// Executes an Ex command.+///+/// Unlike |nvim_command()| this command takes a structured Dictionary instead of a String. This+/// allows for easier construction and manipulation of an Ex command. This also allows for things+/// such as having spaces inside a command argument, expanding filenames in a command that otherwise+/// doesn't expand filenames, etc.+///+/// @see |nvim_exec()|+/// @see |nvim_command()|+///+/// @param cmd       Command to execute. Must be a Dictionary that can contain the same values as+///                  the return value of |nvim_parse_cmd()| except ""addr"", ""nargs"" and ""nextcmd"".+///                  All values except for ""cmd"" are optional.+/// @param opts      Optional parameters.+///                  - output: (boolean, default false) Whether to return command output.+/// @param[out] err  Error details, if any.+/// @return Command output (non-error, non-shell |:!|) if `output` is true, else empty string.+String nvim_cmd(uint64_t channel_id, Dict(cmd) *cmd, Dict(cmd_opts) *opts, Error *err)+  FUNC_API_SINCE(10)+{+  exarg_T ea;+  memset(&ea, 0, sizeof(ea));+  ea.verbose_save = -1;+  ea.save_msg_silent = -1;++  CmdParseInfo cmdinfo;+  memset(&cmdinfo, 0, sizeof(cmdinfo));+  cmdinfo.verbose = -1;++  char *cmdline = NULL;+  char *cmdname = NULL;+  char **args = NULL;+  size_t argc = 0;++  String retv = (String)STRING_INIT;++#define OBJ_TO_BOOL(var, value, default, varname) \+  do { \+    var = api_object_to_bool(value, varname, default, err); \+    if (ERROR_SET(err)) { \+      goto end; \+    } \+  } while (0)++#define VALIDATION_ERROR(...) \+  do { \+    api_set_error(err, kErrorTypeValidation, __VA_ARGS__); \+    goto end; \+  } while (0)++  bool output;+  OBJ_TO_BOOL(output, opts->output, false, ""'output'"");++  // First, parse the command name and check if it exists and is valid.+  if (!HAS_KEY(cmd->cmd)) {+    VALIDATION_ERROR(""No 'cmd' specified"");+  } else if (cmd->cmd.type != kObjectTypeString) {+    VALIDATION_ERROR(""'cmd' must be a String"");+  } else if (cmd->cmd.data.string.data[0] == NUL) {+    VALIDATION_ERROR(""'cmd' cannot be an empty String"");",we don't need to be this detailed in validation errors. this can just be a single if with `||` and error message `'cmd' must be a non-empty string` (similar to existing errors like `x must be a non-negative integer`),
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/18489,870340836,2022-05-11T14:00:46Z,src/nvim/eval/funcs.c,"@@ -7890,18 +7890,18 @@ static void f_rpcrequest(typval_T *argvars, typval_T *rettv, FunPtr fptr)     // If this is called from a provider function, restore the scope     // information of the caller.     save_current_sctx = current_sctx;-    save_sourcing_name = sourcing_name;+    save_sourcing_name = (uint8_t *)sourcing_name;",Fixed it now. I also got confused because it look extremely similar to the other code you commented on :),
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17933,870375201,2022-05-11T14:26:55Z,runtime/lua/vim/shared.lua,"@@ -107,13 +107,13 @@ end --- ---@see |vim.gsplit()| -------@param s String to split----@param sep Separator string or pattern----@param kwargs Keyword arguments:+---@param s string String to split+---@param sep string Separator or pattern+---@param kwargs table|boolean Keyword arguments:",`kwargs` can technically be a Boolean but that���s only for backward compatibility. We should only advertise it as a table argument.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18453,870871379,2022-05-12T01:20:21Z,src/nvim/terminal.c,"@@ -404,7 +404,7 @@ void terminal_enter(void)    // Disable these options in terminal-mode. They are nonsense because cursor is   // placed at end of buffer to ""follow"" output. #11072-  win_T *save_curwin = curwin;+  handle_T save_handle = curwin->handle;","nit: I'd leave the name as it was, it's a bit more semantically descriptive",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/18528,871284660,2022-05-12T11:50:20Z,src/nvim/api/vim.c,"@@ -778,6 +782,42 @@ void nvim_set_option_value(String name, Object value, Dict(option) *opts, Error     return;   } +  int opt_type = SREQ_GLOBAL;+  void *to = NULL;++  if (opts->win.type == kObjectTypeInteger) {+    scope = OPT_LOCAL;+    opt_type = SREQ_WIN;+    to = find_window_by_handle((int)opts->win.data.integer, err);+  } else if (HAS_KEY(opts->win)) {+    api_set_error(err, kErrorTypeValidation, ""invalid value for key: win"");+    return;+  }++  if (opts->buf.type == kObjectTypeInteger) {+    scope = OPT_LOCAL;+    opt_type = SREQ_BUF;+    to = find_buffer_by_handle((int)opts->buf.data.integer, err);+  } else if (HAS_KEY(opts->buf)) {+    api_set_error(err, kErrorTypeValidation, ""invalid value for key: buf"");+    return;+  }++  if (HAS_KEY(opts->scope) && HAS_KEY(opts->win)) {","~My understanding of all this is still incomplete, so I'll need a little extra help if that's ok? Is my comment on the other PR at least correct?~You have replied, thanks.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18547,871897893,2022-05-12T23:50:10Z,src/nvim/ex_docmd.c,"@@ -8972,15 +8972,13 @@ bool save_current_state(save_state_T *sst)   sst->save_restart_edit = restart_edit;   sst->save_msg_didout = msg_didout;   sst->save_State = State;-  sst->save_insertmode = p_im;",This item in the struct is unused,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18443,871925274,2022-05-13T01:15:28Z,test/functional/plugin/man_spec.lua,"@@ -137,4 +140,16 @@ describe(':Man', function()       ]])     end)   end)++  describe(""quit with q (#18281)"", function()+    before_each(function()+      helpers.clear()+    end)++    it(""exits with 0 after q"", function()+      -- funcs.system({ nvim_prog, ""-u"", ""NONE"", ""-i"", ""NONE"", ""--headless"", ""--cmd"", cmdline })","I think this test could be a good model: https://github.com/neovim/neovim/blob/233c41cb8cfe1aa5a8520fe6104adacc53c0ece2/test/functional/autocmd/termxx_spec.lua#L125create a `VimEnter` handler (autocmd) that echos some text:```lualocal output = funcs.system({nvim_prog, '--headless', '+autocmd VimLeave * echo ""quit works!!""', '+Man!', '+call nvim_input(""q"")'}, {'manpage contents'})eq('quit works!!', output)```",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/16251,872009688,2022-05-13T05:23:20Z,src/nvim/ex_getln.c,"@@ -2428,7 +2427,23 @@ static void abandon_cmdline(void) /// @param indent  indent for inside conditionals char_u *getcmdline(int firstc, long count, int indent, bool do_concat FUNC_ATTR_UNUSED) {-  return command_line_enter(firstc, count, indent, true);+  bool check_cmdheight = p_ch < 1 && !ui_has(kUIMessages);++  if (check_cmdheight) {+    set_option_value(""ch"", 1L, NULL, 0);+    redraw_statuslines();+  }++  char_u *ret = command_line_enter(firstc, count, indent, true);;++  if (check_cmdheight) {+    set_option_value(""ch"", 0L, NULL, 0);++    // Buffer redraw is needed if no command line","Redrawing everything is suboptimal for this, I'm sure redrawing the current window would be enough? Alternatively, you could check if `redrawcmdline` works, that'd be even better.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18555,872146447,2022-05-13T08:44:48Z,runtime/doc/syntax.txt,"@@ -5096,51 +5096,51 @@ These are the builtin highlighting groups.  Note that the highlighting depends on the value of 'background'.  You can see the current settings with the "":highlight"" command. 							*hl-ColorColumn*-ColorColumn	used for the columns set with 'colorcolumn'+ColorColumn	Used for the columns set with 'colorcolumn' 							*hl-Conceal*-Conceal		placeholder characters substituted for concealed+Conceal		Placeholder characters substituted for concealed 		text (see 'conceallevel') 							*hl-CurSearch*-CurSearch	used for highlighting a search pattern under the cursor+CurSearch	Used for highlighting a search pattern under the cursor 		(see 'hlsearch') 							*hl-Cursor*-Cursor		character under the cursor-lCursor		the character under the cursor when |language-mapping|+Cursor		Character under the cursor+lCursor		The character under the cursor when |language-mapping| 		is used (see 'guicursor') 							*hl-CursorIM*-CursorIM	like Cursor, but used when in IME mode |CursorIM|+CursorIM	Like Cursor, but used when in IME mode |CursorIM| 							*hl-CursorColumn* CursorColumn	Screen-column at the cursor, when 'cursorcolumn' is set. 							*hl-CursorLine* CursorLine	Screen-line at the cursor, when 'cursorline' is set. 		Low-priority if foreground (ctermfg OR guifg) is not set. 							*hl-Directory*-Directory	directory names (and other special names in listings)+Directory	Directory names (and other special names in listings)",```suggestionDirectory	Directory names (and other special names in listings).```,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/18555,872251226,2022-05-13T10:43:05Z,runtime/doc/eval.txt,"@@ -3137,8 +3137,10 @@ text... :for {var} in {object}					*:for* *E690* *E732* :endfo[r]						*:endfo* *:endfor* 			Repeat the commands between `:for` and `:endfor` for-			each item in {object}.  {object} can be a |List| or-			a |Blob|.  Variable {var} is set to the value of each+			each item in {object}.  {object} can be a |List|,+			a |Blob| or a |String|.++			Variable {var} is set to the value of each","Maybe also format the following paragraphs a bit to match Vim (minus the Vim9 stuff), like:```vimhelp			Variable {var} is set to the value of each item.			When an error is detected for a command inside the			loop, execution continues after the `endfor`.			Changing {object} inside the loop affects what items			are used. Make a copy if this is unwanted: >				:for item in copy(mylist)<```",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/18558,872312086,2022-05-13T11:45:26Z,runtime/doc/api.txt,"@@ -1580,8 +1580,28 @@ nvim_set_hl({ns_id}, {name}, {*val})                           *nvim_set_hl()*                              |nvim_create_namespace()|. Use 0 to set a                              highlight group globally |:highlight|.                     {name}   Highlight group name, e.g. ""ErrorMsg""-                    {val}    Highlight definition map, like |synIDattr()|. In-                             addition, the following keys are recognized:+                    {val}    Highlight definition map, accepts the following+                             keys:+                             ��� fg (or foreground): color name or ""#RRGGBB"",",Small nit. All attributes are long form. Looks/reads better with long form first for background and foreground.,
866010,rktjmp,https://api.github.com/repos/neovim/neovim/pulls/18558,872316574,2022-05-13T11:51:48Z,runtime/doc/api.txt,"@@ -1580,8 +1580,28 @@ nvim_set_hl({ns_id}, {name}, {*val})                           *nvim_set_hl()*                              |nvim_create_namespace()|. Use 0 to set a                              highlight group globally |:highlight|.                     {name}   Highlight group name, e.g. ""ErrorMsg""-                    {val}    Highlight definition map, like |synIDattr()|. In-                             addition, the following keys are recognized:+                    {val}    Highlight definition map, accepts the following+                             keys:+                             ��� fg (or foreground): color name or ""#RRGGBB"",","I would argue that  ""fg"" and ""bg"" are more natural/important in this case due to the historical `guifg` & `ctermfg` in `:highlight` and I think 99% of colorschemes use `fg` and `bg` as key values.Of course I will defer to the team if you confirm the desire, personally I was surprised to see the long forms were even accepted options.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18558,872357656,2022-05-13T12:42:30Z,src/nvim/api/vim.c,"@@ -133,15 +133,34 @@ Dictionary nvim__get_hl_defs(Integer ns_id, Error *err) /// @param ns_id Namespace id for this highlight |nvim_create_namespace()|. ///              Use 0 to set a highlight group globally |:highlight|. /// @param name  Highlight group name, e.g. ""ErrorMsg""-/// @param val   Highlight definition map, like |synIDattr()|. In-///              addition, the following keys are recognized:+/// @param val   Highlight definition map, accepts the following keys:+///                - foreground (or fg): color name or ""#RRGGBB"", see note.+///                - background (or bg): color name or ""#RRGGBB"", see note.+///                - special (or sp): color name or ""#RRGGBB""+///                - blend: integer between 0 and 100+///                - bold: boolean+///                - standout: boolean+///                - underline: boolean+///                - underlineline: boolean+///                - undercurl: boolean+///                - underdot: boolean+///                - underdash: boolean+///                - strikethrough: boolean+///                - italic: boolean+///                - reverse: boolean+///                - nocombine: boolean+///                - link: name of another highlight group to link to, see |:hi-link|.+///              Additionally, the following keys are recognized: ///                - default: Don't override existing definition |:hi-default| ///                - ctermfg: Sets foreground of cterm color |highlight-ctermfg| ///                - ctermbg: Sets background of cterm color |highlight-ctermbg|-///                - cterm: cterm attribute map, like-///                  |highlight-args|.-///                  Note: Attributes default to those set for `gui`-///                        if not set.+///                - cterm: cterm attribute map, like |highlight-args|.+///                  Note: Attributes default to those set for `gui` if not set.+///             Note: The foreground and background keys also accept the string","try moving this before the `@param` list, and change it to `@note````suggestion/// @note The foreground and background keys also accept the string```",
866010,rktjmp,https://api.github.com/repos/neovim/neovim/pulls/18558,872357758,2022-05-13T12:42:37Z,runtime/doc/api.txt,"@@ -1590,7 +1610,13 @@ nvim_set_hl({ns_id}, {name}, {*val})                           *nvim_set_hl()*                                |highlight-ctermbg|                              ��� cterm: cterm attribute map, like                                |highlight-args|. Note: Attributes default to-                               those set for `gui` if not set.","Perhaps> Note: if not set, cterm attributes will match those from the attribute map documented above.I don't *think* you need to point out that fg/bg wont be copied as those are explicitly listed as ctermfg/bg. I did call it ""primary attribute map above"" but I think primary is superfluous.Not sure if you need ""supported cterm attributes"", I think only `blend` isn't supported in cterm? If so, probably I'd just tack ""Blend is not supported in cterm mode(?)"" on the end to remove ambiguity.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18430,872670870,2022-05-13T18:30:38Z,runtime/lua/vim/filetype/detect.lua,"@@ -22,16 +32,135 @@ local function findany(s, patterns)   return false end +---@private+local function nextnonblank(bufnr, start_lnum)+  for _, line in ipairs(getlines(bufnr, start_lnum, -1)) do+    if not line:find('^%s*$') then+      return line+    end+  end+  return nil+end+ -- luacheck: push no unused args -- luacheck: push ignore 122 -function M.asm(path, bufnr) end+-- This function checks for the kind of assembly that is wanted by the user, or+-- can be detected from the first five lines of the file.+function M.asm(bufnr)+  -- Make sure b:asmsyntax exists+  if not vim.b[bufnr].asmsyntax then+    vim.b[bufnr].asmsyntax = ''+  end++  if vim.b[bufnr].asmsyntax == '' then+    M.asm_syntax(bufnr)+  end++  -- If b:asmsyntax still isn't set, default to asmsyntax or GNU+  if vim.b[bufnr].asmsyntax == '' then+    if vim.g.asmsyntax and vim.g.asmsyntax ~= 0 then+      vim.b[bufnr].asmsyntax = vim.g.asmsyntax+    else+      vim.b[bufnr].asmsyntax = 'asm'+    end+  end+  vim.bo[bufnr].filetype = vim.fn.fnameescape(vim.b[bufnr].asmsyntax)+end++-- Checks the first 5 lines for a asmsyntax=foo override.+-- Only whitespace characters can be present immediately before or after this statement.+function M.asm_syntax(bufnr)+  local lines = getlines(bufnr, 1, 5, { concat = true, sep = ' ' })+  local match = lines:match('%sasmsyntax=([a-zA-Z0-9]+)%s')+  if match then+    vim.b['asmsyntax'] = match+  elseif findany(lines:lower(), { '%.title', '%.ident', '%.macro', '%.subtitle', '%.library' }) then+    vim.b['asmsyntax'] = 'vmasm'+  end+end++local visual_basic_content = { 'vb_name', 'begin vb%.form', 'begin vb%.mdiform', 'begin vb%.usercontrol' }++-- See frm() for Visual Basic form file detection+function M.bas(bufnr)+  if vim.g.filetype_bas then+    vim.bo[bufnr].filetype = vim.g.filetype_bas+    return+  end -function M.asm_syntax(path, bufnr) end+  -- Most frequent FreeBASIC-specific keywords in distro files+  local fb_keywords = {+    '^%s*extern',+    '^%s*var',+    '^%s*enum',+    '^%s*private',+    '^%s*scope',+    '^%s*union',+    '^%s*byref',+    '^%s*operator',+    '^%s*constructor',+    '^%s*delete',+    '^%s*namespace',+    '^%s*public',+    '^%s*property',+    '^%s*with',+    '^%s*destructor',+    '^%s*using',+  }+  local last_part = '^.%s*%[:=%(%]'","The pattern in filetype.vim is `\%(\s*[:=(]\)`, so I think this should instead be```suggestion  local last_part = '^.%s*[:=%(]'```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18430,872686921,2022-05-13T18:41:55Z,runtime/lua/vim/filetype/detect.lua,"@@ -68,17 +191,109 @@ function M.cfg(bufnr)   end end -function M.change(path, bufnr) end+-- This function checks if one of the first ten lines start with a '@'.  In+-- that case it is probably a change file.+-- If the first line starts with # or ! it's probably a ch file.+-- If a line has ""main"", ""include"", ""//"" or ""/*"" it's probably ch.+-- Otherwise CHILL is assumed.+function M.change(bufnr)+  local first_line = getlines(bufnr, 1)+  if findany(first_line, { '^#', '^!' }) then+    vim.bo[bufnr].filetype = 'ch'+    return+  end+  for _, line in ipairs(getlines(bufnr, 1, 10)) do+    if line:find('^@') then+      vim.bo[bufnr].filetype = 'change'+      return+    end+    line = line:lower()+    if line:find('module') then+      vim.bo[bufnr].filetype = 'chill'+      return+    elseif findany(line, { 'main%s*%(', '#%s*include', '//' }) then+      vim.bo[bufnr].filetype = 'ch'+      return+    end+  end+  vim.bo[bufnr].filetype = 'chill'+end  function M.csh(path, bufnr) end -function M.dat(path, bufnr) end+-- Determine if a *.dat file is Kuka Robot Language+-- TODO: this one fails for some reason, so I omitted it. #18219 should be merged first.+function M.dat(bufnr)+  -- if vim.g.filetype_dat then+  --   vim.bo[bufnr].filetype = vim.g.filetype_dat+  --   return+  -- end+  -- local line = nextnonblank(bufnr, 1):lower()+  -- if findany(line, { ""^%s*&%w+"", ""^%s*defdat"" }) then+  --   vim.bo[bufnr].filetype = ""krl""+  -- end+end -function M.dep3patch(path, bufnr) end+-- This function is called for all files under */debian/patches/*, make sure not+-- to non-dep3patch files, such as README and other text files.+function M.dep3patch(path, bufnr)+  local file_name = vim.fn.fnamemodify(path, ':t')+  if file_name == 'series' then+    return+  end++  for _, line in ipairs(getlines(bufnr, 1, 100)) do+    if+      findany(line, {+        '^Description:',+        '^Subject:',+        '^Origin:',+        '^Bug:',+        '^Forwarded:',+        '^Author:',+        '^From:',+        '^Reviewed%-by:',+        '^Acked%-by:',+        '^Last%-Updated:',+        '^Applied%-Upstream:',+      })+    then+      vim.bo[bufnr].filetype = 'dep3patch'+    elseif line:find('^%-%-%-') then+      -- End of headers found. stop processing+      return+    end+  end+end -function M.dtrace(path, bufnr) end+function M.dtrace(bufnr)+  local did_filetype = vim.fn.did_filetype()+  if did_filetype and did_filetype ~= 0 then+    -- Filetype was already detected+    return+  end+  for _, line in ipairs(getlines(bufnr, 1, 100)) do+    if findany(line, { '^module', '^import' }) then+      --  D files often start with a module and/or import statement.+      vim.bo[bufnr].filetype = 'd'+      return+    elseif findany(line, { '^#!%S+dtrace', '#pragma%s+D%s+option', ':%S*:%S*:' }) then","For the last pattern, Lua's `*` operator is greedy but filetype.vim uses `{-}` (non-greedy), so I think this is a better conversion:```suggestion    elseif findany(line, { '^#!%S+dtrace', '#pragma%s+D%s+option', ':[^%s:]*:[^%s:]*:' }) then```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18430,872687903,2022-05-13T18:43:28Z,runtime/lua/vim/filetype/detect.lua,"@@ -138,18 +353,35 @@ end function M.frm(bufnr)   if vim.g.filetype_frm then     vim.bo[bufnr].filetype = vim.g.filetype_frm+    return+  end+  local lines = getlines(bufnr, 1, 5, { concat = true }):lower()+  if findany(lines, visual_basic_content) then+    vim.bo[bufnr].filetype = 'vb'   else     -- Always ignore case-    local lines = getlines(bufnr, 1, 5, { concat = true }):lower()-    if findany(lines, { 'vb_name', 'begin vb%.form', 'begin vb%.mdiform' }) then+    if findany(lines, visual_basic_content) then       vim.bo[bufnr].filetype = 'vb'     else       vim.bo[bufnr].filetype = 'form'     end   end end",Looks like you're testing the same condition twice?,X
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18430,872694459,2022-05-13T18:52:53Z,runtime/lua/vim/filetype/detect.lua,"@@ -198,11 +444,101 @@ function M.inp(bufnr)   end end -function M.lpc(path, bufnr) end+function M.lpc(bufnr)+  if vim.g.lpc_syntax_for_c then+    for _, line in ipairs(getlines(bufnr, 1, 12)) do+      if+        findany(line, {+          '^//',+          '^inherit',+          '^private',+          '^protected',+          '^nosave',+          '^string',+          '^object',+          '^mapping',+          '^mixed',+        })+      then+        vim.bo[bufnr].filetype = 'lpc'+        return+      end+    end+  end+  vim.bo[bufnr].filetype = 'c'+end -function M.lprolog(path, bufnr) end+function M.m(bufnr)+  if vim.g.filetype_m then+    vim.bo[bufnr].filetype = vim.g.filetype_m+    return+  end++  -- Excluding end(for|function|if|switch|while) common to Murphi+  local octave_block_terminators = {+    'end_try_catch',+    'endclassdef',+    'endenumeration',+    'endevents',+    'endmethods',+    'endparfor',+    'endproperties',+  }",For `\<` and `\>`:```suggestion  local octave_block_terminators = vim.regex([[\%(^\|;\)\s*\<end\%(_try_catch\|classdef\|enumeration\|events\|methods\|parfor\|properties\)\>]])```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18430,872700799,2022-05-13T19:02:00Z,runtime/lua/vim/filetype/detect.lua,"@@ -236,29 +580,135 @@ function M.mms(bufnr)   vim.bo[bufnr].filetype = 'mmix' end -function M.mod(path, bufnr) end+-- Returns true if file content looks like LambdaProlog+local function is_lprolog(bufnr)+  -- Skip apparent comments and blank lines, what looks like+  -- LambdaProlog comment may be RAPID header+  for _, line in ipairs(getlines(bufnr, 1, -1)) do+    -- The second pattern matches a LambdaProlog comment+    if not findany(line, { '^%s*$', '^%s*%%' }) then+      -- The pattern must not catch a go.mod file+      return findany(line, { 'module%s+%w+%s*.%s*%%', 'module%s+%w+%s*.%s*$' })+    end+  end+end++-- Determine if *.mod is ABB RAPID, LambdaProlog, Modula-2, Modsim III or go.mod+function M.mod(path, bufnr)+  if vim.g.filetype_mod then+    vim.bo[bufnr].filetype = vim.g.filetype_mod+  elseif is_lprolog(bufnr) then+    vim.bo[bufnr].filetype = 'lprolog'+  elseif findany(nextnonblank(bufnr, 1):lower(), { 'module%s+%w+%s*;', '^%s*%(%*' }) then","`MODULE` is uppercase in filetype.vim so let's assume it's case sensitive here. And since it uses `\<` let's just copy the pattern directly:```suggestion  elseif vim.regex([[\%(\<MODULE\s\+\w\+\s*;\|^\s*(\*\)]]):match_str(nextnonblank(bufnr, 1)) then```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18430,872704856,2022-05-13T19:08:32Z,runtime/lua/vim/filetype/detect.lua,"@@ -236,29 +580,135 @@ function M.mms(bufnr)   vim.bo[bufnr].filetype = 'mmix' end -function M.mod(path, bufnr) end+-- Returns true if file content looks like LambdaProlog+local function is_lprolog(bufnr)+  -- Skip apparent comments and blank lines, what looks like+  -- LambdaProlog comment may be RAPID header+  for _, line in ipairs(getlines(bufnr, 1, -1)) do+    -- The second pattern matches a LambdaProlog comment+    if not findany(line, { '^%s*$', '^%s*%%' }) then+      -- The pattern must not catch a go.mod file+      return findany(line, { 'module%s+%w+%s*.%s*%%', 'module%s+%w+%s*.%s*$' })+    end+  end+end++-- Determine if *.mod is ABB RAPID, LambdaProlog, Modula-2, Modsim III or go.mod+function M.mod(path, bufnr)+  if vim.g.filetype_mod then+    vim.bo[bufnr].filetype = vim.g.filetype_mod+  elseif is_lprolog(bufnr) then+    vim.bo[bufnr].filetype = 'lprolog'+  elseif findany(nextnonblank(bufnr, 1):lower(), { 'module%s+%w+%s*;', '^%s*%(%*' }) then+    vim.bo[bufnr].filetype = 'modula2'+  elseif is_rapid(bufnr) then+    vim.bo[bufnr].filetype = 'rapid'+  elseif path:find('go%.mod$') then+    vim.bo[bufnr].filetype = 'gomod'+  else+    -- Nothing recognized, assume modsim3+    vim.bo[bufnr].filetype = 'modsim3'+  end+end  -- This function checks if one of the first five lines start with a dot. In--- that case it is probably an nroff file: 'filetype' is set and 1 is returned.+-- that case it is probably an nroff file: 'filetype' is set and true is returned. function M.nroff(bufnr)   for _, line in ipairs(getlines(bufnr, 1, 5)) do     if line:find('^%.') then       vim.bo[bufnr].filetype = 'nroff'       return 1     end   end-  return 0+  return false end -function M.perl(path, bufnr) end+-- If the file has an extension of 't' and is in a directory 't' or 'xt' then+-- it is almost certainly a Perl test file.+-- If the first line starts with '#' and contains 'perl' it's probably a Perl file.+-- (Slow test) If a file contains a 'use' statement then it is almost certainly a Perl file.+function M.perl(path, bufnr)+  local dirname = vim.fn.expand(path, '%:p:h:t')+  if vim.fn.expand(dirname, '%:e') == 't' and (dirname == 't' or dirname == 'xt') then+    vim.bo[bufnr].filetype = 'perl'+    return true+  end+  local first_line = getlines(bufnr, 1)+  if first_line:match('^#') and first_line:match('perl') then+    vim.bo[bufnr].filetype = 'perl'+    return true+  end+  for _, line in ipairs(getlines(bufnr, 1, 30)) do+    if line:match('^use%s+.') then+      vim.bo[bufnr].filetype = 'perl'+      return true+    end+  end+  return false+end  function M.pl(path, bufnr) end -function M.pp(path, bufnr) end+local pascal_comments = { '^%s*{', '^%s*%(*', '^%s*//' }+local pascal_keywords = {+  '^%s*program',+  '^%s*unit',+  '^%s*library',+  '^%s*uses',+  '^%s*begin',+  '^%s*procedure',+  '^%s*function',+  '^%s*const',+  '^%s*type',+  '^%s*var',+}",```suggestionlocal pascal_keywords = vim.regex([[^\s*\%(program\|unit\|library\|uses\|begin\|procedure\|function\|const\|type\|var\)\>]])```,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/18276,873173326,2022-05-15T13:54:11Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -363,6 +363,10 @@ function LanguageTree:_get_injections()             table.insert(ranges, node)           end         end++        if metadata[id] and metadata[id].range and #ranges == 0 then+          table.insert(ranges, metadata[id].range)+        end","you could create a function that resolved the node or the range: `process_node(node, id, metadata)`. Then you could also `offset!` the `lang` by just appliying this function. nvim-treesitter's `get_node_text` also worked with nodes and `{range[1], range[2], range[3], range[4]}`, so that you could use everywhere a node or a range interchangeably.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/18575,873185267,2022-05-15T15:22:44Z,runtime/lua/vim/_editor.lua,"@@ -789,7 +790,7 @@ function vim.deprecate(name, alternative, version, plugin)   plugin = plugin or 'Nvim'   message = alternative and (message .. ', use ' .. alternative .. ' instead.') or message   message = message .. ' See :h deprecated\nThis function will be removed in ' .. plugin .. ' version ' .. version-  vim.notify_once(message, vim.log.levels.WARN)+  vim.notify_once(debug.traceback(message, 2), vim.log.levels.WARN, nil, message)","But the entire point of `vim.deprecate()` was to *not* abort the calling code with errors. If it's a fatal error then you could just use `error()` instead. The code that is calling a deprecated function should still work before it's actually removed. It's just that you should see exactly where the deprecated function is used.Maybe it's okay to reuse `vim.depracate()` to throw actual errors too, but I think the backtrace is needed for a ""soft"" deprecation too.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18575,873188543,2022-05-15T15:50:07Z,runtime/lua/vim/_editor.lua,"@@ -789,7 +790,7 @@ function vim.deprecate(name, alternative, version, plugin)   plugin = plugin or 'Nvim'   message = alternative and (message .. ', use ' .. alternative .. ' instead.') or message   message = message .. ' See :h deprecated\nThis function will be removed in ' .. plugin .. ' version ' .. version-  vim.notify_once(message, vim.log.levels.WARN)+  vim.notify_once(debug.traceback(message, 2), vim.log.levels.WARN, nil, message)","> But the entire point of `vim.deprecate()` was to _not_ abort the calling code with errors.No. The minimum use-case of vim.deprecate() is to have a common shape for deprecations (i.e. the message has the same wording, mentions alternative, optionally mentions version...)> If it's a fatal error then you could just use `error()` instead.Plain error() has some minor downsides:1.  message isn't in the ""standard"" format2. loses the theoretical opportunity to statically analyze `deprecate()` calls3. loses theoretical opportunity to localize the message> The code that is calling a deprecated function should still work before it's actually removed.I plan to use vim.deprecate() for hard removals. It's just easier than hand-crafting the usual message (which looks janky because the message looks different every time someone rewrites it).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18575,873188967,2022-05-15T15:54:00Z,runtime/doc/lua.txt,"@@ -1378,6 +1378,8 @@ notify_once({msg}, {level}, {opts})                        *vim.notify_once()*                              |vim.log.levels|.                     {opts}   (table|nil) Optional parameters. Unused by                              default.+                    {key}    (string|nil) Optional key unique to the message.+                             If not given, {msg} is used.","> so how about just handling the behavior of `vim.notify_once` inside `vim.notify` then? If `opts.once` is `true` then it behaves like `notify_once`,Definitely. I don't know why vim.notify_once was added... it will be deprecated, ironically.>  I believe some plugins are replacing vim.notify to show messages in floating windows and stuff like thatWe cannot and must not take the burden of worrying about that. ",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/18575,873190327,2022-05-15T16:05:02Z,runtime/lua/vim/_editor.lua,"@@ -789,7 +790,7 @@ function vim.deprecate(name, alternative, version, plugin)   plugin = plugin or 'Nvim'   message = alternative and (message .. ', use ' .. alternative .. ' instead.') or message   message = message .. ' See :h deprecated\nThis function will be removed in ' .. plugin .. ' version ' .. version-  vim.notify_once(message, vim.log.levels.WARN)+  vim.notify_once(debug.traceback(message, 2), vim.log.levels.WARN, nil, message)","> Show a backtrace only if `vim.o.verbose > 0` ? There can be some way of disabling it, but I think showing a backtrace should be the default. I guess verbose level cannot be a negative number?> The idea is that some users will want to continue to work and can't update stuff, so showing a backtrace all the time will be annoying.The message is only shown once per neovim instance, so it's not all the time. The argument could be made that backtraces will force you into the `Press ENTER or type a command to continue` prompt, but `vim.deprecate` is already a multiline message so it does that either way.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18306,873203555,2022-05-15T17:59:11Z,src/nvim/generators/gen_eval.lua,"@@ -62,7 +62,8 @@ for name, def in pairs(funcs) do   local base = def.base or ""BASE_NONE""   local func = def.func or ('f_' .. name)   local data = def.data or ""NULL""-  gperfpipe:write(('%s,  %s, %s, %s, &%s, (FunPtr)%s\n')-                  :format(name, args[1], args[2], base, func, data))+  local fast = def.fast or false+  gperfpipe:write(('%s,  %s, %s, %s, %s, &%s, (FunPtr)%s\n')+                  :format(name, args[1], args[2], base, fast, func, data))","based on line 45:    %define initializer-suffix ,0,0,false,BASE_NONE,NULL,NULLI would expect `fast` to be in the 4th-last place:```suggestion                  :format(name, args[1], args[2], fast, base, func, data))```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18306,873204465,2022-05-15T18:08:11Z,test/functional/lua/vim_spec.lua,"@@ -794,6 +794,16 @@ describe('lua stdlib', function()           pcall_err(exec_lua, ""vim.fn.nvim_get_current_line()""))   end) +  it('vim.fn can be called in fast events (if function is allowed)', function()+    exec_lua([[+      vim.loop.fs_stat('.', function()+        vim.g.fnres = vim.fn.iconv('hello', 'utf-8', 'utf-8')+      end)+    ]])+    helpers.sleep(10)","I think `poke_eventloop` might work here, and is semantically helpful?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18575,873218938,2022-05-15T20:01:25Z,runtime/lua/vim/_editor.lua,"@@ -446,10 +446,17 @@ do   ---@param msg string Content of the notification to show to the user.   ---@param level number|nil One of the values from |vim.log.levels|.   ---@param opts table|nil Optional parameters. Unused by default.-  function vim.notify_once(msg, level, opts) -- luacheck: no unused args-    if not notified[msg] then+  function vim.notify_once(msg, level, opts, key) -- luacheck: no unused args",i think `-- luacheck: no unused args` can be removed by now?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18575,873244590,2022-05-15T23:23:36Z,runtime/lua/vim/_editor.lua,"@@ -446,10 +446,17 @@ do   ---@param msg string Content of the notification to show to the user.   ---@param level number|nil One of the values from |vim.log.levels|.   ---@param opts table|nil Optional parameters. Unused by default.-  function vim.notify_once(msg, level, opts) -- luacheck: no unused args-    if not notified[msg] then+  function vim.notify_once(msg, level, opts, key)",This could return `true` if it displays and `false` if it skipped. Then `vim.deprecate` could use that to decide whether it should show a backtrace (using plain `vim.notify()` or whatever?).That keeps the door open for making backtrace optional. Would this work?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18461,873247701,2022-05-15T23:47:33Z,src/nvim/diff.c,"@@ -3068,17 +3068,17 @@ static int parse_diff_ed(char_u *line, diffhunk_T *hunk)   }    if (difftype == 'a') {-    hunk->lnum_orig = f1 + 1;+    hunk->lnum_orig = (linenr_T)f1 + 1;",f1 is `long` so why is this cast necessary? oh because `long` could be 64 wide :(Does changing `f1` to int32 avoid the casts? Else we may need to assert...,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18461,873247912,2022-05-15T23:49:01Z,src/nvim/shada.c,"@@ -3886,8 +3886,8 @@ static ShaDaReadResult shada_read_next_item(ShaDaReadDef *const sd_reader, Shada           {             for (i = 0; i < unpacked_2.data.via.map.size; i++) {  // -V535               CHECK_KEY_IS_STR(unpacked_2, ""buffer list entry"")-              LONG_KEY(unpacked_2, ""buffer list entry"", KEY_LNUM,-                       entry->data.buffer_list.buffers[j].pos.lnum)+              INTEGER_KEY(unpacked_2, ""buffer list entry"", KEY_LNUM,+                          entry->data.buffer_list.buffers[j].pos.lnum)",looks like `LONG_KEY` is no longer used,
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/18575,873248206,2022-05-15T23:51:22Z,runtime/lua/vim/_editor.lua,"@@ -446,10 +446,17 @@ do   ---@param msg string Content of the notification to show to the user.   ---@param level number|nil One of the values from |vim.log.levels|.   ---@param opts table|nil Optional parameters. Unused by default.-  function vim.notify_once(msg, level, opts) -- luacheck: no unused args-    if not notified[msg] then+  function vim.notify_once(msg, level, opts, key)",Sure. Should we add an optional `opts` dictionary to `vim.deprecate` as the fifth argument then?,
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/18575,873249175,2022-05-15T23:59:06Z,runtime/lua/vim/_editor.lua,"@@ -789,7 +790,9 @@ function vim.deprecate(name, alternative, version, plugin)   plugin = plugin or 'Nvim'   message = alternative and (message .. ', use ' .. alternative .. ' instead.') or message   message = message .. ' See :h deprecated\nThis function will be removed in ' .. plugin .. ' version ' .. version-  vim.notify_once(message, vim.log.levels.WARN)+  if vim.notify_once(message, vim.log.levels.WARN) then+    vim.notify(debug.traceback('', 2):sub(2), vim.log.levels.WARN)","Looks like you can't just do `debug.traceback(nil, 2)` if you want to start the traceback from the function that calls `vim.deprecate`, and you have to include some message. Alternatively, it could just be simply `debug.traceback()` and the traceback could start from this line.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18575,873249489,2022-05-16T00:00:56Z,runtime/lua/vim/_editor.lua,"@@ -446,10 +446,17 @@ do   ---@param msg string Content of the notification to show to the user.   ---@param level number|nil One of the values from |vim.log.levels|.   ---@param opts table|nil Optional parameters. Unused by default.-  function vim.notify_once(msg, level, opts) -- luacheck: no unused args-    if not notified[msg] then+  function vim.notify_once(msg, level, opts, key)","> Sure. Should we add an optional opts dictionary to vim.deprecate as the fifth argument then?In general when a Lua function wants to have an `opts` arg we should almost always change the function to accept a ""kwargs"" form (i.e. a single dict param). The old non-dict params form remains as an optional interface.So, for now I'd say just add another param, unless you want to take a stab at that.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/18563,873403437,2022-05-16T07:26:38Z,.github/workflows/ci.yml,"@@ -92,6 +101,10 @@ jobs:           token: ${{ secrets.GITHUB_TOKEN }}           args: --check runtime/ +      - if: ""!cancelled()""+        name: uncrustify+        run: uncrustify -c ./src/uncrustify.cfg -q --replace --no-backup $(find ./src/nvim -name ""*.[ch]"")","Hmm, not a fan of this the git syntax. It's very ambiguous that it searches recursive.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18577,873420834,2022-05-16T07:47:03Z,runtime/lua/vim/lsp/handlers.lua,"@@ -321,13 +321,14 @@ end --see: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_hover M['textDocument/hover'] = M.hover ----@private --- Jumps to a location. Used as a handler for multiple LSP methods.----@param _ (not used) ---@param result (table) result of LSP method; a location or a list of locations. ---@param ctx (table) table containing the context of the request, including the method ---(`textDocument/definition` can return `Location` or `Location[]`-local function location_handler(_, result, ctx, _)+---@param config table Configuration table.+---     - reuse_win: (default=nil) Jump to existing window if buffer is already open.+function M.location_handler(_, result, ctx, config)",I'm not sure if we still want to follow this model. For better multi client support for references and other locations we'd need to merge the results from all clients and then display them.  The location_handler signature wouldn't fit for that because the ctx with it's client_id implies a single clientI think we'd have to move into a similar direction as we did for format/rename and others and pass options via `buf.references { ... }` and probably inline the handler implementation.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18461,873674500,2022-05-16T12:37:25Z,src/nvim/charset.c,"@@ -1394,6 +1394,14 @@ long getdigits_long(char_u **pp, bool strict, long def)   return (long)number; } +/// Gets a int32_t number from a string.+///+/// @see getdigits+int32_t getdigits_int32(char **pp, bool strict, long def)+{+  return (int32_t)getdigits((char_u **)pp, strict, def);","we would need the similar treatment here as the other `getdigits_xx`. something like..```  intmax_t number = getdigits(pp, strict, def);#if SIZEOF_INTMAX_T > sizeof(int32_t)  if (strict) {    assert(number >= INT32_MIN && number <= INT32_MAX);  } else if (!(number >= INT32_MIN && number <= INT32_MAX)) {    return def;  }#endif  return (int32_t)number;```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18562,874088932,2022-05-16T19:35:15Z,src/nvim/window.c,"@@ -6662,6 +6652,32 @@ static void last_status_rec(frame_T *fr, bool statusline, bool is_stl_global)   } } +// Add or remove window bars from windows depending on the value of 'winbar'.+void set_winbar(void)+{+  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+    if (*p_wbr != NUL || *wp->w_p_wbr != NUL) {+      if (wp->w_winbar_height) {+        continue;+      }+      wp->w_winrow_off += 1;+      wp->w_height_inner -= 1;","this feels a little hackish. Instead of adjusting dependent variables around, perhaps we can move the calculation of `w_winrow_off` to `win_set_inner_size` and just call it whenever the value changed. Then we don't need two branches here heither.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/18563,874095389,2022-05-16T19:43:53Z,.github/workflows/ci.yml,"@@ -66,6 +66,32 @@ jobs:             ninja-build \             pkg-config ++      - name: Cache uncrustify+        id: cache-uncrustify+        uses: actions/cache@v2+        with:+          path: ${{ env.CACHE_UNCRUSTIFY }}+          key: ${{ env.UNCRUSTUFY_VERSION }}",lol god damn it,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/18306,874528797,2022-05-17T08:31:26Z,src/nvim/lua/executor.c,"@@ -916,12 +916,22 @@ int nlua_in_fast_event(lua_State *lstate)   return 1; } +static bool viml_func_is_deferred_safe(const char_u *name)+{+  const VimLFuncDef *const fdef = find_internal_func((const char *)name);+  if (fdef) {+    return fdef->fast;+  }+  // Not a vimL function+  return false;+}+ int nlua_call(lua_State *lstate) {   Error err = ERROR_INIT;   size_t name_len;   const char_u *name = (const char_u *)luaL_checklstring(lstate, 1, &name_len);-  if (!nlua_is_deferred_safe()) {+  if (!nlua_is_deferred_safe() && !viml_func_is_deferred_safe(name)) {","I originally did this, but @bfredl suggested I separated it. Since `nlua_is_deferred_safe` is used in a ton of places in the API functions I think I agree it should be split. This new condition is only relevant to `nvim_call`.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/18306,874530791,2022-05-17T08:33:29Z,test/functional/lua/vim_spec.lua,"@@ -794,6 +794,16 @@ describe('lua stdlib', function()           pcall_err(exec_lua, ""vim.fn.nvim_get_current_line()""))   end) +  it('vim.fn can be called in fast events (if function is allowed)', function()+    exec_lua([[+      vim.loop.fs_stat('.', function()+        vim.g.fnres = vim.fn.iconv('hello', 'utf-8', 'utf-8')+      end)+    ]])+    helpers.sleep(10)","~No, actually. `poke_eventloop` iterates to the next main event, whereas here we want to iterate to the next fast event.~~I can modify `poke_eventloop` so it works for both.~Sorry, misunderstood comment. `poke_eventloop` may not work because we don't know how long `fs_stat` will take to execute. It may take several iterations. I can modify to a loop that fails when it loops to a certain max threshold.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/18276,874639596,2022-05-17T10:20:06Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -363,6 +363,10 @@ function LanguageTree:_get_injections()             table.insert(ranges, node)           end         end++        if metadata[id] and metadata[id].range and #ranges == 0 then+          table.insert(ranges, metadata[id].range)+        end","Sorry, but that mostly went over my head. I think the main problem is that I simply just don't understand this code. It looks pretty fragile and overly complex.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/18563,874709939,2022-05-17T11:43:24Z,.github/workflows/ci.yml,"@@ -66,6 +66,32 @@ jobs:             ninja-build \             pkg-config ++      - name: Cache uncrustify+        id: cache-uncrustify+        uses: actions/cache@v2+        with:+          path: ${{ env.CACHE_UNCRUSTIFY }}+          key: ${{ env.UNCRUSTIFY_VERSION }}++      - name: Clone uncrustify+        if: steps.cache-uncrustify.outputs.cache-hit != 'true'+        uses: actions/checkout@v2+        with:+          repository: uncrustify/uncrustify+          ref: ${{ env.UNCRUSTIFY_VERSION }}+          path: uncrustify++      - name: Install uncrustify+        if: steps.cache-uncrustify.outputs.cache-hit != 'true'+        run: |+          source_dir=uncrustify+          build_dir=uncrustify/build+          cmake -S $source_dir -B $build_dir -G Ninja -DCMAKE_BUILD_TYPE=Release+          cmake --build $build_dir+          mkdir -p $HOME/.cache+          cp $build_dir/uncrustify ${{ env.CACHE_UNCRUSTIFY }}","it's up to you, this is just a standard procedure and is a benefit of using cmake, it ensures:1. the binary is available under `<prefix>/bin/uncrustify`, so no need to manually locate it in `$build_dir`2. if uncrustify starts linking against a library and/or starts expecting headers, then copying the binary alone wouldn't work anymore",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18430,874809284,2022-05-17T13:22:39Z,runtime/lua/vim/filetype/detect.lua,"@@ -1,15 +1,28 @@+-- Contains filetype detection functions converted to Lua from Vim's autoload/runtime/dist/ft.vim file.++-- Here are a few guidelines to follow when porting a new function:+-- Sort the function alphabetically and omit 'ft' or 'check' from the new function name.+-- Use :find instead of :match / :sub if possible.+-- When '=~' is used to match a pattern, there are two possibilities:+-- If the pattern only contains lowercase characters treat the comparison as case-insensitive.+-- Otherwise, treat it as case-sensitive. Basically, we apply 'smartcase' (if upper case+-- characters are used in the original pattern, then it's likely that case does matter).++-- When '\k', '\<' or '\>' is used in a pattern, use the matchre function.+-- Note that vim.regex is case-sensitive by default, so add the '\c' flag if only+-- lowercase letters are present in the pattern:+-- Example:+-- `if line =~ '^\s*unwind_protect\>'` => `if matchre(line, [[\c^\s*unwind_protect\>]])","```suggestion--  * Sort the function alphabetically and omit 'ft' or 'check' from the new function name.--  * Use ':find' instead of ':match' / ':sub' if possible.--  * When '=~' is used to match a pattern, there are two possibilities:--     - If the pattern only contains lowercase characters, treat the comparison as case-insensitive.--     - Otherwise, treat it as case-sensitive. --     (Basically, we apply 'smartcase': if upper case characters are used in the original pattern, then --     it's likely that case does matter).--  * When '\k', '\<' or '\>' is used in a pattern, use the 'matchregex' function.--     Note that vim.regex is case-sensitive by default, so add the '\c' flag if only lowercase letters --     are present in the pattern:--     Example:--     `if line =~ '^\s*unwind_protect\>'` => `if matchregex(line, [[\c^\s*unwind_protect\>]])```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18562,874814161,2022-05-17T13:26:44Z,src/nvim/window.c,"@@ -1687,15 +1680,15 @@ int make_windows(int count, bool vertical)   int todo;    if (vertical) {-    // Each window needs at least 'winminwidth' lines and a separator-    // column.+    // Each window needs at least 'winminwidth' lines and a separator column.     maxcount = (curwin->w_width + curwin->w_vsep_width                 - (p_wiw - p_wmw)) / (p_wmw + 1);   } else {-    // Each window needs at least 'winminheight' lines-    // If statusline isn't global, each window also needs a statusline+    // Each window needs at least 'winminheight' lines.+    // If statusline isn't global, each window also needs a statusline.+    // If 'winbar' is set, each window also needs a winbar.     maxcount = (curwin->w_height + curwin->w_hsep_height + curwin->w_status_height-                - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);+                - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT + winbar_height());","ok, so the interpretation of `p_wmh` will only be regards with the global value. I'd suggest renaming the function `global_winbar_height()` as not to give a false impression (and avoid ns clash with `winbar_height` variables in the same file)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18615,875805171,2022-05-18T11:58:23Z,test/functional/ex_cmds/mksession_spec.lua,"@@ -113,5 +116,7 @@ describe(':mksession', function()      local expected_cwd = cwd_dir..'/'..tab_dir     matches('^term://'..pesc(expected_cwd)..'//%d+:', funcs.expand('%'))+    command('bd!')+    sleep(100)  -- Make sure the process exits.","I need to make retry() more ergonomic, but meanwhile a hack like `neq(2, eval('1+1'))` works to check if the process is dead.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18617,876354610,2022-05-18T20:43:38Z,src/nvim/autocmd.c,"@@ -2465,45 +2472,44 @@ bool autocmd_delete_id(int64_t id) // =========================================================================== //  AucmdExecutable Functions // ===========================================================================-char *aucmd_exec_default_desc(AucmdExecutable acc)++/// Generate a string description of a callback+static char *aucmd_callback_to_string(Callback cb) {+  // NOTE: this function probably belongs in a helper   size_t msglen = 100;+  char *msg = (char *)xmallocz(msglen); -  switch (acc.type) {-  case CALLABLE_CB:-    switch (acc.callable.cb.type) {-    case kCallbackLua: {-      char *msg = (char *)xmallocz(msglen);-      snprintf(msg, msglen, ""<Lua function %d>"", acc.callable.cb.data.luaref);-      return msg;-    }-    case kCallbackFuncref: {-      // TODO(tjdevries): Is this enough space for this?-      char *msg = (char *)xmallocz(msglen);-      snprintf(msg, msglen, ""<vim function: %s>"", acc.callable.cb.data.funcref);-      return msg;-    }-    case kCallbackPartial: {-      char *msg = (char *)xmallocz(msglen);-      snprintf(msg, msglen, ""<vim partial: %s>"", acc.callable.cb.data.partial->pt_name);-      return msg;-    }-    default:-      return NULL;-    }+  switch (cb.type) {+  case kCallbackLua: {+    snprintf(msg, msglen, ""<Lua function %d>"", cb.data.luaref);","no need to mention ""function"" unless/until we support tables later...```suggestion    snprintf(msg, msglen, ""<Lua: %d>"", cb.data.luaref);```",
541289,dstein64,https://api.github.com/repos/neovim/neovim/pulls/17197,876399889,2022-05-18T21:31:20Z,test/functional/terminal/tui_spec.lua,"@@ -1529,119 +1529,44 @@ describe(""TUI"", function() end)  describe('TUI bg color', function()-  local screen--  local function setup()-    -- Only single integration test.-    -- See test/unit/tui_spec.lua for unit tests.-    clear()-    screen = thelpers.screen_setup(0, '[""'..nvim_prog-      ..'"", ""-u"", ""NONE"", ""-i"", ""NONE"", ""--cmd"", ""set noswapfile"", '-      ..'""-c"", ""autocmd OptionSet background echo \\""did OptionSet, yay!\\""""]')-  end--  before_each(setup)--  it('triggers OptionSet event on unsplit terminal-response', function()-    screen:expect([[-    {1: }                                                 |-    {4:~                                                 }|-    {4:~                                                 }|-    {4:~                                                 }|-    {5:[No Name]                       0,0-1          All}|-                                                      |-    {3:-- TERMINAL --}                                    |-    ]])-    feed_data('\027]11;rgb:ffff/ffff/ffff\007')-    screen:expect{any='did OptionSet, yay!'}--    feed_data(':echo ""new_bg="".&background\n')-    screen:expect{any='new_bg=light'}--    setup()-    screen:expect([[-    {1: }                                                 |-    {4:~                                                 }|-    {4:~                                                 }|-    {4:~                                                 }|-    {5:[No Name]                       0,0-1          All}|-                                                      |-    {3:-- TERMINAL --}                                    |-    ]])-    feed_data('\027]11;rgba:ffff/ffff/ffff/8000\027\\')-    screen:expect{any='did OptionSet, yay!'}+  before_each(clear) -    feed_data(':echo ""new_bg="".&background\n')-    screen:expect{any='new_bg=light'}+  it('is properly set in a nested Neovim instance when background=dark', function()+    command('set background=dark')  -- set outer Neovim background+    local screen = thelpers.screen_setup(0, string.format(+      '[""%s"", ""-u"", ""NONE"", ""-i"", ""NONE"", ""--cmd"", ""set noswapfile""]', nvim_prog))+    retry(nil, 30000, function()  -- wait for automatic background processing+      screen:sleep(20)+      feed_command('set background?')  -- check nested Neovim background+      screen:expect([[+      {1: }                                                 |+      {4:~                                                 }|+      {4:~                                                 }|+      {4:~                                                 }|+      {5:[No Name]                       0,0-1          All}|+        background=dark                                 |+      {3:-- TERMINAL --}                                    |+      ]])+    end)   end) -  it('triggers OptionSet event with split terminal-response', function()","That test was starting a nested Nvim instance. On startup, that nested instance would query for background color, but there would be no response. The test would then simulate a background color response and check that Nvim handled accordingly by setting a background option (`OptionSet` would be triggered).Now when the nested instance initially queries on startup for background color, there is a response, so a simulated response after startup doesn't work in this context since Nvim is no longer in a state to handle the response and trigger `OptionSet` at that point.That test was added to test that the query response is properly handled when the response is not split (presumably the easier case relative to being split). This is still tested for in `test/unit/tui_spec.lua`, but not by relying on the `OptionSet` event.**Summary**The existing test had a dependence on the nested terminal not responding to an OSC background request. Now that the nested terminal does respond to an OSC background request, that approach no longer works.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18630,876402554,2022-05-18T21:35:51Z,src/nvim/options.lua,"@@ -1909,13 +1909,6 @@ return {       redraw={'current_window'},       defaults={if_true=false}     },-    {-      full_name='remap',-      short_desc=N_(""mappings to work recursively""),-      type='bool', scope={'global'},-      varname='p_remap',-      defaults={if_true=true}-    },","Follow the pattern used for e.g. `'compatible'`: change `varname` to `'p_force_on'` and the descriptino to `""No description""`.",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18623,876414007,2022-05-18T21:55:53Z,runtime/lua/vim/filetype.lua,"@@ -968,22 +969,22 @@ local extension = {   scd = function(path, bufnr)     require('vim.filetype.detect').scd(bufnr)   end,-  sh = function()-    vim.fn['dist#ft#SetFileTypeSH'](vim.fn.getline(1))+  sh = function(path, bufnr)+    require('vim.filetype.detect').sh(path, bufnr, vim.fn.getline(1))   end,-  shtml = function()-    vim.fn['dist#ft#FThtml']()+  shtml = function(path, bufnr)+    require('vim.filetype.detect').html(bufnr)   end,   sql = function(path, bufnr)     require('vim.filetype.detect').sql(bufnr)   end,-  stm = function()-    vim.fn['dist#ft#FThtml']()+  stm = function(path, bufnr)+    require('vim.filetype.detect').html(bufnr)   end,-  tcsh = function()-    vim.fn['dist#ft#SetFileTypeShell']('tcsh')+  tcsh = function(path, bufnr)+    require('vim.filetype.detect').shell(path, bufnr, 'tcsh')   end,-  tex = function()+  tex = function(path, bufnr)     vim.fn['dist#ft#FTtex']()","Thank you, I think the main issues were an incorrect pattern for the `context` path and incorrect logic in the `lpat_match` / `cpat_match` part.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18617,877125974,2022-05-19T14:20:50Z,test/functional/api/autocmd_spec.lua,"@@ -144,8 +144,11 @@ describe('autocmd api', function()           })         ]]) -        eq(desc, meths.get_autocmds({ event = 'BufReadPost' })[1].desc)-        matches('<Lua function %d>', meths.get_autocmds({ event = 'BufReadPost' })[1].command)+      local aus = meths.get_autocmds({ event = 'BufReadPost' })+      local first = aus[1]+        eq(desc, first.desc)+        eq(nil, first.command)+        eq(""userdata"", type(first.callback))","The callback is coming back as userdata because the type can't be serialized as a string over the RPC channel. Testing that it's ""userdata"" is not actually that helpful, what we want to test for is that it's a *function*.We can do this by getting the values inside an `exec_lua` block and then returning that to the test runner:```lualocal result = exec_lua [[  local aus = vim.api.nvim_get_autocmds({ event = 'BufReadPost' })  local first = aus[1]  return { desc = first.desc, command = first.command, cbtype = type(first.callback) }]]eq({ desc = desc, command = nil, cbtype = ""function"" }, result)```You can combine this with the `exec_lua` block just above it too.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/18617,877314338,2022-05-19T17:10:19Z,test/functional/api/autocmd_spec.lua,"@@ -195,33 +197,29 @@ describe('autocmd api', function()     end)      it('removes an autocommand if the callback returns true', function()+      local group_name = ""ToBeRemoved""+      meths.set_var(""group_name"", group_name)+       meths.set_var(""some_condition"", false) -      exec_lua [[-      vim.api.nvim_create_autocmd(""User"", {-        pattern = ""Test"",-        desc = ""A test autocommand"",-        callback = function()-          return vim.g.some_condition-        end,-      })+      local result = exec_lua [[+        local gid = vim.api.nvim_create_augroup(vim.g.group_name, {})+        local id = vim.api.nvim_create_autocmd(""User"", {+          group = vim.g.group_name,+          pattern = ""RemovalTest"",+          desc = ""A test autocommand"",+          callback = function()+            return vim.g.some_condition+          end,+        })+        vim.g.some_condition = true+        vim.api.nvim_exec_autocmds(""User"", {pattern = ""RemovalTest""})","commenting out the call to `nvim_get_autocmds()` will get the test-case to pass.  it looks like a race-condition between `nvim_get_autocmds()` and `au_cleanup()` (or whatever is responsible for clearing the autocmds)if this is actually the case, then I'm afraid that the solution won't be trivialthe first thing that jumps to mind is that we'd need to mark the `autocmd` for deletion individually, instead of marking the entire state as ""not clean"", but that means a large-ish refactor for the logic of clearing the autocmds. see https://github.com/neovim/neovim/blob/2c72dc39d718955ac485a08eecd8407641b98599/src/nvim/autocmd.c#L96-L94",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18219,877529133,2022-05-19T20:48:55Z,runtime/lua/vim/filetype.lua,"@@ -1007,6 +1036,156 @@ local extension = {       return 'text'     end   end,+  cmd = function(path, bufnr)+    if getline(bufnr, 1):find('^/%*') then+      return 'rexx'+    end+    return 'dosbatch'+  end,+  rul = function(path, bufnr)+    require('vim.filetype.detect').rul(bufnr)+  end,+  cpy = function(path, bufnr)+    if getline(bufnr, 1):find('^##') then+      return 'python'+    end+    return 'cobol'+  end,+  dsl = function(path, bufnr)+    if getline(bufnr, 1):find('^%s*<!') then+      return 'dsl'+    end+    return 'structurizr'+  end,+  edf = 'edif',+  edfi = 'edif',+  edo = 'edif',+  edn = function(path, bufnr)+    if getline(bufnr, 1):find('^%s*%(%s*edif>') then+      return 'edif'+    end+    return 'clojure'+  end,+  smil = function(path, bufnr)+    if getline(bufnr, 1):find('<%?%s*xml.*%?>') then+      return 'xml'+    end+    return 'smil'+  end,+  smi = function(path, bufnr)+    if getline(bufnr, 1):find('<smil>') then+      return 'smil'+    end+    return 'mib'+  end,+  install = function(path, bufnr)+    if getline(bufnr, 1):find('<%?php') then+      return 'php'+    end+    vim.fn['dist#ft#SetFileTypeSH']('bash')+  end,+  pm = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find('XPM2') then+      return 'xpm2'+    elseif line:find('XPM') then+      return 'xpm'+    else+      return 'perl'+    end+  end,+  me = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, ':t')+    if filename ~= 'read.me' and filename ~= 'click.me' then+      return 'nroff'+    end+  end,+  reg = function(path, bufnr)+    local line = getline(bufnr, 1):lower()+    if line:find('^regedit[0-9]*%s*$') or line:find('^windows registry editor version %d*%.%d*%s*$') then","```luaif findany(line, { '^regedit[0-9]*%s*$', '^windows registry editor version %d*%.%d*%s*$' }) then```(`findany` is currently only defined in `detect.lua`, if we decide to put all more complex checks in `detect.lua` there won't be duplicate code)",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18219,877534650,2022-05-19T20:56:36Z,runtime/lua/vim/filetype.lua,"@@ -1007,6 +1036,156 @@ local extension = {       return 'text'     end   end,+  cmd = function(path, bufnr)+    if getline(bufnr, 1):find('^/%*') then+      return 'rexx'+    end+    return 'dosbatch'+  end,+  rul = function(path, bufnr)+    require('vim.filetype.detect').rul(bufnr)+  end,+  cpy = function(path, bufnr)+    if getline(bufnr, 1):find('^##') then+      return 'python'+    end+    return 'cobol'+  end,+  dsl = function(path, bufnr)+    if getline(bufnr, 1):find('^%s*<!') then+      return 'dsl'+    end+    return 'structurizr'+  end,+  edf = 'edif',+  edfi = 'edif',+  edo = 'edif',+  edn = function(path, bufnr)+    if getline(bufnr, 1):find('^%s*%(%s*edif>') then+      return 'edif'+    end+    return 'clojure'+  end,+  smil = function(path, bufnr)+    if getline(bufnr, 1):find('<%?%s*xml.*%?>') then+      return 'xml'+    end+    return 'smil'+  end,+  smi = function(path, bufnr)+    if getline(bufnr, 1):find('<smil>') then+      return 'smil'+    end+    return 'mib'+  end,+  install = function(path, bufnr)+    if getline(bufnr, 1):find('<%?php') then+      return 'php'+    end+    vim.fn['dist#ft#SetFileTypeSH']('bash')+  end,+  pm = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find('XPM2') then+      return 'xpm2'+    elseif line:find('XPM') then+      return 'xpm'+    else+      return 'perl'+    end+  end,+  me = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, ':t')+    if filename ~= 'read.me' and filename ~= 'click.me' then+      return 'nroff'+    end+  end,+  reg = function(path, bufnr)+    local line = getline(bufnr, 1):lower()+    if line:find('^regedit[0-9]*%s*$') or line:find('^windows registry editor version %d*%.%d*%s*$') then+      return 'registry'+    end+  end,+  decl = function(path, bufnr)+    require('vim.filetype.detect').decl(bufnr)+  end,+  dec = function(path, bufnr)+    require('vim.filetype.detect').decl(bufnr)+  end,+  dcl = function(path, bufnr)+    require('vim.filetype.detect').dcl(bufnr)+  end,+  web = function(path, bufnr)+    require('vim.filetype.detect').web(bufnr)+  end,+  ttl = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find('^@?prefix') or line:find('^@?base') then+      return 'turtle'+    end+    return 'teraterm'+  end,+  am = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, ':t'):lower()+    if not filename:find('makefile%.am$') then+      return 'elf'+    end+  end,+  ['m4'] = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, ':t'):lower()+    if not filename:find('html%.m4$') and not filename:find('fvwm2rc') then+      return 'm4'+    end+  end,+  hw = function(path, bufnr)+    if getline(bufnr, 1):find('<%?php') then+      return 'php'+    end+    return 'virata'+  end,+  module = function(path, bufnr)+    if getline(bufnr, 1):find('<%?php') then+      return 'php'+    end+    return 'virata'+  end,+  pkg = function(path, bufnr)+    if getline(bufnr, 1):find('<%?php') then+      return 'php'+    end+    return 'virata'+  end,+  ms = function(path, bufnr)+    if vim.fn['dist#ft#FTnroff']() == 0 then",```luaif not require('vim.filetype.detect').nroff(bufnr) then```(similarly below),
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18650,878256976,2022-05-20T15:07:58Z,src/nvim/screen.c,"@@ -5332,11 +5333,29 @@ static void win_redr_custom(win_T *wp, bool draw_winbar, bool draw_ruler)     attr = (wp == curwin) ? HL_ATTR(HLF_WBR) : HL_ATTR(HLF_WBRNC);     maxwidth = wp->w_width_inner;     use_sandbox = was_set_insecurely(wp, ""winbar"", 0);++    if (wp->w_winbar_height && wp->w_winbar_click_defs_size != (size_t)maxwidth) {",I'd change these to `< (size_t)maxwidth`. these data are not big enough to have a lot of reallocations just to save the last byte.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18623,878415309,2022-05-20T18:06:09Z,runtime/lua/vim/filetype/detect.lua,"@@ -131,7 +134,15 @@ function M.bas(bufnr)   vim.bo[bufnr].filetype = 'basic' end -function M.bindzone(bufnr, default_ft) end+function M.bindzone(bufnr, default)+  local lines = table.concat(getlines(bufnr, 1, 4))+  local first = '^; <<>> DiG [0-9%.]+.* <<>>'+  if findany(lines, { first .. '%$ORIGIN', first .. '%$TTL', first .. 'IN%s+SOA' }) then","The pattern in filetype.vim is ambiguous, I had to look up the file format of a bind zone file to verify:```suggestion  if findany(lines, { '^; <<>> DiG [0-9%.]+.* <<>>', '%$ORIGIN', '%$TTL', 'IN%s+SOA' }) then```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18623,878435021,2022-05-20T18:24:00Z,runtime/lua/vim/filetype/detect.lua,"@@ -787,9 +862,67 @@ function M.scd(bufnr)   end end -function M.sh(path, bufnr) end+-- Also called from filetype.lua+function M.sh(path, bufnr, name)","In contradiction to the general rule, I think we can use case *sensitive* regexes (i.e. remove `\c`) in this function, because:1) a lot of times the `name` argument is being passed directly from `filetype.lua`, where we know the value is lower case2) the rest of the cases come from a shebang line, which we know will be lower case (I guess *technically* on a case insensitive filesystem like macOS someone could use an uppercase shebang, but I don't care about supporting that kind of madness)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18665,878630619,2022-05-21T02:19:07Z,test/functional/ui/input_spec.lua,"@@ -406,6 +406,78 @@ describe('input non-printable chars', function()   end) end) +describe('skip do you really want to write on force write', function()+  after_each(function()+    os.remove('Xtest-overwrite-forced')+  end)++  it(""does not ask for confirmation when force write"", function()+    write_file(""Xtest-overwrite-forced"", [[foobar]])+    local screen = Screen.new(60,8)","tests can be much less verbose by using a smaller screen where there's not much need for a big screen.```suggestion    local screen = Screen.new(40,4)```Not sure if screen tests are really appropriate for this feature, but at least you wrote tests :D",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18650,878633350,2022-05-21T02:52:02Z,src/nvim/screen.c,"@@ -5332,11 +5333,29 @@ static void win_redr_custom(win_T *wp, bool draw_winbar, bool draw_ruler)     attr = (wp == curwin) ? HL_ATTR(HLF_WBR) : HL_ATTR(HLF_WBRNC);     maxwidth = wp->w_width_inner;     use_sandbox = was_set_insecurely(wp, ""winbar"", 0);++    if (wp->w_winbar_height && wp->w_winbar_click_defs_size < (size_t)maxwidth) {",a terse comment can help a lot when reading these big walls of code.```suggestion    // prepare clickable areas (?)    if (wp->w_winbar_height && wp->w_winbar_click_defs_size < (size_t)maxwidth) {```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18690,878840203,2022-05-22T10:54:27Z,src/nvim/mbyte.c,"@@ -1048,11 +1054,13 @@ bool utf_printable(int c) {   // Sorted list of non-overlapping intervals.   // 0xd800-0xdfff is reserved for UTF-16, actually illegal.+  // 0x10FFFF is the last valid codepoints, all values above that+  // must be escaped.   static struct interval nonprint[] =   {     { 0x070f, 0x070f }, { 0x180b, 0x180e }, { 0x200b, 0x200f }, { 0x202a, 0x202e },     { 0x2060, 0x206f }, { 0xd800, 0xdfff }, { 0xfeff, 0xfeff }, { 0xfff9, 0xfffb },-    { 0xfffe, 0xffff }+    { 0xfffe, 0xffff }, { 0x110000, 0x8fffffff },","`interval` is two `long`s, on platforms with 32-bit `long` it is limited to `0x7fffffff`, so `0x8fffffff` will overflow and become a negative number?",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/18631,878849221,2022-05-22T11:52:48Z,runtime/lua/vim/lsp.lua,"@@ -662,6 +663,30 @@ function lsp.client()   error() end +--- Starts a new client or re-uses an existing client and attaches the current+--- buffer to it.+---+---@param config table Same configuration as documented in |lsp.start_client()|+---@param reuse_client nil|fun(client: table): boolean Function used to decide+--- if a client should be re-used. All running clients are tested. Starts a new+--- client if nothing matches. If `nil` clients that share the same name and+--- same `root_dir` are re-used+function lsp.start_or_attach(config, reuse_client)+  reuse_client = reuse_client+    or function(client)+      return client.config.root_dir == config.root_dir and client.name == config.name","wouldn't it be better if this already uses the streamline approach of `workspace_folders`? since `root_dir` is more or less a utility wrapper around it, imohttps://github.com/neovim/nvim-lspconfig/blob/9e6bcf5a8915e8423d5cc7f82c5069c11272184d/lua/lspconfig/configs.lua#L195-L201",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/17090,878852240,2022-05-22T12:15:42Z,.busted,"@@ -0,0 +1,39 @@+-- vim: ft=lua tw=80 sw=2 ts=2++return {+  _all = {+    verbose = true,+    lazy = true,+    helper = ""test/functional/preload.lua"",+    lpath = ""build/?.lua;runtime/lua/?.lua;./?.lua"",+    output = ""test.busted.outputHandlers.nvim"",+  },+  ---+  functional = { ROOT = { ""test/functional"" } },+  ---+  apiFunc = { ROOT = { ""test/functional/api"" } },","> something that I've made clear numerous times before, e.g. [#15708 (review)](https://github.com/neovim/neovim/pull/15708#pullrequestreview-758064590)I'm trying to remove the dependency on `make`, but also cleanup the interface of `cmake`> This is an extra layer of configuration that gains nothing. And it moves knowledge out of cmake, which is the wrong directionCurrently there's a lot of overlap between `cmake/RunTests.cmake` and `helpers.lua`, and then some options use cmake vars and some rely on env vars.Using a busted configuration file will helps us track (and override) all variables in a centralized manner, see `--Xhelper OPTIONS`, without repeating the default options that are already set in `.busted` or the helper.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17090,878861540,2022-05-22T13:23:32Z,.busted,"@@ -0,0 +1,39 @@+-- vim: ft=lua tw=80 sw=2 ts=2++return {+  _all = {+    verbose = true,+    lazy = true,+    helper = ""test/functional/preload.lua"",+    lpath = ""build/?.lua;runtime/lua/?.lua;./?.lua"",+    output = ""test.busted.outputHandlers.nvim"",+  },+  ---+  functional = { ROOT = { ""test/functional"" } },+  ---+  apiFunc = { ROOT = { ""test/functional/api"" } },","> I'm trying to remove the dependency on make, but also cleanup the interface of cmakeWhat dependency? Nothing is dependent on make. `cmake -C build unittest` already works.And the makefile isn't going away, so again, adding new layers is not wanted.> have you seen https://github.com/neovim/neovim/pull/18674?yes, and still see no reason to add this extra layer.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/17090,878864094,2022-05-22T13:42:03Z,.busted,"@@ -0,0 +1,39 @@+-- vim: ft=lua tw=80 sw=2 ts=2++return {+  _all = {+    verbose = true,+    lazy = true,+    helper = ""test/functional/preload.lua"",+    lpath = ""build/?.lua;runtime/lua/?.lua;./?.lua"",+    output = ""test.busted.outputHandlers.nvim"",+  },+  ---+  functional = { ROOT = { ""test/functional"" } },+  ---+  apiFunc = { ROOT = { ""test/functional/api"" } },","> What dependency? Nothing is dependent on makethat part is regarding the docs ���� > yes, and still see no reason to add this extra layer.I still don't get how this is a new layer.I'm hoping to consolidate the split between `cmake/RunTests.cmake` and `helpers.lua`, where each of those can toggle a few configuration, but not all https://github.com/neovim/neovim/blob/e7b3fd8ad603ba064ce9457a8866430c436c3737/cmake/RunTests.cmake#L9-L21vshttps://github.com/neovim/neovim/blob/e7b3fd8ad603ba064ce9457a8866430c436c3737/test/functional/helpers.lua#L31-L46isn't it better to make full use of busted, which is already used and isn't going anywhere, and reduce the instances where we're  shoe-horning CMake into configuring **both** the test-environment **and** the test-suit? that's what I'm trying to achieve here. worse-case is we learn the requirements to run busted for tests that don't require RPC, and try to configure them all in `helpers.lua`, or learn what the blocker is.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17090,878864703,2022-05-22T13:46:54Z,.busted,"@@ -0,0 +1,39 @@+-- vim: ft=lua tw=80 sw=2 ts=2++return {+  _all = {+    verbose = true,+    lazy = true,+    helper = ""test/functional/preload.lua"",+    lpath = ""build/?.lua;runtime/lua/?.lua;./?.lua"",+    output = ""test.busted.outputHandlers.nvim"",+  },+  ---+  functional = { ROOT = { ""test/functional"" } },+  ---+  apiFunc = { ROOT = { ""test/functional/api"" } },","> isn't it better to make full use of busted, which is already used and isn't going anywhere,`helpers.lua` also isn't going anywhere. Several of your PRs have turned about to be a ""solution in search of a problem"", and I don't want to spend more time on such PRs. So I am skeptical about other similar changes. ""Making full use of busted"" means nothing. You need to present a clear case, in one short sentence, about the actual problem that is being solved. Not ""it would be nice"".> I still don't get how this is a new layer.It's a new configuration file where knowledge lives, a new concept that we might need to document, etc. It also adds a bunch of aliases that are basically useless. So we now have ""N+1 ways of doing things"".",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18631,878875471,2022-05-22T14:14:46Z,runtime/doc/lsp.txt,"@@ -954,6 +954,20 @@ start_client({config})                                *vim.lsp.start_client()*                     not be fully initialized. Use `on_init` to do any actions                     once the client has been initialized. +start_or_attach({config}, {reuse_client})          *vim.lsp.start_or_attach()*",The name is awkward because it should just be a  parameter on `start_client` :),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18650,878876444,2022-05-22T14:21:31Z,src/nvim/screen.c,"@@ -5672,19 +5704,19 @@ void screenalloc(void)   resizing = false; } -/// Clear tab_page_click_defs table+/// Clear status line, window bar or tab page line click definition table /// /// @param[out]  tpcd  Table to clear. /// @param[in]  tpcd_size  Size of the table.-void clear_tab_page_click_defs(StlClickDefinition *const tpcd, const long tpcd_size)+void clear_click_defs(StlClickDefinition *const click_defs, const long click_defs_size)","common prefixes are very helpful. without ""stl"" it's not clear that this is for statuslines.```suggestionvoid stl_clear_click_defs(StlClickDefinition *const click_defs, const long click_defs_size)```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18665,878878452,2022-05-22T14:36:16Z,test/functional/ui/input_spec.lua,"@@ -406,6 +406,61 @@ describe('input non-printable chars', function()   end) end) +describe('skip do you really want to write on force write', function()+  after_each(function()+    os.remove('Xtest-overwrite-forced')+  end)++  it(""does not ask for confirmation when force write"", function()+    write_file(""Xtest-overwrite-forced"", [[foobar]])+    local screen = Screen.new(40,4)+    screen:set_default_attr_ids({+      [1] = {bold = true, foreground = Screen.colors.Blue1},+      [2] = {foreground = Screen.colors.Grey100, background = Screen.colors.Red},+      [3] = {bold = true, foreground = Screen.colors.SeaGreen4}+    })+    screen:attach()+    command(""set display-=msgsep shortmess-=F"")++    feed_command(""e Xtest-overwrite-forced"")+    screen:expect([[+      ^foobar                                  |+      {1:~                                       }|+      {1:~                                       }|+      ""Xtest-overwrite-forced"" [noeol] 1L, 6B |+    ]])++    -- The timestamp is in second resolution, wait two seconds to be sure.+    screen:sleep(2000)","The test could be a lot faster by manually changing the time via `utime`:https://github.com/luvit/luv/blob/master/docs.md#uvfs_utimepath-atime-mtime-callback    helpers.nvim_exec_lua([[vim.loop.fs_utime('Xtest-overwrite-forced', 999999999, 999999999)]])This is worth the trouble to save 2 seconds. If all of our tests took 1 second, the test suite would take 1.1 hours to run.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18623,878892696,2022-05-22T16:03:59Z,runtime/lua/vim/filetype.lua,"@@ -1680,24 +1680,27 @@ local pattern = {       return 'git'     end   end,-  ['.*%.[Cc][Ff][Gg]'] = function(path, bufnr)-    require('vim.filetype.detect').cfg(bufnr)-  end,+  ['.*%.[Cc][Ff][Gg]'] = {+    function(path, bufnr)+      return require('vim.filetype.detect').cfg(bufnr)+    end,+    { priority = -1 },","Can you leave a comment why this is needed (even if it's just reference which other filetypes this pattern ""competes"" with, it's useful knowledge to avoid a Chesterton's Fence situation).",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18631,878907006,2022-05-22T18:13:32Z,runtime/doc/lsp.txt,"@@ -954,6 +954,20 @@ start_client({config})                                *vim.lsp.start_client()*                     not be fully initialized. Use `on_init` to do any actions                     once the client has been initialized. +start_or_attach({config}, {reuse_client})          *vim.lsp.start_or_attach()*+                Starts a new client or re-uses an existing client and attaches+                the current buffer to it.++                Parameters: ~+                    {config}        (table) Same configuration as documented+                                    in |lsp.start_client()|+                    {reuse_client}  nil|fun(client: table): boolean Function","It also attaches the current buffer. We'd probably have to add two parameters to `start_client`, `reuse_client` and `(auto)attach = true|false` to keep the existing behavior by default. And then users would have to add an explicit `attach = true` to their configuration to opt into the new behavior. I'm not sure that would be an improvement over this. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18703,878914265,2022-05-22T19:20:08Z,runtime/lua/vim/lsp/rpc.lua,"@@ -4,6 +4,8 @@ local log = require('vim.lsp.log') local protocol = require('vim.lsp.protocol') local validate, schedule, schedule_wrap = vim.validate, vim.schedule, vim.schedule_wrap +local is_win = uv.os_uname().version:find('Windows')","just for reference, a clever way that is common in Lua, that we use elsewhere:https://github.com/neovim/neovim/blob/63741176ce9bf576ee9693b93844e1cbcf0420b2/test/helpers.lua#L262-L264",
31444858,lorlouis,https://api.github.com/repos/neovim/neovim/pulls/18665,878926423,2022-05-22T21:11:55Z,test/functional/ui/input_spec.lua,"@@ -406,6 +406,61 @@ describe('input non-printable chars', function()   end) end) +describe('skip do you really want to write on force write', function()+  after_each(function()+    os.remove('Xtest-overwrite-forced')+  end)++  it(""does not ask for confirmation when force write"", function()+    write_file(""Xtest-overwrite-forced"", [[foobar]])+    local screen = Screen.new(40,4)+    screen:set_default_attr_ids({+      [1] = {bold = true, foreground = Screen.colors.Blue1},+      [2] = {foreground = Screen.colors.Grey100, background = Screen.colors.Red},+      [3] = {bold = true, foreground = Screen.colors.SeaGreen4}+    })+    screen:attach()+    command(""set display-=msgsep shortmess-=F"")++    feed_command(""e Xtest-overwrite-forced"")+    screen:expect([[+      ^foobar                                  |+      {1:~                                       }|+      {1:~                                       }|+      ""Xtest-overwrite-forced"" [noeol] 1L, 6B |+    ]])++    -- The timestamp is in second resolution, wait two seconds to be sure.+    screen:sleep(2000)+    write_file(""Xtest-overwrite-forced"", [[smurf]])+    feed_command(""w"")+    screen:expect([[+      {2:WARNING: The file has been changed since}|+      {2: reading it!!!}                          |+      {3:Do you really want to write to it (y/n)^?}|+                                              |+    ]])++    feed(""n"")+    feed(""<cr>"")+    screen:expect([[+      ^foobar                                  |+      {1:~                                       }|+      {1:~                                       }|+                                              |+    ]])++    feed(""w!"")+    screen:expect([[+      fooba^r                                  |+      {1:~                                       }|+      {1:~                                       }|+                                              |+    ]])+    feed(""n"")","I accidentally called feed() instead of feed_command(). When calling the proper method, the screens differ.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18547,878928061,2022-05-22T21:28:11Z,runtime/doc/index.txt,"@@ -1068,7 +1066,7 @@ tag		command		action in Command-line editing mode	~ |c_<Esc>|	<Esc>		abandon command-line without executing it |c_CTRL-[|	CTRL-[		same as <Esc> |c_CTRL-\_CTRL-N| CTRL-\ CTRL-N	go to Normal mode, abandon command-line-|c_CTRL-\_CTRL-G| CTRL-\ CTRL-G	go to mode specified with 'insertmode',+|c_CTRL-\_CTRL-G| CTRL-\ CTRL-G	go to Normal mode, abandon command-line 				abandon command-line","duplicate, remove?",X
5308024,andmis,https://api.github.com/repos/neovim/neovim/pulls/18674,879575061,2022-05-23T15:12:41Z,test/CMakeLists.txt,"@@ -0,0 +1,149 @@+add_subdirectory(includes)++get_property(+  TEST_INCLUDE_DIRS DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}+  PROPERTY INCLUDE_DIRECTORIES+)++# When running tests from 'ninja' we need to use the+# console pool: to do so we need to use the USES_TERMINAL+# option, but this is only available in CMake 3.2+set(TEST_TARGET_ARGS)+list(APPEND TEST_TARGET_ARGS ""USES_TERMINAL"")++set(UNITTEST_PREREQS nvim nvim-test unittest-headers)+set(FUNCTIONALTEST_PREREQS nvim printenv-test printargs-test shell-test streams-test tty-test ${GENERATED_HELP_TAGS})+set(BENCHMARK_PREREQS nvim tty-test)++# Useful for automated build systems, if they want to manually run the tests.+add_custom_target(+  unittest-prereqs+  DEPENDS ${UNITTEST_PREREQS}+)+set_target_properties(unittest-prereqs PROPERTIES FOLDER test)++add_custom_target(+  functionaltest-prereqs+  DEPENDS ${FUNCTIONALTEST_PREREQS}+)++add_custom_target(+  benchmark-prereqs+  DEPENDS ${BENCHMARK_PREREQS}+)++check_lua_module(${LUA_PRG} ""ffi"" LUA_HAS_FFI)+if(LUA_HAS_FFI)+  add_custom_target(+    unittest+    COMMAND ${CMAKE_COMMAND}+    -DBUSTED_PRG=${BUSTED_PRG}+    -DLUA_PRG=${LUA_PRG}+    -DWORKING_DIR=${CMAKE_CURRENT_SOURCE_DIR}+    -DBUSTED_OUTPUT_TYPE=${BUSTED_OUTPUT_TYPE}+    -DTEST_DIR=${CMAKE_CURRENT_SOURCE_DIR}/test+    -DBUILD_DIR=${CMAKE_BINARY_DIR}+    -DTEST_TYPE=unit+    -P ${PROJECT_SOURCE_DIR}/cmake/RunTests.cmake+    DEPENDS ${UNITTEST_PREREQS}","Shouldn't you just depend on the `unittest-prereqs` target here? And in that case the three local variables `[UNITTEST|FUNCTIONALTEST|BENCHMARK]_PREREQS` are not actually needed, the lists of prereqs can be inlined in the `add_custom_target` calls.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18515,882435466,2022-05-26T08:20:25Z,test/functional/core/job_spec.lua,"@@ -23,6 +23,9 @@ local expect_msg_seq = helpers.expect_msg_seq local pcall_err = helpers.pcall_err local Screen = require('test.functional.ui.screen') +local run_test = false++if run_test then",I know. But these tests are just flaky. They do not always fail. If you always skip them then accidental regressions may happen and go unnoticed.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/18743,882525791,2022-05-26T10:18:06Z,src/nvim/api/private/helpers.c,"@@ -1039,6 +1039,45 @@ Object copy_object(Object obj)   } } +int get_option_value_for(char *key, long *numval, char **stringval, int opt_flags, int opt_type,",This is *very* similar to `set_option_value_for`. Is there any reasonable way we can unify them?,X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/18743,882527100,2022-05-26T10:19:55Z,src/nvim/api/vim.c,"@@ -737,9 +738,44 @@ Object nvim_get_option_value(String name, Dict(option) *opts, Error *err)     goto end;   } +  int opt_type = SREQ_GLOBAL;+  void *from = NULL;++  if (opts->win.type == kObjectTypeInteger) {","Again, the argument validation is quite similar to `nvim_set_option_value`. Can we unify?",X
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/8519,882809937,2022-05-26T15:37:08Z,src/nvim/log.c,"@@ -284,13 +287,17 @@ static bool v_do_log_to_file(FILE *log_file, int log_level, const char *context,                              va_list args)   FUNC_ATTR_PRINTF(7, 0) {+  // Name of the Nvim instance that produced the log.+  // TODO(justinmk): introduce v:name?+  static char name[16] = { 0 };+   static const char *log_levels[] = {","I think it would be useful to define this list globally, so it can be re-used by the lua loggerhttps://github.com/neovim/neovim/blob/497046466e4a969cefce5fc2b7992dde157aa1a5/runtime/lua/vim/_editor.lua#L56-L65and on that note, maybe it would then make sense to keep the name more verbose, e.g. `LOG_LEVEL_x`, to keep the two loggers more in sync.",X
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18219,882880318,2022-05-26T16:55:01Z,runtime/lua/vim/filetype/detect.lua,"@@ -869,6 +869,85 @@ function M.y(bufnr)   vim.bo[bufnr].filetype = 'yacc' end +function M.decl(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 3)) do+    if line:lower():find('^<!sgml') then+      vim.bo[bufnr].filetype = 'sgmldecl'+      return+    end+  end+end++function M.dcl(bufnr)+  for _, line in ipairs(getlines(bufnr, 1, 3)) do+    if line:lower():find('^<!sgml') then+      vim.bo[bufnr].filetype = 'sgmldecl'+      return+    end+  end+  vim.bo[bufnr].filetype = 'clean'+end","No need to duplicate, use one function but in the `dcl` function in `filetype.lua` simply add `return ""clean""` if `require('vim.filetype.detect').decl()` returns `nil`.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18515,883899602,2022-05-27T18:46:17Z,test/functional/helpers.lua,"@@ -719,6 +724,19 @@ function module.pending_win32(pending_fn)   end end +-- Helper to skip tests. Returns true in FreeBSD systems.+-- pending_fn is pending() from busted+function module.pending_freebsd(pending_fn)","we need to try to avoid introducing more of this kind of thing. we have `skip_fragile` already. We could use that, and define `TEST_SKIP_FRAGILE` on sourcehut :(https://github.com/neovim/neovim/blob/ac73f75fc0073db3e0bb1c0c2758b3dc34a3ed51/test/functional/helpers.lua#L737",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18515,883902445,2022-05-27T18:49:45Z,test/functional/core/job_spec.lua,"@@ -1,3 +1,4 @@+local global_helpers = require('test.helpers')","never needed, because test.helpers is already merged-into functional.test.helpers:https://github.com/neovim/neovim/blob/ac73f75fc0073db3e0bb1c0c2758b3dc34a3ed51/test/functional/helpers.lua#L869",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18515,883906865,2022-05-27T18:55:40Z,test/functional/ui/messages_spec.lua,"@@ -1117,7 +1118,11 @@ vimComment     xxx match /\s""[^\-:.%#=*].*$/ms=s+1,lc=1  excludenl contains=@vim   end) end) +-- FIXME(dundar): Flaky set of tests. I suspect the before_each is faulty and that it infects all+-- tests in the describe block.+if global_helpers.isCI('sourcehut') then describe('ui/ext_messages', function()+  pending(""Flaky set of tests. The before_each function may be broken."", function() end)",skip_fragile. Also don't need the isCI() condition (which looks like it should be flipped anyway?),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/8519,883922510,2022-05-27T19:22:07Z,src/nvim/log.c,"@@ -284,13 +287,17 @@ static bool v_do_log_to_file(FILE *log_file, int log_level, const char *context,                              va_list args)   FUNC_ATTR_PRINTF(7, 0) {+  // Name of the Nvim instance that produced the log.+  // TODO(justinmk): introduce v:name?+  static char name[16] = { 0 };+   static const char *log_levels[] = {","> , is it not possible to set `vim.log.levels` through `src/nvim/lua/stdlib.c`? sorry if it's a stupid question :)could, but not worth the extra code. once we have a public interface, the log levels will be covered by tests, so the small amount of duplication is less costly than the extra code.",X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18770,884007965,2022-05-27T22:12:12Z,runtime/doc/vim_diff.txt,"@@ -567,6 +574,7 @@ Options:   *'toolbar'* *'tb'*   *'toolbariconsize'* *'tbis'*   *'ttybuiltin'* *'tbi'* *'nottybuiltin'* *'notbi'*+  *'ttyfast'* *'tf'* *'nottyfast'* *'notf'*",duplicate below,X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18770,884008395,2022-05-27T22:13:54Z,runtime/doc/vim_diff.txt,"@@ -551,6 +554,10 @@ Options:       nnoremap <Esc> i <   *'macatsui'*+  *'maxcombine'* *'mco'*",duplicate below,X
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/18515,884106187,2022-05-28T09:11:17Z,test/functional/ui/messages_spec.lua,"@@ -1117,7 +1118,11 @@ vimComment     xxx match /\s""[^\-:.%#=*].*$/ms=s+1,lc=1  excludenl contains=@vim   end) end) +-- FIXME(dundar): Flaky set of tests. I suspect the before_each is faulty and that it infects all+-- tests in the describe block.+if global_helpers.isCI('sourcehut') then describe('ui/ext_messages', function()+  pending(""Flaky set of tests. The before_each function may be broken."", function() end)",>  Also don't need the isCI() conditionI think we do. `pending` doesn't work inside describe blocks.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18461,884141966,2022-05-28T14:31:03Z,src/nvim/ex_docmd.c,"@@ -4519,13 +4519,13 @@ static linenr_T get_address(exarg_T *eap, char **ptr, cmd_addr_T addr_type, int           (void)hasFolding(lnum, NULL, &lnum);         }         if (i == '-') {-          lnum -= n;+          lnum -= (linenr_T)n;",`n` is `long` and may overflow here,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/18787,884184387,2022-05-28T22:20:26Z,cmake/RunTests.cmake,"@@ -12,6 +12,12 @@ set(ENV{XDG_CONFIG_HOME} ${BUILD_DIR}/Xtest_xdg/config) set(ENV{XDG_DATA_HOME} ${BUILD_DIR}/Xtest_xdg/share) unset(ENV{XDG_DATA_DIRS}) +# Test being run inside neovim :terminal unset inherited environment variables.+if(DEFINED ENV{NVIM})+  unset(ENV{NVIM_LOG_FILE})",Shouldn't this be checked/cleared independently?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18787,884191155,2022-05-28T23:58:10Z,cmake/RunTests.cmake,"@@ -12,6 +12,12 @@ set(ENV{XDG_CONFIG_HOME} ${BUILD_DIR}/Xtest_xdg/config) set(ENV{XDG_DATA_HOME} ${BUILD_DIR}/Xtest_xdg/share) unset(ENV{XDG_DATA_DIRS}) +# Test being run inside neovim :terminal unset inherited environment variables.+if(DEFINED ENV{NVIM})+  unset(ENV{NVIM_LOG_FILE})+  unset(ENV{NVIM})",this can be  done unconditionally,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18678,884299685,2022-05-29T17:06:22Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -513,25 +513,45 @@ function LanguageTree:register_cbs(cbs)   end end +---Determine whether {inner} is completely inside {outer} (inner=outer -> true).+---@param outer range+---@param inner range+---@return boolean ---@private-local function tree_contains(tree, range)-  local start_row, start_col, end_row, end_col = tree:root():range()-  local start_fits = start_row < range[1] or (start_row == range[1] and start_col <= range[2])-  local end_fits = end_row > range[3] or (end_row == range[3] and end_col >= range[4])+local function range_contains(outer, inner)+  local start_row, start_col, end_row, end_col = unpack(outer)+  local start_fits = start_row < inner[1] or (start_row == inner[1] and start_col <= inner[2])+  local end_fits = end_row > inner[3] or (end_row == inner[3] and end_col >= inner[4]) -  return start_fits and end_fits+  if start_fits and end_fits then+    return true+  end++  return false end  --- Determines whether {range} is contained in this language tree --- ---@param range A range, that is a `{ start_line, start_col, end_line, end_col }` table. function LanguageTree:contains(range)-  for _, tree in pairs(self._trees) do-    if tree_contains(tree, range) then-      return true+  -- Insp(range)+  for _, region in ipairs(self._regions) do+    for _, node_range in ipairs(region) do+      -- node_range is either node (userdata) or six-tuple as set in+      -- |LanguageTree:set_included_regions|.+      local region_range+      if type(node_range) == ""table"" then+        -- omit byte-offset of start/end-position.+        region_range = {node_range[1], node_range[2], node_range[4], node_range[5]}","~~Why use different structures at all and not just work with `range` or `region`, depending on what data you need?~~I think `region_range` is a bit unfortunate in principle -- is it a `region` or a `range`? -- but the use is probably clear from the context. Maybe `tree_range` for the local range? Otherwise it's OK with me.",X
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/18678,884302087,2022-05-29T17:28:44Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -513,25 +513,45 @@ function LanguageTree:register_cbs(cbs)   end end +---Determine whether {inner} is completely inside {outer} (inner=outer -> true).+---@param outer range+---@param inner range+---@return boolean ---@private-local function tree_contains(tree, range)-  local start_row, start_col, end_row, end_col = tree:root():range()-  local start_fits = start_row < range[1] or (start_row == range[1] and start_col <= range[2])-  local end_fits = end_row > range[3] or (end_row == range[3] and end_col >= range[4])+local function range_contains(outer, inner)+  local start_row, start_col, end_row, end_col = unpack(outer)+  local start_fits = start_row < inner[1] or (start_row == inner[1] and start_col <= inner[2])+  local end_fits = end_row > inner[3] or (end_row == inner[3] and end_col >= inner[4]) -  return start_fits and end_fits+  if start_fits and end_fits then+    return true+  end++  return false end  --- Determines whether {range} is contained in this language tree --- ---@param range A range, that is a `{ start_line, start_col, end_line, end_col }` table. function LanguageTree:contains(range)-  for _, tree in pairs(self._trees) do-    if tree_contains(tree, range) then-      return true+  -- Insp(range)+  for _, region in ipairs(self._regions) do+    for _, node_range in ipairs(region) do+      -- node_range is either node (userdata) or six-tuple as set in+      -- |LanguageTree:set_included_regions|.+      local region_range+      if type(node_range) == ""table"" then+        -- omit byte-offset of start/end-position.+        region_range = {node_range[1], node_range[2], node_range[4], node_range[5]}","I think ""region"" should be ok as it is the data structure applied to `set_included_regions`",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18678,884302104,2022-05-29T17:29:04Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -513,25 +513,45 @@ function LanguageTree:register_cbs(cbs)   end end +---Determine whether {inner} is completely inside {outer} (inner=outer -> true).+---@param outer range+---@param inner range+---@return boolean ---@private-local function tree_contains(tree, range)-  local start_row, start_col, end_row, end_col = tree:root():range()-  local start_fits = start_row < range[1] or (start_row == range[1] and start_col <= range[2])-  local end_fits = end_row > range[3] or (end_row == range[3] and end_col >= range[4])+local function range_contains(outer, inner)+  local start_row, start_col, end_row, end_col = unpack(outer)+  local start_fits = start_row < inner[1] or (start_row == inner[1] and start_col <= inner[2])+  local end_fits = end_row > inner[3] or (end_row == inner[3] and end_col >= inner[4]) -  return start_fits and end_fits+  if start_fits and end_fits then+    return true+  end++  return false end  --- Determines whether {range} is contained in this language tree --- ---@param range A range, that is a `{ start_line, start_col, end_line, end_col }` table. function LanguageTree:contains(range)-  for _, tree in pairs(self._trees) do-    if tree_contains(tree, range) then-      return true+  -- Insp(range)+  for _, region in ipairs(self._regions) do+    for _, node_range in ipairs(region) do+      -- node_range is either node (userdata) or six-tuple as set in+      -- |LanguageTree:set_included_regions|.+      local region_range+      if type(node_range) == ""table"" then+        -- omit byte-offset of start/end-position.+        region_range = {node_range[1], node_range[2], node_range[4], node_range[5]}",It's just about the naming. I think it's much better now; let's see if someone else has a better suggestion.,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/18777,884305016,2022-05-29T17:55:37Z,src/nvim/api/buffer.c,"@@ -1137,12 +1137,16 @@ Boolean nvim_buf_is_loaded(Buffer buffer)   return buf && buf->b_ml.ml_mfp != NULL; } -/// Deletes the buffer. See |:bwipeout|+/// Deletes the buffer. /// /// @param buffer Buffer handle, or 0 for current buffer /// @param opts  Optional parameters. Keys: ///          - force:  Force deletion and ignore unsaved changes.-///          - unload: Unloaded only, do not delete. See |:bunload|+///          - action: (default: ""wipeout"")",I was going off based on the name of the enum https://github.com/neovim/neovim/blob/081eb72a80afd83398465382171765bdeaf6dba5/src/nvim/buffer.h#L39-L46,
41961280,L3MON4D3,https://api.github.com/repos/neovim/neovim/pulls/18678,884306002,2022-05-29T18:05:30Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -513,25 +513,45 @@ function LanguageTree:register_cbs(cbs)   end end +---Determine whether {inner} is completely inside {outer} (inner=outer -> true).+---@param outer range+---@param inner range+---@return boolean ---@private-local function tree_contains(tree, range)-  local start_row, start_col, end_row, end_col = tree:root():range()-  local start_fits = start_row < range[1] or (start_row == range[1] and start_col <= range[2])-  local end_fits = end_row > range[3] or (end_row == range[3] and end_col >= range[4])+local function range_contains(outer, inner)+  local start_row, start_col, end_row, end_col = unpack(outer)+  local start_fits = start_row < inner[1] or (start_row == inner[1] and start_col <= inner[2])+  local end_fits = end_row > inner[3] or (end_row == inner[3] and end_col >= inner[4]) -  return start_fits and end_fits+  if start_fits and end_fits then+    return true+  end++  return false end  --- Determines whether {range} is contained in this language tree --- ---@param range A range, that is a `{ start_line, start_col, end_line, end_col }` table. function LanguageTree:contains(range)-  for _, tree in pairs(self._trees) do-    if tree_contains(tree, range) then-      return true+  -- Insp(range)+  for _, region in ipairs(self._regions) do+    for _, node_range in ipairs(region) do+      -- node_range is either node (userdata) or six-tuple as set in+      -- |LanguageTree:set_included_regions|.+      local region_range+      if type(node_range) == ""table"" then+        -- omit byte-offset of start/end-position.+        region_range = {node_range[1], node_range[2], node_range[4], node_range[5]}","I'd be fine with `region_contains` instead of `range_contains`, whichever you prefer :)(that routine is only used in `contains`, so no big difference I'd say)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18219,884909416,2022-05-30T14:53:53Z,runtime/lua/vim/filetype.lua,"@@ -1009,6 +1036,144 @@ local extension = {       return 'text'     end   end,+  cmd = function(path, bufnr)+    if getline(bufnr, 1):find('^/%*') then+      return 'rexx'+    end+    return 'dosbatch'+  end,+  rul = function(path, bufnr)+    return require('vim.filetype.detect').rul(bufnr)+  end,+  cpy = function(path, bufnr)+    if getline(bufnr, 1):find('^##') then+      return 'python'+    end+    return 'cobol'+  end,+  dsl = function(path, bufnr)+    if getline(bufnr, 1):find('^%s*<!') then+      return 'dsl'+    end+    return 'structurizr'+  end,+  edf = 'edif',+  edfi = 'edif',+  edo = 'edif',+  edn = function(path, bufnr)+    return require('vim.filetype.detect').edn(bufnr)+  end,+  smil = function(path, bufnr)+    if getline(bufnr, 1):find('<%?%s*xml.*%?>') then+      return 'xml'+    end+    return 'smil'+  end,+  smi = function(path, bufnr)+    return require('vim.filetype.detect').smi(bufnr)+  end,+  install = function(path, bufnr)+    if getline(bufnr, 1):lower():find('<%?php') then+      return 'php'+    end+    return require('vim.filetype.detect').sh(path, bufnr, 'bash')+  end,+  pm = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find('XPM2') then+      return 'xpm2'+    elseif line:find('XPM') then+      return 'xpm'+    else+      return 'perl'+    end+  end,+  me = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, ':t'):lower()+    if filename ~= 'read.me' and filename ~= 'click.me' then+      return 'nroff'+    end+  end,+  reg = function(path, bufnr)+    local line = getline(bufnr, 1):lower()+    if line:find('^regedit[0-9]*%s*$') or line:find('^windows registry editor version %d*%.%d*%s*$') then+      return 'registry'+    end+  end,+  decl = function(path, bufnr)+    return require('vim.filetype.detect').decl(bufnr)+  end,+  dec = function(path, bufnr)+    return require('vim.filetype.detect').decl(bufnr)+  end,+  dcl = function(path, bufnr)+    local decl = require('vim.filetype.detect').decl(bufnr)+    if decl then+      return decl+    end+    return 'clean'+  end,+  web = function(path, bufnr)+    return require('vim.filetype.detect').web(bufnr)+  end,+  ttl = function(path, bufnr)+    local line = getline(bufnr, 1):lower()+    if line:find('^@?prefix') or line:find('^@?base') then+      return 'turtle'+    end+    return 'teraterm'+  end,+  am = function(path, bufnr)+    if not path:lower():find('makefile%.am$') then+      return 'elf'+    end+  end,+  ['m4'] = function(path, bufnr)+    local path_lower = path:lower()+    if not path_lower:find('html%.m4$') and not path_lower:find('fvwm2rc') then+      return 'm4'+    end+  end,+  hw = function(path, bufnr)+    return require('vim.filetype.detect').hw(bufnr)+  end,+  module = function(path, bufnr)+    return require('vim.filetype.detect').hw(bufnr)+  end,+  pkg = function(path, bufnr)+    return require('vim.filetype.detect').hw(bufnr)+  end,+  ms = function(path, bufnr)+    if not require('vim.filetype.detect').nroff(bufnr) then+      return 'xmath'+    end+  end,+  t = function(path, bufnr)+    if not require('vim.filetype.detect').nroff(bufnr) and not require('vim.filetype.detect').perl(path, bufnr) then+      return 'tads'+    end+  end,+  class = function(path, bufnr)+    if not getline(bufnr, 1):find('^\202\254\186\190') then","Maybe add a comment here as this is not super obvious:```suggestion    -- Check if not a Java class (starts with '\xca\xfe\xba\xbe')    if not getline(bufnr, 1):find('^\202\254\186\190') then```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18219,884909418,2022-05-30T14:53:53Z,runtime/lua/vim/filetype.lua,"@@ -1009,6 +1036,144 @@ local extension = {       return 'text'     end   end,+  cmd = function(path, bufnr)+    if getline(bufnr, 1):find('^/%*') then+      return 'rexx'+    end+    return 'dosbatch'+  end,+  rul = function(path, bufnr)+    return require('vim.filetype.detect').rul(bufnr)+  end,+  cpy = function(path, bufnr)+    if getline(bufnr, 1):find('^##') then+      return 'python'+    end+    return 'cobol'+  end,+  dsl = function(path, bufnr)+    if getline(bufnr, 1):find('^%s*<!') then+      return 'dsl'+    end+    return 'structurizr'+  end,+  edf = 'edif',+  edfi = 'edif',+  edo = 'edif',+  edn = function(path, bufnr)+    return require('vim.filetype.detect').edn(bufnr)+  end,+  smil = function(path, bufnr)+    if getline(bufnr, 1):find('<%?%s*xml.*%?>') then+      return 'xml'+    end+    return 'smil'+  end,+  smi = function(path, bufnr)+    return require('vim.filetype.detect').smi(bufnr)+  end,+  install = function(path, bufnr)+    if getline(bufnr, 1):lower():find('<%?php') then+      return 'php'+    end+    return require('vim.filetype.detect').sh(path, bufnr, 'bash')+  end,+  pm = function(path, bufnr)+    local line = getline(bufnr, 1)+    if line:find('XPM2') then+      return 'xpm2'+    elseif line:find('XPM') then+      return 'xpm'+    else+      return 'perl'+    end+  end,+  me = function(path, bufnr)+    local filename = vim.fn.fnamemodify(path, ':t'):lower()+    if filename ~= 'read.me' and filename ~= 'click.me' then+      return 'nroff'+    end+  end,+  reg = function(path, bufnr)+    local line = getline(bufnr, 1):lower()+    if line:find('^regedit[0-9]*%s*$') or line:find('^windows registry editor version %d*%.%d*%s*$') then+      return 'registry'+    end+  end,+  decl = function(path, bufnr)+    return require('vim.filetype.detect').decl(bufnr)+  end,+  dec = function(path, bufnr)+    return require('vim.filetype.detect').decl(bufnr)+  end,+  dcl = function(path, bufnr)+    local decl = require('vim.filetype.detect').decl(bufnr)+    if decl then+      return decl+    end+    return 'clean'+  end,+  web = function(path, bufnr)+    return require('vim.filetype.detect').web(bufnr)+  end,+  ttl = function(path, bufnr)+    local line = getline(bufnr, 1):lower()+    if line:find('^@?prefix') or line:find('^@?base') then+      return 'turtle'+    end+    return 'teraterm'+  end,+  am = function(path, bufnr)+    if not path:lower():find('makefile%.am$') then+      return 'elf'+    end+  end,+  ['m4'] = function(path, bufnr)+    local path_lower = path:lower()+    if not path_lower:find('html%.m4$') and not path_lower:find('fvwm2rc') then+      return 'm4'+    end+  end,+  hw = function(path, bufnr)+    return require('vim.filetype.detect').hw(bufnr)+  end,+  module = function(path, bufnr)+    return require('vim.filetype.detect').hw(bufnr)+  end,+  pkg = function(path, bufnr)+    return require('vim.filetype.detect').hw(bufnr)+  end,+  ms = function(path, bufnr)+    if not require('vim.filetype.detect').nroff(bufnr) then+      return 'xmath'+    end+  end,+  t = function(path, bufnr)+    if not require('vim.filetype.detect').nroff(bufnr) and not require('vim.filetype.detect').perl(path, bufnr) then+      return 'tads'+    end+  end,+  class = function(path, bufnr)+    if not getline(bufnr, 1):find('^\202\254\186\190') then","Maybe add a comment here is this is not super obvious:```suggestion    -- Check if not a Java class (starts with '\xca\xfe\xba\xbe')    if not getline(bufnr, 1):find('^\202\254\186\190') then```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,885112025,2022-05-30T23:43:36Z,src/nvim/buffer_defs.h,"@@ -906,6 +906,9 @@ struct file_buffer {   int flush_count;    int b_diff_failed;    // internal diff failed for this buffer++  // Whether to not send b:changedtick for buffer updates+  bool no_send_tick;","- ""tick"" is ambiguous. Even in this structure there is `b_sst_lasttick` which is unrelated to buffer changedtick.- Using the same nonce helps with discoverability.- I'd suggest also using ""positive logic"", i.e. instead of `no_foo`, name it `foo`, and have it enabled by default.```suggestion  // Enable b:changedtick in this buffer.  bool changedtick;```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,885116403,2022-05-31T00:05:30Z,src/nvim/ex_cmds_defs.h,"@@ -91,6 +92,7 @@ typedef struct exarg exarg_T; #define BAD_DROP        (-2)    // erase it  typedef void (*ex_func_T)(exarg_T *eap);+typedef int (*ex_cmdpreview_func_T)(exarg_T *eap, long cmdpreview_ns, handle_T cmdpreview_bufnr);","- The `ex_` part already signals that this is related to commands.- Seems like the ""cmdpreview"" name (instead of ""preview"") is not being used much elsewhere in this PR.```suggestiontypedef int (*ex_func_preview_T)(exarg_T *eap, long preview_ns, handle_T preview_bufnr);```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/18583,885487094,2022-05-31T10:45:46Z,runtime/lua/vim/fs.lua,"@@ -0,0 +1,205 @@+local M = {}++--- Iterate over all the parents of the given file or directory.+---+--- Example:+--- <pre>+--- local root_dir+--- for dir in vim.fs.parents(vim.api.nvim_buf_get_name(0)) do+---   if vim.fn.isdirectory(dir .. ""/.git"") == 1 then+---     root_dir = dir+---     break+---   end+--- end+---+--- if root_dir then+---   print(""Found git repository at"", root_dir)+--- end+--- </pre>+---+---@param start (string) Initial file or directory.+---@return (function) Iterator+function M.parents(start)+  return function(_, dir)+    local parent = M.dirname(dir)+    if parent == dir then+      return nil+    end++    return parent+  end,+    nil,+    start+end++--- Return the parent directory of the given file or directory+---+---@param file (string) File or directory+---@return (string) Parent directory of {file}+function M.dirname(file)+  return vim.fn.fnamemodify(file, ':h')+end++--- Return the basename of the given file or directory+---+---@param file (string) File or directory+---@return (string) Basename of {file}+function M.basename(file)+  return vim.fn.fnamemodify(file, ':t')+end++--- Return an iterator over the files and directories located in {path}+---+---@param path (string) An absolute or relative path to the directory to iterate+---            over. The path is first normalized |vim.fs.normalize()|.+---@return Iterator over files and directories in {path}. Each iteration yields+---        two values: name and type. Each ""name"" is the basename of the file or+---        directory relative to {path}. Type is one of ""file"" or ""directory"".+function M.dir(path)+  return function(fs)+    return vim.loop.fs_scandir_next(fs)+  end, vim.loop.fs_scandir(M.normalize(path))+end++--- Find files or directories in the given path.+---+--- Finds any files or directories given in {names} starting from {path}. If+--- {upward} is ""true"" then the search traverses upward through parent+--- directories; otherwise, the search traverses downward. Note that downward+--- searches are recursive and may search through many directories! If {stop}+--- is non-nil, then the search stops when the directory given in {stop} is+--- reached. The search terminates when {limit} (default 1) matches are found.+--- The search can be narrowed to find only files or or only directories by+--- specifying {type} to be ""file"" or ""directory"", respectively.+---+---@param names (string|table) Names of the files and directories to find. Must+---             be base names, paths and globs are not supported.+---@param opts (table) Optional keyword arguments:+---                       - path (string): Path to begin searching from. If+---                              omitted, the current working directory is used.+---                       - upward (boolean, default false): If true, search+---                                upward through parent directories. Otherwise,+---                                search through child directories+---                                (recursively).+---                       - stop (string): Stop searching when this directory is+---                              reached. The directory itself is not searched.+---                       - type (string): Find only files (""file"") or+---                              directories (""directory""). If omitted, both+---                              files and directories that match {name} are+---                              included.+---                       - limit (number, default 1): Stop the search after+---                               finding this many matches. Use `math.huge` to+---                               place no limit on the number of matches.+---@return (table) The paths of all matching files or directories+function M.find(names, opts)+  opts = opts or {}+  vim.validate({+    names = { names, { 's', 't' } },+    path = { opts.path, 's', true },+    upward = { opts.upward, 'b', true },+    stop = { opts.stop, 's', true },+    type = { opts.type, 's', true },+    limit = { opts.limit, 'n', true },+  })++  names = type(names) == 'string' and { names } or names++  local path = opts.path or vim.loop.cwd()+  local stop = opts.stop+  local limit = opts.limit or 1++  local matches = {}++  ---@private+  local function add(match)+    matches[#matches + 1] = match+    if #matches == limit then+      return true+    end+  end++  if opts.upward then+    ---@private+    local function test(p)+      local t = {}+      for _, name in ipairs(names) do+        local f = p .. '/' .. name+        local stat = vim.loop.fs_stat(f)+        if stat and (not opts.type or opts.type == stat.type) then+          t[#t + 1] = f+        end+      end++      return t+    end++    for _, match in ipairs(test(path)) do+      if add(match) then+        return matches+      end+    end++    for parent in M.parents(path) do+      if stop and parent == stop then+        break+      end++      for _, match in ipairs(test(parent)) do+        if add(match) then+          return matches+        end+      end+    end+  else+    local dirs = { path }+    while #dirs > 0 do+      local dir = table.remove(dirs, 1)+      if stop and dir == stop then+        break+      end++      for other, type in M.dir(dir) do+        local f = dir .. '/' .. other+        for _, name in ipairs(names) do+          if name == other and (not opts.type or opts.type == type) then+            if add(f) then+              return matches+            end+          end+        end++        if type == 'directory' then+          dirs[#dirs + 1] = f+        end+      end+    end+  end++  return matches+end++--- Normalize a path to a standard format. A tilde (~) character at the+--- beginning of the path is expanded to the user's home directory and any+--- backslash (\\) characters are converted to forward slashes (/). Environment+--- variables are also expanded.",> and any backslash (\\) characters are converted to forward slashes (/)I think it might be better extract to this to a separate [sanitize function](https://github.com/neovim/nvim-lspconfig/blob/9e6bcf5a8915e8423d5cc7f82c5069c11272184d/lua/lspconfig/util.lua#L101-L107),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,885510708,2022-05-31T11:15:21Z,src/nvim/buffer_updates.c,"@@ -197,6 +197,9 @@ void buf_updates_send_changes(buf_T *buf, linenr_T firstline, int64_t num_added,     return;   } +  // Don't send b:changedtick during 'inccommand' preview if ""buf"" is the current buffer.+  bool send_tick = !(cmdpreview && buf == curbuf);","The `buf == curbuf` condition makes me wonder if the cmdpreview protocol should forbid switching buffers? But it is common for plugins to temporarily switch buffers, and we don't have a way of preventing it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,886040304,2022-05-31T19:15:40Z,src/nvim/ex_getln.c,"@@ -2306,6 +2313,267 @@ static int empty_pattern(char_u *p)   return n == 0 || (n >= 2 && p[n - 2] == '\\' && p[n - 1] == '|'); } +handle_T cmdpreview_get_bufnr(void)+{+  return cmdpreview_bufnr;+}++long cmdpreview_get_ns(void)+{+  return cmdpreview_ns;+}++/// Sets up command preview buffer.+///+/// @return Pointer to command preview buffer if succeeded, NULL if failed.+static buf_T *cmdpreview_open_buf(void)+{+  buf_T *cmdpreview_buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;++  // If preview buffer doesn't exist, open one.+  if (cmdpreview_buf == NULL) {+    Error err = ERROR_INIT;+    handle_T bufnr = nvim_create_buf(false, true, &err);++    if (ERROR_SET(&err)) {+      return NULL;+    }++    cmdpreview_buf = buflist_findnr(bufnr);+  }++  // Preview buffer cannot preview itself!+  if (cmdpreview_buf == curbuf) {+    return NULL;+  }++  // Rename preview buffer.+  aco_save_T aco;+  aucmd_prepbuf(&aco, cmdpreview_buf);+  int retv = rename_buffer(""[Preview]"");+  aucmd_restbuf(&aco);++  if (retv == FAIL) {+    return NULL;+  }++  // Temporarily switch to preview buffer to set it up for previewing.+  aucmd_prepbuf(&aco, cmdpreview_buf);+  buf_clear();+  curbuf->b_p_ma = true;+  curbuf->b_p_ul = -1;+  curbuf->b_p_tw = 0;  // Reset 'textwidth' (was set by ftplugin)+  aucmd_restbuf(&aco);+  cmdpreview_bufnr = cmdpreview_buf->handle;++  return cmdpreview_buf;+}++/// Open command preview window if it's not already open.+/// Returns to original window after opening command preview window.+///+/// @param cmdpreview_buf Pointer to command preview buffer+///+/// @return Pointer to command preview window if succeeded, NULL if failed.+static win_T *cmdpreview_open_win(buf_T *cmdpreview_buf)+{+  win_T *save_curwin = curwin;+  bool win_found = false;++  // Try to find an existing preview window.+  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+    if (wp->w_buffer == cmdpreview_buf) {+      win_enter(wp, false);+      win_found = true;+      break;+    }+  }++  // If an existing window is not found, create one.+  if (!win_found && win_split((int)p_cwh, WSP_BOT) == FAIL) {+    return NULL;+  }++  win_T *preview_win = curwin;+  Error err = ERROR_INIT;++  // Switch to preview buffer+  try_start();+  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, cmdpreview_buf->handle, 0);+  if (try_end(&err) || result == FAIL) {+    api_clear_error(&err);+    return NULL;+  }++  curwin->w_p_cul = false;+  curwin->w_p_cuc = false;+  curwin->w_p_spell = false;+  curwin->w_p_fen = false;++  win_enter(save_curwin, false);+  return preview_win;+}++/// Closes any open command preview windows.+static void cmdpreview_close_win(void)+{+  buf_T *buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;+  if (buf != NULL) {+    close_windows(buf, false);+  }+}++/// Show 'inccommand' preview. It works like this:+///    1. Store current undo information so we can revert to current state later.+///    2. Execute the preview callback with the parsed command, preview buffer number and preview+///       namespace number as arguments. The preview callback sets the highlight and does the+///       changes required for the preview if needed.+///    3. Preview callback returns 0, 1 or 2. 0 means no preview is shown. 1 means preview is shown+///       but preview window doesn't need to be opened. 2 means preview is shown and preview window+///       needs to be opened if inccommand=split.+///    4. Use the return value of the preview callback to determine whether to+///       open the preview window or not and open preview window if needed.+///    5. If the return value of the preview callback is not 0, update the screen while the effects+///       of the preview are still in place.+///    6. Revert all changes made by the preview callback.+static void cmdpreview_show(CommandLineState *s)",A key feature of 'inccommand' `:substitute` is that it skips the preview if the preview takes too long: https://github.com/neovim/neovim/blob/46536f53e82967dcac8d030ee3394cdb156f9603/src/nvim/ex_cmds.c#L4430-L4432That should also be built into the handling of user-defined cmd preview.,
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/18194,886049211,2022-05-31T19:23:09Z,src/nvim/ex_getln.c,"@@ -2306,6 +2313,267 @@ static int empty_pattern(char_u *p)   return n == 0 || (n >= 2 && p[n - 2] == '\\' && p[n - 1] == '|'); } +handle_T cmdpreview_get_bufnr(void)+{+  return cmdpreview_bufnr;+}++long cmdpreview_get_ns(void)+{+  return cmdpreview_ns;+}++/// Sets up command preview buffer.+///+/// @return Pointer to command preview buffer if succeeded, NULL if failed.+static buf_T *cmdpreview_open_buf(void)+{+  buf_T *cmdpreview_buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;++  // If preview buffer doesn't exist, open one.+  if (cmdpreview_buf == NULL) {+    Error err = ERROR_INIT;+    handle_T bufnr = nvim_create_buf(false, true, &err);++    if (ERROR_SET(&err)) {+      return NULL;+    }++    cmdpreview_buf = buflist_findnr(bufnr);+  }++  // Preview buffer cannot preview itself!+  if (cmdpreview_buf == curbuf) {+    return NULL;+  }++  // Rename preview buffer.+  aco_save_T aco;+  aucmd_prepbuf(&aco, cmdpreview_buf);+  int retv = rename_buffer(""[Preview]"");+  aucmd_restbuf(&aco);++  if (retv == FAIL) {+    return NULL;+  }++  // Temporarily switch to preview buffer to set it up for previewing.+  aucmd_prepbuf(&aco, cmdpreview_buf);+  buf_clear();+  curbuf->b_p_ma = true;+  curbuf->b_p_ul = -1;+  curbuf->b_p_tw = 0;  // Reset 'textwidth' (was set by ftplugin)+  aucmd_restbuf(&aco);+  cmdpreview_bufnr = cmdpreview_buf->handle;++  return cmdpreview_buf;+}++/// Open command preview window if it's not already open.+/// Returns to original window after opening command preview window.+///+/// @param cmdpreview_buf Pointer to command preview buffer+///+/// @return Pointer to command preview window if succeeded, NULL if failed.+static win_T *cmdpreview_open_win(buf_T *cmdpreview_buf)+{+  win_T *save_curwin = curwin;+  bool win_found = false;++  // Try to find an existing preview window.+  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+    if (wp->w_buffer == cmdpreview_buf) {+      win_enter(wp, false);+      win_found = true;+      break;+    }+  }++  // If an existing window is not found, create one.+  if (!win_found && win_split((int)p_cwh, WSP_BOT) == FAIL) {+    return NULL;+  }++  win_T *preview_win = curwin;+  Error err = ERROR_INIT;++  // Switch to preview buffer+  try_start();+  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, cmdpreview_buf->handle, 0);+  if (try_end(&err) || result == FAIL) {+    api_clear_error(&err);+    return NULL;+  }++  curwin->w_p_cul = false;+  curwin->w_p_cuc = false;+  curwin->w_p_spell = false;+  curwin->w_p_fen = false;++  win_enter(save_curwin, false);+  return preview_win;+}++/// Closes any open command preview windows.+static void cmdpreview_close_win(void)+{+  buf_T *buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;+  if (buf != NULL) {+    close_windows(buf, false);+  }+}++/// Show 'inccommand' preview. It works like this:+///    1. Store current undo information so we can revert to current state later.+///    2. Execute the preview callback with the parsed command, preview buffer number and preview+///       namespace number as arguments. The preview callback sets the highlight and does the+///       changes required for the preview if needed.+///    3. Preview callback returns 0, 1 or 2. 0 means no preview is shown. 1 means preview is shown+///       but preview window doesn't need to be opened. 2 means preview is shown and preview window+///       needs to be opened if inccommand=split.+///    4. Use the return value of the preview callback to determine whether to+///       open the preview window or not and open preview window if needed.+///    5. If the return value of the preview callback is not 0, update the screen while the effects+///       of the preview are still in place.+///    6. Revert all changes made by the preview callback.+static void cmdpreview_show(CommandLineState *s)","Another important optimization was to stop looking for matches if additional ones would not be shown to the user (either the preview buffer is full and icm=split, or they're out of the viewport of the current buffer with icm=nosplit). This PR is too complicated for me, so I could not discern if that was implemented, but I figured I'd mention it (ofc it's most helpfull in large files).",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/18194,886062398,2022-05-31T19:32:54Z,src/nvim/ex_getln.c,"@@ -2306,6 +2313,267 @@ static int empty_pattern(char_u *p)   return n == 0 || (n >= 2 && p[n - 2] == '\\' && p[n - 1] == '|'); } +handle_T cmdpreview_get_bufnr(void)+{+  return cmdpreview_bufnr;+}++long cmdpreview_get_ns(void)+{+  return cmdpreview_ns;+}++/// Sets up command preview buffer.+///+/// @return Pointer to command preview buffer if succeeded, NULL if failed.+static buf_T *cmdpreview_open_buf(void)+{+  buf_T *cmdpreview_buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;++  // If preview buffer doesn't exist, open one.+  if (cmdpreview_buf == NULL) {+    Error err = ERROR_INIT;+    handle_T bufnr = nvim_create_buf(false, true, &err);++    if (ERROR_SET(&err)) {+      return NULL;+    }++    cmdpreview_buf = buflist_findnr(bufnr);+  }++  // Preview buffer cannot preview itself!+  if (cmdpreview_buf == curbuf) {+    return NULL;+  }++  // Rename preview buffer.+  aco_save_T aco;+  aucmd_prepbuf(&aco, cmdpreview_buf);+  int retv = rename_buffer(""[Preview]"");+  aucmd_restbuf(&aco);++  if (retv == FAIL) {+    return NULL;+  }++  // Temporarily switch to preview buffer to set it up for previewing.+  aucmd_prepbuf(&aco, cmdpreview_buf);+  buf_clear();+  curbuf->b_p_ma = true;+  curbuf->b_p_ul = -1;+  curbuf->b_p_tw = 0;  // Reset 'textwidth' (was set by ftplugin)+  aucmd_restbuf(&aco);+  cmdpreview_bufnr = cmdpreview_buf->handle;++  return cmdpreview_buf;+}++/// Open command preview window if it's not already open.+/// Returns to original window after opening command preview window.+///+/// @param cmdpreview_buf Pointer to command preview buffer+///+/// @return Pointer to command preview window if succeeded, NULL if failed.+static win_T *cmdpreview_open_win(buf_T *cmdpreview_buf)+{+  win_T *save_curwin = curwin;+  bool win_found = false;++  // Try to find an existing preview window.+  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+    if (wp->w_buffer == cmdpreview_buf) {+      win_enter(wp, false);+      win_found = true;+      break;+    }+  }++  // If an existing window is not found, create one.+  if (!win_found && win_split((int)p_cwh, WSP_BOT) == FAIL) {+    return NULL;+  }++  win_T *preview_win = curwin;+  Error err = ERROR_INIT;++  // Switch to preview buffer+  try_start();+  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, cmdpreview_buf->handle, 0);+  if (try_end(&err) || result == FAIL) {+    api_clear_error(&err);+    return NULL;+  }++  curwin->w_p_cul = false;+  curwin->w_p_cuc = false;+  curwin->w_p_spell = false;+  curwin->w_p_fen = false;++  win_enter(save_curwin, false);+  return preview_win;+}++/// Closes any open command preview windows.+static void cmdpreview_close_win(void)+{+  buf_T *buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;+  if (buf != NULL) {+    close_windows(buf, false);+  }+}++/// Show 'inccommand' preview. It works like this:+///    1. Store current undo information so we can revert to current state later.+///    2. Execute the preview callback with the parsed command, preview buffer number and preview+///       namespace number as arguments. The preview callback sets the highlight and does the+///       changes required for the preview if needed.+///    3. Preview callback returns 0, 1 or 2. 0 means no preview is shown. 1 means preview is shown+///       but preview window doesn't need to be opened. 2 means preview is shown and preview window+///       needs to be opened if inccommand=split.+///    4. Use the return value of the preview callback to determine whether to+///       open the preview window or not and open preview window if needed.+///    5. If the return value of the preview callback is not 0, update the screen while the effects+///       of the preview are still in place.+///    6. Revert all changes made by the preview callback.+static void cmdpreview_show(CommandLineState *s)",> A key feature of 'inccommand' `:substitute` is that it skips the preview if the preview takes too long: https://github.com/neovim/neovim/blob/46536f53e82967dcac8d030ee3394cdb156f9603/src/nvim/ex_cmds.c#L4430-L4432> > That should also be built into the handling of user-defined cmd preview.How should we implement that though? Or should we leave that to the preview callback?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18194,886085702,2022-05-31T20:05:40Z,src/nvim/ex_getln.c,"@@ -2306,6 +2313,267 @@ static int empty_pattern(char_u *p)   return n == 0 || (n >= 2 && p[n - 2] == '\\' && p[n - 1] == '|'); } +handle_T cmdpreview_get_bufnr(void)+{+  return cmdpreview_bufnr;+}++long cmdpreview_get_ns(void)+{+  return cmdpreview_ns;+}++/// Sets up command preview buffer.+///+/// @return Pointer to command preview buffer if succeeded, NULL if failed.+static buf_T *cmdpreview_open_buf(void)+{+  buf_T *cmdpreview_buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;++  // If preview buffer doesn't exist, open one.+  if (cmdpreview_buf == NULL) {+    Error err = ERROR_INIT;+    handle_T bufnr = nvim_create_buf(false, true, &err);++    if (ERROR_SET(&err)) {+      return NULL;+    }++    cmdpreview_buf = buflist_findnr(bufnr);+  }++  // Preview buffer cannot preview itself!+  if (cmdpreview_buf == curbuf) {+    return NULL;+  }++  // Rename preview buffer.+  aco_save_T aco;+  aucmd_prepbuf(&aco, cmdpreview_buf);+  int retv = rename_buffer(""[Preview]"");+  aucmd_restbuf(&aco);++  if (retv == FAIL) {+    return NULL;+  }++  // Temporarily switch to preview buffer to set it up for previewing.+  aucmd_prepbuf(&aco, cmdpreview_buf);+  buf_clear();+  curbuf->b_p_ma = true;+  curbuf->b_p_ul = -1;+  curbuf->b_p_tw = 0;  // Reset 'textwidth' (was set by ftplugin)+  aucmd_restbuf(&aco);+  cmdpreview_bufnr = cmdpreview_buf->handle;++  return cmdpreview_buf;+}++/// Open command preview window if it's not already open.+/// Returns to original window after opening command preview window.+///+/// @param cmdpreview_buf Pointer to command preview buffer+///+/// @return Pointer to command preview window if succeeded, NULL if failed.+static win_T *cmdpreview_open_win(buf_T *cmdpreview_buf)+{+  win_T *save_curwin = curwin;+  bool win_found = false;++  // Try to find an existing preview window.+  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+    if (wp->w_buffer == cmdpreview_buf) {+      win_enter(wp, false);+      win_found = true;+      break;+    }+  }++  // If an existing window is not found, create one.+  if (!win_found && win_split((int)p_cwh, WSP_BOT) == FAIL) {+    return NULL;+  }++  win_T *preview_win = curwin;+  Error err = ERROR_INIT;++  // Switch to preview buffer+  try_start();+  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, cmdpreview_buf->handle, 0);+  if (try_end(&err) || result == FAIL) {+    api_clear_error(&err);+    return NULL;+  }++  curwin->w_p_cul = false;+  curwin->w_p_cuc = false;+  curwin->w_p_spell = false;+  curwin->w_p_fen = false;++  win_enter(save_curwin, false);+  return preview_win;+}++/// Closes any open command preview windows.+static void cmdpreview_close_win(void)+{+  buf_T *buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;+  if (buf != NULL) {+    close_windows(buf, false);+  }+}++/// Show 'inccommand' preview. It works like this:+///    1. Store current undo information so we can revert to current state later.+///    2. Execute the preview callback with the parsed command, preview buffer number and preview+///       namespace number as arguments. The preview callback sets the highlight and does the+///       changes required for the preview if needed.+///    3. Preview callback returns 0, 1 or 2. 0 means no preview is shown. 1 means preview is shown+///       but preview window doesn't need to be opened. 2 means preview is shown and preview window+///       needs to be opened if inccommand=split.+///    4. Use the return value of the preview callback to determine whether to+///       open the preview window or not and open preview window if needed.+///    5. If the return value of the preview callback is not 0, update the screen while the effects+///       of the preview are still in place.+///    6. Revert all changes made by the preview callback.+static void cmdpreview_show(CommandLineState *s)","> How should we implement that though? Or should we leave that to the preview callback?Should be done implicitly, builtin. - Maybe `f_wait` (`:help wait()`) could be used, or at least provides a starting point: https://github.com/neovim/neovim/blob/c632f64e247c672e425f609bb47a9ab0517a4c31/src/nvim/eval/funcs.c#L3869- I think we need this: https://github.com/neovim/neovim/issues/6800     - related stale PR: https://github.com/neovim/neovim/pull/6809> Another important optimization was to stop looking for matches ... I could not discern if that was implemented,@KillTheMule I believe that is covered by tests so I don't think there was a regression.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18631,886661789,2022-06-01T10:47:23Z,runtime/doc/lsp.txt,"@@ -954,6 +954,20 @@ start_client({config})                                *vim.lsp.start_client()*                     not be fully initialized. Use `on_init` to do any actions                     once the client has been initialized. +start_or_attach({config}, {reuse_client})          *vim.lsp.start_or_attach()*+                Starts a new client or re-uses an existing client and attaches+                the current buffer to it.++                Parameters: ~+                    {config}        (table) Same configuration as documented+                                    in |lsp.start_client()|+                    {reuse_client}  nil|fun(client: table): boolean Function","> I wonder though, if we had this feature from the beginning, would we make multiple functions for it or would it be a feature of start_client() ?Probably not. It still might be better to add a new function that does everything right, and then deprecate the old functions. (The biggest consumer of the old functions is nvim-lspconfig, which will be made obsolete -- as far as code goes -- by this PR anyway.)",
866010,rktjmp,https://api.github.com/repos/neovim/neovim/pulls/18820,887428993,2022-06-02T01:44:54Z,test/functional/api/highlight_spec.lua,"@@ -337,4 +337,10 @@ describe(""API: set highlight"", function()       exec_capture('highlight Test_hl3'))    end)++  it (""correctly sets 'Normal' internal properties"", function()","Hardest part of the test was naming it and while the issue is listed with get_hl_by_name, the cause is closer to set_hl, so I stuck it here.",
6705160,williamboman,https://api.github.com/repos/neovim/neovim/pulls/18631,887935051,2022-06-02T13:11:04Z,runtime/doc/lsp.txt,"@@ -800,6 +794,58 @@ set_log_level({level})                               *vim.lsp.set_log_level()*                 See also: ~                     |vim.lsp.log_levels| +start({config}, {opts})                                      *vim.lsp.start()*+                Create a new LSP client and start a language server or reuses+                an already running client if one is found matching `name` and+                `root_dir`. Attaches the current buffer to the client.++                Example:+>++    vim.lsp.start({+       name = 'my-server-name',+       cmd = {'name-of-language-server-executable'},+       root_dir = vim.fs.dirname(vim.fs.find({'pyproject.toml', 'setup.py'})[1]),+    })+<++                See |lsp.start_client| for all available options. The most+                important are:++                `name` is an arbitrary name for the LSP client. It should be+                unique per language server.++                `cmd` the command as list - used to start the language server. The+                command must be present in the `$PATH` environment variable or an absolute path to the executable.+                Shell constructs like `~` are NOT expanded.","I don't recall all the details, but I wonder if it'd be worthwhile documenting how Windows handles (or rather doesn't handle) certain executables [through libuv](https://github.com/libuv/libuv/blob/2a1b880f5439e074ef4d5c556f626b1044fb6781/src/win/process.c#L304-L308). A large portion of servers are distributed as `.cmd`, `.ps1` or `.bat` scripts on Windows, which would not play nicely here as libuv wouldn't recognize them as executable. This is currently handled by lspconfig by using `cmd.exe /C` as an intermediary for launching server processes.I think this could potentially be a source of high volume issues for Windows users.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18631,887954913,2022-06-02T13:30:36Z,runtime/doc/lsp.txt,"@@ -800,6 +794,58 @@ set_log_level({level})                               *vim.lsp.set_log_level()*                 See also: ~                     |vim.lsp.log_levels| +start({config}, {opts})                                      *vim.lsp.start()*+                Create a new LSP client and start a language server or reuses+                an already running client if one is found matching `name` and+                `root_dir`. Attaches the current buffer to the client.++                Example:+>++    vim.lsp.start({+       name = 'my-server-name',+       cmd = {'name-of-language-server-executable'},+       root_dir = vim.fs.dirname(vim.fs.find({'pyproject.toml', 'setup.py'})[1]),+    })+<++                See |lsp.start_client| for all available options. The most+                important are:++                `name` is an arbitrary name for the LSP client. It should be+                unique per language server.++                `cmd` the command as list - used to start the language server. The+                command must be present in the `$PATH` environment variable or an absolute path to the executable.+                Shell constructs like `~` are NOT expanded.","I think that's out of scope of this PR, the methods docs are already quite long and I think if it gets longer people are more prone to skipping reading it altogether. This may be something for the FAQ section.",
6705160,williamboman,https://api.github.com/repos/neovim/neovim/pulls/18631,888038572,2022-06-02T14:46:02Z,runtime/doc/lsp.txt,"@@ -800,6 +794,58 @@ set_log_level({level})                               *vim.lsp.set_log_level()*                 See also: ~                     |vim.lsp.log_levels| +start({config}, {opts})                                      *vim.lsp.start()*+                Create a new LSP client and start a language server or reuses+                an already running client if one is found matching `name` and+                `root_dir`. Attaches the current buffer to the client.++                Example:+>++    vim.lsp.start({+       name = 'my-server-name',+       cmd = {'name-of-language-server-executable'},+       root_dir = vim.fs.dirname(vim.fs.find({'pyproject.toml', 'setup.py'})[1]),+    })+<++                See |lsp.start_client| for all available options. The most+                important are:++                `name` is an arbitrary name for the LSP client. It should be+                unique per language server.++                `cmd` the command as list - used to start the language server. The+                command must be present in the `$PATH` environment variable or an absolute path to the executable.+                Shell constructs like `~` are NOT expanded.","I was just thinking if this is a new API that is intended to be used directly by users it might lead to some hard-to-troubleshoot issues. I'd wager a vast majority of users would expect ergonomics similar to their shell environment, with path expansion and `PATHEXT` to be respected.Just an example from the perspective of Windows users, the following would not function:```luavim.lsp.start {  cmd = { ""typescript-language-server"", ""--stdio"" },  ..}```Assuming you have your npm PATH set up correctly; jumping into a shell and typing `where typescript-language-server` would look fine, going into Neovim and trying `:echo executable(""typescript-language-server"")` would [also look fine](https://github.com/neovim/neovim/blob/c632f64e247c672e425f609bb47a9ab0517a4c31/src/nvim/os/fs.c#L323). There's no single entrypoint other than directly interacting with `vim.loop.spawn` to troubleshoot this.I think this has been discussed before, but I think spawning RPC processes via a shell should be considered as more LSP functionality finds its way into core (or some other alternative to meet user expectations). There might be some other future plans that I'm not aware of so apologies if I'm overreaching",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18814,888123649,2022-06-02T15:59:10Z,runtime/lua/vim/filetype.lua,"@@ -1175,6 +1236,82 @@ local extension = {       return 'rc'     end   end,+  news = function(path, bufnr)+    return require('vim.filetype.detect').news(bufnr)+  end,+  control = function(path, bufnr)+    return require('vim.filetype.detect').control(bufnr)+  end,+  copyright = function(path, bufnr)+    return require('vim.filetype.detect').copyright(bufnr)+  end,+  log = function(path, bufnr)","I don't see `*.log` in `filetype.vim`? If this is a refactor of the `upstream` patterns, maybe a comment would be helpful?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18631,889003182,2022-06-03T14:33:21Z,runtime/lua/vim/lsp.lua,"@@ -662,6 +663,77 @@ function lsp.client()   error() end +--- Create a new LSP client and start a language server or reuses an already+--- running client if one is found matching `name` and `root_dir`.+--- Attaches the current buffer to the client.+---+--- Example:+---+--- <pre>+--- vim.lsp.start({+---    name = 'my-server-name',+---    cmd = {'name-of-language-server-executable'},+---    root_dir = vim.fs.dirname(vim.fs.find({'pyproject.toml', 'setup.py'}, { upward = true })[1]),+--- })+--- </pre>+---+--- See |lsp.start_client| for all available options. The most important are:",should we deprecate start_client and move its docs to start()?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18543,889061819,2022-06-03T15:40:25Z,CMakeLists.txt,"@@ -748,15 +745,51 @@ if(BUSTED_LUA_PRG)     set_target_properties(functionaltest-lua PROPERTIES FOLDER test) endif() -if(LUACHECK_PRG)-  add_custom_target(lualint-    COMMAND ${LUACHECK_PRG} -q runtime/ scripts/ src/ test/-    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})-else()-  add_custom_target(lualint false-    COMMENT ""lualint: LUACHECK_PRG not defined"")-endif()-+find_program(LUACHECK luacheck)","the `_PRG` suffix convention was intentional and used throughout our cmake files. Why revert that? It is useful as a hint that this is a CLI, not a shared library.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18543,889070919,2022-06-03T15:51:48Z,cmake/lint.cmake,"@@ -0,0 +1,35 @@+if(PROGRAM)","If we're trying to de-clutter the main `CMakeLists.txt`, can we move all of the `add_custom_target` calls into this file?  It doesn't need to be parameterized.",X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18851,889200978,2022-06-03T17:50:15Z,runtime/lua/vim/filetype.lua,"@@ -1230,9 +1230,10 @@ local filename = {   Dockerfile = 'dockerfile',   npmrc = 'dosini',   ['/etc/yum.conf'] = 'dosini',-  ['/etc/pacman.conf'] = 'conf',   ['.npmrc'] = 'dosini',   ['.editorconfig'] = 'dosini',+  ['/etc/pacman.conf'] = 'confini',","@gpanders This entry doesn't appear in `filetype.vim` (it only has `*/etc/pacman.conf`, which appears in the `patterns` table below).Is this by design (`*` is none or some in Vim, but only some in Lua)?",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18851,889227222,2022-06-03T18:28:17Z,runtime/lua/vim/filetype.lua,"@@ -1230,9 +1230,10 @@ local filename = {   Dockerfile = 'dockerfile',   npmrc = 'dosini',   ['/etc/yum.conf'] = 'dosini',-  ['/etc/pacman.conf'] = 'conf',   ['.npmrc'] = 'dosini',   ['.editorconfig'] = 'dosini',+  ['/etc/pacman.conf'] = 'confini',","Yes it's intentional, because filenames are matched sooner (and much faster) than patterns, it's a way to short-circuit the pattern detection for the case when the file is named `/etc/pacman.conf` (which is the most common scenario anyway). I think we do this for all of the patterns that start with `*/`.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18814,889437479,2022-06-04T02:12:32Z,runtime/lua/vim/filetype.lua,"@@ -1175,6 +1241,67 @@ local extension = {       return 'rc'     end   end,+  control = function(path, bufnr)+    return require('vim.filetype.detect').control(bufnr)+  end,+  copyright = function(path, bufnr)+    return require('vim.filetype.detect').copyright(bufnr)+  end,+  -- Ignored extensions+  bak = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  ['dpkg-dist'] = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  ['dpkg-old'] = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  ['dpkg-new'] = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  ['dpkg-bak'] = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  new = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  old = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  orig = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  pacsave = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  pacnew = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  rpmsave = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  rmpnew = function(path, bufnr)+    local root = vim.fn.fnamemodify(path, ':r')+    return M.match(root, bufnr)+  end,+  ['in'] = function(path, bufnr)+    if vim.fn.expand(path, ':t') ~= 'configure.in' then+      local root = vim.fn.fnameescape(vim.fn.fnamemodify(path, ':r'))","Using `fnameescape` here, but not in the other patterns above. I wonder if we need it at all? My guess is that we do not since we are just passing the result of `fnamemodify` directly to `vim.filetype.match`.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18814,889440939,2022-06-04T02:25:13Z,runtime/lua/vim/filetype.lua,"@@ -1571,11 +1736,26 @@ local pattern = {   ['.*/%.config/git/config'] = 'gitconfig',   ['.*%.git/config%.worktree'] = 'gitconfig',   ['.*%.git/worktrees/.*/config%.worktree'] = 'gitconfig',+  ['/git/config'] = function(path, bufnr)","If the pattern contains a `/` character then the pattern is matched against the full file path, so this will never match. Needs to be:```suggestion  ['.*/git/config'] = function(path, bufnr)```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18814,889502790,2022-06-04T08:16:59Z,runtime/lua/vim/filetype.lua,"@@ -1741,8 +1963,15 @@ local pattern = {   ['.*%.properties_.._.._.*'] = starsetf('jproperties'),   ['.*%.vhdl_[0-9].*'] = starsetf('vhdl'),   ['.*/%.fvwm/.*'] = starsetf('fvwm'),+  ['.*fvwmrc.*'] = function(path, bufnr)+    vim.b[bufnr].fvwm_version = 1+    starsetf('fvwm')","Hmm... To be honest, I'm not at all a fan of how `filetype.vim` mixes setting `filetype` and ""flavor variables""; this makes it harder to expose `vim.filetype.match` for other purposes.Maybe we should instead refactor so that all patterns return a string (the filetype) and optionally a callback that is then run by `filetype.match` (unless called with an option to skip it)? This will be a bit tricky for some of the `detect.lua` patterns, though...",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/18777,889520121,2022-06-04T11:34:58Z,src/nvim/api/buffer.c,"@@ -1137,12 +1137,16 @@ Boolean nvim_buf_is_loaded(Buffer buffer)   return buf && buf->b_ml.ml_mfp != NULL; } -/// Deletes the buffer. See |:bwipeout|+/// Deletes the buffer. /// /// @param buffer Buffer handle, or 0 for current buffer /// @param opts  Optional parameters. Keys: ///          - force:  Force deletion and ignore unsaved changes.-///          - unload: Unloaded only, do not delete. See |:bunload|+///          - action: (default: ""wipeout"")","I feel like `type` in this case is likely to imply the buffer type, rather than the operation type, as if it's a filtering parameter, e.g.```luavim.api.nvim_bufdelete(buffer=0, {type=""prompt""})```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/18631,889529299,2022-06-04T13:10:04Z,runtime/doc/lsp.txt,"@@ -24,88 +24,82 @@ QUICKSTART                                              *lsp-quickstart* Nvim provides an LSP client, but the servers are provided by third parties. Follow these steps to get LSP features: -  1. Install the nvim-lspconfig plugin.  It provides common configuration for-     various servers so you can get started quickly.-     https://github.com/neovim/nvim-lspconfig-  2. Install a language server. A list of language servers can be found here:+  1. Install language servers using your package manager or by+     following the upstream installation instruction.++     A list of language servers is available at:+      https://microsoft.github.io/language-server-protocol/implementors/servers/-     See individual server documentation for installation instructions.-  3. Add `lua require('lspconfig').xx.setup{���}` to your init.vim, where ""xx"" is-     the name of the relevant config. See the nvim-lspconfig README for details.-     NOTE: Make sure to restart nvim after installing and configuring.-  4. Check that an LSP client has attached to the current buffer:  > -      :lua print(vim.inspect(vim.lsp.buf_get_clients()))+  2. Configure the LSP client per language server.+     A minimal example:+>+     vim.lsp.start({+        name = 'my-server-name',+        cmd = {'name-of-language-server-executable'},+        root_dir = vim.fs.dirname(vim.fs.find({'setup.py', 'pyproject.toml'}, { upward = true })[1]),","> should this be a function so that it's eval'd dynamically?I'm not sure if it is needed, given that `vim.lsp.start` will likely be called within a FileType event most of the time, so you already get some lazy evaluation due to that.If we end up adding `lsp.config` too, that may change things.> Having it be a function would also allow potentially running it in async mode, making things like shelling out to locate an appropriate root dir less disruptive to the UXOnly if the function supported a callback.",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18814,889744782,2022-06-05T22:33:46Z,runtime/lua/vim/filetype.lua,"@@ -1741,8 +1963,15 @@ local pattern = {   ['.*%.properties_.._.._.*'] = starsetf('jproperties'),   ['.*%.vhdl_[0-9].*'] = starsetf('vhdl'),   ['.*/%.fvwm/.*'] = starsetf('fvwm'),+  ['.*fvwmrc.*'] = function(path, bufnr)+    vim.b[bufnr].fvwm_version = 1+    starsetf('fvwm')",@gpanders I think your proposed solution will not always work since sometimes the `starsetf` function is called multiple times (with different arguments) within one pattern function. What do you think of the approach I came up with? :D **Edit:** I just realized setting the priority to `-infinity` for the original pattern is wrong so my solution is not really correct.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18814,889770771,2022-06-06T01:40:51Z,runtime/lua/vim/filetype.lua,"@@ -1741,8 +1963,15 @@ local pattern = {   ['.*%.properties_.._.._.*'] = starsetf('jproperties'),   ['.*%.vhdl_[0-9].*'] = starsetf('vhdl'),   ['.*/%.fvwm/.*'] = starsetf('fvwm'),+  ['.*fvwmrc.*'] = function(path, bufnr)+    vim.b[bufnr].fvwm_version = 1+    starsetf('fvwm')","Let's take a step back: the `starsetf` function really does just two things: 1) check the file path against `g:ft_ignore_pat`, and 2) set the priority of the match to `-math.huge`.Those two things should be generalizable. So here's what I have in mind: modify `starsetf` to accept either a string or a function. If a string, then it acts exactly as it does right now: it performs steps (1) and (2) above and simply returns the given string as the filetype. If a function, then it still performs steps (1) and (2) but also evaluates the given function to retrieve the filetype.@clason's point is separate, but still relevant as we will need to incorporate that solution into `starsetf` as well. But I think we can do that in a follow up PR (I have an idea on how to address this).Here's a patch:```diffdiff --git a/runtime/lua/vim/filetype.lua b/runtime/lua/vim/filetype.luaindex f5c29639c..ff6cdcef9 100644--- a/runtime/lua/vim/filetype.lua+++ b/runtime/lua/vim/filetype.lua@@ -5,14 +5,15 @@ local M = {} ---@private local function starsetf(ft)   return {-    function(path)+    function(path, bufnr)+      local f = type(ft) == 'function' and ft(path, bufnr) or ft       if not vim.g.ft_ignore_pat then-        return ft+        return f       end        local re = vim.regex(vim.g.ft_ignore_pat)-      if re:match_str(path) then-        return ft+      if not re:match_str(path) then+        return f       end     end,     {```Then this can be used in one of two ways:The current method:```lua['foo'] = starsetf('fooscript'),```or using a function:```lua['bar'] = starsetf(function(path, bufnr)  if some_condition then    return 'barscript'  end  return 'somethingelse'end),```I think this should cover all the cases. I will make a follow up PR to address the ""setting buffer variables"" issue once we get this one merged. What do you think?",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/18543,890145808,2022-06-06T13:25:50Z,cmake/lint.cmake,"@@ -0,0 +1,35 @@+if(PROGRAM)","Hmm, not quite. Most importantly it allows us to silence the regular output of uncrustify check which is abysmal normally. The other checks can be moved into the main cmakelists but I don't see uncrustify being moved to cmakelists without making the linting useless. Shall we add a `uncrustify.cmake` file for the time being then?I'll send a PR to uncrustify to fix the check output, this is getting ridiculous.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/18892,891492585,2022-06-07T16:58:46Z,Makefile,"@@ -91,6 +91,9 @@ SINGLE_MAKE = export MAKEFLAGS= ; $(MAKE) nvim: build/.ran-cmake deps 	+$(BUILD_TOOL) -C build +asan:+	$(MAKEFILE_DIR)/contrib/asan.sh","Eh, is this even possible to do in cmake only? We need to call cmake multiple times to build nvim, and this needs to be a dependency of the nvim target. If anything this should be in the Makefile?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18894,891812303,2022-06-08T00:29:11Z,runtime/lua/vim/filetype.lua,"@@ -2283,13 +2298,13 @@ end  ---@private local function dispatch(ft, path, bufnr, ...)+  local extra   if type(ft) == 'function' then-    ft = ft(path, bufnr, ...)+    ft, extra = ft(path, bufnr, ...)","+1 for making side effects opt-in. But this ""return a worker function"" pattern is unusual, maybe we can make it more intuitive by thinking of a name other than ""extra"". Perhaps `bufinit`, `init`, `setup`, `on_detect`? Any name that would make sense as a normal function.If this isn't user-facing, then it's less important. But still helpful.```suggestion    ft, on_detect = ft(path, bufnr, ...)```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18832,892821278,2022-06-08T20:15:11Z,src/nvim/terminal.c,"@@ -233,6 +233,8 @@ Terminal *terminal_open(buf_T *buf, TerminalOptions opts)   RESET_BINDING(curwin);   // Reset cursor in current window.   curwin->w_cursor = (pos_T){ .lnum = 1, .col = 0, .coladd = 0 };+  // Intitialzie to check if the scrollback buffer has been allocated inside a TermOpen autocmd","- spellcheck- use punctuation in comments, it avoids ambiguity.```suggestion  // Initialize in case the scrollback buffer was allocated in a TermOpen autocmd.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18911,893604298,2022-06-09T14:49:34Z,test/functional/treesitter/parser_spec.lua,"@@ -169,23 +169,23 @@ void ui_refresh(void)    it(""supports caching queries"", function()     local long_query = query:rep(100)-    local first_run = exec_lua ([[-      local before = vim.loop.hrtime()-      cquery = vim.treesitter.parse_query(""c"", ...)-      local after = vim.loop.hrtime()-      return after - before-    ]], long_query)--    local subsequent_runs = exec_lua ([[-      local before = vim.loop.hrtime()-      for i=1,100,1 do-        cquery = vim.treesitter.parse_query(""c"", ...)-      end-      local after = vim.loop.hrtime()-      return after - before-    ]], long_query)+    local function q(n)+      return exec_lua ([[+        local query, n = ...+        local before = vim.loop.hrtime()+        for i=1,n,1 do+          cquery = vim.treesitter.parse_query(""c"", ...)+        end+        local after = vim.loop.hrtime()+        return after - before+      ]], long_query, n)+    end++    local firstrun = q(1)+    local manyruns = q(100) -    assert.True(1000 * subsequent_runs < first_run)","assert.True is useless, do not use it. Maybe ok() should also be removed.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/18678,894004837,2022-06-09T22:15:38Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -513,25 +513,40 @@ function LanguageTree:register_cbs(cbs)   end end +---Determine whether {range} is completely inside {region} (range(region)==range -> true).+---@param region node or 6-tuple srow, scol, sbyte, erow, ecol, ebyte.+---@param inner range, 4-tuple srow, scol, erow, ecol.+---@return boolean ---@private-local function tree_contains(tree, range)-  local start_row, start_col, end_row, end_col = tree:root():range()+local function region_contains(region, range)+  local start_row, start_col, end_row, end_col+  if type(region) == 'table' then+    start_row, start_col, end_row, end_col = region[1], region[2], region[4], region[5]+  else+    start_row, start_col, end_row, end_col = region:range()+  end+   local start_fits = start_row < range[1] or (start_row == range[1] and start_col <= range[2])   local end_fits = end_row > range[3] or (end_row == range[3] and end_col >= range[4]) -  return start_fits and end_fits+  if start_fits and end_fits then+    return true+  end++  return false",This change seems unnecessary and makes the code worse.```luareturn condition```is much better than```luaif condition then    return trueendreturn false```,
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18710,894867259,2022-06-10T20:27:15Z,runtime/lua/vim/scripts.lua,"@@ -0,0 +1,359 @@+-- Ported from scripts.vim++-- Only do the rest when the FileType autocommand has not been triggered yet.+if vim.fn.did_filetype() ~= 0 then+  return+end++-- Load the user defined scripts file first+-- Only do this when the FileType autocommand has not been triggered yet+if vim.fn.exists('myscriptsfile') ~= 0 and vim.fn.filereadable(vim.fn.expand('myscriptsfile')) ~= 0 then+  vim.cmd('execute source myscriptsfile')+  if vim.fn.did_filetype() ~= 0 then+    return+  end+end++local getlines = vim.filetype.getlines+local findany = vim.filetype.findany+local matchregex = vim.filetype.matchregex++local detect = require('vim.filetype.detect')++---@private+local function scripts_shebang(path, bufnr)+  local first_line = getlines(bufnr, 1)+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)+      :gsub('%-%-ignore%-environment', '', 1)+      :gsub('%-%-split%-string', '', 1)+    first_line = vim.fn.substitute(first_line, [[\<env\s\+]], '', '')+  end++  -- Get the program name.+  -- Only accept spaces in PC style paths: ""#!c:/program files/perl [args]"".+  -- If the word env is used, use the first word after the space:+  -- ""#!/usr/bin/env perl [path/args]""+  -- If there is no path use the first word: ""#!perl [path/args]"".+  -- Otherwise get the last word after a slash: ""#!/usr/bin/perl [path/args]"".+  local name+  if first_line:find('^#!%s*%a:[/\\]') then+    name = vim.fn.substitute(first_line, [[^#!.*[/\\]\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!.*\<env\>]]) then+    name = vim.fn.substitute(first_line, [[^#!.*\<env\>\s\+\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!\s*[^/\\ ]*\>\([^/\\]\|$\)]]) then+    name = vim.fn.substitute(first_line, [[^#!\s*\([^/\\ ]*\>\).*]], '\\1', '')+  else+    name = vim.fn.substitute(first_line, [[^#!\s*\S*[/\\]\(\i\+\).*]], '\\1', '')+  end++  -- tcl scripts may have #!/bin/sh in the first line and ""exec wish"" in the+  -- third line. Suggested by Steven Atkinson.+  if getlines(bufnr, 3):find('^exec wish') then+    name = 'wish'+  end++  if matchregex(name, [[^\(bash\d*\|\|ksh\d*\|sh\)\>]]) then+    -- Bourne-like shell scripts: bash bash2 ksh ksh93 sh+    return detect.sh(path, bufnr, first_line)+  elseif matchregex(name, [[^csh\>]]) then+    return detect.shell(path, bufnr, vim.g.filetype_csh or 'csh')+  elseif matchregex(name, [[^tcsh\>]]) then+    return detect.shell(path, bufnr, 'tcsh')+  end++  local patterns = {+    ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+    ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+    ['^expect\\>'] = { 'expect', { vim_regex = true } },+    ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+    ['make\\>'] = { 'make', { vim_regex = true } },+    ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+    lua = 'lua',+    perl = 'lua',+    php = 'php',+    python = 'python',+    ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+    raku = 'raku',+    ruby = 'ruby',+    ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+    ['rhino\\>'] = { 'javascript', { vim_regex = true } },+    -- BC calculator+    ['^bc\\>'] = { 'bc', { vim_regex = true } },+    ['sed\\>'] = { 'sed', { vim_regex = true } },+    ocaml = 'ocaml',+    -- Awk scripts; also finds ""gawk""+    ['awk\\>'] = { 'awk', { vim_regex = true } },+    wml = 'wml',+    scheme = 'scheme',+    cfengine = 'cfengine',+    escript = 'erlang',+    haskell = 'haskell',+    clojure = 'clojure',+    ['scala\\>'] = { 'scala', { vim_regex = true } },+    -- Free Pascal+    ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+    ['fennel\\>'] = { 'fennel', { vim_regex = true } },+    -- MikroTik RouterOS script+    ['rsc\\>'] = { 'routeros', { vim_regex = true } },+    -- Fish shell+    ['fish\\>'] = { 'fish', { vim_regex = true } },+    ['gforth\\>'] = { 'forth', { vim_regex = true } },+  }++  for k, v in pairs(patterns) do+    local ft = type(v) == 'table' and v[1] or v+    local opts = type(v) == 'table' and v[2] or {}+    if opts.vim_regex and matchregex(name, k) or name:find(k) then+      return ft+    end+  end+end++local function scripts_no_shebang(path, bufnr)+  local lines = getlines(bufnr, 1, 5)++  if lines[1]:find('^:$') then+    -- Bourne-like shell scripts: sh ksh bash bash2+    return detect.sh(path, bufnr, lines[1])+  elseif matchregex('\n' .. table.concat(lines, '\n'), [[\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>]]) then+    -- Z shell scripts+    return 'zsh'+  end++  local patterns = {+    ['^#compdef\\>'] = { 'zsh', { vim_regex = true } },+    ['^#autoload\\>'] = { 'zsh', { vim_regex = true } },+    -- ELM Mail files+    ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 19%d%d$'] = 'mail',+    ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 20%d%d$'] = 'mail',+    ['^From %- .* 19%d%d$'] = 'mail',+    ['^From %- .* 20%d%d$'] = 'mail',+    -- Mason+    ['^<[%%&].*>'] = 'mason',+    -- Vim scripts (must have '"" vim' as the first line to trigger this)+    ['^"" *[vV]im$['] = 'vim',+    -- libcxx and libstdc++ standard library headers like [""iostream[""] do not have+    -- an extension, recognize the Emacs file mode.+    ['%-%*%-.*[cC]%+%+.*%-%*%-'] = 'cpp',+    ['^\\*\\* LambdaMOO Database, Format Version \\%([1-3]\\>\\)\\@!\\d\\+ \\*\\*$'] = {+      'moo',+      { vim_regex = true },+    },+    -- Diff file:+    -- - ""diff"" in first line (context diff)+    -- - ""Only in "" in first line+    -- - ""--- "" in first line and ""+++ "" in second line (unified diff).+    -- - ""*** "" in first line and ""--- "" in second line (context diff).+    -- - ""# It was generated by makepatch "" in the second line (makepatch diff).+    -- - ""Index: <filename>"" in the first line (CVS file)+    -- - ""=== "", line of ""="", ""---"", ""+++ "" (SVK diff)+    -- - ""=== "", ""--- "", ""+++ "" (bzr diff, common case)+    -- - ""=== (removed|added|renamed|modified)"" (bzr diff, alternative)+    -- - ""# HG changeset patch"" in first line (Mercurial export format)+    ['^\\(diff\\>\\|Only in \\|\\d\\+\\(,\\d\\+\\)\\=[cda]\\d\\+\\>\\|# It was generated by makepatch \\|Index:\\s\\+\\f\\+\\r\\=$\\|===== \\f\\+ \\d\\+\\.\\d\\+ vs edited\\|==== //\\f\\+#\\d\\+\\|# HG changeset patch\\)'] = {+      'diff',+      { vim_regex = true },+    },+    function()+      if+        lines[1]:find('^%-%-%- ') and lines[2]:find('^%+%+%+ ')+        or lines[1]:find('^%* looking for ') and lines[2]:find('^%* comparing to ')+        or lines[1]:find('^%*%*%* ') and lines[2]:find('^%-%-%- ')+        or lines[1]:find('^=== ') and ((lines[2]:find('^' .. string.rep('=', 66)) and lines[3]:find('^%-%-% ') and lines[4]:find(+          '^%+%+%+'+        )) or (lines[2]:find('^%-%-%- ') and lines[3]:find('^%+%+%+ ')))+        or findany(lines[1], { '^=== removed', '^=== added', '^=== renamed', '^=== modified' })+      then+        return 'diff'+      end+    end,+    -- PostScript Files (must have %!PS as the first line, like a2ps output)+    ['^%%![ \t]*PS'] = 'postscr',+    function()+      -- M4 scripts: Guess there is a line that starts with ""dnl"".+      for _, line in ipairs(lines) do+        if matchregex(line, '^\\%sdnl\\>') then+          return 'm4'+        end+      end+      if vim.env.TERM == 'amiga' and findany(lines[1]:lower(), { '^;', '^%.bra' }) then+        -- AmigaDos scripts+        return 'amiga'+      end+    end,+    -- SiCAD scripts (must have procn or procd as the first line to trigger this)+    ['^ *proc[nd] *$'] = { 'sicad', { ignore_case = true } },+    -- Purify log files start with ""****  Purify""+    ['^%*%*%*%*  Purify'] = 'purifylog',+    -- XML+    ['<%?%s*xml.*%?>'] = 'xml',+    -- XHTML (e.g.: PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"")+    ['\\<DTD\\s\\+XHTML\\s'] = 'xhtml',+    -- HTML (e.g.: <!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"")+    -- Avoid ""doctype html"", used by slim.+    ['\\c<!DOCTYPE\\s\\+html\\>'] = { 'html', { vim_regex = true } },+    -- PDF+    ['^%%PDF%-'] = 'pdf',+    -- XXD output+    ['^%x%x%x%x%x%x%x: %x%x ?%x%x ?%x%x ?%x%x '] = 'xxd',+    -- RCS/CVS log output+    ['^RCS file:'] = { 'rcslog', { start_lnum = 1, end_lnum = 2 } },+    -- CVS commit+    ['^CVS:'] = { 'cvs', { start_lnum = 2 } },+    ['^CVS: '] = { 'cvs', { start_lnum = -1 } },+    -- Prescribe+    ['^!R!'] = 'prescribe',+    -- Send-pr+    ['^SEND%-PR:'] = 'sendpr',+    -- SNNS files+    ['^SNNS network definition file'] = 'snnsnet',+    ['^SNNS pattern definition file'] = 'snnspat',+    ['^SNNS result file'] = 'snnsres',+    ['&%%.-[Vv]irata'] = { 'virata', { start_lnum = 1, end_lnum = 5 } },+    ['[0-9:.]* *execve%('] = 'strace',+    ['^__libc_start_main'] = 'strace',+    -- VSE JCL+    ['^\\* $$ JOB\\>'] = { 'vsejcl', { vim_regex = true } },+    ['^// *JOB\\>'] = { 'vsejcl', { vim_regex = true } },+    -- TAK and SINDA+    ['K & K  Associates'] = { 'takout', { start_lnum = 4 } },+    ['TAK 2000'] = { 'takout', { start_lnum = 2 } },+    ['S Y S T E M S   I M P R O V E D '] = { 'syndaout', { start_lnum = 3 } },+    ['Run Date: '] = { 'takcmp', { start_lnum = 6 } },+    ['Node    File  1'] = { 'sindacmp', { start_lnum = 9 } },+    function()+      -- DNS zone files+      if+        findany(+          lines[1] .. lines[2] .. lines[3] .. lines[4],+          { '^; <<>> DiG [0-9%.]+.* <<>>', '%$ORIGIN', '%$TTL', 'IN%s+SOA' }+        )+      then+        return 'bindzone'+      end+      -- BAAN+      if -- 1 to 80 '*' characters+        lines[1]:find('|%*' .. string.rep('%*?', 79)) and lines[2]:find('VRC ')+        or lines[2]:find('|%*' .. string.rep('%*?', 79)) and lines[3]:find('VRC ')+      then+        return 'baan'+      end+    end,+    -- Valgrind+    ['^==%d+== valgrind'] = 'valgrind',+    ['^==%d+== Using valgrind'] = { 'valgrind', { start_lnum = 3 } },+    -- Go docs+    ['PACKAGE DOCUMENTATION$'] = 'godoc',+    -- Renderman Interface Bytestream+    ['^##RenderMan'] = 'rib',+    -- Scheme scripts+    ['exec%s%+%S*scheme'] = { 'scheme', { start_lnum = 1, end_lnum = 2 } },+    -- Git output+    ['^\\(commit\\|tree\\|object\\) \\x\\{40,\\}\\>\\|^tag \\S\\+$'] = { 'git', { vim_regex = true } },+    function()+      -- Gprof (gnu profiler)+      if lines[1] == 'Flat profile:' and lines[2] == '' and lines[3]:find('^Each sample counts as .* seconds%.$') then+        return 'gprof'+      end+    end,+    -- Erlang terms+    -- (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)+    ['%-%*%-.*erlang.*%-%*%-'] = { 'erlang', { ignore_case = true } },+    -- YAML+    ['^&YAML'] = 'yaml',+    -- MikroTik RouterOS script+    ['^#.*by RouterOS'] = 'routeros',+    -- Sed scripts+    -- #ncomment is allowed but most likely a false positive so reuire a space+    -- before any trailing comment text+    ['^#n%s'] = 'sed',+    ['^#n$'] = 'sed',+  }++  for k, v in pairs(patterns) do+    if type(v) == 'string' then+      -- Check the first line only+      if lines[1]:find(k) then+        return v+      end+    elseif type(v) == 'function' then+      local ft = v()+      if ft then+        return ft+      end+    else+      local opts = type(v) == 'table' and v[2] or {}+      if opts.start_lnum then+        assert(not opts.ignore_case, 'ignore_case=true is ignored when start_lnum is also present, needs refactor')+        for _, line in ipairs(getlines(bufnr, opts.start_lnum, opts.end_lnum)) do+          if line:find(k) then+            return v[1]+          end+        end+      else+        -- Check the first line only+        local line = opts.ignore_case and lines[1]:lower() or lines[1]+        if opts.vim_regex and matchregex(line, k) or line:find(k) then+          return v[1]+        end+      end+    end+  end++  -- CVS diff+  for _, line in ipairs(getlines(bufnr, 1, -1)) do+    if not line:find('^%? ') then+      if matchregex(line, [[^Index:\s\+\f\+$]]) then+        return 'diff'+      elseif+        -- Locale input files: Formal Definitions of Cultural Conventions+        -- Filename must be like en_US, fr_FR@euro or en_US.UTF-8+        findany(path, { '%a%a_%a%a$', '%a%a_%a%a[%.@]', '%a%a_%a%ai18n$', '%a%a_%a%aPOSIX$', '%a%a_%a%atranslit_' })+      then+        for _, line_ in ipairs(getlines(bufnr, 1, 100)) do+          if+            findany(line_, {+              '^LC_IDENTIFICATION$',+              '^LC_CTYPE$',+              '^LC_COLLATE$',+              '^LC_MONETARY$',+              '^LC_NUMERIC$',+              '^LC_TIME$',+              '^LC_MESSAGES$',+              '^LC_PAPER$',+              '^LC_TELEPHONE$',+              '^LC_MEASUREMENT$',+              '^LC_NAME$',+              '^LC_ADDRESS$',+            })+          then+            return 'fdcc'+          end+        end+      end+    end+  end+end++local cpo_save = vim.o.cpoptions+vim.cmd('set cpo&vim')++local path = vim.fn.expand('<afile>')+local bufnr = vim.api.nvim_get_current_buf()++local first_line = getlines(bufnr, 1)+local ft = first_line:find('^#!') and scripts_shebang(path, bufnr) or scripts_no_shebang(path, bufnr)++-- luacheck: push ignore 122++vim.bo[bufnr].filetype = ft",Yes I think so because some functions e.g. in the `patterns` table don't always return a ft string,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18935,895194675,2022-06-12T15:33:48Z,runtime/lua/vim/lsp.lua,"@@ -965,6 +965,7 @@ function lsp.start_client(config)     changetracking.reset(client_id)     if code ~= 0 or (signal ~= 0 and signal ~= 15) then       local msg = string.format('Client %s quit with exit code %s and signal %s', client_id, code, signal)+      local _ = log.warn() and log.warn(log_prefix, msg)","certainly should log such things. Is this dummy assignment a common pattern? why can't we just call `log.warn(log_prefix, msg)`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18936,895198297,2022-06-12T15:39:08Z,src/nvim/api/vim.c,"@@ -1679,21 +1465,6 @@ void nvim_del_keymap(uint64_t channel_id, String mode, String lhs, Error *err)   nvim_buf_del_keymap(channel_id, -1, mode, lhs, err); } -/// Gets a map of global (non-buffer-local) Ex commands.-///-/// Currently only |user-commands| are supported, not builtin Ex commands.-///-/// @param  opts  Optional parameters. Currently only supports-///               {""builtin"":false}-/// @param[out]  err   Error details, if any.-///-/// @returns Map of maps describing commands.-Dictionary nvim_get_commands(Dict(get_commands) *opts, Error *err)","if we really don't like this in vim.c, how about renaming vimscript.c to editor.c and put most of the Ex/func stuff there?Though I would still lean towards keeping it in vim.c. Basically vim.c could be ""vim things"" and most other modules are nvim things like lua, rpc, exmarks, etc.",
6705160,williamboman,https://api.github.com/repos/neovim/neovim/pulls/18935,895199982,2022-06-12T15:53:48Z,runtime/lua/vim/lsp.lua,"@@ -965,6 +965,7 @@ function lsp.start_client(config)     changetracking.reset(client_id)     if code ~= 0 or (signal ~= 0 and signal ~= 15) then       local msg = string.format('Client %s quit with exit code %s and signal %s', client_id, code, signal)+      local _ = log.warn() and log.warn(log_prefix, msg)","Agreed it looks really weird. I was following the conventions I found elsewhere. When calling a log function with no args, it returns `true` if  the current log level permits logging. This is however already guarded by [this branch though](https://github.com/williamboman/neovim/blob/3987466c0590ab3664d8ee917eb5ef7c621d9407/runtime/lua/vim/lsp/log.lua#L91-L93), so I'm not entirely sure what the rationale is behind doing this.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18936,895200037,2022-06-12T15:54:39Z,src/nvim/api/vim.c,"@@ -1679,21 +1465,6 @@ void nvim_del_keymap(uint64_t channel_id, String mode, String lhs, Error *err)   nvim_buf_del_keymap(channel_id, -1, mode, lhs, err); } -/// Gets a map of global (non-buffer-local) Ex commands.-///-/// Currently only |user-commands| are supported, not builtin Ex commands.-///-/// @param  opts  Optional parameters. Currently only supports-///               {""builtin"":false}-/// @param[out]  err   Error details, if any.-///-/// @returns Map of maps describing commands.-Dictionary nvim_get_commands(Dict(get_commands) *opts, Error *err)","I think then ""vimscript"" would become too big. I'd regard ex/user commands as a separate feature as in (1) when the user does :%sub/foo/bar or (2) UserCommand where this command is defined in lua, then vimscript/eval features are not really involved. Though I suppose vimscript.c could be renamed eval.c, and also include nvim_x_set_var as these also use eval code",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18936,895200486,2022-06-12T15:58:06Z,src/nvim/api/vim.c,"@@ -1679,21 +1465,6 @@ void nvim_del_keymap(uint64_t channel_id, String mode, String lhs, Error *err)   nvim_buf_del_keymap(channel_id, -1, mode, lhs, err); } -/// Gets a map of global (non-buffer-local) Ex commands.-///-/// Currently only |user-commands| are supported, not builtin Ex commands.-///-/// @param  opts  Optional parameters. Currently only supports-///               {""builtin"":false}-/// @param[out]  err   Error details, if any.-///-/// @returns Map of maps describing commands.-Dictionary nvim_get_commands(Dict(get_commands) *opts, Error *err)","Too small/granular is usually worse than too big, though (as long as there isn't e.g. shared state in the module). Can we wait to see if it actually becomes a problem?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/18936,895202221,2022-06-12T16:14:16Z,src/nvim/api/vim.c,"@@ -1679,21 +1465,6 @@ void nvim_del_keymap(uint64_t channel_id, String mode, String lhs, Error *err)   nvim_buf_del_keymap(channel_id, -1, mode, lhs, err); } -/// Gets a map of global (non-buffer-local) Ex commands.-///-/// Currently only |user-commands| are supported, not builtin Ex commands.-///-/// @param  opts  Optional parameters. Currently only supports-///               {""builtin"":false}-/// @param[out]  err   Error details, if any.-///-/// @returns Map of maps describing commands.-Dictionary nvim_get_commands(Dict(get_commands) *opts, Error *err)","I don't think anything is becoming too granular either. Each new module in this PR is pretty big. It would be ""wait and see"" on that part as well.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16271,895253626,2022-06-13T00:19:44Z,test/functional/vimscript/system_spec.lua,"@@ -190,6 +190,27 @@ describe('system()', function()       eq(iswin() and '??\n' or '������\n', eval([[system('Write-Output ""������""')]]))     end) +    it('check powershell filter and redirection (#16271)', function()","since there is no unix test here, let's add it to the windows-only tests here:https://github.com/neovim/neovim/blob/e420cd6c67a0aad5b5dcb40748f733876e66a2c3/test/functional/vimscript/system_spec.lua#L128",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16271,895253756,2022-06-13T00:20:52Z,test/functional/vimscript/system_spec.lua,"@@ -190,6 +190,27 @@ describe('system()', function()       eq(iswin() and '??\n' or '������\n', eval([[system('Write-Output ""������""')]]))     end) +    it('check powershell filter and redirection (#16271)', function()+      if iswin() then+        local tempfile = helpers.tmpname()+        nvim('set_option', 'shell', 'pwsh')+        nvim('set_option', 'shellcmdflag', '-NoLogo -NoProfile -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;')+        nvim('set_option', 'shellredir', '-RedirectStandardOutput %s -NoNewWindow -Wait')+        nvim('set_option', 'shellpipe', '-RedirectStandardOutput %s -NoNewWindow -Wait')+        nvim('set_option', 'shellquote', '')+        nvim('set_option', 'shellxquote', '')+        screen:try_resize(100, 14)+        feed(':edit ' .. tempfile .. '<cr>')+        feed('i3<cr>1<cr>2<esc>:write<cr>')+        feed(':4verbose %!sort<cr>')+        screen:expect{+          any=[[3 lines filtered]]","can we also check that the args (RedirectStandardOutput, etc) are printed ? That's why `:4verbose` is used, right?Note that `any` supports a Lua pattern.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/18927,895513896,2022-06-13T09:27:40Z,test/functional/api/version_spec.lua,"@@ -93,6 +93,7 @@ describe(""api metadata"", function()   local api, compat, stable, api_level   local old_api = {}   setup(function()+    clear() -- this should called to create a session before trying to request api_info","because `setup()` gets called first> You can also use the functions `before_each` and `after_each` to define functions that should be run before any nested tests, and `setup` and `teardown` for functions that should be run before and after the `describe` block.try this```diffdiff --git a/test/functional/api/version_spec.lua b/test/functional/api/version_spec.luaindex 390c9a20f..645afc036 100644--- a/test/functional/api/version_spec.lua+++ b/test/functional/api/version_spec.lua@@ -47,7 +47,10 @@ end)   describe(""api metadata"", function()-  before_each(clear)+  before_each(function()+    clear()+    eq(nil, _G.api_methods)+  end)    local function name_table(entries)     local by_name = {}@@ -93,6 +96,7 @@ describe(""api metadata"", function()   local api, compat, stable, api_level   local old_api = {}   setup(function()+    _G.api_methods = 2     clear() -- this should called to create a session before trying to request api_info     api = meths.get_api_info()[2]     compat  = api.version.api_compatible```here are the results```console$ TEST_FILE=test/functional/api/version_spec.lua cmake --build build --target functionaltest[----------] Global test environment setup.[----------] Running tests from test/functional/api/version_spec.lua[ RUN      ] api_info()['version'] returns API level: 6.71 ms OK[ RUN      ] api_info()['version'] returns Nvim version: 6.58 ms OKnan ms test/helpers.lua:73: Expected objects to be the same.Passed in:(number) 2Expected:(nil)```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/18448,896337376,2022-06-14T03:22:47Z,src/nvim/eval.c,"@@ -8985,8 +8985,8 @@ static void delete_var(hashtab_T *ht, hashitem_T *hi) static void list_one_var(dictitem_T *v, const char *prefix, int *first) {   char *const s = encode_tv2echo(&v->di_tv, NULL);-  list_one_var_a(prefix, (const char *)v->di_key, STRLEN(v->di_key),-                 v->di_tv.v_type, (s == NULL ? """" : s), first);+  list_one_var_a(prefix, (const char *)v->di_key, (ptrdiff_t)STRLEN(v->di_key),+                 (int)v->di_tv.v_type, (s == NULL ? """" : s), first);",Third argument of `list_one_var_a()` can be changed to `VarType` type,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17099,896532817,2022-06-14T08:31:39Z,runtime/doc/treesitter.txt,"@@ -429,10 +429,10 @@ add_predicate({name}, {handler}, {force})                    *add_predicate()*                                be (match, pattern, bufnr, predicate)  get_node_text({node}, {source})                              *get_node_text()*-                Gets the text corresponding to a given node+                Gets the text corresponding to a given node or a list of nodes                  Parameters: ~-                    {node}    the node+                    {node}    the node or list of nodes",What is a return value/type when a list of nodes is passed? List of strings or a single string?,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17099,896535009,2022-06-14T08:33:41Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -340,7 +340,9 @@ function LanguageTree:_get_injections()          -- Allow for captured nodes to be used         if type(content) == 'number' then-          content = { match[content]:range() }+          for _, node in ipairs(match[content]) do+            vim.list_extend(ranges, { node:range() })",Is `list_extend` right here? Can't we have `ranges[#ranges+1] = node:range()`?,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17099,896536925,2022-06-14T08:35:31Z,runtime/lua/vim/treesitter/query.lua,"@@ -179,11 +179,19 @@ function M.parse_query(lang, query)   end end ---- Gets the text corresponding to a given node+--- Gets the text corresponding to a given node or a list of nodes -------@param node the node+---@param node the node or list of nodes ---@param source The buffer or string from which the node is extracted function M.get_node_text(node, source)+  -- If node is a list of nodes then return their concatenated text+  if node['start'] == nil and type(node) == 'table' then",Shouldn't these conditions be in reverse order? You can't check an index is present without knowing the variable is a table first.```suggestion  if type(node) == 'table' and node['start'] == nil then```,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17099,896538592,2022-06-14T08:37:10Z,runtime/lua/vim/treesitter/query.lua,"@@ -179,11 +179,19 @@ function M.parse_query(lang, query)   end end ---- Gets the text corresponding to a given node+--- Gets the text corresponding to a given node or a list of nodes -------@param node the node+---@param node the node or list of nodes ---@param source The buffer or string from which the node is extracted function M.get_node_text(node, source)+  -- If node is a list of nodes then return their concatenated text+  if node['start'] == nil and type(node) == 'table' then+    local text = ''+    for _, node1 in ipairs(node) do+      text = text .. M.get_node_text(node1, source)","string concatenation in Lua is horribly slow. A better idiom is to populate a table first and then call `table.concat`.However, it may be better to change the signature of this to return a list of strings?",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17099,896554415,2022-06-14T08:52:20Z,runtime/lua/vim/treesitter/query.lua,"@@ -328,24 +336,25 @@ local directive_handlers = {   -- Example: (#offset! @_node 0 1 0 -1)   ['offset!'] = function(match, _, _, pred, metadata)     local capture_id = pred[2]-    local offset_node = match[capture_id]-    local range = { offset_node:range() }-    local start_row_offset = pred[3] or 0-    local start_col_offset = pred[4] or 0-    local end_row_offset = pred[5] or 0-    local end_col_offset = pred[6] or 0--    range[1] = range[1] + start_row_offset-    range[2] = range[2] + start_col_offset-    range[3] = range[3] + end_row_offset-    range[4] = range[4] + end_col_offset--    -- If this produces an invalid range, we just skip it.-    if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      if not metadata[capture_id] then-        metadata[capture_id] = {}+    for _, offset_node in ipairs(match[capture_id]) do",Probably worth adding a TODO here to change the metadata format to accommodate multiple nodes.,
10165741,MDeiml,https://api.github.com/repos/neovim/neovim/pulls/17099,896602079,2022-06-14T09:37:46Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -340,7 +340,9 @@ function LanguageTree:_get_injections()          -- Allow for captured nodes to be used         if type(content) == 'number' then-          content = { match[content]:range() }+          for _, node in ipairs(match[content]) do+            vim.list_extend(ranges, { node:range() })","This seemed weird to me as well, but I trusted the old implementation here, which was to add `content` with `list_extend` a few lines down. Test also pass, but I'll have a look at this again.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17099,897673653,2022-06-15T08:13:57Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -340,7 +340,9 @@ function LanguageTree:_get_injections()          -- Allow for captured nodes to be used         if type(content) == 'number' then-          content = { match[content]:range() }+          for _, node in ipairs(match[content]) do+            vim.list_extend(ranges, { node:range() })",So then why not `ranges[#ranges+1] = {node:range()}`?Isn't `ranges` a list of ranges (a.k.a a list of integer lists)? `vim.list_extend` will just make ranges a list of integers?,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17099,897675582,2022-06-15T08:15:57Z,runtime/lua/vim/treesitter/query.lua,"@@ -179,11 +179,19 @@ function M.parse_query(lang, query)   end end ---- Gets the text corresponding to a given node+--- Gets the text corresponding to a given node or a list of nodes -------@param node the node+---@param node the node or list of nodes ---@param source The buffer or string from which the node is extracted function M.get_node_text(node, source)+  -- If node is a list of nodes then return their concatenated text+  if node['start'] == nil and type(node) == 'table' then+    local text = ''+    for _, node1 in ipairs(node) do+      text = text .. M.get_node_text(node1, source)","Sure. When passing a single node which isn't a list, a single string should be returned.I'm just contemplating whether if a list is given as the input, then a list is returned? Should remain compat and doesn't remove information.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18813,898194183,2022-06-15T16:34:38Z,runtime/lua/vim/filetype.lua,"@@ -793,11 +979,7 @@ local extension = {   tutor = 'tutor',   twig = 'twig',   ts = function(path, bufnr)-    if getline(bufnr, 1):find('<%?xml') then-      return 'xml'-    else-      return 'typescript'-    end+    return M.getlines(bufnr, 1):find('<%?xml') and 'xml' or 'typescript'","Yeah, that is a valid point. I was just going by the previous discussion (content check => detect.lua). We can come up with other rules; the main part is pick something workable and document it so it won't be a dice roll next time a pattern needs to be ported or implemented ;)",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15831,899262520,2022-06-16T16:07:32Z,runtime/doc/vim_diff.txt,"@@ -383,6 +383,8 @@ Normal commands: Options:   'ttimeout', 'ttimeoutlen' behavior was simplified   |jumpoptions| ""stack"" behavior+  |jumpoptions| ""view"" behavior which makes navigation less confusing, and+  also applies to |mark-motions|.","@gpanders What about:```  |jumpoptions| ""view"" Which tries restore the |mark-view| when moving through  the jumplist, |changelist|, |alternate-file| or using |mark-motions|.```",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19015,900998584,2022-06-18T17:29:51Z,CMakeLists.txt,"@@ -767,17 +760,8 @@ if(BUSTED_LUA_PRG)     set_target_properties(functionaltest-lua PROPERTIES FOLDER test) endif() -#add uninstall target-if(NOT TARGET uninstall)-    configure_file(-        ""cmake/UninstallHelper.cmake.in""-        ""${CMAKE_CURRENT_BINARY_DIR}/UninstallHelper.cmake""-        IMMEDIATE @ONLY)--    add_custom_target(uninstall-        COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/UninstallHelper.cmake)-endif()-+add_custom_target(uninstall+  COMMAND ${CMAKE_COMMAND} -P ${PROJECT_SOURCE_DIR}/cmake/UninstallHelper.cmake)","This is taken straight from the [cmake FAQ](https://gitlab.kitware.com/cmake/community/-/wikis/FAQ#can-i-do-make-uninstall-with-cmake). This particular code snippet has existed for a VERY long time (since around 2010). The `IMMEDIATE` for `configure_file` is an undocumented keyword kept for backwards compatibility. It was officially ""removed"" in 2.x. It's so long ago that finding information about it is difficult. I think it's one of those ""Well, no need to change it if it works"" situations taken to the extreme.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/18932,901055090,2022-06-19T06:32:35Z,src/nvim/ui.c,"@@ -18,6 +18,7 @@ #include ""nvim/ex_getln.h"" #include ""nvim/fold.h"" #include ""nvim/garray.h""+#include ""nvim/globals.h""",I don't think it is necessary because it is included in the following section of `vim.h`.https://github.com/neovim/neovim/blob/7b2b44bce4bff85d9fd1bef09d294ddb889056e4/src/nvim/vim.h#L296,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18961,901079135,2022-06-19T09:57:00Z,src/nvim/window.c,"@@ -5543,9 +5543,10 @@ static void frame_setheight(frame_T *curfrp, int height)   if (curfrp->fr_parent == NULL) {     // topframe: can only change the command line     if (height > ROWS_AVAIL) {-      // If height is greater than the available space, try to create space for the frame by-      // reducing 'cmdheight' if possible, while making sure `cmdheight` doesn't go below 1.-      height = MIN(ROWS_AVAIL + (p_ch - 1), height);+      // If height is greater than the available space, try to create space for+      // the frame by reducing 'cmdheight' if possible, while making sure+      // `cmdheight` doesn't go below 1.",Last year we changed the style guide to allow lines up to 100 chars long. Don't need to reformat this comment.,
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/18961,901081104,2022-06-19T10:12:43Z,src/nvim/window.c,"@@ -5543,9 +5543,10 @@ static void frame_setheight(frame_T *curfrp, int height)   if (curfrp->fr_parent == NULL) {     // topframe: can only change the command line     if (height > ROWS_AVAIL) {-      // If height is greater than the available space, try to create space for the frame by-      // reducing 'cmdheight' if possible, while making sure `cmdheight` doesn't go below 1.-      height = MIN(ROWS_AVAIL + (p_ch - 1), height);+      // If height is greater than the available space, try to create space for+      // the frame by reducing 'cmdheight' if possible, while making sure+      // `cmdheight` doesn't go below 1.","Oh, I have not know this.I just found the comment line is too long.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19010,901108144,2022-06-19T13:35:55Z,test/functional/ui/decorations_spec.lua,"@@ -866,6 +866,36 @@ end]]   end) end) +describe('extmark conceal', function()+  local screen, ns+  before_each( function()+    clear()+    screen = Screen.new(50, 5)+    screen:attach()+    screen:set_default_attr_ids {+      [0] = {bold=true, foreground=Screen.colors.Blue};+      [1] = {background=Screen.colors.DarkGrey, foreground=Screen.colors.LightGrey};+    }++    ns = meths.create_namespace 'test'+  end)++  it('conceals', function()+    insert([[+foo+]])",for future reference: insert()..rawfeed() does `dedent()` so the string literal can be nicely indented. Also insert() takes a list of lines.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19020,901156026,2022-06-19T20:50:37Z,src/nvim/eval/funcs.c,"@@ -8053,14 +8055,16 @@ static void f_screenchar(typval_T *argvars, typval_T *rettv, FunPtr fptr) {   int c; +  ScreenGrid *grid;   int row = tv_get_number_chk(&argvars[0], NULL) - 1;   int col = tv_get_number_chk(&argvars[1], NULL) - 1;-  if (row < 0 || row >= default_grid.rows-      || col < 0 || col >= default_grid.cols) {++  screenchar_adjust(&grid, &row, &col);++  if (row < 0 || row >= grid->rows+      || col < 0 || col >= grid->cols) {",nit: can be on 1 line (similar for the other functions),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19029,901646716,2022-06-20T13:11:24Z,.github/workflows/release.yml,"@@ -118,6 +118,63 @@ jobs:           path: build/release/nvim-macos.tar.gz           retention-days: 1 +  macOS-universal:+    runs-on: macos-11+    steps:+      - uses: actions/checkout@v3+        with:+          fetch-depth: 0+      - name: Install brew packages+        run: |+          brew update --quiet+          brew install automake ninja+      - if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name != 'nightly')+        run: printf 'NVIM_BUILD_TYPE=Release\n' >> $GITHUB_ENV+      - if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name == 'nightly')+        run: printf 'NVIM_BUILD_TYPE=RelWithDebInfo\n' >> $GITHUB_ENV+      - name: Provision universal `libintl`+        run: |+          bottle_tag=""arm64_big_sur""+          brew fetch --bottle-tag=""$bottle_tag"" gettext+          cd ""$(mktemp -d)""+          tar xf ""$(brew --cache)""/**/*gettext*${bottle_tag}*.tar.gz+          gettext_prefix=""$(brew --prefix gettext)""+          broken_install_name=""$(otool -D gettext/*/lib/libintl.dylib | sed 1d)""+          fixed_install_name=""$(otool -D ""${gettext_prefix}/lib/libintl.dylib"" | sed 1d)""+          libintl_basename=""$(basename ""$fixed_install_name"")""+          install_name_tool -change ""$broken_install_name"" ""$fixed_install_name"" gettext/*/lib/""$libintl_basename""+          lipo gettext/*/lib/""$libintl_basename"" \+               ""${gettext_prefix}/lib/${libintl_basename}"" \+               -create -output ""$libintl_basename""+          mv -f ""$libintl_basename"" ""${gettext_prefix}/lib/${libintl_basename}""+      - name: Build release+        run: |+          CMAKE_EXTRA_FLAGS=""-DCMAKE_INSTALL_PREFIX:PATH= -DCMAKE_OSX_DEPLOYMENT_TARGET=11 -DCMAKE_OSX_ARCHITECTURES=\\\""arm64;x86_64\\\""""","Try `\;`(in cmake, `;` is how a ""list"" is internally encoded, but `\;` should work around this)",
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19029,901673342,2022-06-20T13:39:15Z,.github/workflows/notes.md,"@@ -18,12 +18,18 @@ ${NVIM_VERSION} 2. Run the MSI 3. Search and run `nvim-qt.exe` or run `nvim.exe` on your CLI of choice. -### macOS+### macOS 10.11+  1. Download **nvim-macos.tar.gz** 2. Extract: `tar xzvf nvim-macos.tar.gz` 3. Run `./nvim-osx64/bin/nvim` +### macOS 11+ (Universal)","Having a single universal build is tricky. Ideally you'll want to set different `MACOSX_DEPLOYMENT_TARGET`/`CMAKE_OSX_DEPLOYMENT_TARGET`s for each arch slice (`10.11` for `x86_64`, `11` for `arm64`), and `cmake` doesn't make it easy to set arch-dependent depoloyment targets. Setting only one means you end up with a binary with restricted portability (deployment target too high) or with a possibly broken `arm64` slice (deployment target too low).One way to do this is to build for each arch separately and then use `lipo` to bundle them all up.If I can get this approach for a universal build working then this alternative approach (build separately + bundle together with `lipo`) should be relatively straightforward.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19032,902049641,2022-06-20T23:32:34Z,src/nvim/api/vimscript.c,"@@ -94,6 +106,31 @@ String nvim_exec(uint64_t channel_id, String src, Boolean output, Error *err)   return (String)STRING_INIT; } +/// Executes Vimscript (multiline block of Ex commands), like anonymous+/// |:source|.+///+/// Unlike |nvim_command()| this function supports heredocs, script-scope (s:),+/// etc.+///+/// On execution error: fails with VimL error, updates v:errmsg.+///+/// @see |execute()|+/// @see |nvim_command()|+/// @see |nvim_cmd()|+///+/// @param src      Vimscript code+/// @param output   Capture and return all (non-error, non-shell |:!|) output+/// @param[out] err Error details (Vim error), if any+/// @return Output (non-error, non-shell |:!|) if `output` is true,+///         else empty string.",can omit the doc except one `@deprecated use nvim_exec2` line,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19032,902052865,2022-06-20T23:43:53Z,src/nvim/api/vimscript.c,"@@ -39,13 +39,25 @@ /// @see |nvim_cmd()| /// /// @param src      Vimscript code-/// @param output   Capture and return all (non-error, non-shell |:!|) output+/// @param opts  Optional parameters.+///         - output: Capture and return all (non-error, non-shell |:!|) output.+///           Default: `false`. /// @param[out] err Error details (Vim error), if any-/// @return Output (non-error, non-shell |:!|) if `output` is true,+/// @return Output (non-error, non-shell |:!|) if `opts.output` is true, ///         else empty string.-String nvim_exec(uint64_t channel_id, String src, Boolean output, Error *err)-  FUNC_API_SINCE(7)+String nvim_exec2(uint64_t channel_id, String src, Dict(exec) *opts, Error *err)+  FUNC_API_SINCE(10) {+  Boolean output = false;+  if (HAS_KEY(opts->output)) {+    if (opts->output.type != kObjectTypeBoolean) {+      api_set_error(err, kErrorTypeValidation, ""'output' should be boolean"");+      return (String)STRING_INIT;+    }++    output = opts->output.data.boolean;+  }+   const int save_msg_silent = msg_silent;",using `TRY_WRAP` may improve exception behavior. Don't need to make this optional.see other functions in this file for `TRY_WRAP` example usage. https://github.com/neovim/neovim/blob/f4518ef56d26ef77a6622b8a7ff7660a96ac3781/src/nvim/api/vimscript.c#L130,
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19029,902356909,2022-06-21T09:02:14Z,third-party/cmake/BuildLuajit.cmake,"@@ -30,13 +30,14 @@ function(BuildLuajit)     CONFIGURE_COMMAND ""${_luajit_CONFIGURE_COMMAND}""     BUILD_IN_SOURCE 1     BUILD_COMMAND ""${_luajit_BUILD_COMMAND}""-    INSTALL_COMMAND ""${_luajit_INSTALL_COMMAND}"")+    INSTALL_COMMAND ""${_luajit_INSTALL_COMMAND}""+    DEPENDS ""${_luajit_DEPENDS}"")    # Create symlink for development version manually.   if(UNIX)     add_custom_command(       TARGET ${_luajit_TARGET}-      COMMAND ${CMAKE_COMMAND} -E create_symlink luajit-2.1.0-beta3 ${DEPS_BIN_DIR}/luajit)+      COMMAND ${CMAKE_COMMAND} -E create_symlink luajit-2.1.0-beta3 ${DEPS_BIN_DIR}/${_luajit_TARGET})","This seems to make my build woes go away. I don't understand why, but it does.For context:Without this, I get [errors](https://github.com/carlocab/neovim/runs/6979698925?check_suite_focus=true#step:7:2393) about the failure to create a symlink because the file already exists. I tried making the `add_custom_command` call conditional on `_luajit_TARGET` being equal to `luajit` (https://github.com/neovim/neovim/pull/19029/commits/0c4f94ecfb912adf8d7c8fac59c659e70b7609f5), but that didn't seem to work. But I may have just done that wrong.",
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19029,902368271,2022-06-21T09:13:15Z,third-party/cmake/BuildLuajit.cmake,"@@ -30,13 +30,14 @@ function(BuildLuajit)     CONFIGURE_COMMAND ""${_luajit_CONFIGURE_COMMAND}""     BUILD_IN_SOURCE 1     BUILD_COMMAND ""${_luajit_BUILD_COMMAND}""-    INSTALL_COMMAND ""${_luajit_INSTALL_COMMAND}"")+    INSTALL_COMMAND ""${_luajit_INSTALL_COMMAND}""+    DEPENDS ""${_luajit_DEPENDS}"")    # Create symlink for development version manually.   if(UNIX)     add_custom_command(       TARGET ${_luajit_TARGET}-      COMMAND ${CMAKE_COMMAND} -E create_symlink luajit-2.1.0-beta3 ${DEPS_BIN_DIR}/luajit)+      COMMAND ${CMAKE_COMMAND} -E create_symlink luajit-2.1.0-beta3 ${DEPS_BIN_DIR}/${_luajit_TARGET})","Not exactly. I build intermediate luajit targets [here](https://github.com/neovim/neovim/blob/fd2329a80be0ff405e058cbed0d5ebc4201e3a73/third-party/cmake/BuildLuajit.cmake#L91-L96):```cmake    BuildLuaJit(TARGET ""luajit-${ARCH}""        BUILD_COMMAND ${BUILDCMD_UNIX}        CC=${LUAJIT_C_COMPILER} STATIC_CC=${STATIC_CC}        DYNAMIC_CC=${DYNAMIC_CC} TARGET_LD=${TARGET_LD}        PREFIX=${DEPS_INSTALL_DIR}        ${DEPLOYMENT_TARGET})```",
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19029,902371199,2022-06-21T09:15:54Z,third-party/cmake/BuildLuajit.cmake,"@@ -51,30 +52,58 @@ if(CMAKE_SYSTEM_NAME MATCHES ""OpenBSD"") else()   set(AMD64_ABI """") endif()-set(INSTALLCMD_UNIX ${MAKE_PRG} CFLAGS=-fPIC-                                CFLAGS+=-DLUA_USE_APICHECK-                                CFLAGS+=-funwind-tables-                                ${NO_STACK_CHECK}-                                ${AMD64_ABI}-                                CCDEBUG+=-g-                                Q=-                                install)+set(BUILDCMD_UNIX ${MAKE_PRG} CFLAGS=-fPIC+                              CFLAGS+=-DLUA_USE_APICHECK+                              CFLAGS+=-funwind-tables+                              ${NO_STACK_CHECK}+                              ${AMD64_ABI}+                              CCDEBUG+=-g+                              Q=) -if(UNIX)-  if(CMAKE_SYSTEM_NAME STREQUAL ""Darwin"")-    if(CMAKE_OSX_DEPLOYMENT_TARGET)-      set(DEPLOYMENT_TARGET ""MACOSX_DEPLOYMENT_TARGET=${CMAKE_OSX_DEPLOYMENT_TARGET}"")-    else()-      # Use the same target as our nightly builds-      set(DEPLOYMENT_TARGET ""MACOSX_DEPLOYMENT_TARGET=10.11"")-    endif()+if(CMAKE_SYSTEM_NAME STREQUAL ""Darwin"")+  if(CMAKE_OSX_DEPLOYMENT_TARGET)+    set(DEPLOYMENT_TARGET ""MACOSX_DEPLOYMENT_TARGET=${CMAKE_OSX_DEPLOYMENT_TARGET}"")   else()-    set(DEPLOYMENT_TARGET """")+    # Use the same target as our nightly builds+    set(DEPLOYMENT_TARGET ""MACOSX_DEPLOYMENT_TARGET=10.11"")   endif()+else()+  set(DEPLOYMENT_TARGET """")+endif() -  BuildLuaJit(INSTALL_COMMAND ${INSTALLCMD_UNIX}+if(UNIX AND NOT CMAKE_OSX_ARCHITECTURES)+  BuildLuaJit(INSTALL_COMMAND ${BUILDCMD_UNIX}     CC=${DEPS_C_COMPILER} PREFIX=${DEPS_INSTALL_DIR}-    ${DEPLOYMENT_TARGET})+    ${DEPLOYMENT_TARGET} install)++elseif(CMAKE_OSX_ARCHITECTURES AND APPLE)++  set(LUAJIT_SRC_DIR ""${DEPS_BUILD_DIR}/src/luajit"")+  foreach(ARCH IN LISTS CMAKE_OSX_ARCHITECTURES)+    set(STATIC_CC ""${LUAJIT_C_COMPILER} -arch ${ARCH}"")+    set(DYNAMIC_CC ""${LUAJIT_C_COMPILER} -arch ${ARCH} -fPIC"")+    set(TARGET_LD ""${LUAJIT_C_COMPILER} -arch ${ARCH}"")+    list(APPEND LUAJIT_THIN_EXECUTABLES ""${LUAJIT_SRC_DIR}-${ARCH}/src/luajit"")+    list(APPEND LUAJIT_THIN_STATIC_LIBS ""${LUAJIT_SRC_DIR}-${ARCH}/src/libluajit.a"")+    list(APPEND LUAJIT_THIN_DYLIBS ""${LUAJIT_SRC_DIR}-${ARCH}/src/libluajit.so"")+    list(APPEND LUAJIT_THIN_DEPS ""luajit-${ARCH}"")++    BuildLuaJit(TARGET ""luajit-${ARCH}""+        BUILD_COMMAND ${BUILDCMD_UNIX}+        CC=${LUAJIT_C_COMPILER} STATIC_CC=${STATIC_CC}+        DYNAMIC_CC=${DYNAMIC_CC} TARGET_LD=${TARGET_LD}+        PREFIX=${DEPS_INSTALL_DIR}+        ${DEPLOYMENT_TARGET})","For reference (I should/will add this to a commit message):The extra flags are taken from https://luajit.org/install.html, in the section on cross-compiling.We could technically define a `CROSS` variable instead, but this would require creating executable stubs like `arm64-apple-darwin-clang` that basically just call `clang -arch arm64`.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19038,902412714,2022-06-21T09:55:10Z,src/nvim/api/options.c,"@@ -486,66 +457,29 @@ void set_option_to(uint64_t channel_id, void *to, int type, String name, Object                           ? 0 : (type == SREQ_GLOBAL)                                 ? OPT_GLOBAL : OPT_LOCAL; -    set_option_value_for(name.data, numval, stringval,-                         opt_flags, type, to, err);+    get_or_set_option_value_for(name.data, &numval, &stringval, opt_flags, type, to, false, err);   }); } -void set_option_value_for(char *key, long numval, char *stringval, int opt_flags, int opt_type,-                          void *from, Error *err)+static int get_or_set_option_value(char *key, long *numval, char **stringval, int opt_flags, bool get, Error *err) {-  switchwin_T switchwin;-  aco_save_T aco;--  try_start();-  switch (opt_type) {-  case SREQ_WIN:-    if (switch_win_noblock(&switchwin, (win_T *)from, win_find_tabpage((win_T *)from), true)-        == FAIL) {-      restore_win_noblock(&switchwin, true);+  if (get) {+    return get_option_value(key, numval, stringval, opt_flags);+  } else {+    char *errmsg;+    if ((errmsg = set_option_value(key, *numval, *stringval, opt_flags))) {       if (try_end(err)) {-        return;+        return 0;       }-      api_set_error(err,-                    kErrorTypeException,-                    ""Problem while switching windows"");-      return;-    }-    set_option_value_err(key, numval, stringval, opt_flags, err);-    restore_win_noblock(&switchwin, true);-    break;-  case SREQ_BUF:-    aucmd_prepbuf(&aco, (buf_T *)from);-    set_option_value_err(key, numval, stringval, opt_flags, err);-    aucmd_restbuf(&aco);-    break;-  case SREQ_GLOBAL:-    set_option_value_err(key, numval, stringval, opt_flags, err);-    break;-  }--  if (ERROR_SET(err)) {-    return;-  }--  try_end(err);-} -static void set_option_value_err(char *key, long numval, char *stringval, int opt_flags, Error *err)-{-  char *errmsg;--  if ((errmsg = set_option_value(key, numval, stringval, opt_flags))) {-    if (try_end(err)) {-      return;+      api_set_error(err, kErrorTypeException, ""%s"", errmsg);     }--    api_set_error(err, kErrorTypeException, ""%s"", errmsg);+    return 0;   } } -int get_option_value_for(char *key, long *numval, char **stringval, int opt_flags, int opt_type,-                         void *from, Error *err)+static int get_or_set_option_value_for(char *key, long *numval, char **stringval, int opt_flags, int opt_type,","```Use existing common {action} names if possible:    add     Append to, or insert into, a collection    create  Create a new thing    del     Delete a thing (or group of things)    exec    Execute code    get     Get a thing (or group of things by query)    list    Get all things    set     Set a thing (or group of things)```Hm.... I'm not sure there is an ideal solution here.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19038,902426944,2022-06-21T10:10:41Z,src/nvim/api/options.c,"@@ -486,66 +457,29 @@ void set_option_to(uint64_t channel_id, void *to, int type, String name, Object                           ? 0 : (type == SREQ_GLOBAL)                                 ? OPT_GLOBAL : OPT_LOCAL; -    set_option_value_for(name.data, numval, stringval,-                         opt_flags, type, to, err);+    get_or_set_option_value_for(name.data, &numval, &stringval, opt_flags, type, to, false, err);   }); } -void set_option_value_for(char *key, long numval, char *stringval, int opt_flags, int opt_type,-                          void *from, Error *err)+static int get_or_set_option_value(char *key, long *numval, char **stringval, int opt_flags, bool get, Error *err) {-  switchwin_T switchwin;-  aco_save_T aco;--  try_start();-  switch (opt_type) {-  case SREQ_WIN:-    if (switch_win_noblock(&switchwin, (win_T *)from, win_find_tabpage((win_T *)from), true)-        == FAIL) {-      restore_win_noblock(&switchwin, true);+  if (get) {+    return get_option_value(key, numval, stringval, opt_flags);+  } else {+    char *errmsg;+    if ((errmsg = set_option_value(key, *numval, *stringval, opt_flags))) {       if (try_end(err)) {-        return;+        return 0;       }-      api_set_error(err,-                    kErrorTypeException,-                    ""Problem while switching windows"");-      return;-    }-    set_option_value_err(key, numval, stringval, opt_flags, err);-    restore_win_noblock(&switchwin, true);-    break;-  case SREQ_BUF:-    aucmd_prepbuf(&aco, (buf_T *)from);-    set_option_value_err(key, numval, stringval, opt_flags, err);-    aucmd_restbuf(&aco);-    break;-  case SREQ_GLOBAL:-    set_option_value_err(key, numval, stringval, opt_flags, err);-    break;-  }--  if (ERROR_SET(err)) {-    return;-  }--  try_end(err);-} -static void set_option_value_err(char *key, long numval, char *stringval, int opt_flags, Error *err)-{-  char *errmsg;--  if ((errmsg = set_option_value(key, numval, stringval, opt_flags))) {-    if (try_end(err)) {-      return;+      api_set_error(err, kErrorTypeException, ""%s"", errmsg);     }--    api_set_error(err, kErrorTypeException, ""%s"", errmsg);+    return 0;   } } -int get_option_value_for(char *key, long *numval, char **stringval, int opt_flags, int opt_type,-                         void *from, Error *err)+static int get_or_set_option_value_for(char *key, long *numval, char **stringval, int opt_flags, int opt_type,","> Hmm... ""Do two things"" is not a great function ;) Don't look too hard into this codebase then ���� > Does the refactor make it harder to implement or fix something for get or set in the future?)I really don't think so, and if it turns out to be the case, it would be fairly straight-forward to re-specialise these. > Can you summarize in one sentence what this function does?Emm, this ""gets"" ""or"" ""sets"" an ""option"" ""value"" ""for"" a given scope ���� The main reason I wanted to refactor this was for the buf and win cases which need to set up and restore context, and it's what specifically makes the semantics of options nuanced, and thus did not want it repeated more than once.The fact this sets or gets an option isn't the main concern here, as that is down further down. I think the risks of these code paths unintentionally diverging is more of a concern. I.e. if someone changes the semantics of _set_, they must be forced to consider if _get_ should also be changed.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19029,902640593,2022-06-21T13:45:04Z,.github/workflows/notes.md,"@@ -18,12 +18,18 @@ ${NVIM_VERSION} 2. Run the MSI 3. Search and run `nvim-qt.exe` or run `nvim.exe` on your CLI of choice. -### macOS+### macOS 10.11+  1. Download **nvim-macos.tar.gz** 2. Extract: `tar xzvf nvim-macos.tar.gz` 3. Run `./nvim-osx64/bin/nvim` +### macOS 11+ (Universal)",">This is because we pre-compile Lua sources into byte-code, which requires a lua[jit] compiler that runs on the host machine.This is optional and a ""nice to have"", but needn't be a show stopper. From a perspective of ""why not squeeze out as much performance as possible so long as it's easy to do?"" it makes sense, but sacrificing pre-compilation for portability is a perfectly sane tradeoff.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19029,902685256,2022-06-21T14:21:19Z,.github/workflows/notes.md,"@@ -18,12 +18,18 @@ ${NVIM_VERSION} 2. Run the MSI 3. Search and run `nvim-qt.exe` or run `nvim.exe` on your CLI of choice. -### macOS+### macOS 10.11+  1. Download **nvim-macos.tar.gz** 2. Extract: `tar xzvf nvim-macos.tar.gz` 3. Run `./nvim-osx64/bin/nvim` +### macOS 11+ (Universal)","According to https://luajit.org/extensions.html#string_dump:>The generated bytecode is portable and can be loaded on any architecture that LuaJIT supports, independent of word size or endianess. However the bytecode compatibility versions must match. Bytecode stays compatible for dot releases (x.y.0 ��� x.y.1), but may change with major or minor releases (2.0 ��� 2.1) or between any beta release.So it sounds like it should work.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16271,903701281,2022-06-22T12:49:39Z,test/functional/ex_cmds/shell_filter_spec.lua,"@@ -0,0 +1,35 @@+local helpers = require('test.functional.helpers')(after_each)+local Screen = require('test.functional.ui.screen')+local clear = helpers.clear+local insert = helpers.insert+local expect = helpers.expect+local feed = helpers.feed++before_each(clear)++describe('shell filtering', function()","ok, we could rename  system_spec.lua to shell_spec and ~~maybe add a describe('shell') group~~. add the test to this group: https://github.com/neovim/neovim/blob/dd591adf8a1d145b2fdf9115509bcc80c9ee7943/test/functional/vimscript/system_spec.lua#L120 I have some local changes, so please avoid pushing to the PR.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18895,904076351,2022-06-22T17:54:41Z,runtime/lua/vim/filetype.lua,"@@ -2214,29 +2215,85 @@ local function match_pattern(name, path, tail, pat)   return matches end ---- Find the filetype for the given filename and buffer.+--- Perform filetype detection. -------@param name string File name (can be an absolute or relative path)----@param bufnr number|nil The buffer to set the filetype for. Defaults to the current buffer.+--- The filetype can be detected using one of three methods:+---  1. Using an existing buffer+---  2. Using only a file name+---  3. Using only file contents+---+--- Of these, option 1 provides the most accurate results as it uses both the+--- buffer's filename and (optionally) the buffer contents. Options 2 and 3 can be used without an+--- existing buffer, but may not always provide a match.+---+--- Each of the three options is specified using a key to the single argument to this function.+--- Example:+---+--- <pre>+---   -- Using a buffer number+---   vim.filetype.match({ buf = 42 })+---+---   -- Using a filename+---   vim.filetype.match({ filename = ""main.lua"" })+---+---   -- Using file contents+---   vim.filetype.match({ contents = ""#!/usr/bin/env bash"" })+--- </pre>+---+---@param arg table Table specifying which matching strategy to use. It is an error to provide more+---                 than one strategy. Accepted keys are:+---                   * buf (number): Buffer number to use for matching+---                   * filename (string): Filename to use for matching. Note that the file need not+---                                        actually exist in the filesystem, only the name itself is+---                                        used.+---                   * contents (string): File contents to use for matching. ---@return string|nil If a match was found, the matched filetype. ---@return function|nil A function that modifies buffer state when called (for example, to set some ---                     filetype specific buffer variables). The function accepts a buffer number as ---                     its only argument.-function M.match(name, bufnr)+function M.match(arg)   vim.validate({-    name = { name, 's' },-    bufnr = { bufnr, 'n', true },+    arg = { arg, 't' },   }) +  if not (arg.buf or arg.filename or arg.contents) then+    error('One of ""buf"", ""filename"", or ""contents"" must be given')+  end++  if (arg.buf and arg.filename) or (arg.buf and arg.contents) or (arg.filename and arg.contents) then+    error('Only one of ""buf"", ""filename"", or ""contents"" must be given')+  end+   -- When fired from the main filetypedetect autocommand the {bufnr} argument is omitted, so we use","Given the validation above, this is no longer true?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19060,904685481,2022-06-23T07:43:35Z,src/nvim/lua/converter.c,"@@ -388,12 +388,12 @@ bool nlua_pop_typval(lua_State *lstate, typval_T *ret_tv)       LuaCFunctionState *state = xmalloc(sizeof(LuaCFunctionState));       state->lua_callable.func_ref = nlua_ref_global(lstate, -1); -      char_u *name = register_cfunc(&nlua_CFunction_func_call,-                                    &nlua_CFunction_func_free,-                                    state);+      char *name = (char *)register_cfunc(&nlua_CFunction_func_call,+                                          &nlua_CFunction_func_free,+                                          state);        cur.tv->v_type = VAR_FUNC;-      cur.tv->vval.v_string = (char *)vim_strsave(name);+      cur.tv->vval.v_string = name;","I believe this duplication is necessary, otherwise the entry in the function hash table will be freed.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19059,904948945,2022-06-23T12:19:27Z,src/nvim/quickfix.c,"@@ -3319,7 +3319,6 @@ void qf_age(exarg_T *eap)   }    if (eap->addr_count != 0) {-    assert(eap->line2 <= INT_MAX);","this depends on the size of int, which is system-dependent. coverity is complaining because it builds on a system where int=4bytes.removing this assert will cause the inverse complaint on various static analyzers, e.g. PVS.the usual way to fix this is something like https://github.com/neovim/neovim/blob/05ca14a8810555495c309b8add3002773c77123d/src/nvim/charset.c#L1401",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18895,905137746,2022-06-23T15:02:13Z,runtime/lua/vim/filetype.lua,"@@ -2214,29 +2221,74 @@ local function match_pattern(name, path, tail, pat)   return matches end ---- Find the filetype for the given filename and buffer.+--- Perform filetype detection.+---+--- The filetype can be detected using one of three methods:+---  1. Using an existing buffer+---  2. Using only a file name+---  3. Using only file contents+---+--- Of these, option 1 provides the most accurate result as it uses both the buffer's filename and+--- (optionally) the buffer contents. Options 2 and 3 can be used without an existing buffer, but+--- may not always provide a match in cases where the filename (or contents) cannot unambiguously+--- determine the filetype.+---+--- Each of the three options is specified using a key to the single argument of this function.+--- Example:+---+--- <pre>+---   -- Using a buffer number+---   vim.filetype.match({ buf = 42 }) -------@param name string File name (can be an absolute or relative path)----@param bufnr number|nil The buffer to set the filetype for. Defaults to the current buffer.+---   -- Using a filename+---   vim.filetype.match({ filename = ""main.lua"" })+---+---   -- Using file contents+---   vim.filetype.match({ contents = {""#!/usr/bin/env bash""} })+--- </pre>+---+---@param arg table Table specifying which matching strategy to use. It is an error to provide more+---                 than one strategy. Accepted keys are:+---                   * buf (number): Buffer number to use for matching+---                   * filename (string): Filename to use for matching. Note that the file need not+---                                        actually exist in the filesystem, only the name itself is+---                                        used.+---                   * contents (table): An array of lines representing file contents to use for+---                                       matching. ---@return string|nil If a match was found, the matched filetype. ---@return function|nil A function that modifies buffer state when called (for example, to set some ---                     filetype specific buffer variables). The function accepts a buffer number as ---                     its only argument.-function M.match(name, bufnr)+function M.match(arg)   vim.validate({-    name = { name, 's' },-    bufnr = { bufnr, 'n', true },+    arg = { arg, 't' },   }) -  -- When fired from the main filetypedetect autocommand the {bufnr} argument is omitted, so we use-  -- the current buffer. The {bufnr} argument is provided to allow extensibility in case callers-  -- wish to perform filetype detection on buffers other than the current one.-  bufnr = bufnr or api.nvim_get_current_buf()+  if not (arg.buf or arg.filename or arg.contents) then+    error('One of ""buf"", ""filename"", or ""contents"" must be given')+  end++  if (arg.buf and arg.filename) or (arg.buf and arg.contents) or (arg.filename and arg.contents) then+    error('Only one of ""buf"", ""filename"", or ""contents"" must be given')+  end++  local bufnr = arg.buf+  local name = bufnr and api.nvim_buf_get_name(bufnr) or arg.filename+  local contents = arg.contents -  name = normalize_path(name)+  if name then+    name = normalize_path(name)+  end    local ft, on_detect +  if not (bufnr or name) then+    -- Sanity check: this should not happen+    assert(contents, 'contents should be non-nil when bufnr and filename are nil')+    -- TODO: ""scripts.lua"" content matching","But I agree that this means characterizing `scripts.lua` as ""content matching"" is slightly misleading -- it is just the last (mostly content-based) step in the matching pipeline, independently of the argument (although it can -- and should -- indeed be skipped for `filename`?)",
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19029,905984336,2022-06-24T11:44:55Z,.github/workflows/release.yml,"@@ -118,6 +118,65 @@ jobs:           path: build/release/nvim-macos.tar.gz           retention-days: 1 +  macOS-universal:+    runs-on: macos-11+    steps:+      - uses: actions/checkout@v3+        with:+          fetch-depth: 0+      - name: Install brew packages+        run: |+          brew update --quiet+          brew install automake ninja+      - if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name != 'nightly')+        run: printf 'NVIM_BUILD_TYPE=Release\n' >> $GITHUB_ENV+      - if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name == 'nightly')+        run: printf 'NVIM_BUILD_TYPE=RelWithDebInfo\n' >> $GITHUB_ENV+      - name: Provision universal `libintl`+        run: |+          bottle_tag=""arm64_big_sur""+          brew fetch --bottle-tag=""$bottle_tag"" gettext+          cd ""$(mktemp -d)""+          tar xf ""$(brew --cache)""/**/*gettext*${bottle_tag}*.tar.gz+          gettext_prefix=""$(brew --prefix gettext)""+          libintl_install_name=""$(otool -D ""${gettext_prefix}/lib/libintl.dylib"" | sed 1d)""+          libintl_basename=""$(basename ""$libintl_install_name"")""+          install_name_tool -id ""$libintl_install_name"" gettext/*/lib/""$libintl_basename""+          lipo gettext/*/lib/""$libintl_basename"" ""$libintl_install_name"" -create -output ""$libintl_basename""+          mv -f ""$libintl_basename"" ""$libintl_install_name""+          codesign --force --sign - ""$libintl_install_name""+      - name: Build release+        run: |+          export MACOSX_DEPLOYMENT_TARGET=""11""+          OSX_FLAGS=""-DCMAKE_OSX_DEPLOYMENT_TARGET=${MACOSX_DEPLOYMENT_TARGET} -DCMAKE_OSX_ARCHITECTURES=arm64\;x86_64""+          make CMAKE_BUILD_TYPE=${NVIM_BUILD_TYPE} \+               CMAKE_EXTRA_FLAGS=""-DCMAKE_INSTALL_PREFIX:PATH= $OSX_FLAGS"" \+               DEPS_CMAKE_FLAGS=""$OSX_FLAGS""+          make DESTDIR=""$GITHUB_WORKSPACE/build/release/nvim-universal"" install+      - name: Create package+        run: |+          cd ""$GITHUB_WORKSPACE/build/release""+          mkdir -p nvim-universal/libs+          libs=($(otool -L nvim-universal/bin/nvim | sed 1d | sed -E -e 's|^[[:space:]]*||' -e 's| .*||'))+          echo ""libs:""+          for lib in ""${libs[@]}""; do+            if echo ""$lib"" | grep -q -E '^(/usr/lib|/System)' 2>/dev/null; then+              echo ""  [skipped] $lib""+            else+              echo ""  $lib""+              relname=""libs/${lib##*/}""+              cp -L ""$lib"" ""nvim-universal/$relname""+              install_name_tool -change ""$lib"" ""@executable_path/../$relname"" nvim-universal/bin/nvim+            fi+          done+          codesign --force --sign - nvim-universal/bin/nvim","Nope; that's why we're using ad ad-hoc signature (`--sign -`). That said, this line goes away when I fix the build to link statically to `libintl`, but only because `clang` executes something similar to this under the hood, and we don't invalidate the ad-hoc signature from `clang` by calling `install_name_tool`.",
10165741,MDeiml,https://api.github.com/repos/neovim/neovim/pulls/17099,906062286,2022-06-24T13:25:44Z,runtime/lua/vim/treesitter/query.lua,"@@ -179,11 +179,19 @@ function M.parse_query(lang, query)   end end ---- Gets the text corresponding to a given node+--- Gets the text corresponding to a given node or a list of nodes -------@param node the node+---@param node the node or list of nodes ---@param source The buffer or string from which the node is extracted function M.get_node_text(node, source)+  -- If node is a list of nodes then return their concatenated text+  if node['start'] == nil and type(node) == 'table' then+    local text = ''+    for _, node1 in ipairs(node) do+      text = text .. M.get_node_text(node1, source)","I'm thinking of this specific use case `get_node_text(match[capture_id])`, which I saw in quite a bit of code, e.g. most of the currently implemented query predicates.If `get_node_text` were to return a list of strings, the type of that expression would change to ""list of string"". If a single string is returned, then the type of that expression stays ""string"" (even though the type of `match[capture_id]` changed).If someone needs the additional information that a list of string has, they will probably want to iterate over that list next, in which case it would be easier (and faster, as this doesn't build the extra table) to just iterate over the list of nodes and then call `get_node_text` in the loop.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19070,906135175,2022-06-24T14:44:11Z,cmake/Util.cmake,"@@ -0,0 +1,58 @@+# Defines a target that depends on ${FILES} and the files found by globbing+# when using ${GLOB_PAT} and ${GLOB_DIRS}. The target will only run if any of+# the files it depends on is changed.+#+# REQUIRED  - Abort if COMMAND doesn't exist.+# GLOB_PAT  - Glob pattern to use. Only used if ${GLOB_DIRS} is specified.+# GLOB_DIRS - The directories to recursively search for files with extension+#             ${GLOB_PAT}.+function(add_smart_target)+  cmake_parse_arguments(SMART+    ""REQUIRED""+    ""TARGET;COMMAND;GLOB_PAT""+    ""FLAGS;FILES;GLOB_DIRS""+    ${ARGN}+  )++  string(TOUPPER ${SMART_COMMAND} COMMAND_UPPER)+  set(PRG_VAR ${COMMAND_UPPER}_PRG)+  find_program(${PRG_VAR} ${SMART_COMMAND})+  set(PRG ${${PRG_VAR}})++  if(NOT PRG)+    add_custom_target(${SMART_TARGET})+    if(SMART_REQUIRED)+      add_custom_command(TARGET ${SMART_TARGET}+        COMMAND ${CMAKE_COMMAND} -E echo ""${SMART_TARGET}: ${SMART_COMMAND} not found""+        COMMAND false)+    else()+      add_custom_command(TARGET ${SMART_TARGET}+        COMMAND ${CMAKE_COMMAND} -E echo ""${SMART_TARGET} SKIP: ${SMART_COMMAND} not found"")+    endif()++    return()+  endif()++  foreach(gd ${SMART_GLOB_DIRS})+    file(GLOB_RECURSE globfiles ${PROJECT_SOURCE_DIR}/${gd}/${SMART_GLOB_PAT})+    list(APPEND SMART_FILES ${globfiles})+  endforeach()++  set(touch_dir ${TOUCHES_DIR}/${SMART_TARGET})+  file(MAKE_DIRECTORY ${touch_dir})++  foreach(f ${SMART_FILES})","I see that this is lifting the pattern already used for the old ""lintc"" target: https://github.com/neovim/neovim/blob/12c62ddea64159f812682d6cccdb3bf0ff50d035/src/nvim/CMakeLists.txt#L788-L804That's good. There might be a cmake feature that does this, but this new function looks pretty low-risk.Later we could try to convert the ""lintc"" target to use this function.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19070,906142389,2022-06-24T14:52:02Z,cmake/RunUncrustify.cmake,"@@ -1,16 +0,0 @@-# HACK: This script is invoked with ""cmake -P ���"" as a workaround to silence uncrustify.","Is this file no longer needed, because the per-file targets avoid uncrustify's noisy output (except on the first run)? That kind of thing is useful to mention in the commit message.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19070,906143503,2022-06-24T14:53:20Z,cmake/Util.cmake,"@@ -0,0 +1,58 @@+# Defines a target that depends on ${FILES} and the files found by globbing+# when using ${GLOB_PAT} and ${GLOB_DIRS}. The target will only run if any of+# the files it depends on is changed.+#+# REQUIRED  - Abort if COMMAND doesn't exist.","This function doesn't have any business doing find_foo(). Just pass a program path to it, maybe with a `fatal` flag like the old `def_cmd_target`. Also if it took a list instead of a glob (perhaps optionally?) then we could use this for ""lintc"".",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19070,906217213,2022-06-24T16:23:44Z,cmake/Util.cmake,"@@ -0,0 +1,58 @@+# Defines a target that depends on ${FILES} and the files found by globbing+# when using ${GLOB_PAT} and ${GLOB_DIRS}. The target will only run if any of+# the files it depends on is changed.+#+# REQUIRED  - Abort if COMMAND doesn't exist.",It does take a list. SMART_FILES is a list. The glob is optional.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19059,906422887,2022-06-24T21:31:50Z,src/nvim/quickfix.c,"@@ -3319,7 +3319,6 @@ void qf_age(exarg_T *eap)   }    if (eap->addr_count != 0) {-    assert(eap->line2 <= INT_MAX);","I don't think neovim will ever build on a system that is less than 32bit (but on the other hand, possibly systems where int is bigger than that). I'd rather codify that assumption than jump though a lot of artificial hoops to pretend that we can.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19079,906439228,2022-06-24T22:16:44Z,scripts/gen_vimdoc.py,"@@ -1096,15 +1096,13 @@ def main(config, args):          docs = '' -        i = 0-        for filename in CONFIG[target]['section_order']:+        for i, filename in enumerate(CONFIG[target]['section_order']):             try:                 title, helptag, section_doc = sections.pop(filename)             except KeyError:                 msg(f'warning: empty docs, skipping (target={target}): {filename}')                 msg(f'    existing docs: {sections.keys()}')                 continue-            i += 1",This `i` seems unused since https://github.com/neovim/neovim/commit/985bc6c6e055785e9cee22c1fd70127f82cdbffb,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19070,906675407,2022-06-25T12:18:50Z,cmake/Util.cmake,"@@ -0,0 +1,58 @@+# Defines a target that depends on ${FILES} and the files found by globbing+# when using ${GLOB_PAT} and ${GLOB_DIRS}. The target will only run if any of+# the files it depends on is changed.+#+# REQUIRED  - Abort if COMMAND doesn't exist.+# GLOB_PAT  - Glob pattern to use. Only used if ${GLOB_DIRS} is specified.+# GLOB_DIRS - The directories to recursively search for files with extension+#             ${GLOB_PAT}.+function(add_smart_target)","Actually this just creates a single target, and a bajillion commands, but I guess that's just a technicality.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16271,906685301,2022-06-25T13:35:44Z,src/nvim/ex_cmds.c,"@@ -1590,7 +1594,10 @@ char *make_filter_cmd(char *cmd, char *itmp, char *otmp) #if defined(UNIX)",TODO: there's a fair amount of duplicate code in these defines,x
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/16271,906694264,2022-06-25T15:12:51Z,runtime/doc/options.txt,"@@ -5292,9 +5292,9 @@ A jump table for the options with a short description can be found at |Q_op|. 	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell* 	To use PowerShell: >-		let &shell = has('win32') ? 'powershell' : 'pwsh'+		let &shell = executable('pwsh') ? 'pwsh' : 'powershell' 		let &shellcmdflag = '-NoLogo -NoProfile -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;'-		let &shellredir = '2>&1 | Out-File -Encoding UTF8 %s; exit $LastExitCode'+		let &shellredir = '-RedirectStandardOutput %s -NoNewWindow -Wait' 		let &shellpipe = '2>&1 | Out-File -Encoding UTF8 %s; exit $LastExitCode'","There are two cases:1. `Start-Process sort -RedirectStandardInput filein.txt -RedirectStandardOutput fileout.txt`: requires redirection.2. `Start-Process dir`: does not require redirectionIn the second case, if the command `dir` does not exist, that is, if the user provides a wrong command, nvim needs to write the error to a file (at least that's my understanding, from [tests like this](https://github.com/neovim/neovim/blob/b7084fef4c850d0352488b14dcff0f36a7e75e1c/test/functional/ex_cmds/make_spec.lua#L24-L31)). Now, pwsh doesn't let users direct both std in and err to the same file, that is, it doesn't let us use something like `2>&1`. If you give the same file to both `-RedirectStandardOutput` and `RedirectStandardError`, pwsh will give error. Stackoverflow suggested simply using `Out-File` to redirect everything to a file.But `Out-File` doesn't work with case 1. My understanding is that, this use case is why vim has two different options for redirection and piping. But I don't have any confirmation except that it seemed to work.",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/16271,906695286,2022-06-25T15:25:03Z,runtime/doc/options.txt,"@@ -5292,9 +5292,9 @@ A jump table for the options with a short description can be found at |Q_op|. 	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell* 	To use PowerShell: >-		let &shell = has('win32') ? 'powershell' : 'pwsh'+		let &shell = executable('pwsh') ? 'pwsh' : 'powershell' 		let &shellcmdflag = '-NoLogo -NoProfile -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;'-		let &shellredir = '2>&1 | Out-File -Encoding UTF8 %s; exit $LastExitCode'+		let &shellredir = '-RedirectStandardOutput %s -NoNewWindow -Wait'","I don't know that. But running commands with wrong arguments in cmd directly gives the following results:```cmdC:\Users\ACER> pwsh -c ""sldkfj  2>&1 | Out-File -Encoding UTF8 err.txt; exit $LastExitCode""sldkfj: The term 'sldkfj' is not recognized as a name of a cmdlet, function, script file, or executable program.Check the spelling of the name, or if a path was included, verify that the path is correct and try again.C:\Users\ACER> echo Exit Code is %errorlevel%Exit Code is 0C:\Users\ACER> pwsh -c ""sldkfj  2>&1 | Out-File -Encoding UTF8 err.txt""sldkfj: The term 'sldkfj' is not recognized as a name of a cmdlet, function, script file, or executable program.Check the spelling of the name, or if a path was included, verify that the path is correct and try again.C:\Users\ACER> echo Exit Code is %errorlevel%Exit Code is 1C:\Users\ACER> pwsh -c ""Start-Process sort -RedirectStandardInput sldkfj.txt -RedirectStandardOutput out.txt -NoNewWindow -Wait""Start-Process: This command cannot be run because either the parameter ""RedirectStandardInput 'C:\Users\ACER\sldkfj.txt'"" has a value that is not valid or cannot be used with this command. Give a valid input and Run your command again.C:\Users\ACER> echo Exit Code is %errorlevel%Exit Code is 1C:\Users\ACER> pwsh -c ""Start-Process sort -RedirectStandardInput sldkfj.txt -RedirectStandardOutput out.txt -NoNewWindow -Wait; exit $LastExitCode""Start-Process: This command cannot be run because either the parameter ""RedirectStandardInput 'C:\Users\ACER\sldkfj.txt'"" has a value that is not valid or cannot be used with this command. Give a valid input and Run your command again.C:\Users\ACER> echo Exit Code is %errorlevel%Exit Code is 0```So, `; exit $LastExitCode` spends (?) the exit code? I don't know how Nvim handles that. I'm sure you can understand whether `; exit $LastExitCode` is needed or not from the above examples.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18674,906705141,2022-06-25T17:17:07Z,.github/workflows/ci.yml,"@@ -260,6 +260,28 @@ jobs:         name: Install nvim         run: ./ci/run_tests.sh install_nvim +      - if: matrix.flavor != 'tsan' && matrix.flavor != 'functionaltest-lua' && !cancelled()+        name: Generate test-runners+        run: |+          cmake --build $GITHUB_WORKSPACE/build --target generate-test-runners+++      # macOS runners have 3 threads",Why are we fiddling with threads? What evidence is there that the test runner is CPU-bound (not IO-bound)? How much faster is the test run with parallel invocation?,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/18674,906810209,2022-06-26T12:49:25Z,.busted,"@@ -0,0 +1,37 @@+-- vim: ft=lua tw=80 sw=2 ts=2++return {+  _all = {+    helper = 'test/preload.lua',+    lpath = 'build/?.lua;runtime/lua/?.lua;./?.lua',+    output = 'test.busted.outputHandlers.nvim',+    Xhelper = { 'IS_FUNCTIONAL_TEST' },+  },+  ---+  functional = { ROOT = { 'test/functional' } },+  ----+  api = { ROOT = { 'test/functional/api' } },+  autocmd = { ROOT = { 'test/functional/autocmd' } },+  core = { ROOT = { 'test/functional/core' } },+  editor = { ROOT = { 'test/functional/editor' } },+  exCmds = { ROOT = { 'test/functional/ex_cmds' } },+  lua = { ROOT = { 'test/functional/lua' } },+  options = { ROOT = { 'test/functional/options' } },+  plugin = { ROOT = { 'test/functional/plugin' } },+  provider = { ROOT = { 'test/functional/provider' } },+  shada = { ROOT = { 'test/functional/shada' } },+  terminal = { ROOT = { 'test/functional/terminal' } },+  treesitter = { ROOT = { 'test/functional/treesitter' } },+  ui = { ROOT = { 'test/functional/ui' } },+  vimscript = { ROOT = { 'test/functional/vimscript' } },+  ---+  unit = {+    ROOT = { 'test/unit' },+    Xhelper = { 'IS_UNIT_TEST' },+  },+  ---+  benchmark = {+    ROOT = { 'test/benchmark' },+    Xhelper = { 'IS_BENCHMARK_TEST' },+  },+}","It's a bit tricky to say one or another, so I'll try to summarize a list of pros and cons### pros- debugging: since you need very few, or no arguments at all, to run tests `busted path/to/test`- ergonomics(1): no need create a [custom argparse](https://github.com//neovim/neovim/blob/b7084fef4c850d0352488b14dcff0f36a7e75e1c/cmake/RunTests.cmake#L35-L40) that determines what is safe to override (`--output`) and what isn't (`--lpath`)- ergonomics(2): no need to [expose environment variables](https://github.com//neovim/neovim/blob/b7084fef4c850d0352488b14dcff0f36a7e75e1c/cmake/RunTests.cmake#L42-L52) either instead of the aforementioned argparse### cons- it may seem that running tests directly with busted works otob, you still need to set some environment variables (this used to be a lot more involved before I've delegated a lot of these responsibilities to [`preload.lua`](https://github.com//kylo252/neovim/blob/cbdd5a9662da6c061755682e58d18416e204c946/test/preload.lua#L136-L166))- bloat(?): always a consideration when adding yet another file to the repo, although it can actually go under `./test`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19060,906816319,2022-06-26T13:33:34Z,test/functional/ex_cmds/sign_spec.lua,"@@ -1,5 +1,5 @@ local helpers = require('test.functional.helpers')(after_each)-local clear, nvim, eq = helpers.clear, helpers.nvim, helpers.eq+local clear, nvim, eq, alive = helpers.clear, helpers.nvim, helpers.eq, helpers.assert_alive","Renaming things on import, adds entropy and makes code less consistent. And in this case, it just makes the code harder to read, because it's not obvious that alive() is an assertion.```suggestionlocal clear, nvim, eq, assert_alive = helpers.clear, helpers.nvim, helpers.eq, helpers.assert_alive```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19091,906835594,2022-06-26T15:30:59Z,src/nvim/api/autocmd.c,"@@ -849,16 +844,16 @@ void nvim_exec_autocmds(Object event, Dict(exec_autocmds) *opts, Error *err)    modeline = api_object_to_bool(opts->modeline, ""modeline"", true, err); -  if (set_pattern && set_buf) {-    api_set_error(err, kErrorTypeValidation, ""must not set 'buffer' and 'pattern'"");-    goto cleanup;-  }-   bool did_aucmd = false;   FOREACH_ITEM(event_array, event_str, {     GET_ONE_EVENT(event_nr, event_str, cleanup) -    did_aucmd |= apply_autocmds_group(event_nr, pattern, NULL, true, au_group, buf, NULL, data);+    for (size_t i = 0; i < patterns.size; i++) {+      Object pat = patterns.items[i];+      char *fname = opts->buffer.type == kObjectTypeNil ? pat.data.string.data : NULL;+      did_aucmd |=+        apply_autocmds_group(event_nr, fname, NULL, true, au_group, buf, NULL, data);+    }","Could also use `FOREACH_ITEM` here.```suggestion    FOREACH_ITEM(patterns, pat, {      char *fname = opts->buffer.type == kObjectTypeNil ? pat.data.string.data : NULL;      did_aucmd |=        apply_autocmds_group(event_nr, fname, NULL, true, au_group, buf, NULL, data);    })```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19091,906836326,2022-06-26T15:36:46Z,src/nvim/api/autocmd.c,"@@ -849,16 +844,16 @@ void nvim_exec_autocmds(Object event, Dict(exec_autocmds) *opts, Error *err)    modeline = api_object_to_bool(opts->modeline, ""modeline"", true, err); -  if (set_pattern && set_buf) {-    api_set_error(err, kErrorTypeValidation, ""must not set 'buffer' and 'pattern'"");-    goto cleanup;-  }-   bool did_aucmd = false;   FOREACH_ITEM(event_array, event_str, {     GET_ONE_EVENT(event_nr, event_str, cleanup) -    did_aucmd |= apply_autocmds_group(event_nr, pattern, NULL, true, au_group, buf, NULL, data);+    for (size_t i = 0; i < patterns.size; i++) {+      Object pat = patterns.items[i];+      char *fname = opts->buffer.type == kObjectTypeNil ? pat.data.string.data : NULL;+      did_aucmd |=+        apply_autocmds_group(event_nr, fname, NULL, true, au_group, buf, NULL, data);+    }",Good idea; will also backport that pattern to `nvim_create_autocommands` (where I stole this from).There's quite a bit of refactoring opportunities on this table for people so inclined ;),
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/19104,906842184,2022-06-26T16:24:07Z,runtime/doc/options.txt,"@@ -3799,9 +3799,9 @@ A jump table for the options with a short description can be found at |Q_op|. <							*lcs-leadmultispace* 	  leadmultispace:c... 			Like multispace value, but only for leading whitespace-			Overrides |lcs-lead| for leading multiple spaces.-			`:set listchars=leadmultispace:---+` shows ten consecutive-			leading spaces as:+			overrides |lcs-lead| for leading multiple spaces.","I think what is actually needed is a  `.` at the end of the first line, like:```vimhelp			Like multispace value, but only for leading			whitespace. Overrides |lcs-lead| for leading multiple			spaces. `:set listchars=leadmultispace:---+` shows ten			consecutive leading spaces as:```Though it does cause a bit of wrapping.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,907121673,2022-06-27T08:35:03Z,runtime/lua/vim/filetype.lua,"@@ -1170,57 +1170,57 @@ local extension = {   -- Ignored extensions   bak = function(path, bufnr)     local root = vim.fn.fnamemodify(path, ':r')-    return M.match(root, bufnr)+    return M.match({ filename = root })","> This seems fine. contents still feels like the odd duck to me. Not sure how to better unify that part yet.I think it would make sense to allow the combination `filename` and `contents` for, e.g., treesitter injections or file previewing. But that requires a bigger refactor (passing `contents` down the chain and abstracting  the `getlines` function), which is outside the scope of this PR (and not required for `filetype.vim` parity, which is the first goal here).",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19043,907203688,2022-06-27T09:56:58Z,src/nvim/CMakeLists.txt,"@@ -97,10 +97,10 @@ file(MAKE_DIRECTORY ${GENERATED_INCLUDES_DIR}) file(MAKE_DIRECTORY ${LINT_SUPPRESSES_ROOT}) file(MAKE_DIRECTORY ${LINT_SUPPRESSES_ROOT}/src) -file(GLOB NVIM_SOURCES *.c)-file(GLOB NVIM_HEADERS *.h)-file(GLOB EXTERNAL_SOURCES ../xdiff/*.c ../mpack/*.c ../cjson/*.c)-file(GLOB EXTERNAL_HEADERS ../xdiff/*.h ../mpack/*.h ../cjson/*.h)+glob_wrapper(NVIM_SOURCES *.c)+glob_wrapper(NVIM_HEADERS *.h)",That and because not all `*.c` files should be in `NVIM_SOURCES` and not all `*.h` files should be in `NVIM_HEADERS`. You'd need to exclude files afterwards so feels like complexity-wise is same.,
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19139,908771485,2022-06-28T17:37:35Z,cmake/FindLibIntl.cmake,"@@ -41,6 +41,16 @@ endif() if (MSVC)   list(APPEND CMAKE_REQUIRED_LIBRARIES ${ICONV_LIBRARY}) endif()++# On macOS, if libintl is a static library then we also need+# to link libiconv and CoreFoundation.+get_filename_component(LibIntl_EXT ""${LibIntl_LIBRARY}"" LAST_EXT)+if (APPLE AND (LibIntl_EXT STREQUAL "".a""))","There really ought to be a better way to check if a library is static, but I'm too tired of CMake to work it out.",
41961280,L3MON4D3,https://api.github.com/repos/neovim/neovim/pulls/18998,909282488,2022-06-29T07:20:17Z,runtime/lua/vim/lsp/_snippet.lua,"@@ -156,10 +156,10 @@ P.seq = function(...)   return function(input, pos)     local values = {}     local new_pos = pos-    for _, parser in ipairs(parsers) do+    for i, parser in ipairs(parsers) do       local result = parser(input, new_pos)       if result.parsed then-        table.insert(values, result.value)+        values[i] = result.value","Previously empty `opt` were just omitted in `seq` (`nil` as last item in list is ignored), now they're `nil`.I don't _think_ this breaks anything, wanted to highlight it nonetheless since I'm not 100% certain.Do you think this could cause any issues @hrsh7th?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19134,909348405,2022-06-29T08:28:55Z,src/nvim/fileio.c,"@@ -1172,28 +1173,20 @@ int readfile(char *fname, char *sfname, linenr_T from, linenr_T lines_to_skip,  #ifdef HAVE_ICONV       if (iconv_fd != (iconv_t)-1) {-        /*-         * Attempt conversion of the read bytes to 'encoding' using-         * iconv().-         */-        const char *fromp;-        char *top;-        size_t from_size;-        size_t to_size;--        fromp = ptr;-        from_size = size;+        // Attempt conversion of the read bytes to 'encoding' using iconv().+        const char *fromp = ptr;+        long from_size = size;",why change to `long` here? (grug rule: `long` type bad!) . Better to keep as `size_t` and add cast or change whatever else also away from `long`.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19137,909391572,2022-06-29T09:11:07Z,src/nvim/mbyte.c,"@@ -1859,7 +1859,7 @@ int mb_tail_off(const char_u *base, const char_u *p)     }   } -  if (utf8len_tab[p[-j]] != i + j + 1) {+  if (utf8len_tab[(uint8_t)p[-j]] != i + j + 1) {",are the usages of `p[...]` above also safe? we could follow the `p_in` pattern to not need to worry.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/18710,909943680,2022-06-29T14:53:41Z,runtime/lua/vim/filetype.lua,"@@ -2297,7 +2603,13 @@ function M.match(arg)   if contents then     -- Sanity check: this should not happen     assert(not bufnr, '""buf"" and ""contents"" are mutually exclusive')-    -- TODO: ""scripts.lua"" content matching+    -- If name is nil, catch any errors from the contents filetype detection function.+    -- If the function tries to use the filename that is nil then it will fail,+    -- but this enables checks which do not need a filename to still work.+    ft = pcall(match_contents, contents, name)+    if ft then+      return ft+    end","On further consideration (and some poking from @clason) this block should be moved to the end of `match()` and should not require that `bufnr` is nil. Basically, even when given a valid `bufnr`, if `match()` fails to find a filetype using the ""standard"" methods (filename, pattern, extension), it should then fall back to doing full content-based detection.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,909961073,2022-06-29T14:56:08Z,runtime/lua/vim/filetype.lua,"@@ -2297,7 +2603,13 @@ function M.match(arg)   if contents then     -- Sanity check: this should not happen     assert(not bufnr, '""buf"" and ""contents"" are mutually exclusive')-    -- TODO: ""scripts.lua"" content matching+    -- If name is nil, catch any errors from the contents filetype detection function.+    -- If the function tries to use the filename that is nil then it will fail,+    -- but this enables checks which do not need a filename to still work.+    ft = pcall(match_contents, contents, name)+    if ft then+      return ft+    end",and (sorry ���� ) then the `match_from` functions and patterns can be moved (back...) to `detect.lua`?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18772,910439010,2022-06-29T21:46:39Z,runtime/lua/vim/lsp/snippet.lua,"@@ -0,0 +1,7 @@+local parser = require('vim.lsp.snippet.parser')+local ast = require('vim.lsp.snippet.ast')++return {+  parser = parser,","No need for this. Just put the parse() function directly in this snippet.lua module. The module tree should not have so much depth unless it is truly needed.It does look like `snippet/ast.lua` module is justified, because its functions operate on a shared datatype.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19111,910447028,2022-06-29T22:00:59Z,test/functional/vimscript/executable_spec.lua,"@@ -17,6 +17,21 @@ describe('executable()', function()     eq(1, call('executable', 'false'))   end) +  if iswin() then+    it('exepath respects shellslash', function()+      command('let $PATH = fnamemodify(""./test/functional/fixtures/bin"", "":p"")')+      eq('test\\functional\\fixtures\\bin\\null.CMD', call('fnamemodify', call('exepath', 'null'), ':.'))+      command('set ssl')+      eq('test/functional/fixtures/bin/null.CMD', call('fnamemodify', call('exepath', 'null'), ':.'))+    end)++    it('stdpath respects shellslash', function()+      eq('build\\Xtest_xdg\\share\\nvim-data', call('fnamemodify', call('stdpath', 'data'), ':.'))","can avoid escaping with `[[ ]]````suggestion      eq([[build\Xtest_xdg\share\nvim-data]], call('fnamemodify', call('stdpath', 'data'), ':.'))```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19082,910979608,2022-06-30T12:41:52Z,src/nvim/msgpack_rpc/channel.c,"@@ -521,8 +521,19 @@ void rpc_close(Channel *channel)   } } +static void exit_delay_cb(uv_timer_t *handle)+{+  uv_timer_stop(&main_loop.exit_delay_timer);+  multiqueue_put(main_loop.fast_events, exit_event, 0);+}+ static void exit_event(void **argv) {+  if (exit_need_delay) {","There is already `process_is_tearing_down`. But it's not global, and semantics are different...Wonder if we can avoid a new global `exit_need_delay`. I noticed that, although `os_exit` calls `event_teardown`,   `process_teardown` is already waiting for events to drain: https://github.com/neovim/neovim/blob/f50135a32e11c535e1dc3a8e9460c5b4e640ee86/src/nvim/event/process.c#L141-L142Could we do a similar check here? Something like this?```if (!process_is_tearing_down || (kl_empty(main_loop.children) && multiqueue_empty(main_loop.events))) {  uv_timer_start(&main_loop.exit_delay_timer, exit_delay_cb, 0, 0);  return;}",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18710,910984637,2022-06-30T12:47:10Z,runtime/lua/vim/filetype.lua,"@@ -2297,7 +2603,13 @@ function M.match(arg)   if contents then     -- Sanity check: this should not happen     assert(not bufnr, '""buf"" and ""contents"" are mutually exclusive')-    -- TODO: ""scripts.lua"" content matching+    -- If name is nil, catch any errors from the contents filetype detection function.+    -- If the function tries to use the filename that is nil then it will fail,+    -- but this enables checks which do not need a filename to still work.+    ft = pcall(match_contents, contents, name)+    if ft then+      return ft+    end","> and (sorry sob ) then the `match_from` functions and patterns can be moved (back...) to `detect.lua`?Does that include all patterns (`patterns_no_hashbang` and `patterns_hashbang`) or only the more complex checks that use a function? After all, the extension and filename patterns are in `filetype.lua` also. ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,911038060,2022-06-30T13:37:40Z,runtime/lua/vim/filetype.lua,"@@ -2297,7 +2603,13 @@ function M.match(arg)   if contents then     -- Sanity check: this should not happen     assert(not bufnr, '""buf"" and ""contents"" are mutually exclusive')-    -- TODO: ""scripts.lua"" content matching+    -- If name is nil, catch any errors from the contents filetype detection function.+    -- If the function tries to use the filename that is nil then it will fail,+    -- but this enables checks which do not need a filename to still work.+    ft = pcall(match_contents, contents, name)+    if ft then+      return ft+    end","I'd say the patterns as well (which are _content_ patterns as opposed to _filename_  patterns) -- the goal is ""locality"": keeping related things close together, so if the patterns are only used by a function in `detect.lua`, they should be in `detect.lua`?Does that make sense?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19175,911464105,2022-06-30T21:38:43Z,src/nvim/globals.h,"@@ -725,7 +725,7 @@ EXTERN bool need_highlight_changed INIT(= true); EXTERN FILE *scriptout INIT(= NULL);  ///< Stream to write script to.  // volatile because it is used in a signal handler.-EXTERN volatile int got_int INIT(= false);  // set to true when interrupt+EXTERN volatile bool got_int INIT(= false); // set to true when interrupt                                             // signal occurred",I guess this `volatile` is also no longer needed as Nvim just terminates on SIGINT.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19185,911882480,2022-07-01T11:34:20Z,src/nvim/ops.c,"@@ -687,7 +687,8 @@ void op_reindent(oparg_T *oap, Indenter how)     redraw_curbuf_later(INVERTED);   } -  if (oap->line_count > p_report) {+  // TODO(Shougo): Use ext_messages instead+  if (oap->line_count > p_report && ui_has_messages()) {     i = oap->line_count - (i + 1);     smsg(NGETTEXT(""%"" PRId64 "" line indented "",                   ""%"" PRId64 "" lines indented "", i),","Display of most messages, especially messages that go through `smsg()` (and similar message functions), should be decided in messages.c, not at every call site.Here for example, there is already `p_report` (which might also be changed by 'shortmess', idk). If users don't want that message they set the 'report' or 'shortmess' option. `cmdheight=0` should just show the message without hit-enter. And the hit-enter should be avoided in messages.c, `wait_return`, or whatever central place decides whether hit-enter is done._Edit: ignore this idea for now. I'm playing around with it and see that it's probably a separate topic. We probably need to introduce a new 'shortmess' option where ""hit enter"" becomes ""hit any key""._",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19189,911932869,2022-07-01T12:48:48Z,test/CMakeLists.txt,"@@ -0,0 +1,62 @@+add_subdirectory(includes)+add_subdirectory(functional/fixtures)+# TODO:+# - specify *all* the luarocks requirements for tests (what about ffi?)+# - use impatient to make up for the (sizeable) overhead when running each test independently",Is it required to run each test independently or can we turn that off?,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19189,911945165,2022-07-01T13:05:13Z,test/CMakeLists.txt,"@@ -0,0 +1,62 @@+add_subdirectory(includes)+add_subdirectory(functional/fixtures)+# TODO:+# - specify *all* the luarocks requirements for tests (what about ffi?)+# - use impatient to make up for the (sizeable) overhead when running each test independently","any and all of the tests provided here are opt-in, I'm considering having different tests presets and configurations, where certain tests will only be enabled in a CI environment, or the other way around.with regards to independent uncrustify tests, isn't it better to have separate output for each file? it's also a very easy choice for multi-threading, here are my test results for comparison<table><tr>	<td>cmd	<td>Total Test time (real)<tr>	<td>ctest --test-dir build -R uncrustify-lint-all --verbose	<td>34.49 sec<tr>	<td>ctest --test-dir build -L lint -j16 --verbose	<td>3.94 sec</table>oh and this means that a git-hook can call the tests per file without having to figure out what flags to pass or not pass to `uncrustify`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19189,912078123,2022-07-01T15:53:24Z,test/CMakeLists.txt,"@@ -0,0 +1,62 @@+add_subdirectory(includes)+add_subdirectory(functional/fixtures)+# TODO:+# - specify *all* the luarocks requirements for tests (what about ffi?)+# - use impatient to make up for the (sizeable) overhead when running each test independently++#################################+########## test specs ###########+#################################++set(ENV{LC_ALL} ""en_US.UTF-8"")++if(POLICY CMP0012)+  # Handle CI=true, without dev warnings.+  cmake_policy(SET CMP0012 NEW)+endif()++set(NVIM_PRG $<TARGET_FILE:nvim>)++set(test_env)+list(+  APPEND test_env+  ""LC_ALL=en_US.UTF-8""+  ""NVIM_PRG=${NVIM_PRG}""+  ""NEOVIM_BUILD_DIR=${PROJECT_BINARY_DIR}""+  ""NEOVIM_SOURCE_DIR=${PROJECT_SOURCE_DIR}""+  ""VIMRUNTIME=${PROJECT_SOURCE_DIR}/runtime""+  ""LOG_DIR=${PROJECT_BINARY_DIR}/log""+  ""TEST_SKIP_FRAGILE=ON""+  ""SYSTEM_NAME=${CMAKE_HOST_SYSTEM_NAME}""+)++add_test(+  NAME commit-lint+  COMMAND ${NVIM_PRG} --headless --clean -es -c [==[lua require('scripts.lintcommit').main({trace=false})]==]+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++get_target_property(LINT_SOURCES nvim_sources INTERFACE_SOURCES)+get_target_property(LINT_HEADERS nvim_headers INTERFACE_SOURCES)++list(APPEND LINT_TARGETS ${LINT_SOURCES} ${LINT_HEADERS})++add_test(+  NAME uncrustify-lint-all","follow the naming conventions of the existing lint targets, in particular ""lint"" should be the prefix",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19189,912079038,2022-07-01T15:54:48Z,test/CMakeLists.txt,"@@ -0,0 +1,62 @@+add_subdirectory(includes)+add_subdirectory(functional/fixtures)+# TODO:+# - specify *all* the luarocks requirements for tests (what about ffi?)+# - use impatient to make up for the (sizeable) overhead when running each test independently++#################################+########## test specs ###########+#################################++set(ENV{LC_ALL} ""en_US.UTF-8"")++if(POLICY CMP0012)+  # Handle CI=true, without dev warnings.+  cmake_policy(SET CMP0012 NEW)+endif()++set(NVIM_PRG $<TARGET_FILE:nvim>)++set(test_env)+list(+  APPEND test_env+  ""LC_ALL=en_US.UTF-8""+  ""NVIM_PRG=${NVIM_PRG}""+  ""NEOVIM_BUILD_DIR=${PROJECT_BINARY_DIR}""+  ""NEOVIM_SOURCE_DIR=${PROJECT_SOURCE_DIR}""","where is this used?follow conventions in the codebase. ""nvim"" is the name used in most technical contexts , not ""neovim""```suggestion  ""NVIM_SOURCE_DIR=${PROJECT_SOURCE_DIR}""```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,912124624,2022-07-01T17:08:27Z,runtime/lua/vim/filetype/detect.lua,"@@ -572,10 +642,15 @@ function M.m(bufnr)   end end -function M.m4(path)-  path = path:lower()-  if not path:find('html%.m4$') and not path:find('fvwm2rc') then-    return 'm4'+local function m4(contents)+  for _, line in ipairs(contents) do+    if matchregex(line, '^\\%s*dnl\\>') then","```suggestion    if matchregex(line, [[^\s*dnl\>]]) then```(not a Lua pattern ;))Should fix the ASAN failure (that was a memory leak for the error, which for some reason doesn't show up in the tests).If you haven't already otherwise, maybe it would make sense to use `[[...]]` strings for Vim regexes consistently to avoid the danger of wrong escaping (and simplify copy&pasting)?",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19189,912342992,2022-07-02T09:27:20Z,src/nvim/CMakeLists.txt,"@@ -130,6 +130,12 @@ glob_wrapper(UNIT_TEST_FIXTURES ${PROJECT_SOURCE_DIR}/test/unit/fixtures/*.c) list(SORT NVIM_SOURCES) list(SORT NVIM_HEADERS) +add_library(nvim_sources INTERFACE)+target_sources(nvim_sources INTERFACE ${NVIM_SOURCES})++add_library(nvim_headers INTERFACE ${NVIM_HEADERS})+target_sources(nvim_headers INTERFACE ${NVIM_HEADERS})","This is done immediately after these collections are created. This list is currently only used in `src/nvim/CMakeLists.txt` and its _child_ directory `src/nvim/po/CMakeLists.txt`, so unless I missed something, this is the first time that this was needed.That said, we can use this same ""modern"" pattern to replace this and other similar usages of directory-based properties with target-based oneshttps://github.com/neovim/neovim/blob/3b23f561aef87687495ca683f12943d0cd8eff15/CMakeLists.txt#L666",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19180,912354711,2022-07-02T11:49:04Z,src/nvim/tui/input.c,"@@ -206,19 +271,46 @@ static void tinput_enqueue(TermInput *input, char *buf, size_t size)   rbuffer_write(input->key_buffer, buf, size); } +static void handle_kitty_key_protocol(TermInput *input, TermKeyKey *key)+{+  const char *name = map_get(KittyKey, cstr_t)(&kitty_key_map, (KittyKey)key->code.codepoint);+  if (name) {+    char buf[64];+    size_t len = 0;+    buf[len++] = '<';+    if (key->modifiers & TERMKEY_KEYMOD_SHIFT) {+      len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""S-"");+    }+    if (key->modifiers & TERMKEY_KEYMOD_ALT) {+      len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""A-"");+    }+    if (key->modifiers & TERMKEY_KEYMOD_CTRL) {+      len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""C-"");+    }+    len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""%s>"", name);+    tinput_enqueue(input, buf, len);+  }+}+ static void forward_simple_utf8(TermInput *input, TermKeyKey *key) {   size_t len = 0;   char buf[64];   char *ptr = key->utf8; -  while (*ptr) {-    if (*ptr == '<') {-      len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""<lt>"");-    } else {-      buf[len++] = *ptr;+  if (key->code.codepoint >= 0xE000 && key->code.codepoint <= 0xF8FF+      && map_has(KittyKey, cstr_t)(&kitty_key_map, (KittyKey)key->code.codepoint)) {+    handle_kitty_key_protocol(input, key);","So this works implicitly/automatically based on the codepoint? Neither users nor Nvim need to set a terminal option? Would this be potentially usable by any terminal emulator that allows configuring arbitrary ""keychord => sequence"" mappings?Do we need a doc near `:help tui-input`, similar to `:help tui-csiu` ?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19203,912364266,2022-07-02T13:41:24Z,src/nvim/api/command.c,"@@ -598,6 +600,7 @@ String nvim_cmd(uint64_t channel_id, Dict(cmd) *cmd, Dict(cmd_opts) *opts, Error      OBJ_TO_CMOD_FLAG(CMOD_SILENT, mods.silent, false, ""'mods.silent'"");     OBJ_TO_CMOD_FLAG(CMOD_ERRSILENT, mods.emsg_silent, false, ""'mods.emsg_silent'"");+    OBJ_TO_CMOD_FLAG(CMOD_UNSILENT, mods.silent, false, ""'mods.unsilent'"");","`CMOD_UNSILENT` overrides `CMOD_SILENT`, and there is actually a usecase for using both `:silent!` and `:unsilent`: <https://github.com/Shougo/neobundle.vim/blob/1306c131ff0a6cc094b7ff0727350e442b5427f1/autoload/neobundle/config.vim#L665>`:silent!` suppresses error messages, while `:unsilent` enables normal messages. And `:silent!` sets both `CMOD_ERRILENT` and `CMOD_SILENT`, so if a dictionary passed to `nvim_cmd` comes from `nvim_parse_cmd` or Lua user command it may have `emsg_silent`, `silent` and `unsilent` all set to `true`.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/19082,912373976,2022-07-02T15:33:46Z,src/nvim/msgpack_rpc/channel.c,"@@ -521,8 +521,19 @@ void rpc_close(Channel *channel)   } } +static void exit_delay_cb(uv_timer_t *handle)+{+  uv_timer_stop(&main_loop.exit_delay_timer);+  multiqueue_put(main_loop.fast_events, exit_event, 0);+}+ static void exit_event(void **argv) {+  if (exit_need_delay) {+    uv_timer_start(&main_loop.exit_delay_timer, exit_delay_cb, 0, 0);","`multiqueue_push()`, `multiqueue_process_events()` and `multiqueue_remove()` are implemented as follows:https://github.com/neovim/neovim/blob/ed429c00d76414d07d7c7129f65ddf9be68e24f4/src/nvim/event/multiqueue.c#L235https://github.com/neovim/neovim/blob/ed429c00d76414d07d7c7129f65ddf9be68e24f4/src/nvim/event/multiqueue.c#L150-L151https://github.com/neovim/neovim/blob/ed429c00d76414d07d7c7129f65ddf9be68e24f4/src/nvim/event/multiqueue.c#L219Therefore, the easiest way to queue a delayed event without causing an infinite loop in the queue currently being processed is to use a timer. Of course, you could safely do that by using `QUEUE_INSERT_HEAD` and `QUEUE_FOREACH`, but since that process is currently only needed for this PR, I don't think the cost of implementing it is worth it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19210,912378248,2022-07-02T16:23:07Z,src/nvim/os/signal.c,"@@ -165,8 +165,6 @@ static char *signal_name(int signum) // This function handles deadly signals. // It tries to preserve any swap files and exit properly. // (partly from Elvis).-// NOTE: Avoid unsafe functions, such as allocating memory, they can result in-// a deadlock. static void deadly_signal(int signum)","Let's add a comment here:```suggestion// NOTE: this is scheduled on the event loop, _not_ called directly from a signal handler.static void deadly_signal(int signum)```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19210,912382385,2022-07-02T17:12:19Z,src/nvim/globals.h,"@@ -503,8 +503,8 @@ EXTERN int stdout_isatty INIT(= true); EXTERN int stdin_fd INIT(= -1);  // true when doing full-screen output, otherwise only writing some messages.-// volatile because it is used in a signal handler.-EXTERN volatile int full_screen INIT(= false);+// no need volatile because callback not called directly from a signal handlers.+EXTERN int full_screen INIT(= false);",can skip the comment here. `deadly_signal` is the most important one because that's where contributors might wonder why we have non-trivial code in a signal handler.```suggestionEXTERN int full_screen INIT(= false);```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,912399690,2022-07-02T20:53:51Z,runtime/lua/vim/filetype/detect.lua,"@@ -1204,4 +1286,269 @@ end -- luacheck: pop -- luacheck: pop +local patterns_hashbang = {+  ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+  ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+  ['^expect\\>'] = { 'expect', { vim_regex = true } },+  ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+  ['make\\>'] = { 'make', { vim_regex = true } },+  ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+  lua = 'lua',+  perl = 'lua',+  php = 'php',+  python = 'python',+  ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+  raku = 'raku',+  ruby = 'ruby',+  ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+  ['rhino\\>'] = { 'javascript', { vim_regex = true } },+  -- BC calculator+  ['^bc\\>'] = { 'bc', { vim_regex = true } },+  ['sed\\>'] = { 'sed', { vim_regex = true } },+  ocaml = 'ocaml',+  -- Awk scripts; also finds ""gawk""+  ['awk\\>'] = { 'awk', { vim_regex = true } },+  wml = 'wml',+  scheme = 'scheme',+  cfengine = 'cfengine',+  escript = 'erlang',+  haskell = 'haskell',+  clojure = 'clojure',+  ['scala\\>'] = { 'scala', { vim_regex = true } },+  -- Free Pascal+  ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+  ['fennel\\>'] = { 'fennel', { vim_regex = true } },+  -- MikroTik RouterOS script+  ['rsc\\>'] = { 'routeros', { vim_regex = true } },+  ['fish\\>'] = { 'fish', { vim_regex = true } },+  ['gforth\\>'] = { 'forth', { vim_regex = true } },+  ['icon\\>'] = { 'icon', { vim_regex = true } },+}++---@private+-- File starts with ""#!"".+local function match_from_hashbang(contents, path)+  local first_line = contents[1]+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if M.matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)+      :gsub('%-%-ignore%-environment', '', 1)+      :gsub('%-%-split%-string', '', 1)+    first_line = vim.fn.substitute(first_line, [[\<env\s\+]], '', '')+  end++  -- Get the program name.+  -- Only accept spaces in PC style paths: ""#!c:/program files/perl [args]"".+  -- If the word env is used, use the first word after the space:+  -- ""#!/usr/bin/env perl [path/args]""+  -- If there is no path use the first word: ""#!perl [path/args]"".+  -- Otherwise get the last word after a slash: ""#!/usr/bin/perl [path/args]"".+  local name+  if first_line:find('^#!%s*%a:[/\\]') then+    name = vim.fn.substitute(first_line, [[^#!.*[/\\]\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!.*\<env\>]]) then+    name = vim.fn.substitute(first_line, [[^#!.*\<env\>\s\+\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!\s*[^/\\ ]*\>\([^/\\]\|$\)]]) then+    name = vim.fn.substitute(first_line, [[^#!\s*\([^/\\ ]*\>\).*]], '\\1', '')+  else+    name = vim.fn.substitute(first_line, [[^#!\s*\S*[/\\]\(\i\+\).*]], '\\1', '')+  end++  -- tcl scripts may have #!/bin/sh in the first line and ""exec wish"" in the+  -- third line. Suggested by Steven Atkinson.+  if contents[3] and contents[3]:find('^exec wish') then+    name = 'wish'+  end++  if matchregex(name, [[^\(bash\d*\|\|ksh\d*\|sh\)\>]]) then+    -- Bourne-like shell scripts: bash bash2 ksh ksh93 sh+    return require('vim.filetype.detect').sh(path, contents, first_line)+  elseif matchregex(name, [[^csh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, vim.g.filetype_csh or 'csh')+  elseif matchregex(name, [[^tcsh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, 'tcsh')+  end++  for k, v in pairs(patterns_hashbang) do+    local ft = type(v) == 'table' and v[1] or v+    local opts = type(v) == 'table' and v[2] or {}+    if opts.vim_regex and matchregex(name, k) or name:find(k) then+      return ft+    end+  end+end++local patterns_text = {+  ['^#compdef\\>'] = { 'zsh', { vim_regex = true } },+  ['^#autoload\\>'] = { 'zsh', { vim_regex = true } },+  -- ELM Mail files+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 19%d%d$'] = 'mail',+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 20%d%d$'] = 'mail',+  ['^From %- .* 19%d%d$'] = 'mail',+  ['^From %- .* 20%d%d$'] = 'mail',+  -- Mason+  ['^<[%%&].*>'] = 'mason',+  -- Vim scripts (must have '"" vim' as the first line to trigger this)+  ['^"" *[vV]im$['] = 'vim',+  -- libcxx and libstdc++ standard library headers like [""iostream[""] do not have+  -- an extension, recognize the Emacs file mode.+  ['%-%*%-.*[cC]%+%+.*%-%*%-'] = 'cpp',+  ['^\\*\\* LambdaMOO Database, Format Version \\%([1-3]\\>\\)\\@!\\d\\+ \\*\\*$'] = {+    'moo',+    { vim_regex = true },+  },+  -- Diff file:+  -- - ""diff"" in first line (context diff)+  -- - ""Only in "" in first line+  -- - ""--- "" in first line and ""+++ "" in second line (unified diff).+  -- - ""*** "" in first line and ""--- "" in second line (context diff).+  -- - ""# It was generated by makepatch "" in the second line (makepatch diff).+  -- - ""Index: <filename>"" in the first line (CVS file)+  -- - ""=== "", line of ""="", ""---"", ""+++ "" (SVK diff)+  -- - ""=== "", ""--- "", ""+++ "" (bzr diff, common case)+  -- - ""=== (removed|added|renamed|modified)"" (bzr diff, alternative)+  -- - ""# HG changeset patch"" in first line (Mercurial export format)+  ['^\\(diff\\>\\|Only in \\|\\d\\+\\(,\\d\\+\\)\\=[cda]\\d\\+\\>\\|# It was generated by makepatch \\|Index:\\s\\+\\f\\+\\r\\=$\\|===== \\f\\+ \\d\\+\\.\\d\\+ vs edited\\|==== //\\f\\+#\\d\\+\\|# HG changeset patch\\)'] = {+    'diff',+    { vim_regex = true },+  },+  function(contents)+    return diff(contents)+  end,+  -- PostScript Files (must have %!PS as the first line, like a2ps output)+  ['^%%![ \t]*PS'] = 'postscr',+  function(contents)+    return m4(contents)+  end,+  -- SiCAD scripts (must have procn or procd as the first line to trigger this)+  ['^ *proc[nd] *$'] = { 'sicad', { ignore_case = true } },+  ['^%*%*%*%*  Purify'] = 'purifylog',+  -- XML+  ['<%?%s*xml.*%?>'] = 'xml',+  -- XHTML (e.g.: PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"")+  ['\\<DTD\\s\\+XHTML\\s'] = 'xhtml',+  -- HTML (e.g.: <!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"")+  -- Avoid ""doctype html"", used by slim.+  ['\\c<!DOCTYPE\\s\\+html\\>'] = { 'html', { vim_regex = true } },+  -- PDF+  ['^%%PDF%-'] = 'pdf',+  -- XXD output+  ['^%x%x%x%x%x%x%x: %x%x ?%x%x ?%x%x ?%x%x '] = 'xxd',+  -- RCS/CVS log output+  ['^RCS file:'] = { 'rcslog', { start_lnum = 1, end_lnum = 2 } },+  -- CVS commit+  ['^CVS:'] = { 'cvs', { start_lnum = 2 } },+  ['^CVS: '] = { 'cvs', { start_lnum = -1 } },+  -- Prescribe+  ['^!R!'] = 'prescribe',+  -- Send-pr+  ['^SEND%-PR:'] = 'sendpr',+  -- SNNS files+  ['^SNNS network definition file'] = 'snnsnet',+  ['^SNNS pattern definition file'] = 'snnspat',+  ['^SNNS result file'] = 'snnsres',+  ['&%%.-[Vv]irata'] = { 'virata', { start_lnum = 1, end_lnum = 5 } },+  ['[0-9:.]* *execve%('] = 'strace',+  ['^__libc_start_main'] = 'strace',+  -- VSE JCL+  ['^\\* $$ JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  ['^// *JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  -- TAK and SINDA+  ['K & K  Associates'] = { 'takout', { start_lnum = 4 } },+  ['TAK 2000'] = { 'takout', { start_lnum = 2 } },+  ['S Y S T E M S   I M P R O V E D '] = { 'syndaout', { start_lnum = 3 } },+  ['Run Date: '] = { 'takcmp', { start_lnum = 6 } },+  ['Node    File  1'] = { 'sindacmp', { start_lnum = 9 } },+  function(contents)+    require('vim.filetype.detect').dns_zone(contents)+  end,+  -- Valgrind+  ['^==%d+== valgrind'] = 'valgrind',+  ['^==%d+== Using valgrind'] = { 'valgrind', { start_lnum = 3 } },+  -- Go docs+  ['PACKAGE DOCUMENTATION$'] = 'godoc',+  -- Renderman Interface Bytestream+  ['^##RenderMan'] = 'rib',+  -- Scheme scripts+  ['exec%s%+%S*scheme'] = { 'scheme', { start_lnum = 1, end_lnum = 2 } },+  -- Git output+  ['^\\(commit\\|tree\\|object\\) \\x\\{40,\\}\\>\\|^tag \\S\\+$'] = { 'git', { vim_regex = true } },+  function(lines)+    -- Gprof (gnu profiler)+    if lines[1] == 'Flat profile:' and lines[2] == '' and lines[3]:find('^Each sample counts as .* seconds%.$') then+      return 'gprof'+    end+  end,+  -- Erlang terms+  -- (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)+  ['%-%*%-.*erlang.*%-%*%-'] = { 'erlang', { ignore_case = true } },+  -- YAML+  ['^&YAML'] = 'yaml',+  -- MikroTik RouterOS script+  ['^#.*by RouterOS'] = 'routeros',+  -- Sed scripts+  -- #ncomment is allowed but most likely a false positive so require a space before any trailing comment text+  ['^#n%s'] = 'sed',+  ['^#n$'] = 'sed',+}++---@private+-- File does not start with ""#!"".+local function match_from_text(contents, path)+  if contents[1]:find('^:$') then+    -- Bourne-like shell scripts: sh ksh bash bash2+    return M.sh(path, contents)+  elseif matchregex('\n' .. table.concat(contents, '\n'), [[\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>]]) then+    -- Z shell scripts+    return 'zsh'+  end++  for k, v in pairs(patterns_text) do+    if type(v) == 'string' then+      -- Check the first line only+      if contents[1]:find(k) then+        return v+      end+    elseif type(v) == 'function' then+      -- If filetype detection fails, continue with the next pattern+      local ok, ft = pcall(v, contents)+      if ok and ft then+        return ft+      end+    else+      local opts = type(v) == 'table' and v[2] or {}+      if opts.start_lnum then+        assert(not opts.ignore_case, 'ignore_case=true is ignored when start_lnum is also present, needs refactor')+        for i = opts.start_lnum, opts.end_lnum do",Won't the fix in your commit run into problems if only start_lnum is specified (which is the case for a few patterns?Maybe it's more robust to require specifying the end_lnum even if it's -1?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,912401905,2022-07-02T21:24:43Z,runtime/lua/vim/filetype/detect.lua,"@@ -1204,4 +1286,269 @@ end -- luacheck: pop -- luacheck: pop +local patterns_hashbang = {+  ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+  ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+  ['^expect\\>'] = { 'expect', { vim_regex = true } },+  ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+  ['make\\>'] = { 'make', { vim_regex = true } },+  ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+  lua = 'lua',+  perl = 'perl',+  php = 'php',+  python = 'python',+  ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+  raku = 'raku',+  ruby = 'ruby',+  ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+  ['rhino\\>'] = { 'javascript', { vim_regex = true } },+  -- BC calculator+  ['^bc\\>'] = { 'bc', { vim_regex = true } },+  ['sed\\>'] = { 'sed', { vim_regex = true } },+  ocaml = 'ocaml',+  -- Awk scripts; also finds ""gawk""+  ['awk\\>'] = { 'awk', { vim_regex = true } },+  wml = 'wml',+  scheme = 'scheme',+  cfengine = 'cfengine',+  escript = 'erlang',+  haskell = 'haskell',+  clojure = 'clojure',+  ['scala\\>'] = { 'scala', { vim_regex = true } },+  -- Free Pascal+  ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+  ['fennel\\>'] = { 'fennel', { vim_regex = true } },+  -- MikroTik RouterOS script+  ['rsc\\>'] = { 'routeros', { vim_regex = true } },+  ['fish\\>'] = { 'fish', { vim_regex = true } },+  ['gforth\\>'] = { 'forth', { vim_regex = true } },+  ['icon\\>'] = { 'icon', { vim_regex = true } },+}++---@private+-- File starts with ""#!"".+local function match_from_hashbang(contents, path)+  local first_line = contents[1]+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)+      :gsub('%-%-ignore%-environment', '', 1)+      :gsub('%-%-split%-string', '', 1)+    first_line = vim.fn.substitute(first_line, [[\<env\s\+]], '', '')+  end++  -- Get the program name.+  -- Only accept spaces in PC style paths: ""#!c:/program files/perl [args]"".+  -- If the word env is used, use the first word after the space:+  -- ""#!/usr/bin/env perl [path/args]""+  -- If there is no path use the first word: ""#!perl [path/args]"".+  -- Otherwise get the last word after a slash: ""#!/usr/bin/perl [path/args]"".+  local name+  if first_line:find('^#!%s*%a:[/\\]') then+    name = vim.fn.substitute(first_line, [[^#!.*[/\\]\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!.*\<env\>]]) then+    name = vim.fn.substitute(first_line, [[^#!.*\<env\>\s\+\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!\s*[^/\\ ]*\>\([^/\\]\|$\)]]) then+    name = vim.fn.substitute(first_line, [[^#!\s*\([^/\\ ]*\>\).*]], '\\1', '')+  else+    name = vim.fn.substitute(first_line, [[^#!\s*\S*[/\\]\(\i\+\).*]], '\\1', '')+  end++  -- tcl scripts may have #!/bin/sh in the first line and ""exec wish"" in the+  -- third line. Suggested by Steven Atkinson.+  if contents[3] and contents[3]:find('^exec wish') then+    name = 'wish'+  end++  if matchregex(name, [[^\(bash\d*\|\|ksh\d*\|sh\)\>]]) then+    -- Bourne-like shell scripts: bash bash2 ksh ksh93 sh+    return require('vim.filetype.detect').sh(path, contents, first_line)+  elseif matchregex(name, [[^csh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, vim.g.filetype_csh or 'csh')+  elseif matchregex(name, [[^tcsh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, 'tcsh')+  end++  for k, v in pairs(patterns_hashbang) do+    local ft = type(v) == 'table' and v[1] or v+    local opts = type(v) == 'table' and v[2] or {}+    if opts.vim_regex and matchregex(name, k) or name:find(k) then+      return ft+    end+  end+end++local patterns_text = {+  ['^#compdef\\>'] = { 'zsh', { vim_regex = true } },+  ['^#autoload\\>'] = { 'zsh', { vim_regex = true } },+  -- ELM Mail files+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 19%d%d$'] = 'mail',+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 20%d%d$'] = 'mail',+  ['^From %- .* 19%d%d$'] = 'mail',+  ['^From %- .* 20%d%d$'] = 'mail',+  -- Mason+  ['^<[%%&].*>'] = 'mason',+  -- Vim scripts (must have '"" vim' as the first line to trigger this)+  ['^"" *[vV]im$['] = 'vim',+  -- libcxx and libstdc++ standard library headers like [""iostream[""] do not have+  -- an extension, recognize the Emacs file mode.+  ['%-%*%-.*[cC]%+%+.*%-%*%-'] = 'cpp',+  ['^\\*\\* LambdaMOO Database, Format Version \\%([1-3]\\>\\)\\@!\\d\\+ \\*\\*$'] = {+    'moo',+    { vim_regex = true },+  },+  -- Diff file:+  -- - ""diff"" in first line (context diff)+  -- - ""Only in "" in first line+  -- - ""--- "" in first line and ""+++ "" in second line (unified diff).+  -- - ""*** "" in first line and ""--- "" in second line (context diff).+  -- - ""# It was generated by makepatch "" in the second line (makepatch diff).+  -- - ""Index: <filename>"" in the first line (CVS file)+  -- - ""=== "", line of ""="", ""---"", ""+++ "" (SVK diff)+  -- - ""=== "", ""--- "", ""+++ "" (bzr diff, common case)+  -- - ""=== (removed|added|renamed|modified)"" (bzr diff, alternative)+  -- - ""# HG changeset patch"" in first line (Mercurial export format)+  ['^\\(diff\\>\\|Only in \\|\\d\\+\\(,\\d\\+\\)\\=[cda]\\d\\+\\>\\|# It was generated by makepatch \\|Index:\\s\\+\\f\\+\\r\\=$\\|===== \\f\\+ \\d\\+\\.\\d\\+ vs edited\\|==== //\\f\\+#\\d\\+\\|# HG changeset patch\\)'] = {+    'diff',+    { vim_regex = true },+  },+  function(contents)+    return diff(contents)+  end,+  -- PostScript Files (must have %!PS as the first line, like a2ps output)+  ['^%%![ \t]*PS'] = 'postscr',+  function(contents)+    return m4(contents)+  end,+  -- SiCAD scripts (must have procn or procd as the first line to trigger this)+  ['^ *proc[nd] *$'] = { 'sicad', { ignore_case = true } },+  ['^%*%*%*%*  Purify'] = 'purifylog',+  -- XML+  ['<%?%s*xml.*%?>'] = 'xml',+  -- XHTML (e.g.: PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"")+  ['\\<DTD\\s\\+XHTML\\s'] = 'xhtml',+  -- HTML (e.g.: <!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"")+  -- Avoid ""doctype html"", used by slim.+  ['\\c<!DOCTYPE\\s\\+html\\>'] = { 'html', { vim_regex = true } },+  -- PDF+  ['^%%PDF%-'] = 'pdf',+  -- XXD output+  ['^%x%x%x%x%x%x%x: %x%x ?%x%x ?%x%x ?%x%x '] = 'xxd',+  -- RCS/CVS log output+  ['^RCS file:'] = { 'rcslog', { start_lnum = 1, end_lnum = 2 } },+  -- CVS commit+  ['^CVS:'] = { 'cvs', { start_lnum = 2 } },+  ['^CVS: '] = { 'cvs', { start_lnum = -1 } },+  -- Prescribe+  ['^!R!'] = 'prescribe',+  -- Send-pr+  ['^SEND%-PR:'] = 'sendpr',+  -- SNNS files+  ['^SNNS network definition file'] = 'snnsnet',+  ['^SNNS pattern definition file'] = 'snnspat',+  ['^SNNS result file'] = 'snnsres',+  ['^%%.-[Vv]irata'] = { 'virata', { start_lnum = 1, end_lnum = 5 } },+  ['[0-9:.]* *execve%('] = 'strace',+  ['^__libc_start_main'] = 'strace',+  -- VSE JCL+  ['^\\* $$ JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  ['^// *JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  -- TAK and SINDA+  ['K & K  Associates'] = { 'takout', { start_lnum = 4 } },+  ['TAK 2000'] = { 'takout', { start_lnum = 2 } },+  ['S Y S T E M S   I M P R O V E D '] = { 'syndaout', { start_lnum = 3 } },+  ['Run Date: '] = { 'takcmp', { start_lnum = 6 } },+  ['Node    File  1'] = { 'sindacmp', { start_lnum = 9 } },+  function(contents)+    require('vim.filetype.detect').dns_zone(contents)+  end,+  -- Valgrind+  ['^==%d+== valgrind'] = 'valgrind',+  ['^==%d+== Using valgrind'] = { 'valgrind', { start_lnum = 3 } },+  -- Go docs+  ['PACKAGE DOCUMENTATION$'] = 'godoc',+  -- Renderman Interface Bytestream+  ['^##RenderMan'] = 'rib',+  -- Scheme scripts+  ['exec%s%+%S*scheme'] = { 'scheme', { start_lnum = 1, end_lnum = 2 } },+  -- Git output+  ['^\\(commit\\|tree\\|object\\) \\x\\{40,\\}\\>\\|^tag \\S\\+$'] = { 'git', { vim_regex = true } },+  function(lines)+    -- Gprof (gnu profiler)+    if lines[1] == 'Flat profile:' and lines[2] == '' and lines[3]:find('^Each sample counts as .* seconds%.$') then+      return 'gprof'+    end+  end,+  -- Erlang terms+  -- (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)+  ['%-%*%-.*erlang.*%-%*%-'] = { 'erlang', { ignore_case = true } },+  -- YAML+  ['^%%YAML'] = 'yaml',+  -- MikroTik RouterOS script+  ['^#.*by RouterOS'] = 'routeros',+  -- Sed scripts+  -- #ncomment is allowed but most likely a false positive so require a space before any trailing comment text+  ['^#n%s'] = 'sed',+  ['^#n$'] = 'sed',+}++---@private+-- File does not start with ""#!"".+local function match_from_text(contents, path)+  if contents[1]:find('^:$') then+    -- Bourne-like shell scripts: sh ksh bash bash2+    return M.sh(path, contents)+  elseif matchregex('\n' .. table.concat(contents, '\n'), [[\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>]]) then+    -- Z shell scripts+    return 'zsh'+  end++  for k, v in pairs(patterns_text) do+    if type(v) == 'string' then+      -- Check the first line only+      if contents[1]:find(k) then+        return v+      end+    elseif type(v) == 'function' then+      -- If filetype detection fails, continue with the next pattern+      local ok, ft = pcall(v, contents)+      if ok and ft then+        return ft+      end+    else+      local opts = type(v) == 'table' and v[2] or {}+      if opts.start_lnum and opts.end_lnum then+        assert(not opts.ignore_case, 'ignore_case=true is ignored when start_lnum is also present, needs refactor')+        for i = opts.start_lnum, opts.end_lnum do+          if not contents[i] then+            break+          elseif contents[i]:find(k) then+            return v[1]+          end+        end+      else+        local line_nr = opts.start_lnum or 1+        local line = opts.ignore_case and contents[line_nr]:lower() or contents[line_nr]+        if opts.vim_regex and matchregex(line, k) or line:find(k) then","but I think the conditionals need to be different, as ` vim_regex` and `lnum` are orthogonal?",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,912402893,2022-07-02T21:37:21Z,runtime/lua/vim/filetype/detect.lua,"@@ -1204,4 +1286,269 @@ end -- luacheck: pop -- luacheck: pop +local patterns_hashbang = {+  ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+  ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+  ['^expect\\>'] = { 'expect', { vim_regex = true } },+  ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+  ['make\\>'] = { 'make', { vim_regex = true } },+  ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+  lua = 'lua',+  perl = 'lua',+  php = 'php',+  python = 'python',+  ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+  raku = 'raku',+  ruby = 'ruby',+  ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+  ['rhino\\>'] = { 'javascript', { vim_regex = true } },+  -- BC calculator+  ['^bc\\>'] = { 'bc', { vim_regex = true } },+  ['sed\\>'] = { 'sed', { vim_regex = true } },+  ocaml = 'ocaml',+  -- Awk scripts; also finds ""gawk""+  ['awk\\>'] = { 'awk', { vim_regex = true } },+  wml = 'wml',+  scheme = 'scheme',+  cfengine = 'cfengine',+  escript = 'erlang',+  haskell = 'haskell',+  clojure = 'clojure',+  ['scala\\>'] = { 'scala', { vim_regex = true } },+  -- Free Pascal+  ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+  ['fennel\\>'] = { 'fennel', { vim_regex = true } },+  -- MikroTik RouterOS script+  ['rsc\\>'] = { 'routeros', { vim_regex = true } },+  ['fish\\>'] = { 'fish', { vim_regex = true } },+  ['gforth\\>'] = { 'forth', { vim_regex = true } },+  ['icon\\>'] = { 'icon', { vim_regex = true } },+}++---@private+-- File starts with ""#!"".+local function match_from_hashbang(contents, path)+  local first_line = contents[1]+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if M.matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)+      :gsub('%-%-ignore%-environment', '', 1)+      :gsub('%-%-split%-string', '', 1)+    first_line = vim.fn.substitute(first_line, [[\<env\s\+]], '', '')+  end++  -- Get the program name.+  -- Only accept spaces in PC style paths: ""#!c:/program files/perl [args]"".+  -- If the word env is used, use the first word after the space:+  -- ""#!/usr/bin/env perl [path/args]""+  -- If there is no path use the first word: ""#!perl [path/args]"".+  -- Otherwise get the last word after a slash: ""#!/usr/bin/perl [path/args]"".+  local name+  if first_line:find('^#!%s*%a:[/\\]') then+    name = vim.fn.substitute(first_line, [[^#!.*[/\\]\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!.*\<env\>]]) then+    name = vim.fn.substitute(first_line, [[^#!.*\<env\>\s\+\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!\s*[^/\\ ]*\>\([^/\\]\|$\)]]) then+    name = vim.fn.substitute(first_line, [[^#!\s*\([^/\\ ]*\>\).*]], '\\1', '')+  else+    name = vim.fn.substitute(first_line, [[^#!\s*\S*[/\\]\(\i\+\).*]], '\\1', '')+  end++  -- tcl scripts may have #!/bin/sh in the first line and ""exec wish"" in the+  -- third line. Suggested by Steven Atkinson.+  if contents[3] and contents[3]:find('^exec wish') then+    name = 'wish'+  end++  if matchregex(name, [[^\(bash\d*\|\|ksh\d*\|sh\)\>]]) then+    -- Bourne-like shell scripts: bash bash2 ksh ksh93 sh+    return require('vim.filetype.detect').sh(path, contents, first_line)+  elseif matchregex(name, [[^csh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, vim.g.filetype_csh or 'csh')+  elseif matchregex(name, [[^tcsh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, 'tcsh')+  end++  for k, v in pairs(patterns_hashbang) do+    local ft = type(v) == 'table' and v[1] or v+    local opts = type(v) == 'table' and v[2] or {}+    if opts.vim_regex and matchregex(name, k) or name:find(k) then+      return ft+    end+  end+end++local patterns_text = {+  ['^#compdef\\>'] = { 'zsh', { vim_regex = true } },+  ['^#autoload\\>'] = { 'zsh', { vim_regex = true } },+  -- ELM Mail files+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 19%d%d$'] = 'mail',+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 20%d%d$'] = 'mail',+  ['^From %- .* 19%d%d$'] = 'mail',+  ['^From %- .* 20%d%d$'] = 'mail',+  -- Mason+  ['^<[%%&].*>'] = 'mason',+  -- Vim scripts (must have '"" vim' as the first line to trigger this)+  ['^"" *[vV]im$['] = 'vim',+  -- libcxx and libstdc++ standard library headers like [""iostream[""] do not have+  -- an extension, recognize the Emacs file mode.+  ['%-%*%-.*[cC]%+%+.*%-%*%-'] = 'cpp',+  ['^\\*\\* LambdaMOO Database, Format Version \\%([1-3]\\>\\)\\@!\\d\\+ \\*\\*$'] = {+    'moo',+    { vim_regex = true },+  },+  -- Diff file:+  -- - ""diff"" in first line (context diff)+  -- - ""Only in "" in first line+  -- - ""--- "" in first line and ""+++ "" in second line (unified diff).+  -- - ""*** "" in first line and ""--- "" in second line (context diff).+  -- - ""# It was generated by makepatch "" in the second line (makepatch diff).+  -- - ""Index: <filename>"" in the first line (CVS file)+  -- - ""=== "", line of ""="", ""---"", ""+++ "" (SVK diff)+  -- - ""=== "", ""--- "", ""+++ "" (bzr diff, common case)+  -- - ""=== (removed|added|renamed|modified)"" (bzr diff, alternative)+  -- - ""# HG changeset patch"" in first line (Mercurial export format)+  ['^\\(diff\\>\\|Only in \\|\\d\\+\\(,\\d\\+\\)\\=[cda]\\d\\+\\>\\|# It was generated by makepatch \\|Index:\\s\\+\\f\\+\\r\\=$\\|===== \\f\\+ \\d\\+\\.\\d\\+ vs edited\\|==== //\\f\\+#\\d\\+\\|# HG changeset patch\\)'] = {+    'diff',+    { vim_regex = true },+  },+  function(contents)+    return diff(contents)+  end,+  -- PostScript Files (must have %!PS as the first line, like a2ps output)+  ['^%%![ \t]*PS'] = 'postscr',+  function(contents)+    return m4(contents)+  end,+  -- SiCAD scripts (must have procn or procd as the first line to trigger this)+  ['^ *proc[nd] *$'] = { 'sicad', { ignore_case = true } },+  ['^%*%*%*%*  Purify'] = 'purifylog',+  -- XML+  ['<%?%s*xml.*%?>'] = 'xml',+  -- XHTML (e.g.: PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"")+  ['\\<DTD\\s\\+XHTML\\s'] = 'xhtml',+  -- HTML (e.g.: <!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"")+  -- Avoid ""doctype html"", used by slim.+  ['\\c<!DOCTYPE\\s\\+html\\>'] = { 'html', { vim_regex = true } },+  -- PDF+  ['^%%PDF%-'] = 'pdf',+  -- XXD output+  ['^%x%x%x%x%x%x%x: %x%x ?%x%x ?%x%x ?%x%x '] = 'xxd',+  -- RCS/CVS log output+  ['^RCS file:'] = { 'rcslog', { start_lnum = 1, end_lnum = 2 } },+  -- CVS commit+  ['^CVS:'] = { 'cvs', { start_lnum = 2 } },+  ['^CVS: '] = { 'cvs', { start_lnum = -1 } },+  -- Prescribe+  ['^!R!'] = 'prescribe',+  -- Send-pr+  ['^SEND%-PR:'] = 'sendpr',+  -- SNNS files+  ['^SNNS network definition file'] = 'snnsnet',+  ['^SNNS pattern definition file'] = 'snnspat',+  ['^SNNS result file'] = 'snnsres',+  ['&%%.-[Vv]irata'] = { 'virata', { start_lnum = 1, end_lnum = 5 } },+  ['[0-9:.]* *execve%('] = 'strace',+  ['^__libc_start_main'] = 'strace',+  -- VSE JCL+  ['^\\* $$ JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  ['^// *JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  -- TAK and SINDA+  ['K & K  Associates'] = { 'takout', { start_lnum = 4 } },+  ['TAK 2000'] = { 'takout', { start_lnum = 2 } },+  ['S Y S T E M S   I M P R O V E D '] = { 'syndaout', { start_lnum = 3 } },+  ['Run Date: '] = { 'takcmp', { start_lnum = 6 } },+  ['Node    File  1'] = { 'sindacmp', { start_lnum = 9 } },+  function(contents)+    require('vim.filetype.detect').dns_zone(contents)+  end,+  -- Valgrind+  ['^==%d+== valgrind'] = 'valgrind',+  ['^==%d+== Using valgrind'] = { 'valgrind', { start_lnum = 3 } },+  -- Go docs+  ['PACKAGE DOCUMENTATION$'] = 'godoc',+  -- Renderman Interface Bytestream+  ['^##RenderMan'] = 'rib',+  -- Scheme scripts+  ['exec%s%+%S*scheme'] = { 'scheme', { start_lnum = 1, end_lnum = 2 } },+  -- Git output+  ['^\\(commit\\|tree\\|object\\) \\x\\{40,\\}\\>\\|^tag \\S\\+$'] = { 'git', { vim_regex = true } },+  function(lines)+    -- Gprof (gnu profiler)+    if lines[1] == 'Flat profile:' and lines[2] == '' and lines[3]:find('^Each sample counts as .* seconds%.$') then+      return 'gprof'+    end+  end,+  -- Erlang terms+  -- (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)+  ['%-%*%-.*erlang.*%-%*%-'] = { 'erlang', { ignore_case = true } },+  -- YAML+  ['^&YAML'] = 'yaml',+  -- MikroTik RouterOS script+  ['^#.*by RouterOS'] = 'routeros',+  -- Sed scripts+  -- #ncomment is allowed but most likely a false positive so require a space before any trailing comment text+  ['^#n%s'] = 'sed',+  ['^#n$'] = 'sed',+}++---@private+-- File does not start with ""#!"".+local function match_from_text(contents, path)+  if contents[1]:find('^:$') then+    -- Bourne-like shell scripts: sh ksh bash bash2+    return M.sh(path, contents)+  elseif matchregex('\n' .. table.concat(contents, '\n'), [[\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>]]) then+    -- Z shell scripts+    return 'zsh'+  end++  for k, v in pairs(patterns_text) do+    if type(v) == 'string' then+      -- Check the first line only+      if contents[1]:find(k) then+        return v+      end+    elseif type(v) == 'function' then+      -- If filetype detection fails, continue with the next pattern+      local ok, ft = pcall(v, contents)+      if ok and ft then+        return ft+      end+    else+      local opts = type(v) == 'table' and v[2] or {}+      if opts.start_lnum then+        assert(not opts.ignore_case, 'ignore_case=true is ignored when start_lnum is also present, needs refactor')+        for i = opts.start_lnum, opts.end_lnum do",(I meant an _unconditional_ `finish` -- no `if`s and buts!),
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,912411108,2022-07-02T23:43:59Z,runtime/lua/vim/filetype/detect.lua,"@@ -1204,4 +1286,269 @@ end -- luacheck: pop -- luacheck: pop +local patterns_hashbang = {+  ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+  ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+  ['^expect\\>'] = { 'expect', { vim_regex = true } },+  ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+  ['make\\>'] = { 'make', { vim_regex = true } },+  ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+  lua = 'lua',+  perl = 'perl',+  php = 'php',+  python = 'python',+  ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+  raku = 'raku',+  ruby = 'ruby',+  ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+  ['rhino\\>'] = { 'javascript', { vim_regex = true } },+  -- BC calculator+  ['^bc\\>'] = { 'bc', { vim_regex = true } },+  ['sed\\>'] = { 'sed', { vim_regex = true } },+  ocaml = 'ocaml',+  -- Awk scripts; also finds ""gawk""+  ['awk\\>'] = { 'awk', { vim_regex = true } },+  wml = 'wml',+  scheme = 'scheme',+  cfengine = 'cfengine',+  escript = 'erlang',+  haskell = 'haskell',+  clojure = 'clojure',+  ['scala\\>'] = { 'scala', { vim_regex = true } },+  -- Free Pascal+  ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+  ['fennel\\>'] = { 'fennel', { vim_regex = true } },+  -- MikroTik RouterOS script+  ['rsc\\>'] = { 'routeros', { vim_regex = true } },+  ['fish\\>'] = { 'fish', { vim_regex = true } },+  ['gforth\\>'] = { 'forth', { vim_regex = true } },+  ['icon\\>'] = { 'icon', { vim_regex = true } },+}++---@private+-- File starts with ""#!"".+local function match_from_hashbang(contents, path)+  local first_line = contents[1]+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)","this line is the culprit. it strips one(!) `-`, which prevents the subsequent `gsubs` from applying. I think the regex with alternatives does not behave the same as a sequential pattern, as the former matches _one_ of the pattern (greedily).",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,912455384,2022-07-03T09:05:38Z,runtime/lua/vim/filetype/detect.lua,"@@ -1204,4 +1286,269 @@ end -- luacheck: pop -- luacheck: pop +local patterns_hashbang = {+  ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+  ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+  ['^expect\\>'] = { 'expect', { vim_regex = true } },+  ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+  ['make\\>'] = { 'make', { vim_regex = true } },+  ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+  lua = 'lua',+  perl = 'perl',+  php = 'php',+  python = 'python',+  ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+  raku = 'raku',+  ruby = 'ruby',+  ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+  ['rhino\\>'] = { 'javascript', { vim_regex = true } },+  -- BC calculator+  ['^bc\\>'] = { 'bc', { vim_regex = true } },+  ['sed\\>'] = { 'sed', { vim_regex = true } },+  ocaml = 'ocaml',+  -- Awk scripts; also finds ""gawk""+  ['awk\\>'] = { 'awk', { vim_regex = true } },+  wml = 'wml',+  scheme = 'scheme',+  cfengine = 'cfengine',+  escript = 'erlang',+  haskell = 'haskell',+  clojure = 'clojure',+  ['scala\\>'] = { 'scala', { vim_regex = true } },+  -- Free Pascal+  ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+  ['fennel\\>'] = { 'fennel', { vim_regex = true } },+  -- MikroTik RouterOS script+  ['rsc\\>'] = { 'routeros', { vim_regex = true } },+  ['fish\\>'] = { 'fish', { vim_regex = true } },+  ['gforth\\>'] = { 'forth', { vim_regex = true } },+  ['icon\\>'] = { 'icon', { vim_regex = true } },+}++---@private+-- File starts with ""#!"".+local function match_from_hashbang(contents, path)+  local first_line = contents[1]+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)+      :gsub('%-%-ignore%-environment', '', 1)+      :gsub('%-%-split%-string', '', 1)","```suggestion      :gsub('%-%-ignore%-environment', '', 1)      :gsub('%-%-split%-string', '', 1)      :gsub('%-[iS]', '', 1)```Starting with the most specific pattern fixes this particular instance, but might not be a general solution.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,912467207,2022-07-03T10:46:16Z,runtime/lua/vim/filetype/detect.lua,"@@ -1204,4 +1286,269 @@ end -- luacheck: pop -- luacheck: pop +local patterns_hashbang = {+  ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+  ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+  ['^expect\\>'] = { 'expect', { vim_regex = true } },+  ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+  ['make\\>'] = { 'make', { vim_regex = true } },+  ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+  lua = 'lua',+  perl = 'perl',+  php = 'php',+  python = 'python',+  ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+  raku = 'raku',+  ruby = 'ruby',+  ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+  ['rhino\\>'] = { 'javascript', { vim_regex = true } },+  -- BC calculator+  ['^bc\\>'] = { 'bc', { vim_regex = true } },+  ['sed\\>'] = { 'sed', { vim_regex = true } },+  ocaml = 'ocaml',+  -- Awk scripts; also finds ""gawk""+  ['awk\\>'] = { 'awk', { vim_regex = true } },+  wml = 'wml',+  scheme = 'scheme',+  cfengine = 'cfengine',+  escript = 'erlang',+  haskell = 'haskell',+  clojure = 'clojure',+  ['scala\\>'] = { 'scala', { vim_regex = true } },+  -- Free Pascal+  ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+  ['fennel\\>'] = { 'fennel', { vim_regex = true } },+  -- MikroTik RouterOS script+  ['rsc\\>'] = { 'routeros', { vim_regex = true } },+  ['fish\\>'] = { 'fish', { vim_regex = true } },+  ['gforth\\>'] = { 'forth', { vim_regex = true } },+  ['icon\\>'] = { 'icon', { vim_regex = true } },+}++---@private+-- File starts with ""#!"".+local function match_from_hashbang(contents, path)+  local first_line = contents[1]+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)+      :gsub('%-%-ignore%-environment', '', 1)+      :gsub('%-%-split%-string', '', 1)+    first_line = vim.fn.substitute(first_line, [[\<env\s\+]], '', '')+  end++  -- Get the program name.+  -- Only accept spaces in PC style paths: ""#!c:/program files/perl [args]"".+  -- If the word env is used, use the first word after the space:+  -- ""#!/usr/bin/env perl [path/args]""+  -- If there is no path use the first word: ""#!perl [path/args]"".+  -- Otherwise get the last word after a slash: ""#!/usr/bin/perl [path/args]"".+  local name+  if first_line:find('^#!%s*%a:[/\\]') then+    name = vim.fn.substitute(first_line, [[^#!.*[/\\]\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!.*\<env\>]]) then+    name = vim.fn.substitute(first_line, [[^#!.*\<env\>\s\+\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!\s*[^/\\ ]*\>\([^/\\]\|$\)]]) then+    name = vim.fn.substitute(first_line, [[^#!\s*\([^/\\ ]*\>\).*]], '\\1', '')+  else+    name = vim.fn.substitute(first_line, [[^#!\s*\S*[/\\]\(\i\+\).*]], '\\1', '')+  end++  -- tcl scripts may have #!/bin/sh in the first line and ""exec wish"" in the+  -- third line. Suggested by Steven Atkinson.+  if contents[3] and contents[3]:find('^exec wish') then+    name = 'wish'+  end++  if matchregex(name, [[^\(bash\d*\|\|ksh\d*\|sh\)\>]]) then+    -- Bourne-like shell scripts: bash bash2 ksh ksh93 sh+    return require('vim.filetype.detect').sh(path, contents, first_line)+  elseif matchregex(name, [[^csh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, vim.g.filetype_csh or 'csh')+  elseif matchregex(name, [[^tcsh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, 'tcsh')+  end++  for k, v in pairs(patterns_hashbang) do+    local ft = type(v) == 'table' and v[1] or v+    local opts = type(v) == 'table' and v[2] or {}+    if opts.vim_regex and matchregex(name, k) or name:find(k) then+      return ft+    end+  end+end++local patterns_text = {+  ['^#compdef\\>'] = { 'zsh', { vim_regex = true } },+  ['^#autoload\\>'] = { 'zsh', { vim_regex = true } },+  -- ELM Mail files+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 19%d%d$'] = 'mail',+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 20%d%d$'] = 'mail',+  ['^From %- .* 19%d%d$'] = 'mail',+  ['^From %- .* 20%d%d$'] = 'mail',+  -- Mason+  ['^<[%%&].*>'] = 'mason',+  -- Vim scripts (must have '"" vim' as the first line to trigger this)+  ['^"" *[vV]im$['] = 'vim',+  -- libcxx and libstdc++ standard library headers like [""iostream[""] do not have+  -- an extension, recognize the Emacs file mode.+  ['%-%*%-.*[cC]%+%+.*%-%*%-'] = 'cpp',+  ['^\\*\\* LambdaMOO Database, Format Version \\%([1-3]\\>\\)\\@!\\d\\+ \\*\\*$'] = {+    'moo',+    { vim_regex = true },+  },+  -- Diff file:+  -- - ""diff"" in first line (context diff)+  -- - ""Only in "" in first line+  -- - ""--- "" in first line and ""+++ "" in second line (unified diff).+  -- - ""*** "" in first line and ""--- "" in second line (context diff).+  -- - ""# It was generated by makepatch "" in the second line (makepatch diff).+  -- - ""Index: <filename>"" in the first line (CVS file)+  -- - ""=== "", line of ""="", ""---"", ""+++ "" (SVK diff)+  -- - ""=== "", ""--- "", ""+++ "" (bzr diff, common case)+  -- - ""=== (removed|added|renamed|modified)"" (bzr diff, alternative)+  -- - ""# HG changeset patch"" in first line (Mercurial export format)+  ['^\\(diff\\>\\|Only in \\|\\d\\+\\(,\\d\\+\\)\\=[cda]\\d\\+\\>\\|# It was generated by makepatch \\|Index:\\s\\+\\f\\+\\r\\=$\\|===== \\f\\+ \\d\\+\\.\\d\\+ vs edited\\|==== //\\f\\+#\\d\\+\\|# HG changeset patch\\)'] = {+    'diff',+    { vim_regex = true },+  },+  function(contents)+    return diff(contents)+  end,+  -- PostScript Files (must have %!PS as the first line, like a2ps output)+  ['^%%![ \t]*PS'] = 'postscr',+  function(contents)+    return m4(contents)+  end,+  -- SiCAD scripts (must have procn or procd as the first line to trigger this)+  ['^ *proc[nd] *$'] = { 'sicad', { ignore_case = true } },+  ['^%*%*%*%*  Purify'] = 'purifylog',+  -- XML+  ['<%?%s*xml.*%?>'] = 'xml',+  -- XHTML (e.g.: PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"")+  ['\\<DTD\\s\\+XHTML\\s'] = 'xhtml',+  -- HTML (e.g.: <!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"")+  -- Avoid ""doctype html"", used by slim.+  ['\\c<!DOCTYPE\\s\\+html\\>'] = { 'html', { vim_regex = true } },+  -- PDF+  ['^%%PDF%-'] = 'pdf',+  -- XXD output+  ['^%x%x%x%x%x%x%x: %x%x ?%x%x ?%x%x ?%x%x '] = 'xxd',+  -- RCS/CVS log output+  ['^RCS file:'] = { 'rcslog', { start_lnum = 1, end_lnum = 2 } },+  -- CVS commit+  ['^CVS:'] = { 'cvs', { start_lnum = 2 } },+  ['^CVS: '] = { 'cvs', { start_lnum = -1 } },+  -- Prescribe+  ['^!R!'] = 'prescribe',+  -- Send-pr+  ['^SEND%-PR:'] = 'sendpr',+  -- SNNS files+  ['^SNNS network definition file'] = 'snnsnet',+  ['^SNNS pattern definition file'] = 'snnspat',+  ['^SNNS result file'] = 'snnsres',+  ['^%%.-[Vv]irata'] = { 'virata', { start_lnum = 1, end_lnum = 5 } },+  ['[0-9:.]* *execve%('] = 'strace',+  ['^__libc_start_main'] = 'strace',+  -- VSE JCL+  ['^\\* $$ JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  ['^// *JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  -- TAK and SINDA+  ['K & K  Associates'] = { 'takout', { start_lnum = 4 } },+  ['TAK 2000'] = { 'takout', { start_lnum = 2 } },+  ['S Y S T E M S   I M P R O V E D '] = { 'syndaout', { start_lnum = 3 } },+  ['Run Date: '] = { 'takcmp', { start_lnum = 6 } },+  ['Node    File  1'] = { 'sindacmp', { start_lnum = 9 } },+  function(contents)+    require('vim.filetype.detect').dns_zone(contents)+  end,+  -- Valgrind+  ['^==%d+== valgrind'] = 'valgrind',+  ['^==%d+== Using valgrind'] = { 'valgrind', { start_lnum = 3 } },+  -- Go docs+  ['PACKAGE DOCUMENTATION$'] = 'godoc',+  -- Renderman Interface Bytestream+  ['^##RenderMan'] = 'rib',+  -- Scheme scripts+  ['exec%s%+%S*scheme'] = { 'scheme', { start_lnum = 1, end_lnum = 2 } },+  -- Git output+  ['^\\(commit\\|tree\\|object\\) \\x\\{40,\\}\\>\\|^tag \\S\\+$'] = { 'git', { vim_regex = true } },+  function(lines)+    -- Gprof (gnu profiler)+    if lines[1] == 'Flat profile:' and lines[2] == '' and lines[3]:find('^Each sample counts as .* seconds%.$') then+      return 'gprof'+    end+  end,+  -- Erlang terms+  -- (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)+  ['%-%*%-.*erlang.*%-%*%-'] = { 'erlang', { ignore_case = true } },+  -- YAML+  ['^%%YAML'] = 'yaml',+  -- MikroTik RouterOS script+  ['^#.*by RouterOS'] = 'routeros',+  -- Sed scripts+  -- #ncomment is allowed but most likely a false positive so require a space before any trailing comment text+  ['^#n%s'] = 'sed',+  ['^#n$'] = 'sed',+}++---@private+-- File does not start with ""#!"".+local function match_from_text(contents, path)+  if contents[1]:find('^:$') then+    -- Bourne-like shell scripts: sh ksh bash bash2+    return M.sh(path, contents)+  elseif matchregex('\n' .. table.concat(contents, '\n'), [[\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>]]) then+    -- Z shell scripts+    return 'zsh'+  end++  for k, v in pairs(patterns_text) do+    if type(v) == 'string' then+      -- Check the first line only+      if contents[1]:find(k) then+        return v+      end+    elseif type(v) == 'function' then+      -- If filetype detection fails, continue with the next pattern+      local ok, ft = pcall(v, contents)+      if ok and ft then+        return ft+      end+    else+      local opts = type(v) == 'table' and v[2] or {}+      if opts.start_lnum and opts.end_lnum then+        assert(not opts.ignore_case, 'ignore_case=true is ignored when start_lnum is also present, needs refactor')+        for i = opts.start_lnum, opts.end_lnum do+          if not contents[i] then+            break+          elseif contents[i]:find(k) then+            return v[1]+          end+        end+      else+        local line_nr = opts.start_lnum or 1",```suggestion        local line_nr = opts.start_lnum or 1        if line_nr == -1 then line_nr = #contents end```(Probably can be collapsed into a more complicated assignment but grug brain does not like complexity.),
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/18710,912467457,2022-07-03T10:48:09Z,runtime/lua/vim/filetype/detect.lua,"@@ -1204,4 +1286,269 @@ end -- luacheck: pop -- luacheck: pop +local patterns_hashbang = {+  ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+  ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+  ['^expect\\>'] = { 'expect', { vim_regex = true } },+  ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+  ['make\\>'] = { 'make', { vim_regex = true } },+  ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+  lua = 'lua',+  perl = 'perl',+  php = 'php',+  python = 'python',+  ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+  raku = 'raku',+  ruby = 'ruby',+  ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+  ['rhino\\>'] = { 'javascript', { vim_regex = true } },+  -- BC calculator+  ['^bc\\>'] = { 'bc', { vim_regex = true } },+  ['sed\\>'] = { 'sed', { vim_regex = true } },+  ocaml = 'ocaml',+  -- Awk scripts; also finds ""gawk""+  ['awk\\>'] = { 'awk', { vim_regex = true } },+  wml = 'wml',+  scheme = 'scheme',+  cfengine = 'cfengine',+  escript = 'erlang',+  haskell = 'haskell',+  clojure = 'clojure',+  ['scala\\>'] = { 'scala', { vim_regex = true } },+  -- Free Pascal+  ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+  ['fennel\\>'] = { 'fennel', { vim_regex = true } },+  -- MikroTik RouterOS script+  ['rsc\\>'] = { 'routeros', { vim_regex = true } },+  ['fish\\>'] = { 'fish', { vim_regex = true } },+  ['gforth\\>'] = { 'forth', { vim_regex = true } },+  ['icon\\>'] = { 'icon', { vim_regex = true } },+}++---@private+-- File starts with ""#!"".+local function match_from_hashbang(contents, path)+  local first_line = contents[1]+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)+      :gsub('%-%-ignore%-environment', '', 1)+      :gsub('%-%-split%-string', '', 1)","Good catch. Tbh, I am not sure why the Vim version works here: if the first pattern `-[iS]` matches, wouldn't the `-i` in  `--ignore-environment` be matched and consequently replaced first? So I think moving the less specific pattern `ignore-environment` to the end is definitely ""more correct"" and can probably stay that way. I can add a comment though.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/18710,912469540,2022-07-03T11:06:16Z,runtime/lua/vim/filetype/detect.lua,"@@ -1204,4 +1286,269 @@ end -- luacheck: pop -- luacheck: pop +local patterns_hashbang = {+  ['^zsh\\>'] = { 'zsh', { vim_regex = true } },+  ['^\\(tclsh\\|wish\\|expectk\\|itclsh\\|itkwish\\)\\>'] = { 'tcl', { vim_regex = true } },+  ['^expect\\>'] = { 'expect', { vim_regex = true } },+  ['^gnuplot\\>'] = { 'gnuplot', { vim_regex = true } },+  ['make\\>'] = { 'make', { vim_regex = true } },+  ['^pike\\%(\\>\\|[0-9]\\)'] = { 'pike', { vim_regex = true } },+  lua = 'lua',+  perl = 'perl',+  php = 'php',+  python = 'python',+  ['^groovy\\>'] = { 'groovy', { vim_regex = true } },+  raku = 'raku',+  ruby = 'ruby',+  ['node\\(js\\)\\=\\>\\|js\\>'] = { 'javascript', { vim_regex = true } },+  ['rhino\\>'] = { 'javascript', { vim_regex = true } },+  -- BC calculator+  ['^bc\\>'] = { 'bc', { vim_regex = true } },+  ['sed\\>'] = { 'sed', { vim_regex = true } },+  ocaml = 'ocaml',+  -- Awk scripts; also finds ""gawk""+  ['awk\\>'] = { 'awk', { vim_regex = true } },+  wml = 'wml',+  scheme = 'scheme',+  cfengine = 'cfengine',+  escript = 'erlang',+  haskell = 'haskell',+  clojure = 'clojure',+  ['scala\\>'] = { 'scala', { vim_regex = true } },+  -- Free Pascal+  ['instantfpc\\>'] = { 'pascal', { vim_regex = true } },+  ['fennel\\>'] = { 'fennel', { vim_regex = true } },+  -- MikroTik RouterOS script+  ['rsc\\>'] = { 'routeros', { vim_regex = true } },+  ['fish\\>'] = { 'fish', { vim_regex = true } },+  ['gforth\\>'] = { 'forth', { vim_regex = true } },+  ['icon\\>'] = { 'icon', { vim_regex = true } },+}++---@private+-- File starts with ""#!"".+local function match_from_hashbang(contents, path)+  local first_line = contents[1]+  -- Check for a line like ""#!/usr/bin/env {options} bash"".  Turn it into+  -- ""#!/usr/bin/bash"" to make matching easier.+  -- Recognize only a few {options} that are commonly used.+  if matchregex(first_line, [[^#!\s*\S*\<env\s]]) then+    first_line = first_line:gsub('%S+=%S+', '')+    first_line = first_line+      :gsub('%-[iS]', '', 1)+      :gsub('%-%-ignore%-environment', '', 1)+      :gsub('%-%-split%-string', '', 1)+    first_line = vim.fn.substitute(first_line, [[\<env\s\+]], '', '')+  end++  -- Get the program name.+  -- Only accept spaces in PC style paths: ""#!c:/program files/perl [args]"".+  -- If the word env is used, use the first word after the space:+  -- ""#!/usr/bin/env perl [path/args]""+  -- If there is no path use the first word: ""#!perl [path/args]"".+  -- Otherwise get the last word after a slash: ""#!/usr/bin/perl [path/args]"".+  local name+  if first_line:find('^#!%s*%a:[/\\]') then+    name = vim.fn.substitute(first_line, [[^#!.*[/\\]\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!.*\<env\>]]) then+    name = vim.fn.substitute(first_line, [[^#!.*\<env\>\s\+\(\i\+\).*]], '\\1', '')+  elseif matchregex(first_line, [[^#!\s*[^/\\ ]*\>\([^/\\]\|$\)]]) then+    name = vim.fn.substitute(first_line, [[^#!\s*\([^/\\ ]*\>\).*]], '\\1', '')+  else+    name = vim.fn.substitute(first_line, [[^#!\s*\S*[/\\]\(\i\+\).*]], '\\1', '')+  end++  -- tcl scripts may have #!/bin/sh in the first line and ""exec wish"" in the+  -- third line. Suggested by Steven Atkinson.+  if contents[3] and contents[3]:find('^exec wish') then+    name = 'wish'+  end++  if matchregex(name, [[^\(bash\d*\|\|ksh\d*\|sh\)\>]]) then+    -- Bourne-like shell scripts: bash bash2 ksh ksh93 sh+    return require('vim.filetype.detect').sh(path, contents, first_line)+  elseif matchregex(name, [[^csh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, vim.g.filetype_csh or 'csh')+  elseif matchregex(name, [[^tcsh\>]]) then+    return require('vim.filetype.detect').shell(path, contents, 'tcsh')+  end++  for k, v in pairs(patterns_hashbang) do+    local ft = type(v) == 'table' and v[1] or v+    local opts = type(v) == 'table' and v[2] or {}+    if opts.vim_regex and matchregex(name, k) or name:find(k) then+      return ft+    end+  end+end++local patterns_text = {+  ['^#compdef\\>'] = { 'zsh', { vim_regex = true } },+  ['^#autoload\\>'] = { 'zsh', { vim_regex = true } },+  -- ELM Mail files+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 19%d%d$'] = 'mail',+  ['^From [a-zA-Z][a-zA-Z_0-9%.=%-]*(@[^ ]*)? .* 20%d%d$'] = 'mail',+  ['^From %- .* 19%d%d$'] = 'mail',+  ['^From %- .* 20%d%d$'] = 'mail',+  -- Mason+  ['^<[%%&].*>'] = 'mason',+  -- Vim scripts (must have '"" vim' as the first line to trigger this)+  ['^"" *[vV]im$['] = 'vim',+  -- libcxx and libstdc++ standard library headers like [""iostream[""] do not have+  -- an extension, recognize the Emacs file mode.+  ['%-%*%-.*[cC]%+%+.*%-%*%-'] = 'cpp',+  ['^\\*\\* LambdaMOO Database, Format Version \\%([1-3]\\>\\)\\@!\\d\\+ \\*\\*$'] = {+    'moo',+    { vim_regex = true },+  },+  -- Diff file:+  -- - ""diff"" in first line (context diff)+  -- - ""Only in "" in first line+  -- - ""--- "" in first line and ""+++ "" in second line (unified diff).+  -- - ""*** "" in first line and ""--- "" in second line (context diff).+  -- - ""# It was generated by makepatch "" in the second line (makepatch diff).+  -- - ""Index: <filename>"" in the first line (CVS file)+  -- - ""=== "", line of ""="", ""---"", ""+++ "" (SVK diff)+  -- - ""=== "", ""--- "", ""+++ "" (bzr diff, common case)+  -- - ""=== (removed|added|renamed|modified)"" (bzr diff, alternative)+  -- - ""# HG changeset patch"" in first line (Mercurial export format)+  ['^\\(diff\\>\\|Only in \\|\\d\\+\\(,\\d\\+\\)\\=[cda]\\d\\+\\>\\|# It was generated by makepatch \\|Index:\\s\\+\\f\\+\\r\\=$\\|===== \\f\\+ \\d\\+\\.\\d\\+ vs edited\\|==== //\\f\\+#\\d\\+\\|# HG changeset patch\\)'] = {+    'diff',+    { vim_regex = true },+  },+  function(contents)+    return diff(contents)+  end,+  -- PostScript Files (must have %!PS as the first line, like a2ps output)+  ['^%%![ \t]*PS'] = 'postscr',+  function(contents)+    return m4(contents)+  end,+  -- SiCAD scripts (must have procn or procd as the first line to trigger this)+  ['^ *proc[nd] *$'] = { 'sicad', { ignore_case = true } },+  ['^%*%*%*%*  Purify'] = 'purifylog',+  -- XML+  ['<%?%s*xml.*%?>'] = 'xml',+  -- XHTML (e.g.: PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"")+  ['\\<DTD\\s\\+XHTML\\s'] = 'xhtml',+  -- HTML (e.g.: <!DOCTYPE HTML PUBLIC ""-//W3C//DTD HTML 4.01//EN"")+  -- Avoid ""doctype html"", used by slim.+  ['\\c<!DOCTYPE\\s\\+html\\>'] = { 'html', { vim_regex = true } },+  -- PDF+  ['^%%PDF%-'] = 'pdf',+  -- XXD output+  ['^%x%x%x%x%x%x%x: %x%x ?%x%x ?%x%x ?%x%x '] = 'xxd',+  -- RCS/CVS log output+  ['^RCS file:'] = { 'rcslog', { start_lnum = 1, end_lnum = 2 } },+  -- CVS commit+  ['^CVS:'] = { 'cvs', { start_lnum = 2 } },+  ['^CVS: '] = { 'cvs', { start_lnum = -1 } },+  -- Prescribe+  ['^!R!'] = 'prescribe',+  -- Send-pr+  ['^SEND%-PR:'] = 'sendpr',+  -- SNNS files+  ['^SNNS network definition file'] = 'snnsnet',+  ['^SNNS pattern definition file'] = 'snnspat',+  ['^SNNS result file'] = 'snnsres',+  ['^%%.-[Vv]irata'] = { 'virata', { start_lnum = 1, end_lnum = 5 } },+  ['[0-9:.]* *execve%('] = 'strace',+  ['^__libc_start_main'] = 'strace',+  -- VSE JCL+  ['^\\* $$ JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  ['^// *JOB\\>'] = { 'vsejcl', { vim_regex = true } },+  -- TAK and SINDA+  ['K & K  Associates'] = { 'takout', { start_lnum = 4 } },+  ['TAK 2000'] = { 'takout', { start_lnum = 2 } },+  ['S Y S T E M S   I M P R O V E D '] = { 'syndaout', { start_lnum = 3 } },+  ['Run Date: '] = { 'takcmp', { start_lnum = 6 } },+  ['Node    File  1'] = { 'sindacmp', { start_lnum = 9 } },+  function(contents)+    require('vim.filetype.detect').dns_zone(contents)+  end,+  -- Valgrind+  ['^==%d+== valgrind'] = 'valgrind',+  ['^==%d+== Using valgrind'] = { 'valgrind', { start_lnum = 3 } },+  -- Go docs+  ['PACKAGE DOCUMENTATION$'] = 'godoc',+  -- Renderman Interface Bytestream+  ['^##RenderMan'] = 'rib',+  -- Scheme scripts+  ['exec%s%+%S*scheme'] = { 'scheme', { start_lnum = 1, end_lnum = 2 } },+  -- Git output+  ['^\\(commit\\|tree\\|object\\) \\x\\{40,\\}\\>\\|^tag \\S\\+$'] = { 'git', { vim_regex = true } },+  function(lines)+    -- Gprof (gnu profiler)+    if lines[1] == 'Flat profile:' and lines[2] == '' and lines[3]:find('^Each sample counts as .* seconds%.$') then+      return 'gprof'+    end+  end,+  -- Erlang terms+  -- (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)+  ['%-%*%-.*erlang.*%-%*%-'] = { 'erlang', { ignore_case = true } },+  -- YAML+  ['^%%YAML'] = 'yaml',+  -- MikroTik RouterOS script+  ['^#.*by RouterOS'] = 'routeros',+  -- Sed scripts+  -- #ncomment is allowed but most likely a false positive so require a space before any trailing comment text+  ['^#n%s'] = 'sed',+  ['^#n$'] = 'sed',+}++---@private+-- File does not start with ""#!"".+local function match_from_text(contents, path)+  if contents[1]:find('^:$') then+    -- Bourne-like shell scripts: sh ksh bash bash2+    return M.sh(path, contents)+  elseif matchregex('\n' .. table.concat(contents, '\n'), [[\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>]]) then+    -- Z shell scripts+    return 'zsh'+  end++  for k, v in pairs(patterns_text) do+    if type(v) == 'string' then+      -- Check the first line only+      if contents[1]:find(k) then+        return v+      end+    elseif type(v) == 'function' then+      -- If filetype detection fails, continue with the next pattern+      local ok, ft = pcall(v, contents)+      if ok and ft then+        return ft+      end+    else+      local opts = type(v) == 'table' and v[2] or {}+      if opts.start_lnum and opts.end_lnum then+        assert(not opts.ignore_case, 'ignore_case=true is ignored when start_lnum is also present, needs refactor')+        for i = opts.start_lnum, opts.end_lnum do+          if not contents[i] then+            break+          elseif contents[i]:find(k) then+            return v[1]+          end+        end+      else+        local line_nr = opts.start_lnum or 1",I'd remove the comment for the patterns (or move it to the top of the `gsub` chain) to stop Stylua from going haywire.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19218,912516586,2022-07-03T17:39:22Z,runtime/lua/vim/filetype.lua,"@@ -1305,7 +1304,7 @@ local filename = {   ['/debian/copyright'] = 'debcopyright',   ['/etc/apt/sources.list'] = 'debsources',   ['denyhosts.conf'] = 'denyhosts',-  ['.*/debian/patches/.*'] = function(path, bufnr)+  ['*/debian/patches/.*'] = function(path, bufnr)",should be in `pattern` table (with the `.*`),
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/19218,912744912,2022-07-04T08:17:20Z,runtime/lua/vim/filetype.lua,"@@ -1693,6 +1690,9 @@ local pattern = {   ['.*/%.?cmus/.*%.theme'] = 'cmusrc',   ['.*/%.cmus/autosave'] = 'cmusrc',   ['.*/%.cmus/command%-history'] = 'cmusrc',+  ['/etc/hostname%..*'] = starsetf('config'),","Not sure about that one, the pattern in `filetype.vim` is `/etc/hostname.*` so `.*/etc/hostname%..*` seems incorrect to me (the test doesn't fail for me)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19218,912751577,2022-07-04T08:24:48Z,runtime/lua/vim/filetype.lua,"@@ -1693,6 +1690,9 @@ local pattern = {   ['.*/%.?cmus/.*%.theme'] = 'cmusrc',   ['.*/%.cmus/autosave'] = 'cmusrc',   ['.*/%.cmus/command%-history'] = 'cmusrc',+  ['/etc/hostname%..*'] = starsetf('config'),","Ah, I think I see what's going on. This is indeed platform-specific: (my) macOS sandboxes the `/etc` files; trying to edit `/etc/foo` will open `/private/etc/foo`. Hence Vim's pattern here will not work (and Vim in fact behaves the same). That means we have three options:1. accept the failure (`/etc/hostname.*` is not relevant on macOS)2. fix the failure (all other patterns are `*/etc/<foo>`, so this might be an oversight?)3. report the issue upstream and see what they think (@zeertzjq ?)",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/19218,912756400,2022-07-04T08:30:01Z,runtime/lua/vim/filetype.lua,"@@ -1693,6 +1690,9 @@ local pattern = {   ['.*/%.?cmus/.*%.theme'] = 'cmusrc',   ['.*/%.cmus/autosave'] = 'cmusrc',   ['.*/%.cmus/command%-history'] = 'cmusrc',+  ['/etc/hostname%..*'] = starsetf('config'),","> report the issue upstream and see what they thinkWe should definitely do this one, maybe Vim will simply update the pattern to `*/etc/hostname.*` which we can then update as well",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19218,912762594,2022-07-04T08:37:05Z,runtime/lua/vim/filetype.lua,"@@ -1693,6 +1690,9 @@ local pattern = {   ['.*/%.?cmus/.*%.theme'] = 'cmusrc',   ['.*/%.cmus/autosave'] = 'cmusrc',   ['.*/%.cmus/command%-history'] = 'cmusrc',+  ['/etc/hostname%..*'] = starsetf('config'),","I'm quite sure it's an oversight, though -- _every single_ other of the >100 patterns uses `*/etc`.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19218,912793986,2022-07-04T09:10:09Z,runtime/lua/vim/filetype.lua,"@@ -1693,6 +1690,9 @@ local pattern = {   ['.*/%.?cmus/.*%.theme'] = 'cmusrc',   ['.*/%.cmus/autosave'] = 'cmusrc',   ['.*/%.cmus/command%-history'] = 'cmusrc',+  ['/etc/hostname%..*'] = starsetf('config'),","Test fails on macOS CI as well; not sure yet why this is not an issue for `filetype.vim`, but that means we need to adapt the pattern to have the same behavior, independent of what Vim does.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19213,912916132,2022-07-04T11:37:39Z,runtime/lua/vim/lsp/handlers.lua,"@@ -197,7 +197,11 @@ M['textDocument/references'] = function(_, result, ctx, config)         items = util.locations_to_items(result, client.offset_encoding),         context = ctx,       })-      api.nvim_command('botright copen')+      if not config.no_qf_window then+        api.nvim_command('botright copen')+      else+        api.nvim_command('cfirst')+      end","if we're going to introduce new surface area, it should be a function, not another hardcoded flag. Something like this:```suggestion      if not config. on_qflist then        api.nvim_command('botright copen')      else        assert(type(config.on_qflist) == 'function', 'on_qflist is not a function')        config.on_qflist()      end```And this should be done for the loclist case as well. But the option name is just `on_qflist`.We should have generalized `config.loclist` to `config.on_qfitems`, but too late now.The help doc should be something like:```on_qflist : function called after vim.lsp sets the quickfix list (or location list if config.loclist=true).For example to run :cfirst instead of opening the quickfix list:...,on_qflist = function()  vim.cmd('cfirst')end,...```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19213,912923595,2022-07-04T11:47:42Z,runtime/lua/vim/lsp/handlers.lua,"@@ -197,7 +197,11 @@ M['textDocument/references'] = function(_, result, ctx, config)         items = util.locations_to_items(result, client.offset_encoding),         context = ctx,       })-      api.nvim_command('botright copen')+      if not config.no_qf_window then+        api.nvim_command('botright copen')+      else+        api.nvim_command('cfirst')+      end","`config.on_qfitems` would be a more complex discussion, don't need to worry about it here. I think `config.on_qflist` is a reasonable change given the number of places where it is relevant, but also want to hear from @neovim/lsp ",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/19213,913277806,2022-07-04T21:56:10Z,runtime/lua/vim/lsp/handlers.lua,"@@ -197,7 +197,11 @@ M['textDocument/references'] = function(_, result, ctx, config)         items = util.locations_to_items(result, client.offset_encoding),         context = ctx,       })-      api.nvim_command('botright copen')+      if not config.no_qf_window then+        api.nvim_command('botright copen')+      else+        api.nvim_command('cfirst')+      end","Something like `on_qflist` sounds good to me but I think we shouldn't extend `config` with it and instead add `options` to `buf.references`. See the reasons outlined here https://github.com/neovim/neovim/pull/18577#discussion_r873420834Although not sure if it's even worth it. We already expose `utils.locations_to_items` and the references handler doesn't do much more than calling it.One could already write something like this:```luavim.lsp.handlers['textDocument/references'] = function(_, result, ctx, config)  if result and not vim.tbl_isempty(result) then    local client = vim.lsp.get_client_by_id(ctx.client_id)    local items = vim.lsp.util.locations_to_items(result, client.offset_encoding)    vim.fn.setqflist({}, ' ', {      title = 'References',      items = items,      context = ctx,    })  endend```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19213,913668211,2022-07-05T11:01:17Z,runtime/lua/vim/lsp/handlers.lua,"@@ -197,7 +197,11 @@ M['textDocument/references'] = function(_, result, ctx, config)         items = util.locations_to_items(result, client.offset_encoding),         context = ctx,       })-      api.nvim_command('botright copen')+      if not config.no_qf_window then+        api.nvim_command('botright copen')+      else+        api.nvim_command('cfirst')+      end","> but I think we shouldn't extend `config` with it and instead add `options` to `buf.references`. See the reasons outlined here [#18577 (comment)](https://github.com/neovim/neovim/pull/18577#discussion_r873420834)Ah, right. What does that mean for the existing `config.loclist`?> One could already write something like this:Does that handle all 3 cases from this PR?",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19251,914697218,2022-07-06T10:48:41Z,.github/workflows/ci.yml,"@@ -19,9 +19,9 @@ concurrency: jobs:   lint:     # This job tests two things: it lints the code but also builds neovim using-    # system dependencies instead of bundled dependencies. This is to make sure-    # we are able to build neovim without pigeonholing ourselves into specifics-    # of the bundled dependencies.+    # the system's package manager to download third-party dependencies.+    # This is to make sure we are able to build neovim without pigeonholing +    # ourselves into specifics of the bundled dependencies.","system-dependency is not the same thing as a system-managed dependency.I'll put it back, since It was a nit-pick on my part anyway.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/19251,914703539,2022-07-06T10:56:25Z,.github/workflows/ci.yml,"@@ -55,17 +55,17 @@ jobs:             libuv1-dev \             libvterm-dev \             locales \-            lua-busted \-            lua-check \-            lua-filesystem \-            lua-inspect \-            lua-lpeg \-            lua-luv-dev \-            lua-nvim \             luajit \             ninja-build \             pkg-config +      - name: Install luarocks+        run: |+          sudo apt install -y lua5.1 luarocks+          echo ""using luarocks: ""+          luarocks path+          sudo luarocks install luacheck+          sudo luarocks --lua-version=5.1 build luv",That's why the lint job is still using [bundled LUV](https://github.com/neovim/neovim/blob/c68f1d7263cd5296e723d8cfee914c72f58138c3/.github/workflows/env.sh#L56-L58).,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19251,914724333,2022-07-06T11:22:34Z,.github/workflows/ci.yml,"@@ -55,17 +55,17 @@ jobs:             libuv1-dev \             libvterm-dev \             locales \-            lua-busted \-            lua-check \-            lua-filesystem \-            lua-inspect \-            lua-lpeg \-            lua-luv-dev \-            lua-nvim \             luajit \             ninja-build \             pkg-config +      - name: Install luarocks+        run: |+          sudo apt install -y lua5.1 luarocks+          echo ""using luarocks: ""+          luarocks path+          sudo luarocks install luacheck+          sudo luarocks --lua-version=5.1 build luv","doesn't that mean that this description is then obsolete?https://github.com/neovim/neovim/blob/f0503371852ae8f142a4721e9b5670eee1ebb4f3/.github/workflows/ci.yml#L21-L24or at least we should update this block, which otherwise looks identical to the one that install all the depshttps://github.com/neovim/neovim/blob/9ced05413474a7c8b8a8b2f36a27db29a37dfaf6/.github/workflows/ci.yml#L103-L104",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19264,915608180,2022-07-07T08:32:26Z,runtime/lua/vim/F.lua,"@@ -5,40 +5,28 @@ local F = {} ---@param a ---@param b function F.if_nil(a, b)-  if a == nil then-    return b-  end+  if a == nil then return b end   return a end  -- Use in combination with pcall function F.ok_or_nil(status, ...)-  if not status then-    return-  end+  if not status then return end   return ... end  -- Nil pcall.-function F.npcall(fn, ...)-  return F.ok_or_nil(pcall(fn, ...))-end+function F.npcall(fn, ...) return F.ok_or_nil(pcall(fn, ...)) end  --- Wrap a function to return nil if it fails, otherwise the value function F.nil_wrap(fn)-  return function(...)-    return F.npcall(fn, ...)-  end+  return function(...) return F.npcall(fn, ...) end end  --- like {...} except preserve the length explicitly-function F.pack_len(...)-  return { n = select('#', ...), ... }-end+function F.pack_len(...) return { n = select('#', ...), ... } end  --- like unpack() but use the length set by F.pack_len if present-function F.unpack_len(t)-  return unpack(t, 1, t.n)-end+function F.unpack_len(t) return unpack(t, 1, t.n) end",definitely don't think this is an improvement. Kotlin does similar things and it is just visually confusing. A function definition deserves a visual block.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19264,915653464,2022-07-07T09:18:18Z,runtime/lua/vim/lsp.lua,"@@ -89,10 +89,8 @@ end --- supported in any of the servers registered for the current buffer. ---@param method (string) name of the method function lsp._unsupported_method(method)-  local msg = string.format(-    'method %s is not supported by any of the servers registered for the current buffer',-    method-  )+  local msg =+    string.format('method %s is not supported by any of the servers registered for the current buffer', method)",this is over 100 chars long. can we limit it?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19267,916066170,2022-07-07T16:24:37Z,src/nvim/lua/executor.c,"@@ -870,6 +885,49 @@ static int nlua_print(lua_State *const lstate)   return lua_error(lstate); } +/// require used for --startuptime+///+/// @param  lstate  Lua interpreter state.+static int nlua_require(lua_State *const lstate)+  FUNC_ATTR_NONNULL_ALL+{+  const char *name = luaL_checkstring(lstate, 1);+  lua_settop(lstate, 1);+  // [ name ]++  // try cached module from package.loaded first+  lua_getfield(lstate, LUA_REGISTRYINDEX, ""_LOADED"");+  lua_getfield(lstate, 2, name);+  // [ name package.loaded module ]+  if (lua_toboolean(lstate, -1)) {+    return 1;+  }+  lua_pop(lstate, 2);++  // push previous require and module name+  nlua_pushref(lstate, require_ref);+  lua_pushvalue(lstate, 1);+  // [ name require name ]++  // call it directly if log file is closed+  if (time_fd == NULL) {","Sounds reasonable. I agree that this doesn't warrant adding complexity, but a simple approach that covers >90% of cases (such as you suggest) might be worth it.",
1944737,daliusd,https://api.github.com/repos/neovim/neovim/pulls/19213,916121789,2022-07-07T17:32:01Z,runtime/lua/vim/lsp/handlers.lua,"@@ -197,7 +197,11 @@ M['textDocument/references'] = function(_, result, ctx, config)         items = util.locations_to_items(result, client.offset_encoding),         context = ctx,       })-      api.nvim_command('botright copen')+      if not config.no_qf_window then+        api.nvim_command('botright copen')+      else+        api.nvim_command('cfirst')+      end","Hey, I have thought about it and decided to go with `on_list`. This allows deprecate `loclist`. Please look at examples in description, code and let me know what you think.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/19213,916543152,2022-07-08T07:33:58Z,runtime/doc/lsp.txt,"@@ -413,6 +413,29 @@ For the format of the response message, see: For the format of the notification message, see:     https://microsoft.github.io/language-server-protocol/specifications/specification-current/#notificationMessage +                                                                *on-list-handler*++on_list handler accepts single parameter options which can be passed directly+to vim.fn.setqflist or vim.fn.setloclist. E.g.:","I think instead of telling users what they can do with the payload it should first elaborate what's part of the payload. E.g.:```suggestion`on_list` receives a table with: - `items` table[], structured like |setqflist-what| - `title` string, title for the list. - `context` table|nil. `ctx` from |lsp-handler|This table can be used with vim.fn.setqflist or vim.fn.setloclist. E.g.:```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19282,916840292,2022-07-08T13:53:57Z,runtime/lua/vim/lsp/util.lua,"@@ -1366,29 +1366,21 @@ local function close_preview_autocmd(events, winnr, bufnrs)    -- close the preview window when entered a buffer that is not   -- the floating window buffer or the buffer that spawned it-  vim.cmd(string.format(-    [[-    augroup %s-      autocmd!-      autocmd BufEnter * lua vim.lsp.util._close_preview_window(%d, {%s})-    augroup end-  ]],-    augroup,-    winnr,-    table.concat(bufnrs, ',')-  ))+  api.nvim_create_autocmds('BufEnter', {+    group = augroup,+    pattern = '*',","`pattern='*'` is the default, no need to add that.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19282,916844736,2022-07-08T13:58:27Z,runtime/lua/vim/diagnostic.lua,"@@ -347,17 +347,13 @@ local function schedule_display(namespace, bufnr, args)    local key = make_augroup_key(namespace, bufnr)   if not registered_autocmds[key] then-    vim.cmd(string.format(-      [[augroup %s-      au!",use `nvim_clear_autocmds()` (see the similar refactor at https://github.com/nvim-treesitter/nvim-treesitter/commit/07eb437bb1c4c0a0298553dd509294f82362d6bc),
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19283,917209451,2022-07-09T02:27:27Z,runtime/lua/vim/diagnostic.lua,"@@ -1045,26 +1060,6 @@ function M._get_virt_text_chunks(line_diags, opts)   end end ---- Callback scheduled when leaving Insert mode.-------- This function must be exported publicly so that it is available to be---- called from the Vimscript autocommand.-------- See @ref schedule_display()--------@private-function M._execute_scheduled_display(namespace, bufnr)","Keep the public function and have it simply call the new local function, and add a call to `vim.deprecate` that indicates that this function will be removed in the 0.9 release.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19283,917210062,2022-07-09T02:33:56Z,runtime/lua/vim/diagnostic.lua,"@@ -346,18 +366,15 @@ local function schedule_display(namespace, bufnr, args)   bufs_waiting_to_update[bufnr][namespace] = args    local key = make_augroup_key(namespace, bufnr)+  local group = vim.api.nvim_create_augroup(key, { clear = true })   if not registered_autocmds[key] then-    vim.cmd(string.format(-      [[augroup %s-      au!-      autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)-    augroup END]],-      key,-      table.concat(insert_leave_auto_cmds, ','),-      bufnr,-      namespace,-      bufnr-    ))+    vim.api.nvim_create_autocmd(insert_leave_auto_cmds, {+      group = group,+      buffer = bufnr,+      callback = function()+        execute_scheduled_display(namespace, bufnr)+      end,+    })     registered_autocmds[key] = true","`registered_autocmds` could now use group IDs instead of names, and I think a similar thing could be done with `close_preview_autocmd` in `vim.lsp.util`, but maybe that's for future PRs.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19283,917270556,2022-07-09T13:49:22Z,runtime/lua/vim/diagnostic.lua,"@@ -338,6 +338,32 @@ local function make_augroup_key(namespace, bufnr)   return string.format('DiagnosticInsertLeave:%s:%s', bufnr, ns.name) end +---@private+local function execute_scheduled_display(namespace, bufnr)+  local args = bufs_waiting_to_update[bufnr][namespace]+  if not args then+    return+  end++  -- Clear the args so we don't display unnecessarily.+  bufs_waiting_to_update[bufnr][namespace] = nil++  M.show(namespace, bufnr, nil, args)+end++--- @deprecated+--- Callback scheduled when leaving Insert mode.+---+--- called from the Vimscript autocommand.+---+--- See @ref schedule_display()+---+---@private+function M._execute_scheduled_display(namespace, bufnr)+  vim.deprecate('vim.diagnostic._execute_scheduled_display', 'execute_scheduled_display', '0.9')","The second argument to `vim.deprecate` is ""what to use instead"". In this case, there is nothing to use instead, so leave it `nil`.```suggestion  vim.deprecate('vim.diagnostic._execute_scheduled_display', nil, '0.9')```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19283,917270655,2022-07-09T13:50:37Z,runtime/lua/vim/highlight.lua,"@@ -9,28 +9,6 @@ M.priorities = {   user = 200, } ----@private-function M.create(higroup, hi_info, default)-  local options = {}-  -- TODO: Add validation-  for k, v in pairs(hi_info) do-    table.insert(options, string.format('%s=%s', k, v))-  end-  vim.cmd(-    string.format(-      [[highlight %s %s %s]],-      default and 'default' or '',-      higroup,-      table.concat(options, ' ')-    )-  )-end-----@private-function M.link(higroup, link_to, force)-  vim.cmd(string.format([[highlight%s link %s %s]], force and '!' or ' default', higroup, link_to))-end-","Do not simply delete exported functions. Leave them as-is for now and add calls to `vim.deprecate`. For the ""alternative"" field, instruct users to use `vim.api.nvim_set_hl`:```luavim.deprecate('vim.highlight.link', 'vim.api.nvim_set_hl', '0.9')```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19283,917271070,2022-07-09T13:55:49Z,runtime/lua/vim/highlight.lua,"@@ -9,6 +9,30 @@ M.priorities = {   user = 200, } +---@private+function M.create(higroup, hi_info, default)+  vim.deprecate('vim.highlight.create', 'vim.api.nvim_set_hl', '0.9')+  local options = {}+  -- TODO: Add validation+  for k, v in pairs(hi_info) do+    table.insert(options, string.format('%s=%s', k, v))+  end+  vim.cmd(+    string.format(+      [[highlight %s %s %s]],+      default and 'default' or '',+      higroup,+      table.concat(options, ' ')+    )+  )+end++---@private+function M.link(higroup, link_to, force)+  vim.deprecate('vim.highlight.create', 'vim.api.nvim_set_hl', '0.9')","```suggestion  vim.deprecate('vim.highlight.link', 'vim.api.nvim_set_hl', '0.9')```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19301,917313227,2022-07-09T22:06:43Z,src/nvim/testdir/runtest.vim,"@@ -161,9 +161,8 @@ func RunTheTest(test)     endtry   endif -  "" Make ""Q"" switch to Ex mode.-  "" This does not work for all tests.-  nnoremap Q gQ+  "" Align Nvim defaults to Vim.+  source vim_defaults.vim","naming it with setup_ prefix helps discoverability a bit, then it will live next to setup.vim",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19302,917319203,2022-07-09T23:37:20Z,runtime/lua/vim/lsp/util.lua,"@@ -1367,8 +1367,8 @@ local function close_preview_window(winnr, bufnrs)     end      local augroup = 'preview_window_' .. winnr-    api.nvim_del_augroup_by_name(augroup)-    pcall(vim.api.nvim_win_close, winnr, true)+    pcall(api.nvim_del_augroup_by_name, augroup)+    pcall(api.nvim_win_close, winnr, true)","off-topic for this PR, but this seems like a questionable pattern--it is like `try-catch` without handling the error in any way, which is very troublesome to debug. Maybe we need a util function like `vim.pcall()` that ignores errors containing a specified string, and optionally logs failures.In other cases, usually there is a condition that can be checked to avoid needing to silence errors.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19302,917319366,2022-07-09T23:39:42Z,runtime/lua/vim/lsp/util.lua,"@@ -1367,8 +1367,8 @@ local function close_preview_window(winnr, bufnrs)     end      local augroup = 'preview_window_' .. winnr-    api.nvim_del_augroup_by_name(augroup)-    pcall(vim.api.nvim_win_close, winnr, true)+    pcall(api.nvim_del_augroup_by_name, augroup)+    pcall(api.nvim_win_close, winnr, true)","Agreed. (Though here the pattern is more like `silent!`, which doesn't have a Lua analogue, so this is the closest thing.)(Some of the LSP code seems to date from the very early days of Lua runtime. A general cleanup could be worth it.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19306,917386434,2022-07-10T12:09:27Z,src/nvim/ex_cmds.c,"@@ -2120,7 +2120,7 @@ void do_wqall(exarg_T *eap)       if (buf_write_all(buf, eap->forceit) == FAIL) {         error++;       }-      // An autocommand may have deleted the buffer.+      // an autocommand may have deleted the buffer","using punctuation in comments is useful, avoids ambiguity. ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19309,917394773,2022-07-10T13:16:08Z,runtime/lua/vim/lsp.lua,"@@ -4,15 +4,15 @@ local lsp_rpc = require('vim.lsp.rpc') local protocol = require('vim.lsp.protocol') local util = require('vim.lsp.util') local sync = require('vim.lsp.sync')-local api = vim.api  local vim = vim+local a = vim.api local nvim_err_writeln, nvim_buf_get_lines, nvim_command, nvim_buf_get_option, nvim_exec_autocmds =-  vim.api.nvim_err_writeln,-  vim.api.nvim_buf_get_lines,-  vim.api.nvim_command,-  vim.api.nvim_buf_get_option,-  vim.api.nvim_exec_autocmds+  a.nvim_err_writeln,+  a.nvim_buf_get_lines,+  a.nvim_command,+  a.nvim_buf_get_option,+  a.nvim_exec_autocmds local uv = vim.loop","What's the general opinion on ""hiding"" `vim.loop` like that? It's shorter, and points towards the Luv docs, but on the other hand breaks the link to `:h vim.loop`.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19309,917394986,2022-07-10T13:17:56Z,runtime/lua/vim/lsp.lua,"@@ -4,15 +4,15 @@ local lsp_rpc = require('vim.lsp.rpc') local protocol = require('vim.lsp.protocol') local util = require('vim.lsp.util') local sync = require('vim.lsp.sync')-local api = vim.api  local vim = vim+local a = vim.api local nvim_err_writeln, nvim_buf_get_lines, nvim_command, nvim_buf_get_option, nvim_exec_autocmds =-  vim.api.nvim_err_writeln,-  vim.api.nvim_buf_get_lines,-  vim.api.nvim_command,-  vim.api.nvim_buf_get_option,-  vim.api.nvim_exec_autocmds+  a.nvim_err_writeln,+  a.nvim_buf_get_lines,+  a.nvim_command,+  a.nvim_buf_get_option,+  a.nvim_exec_autocmds local uv = vim.loop local tbl_isempty, tbl_extend = vim.tbl_isempty, vim.tbl_extend local validate = vim.validate","Again, general question: Is this ""local import everything"" a pattern we want to encourage?",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/19329,918369323,2022-07-11T21:36:01Z,runtime/lua/vim/lsp.lua,"@@ -739,10 +739,12 @@ function lsp.start(config, opts)     end   config.name = config.name or (config.cmd[1] and vim.fs.basename(config.cmd[1])) or nil   local bufnr = api.nvim_get_current_buf()-  for _, client in pairs(lsp.get_active_clients()) do-    if reuse_client(client, config) then-      lsp.buf_attach_client(bufnr, client.id)-      return client.id+  for _, clients in ipairs({uninitialized_clients, lsp.get_active_clients()}) do","This creates a list with two entries, I think you need to use `unwrap` or something equivalent here. ",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/19329,918396195,2022-07-11T22:24:05Z,runtime/lua/vim/lsp.lua,"@@ -739,10 +739,12 @@ function lsp.start(config, opts)     end   config.name = config.name or (config.cmd[1] and vim.fs.basename(config.cmd[1])) or nil   local bufnr = api.nvim_get_current_buf()-  for _, client in pairs(lsp.get_active_clients()) do-    if reuse_client(client, config) then-      lsp.buf_attach_client(bufnr, client.id)-      return client.id+  for _, clients in ipairs({uninitialized_clients, lsp.get_active_clients()}) do",I intended it to be a list with two entries.I'm not sure how unwrap would help the logic. Could you clarify?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17099,919810527,2022-07-13T08:40:37Z,runtime/lua/vim/treesitter/query.lua,"@@ -179,11 +179,19 @@ function M.parse_query(lang, query)   end end ---- Gets the text corresponding to a given node+--- Gets the text corresponding to a given node or a list of nodes -------@param node the node+---@param node the node or list of nodes ---@param source The buffer or string from which the node is extracted function M.get_node_text(node, source)+  -- If node is a list of nodes then return their concatenated text+  if node['start'] == nil and type(node) == 'table' then+    local text = ''+    for _, node1 in ipairs(node) do+      text = text .. M.get_node_text(node1, source)","> Sure. When passing a single node which isn't a list, a single string should be returned.> > I'm just contemplating whether if a list is given as the input, then a list is returned? Should remain compat and doesn't remove information.I disagree; return types should be static. Either we need two functions, or (as an uneasy compromise)  add an `opts` table that controls the behavior.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17099,919831632,2022-07-13T09:01:39Z,runtime/doc/treesitter.txt,"@@ -429,10 +429,10 @@ add_predicate({name}, {handler}, {force})                    *add_predicate()*                                be (match, pattern, bufnr, predicate)  get_node_text({node}, {source})                              *get_node_text()*-                Gets the text corresponding to a given node+                Gets the text corresponding to a given node or a list of nodes                  Parameters: ~-                    {node}    the node+                    {node}    the node or list of nodes","Tbh, thinking about it, do we even need this change? What's the reason for allowing this function to accept a node list as opposed to just running a map function on the node list?",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19315,920769382,2022-07-14T05:40:20Z,src/nvim/channel.c,"@@ -517,6 +517,45 @@ uint64_t channel_from_stdio(bool rpc, CallbackReader on_output, const char **err   return channel->id; } +size_t newline_adjust(char **str)+{+#ifdef UNIX+  return 0;+#else+  if (!str || !*str) {+    return 0;+  }+  size_t c = 0;+  char *p = *str;++  while (*p++) {+    c += *p == '\n' ? 1 : 0;+  }",Should I use `strcnt`?https://github.com/neovim/neovim/blob/778541067a2f0ec3ef4bc1b07def646323e852a9/src/nvim/memory.c#L269-L286,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19290,920840449,2022-07-14T07:27:06Z,src/nvim/menu.c,"@@ -1819,3 +1819,57 @@ static char *menu_translate_tab_and_shift(char *arg_start)    return arg; }++// build new menu from list of items+void menu_build(char *name, menuitem_T **items, size_t nitems)+{+  unsigned sep = 0;++  // clear menu just in case+  vim_snprintf((char *)IObuff, IOSIZE, ""silent! aunmenu %s"", name);+  do_cmdline_cmd((char *)IObuff);++  for (size_t i = 0; i < nitems; i++) {+    if (items[i] == NULL) {+      // separator+      vim_snprintf((char *)IObuff, IOSIZE, ""anoremenu %s.-%u-<Tab> <Nop>"",+                   name, ++sep);+    } else {+      // normal item+      char *text = (char *)vim_strsave_escaped((char_u *)_(items[i]->text),+                                               escape_chars);+      vim_snprintf((char *)IObuff, IOSIZE, ""%snoremenu %s.%s<Tab> %s"",+                   items[i]->mode, name, text, items[i]->command);+      XFREE_CLEAR(text);+    }++    // add to menu+    do_cmdline_cmd((char *)IObuff);+  }+}++// initialization of default menus+void init_default_menus(void)+{+#define ITEM(m, t, c) &(menuitem_T) { (m), (t), (c) },++  // for right mouse button+  menuitem_T *popup[] = {+    //   Mode Text                Command+    ITEM(""a"", N_(""Undo""),         ""u"")+    ITEM(""v"", N_(""Cut""),          ""\""+x"")+    ITEM(""v"", N_(""Copy""),         ""\""+y"")+    ITEM(""a"", N_(""Paste""),        ""\""+gP"")+    ITEM(""v"", N_(""Paste""),        ""\""+p"")+    ITEM(""v"", N_(""Delete""),       ""\""_x"")+    ITEM(""n"", N_(""Select All""),   ""ggVG"")+    ITEM(""v"", N_(""Select All""),   ""gg0oG$"")+    ITEM(""i"", N_(""Select All""),   ""<C-Home><C-O>VG"")+    NULL,+    ITEM(""a"", N_(""How-to disable mouse""), ""<Cmd>help disable-mouse<CR>"")+  };++#undef ITEM++  menu_build(""PopUp"", popup, ARRAY_SIZE(popup));","this is nicely done, but could instead be done in Lua in `./runtime/lua/vim/_editor.lua`, in a new `vim._init_default_mappings` function. That avoids some C code and the `menuitem_T` type. Then it can be called like this: https://github.com/neovim/neovim/blob/b81d1eb26502f403574113385a75444f8880828e/src/nvim/api/vim.c#L1835-L1837I think this is worth doing to avoid continuing the pattern of adding more and more C code, and to help kickstart a pattern of using Lua for business logic.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19290,922174121,2022-07-15T13:37:34Z,runtime/lua/vim/_editor.lua,"@@ -810,6 +810,44 @@ function vim.deprecate(name, alternative, version, plugin, backtrace)   end end +--- Create builtin mappings (incl. menus).+--- Called once on startup.+function vim._init_default_mappings()+  -- mappings++  --@private+  local function map(mode, lhs, rhs)+    vim.api.nvim_set_keymap(mode, lhs, rhs, { noremap = true, desc = 'Nvim builtin' })+  end++  map('n',  'Y',      'y$')+  -- Use normal! <C-L> to prevent inserting raw <C-L> when using i_<C-O>+  -- See https://github.com/neovim/neovim/issues/17473+  map('n',  '<C-L>',  '<Cmd>nohlsearch<Bar>diffupdate<Bar>normal! <C-L><CR>')+  map('i',  '<C-U>',  '<C-G>u<C-U>')+  map('i',  '<C-W>',  '<C-G>u<C-W>')+  map('x',  '*',      'y/\\V<C-R>""<CR>')","- is this really equivalent? the C string was `""y/\\\\V<C-R>\""<CR>""`. In Lua, single-quotes still need similar escaping. To avoid escaping at the Lua layer, use `[[...]]`.- similar for the one below```suggestion  map('x',  '*',      [[y/\V<C-R>""<CR>]])```",
35012635,matveyt,https://api.github.com/repos/neovim/neovim/pulls/19290,922267175,2022-07-15T15:17:43Z,test/functional/core/startup_spec.lua,"@@ -524,8 +524,8 @@ describe('sysinit', function()     screen:expect([[       ^                                                            |       Entering Debug mode.  Type ""cont"" to continue.              |-      pre-vimrc command line                                      |-      cmd: set noruler                                            |+      {MATCH:.+}|+      {MATCH:cmd: .+}|",`-D` prints the first VimScript command along with its source. After this PR it becomes `aunmenu *` (as default mappings precede even `--cmd`). But even this may change some day. So I'm not sure what could be matched here without future issues? Or maybe we should move `--cmd` to occur _before_ default mappings?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17446,922285487,2022-07-15T15:39:21Z,runtime/doc/options.txt,"@@ -2650,6 +2650,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	To close folds you can re-apply 'foldlevel' with the |zx| command or 	set the 'foldclose' option to ""all"". +    						      *'foldoptions'* *'fop'*+'foldoptions' 'fop'	string (default """")+			local to window+	List of words that change the behavor of the |foldcolumn|.+          nodigits      Disable digits shown to indicate the nesting level.","> I've tried doing this but can't seem a find a way to properly set the default value. Doing it in the lua options definitions has no effect.did you look at existing examples, e.g. https://github.com/neovim/neovim/blob/9370e1c5111ee90f64260398b0623da4759f8f16/src/nvim/options.lua#L633-L640and what exactly did you try",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19309,922293400,2022-07-15T15:46:25Z,runtime/lua/vim/lsp/buf.lua,"@@ -1,6 +1,5 @@-local vim = vim+local a = vim.api local validate = vim.validate-local vfn = vim.fn","+1 for removing this. Renaming modules is definitely something to avoid, it adds needless unfamiliarity to every file.The exception is if there is a consistent convention. For example in the test files I think we should always import ""helpers"" as `local t = require('test.helpers')`. That would avoid a lot of boilerplate.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19290,922307939,2022-07-15T16:04:56Z,test/functional/core/startup_spec.lua,"@@ -524,8 +524,8 @@ describe('sysinit', function()     screen:expect([[       ^                                                            |       Entering Debug mode.  Type ""cont"" to continue.              |-      pre-vimrc command line                                      |-      cmd: set noruler                                            |+      {MATCH:.+}|+      {MATCH:cmd: .+}|","I'd say just add `aunmenu *` here. It's not too bad to update it every now and then, and it gives visbility.",X
161548,andersevenrud,https://api.github.com/repos/neovim/neovim/pulls/17446,922364270,2022-07-15T17:11:42Z,runtime/doc/options.txt,"@@ -2650,6 +2650,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	To close folds you can re-apply 'foldlevel' with the |zx| command or 	set the 'foldclose' option to ""all"". +    						      *'foldoptions'* *'fop'*+'foldoptions' 'fop'	string (default """")+			local to window+	List of words that change the behavor of the |foldcolumn|.+          nodigits      Disable digits shown to indicate the nesting level.","@justinmk Yeah, I've looked hard at finding a solution to my issue. But totally hit a wall.Here's my uncomitted work based on this branch:```patchdiff --git a/runtime/doc/options.txt b/runtime/doc/options.txtindex 536cce727..6a81e5dc2 100644--- a/runtime/doc/options.txt+++ b/runtime/doc/options.txt@@ -2651,10 +2651,10 @@ A jump table for the options with a short description can be found at |Q_op|.        set the 'foldclose' option to ""all"".                                                      *'foldoptions'* *'fop'*-'foldoptions' 'fop'    string (default """")+'foldoptions' 'fop'    string (default ""digits"")                        local to window-       List of words that change the behavor of the |foldcolumn|.-          nodigits      Disable digits shown to indicate the nesting level.+       List of words that change the behavor of the |folding|.+          digits        Enable digits shown to indicate the nesting level.                                                *'foldtext'* *'fdt'* 'foldtext' 'fdt'       string (default: ""foldtext()"")diff --git a/src/nvim/option_defs.h b/src/nvim/option_defs.hindex a4de28f2c..36d1e9c0f 100644--- a/src/nvim/option_defs.h+++ b/src/nvim/option_defs.h@@ -461,9 +461,9 @@ static char *(p_fdo_values[]) = { ""all"", ""block"", ""hor"", ""mark"", ""percent"", #define FDO_UNDO               0x200 #define FDO_JUMP               0x400 #ifdef IN_OPTION_C-static char *(p_fop_values[]) = { ""nodigits"", NULL };+static char *(p_fop_values[]) = { ""digits"", NULL }; #endif-#define FOP_NODIGITS           0x01+#define FOP_DIGITS             0x01 EXTERN char_u *p_fp;          // 'formatprg' EXTERN int p_fs;                // 'fsync' EXTERN int p_gd;                // 'gdefault'diff --git a/src/nvim/options.lua b/src/nvim/options.luaindex 8bb4ad29d..afdb127bb 100644--- a/src/nvim/options.lua+++ b/src/nvim/options.lua@@ -867,7 +867,7 @@ return {       type='string', list='onecomma', scope={'window'},       deny_duplicates=true,       redraw={'current_window'},-      defaults={if_true=''}+      defaults={if_true='digits'}     },     {       full_name='foldenable', abbreviation='fen',diff --git a/src/nvim/screen.c b/src/nvim/screen.cindex 7562326f5..c73b195c6 100644--- a/src/nvim/screen.c+++ b/src/nvim/screen.c@@ -1922,7 +1922,7 @@ static size_t fill_foldcolumn(char_u *p, win_T *wp, foldinfo_T foldinfo, linenr_   int symbol = 0;   int len = 0;   bool closed = foldinfo.fi_lines > 0;-  bool no_digits = wp->w_p_fop_flags & FOP_NODIGITS;+  bool no_digits = !(wp->w_p_fop_flags & FOP_DIGITS);   // Init to all spaces.   memset(p, ' ', MAX_MCO * fdc + 1);diff --git a/test/functional/ui/fold_spec.lua b/test/functional/ui/fold_spec.luaindex f73459038..f40999cfe 100644--- a/test/functional/ui/fold_spec.lua+++ b/test/functional/ui/fold_spec.lua@@ -1866,7 +1866,7 @@ describe(""folded lines"", function()         ]])       end-      command('set foldoptions=nodigits')+      command('set foldoptions=')       if multigrid then         screen:expect([[           ## grid 1```It doesn't seem like `defaults` does anything when the scope is set to `window`, unless I'm totally missing something obvious here :thinking: ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17446,922389045,2022-07-15T17:40:54Z,runtime/doc/options.txt,"@@ -2650,6 +2650,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	To close folds you can re-apply 'foldlevel' with the |zx| command or 	set the 'foldclose' option to ""all"". +    						      *'foldoptions'* *'fop'*+'foldoptions' 'fop'	string (default """")+			local to window+	List of words that change the behavor of the |foldcolumn|.+          nodigits      Disable digits shown to indicate the nesting level.",hmm `cursorlineopt` is similar and it seems to work. Maybe try `redraw={'current_window_only'}` (just a guess) ?,
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19315,922418688,2022-07-15T18:21:54Z,test/functional/ui/output_spec.lua,"@@ -55,7 +55,7 @@ describe(""shell command :!"", function()     if 'openbsd' == helpers.uname() then       pending('FIXME #10804')     end-    child_session.feed_data(("":!%s REP 30001 foo\n""):format(testprg('shell-test')))+    child_session.feed_data(("":!%s REP 30001 foo\r""):format(testprg('shell-test')))","I ended up changing the test itself. I mean, `<CR>` means Carriage Return. So `\r` seems more appropriate, right? I donno more in-depth technicalities of these end-of-line stuff, tho.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/16067,922828512,2022-07-17T12:47:15Z,src/nvim/shada.c,"@@ -2216,8 +2222,22 @@ static inline ShaDaWriteResult shada_read_when_writing(ShaDaReadDef *const sd_re               }               shada_free_shada_entry(&wms_entry->data);             }+          } else {+            FOR_ALL_BUFFERS(buf) {+              if (strequal((char *)buf->b_ffname, entry.data.filemark.fname)) {+                fmark_T *fmp = xmalloc(sizeof(fmark_T));+                mark_get(buf, curwin, fmp, kMarkBufLocal, (int)entry.data.filemark.name);+                if (fmp->timestamp > entry.timestamp) {+                  set_wms = false;+                  break;+                }+                XFREE_CLEAR(fmp);","`fmark_T` can be allocated on the stack here:```suggestion                fmark_T fmp;                mark_get(buf, curwin, &fmp, kMarkBufLocal, (int)entry.data.filemark.name);                if (fmp.timestamp > entry.timestamp) {                  set_wms = false;                  break;                }```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/18375,922871141,2022-07-17T17:13:53Z,runtime/doc/ui.txt,"@@ -55,8 +55,8 @@ with these (optional) keys: 	`stdin_fd`		Read buffer from `fd` as if it was a stdin pipe 				This option can only used by |--embed| ui, 				see |ui-startup-stdin|.--+	`term_ttyin`		Tells if `stdin` is a `tty` or not.","for parallel form with `stdin_fd` this could be named `stdin_tty` , `stdout_tty`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19360,922902832,2022-07-17T22:22:26Z,src/nvim/ex_getln.c,"@@ -194,6 +194,32 @@ typedef struct command_line_state {   long *b_im_ptr; } CommandLineState; +typedef struct cmdpreview_win_info {+  win_T *win;+  pos_T save_w_cursor;+  viewstate_T save_viewstate;+  int save_w_p_cul;+  int save_w_p_cuc;+} CpWinInfo;++typedef struct cmdpreview_buf_info {+  buf_T *buf;+  time_t save_b_u_time_cur;+  long save_b_u_seq_cur;+  u_header_T *save_b_u_newhead;+  long save_b_p_ul;+  int save_b_changed;+  varnumber_T save_changedtick;+} CpBufInfo;++typedef struct cmdpreview_info {+  kvec_t(CpWinInfo) win_info;+  kvec_t(CpBufInfo) buf_info;+  bool save_hls;+  cmdmod_T save_cmdmod;+  garray_T save_view;+} CpInfo;","Looks like these 3 new types were added but are only used in one self-contained function. That doesn't add meaningful structure, and it does add indirection. Indirection is a different cost. If the logic can stay in a single self-contained function that's a pretty strong advantage. I would suggest reverting these new types.If the single big function is ""unreadable"", just make sure the setup/teardown parts are clearly marked.Alternatively, a different approach would be to ask, what is cmdpreview-specific about saving/restoring bufinfo and wininfo? Looks like nothing really. You could look into `ctx_save` and `ctx_restore` and see if that would serve the purpose here, or think about how `ctx_save` / `ctx_restore` could be enhanced to serve the purpose here...",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19268,922939079,2022-07-18T02:35:38Z,src/nvim/ex_cmds.c,"@@ -1583,22 +1583,43 @@ char *make_filter_cmd(char *cmd, char *itmp, char *otmp)   if (otmp != NULL) {     len += STRLEN(otmp) + STRLEN(p_srr) + 2;  // two extra spaces (""  ""),   }++  const char *const cmd_args = strchr(cmd, ' ');+  len += (is_pwsh && cmd_args)+      ? STRLEN("" -ArgumentList "") + 2  // two extra quotes+      : 0;+   char *const buf = xmalloc(len); -#if defined(UNIX)-  // Put delimiters around the command (for concatenated commands) when-  // redirecting input and/or output.   if (is_pwsh) {     xstrlcpy(buf, ""Start-Process "", len);-    xstrlcat(buf, cmd, len);+    if (cmd_args == NULL) {+      xstrlcat(buf, cmd, len);+    } else {+      char *con = NULL;+      char *dupcmd = xstrdup(cmd);","I am duplicating `cmd` into `dupcmd` so that the original `cmd` isn't modified by strtok, because `cmd` is used later in L1649 (of my commit; L1636 in master).https://github.com/neovim/neovim/blob/1b462705d049fa0cf2bb99bae9112b84abea8d5a/src/nvim/ex_cmds.c#L1636",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19430,924444251,2022-07-19T12:32:34Z,cmake.deps/CMakeLists.txt,"@@ -132,6 +132,18 @@ if(CMAKE_OSX_ARCHITECTURES)   endforeach() endif() +# If the macOS deployment target is not set manually (via $MACOSX_DEPLOYMENT_TARGET),+# fall back to local system version. Needs to be done here and in top-level CMakeLists.txt.+if(CMAKE_SYSTEM_NAME STREQUAL ""Darwin"")+  if(NOT CMAKE_OSX_DEPLOYMENT_TARGET)",I get there when `$MACOSX_DEPLOYMENT_TARGET` is not set when calling `make`. CMake doesn't seem to have a fallback value for this variable (`CMAKE_OSX_DEPLOYMENT_TARGET`) in this case; instead it uses a (version specific) fallback lower down the chain if the variable is not set.,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/19419,924574182,2022-07-19T14:28:11Z,src/nvim/screen.c,"@@ -2196,7 +2198,7 @@ static int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool noc      has_decor = decor_redraw_line(buf, lnum - 1, &decor_state); -    providers_invoke_line(wp, providers, lnum - 1, &has_decor, &provider_err);+    providers_invoke_line(wp, providers, lnum - 1, &has_decor, &decor_spell, &provider_err);","My issue with this is that the `spell` option of the decoration provider says: ""This decoration provider handles spell checking on it's own"", and not ""I think that this window should be spell checked"".Maybe enabling the `spell` option for a decoration provider would make nvim listen to the return value of the decoration provider `on_win` telling wether _this window_ is spellchecked with _this decoration provider_.",X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19419,924586038,2022-07-19T14:38:16Z,src/nvim/screen.c,"@@ -2196,7 +2198,7 @@ static int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool noc      has_decor = decor_redraw_line(buf, lnum - 1, &decor_state); -    providers_invoke_line(wp, providers, lnum - 1, &has_decor, &provider_err);+    providers_invoke_line(wp, providers, lnum - 1, &has_decor, &decor_spell, &provider_err);","Sure, on the user side -- I was more wondering about the backend (skipping the spelling code in the decor provider if it's unwanted, independent of whether it's for legacy or treesitter highlighting).If this makes no sense in this context because I'm missing something fundamental, feel free to ignore me here.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19419,924597554,2022-07-19T14:47:59Z,src/nvim/screen.c,"@@ -2196,7 +2198,7 @@ static int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool noc      has_decor = decor_redraw_line(buf, lnum - 1, &decor_state); -    providers_invoke_line(wp, providers, lnum - 1, &has_decor, &provider_err);+    providers_invoke_line(wp, providers, lnum - 1, &has_decor, &decor_spell, &provider_err);","@clason : for context, the main reason we even need this option is to avoid this nasty hack: https://github.com/lewis6991/neovim/blob/45c20f32e24a9ed26093e9600402562b9a91377e/runtime/lua/vim/treesitter/spell.lua#L121-L128",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19419,924613648,2022-07-19T15:01:20Z,src/nvim/screen.c,"@@ -2196,7 +2198,7 @@ static int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool noc      has_decor = decor_redraw_line(buf, lnum - 1, &decor_state); -    providers_invoke_line(wp, providers, lnum - 1, &has_decor, &provider_err);+    providers_invoke_line(wp, providers, lnum - 1, &has_decor, &decor_spell, &provider_err);","> Sure, on the user side -- I was more wondering about the backend (skipping the spelling code in the decor provider if it's unwanted, independent of whether it's for legacy or treesitter highlighting).Ok sure. Pretty sure `set spell`/`set nospell` handles the brunt that, or it should. The extmark will still be there, it'll just be invisible and the spell checker won't run on it.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19432,925817465,2022-07-20T16:24:41Z,cmake/RunTests.cmake,"@@ -51,18 +40,13 @@ if(DEFINED ENV{TEST_FILTER_OUT} AND NOT ""$ENV{TEST_FILTER_OUT}"" STREQUAL """")   list(APPEND BUSTED_ARGS --filter-out $ENV{TEST_FILTER_OUT}) endif() -# TMPDIR: for helpers.tmpname() and Nvim tempname().-set(ENV{TMPDIR} ""${BUILD_DIR}/Xtest_tmpdir"")","that is now done in the `suite_setup()` hook, where it also makes sure that these folders existhttps://github.com/neovim/neovim/blob/92c50d41e1751dd274f27f46831fba3cd91b323a/test/helpers.lua#L885-L894",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19448,926110302,2022-07-20T22:41:55Z,src/nvim/CMakeLists.txt,"@@ -265,7 +283,7 @@ foreach(sfile ${NVIM_SOURCES}   get_preproc_output(PREPROC_OUTPUT ${gf_i})    set(depends ""${HEADER_GENERATOR}"" ""${sfile}"")-  if(""${f}"" STREQUAL ""version.c"")+  if(IS_INSIDE_GIT_TREE AND ""${f}"" STREQUAL ""version.c"")","why is this condition needed, it should be harmless if `NVIM_VERSION_GIT_H` is just a blank file or whatever.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19448,926361303,2022-07-21T07:47:33Z,src/nvim/CMakeLists.txt,"@@ -221,15 +221,33 @@ function(get_preproc_output varname iname)   endif() endfunction() -set(NVIM_VERSION_GIT_H ${PROJECT_BINARY_DIR}/cmake.config/auto/versiondef_git.h)+execute_process(+  COMMAND git rev-parse --is-inside-work-tree",">  Keep things simple and obvious.I agree this may not be too obvious, but we still need to cover the two separate cases either way> 2\. why can't this be done in `GenerateVersion.cmake`? Just generate an empty file or something.I wanted to avoid re-generating `versiondef_git.h` on every build for those specific workflows, but maybe that's not a big deal.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19448,926371392,2022-07-21T07:58:10Z,src/nvim/CMakeLists.txt,"@@ -221,15 +221,33 @@ function(get_preproc_output varname iname)   endif() endfunction() -set(NVIM_VERSION_GIT_H ${PROJECT_BINARY_DIR}/cmake.config/auto/versiondef_git.h)+execute_process(+  COMMAND git rev-parse --is-inside-work-tree+  OUTPUT_VARIABLE IS_INSIDE_GIT_TREE+  OUTPUT_STRIP_TRAILING_WHITESPACE+)++if(IS_INSIDE_GIT_TREE)+  set(NVIM_VERSION_GIT_H ${PROJECT_BINARY_DIR}/cmake.config/auto/versiondef_git.h)+else()+  set(NVIM_VERSION_MEDIUM+    ""v${NVIM_VERSION_MAJOR}.${NVIM_VERSION_MINOR}.${NVIM_VERSION_PATCH}${NVIM_VERSION_PRERELEASE}"")","good idea! can we rename `${NVIM_VERSION_MEDIUM}` to something more obvious, maybe `${NVIM_VERSION_TAG}`? unless I'm missing what ""medium"" stands for.> [Is ���v1.2.3��� a semantic version?](https://semver.org/#is-v123-a-semantic-version)> No, ���v1.2.3��� is not a semantic version. However, prefixing a semantic version with a ���v��� is a common way (in English) to indicate it is a version number. Abbreviating ���version��� as ���v��� is often seen with version control. Example: git tag v1.2.3 -m ""Release version 1.2.3"", in which case ���v1.2.3��� is a tag name and the semantic version is ���1.2.3���.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19448,926374615,2022-07-21T08:01:27Z,src/nvim/CMakeLists.txt,"@@ -265,7 +283,7 @@ foreach(sfile ${NVIM_SOURCES}   get_preproc_output(PREPROC_OUTPUT ${gf_i})    set(depends ""${HEADER_GENERATOR}"" ""${sfile}"")-  if(""${f}"" STREQUAL ""version.c"")+  if(IS_INSIDE_GIT_TREE AND ""${f}"" STREQUAL ""version.c"")","I wanted to avoid re-generating `versiondef_git.h` on every build for when (git is not available, or not a repo clone), and the easiest way was to basically drop it from being a dependency in those cases.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19448,927644107,2022-07-22T13:19:07Z,cmake/GenerateVersion.cmake,"@@ -19,30 +13,29 @@ execute_process(   RESULT_VARIABLE RES ) -if(""${RES}"" EQUAL 1)+if(NOT GIT_TAG)","This should check `RES`. `GIT_TAG` could be non-empty on some failures. There are numerous existing examples of this pattern in the codebase, why not use the same pattern?",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/19243,927717722,2022-07-22T14:37:58Z,runtime/doc/options.txt,"@@ -5918,6 +5918,21 @@ A jump table for the options with a short description can be found at |Q_op|. 	When on, splitting a window will put the new window right of the 	current one. |:vsplit| +			*'splitscroll'* *'spsc'* *'nosplitscroll'* *'nospsc'*+'splitscroll' 'spsc'	number	(default 0)+			global+	The value of this option influences the scroll behavior when opening","I would tend to agree but I tried to mimic the wording of other options, This preamble seems to be quite prevalent throughout:https://github.com/neovim/neovim/blob/b78e4139b2914ed0e35f7643461561683c8051b7/runtime/doc/options.txt#L3657-L3664Not trying to be difficult just thought I'd mention why I worded it as such. Let me know if you still want the change.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19483,928239644,2022-07-24T11:09:42Z,src/nvim/po/zh_CN.UTF-8.po,"@@ -401,11 +401,11 @@ msgstr ""������������������""  #: ../edit.c:101 msgid ""E839: Completion function changed window""-msgstr """"+msgstr ""E839: ������������������������""","```suggestionmsgstr ""E839: ���������������������������""```Actually this error message is no longer used.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19497,928906720,2022-07-25T13:48:40Z,test/functional/ex_cmds/mksession_spec.lua,"@@ -37,22 +37,107 @@ describe(':mksession', function()      -- Create three windows: first two from top show same terminal, third -     -- another one (created earlier).+    command('set sessionoptions+=terminal')     command('terminal')     command('split')     command('terminal')     command('split')-    command('mksession '..session_file)+    command('mksession ' .. session_file)     command('%bwipeout!')      -- Create a new test instance of Nvim.     clear()     -- Restore session.-    command('source '..session_file)+    command('source ' .. session_file)      eq(funcs.winbufnr(1), funcs.winbufnr(2))     neq(funcs.winbufnr(1), funcs.winbufnr(3))   end) +  it(+    'do not restore :terminal if not set in sessionoptions, terminal in current window #13078',+    function()+      command('set sessionoptions-=terminal')++      local tmpfile_base = file_prefix .. '-tmpfile'++      command('edit ' .. tmpfile_base .. '1')+      command('terminal')++      local buf_count = #meths.list_bufs()+      eq(2, buf_count)++      eq('terminal', meths.buf_get_option(0, 'buftype'))++      command('mksession ' .. session_file)+      command('%bwipeout!')++      -- Create a new test instance of Nvim.+      clear()++      -- Restore session.+      command('source ' .. session_file)++      -- no terminal should be set. As a side effect we end up with a blank buffer+      eq(2, #meths.list_bufs())+      eq('', meths.buf_get_option(meths.list_bufs()[1], 'buftype'))+      eq('', meths.buf_get_option(meths.list_bufs()[2], 'buftype'))+    end+  )++  it('do not restore :terminal if not set in sessionoptions, terminal hidden #13078', function()+    command('set sessionoptions-=terminal')",how much is different between these tests? any way to have a shared function to avoid lots of duplicate code?,X
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/19515,929972036,2022-07-26T13:34:06Z,cmake/GenerateVersion.cmake,"@@ -7,19 +7,8 @@ set(NVIM_VERSION_MEDIUM     ""v${NVIM_VERSION_MAJOR}.${NVIM_VERSION_MINOR}.${NVIM_VERSION_PATCH}${NVIM_VERSION_PRERELEASE}"")  execute_process(-  COMMAND git describe --first-parent --dirty-  OUTPUT_VARIABLE GIT_TAG-  ERROR_VARIABLE ERR-  RESULT_VARIABLE RES-)--if(NOT RES EQUAL 0)","The command can still fail if you're not building from a git clone (e.g., release tarball).",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19513,930027520,2022-07-26T14:20:23Z,src/nvim/api/command.c,"@@ -779,41 +770,41 @@ static void build_cmdline_str(char **cmdlinep, exarg_T *eap, CmdParseInfo *cmdin    // Keep the index of the position where command name starts, so eap->cmd can point to it.   size_t cmdname_idx = cmdline.size;-  kv_printf(cmdline, ""%s"", eap->cmd);+  kv_concat(cmdline, eap->cmd);    // Command bang.   if (eap->argt & EX_BANG && eap->forceit) {-    kv_printf(cmdline, ""!"");+    kv_concat(cmdline, ""!"");   }    // Command register.   if (eap->argt & EX_REGSTR && eap->regname) {     kv_printf(cmdline, "" %c"", eap->regname);   } -  // Iterate through each argument and store the starting index and length of each argument-  size_t *argidx = xcalloc(argc, sizeof(size_t));+  // As arguments are appended, use the command index and argument indices to set the+  // values of eap->cmd, eap->arg and eap->args.   eap->argc = argc;   eap->arglens = xcalloc(argc, sizeof(size_t));-  for (size_t i = 0; i < argc; i++) {-    argidx[i] = cmdline.size + 1;  // add 1 to account for the space.-    eap->arglens[i] = STRLEN(args[i]);-    kv_printf(cmdline, "" %s"", args[i]);-  }--  // Now that all the arguments are appended, use the command index and argument indices to set the-  // values of eap->cmd, eap->arg and eap->args.-  eap->cmd = cmdline.items + cmdname_idx;   eap->args = xcalloc(argc, sizeof(char *));+  eap->cmd = cmdline.items + cmdname_idx;+   for (size_t i = 0; i < argc; i++) {-    eap->args[i] = cmdline.items + argidx[i];+    String s = args.items[i].data.string;+    kv_concat(cmdline, "" "");+    eap->args[i] = cmdline.items + cmdline.size;","Yep, don't worry. Already running this through the santizer myself.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19513,930054243,2022-07-26T14:41:51Z,src/nvim/api/command.c,"@@ -779,41 +770,41 @@ static void build_cmdline_str(char **cmdlinep, exarg_T *eap, CmdParseInfo *cmdin    // Keep the index of the position where command name starts, so eap->cmd can point to it.   size_t cmdname_idx = cmdline.size;-  kv_printf(cmdline, ""%s"", eap->cmd);+  kv_concat(cmdline, eap->cmd);    // Command bang.   if (eap->argt & EX_BANG && eap->forceit) {-    kv_printf(cmdline, ""!"");+    kv_concat(cmdline, ""!"");   }    // Command register.   if (eap->argt & EX_REGSTR && eap->regname) {     kv_printf(cmdline, "" %c"", eap->regname);   } -  // Iterate through each argument and store the starting index and length of each argument-  size_t *argidx = xcalloc(argc, sizeof(size_t));+  // As arguments are appended, use the command index and argument indices to set the+  // values of eap->cmd, eap->arg and eap->args.   eap->argc = argc;   eap->arglens = xcalloc(argc, sizeof(size_t));-  for (size_t i = 0; i < argc; i++) {-    argidx[i] = cmdline.size + 1;  // add 1 to account for the space.-    eap->arglens[i] = STRLEN(args[i]);-    kv_printf(cmdline, "" %s"", args[i]);-  }--  // Now that all the arguments are appended, use the command index and argument indices to set the-  // values of eap->cmd, eap->arg and eap->args.-  eap->cmd = cmdline.items + cmdname_idx;   eap->args = xcalloc(argc, sizeof(char *));+  eap->cmd = cmdline.items + cmdname_idx;+   for (size_t i = 0; i < argc; i++) {-    eap->args[i] = cmdline.items + argidx[i];+    String s = args.items[i].data.string;+    kv_concat(cmdline, "" "");+    eap->args[i] = cmdline.items + cmdline.size;","```diffdiff --git a/src/nvim/api/command.c b/src/nvim/api/command.cindex 9b2447e72..b0cf21035 100644--- a/src/nvim/api/command.c+++ b/src/nvim/api/command.c@@ -787,19 +787,26 @@ static void build_cmdline_str(char **cmdlinep, exarg_T *eap, CmdParseInfo *cmdin   eap->argc = argc;   eap->arglens = xcalloc(argc, sizeof(size_t));   eap->args = xcalloc(argc, sizeof(char *));-  eap->cmd = cmdline.items + cmdname_idx; +  size_t offset = cmdline.size;   for (size_t i = 0; i < argc; i++) {     String s = args.items[i].data.string;     kv_concat(cmdline, "" "");-    eap->args[i] = cmdline.items + cmdline.size;-    eap->arglens[i] = s.size;     kv_concat_len(cmdline, s.data, s.size);   }    // Done appending to cmdline, ensure it is NUL terminated   kv_push(cmdline, NUL); +  eap->cmd = cmdline.items + cmdname_idx;+  for (size_t i = 0; i < argc; i++) {+    String s = args.items[i].data.string;+    offset++; // kv_concat(cmdline, "" "");+    eap->args[i] = cmdline.items + offset;+    eap->arglens[i] = s.size;+    offset += s.size; // kv_concat_len(cmdline, s.data, s.size);+  }+   // If there isn't an argument, make eap->arg point to end of cmdline.   eap->arg = argc > 0 ? eap->args[0] : cmdline.items + cmdline.size; ```",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19513,930071099,2022-07-26T14:55:27Z,src/nvim/api/command.c,"@@ -791,29 +782,36 @@ static void build_cmdline_str(char **cmdlinep, exarg_T *eap, CmdParseInfo *cmdin     kv_printf(cmdline, "" %c"", eap->regname);   } -  // Iterate through each argument and store the starting index and length of each argument-  size_t *argidx = xcalloc(argc, sizeof(size_t));   eap->argc = argc;   eap->arglens = xcalloc(argc, sizeof(size_t));+  size_t argstart_idx = cmdline.size;   for (size_t i = 0; i < argc; i++) {-    argidx[i] = cmdline.size + 1;  // add 1 to account for the space.-    eap->arglens[i] = STRLEN(args[i]);-    kv_printf(cmdline, "" %s"", args[i]);+    String s = args.items[i].data.string;+    eap->arglens[i] = s.size;+    kv_concat(cmdline, "" "");+    kv_concat_len(cmdline, s.data, s.size);+  }++  // Done appending to cmdline, ensure it is NUL terminated+  if (argc > 0) {+    kv_push(cmdline, NUL);","It might be because here null is not always written, while it should be done unconditionally?",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19513,930150085,2022-07-26T16:02:07Z,src/nvim/api/command.c,"@@ -779,41 +770,46 @@ static void build_cmdline_str(char **cmdlinep, exarg_T *eap, CmdParseInfo *cmdin    // Keep the index of the position where command name starts, so eap->cmd can point to it.   size_t cmdname_idx = cmdline.size;-  kv_printf(cmdline, ""%s"", eap->cmd);+  kv_concat(cmdline, eap->cmd);    // Command bang.   if (eap->argt & EX_BANG && eap->forceit) {-    kv_printf(cmdline, ""!"");+    kv_concat(cmdline, ""!"");   }    // Command register.   if (eap->argt & EX_REGSTR && eap->regname) {     kv_printf(cmdline, "" %c"", eap->regname);   } -  // Iterate through each argument and store the starting index and length of each argument-  size_t *argidx = xcalloc(argc, sizeof(size_t));   eap->argc = argc;   eap->arglens = xcalloc(argc, sizeof(size_t));+  size_t argstart_idx = cmdline.size;   for (size_t i = 0; i < argc; i++) {-    argidx[i] = cmdline.size + 1;  // add 1 to account for the space.-    eap->arglens[i] = STRLEN(args[i]);-    kv_printf(cmdline, "" %s"", args[i]);+    String s = args.items[i].data.string;+    eap->arglens[i] = s.size;+    kv_concat(cmdline, "" "");+    kv_concat_len(cmdline, s.data, s.size);   } +  // Done appending to cmdline, ensure it is NUL terminated+  kv_printf(cmdline, """");+   // Now that all the arguments are appended, use the command index and argument indices to set the   // values of eap->cmd, eap->arg and eap->args.   eap->cmd = cmdline.items + cmdname_idx;   eap->args = xcalloc(argc, sizeof(char *));+  size_t offset = argstart_idx;   for (size_t i = 0; i < argc; i++) {-    eap->args[i] = cmdline.items + argidx[i];+    offset++;  // Account for space+    eap->args[i] = cmdline.items + offset;+    offset += eap->arglens[i];   }   // If there isn't an argument, make eap->arg point to end of cmdline.   eap->arg = argc > 0 ? eap->args[0] : cmdline.items + cmdline.size;","Also now because of that `kv_push(cmdline, NUL)` should be done unconditionally.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19533,931048790,2022-07-27T13:15:09Z,src/nvim/syntax.c,"@@ -430,7 +430,7 @@ void syntax_start(win_T *wp, linenr_T lnum)     } else {       // Need to parse ""minlines"" lines before state can be considered       // valid to store.-      first_stored = current_lnum + syn_block->b_syn_sync_minlines;+      first_stored = current_lnum + (linenr_T)syn_block->b_syn_sync_minlines;",Will it make more sense to change the three `long`s in `synblock_T` to `int32_t`?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19534,931079170,2022-07-27T13:41:52Z,runtime/lua/vim/uri.lua,"@@ -59,8 +59,12 @@ end  --- Get a URI from a file path. ---@param path string Path to file+---@param force_valid boolean Force valid absolute paths ---@return string URI-local function uri_from_fname(path)+local function uri_from_fname(path, force_valid)","an opt-in parameter like this means the caller needs to be aware of it anyways, which means it doesn't gain much vs forcing the caller to pass a full path.Long-term it doesn't matter I guess because we probably need a `Uri` type.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19521,931080909,2022-07-27T13:43:24Z,src/nvim/regexp.c,"@@ -2558,15 +2558,14 @@ long vim_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum,   }   rex_in_use = true; -  int result = rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col,-                                                   tm, timed_out);+  int result = (int)rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col, tm, timed_out);","It may make more sense to make this `result` a `long`, as the declaration is already in the middle.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19545,931225527,2022-07-27T15:45:45Z,runtime/lua/vim/filetype.lua,"@@ -1559,6 +1557,8 @@ local filename = {   ['sshd_config'] = 'sshdconfig',   ['/etc/sudoers'] = 'sudoers',   ['sudoers.tmp'] = 'sudoers',+  ['/sway/config'] = 'swayconfig',+  ['/.sway/config'] = 'swayconfig',","I think these should be removed, `/sway/config` and `/.sway/config` are not realistic absolute file paths (even though they *technically* match the pattern in `filetype.vim`). Same for the `i3` ones too.The entries in the pattern section need to be updated too.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19538,931310133,2022-07-27T17:12:42Z,src/nvim/spell.c,"@@ -137,7 +137,7 @@ slang_T *first_lang = NULL; char_u *int_wordlist = NULL;  typedef struct wordcount_S {-  uint16_t wc_count;                // nr of times word was seen+  int wc_count;                     // nr of times word was seen","maybe just `(wc->wc_count += (uint16_t)count)` ? No problem if that truncates the value, the if condition is checking for that as well.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19558,932313256,2022-07-28T14:41:27Z,runtime/doc/lsp.txt,"@@ -1197,32 +1197,33 @@ format({options})                                       *vim.lsp.buf.format()*                                ��� formatting_options (table|nil): Can be used                                  to specify FormattingOptions. Some                                  unspecified options will be automatically-                                 derived from the current Neovim options.--                See also: ~-                    https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting-                    ��� timeout_ms (integer|nil, default 1000): Time in-                      milliseconds to block for formatting requests. No effect-                      if async=true-                    ��� bufnr (number|nil): Restrict formatting to the clients-                      attached to the given buffer, defaults to the current-                      buffer (0).-                    ��� filter (function|nil): Predicate used to filter clients.-                      Receives a client as argument and must return a boolean.-                      Clients matching the predicate are included. Example:    ��� >+                                 derived from the current Neovim options. See https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#formattingOptions","no. If  URL is really long, putting it on its own line doesn't change much anyway...",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19533,932797292,2022-07-29T01:37:20Z,src/nvim/syntax.c,"@@ -2916,9 +2914,8 @@ static int syn_regexec(regmmatch_T *rmp, linenr_T lnum, colnr_T col, syn_time_T     return false;   } -  rmp->rmm_maxcol = syn_buf->b_p_smc;-  r = vim_regexec_multi(rmp, syn_win, syn_buf, lnum, col,-                        syn_tm, &timed_out);+  rmp->rmm_maxcol = (colnr_T)syn_buf->b_p_smc;+  int r = (int)vim_regexec_multi(rmp, syn_win, syn_buf, lnum, col, syn_tm, &timed_out);","```suggestion  long r = vim_regexec_multi(rmp, syn_win, syn_buf, lnum, col, syn_tm, &timed_out);```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19538,933644374,2022-07-29T22:09:28Z,src/nvim/spell.c,"@@ -3821,13 +3815,13 @@ static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool so       if (sp->ts_prefixdepth == PFD_PREFIXTREE) {         // Skip over the NUL bytes, we use them later.         for (n = 0; n < len && byts[arridx + n] == 0; n++) {}-        sp->ts_curi += n;+        sp->ts_curi = (int16_t)(sp->ts_curi + n);",I guess casting `n` to `int16_t` should be fine. If `n` is too large for `int16_t` the result is unexpected anyway.```suggestion        sp->ts_curi += (int16_t)n;```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19524,933666507,2022-07-29T22:51:42Z,src/nvim/screen.c,"@@ -798,7 +798,7 @@ static void win_update(win_T *wp, DecorProviders *providers)         /* Need to redraw lines above the change that may be included          * in a pattern match. */         if (syntax_present(wp)) {-          mod_top -= buf->b_s.b_syn_sync_linebreaks;+          mod_top -= (linenr_T)buf->b_s.b_syn_sync_linebreaks;",This cast is no longer needed```suggestion          mod_top -= buf->b_s.b_syn_sync_linebreaks;```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19590,933968113,2022-07-31T11:03:49Z,src/nvim/mbyte.c,"@@ -1840,7 +1840,7 @@ int mb_off_next(const char_u *base, const char_u *p) /// Return the offset from ""p"" to the last byte of the character it points /// into.  Can start anywhere in a stream of bytes. /// Composing characters are not included.","```suggestion/// Return the offset from `p_in` to the last byte of the codepoint it points/// to.  Can start anywhere in a stream of bytes./// Note: Unlike `utf_tail_off`, counts individual codepoints of composed characters /// separately.```(and similarly for `utf_cp_head_off`, which I can't comment on).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19598,934452152,2022-08-01T12:04:38Z,src/nvim/mapping.c,"@@ -2396,10 +2407,16 @@ void modify_keymap(uint64_t channel_id, Buffer buffer, bool is_unmap, String mod     KEY_TO_BOOL(script);     KEY_TO_BOOL(expr);     KEY_TO_BOOL(unique);+    KEY_TO_BOOL(replace_keycodes); #undef KEY_TO_BOOL   }   parsed_args.buffer = !global; +  if (parsed_args.replace_keycodes && !parsed_args.expr) {+    api_set_error(err, kErrorTypeValidation,  ""\""replace_keycodes\"" requires \""expr\"""");","Error is usually a good idea, espcially if it can be done trivially as it is here. The exception is when there's a common expected use-case where it's convenient for callers.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19598,934466617,2022-08-01T12:22:30Z,src/nvim/mapping.c,"@@ -2396,10 +2407,16 @@ void modify_keymap(uint64_t channel_id, Buffer buffer, bool is_unmap, String mod     KEY_TO_BOOL(script);     KEY_TO_BOOL(expr);     KEY_TO_BOOL(unique);+    KEY_TO_BOOL(replace_keycodes); #undef KEY_TO_BOOL   }   parsed_args.buffer = !global; +  if (parsed_args.replace_keycodes && !parsed_args.expr) {+    api_set_error(err, kErrorTypeValidation,  ""\""replace_keycodes\"" requires \""expr\"""");","I mean maybe not ignored, but it's useless without the callback, isn't it?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19598,934486344,2022-08-01T12:45:31Z,src/nvim/mapping.c,"@@ -2396,10 +2407,16 @@ void modify_keymap(uint64_t channel_id, Buffer buffer, bool is_unmap, String mod     KEY_TO_BOOL(script);     KEY_TO_BOOL(expr);     KEY_TO_BOOL(unique);+    KEY_TO_BOOL(replace_keycodes); #undef KEY_TO_BOOL   }   parsed_args.buffer = !global; +  if (parsed_args.replace_keycodes && !parsed_args.expr) {+    api_set_error(err, kErrorTypeValidation,  ""\""replace_keycodes\"" requires \""expr\"""");",Why useless? It is shown in `:map`.,
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19598,934488538,2022-08-01T12:47:59Z,src/nvim/mapping.c,"@@ -2396,10 +2407,16 @@ void modify_keymap(uint64_t channel_id, Buffer buffer, bool is_unmap, String mod     KEY_TO_BOOL(script);     KEY_TO_BOOL(expr);     KEY_TO_BOOL(unique);+    KEY_TO_BOOL(replace_keycodes); #undef KEY_TO_BOOL   }   parsed_args.buffer = !global; +  if (parsed_args.replace_keycodes && !parsed_args.expr) {+    api_set_error(err, kErrorTypeValidation,  ""\""replace_keycodes\"" requires \""expr\"""");","I didn't notice that :) My bad then, I thought it was only supposed to describe lua functions, because you couldn't print the function source like you can with vim script.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19488,934502849,2022-08-01T13:01:37Z,cmake/Format.cmake,"@@ -0,0 +1,67 @@+# Returns a list of all files that has been changed in current branch compared+# to master branch. This includes unstaged, staged and committed files.+function(get_changed_files outvar)+  set(default_branch master)++  execute_process(+    COMMAND git branch --show-current+    OUTPUT_VARIABLE current_branch+    OUTPUT_STRIP_TRAILING_WHITESPACE)++  execute_process(+    COMMAND git merge-base ${default_branch} ${current_branch}+    OUTPUT_VARIABLE ancestor_commit+    OUTPUT_STRIP_TRAILING_WHITESPACE)++  # Changed files that have been committed+  execute_process(+    COMMAND git diff --name-only ${ancestor_commit}...${current_branch}+    OUTPUT_VARIABLE committed_files+    OUTPUT_STRIP_TRAILING_WHITESPACE)+  separate_arguments(committed_files NATIVE_COMMAND ${committed_files})++  # Unstaged files+  execute_process(+    COMMAND git diff --name-only+    OUTPUT_VARIABLE unstaged_files+    OUTPUT_STRIP_TRAILING_WHITESPACE)+  separate_arguments(unstaged_files NATIVE_COMMAND ${unstaged_files})++  # Staged files+  execute_process(+    COMMAND git diff --cached --name-only+    OUTPUT_VARIABLE staged_files+    OUTPUT_STRIP_TRAILING_WHITESPACE)+  separate_arguments(staged_files NATIVE_COMMAND ${staged_files})++  set(files ${committed_files} ${unstaged_files} ${staged_files})+  list(REMOVE_DUPLICATES files)++  set(${outvar} ""${files}"" PARENT_SCOPE)+endfunction()++get_changed_files(changed_files)++if(LANG STREQUAL c)","Similar to the discussion for the lint targets, I'd suggest that Format.cmake just takes a list of files instead of putting a switch-case in here for all possible targets. But passing files is unpleasant with `-P`, so I guess that's the tradeoff. Do we need `-P` though?Not a blocker anyways.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19598,934527348,2022-08-01T13:26:53Z,runtime/lua/vim/keymap.lua,"@@ -60,22 +59,9 @@ function keymap.set(mode, lhs, rhs, opts)   local is_rhs_luaref = type(rhs) == 'function'   mode = type(mode) == 'string' and { mode } or mode -  if is_rhs_luaref and opts.expr then-    local user_rhs = rhs-    rhs = function()-      local res = user_rhs()-      if res == nil then-        -- TODO(lewis6991): Handle this in C?-        return ''","I tried to understand why this is there, but I couldn't really tell the difference? I see now that Lewis mentions that it used to throw an error, but this seems to no longer be the case. Is it possible that something changed in the implementation and this is no longer relevant?I could do something like this, but it would be nice to explain in the comment why is it here:```lua  if (p == NULL) {    return mp->m_replace_keycodes ? (char_u *)xstrdup("""") : NULL;  }```",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19597,934665147,2022-08-01T15:35:57Z,src/nvim/lua/executor.c,"@@ -2076,3 +2076,34 @@ int nlua_do_ucmd(ucmd_T *cmd, exarg_T *eap, bool preview)    return retv; }++/// String representation of a Lua function reference+///+/// @return Allocated string+char *nlua_funcref_str(LuaRef ref)+{+  lua_State *const lstate = global_lstate;+  StringBuilder str = KV_INITIAL_VALUE;+  kv_resize(str, 16);++  if (!lua_checkstack(lstate, 1)) {+    goto plain;+  }+  nlua_pushref(lstate, ref);+  if (!lua_isfunction(lstate, -1)) {+    lua_pop(lstate, 1);+    goto plain;+  }++  lua_Debug ar;","To answer my own question, the implementation of `lua_getinfo` in LuaJIT appears to me that it is quite lean: https://github.com/LuaJIT/LuaJIT/blob/7306ba78d62b55a64f25231df1d5697345a5572e/src/lj_debug.c#L429",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19597,934723631,2022-08-01T16:42:17Z,src/nvim/lua/executor.c,"@@ -2076,3 +2076,34 @@ int nlua_do_ucmd(ucmd_T *cmd, exarg_T *eap, bool preview)    return retv; }++/// String representation of a Lua function reference+///+/// @return Allocated string+char *nlua_funcref_str(LuaRef ref)+{+  lua_State *const lstate = global_lstate;+  StringBuilder str = KV_INITIAL_VALUE;+  kv_resize(str, 16);++  if (!lua_checkstack(lstate, 1)) {+    goto plain;+  }+  nlua_pushref(lstate, ref);+  if (!lua_isfunction(lstate, -1)) {+    lua_pop(lstate, 1);+    goto plain;+  }++  lua_Debug ar;","Now the string representation for commands is rendered when you print them, it will no longer impact the performance of defining commands.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19615,934900518,2022-08-01T20:36:54Z,SUPPORTED_PLATFORMS.md,"@@ -0,0 +1,46 @@+# Supported platforms++|  System | Support type | Supported versions | Notes |+|---|---|---|---|+| Linux | Tier 1 | Linux >= 2.6.32 with glibc >= 2.12 | |+| macOS | Tier 1 | macOS >= 10.15 | Current and previous macOS release |","We dropped 10.15 from CI, so it's no longer Tier 1.We should also distinguish Intel and M1.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19615,934904814,2022-08-01T20:43:21Z,SUPPORTED_PLATFORMS.md,"@@ -0,0 +1,46 @@+# Supported platforms++|  System | Support type | Supported versions | Notes |+|---|---|---|---|+| Linux | Tier 1 | Linux >= 2.6.32 with glibc >= 2.12 | |+| macOS | Tier 1 | macOS >= 10.15 | Current and previous macOS release |+| Windows | Tier 1 | >= Windows 8 | VS 2015 and later are supported |+| FreeBSD | Tier 1 | >= 10 | |",Not sure what the minimum version for openbsd is since libuv hasn't listed it either. An empty value or an N/A is good enough for now perhaps?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19622,935464408,2022-08-02T11:38:54Z,src/nvim/eval/funcs.c,"@@ -8168,6 +8168,17 @@ static void f_setcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)   } } +/// ""setcmdline()"" function+static void f_setcmdline(typval_T *argvars, typval_T *rettv, FunPtr fptr)","let's take cmdpos as an optional second parameter (`setcmdpos()` will not work, it needs to be changed directly in `set_cmdline_str`)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19622,935467535,2022-08-02T11:41:40Z,src/nvim/ex_getln.c,"@@ -6250,6 +6250,58 @@ int get_cmdline_screen_pos(void)   return p->cmdspos; } +// Set the command line str to ""str"".+// Returns 1 when failed, 0 when OK.+int set_cmdline_str(const char *str)+{+  struct cmdline_info *p = get_ccline_ptr();++  if (p == NULL) {+    return 1;+  }++  int len = (int)STRLEN(str);+  realloc_cmdbuff(len + 1);+  p->cmdlen = len;+  STRCPY(p->cmdbuff, str);++  p->cmdpos = p->cmdlen;+  new_cmdpos = p->cmdpos;++  redrawcmd();++  // Trigger CmdlineChanged autocommands.+  if (has_event(EVENT_CMDLINECHANGED)) {+    TryState tstate;+    Error err = ERROR_INIT;+    save_v_event_T save_v_event;+    dict_T *dict = get_v_event(&save_v_event);++    char firstcbuf[2];+    firstcbuf[0] = (char)ccline.cmdfirstc;+    firstcbuf[1] = 0;++    // set v:event to a dictionary with information about the commandline+    tv_dict_add_str(dict, S_LEN(""cmdtype""), firstcbuf);+    tv_dict_add_nr(dict, S_LEN(""cmdlevel""), ccline.level);+    tv_dict_set_keys_readonly(dict);+    try_enter(&tstate);++    apply_autocmds(EVENT_CMDLINECHANGED, firstcbuf, firstcbuf, false, curbuf);+    restore_v_event(dict, &save_v_event);++    bool tl_ret = try_leave(&tstate, &err);+    if (!tl_ret && ERROR_SET(&err)) {+      msg_putchar('\n');+      msg_printf_attr(HL_ATTR(HLF_E)|MSG_HIST, (char *)e_autocmd_err, err.msg);+      api_clear_error(&err);+      redrawcmd();+    }+  }","this is quite a bit of duplicated code, could break out to a `trigger_cmdlinechanged_event` helper function",X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19603,935683273,2022-08-02T14:41:15Z,src/nvim/quickfix.c,"@@ -1754,16 +1712,14 @@ static void ll_free_all(qf_info_T **pqi) /// Free all the quickfix/location lists in the stack. void qf_free_all(win_T *wp) {-  int i;-  qf_info_T *qi = &ql_info;-   if (wp != NULL) {     // location list     ll_free_all(&wp->w_llist);     ll_free_all(&wp->w_llist_ref);   } else {+    qf_info_T *qi = &ql_info;     // quickfix list",```suggestion    // quickfix list    qf_info_T *qi = &ql_info;```,
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19632,937434419,2022-08-04T07:21:04Z,cmake/FindLibUV.cmake,"@@ -13,7 +13,7 @@ endif() find_path(LIBUV_INCLUDE_DIR uv.h   HINTS ${PC_LIBUV_INCLUDEDIR} ${PC_LIBUV_INCLUDE_DIRS}) -list(APPEND LIBUV_NAMES uv)+list(APPEND LIBUV_NAMES uv libuv)",```suggestionlist(APPEND LIBUV_NAMES uv uv_a)```Maybe?,
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19632,937450316,2022-08-04T07:39:06Z,cmake.deps/cmake/BuildLibuv.cmake,"@@ -1,77 +1,15 @@-# BuildLibuv(TARGET targetname CONFIGURE_COMMAND ... BUILD_COMMAND ... INSTALL_COMMAND ...)-# Reusable function to build libuv, wraps ExternalProject_Add.-# Failing to pass a command argument will result in no command being run-function(BuildLibuv)-  cmake_parse_arguments(_libuv-    ""BUILD_IN_SOURCE""-    ""TARGET""-    ""PATCH_COMMAND;CONFIGURE_COMMAND;BUILD_COMMAND;INSTALL_COMMAND""-    ${ARGN})--  if(NOT _libuv_CONFIGURE_COMMAND AND NOT _libuv_BUILD_COMMAND-        AND NOT _libuv_INSTALL_COMMAND)-    message(FATAL_ERROR ""Must pass at least one of CONFIGURE_COMMAND, BUILD_COMMAND, INSTALL_COMMAND"")-  endif()-  if(NOT _libuv_TARGET)-    set(_libuv_TARGET ""libuv"")-  endif()--  ExternalProject_Add(${_libuv_TARGET}-    PREFIX ${DEPS_BUILD_DIR}-    URL ${LIBUV_URL}-    DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/libuv-    DOWNLOAD_COMMAND ${CMAKE_COMMAND}-      -DPREFIX=${DEPS_BUILD_DIR}-      -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/libuv-      -DURL=${LIBUV_URL}-      -DEXPECTED_SHA256=${LIBUV_SHA256}-      -DTARGET=${_libuv_TARGET}-      -DUSE_EXISTING_SRC_DIR=${USE_EXISTING_SRC_DIR}-      -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake-    PATCH_COMMAND ""${_libuv_PATCH_COMMAND}""-    BUILD_IN_SOURCE ${_libuv_BUILD_IN_SOURCE}-    CONFIGURE_COMMAND ""${_libuv_CONFIGURE_COMMAND}""-    BUILD_COMMAND ""${_libuv_BUILD_COMMAND}""-    INSTALL_COMMAND ""${_libuv_INSTALL_COMMAND}"")-endfunction()--set(UNIX_CFGCMD sh ${DEPS_BUILD_DIR}/src/libuv/autogen.sh &&-  ${DEPS_BUILD_DIR}/src/libuv/configure --with-pic --disable-shared-  --prefix=${DEPS_INSTALL_DIR} --libdir=${DEPS_INSTALL_DIR}/lib-  CC=${DEPS_C_COMPILER})--if(UNIX)-  BuildLibuv(-    CONFIGURE_COMMAND ${UNIX_CFGCMD} MAKE=${MAKE_PRG}-    INSTALL_COMMAND ${MAKE_PRG} V=1 install)--elseif(WIN32)--  set(UV_OUTPUT_DIR ${DEPS_BUILD_DIR}/src/libuv/${CMAKE_BUILD_TYPE})-  if(MSVC)-    set(BUILD_SHARED ON)-  elseif(MINGW)-    set(BUILD_SHARED OFF)-  else()-    message(FATAL_ERROR ""Trying to build libuv in an unsupported system ${CMAKE_SYSTEM_NAME}/${CMAKE_C_COMPILER_ID}"")-  endif()-  BuildLibUv(BUILD_IN_SOURCE-    CONFIGURE_COMMAND ${CMAKE_COMMAND} -E copy-        ${CMAKE_CURRENT_SOURCE_DIR}/cmake/LibuvCMakeLists.txt-        ${DEPS_BUILD_DIR}/src/libuv/CMakeLists.txt-      COMMAND ${CMAKE_COMMAND} ${DEPS_BUILD_DIR}/src/libuv/CMakeLists.txt-        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}-        -DCMAKE_GENERATOR=${CMAKE_GENERATOR}-        -DCMAKE_GENERATOR_PLATFORM=${CMAKE_GENERATOR_PLATFORM}-        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}-        -DBUILD_SHARED_LIBS=${BUILD_SHARED}-        -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR}-    PATCH_COMMAND ${LIBUV_PATCH_COMMAND}-    BUILD_COMMAND ${CMAKE_COMMAND} --build . --config ${CMAKE_BUILD_TYPE}-    INSTALL_COMMAND ${CMAKE_COMMAND} --build . --target install --config ${CMAKE_BUILD_TYPE})--else()-  message(FATAL_ERROR ""Trying to build libuv in an unsupported system ${CMAKE_SYSTEM_NAME}/${CMAKE_C_COMPILER_ID}"")-endif()+ExternalProject_Add(libuv+  PREFIX ${DEPS_BUILD_DIR}+  URL ${LIBUV_URL}+  CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR} -DBUILD_TESTING=OFF",```suggestion  CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR} -DBUILD_TESTING=OFF -DCMAKE_POSITION_INDEPENDENT_CODE=ON```You need this to replicate the `--with-pic` flag you used to pass to `configure`.Also fixes```/usr/bin/ld: /home/runner/nvim-deps/usr/lib/libuv_a.a(core.c.o): relocation R_X86_64_PC32 against symbol `environ@@GLIBC_2.2.5' can not be used when making a shared object; recompile with -fPIC/usr/bin/ld: final link failed: bad valuecollect2: error: ld returned 1 exit status```https://github.com/neovim/neovim/runs/7667248317?check_suite_focus=true#step:11:896,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19632,937891489,2022-08-04T14:51:59Z,cmake.deps/cmake/BuildLuarocks.cmake,"@@ -192,7 +192,16 @@ if(USE_BUNDLED_BUSTED)   # luv   set(LUV_DEPS luacheck)   if(USE_BUNDLED_LUV)-    list(APPEND LUV_DEPS luv-static lua-compat-5.3)++    # HACK: the luv rockspec requires libuv.a or libuv.so+    add_custom_target(link-libuv+      COMMAND ${CMAKE_COMMAND} -E create_symlink+        ${DEPS_INSTALL_DIR}/lib/libuv_a.a+        ${DEPS_INSTALL_DIR}/lib/libuv.a",This works ok for unix. The issue is the library has a different path for windows.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/13883,939632980,2022-08-07T08:59:27Z,src/nvim/eval/funcs.c,"@@ -8132,6 +8132,156 @@ static void set_position(typval_T *argvars, typval_T *rettv, bool charpos)   } } +static int tv_nr_compare(const void *a1, const void *a2)+{+  listitem_T *li1 = *(listitem_T **)a1;+  listitem_T *li2 = *(listitem_T **)a2;++  return (int)(li1->li_tv.vval.v_number - li2->li_tv.vval.v_number);+}++extern cw_interval_T *cw_table;+extern size_t cw_table_size;++/// ""setcellwidths()"" function+static void f_setcellwidths(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  list_T *l;+  listitem_T *li;+  int item;+  int i;+  listitem_T **ptrs;+  cw_interval_T *table;+  cw_interval_T *cw_table_save;+  size_t cw_table_size_save;+  char *error = NULL;++  if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL) {+    emsg(_(e_listreq));+    return;+  }+  l = argvars[0].vval.v_list;+  if (l->lv_len == 0) {+    // Clearing the table.+    xfree(cw_table);+    cw_table = NULL;+    cw_table_size = 0;+    return;+  }++  ptrs = xmalloc((unsigned long)l->lv_len * sizeof(listitem_T *));+  if (ptrs == NULL) {+    return;+  }++  // Check that all entries are a list with three numbers, the range is+  // valid and the cell width is valid.+  item = 0;+  for (li = l->lv_first; li != NULL; li = li->li_next) {+    listitem_T *lili;+    varnumber_T n1;++    if (li->li_tv.v_type != VAR_LIST || li->li_tv.vval.v_list == NULL) {+      semsg(_(""E1109: List item %d is not a List""), item);+      xfree(ptrs);+      return;+    }+    lili = li->li_tv.vval.v_list->lv_first;+    ptrs[item] = lili;+    for (i = 0; lili != NULL; lili = lili->li_next, ++i) {+      if (lili->li_tv.v_type != VAR_NUMBER) {+        break;+      }+      if (i == 0) {+        n1 = lili->li_tv.vval.v_number;+        if (n1 < 0x100) {+          semsg(_(""E1114: Only values of 0x100 and higher supported""));+          xfree(ptrs);+          return;+        }+      } else if (i == 1 && lili->li_tv.vval.v_number < n1) {+        semsg(_(""E1111: List item %d range invalid""), item);+        xfree(ptrs);+        return;+      } else if (i == 2 && (lili->li_tv.vval.v_number < 1+                            || lili->li_tv.vval.v_number > 2)) {+        semsg(_(""E1112: List item %d cell width invalid""), item);+        xfree(ptrs);+        return;+      }+    }+    if (i != 3) {+      semsg(_(""E1110: List item %d does not contain 3 numbers""), item);+      xfree(ptrs);+      return;+    }+    ++item;+  }++  // Sort the list on the first number.+  qsort((void *)ptrs, (size_t)l->lv_len, sizeof(listitem_T *), tv_nr_compare);++  table = xmalloc((unsigned long)l->lv_len * sizeof(cw_interval_T));+  if (table == NULL) {+    xfree(ptrs);+    return;+  }++  // Store the items in the new table.+  item = 0;+  for (item = 0; item < l->lv_len; ++item) {+    listitem_T *lili = ptrs[item];+    varnumber_T n1;++    n1 = lili->li_tv.vval.v_number;+    if (item > 0 && n1 <= table[item - 1].last) {+      semsg(_(""E1113: Overlapping ranges for 0x%llx""), (long long)n1);+      xfree(ptrs);+      xfree(table);+      return;+    }+    table[item].first = n1;+    lili = lili->li_next;+    table[item].last = lili->li_tv.vval.v_number;+    lili = lili->li_next;+    table[item].width = (char)lili->li_tv.vval.v_number;+  }++  xfree(ptrs);++  cw_table_save = cw_table;+  cw_table_size_save = cw_table_size;+  cw_table = table;+  cw_table_size = (size_t)l->lv_len;++  // Check that the new value does not conflict with 'fillchars' or 'listchars'.+  if (set_chars_option(curwin, &p_fcs, false) != NULL) {+    error = ""E835: Conflicts with value of 'fillchars'"";+  } else if (set_chars_option(curwin, &p_lcs, false) != NULL) {+    error = ""E835: Conflicts with value of 'listchars'"";","```suggestion    error = ""E834: Conflicts with value of 'listchars'"";```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19663,939651879,2022-08-07T11:31:20Z,runtime/doc/help.txt,"@@ -185,6 +185,7 @@ Other ~ |channel.txt|		Nvim asynchronous IO |dev_style.txt|		Nvim style guide |job_control.txt|	Spawn and control multiple processes+|luarefvim.txt|		Lua reference manual","I'd use just `luaref.txt` (or `luarefman.txt` or `luareference.txt`, for disambiguation) -- the `vim` part is slightly misleading since the documentation is _not_ Vim-related (only the format is).",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19686,941001802,2022-08-09T07:35:33Z,src/nvim/tui/tui.c,"@@ -875,6 +875,53 @@ static void cursor_goto(UI *ui, int row, int col)   ugrid_goto(grid, row, col); } +static void print_spaces(UI *ui, int width)+{+  TUIData *data = ui->data;+  UGrid *grid = &data->grid;++  out(ui, data->space_buf, (size_t)width);+  grid->col += width;+  if (data->immediate_wrap_after_last_column) {+    // Printing at the right margin immediately advances the cursor.+    final_column_wrap(ui);+  }+}++/// Move cursor to the position given by `row` and `col` and print the character in `cell`.+/// This allows the grid to assume wider ambiguous-width characters than the host terminal.+///+/// @param is_doublewidth  whether the character is double-width on the grid.+///                        If true and the character is ambiguous-width, clear two cells.+static void print_cell_at_pos(UI *ui, int row, int col, UCell *cell, bool is_doublewidth)+{+  TUIData *data = ui->data;+  UGrid *grid = &data->grid;++  if (grid->row == -1 && cell->data[0] == NUL) {+    // If cursor needs to repositioned and there is nothing to print, don't move cursor.+    return;+  }++  cursor_goto(ui, row, col);++  bool is_ambiwidth = utf_ambiguous_width(utf_ptr2char(cell->data));+  if (is_ambiwidth && is_doublewidth) {+    // Clear the two screen cells.+    // If the character is single-width in the host terminal it won't change the second cell.+    update_attrs(ui, cell->attr);+    print_spaces(ui, 2);+    cursor_goto(ui, row, col);+  }++  print_cell(ui, cell);++  if (is_ambiwidth) {","Not sure if I should add a ` && is_doublewidth` check here.- If I do not add a ` && is_doublewidth` check here, this matches Vim's behavior better, and also makes cursor position correct on a line with emoji modifiers (ref #7151), but performance is possibly not ideal.- If I add a ` && is_doublewidth` check here, cursor position is still broken on a line with emoji modifiers, but performance is better.However, I think it isn't common for there to be a lot of ambiguous-width characters in a buffer, and window separators (whose defaults are ambiguous-width) aren't redrawn very often, so performance is likely not a great concern here.",
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/19632,941527766,2022-08-09T16:00:20Z,cmake.deps/cmake/BuildLibuv.cmake,"@@ -1,77 +1,25 @@-# BuildLibuv(TARGET targetname CONFIGURE_COMMAND ... BUILD_COMMAND ... INSTALL_COMMAND ...)-# Reusable function to build libuv, wraps ExternalProject_Add.-# Failing to pass a command argument will result in no command being run-function(BuildLibuv)-  cmake_parse_arguments(_libuv-    ""BUILD_IN_SOURCE""-    ""TARGET""-    ""PATCH_COMMAND;CONFIGURE_COMMAND;BUILD_COMMAND;INSTALL_COMMAND""-    ${ARGN})--  if(NOT _libuv_CONFIGURE_COMMAND AND NOT _libuv_BUILD_COMMAND-        AND NOT _libuv_INSTALL_COMMAND)-    message(FATAL_ERROR ""Must pass at least one of CONFIGURE_COMMAND, BUILD_COMMAND, INSTALL_COMMAND"")-  endif()-  if(NOT _libuv_TARGET)-    set(_libuv_TARGET ""libuv"")-  endif()--  ExternalProject_Add(${_libuv_TARGET}-    PREFIX ${DEPS_BUILD_DIR}-    URL ${LIBUV_URL}-    DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/libuv-    DOWNLOAD_COMMAND ${CMAKE_COMMAND}-      -DPREFIX=${DEPS_BUILD_DIR}-      -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/libuv-      -DURL=${LIBUV_URL}-      -DEXPECTED_SHA256=${LIBUV_SHA256}-      -DTARGET=${_libuv_TARGET}-      -DUSE_EXISTING_SRC_DIR=${USE_EXISTING_SRC_DIR}-      -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake-    PATCH_COMMAND ""${_libuv_PATCH_COMMAND}""-    BUILD_IN_SOURCE ${_libuv_BUILD_IN_SOURCE}-    CONFIGURE_COMMAND ""${_libuv_CONFIGURE_COMMAND}""-    BUILD_COMMAND ""${_libuv_BUILD_COMMAND}""-    INSTALL_COMMAND ""${_libuv_INSTALL_COMMAND}"")-endfunction()--set(UNIX_CFGCMD sh ${DEPS_BUILD_DIR}/src/libuv/autogen.sh &&-  ${DEPS_BUILD_DIR}/src/libuv/configure --with-pic --disable-shared-  --prefix=${DEPS_INSTALL_DIR} --libdir=${DEPS_INSTALL_DIR}/lib-  CC=${DEPS_C_COMPILER})--if(UNIX)-  BuildLibuv(-    CONFIGURE_COMMAND ${UNIX_CFGCMD} MAKE=${MAKE_PRG}-    INSTALL_COMMAND ${MAKE_PRG} V=1 install)--elseif(WIN32)--  set(UV_OUTPUT_DIR ${DEPS_BUILD_DIR}/src/libuv/${CMAKE_BUILD_TYPE})-  if(MSVC)-    set(BUILD_SHARED ON)-  elseif(MINGW)-    set(BUILD_SHARED OFF)-  else()-    message(FATAL_ERROR ""Trying to build libuv in an unsupported system ${CMAKE_SYSTEM_NAME}/${CMAKE_C_COMPILER_ID}"")-  endif()-  BuildLibUv(BUILD_IN_SOURCE-    CONFIGURE_COMMAND ${CMAKE_COMMAND} -E copy-        ${CMAKE_CURRENT_SOURCE_DIR}/cmake/LibuvCMakeLists.txt-        ${DEPS_BUILD_DIR}/src/libuv/CMakeLists.txt-      COMMAND ${CMAKE_COMMAND} ${DEPS_BUILD_DIR}/src/libuv/CMakeLists.txt-        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}-        -DCMAKE_GENERATOR=${CMAKE_GENERATOR}-        -DCMAKE_GENERATOR_PLATFORM=${CMAKE_GENERATOR_PLATFORM}-        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}-        -DBUILD_SHARED_LIBS=${BUILD_SHARED}-        -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR}-    PATCH_COMMAND ${LIBUV_PATCH_COMMAND}-    BUILD_COMMAND ${CMAKE_COMMAND} --build . --config ${CMAKE_BUILD_TYPE}-    INSTALL_COMMAND ${CMAKE_COMMAND} --build . --target install --config ${CMAKE_BUILD_TYPE})--else()-  message(FATAL_ERROR ""Trying to build libuv in an unsupported system ${CMAKE_SYSTEM_NAME}/${CMAKE_C_COMPILER_ID}"")-endif()+ExternalProject_Add(libuv+  PREFIX ${DEPS_BUILD_DIR}+  URL ${LIBUV_URL}+  CMAKE_ARGS+    -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR}+    -DCMAKE_INSTALL_LIBDIR=lib+    -DBUILD_TESTING=OFF+    -DCMAKE_POSITION_INDEPENDENT_CODE=ON+    ""-DCMAKE_OSX_ARCHITECTURES:STRING=${CMAKE_OSX_ARCHITECTURES}""","You can do something like this to deal with the `;`:https://github.com/neovim/neovim/blob/3030b4d65345baaa92606ad47e53573463c842d8/cmake.deps/cmake/BuildLuv.cmake#L52Or, if the quoting works then maybe we don't need `CMAKE_OSX_ARCHITECTURES_ALTSEP` and it can be removed. Though IIRC I couldn't get the quoting to work.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19693,941551000,2022-08-09T16:23:44Z,.github/workflows/release.yml,"@@ -27,15 +27,15 @@ jobs:       - name: Install dependencies         run: |           sudo apt-get update-          sudo apt-get install -y autoconf automake build-essential cmake gcc-11 gettext libtool-bin locales ninja-build pkg-config unzip+          sudo apt-get install -y autoconf automake build-essential cmake gettext libtool-bin locales ninja-build pkg-config unzip","No, we're not. [ubuntu-20.04](https://github.com/actions/runner-images/blob/main/images/linux/Ubuntu2004-Readme.md#language-and-runtime) ships with `gcc-10`, although `gcc-9` is still the default.(You can [verify in the log](https://github.com/clason/neovim/runs/7749783701?check_suite_focus=true#step:3:40) that it doesn't pull in any `gcc`.)",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/19693,941732595,2022-08-09T19:37:20Z,.github/workflows/release.yml,"@@ -27,15 +27,15 @@ jobs:       - name: Install dependencies         run: |           sudo apt-get update-          sudo apt-get install -y autoconf automake build-essential cmake gcc-11 gettext libtool-bin locales ninja-build pkg-config unzip+          sudo apt-get install -y autoconf automake build-essential cmake gettext libtool-bin locales ninja-build pkg-config unzip","> No, we're not.I know. That's why I suggested we should. If you'd rather rely on GH installing, that's fine. I was just suggesting being explicit, since we're explicitly using a non-default tool chain.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/19693,941748818,2022-08-09T19:58:43Z,.github/workflows/release.yml,"@@ -27,15 +27,15 @@ jobs:       - name: Install dependencies         run: |           sudo apt-get update-          sudo apt-get install -y autoconf automake build-essential cmake gcc-11 gettext libtool-bin locales ninja-build pkg-config unzip+          sudo apt-get install -y autoconf automake build-essential cmake gettext libtool-bin locales ninja-build pkg-config unzip","GH is currently including gcc-10 in their list of additional packages they install on top of the ""base Ubuntu image + build-essential"" image.  I prefer to rely on the latter and explicitly list additional dependencies from that, rather than using GH's custom image as the base.  It's my distro packager OCD shining through.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19693,941762805,2022-08-09T20:17:30Z,.github/workflows/release.yml,"@@ -27,15 +27,15 @@ jobs:       - name: Install dependencies         run: |           sudo apt-get update-          sudo apt-get install -y autoconf automake build-essential cmake gcc-11 gettext libtool-bin locales ninja-build pkg-config unzip+          sudo apt-get install -y autoconf automake build-essential cmake gettext libtool-bin locales ninja-build pkg-config unzip","> But I don't see how asking to install something that is already installed (so it's at best a noop) is an improvement?I think it's just to be explicit to future developers that `gcc-10` is a dependency; this doesn't have any practical effects in and of itself. In the event that we, for example, change CI providers that doesn't have `gcc-10` by default then we'd be sure this still works if we copy paste the steps. It's a ""correctness"" thing rather than ""useful"" thing ;)I'd say the PR is fine as is. If you wanna drop a `gcc-10` in the install list that's fine by me, and if not then let's merge this already :)",
32016110,zbirenbaum,https://api.github.com/repos/neovim/neovim/pulls/19705,942993930,2022-08-10T23:28:56Z,runtime/lua/vim/diagnostic.lua,"@@ -895,22 +895,30 @@ M.handlers.signs = {     end      local ns = M.get_namespace(namespace)-    if not ns.user_data.sign_group then-      ns.user_data.sign_group = string.format('vim.diagnostic.%s', ns.name)+    if not ns.user_data.sign_ns then+      ns.user_data.sign_ns = vim.api.nvim_create_namespace('')     end -    local sign_group = ns.user_data.sign_group+    local sign_ns = ns.user_data.sign_ns     for _, diagnostic in ipairs(diagnostics) do-      vim.fn.sign_place(0, sign_group, sign_highlight_map[diagnostic.severity], bufnr, {+      local lnum = diagnostic.lnum+      local col = diagnostic.col+      local sign_text = opts.sign_text and opts.sign_text[diagnostic.severity] or M.severity[diagnostic.severity]:sub(1,1)","I believe the docs are generated from the comments in the source via Doxygen correct? Is there a formatter for the comments?Also, I think it would be better to change sign_text to a function `M.resolve_sign` which takes a diagnostic as its parameter, is public, and can be configured `via vim.diagnostic.config`, similar to what is implemented for the formatting of the virtual_text handler to allow for more advanced configurations.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19705,943454110,2022-08-11T12:58:01Z,runtime/lua/vim/diagnostic.lua,"@@ -895,22 +895,30 @@ M.handlers.signs = {     end      local ns = M.get_namespace(namespace)-    if not ns.user_data.sign_group then-      ns.user_data.sign_group = string.format('vim.diagnostic.%s', ns.name)+    if not ns.user_data.sign_ns then+      ns.user_data.sign_ns = vim.api.nvim_create_namespace('')     end -    local sign_group = ns.user_data.sign_group+    local sign_ns = ns.user_data.sign_ns     for _, diagnostic in ipairs(diagnostics) do-      vim.fn.sign_place(0, sign_group, sign_highlight_map[diagnostic.severity], bufnr, {+      local lnum = diagnostic.lnum+      local col = diagnostic.col+      local sign_text = opts.sign_text and opts.sign_text[diagnostic.severity] or M.severity[diagnostic.severity]:sub(1,1)+      local sign_opts = {+        sign_text = sign_text,+        sign_hl_group = sign_highlight_map[diagnostic.severity],         priority = get_priority(diagnostic.severity),",Here is the usage:https://github.com/neovim/neovim/blob/6669fc94ae76399a619a350b5d2fc9421e575a81/src/nvim/decoration.c#L386-L392,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19705,943826516,2022-08-11T18:57:48Z,runtime/lua/vim/diagnostic.lua,"@@ -895,22 +895,30 @@ M.handlers.signs = {     end      local ns = M.get_namespace(namespace)-    if not ns.user_data.sign_group then-      ns.user_data.sign_group = string.format('vim.diagnostic.%s', ns.name)+    if not ns.user_data.sign_ns then+      ns.user_data.sign_ns = vim.api.nvim_create_namespace('')     end -    local sign_group = ns.user_data.sign_group+    local sign_ns = ns.user_data.sign_ns     for _, diagnostic in ipairs(diagnostics) do-      vim.fn.sign_place(0, sign_group, sign_highlight_map[diagnostic.severity], bufnr, {+      local lnum = diagnostic.lnum+      local col = diagnostic.col+      local sign_text = opts.sign_text and opts.sign_text[diagnostic.severity] or M.severity[diagnostic.severity]:sub(1,1)+      local sign_opts = {+        sign_text = sign_text,+        sign_hl_group = sign_highlight_map[diagnostic.severity],         priority = get_priority(diagnostic.severity),-        lnum = diagnostic.lnum + 1,-      })+      }+      pcall(vim.api.nvim_buf_set_extmark, bufnr, sign_ns, lnum, col, sign_opts)","My vote would be on `col=0` then, as signs don't care about columns.(Strict is not equivalent to pcall, either semantically or functionally.)",
32016110,zbirenbaum,https://api.github.com/repos/neovim/neovim/pulls/19705,943880907,2022-08-11T20:00:20Z,runtime/lua/vim/diagnostic.lua,"@@ -895,22 +895,30 @@ M.handlers.signs = {     end      local ns = M.get_namespace(namespace)-    if not ns.user_data.sign_group then-      ns.user_data.sign_group = string.format('vim.diagnostic.%s', ns.name)+    if not ns.user_data.sign_ns then+      ns.user_data.sign_ns = vim.api.nvim_create_namespace('')     end -    local sign_group = ns.user_data.sign_group+    local sign_ns = ns.user_data.sign_ns     for _, diagnostic in ipairs(diagnostics) do-      vim.fn.sign_place(0, sign_group, sign_highlight_map[diagnostic.severity], bufnr, {+      local lnum = diagnostic.lnum+      local col = diagnostic.col+      local sign_text = opts.sign_text and opts.sign_text[diagnostic.severity] or M.severity[diagnostic.severity]:sub(1,1)+      local sign_opts = {+        sign_text = sign_text,+        sign_hl_group = sign_highlight_map[diagnostic.severity],         priority = get_priority(diagnostic.severity),-        lnum = diagnostic.lnum + 1,-      })+      }+      pcall(vim.api.nvim_buf_set_extmark, bufnr, sign_ns, lnum, col, sign_opts)","> My vote would be on `col=0` then, as signs don't care about columns.> > (Strict is not equivalent to pcall, either semantically or functionally.)I phrased that very poorly, I just meant that the error it avoids is the same one I used pcall to ignore, but since other errors would be suppressed by pcall that would not be by strict, I agree that it is functionally different.I also think col being 0 is the best choice here though.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19713,944430629,2022-08-12T12:50:12Z,ci/common/build.sh,"@@ -24,9 +24,7 @@ build_deps() {   mkdir -p ""${DEPS_BUILD_DIR}""    # Use cached dependencies if $CACHE_MARKER exists.-  if test ""${CACHE_ENABLE}"" = ""false"" ; then-    export CCACHE_RECACHE=1-  elif test -f ""${CACHE_MARKER}"" ; then+  if test -f ""${CACHE_MARKER}"" && ! test ""${CACHE_ENABLE}"" = ""false"" ; then","I think we can remove the second condition (`&& test ""${CACHE_ENABLE}"" = ""false""`) since it's always set to true when using `env.sh`, and because I don't think caching can be meaningfully generalized across CI providers anyway. If you decide to remove this then the `CACHE_ENABLE=true` in `.github/workflows/env.sh` should also be removed.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19632,944477812,2022-08-12T13:41:58Z,cmake.deps/cmake/BuildLibuv.cmake,"@@ -1,77 +1,26 @@-# BuildLibuv(TARGET targetname CONFIGURE_COMMAND ... BUILD_COMMAND ... INSTALL_COMMAND ...)-# Reusable function to build libuv, wraps ExternalProject_Add.-# Failing to pass a command argument will result in no command being run-function(BuildLibuv)-  cmake_parse_arguments(_libuv-    ""BUILD_IN_SOURCE""-    ""TARGET""-    ""PATCH_COMMAND;CONFIGURE_COMMAND;BUILD_COMMAND;INSTALL_COMMAND""-    ${ARGN})--  if(NOT _libuv_CONFIGURE_COMMAND AND NOT _libuv_BUILD_COMMAND-        AND NOT _libuv_INSTALL_COMMAND)-    message(FATAL_ERROR ""Must pass at least one of CONFIGURE_COMMAND, BUILD_COMMAND, INSTALL_COMMAND"")-  endif()-  if(NOT _libuv_TARGET)-    set(_libuv_TARGET ""libuv"")-  endif()--  ExternalProject_Add(${_libuv_TARGET}-    PREFIX ${DEPS_BUILD_DIR}-    URL ${LIBUV_URL}-    DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/libuv-    DOWNLOAD_COMMAND ${CMAKE_COMMAND}-      -DPREFIX=${DEPS_BUILD_DIR}-      -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/libuv-      -DURL=${LIBUV_URL}-      -DEXPECTED_SHA256=${LIBUV_SHA256}-      -DTARGET=${_libuv_TARGET}-      -DUSE_EXISTING_SRC_DIR=${USE_EXISTING_SRC_DIR}-      -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake-    PATCH_COMMAND ""${_libuv_PATCH_COMMAND}""-    BUILD_IN_SOURCE ${_libuv_BUILD_IN_SOURCE}-    CONFIGURE_COMMAND ""${_libuv_CONFIGURE_COMMAND}""-    BUILD_COMMAND ""${_libuv_BUILD_COMMAND}""-    INSTALL_COMMAND ""${_libuv_INSTALL_COMMAND}"")-endfunction()--set(UNIX_CFGCMD sh ${DEPS_BUILD_DIR}/src/libuv/autogen.sh &&-  ${DEPS_BUILD_DIR}/src/libuv/configure --with-pic --disable-shared-  --prefix=${DEPS_INSTALL_DIR} --libdir=${DEPS_INSTALL_DIR}/lib-  CC=${DEPS_C_COMPILER})--if(UNIX)-  BuildLibuv(-    CONFIGURE_COMMAND ${UNIX_CFGCMD} MAKE=${MAKE_PRG}-    INSTALL_COMMAND ${MAKE_PRG} V=1 install)--elseif(WIN32)--  set(UV_OUTPUT_DIR ${DEPS_BUILD_DIR}/src/libuv/${CMAKE_BUILD_TYPE})-  if(MSVC)-    set(BUILD_SHARED ON)-  elseif(MINGW)-    set(BUILD_SHARED OFF)-  else()-    message(FATAL_ERROR ""Trying to build libuv in an unsupported system ${CMAKE_SYSTEM_NAME}/${CMAKE_C_COMPILER_ID}"")-  endif()-  BuildLibUv(BUILD_IN_SOURCE-    CONFIGURE_COMMAND ${CMAKE_COMMAND} -E copy-        ${CMAKE_CURRENT_SOURCE_DIR}/cmake/LibuvCMakeLists.txt-        ${DEPS_BUILD_DIR}/src/libuv/CMakeLists.txt-      COMMAND ${CMAKE_COMMAND} ${DEPS_BUILD_DIR}/src/libuv/CMakeLists.txt-        -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}-        -DCMAKE_GENERATOR=${CMAKE_GENERATOR}-        -DCMAKE_GENERATOR_PLATFORM=${CMAKE_GENERATOR_PLATFORM}-        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}-        -DBUILD_SHARED_LIBS=${BUILD_SHARED}-        -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR}-    PATCH_COMMAND ${LIBUV_PATCH_COMMAND}-    BUILD_COMMAND ${CMAKE_COMMAND} --build . --config ${CMAKE_BUILD_TYPE}-    INSTALL_COMMAND ${CMAKE_COMMAND} --build . --target install --config ${CMAKE_BUILD_TYPE})--else()-  message(FATAL_ERROR ""Trying to build libuv in an unsupported system ${CMAKE_SYSTEM_NAME}/${CMAKE_C_COMPILER_ID}"")-endif()+ExternalProject_Add(libuv+  PREFIX ${DEPS_BUILD_DIR}+  URL ${LIBUV_URL}+  CMAKE_ARGS+    -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR}+    -DCMAKE_INSTALL_LIBDIR=lib+    -DBUILD_TESTING=OFF+    -DCMAKE_POSITION_INDEPENDENT_CODE=ON+    -DLIBUV_BUILD_SHARED=OFF+  CMAKE_CACHE_ARGS+    -DCMAKE_OSX_ARCHITECTURES:STRING=${CMAKE_OSX_ARCHITECTURES}","Hmm, now we have two different, janky workarounds to deal with the same problem: cmake not passing lists correctly. We should stick to one of them if possible. Could we test if this works for the other places where we use the LIST_SEP workaround?",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19128,945122620,2022-08-13T10:17:05Z,CMakePresets.json,"@@ -0,0 +1,173 @@+{+  ""version"": 3,+  ""configurePresets"": [+    {+      ""name"": ""base"",+      ""displayName"": ""base preset"",+      ""generator"": ""Ninja"",+      ""binaryDir"": ""${sourceDir}/build/${presetName}"",","Having multiple build dirs isn't bad, but surprising compared to previous behavior. Maybe we should drop the `${presetName}` here and in `LOG_DIR`?",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19128,945164243,2022-08-13T16:10:17Z,CMakePresets.json,"@@ -0,0 +1,173 @@+{+  ""version"": 3,+  ""configurePresets"": [+    {+      ""name"": ""base"",+      ""displayName"": ""base preset"",+      ""generator"": ""Ninja"",+      ""binaryDir"": ""${sourceDir}/build/${presetName}"",+      ""cacheVariables"": {+        ""CMAKE_EXPORT_COMPILE_COMMANDS"": true+      },+      ""environment"": {+        ""LOG_DIR"": ""${sourceDir}/build/${presetName}/logs""+      },+      ""hidden"": true+    },+    {+      ""name"": ""release"",+      ""displayName"": ""Release"",+      ""description"": ""Same as RelWithDebInfo, but disables debug information"",+      ""cacheVariables"": {+        ""CMAKE_BUILD_TYPE"": ""Release""+      },+      ""inherits"": [+        ""base""+      ]+    },+    {+      ""name"": ""relwithdebinfo"",+      ""displayName"": ""RelWithDebInfo"",+      ""description"": ""Enables optimizations (-Og or -O2) with debug information"",+      ""cacheVariables"": {+        ""CMAKE_BUILD_TYPE"": ""RelWithDebInfo""+      },+      ""inherits"": [+        ""base""+      ]+    },+    {+      ""name"": ""debug"",+      ""displayName"": ""Debug"",+      ""description"": ""Disables optimizations (-O0), enables debug information"",+      ""cacheVariables"": {+        ""CMAKE_BUILD_TYPE"": ""Debug""+      },+      ""inherits"": [+        ""base""+      ]+    },+    {+      ""name"": ""debug-clang"",+      ""displayName"": ""Debug (w/ clang toolchain)"",+      ""environment"": {+        ""CC"": ""clang"",+        ""CXX"": ""clang++""+      },+      ""inherits"": [+        ""debug""+      ]+    },+    {+      ""name"": ""asan"",+      ""displayName"": ""Debug (w/ ASAN/UBSAN support)"",+      ""cacheVariables"": {+        ""CLANG_ASAN_UBSAN"": ""ON""+      },+      ""environment"": {+        ""ASAN_OPTIONS"": ""'detect_leaks=0;log_path=$env{LOG_DIR}'"",+        ""UBSAN_OPTIONS"": ""'print_stacktrace=1'""+      },+      ""inherits"": [+        ""debug-clang""+      ]+    },+    {+      ""name"": ""tsan"",+      ""displayName"": ""Debug (w/ TSAN support)"",+      ""cacheVariables"": {+        ""CLANG_TSAN"": ""ON""+      },+      ""environment"": {+        ""TSAN_OPTIONS"": ""'log_path=$env{LOG_DIR}'""+      },+      ""inherits"": [+        ""debug-clang""+      ]+    },+    {+      ""name"": ""msan"",+      ""displayName"": ""Debug (w/ MSAN support)"",+      ""cacheVariables"": {+        ""CLANG_MSAN"": ""ON""+      },+      ""environment"": {+        ""MSAN_OPTIONS"": ""'log_path=$env{LOG_DIR}'""+      },+      ""inherits"": [+        ""debug-clang""+      ]+    },+    {+      ""name"": ""win-x64"",+      ""displayName"": ""Windows MSVC x64 (/w VS2019)"",+      ""generator"": ""Visual Studio 17 2022"",+      ""architecture"": {+        ""value"": ""x64"",+        ""strategy"": ""set""+      },+      ""cacheVariables"":{+        ""CMAKE_BUILD_TYPE"": ""RelWithDebInfo""+      },+      ""inherits"": ""base"",+      ""condition"": {+        ""type"": ""equals"",+        ""lhs"": ""${hostSystemName}"",+        ""rhs"": ""Windows""+      }+    },+    {+      ""name"": ""win-ninja-x64"",+      ""displayName"": ""Windows x64 (/w Ninja)"",+      ""generator"": ""Ninja"",+      ""cacheVariables"":{+        ""CMAKE_BUILD_TYPE"": ""RelWithDebInfo""+      },+      ""inherits"": ""base"",+      ""condition"": {+        ""type"": ""equals"",+        ""lhs"": ""${hostSystemName}"",+        ""rhs"": ""Windows""+      }+    }+  ],+  ""buildPresets"": [","Indeed, this is very specific to MSBuild, as that's the only way to make it build in parallel, whereas Ninja, by design, barely has any runtime flags other than `-v`, so I'm not sure how to best handle this tbh ���� ",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19761,945191948,2022-08-13T21:35:50Z,runtime/lua/vim/keymap.lua,"@@ -36,14 +36,16 @@ local keymap = {} ---@param lhs string           Left-hand side |{lhs}| of the mapping. ---@param rhs string|function  Right-hand side |{rhs}| of the mapping. Can also be a Lua function. ------@param opts table A table of |:map-arguments| such as ""silent"". In addition to the options----                  listed in |nvim_set_keymap()|, this table also accepts the following keys:----                  - buffer: (number or boolean) Add a mapping to the given buffer. When ""true""----                    or 0, use the current buffer.----                  - remap: (boolean) Make the mapping recursive. This is the----                  inverse of the ""noremap"" option from |nvim_set_keymap()|.----                  Default `false`.----                  - replace_keycodes: (boolean) defaults to true if ""expr"" is true.+---@param opts table A table of |:map-arguments|. Accepts all options accepted by the {opts}+---                  parameter in |nvim_set_keymap()|, with the following notable differences in+---                  default values:+---                  - replace_keycodes: (boolean) Defaults to true if ""expr"" is true.+---                  In addition to those options, the table accepts the following keys:","I previously also tried to insert a sentence after a list in arguments, but it didn't seem to work. As you can see in the generated docs this is appended to the previous line.",
24771416,mityu,https://api.github.com/repos/neovim/neovim/pulls/17335,945293723,2022-08-14T13:52:06Z,src/nvim/window.c,"@@ -5452,7 +5458,9 @@ static void frame_setheight(frame_T *curfrp, int height)   if (curfrp->fr_parent == NULL) {     // topframe: can only change the command line     if (height > ROWS_AVAIL) {-      height = ROWS_AVAIL;+      // If height is greater than the available space, try to create space for the frame by+      // reducing 'cmdheight' if possible, while making sure `cmdheight` doesn't go below 1.+      height = MIN(ROWS_AVAIL + (p_ch - 1), height);","This PR is to automatically change the `'cmdheight'` value when the command line height is changed with `:resize` like operations.However, it seems to me that these lines are for another purpose: reduce the command line height when maximizing a window (or making window height bigger).This change is a breaking change and I wonder if it is expected.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19773,945341341,2022-08-14T20:54:05Z,runtime/lua/vim/uri.lua,"@@ -83,6 +83,14 @@ local WINDOWS_URI_SCHEME_PATTERN = '^([a-zA-Z]+[a-zA-Z0-9.+-]*):[a-zA-Z]:.*' ---@param bufnr number ---@return string URI local function uri_from_bufnr(bufnr)+  local relative_name+  vim.api.nvim_buf_call(bufnr, function()+    relative_name = vim.api.nvim_exec("":echo @%"", true)+  end)","Another question, when there are multiple denols instances running, can they open the same `deno:` file twice, but with different contents? If yes then it might be necessary to also have a language server identifier in the path, because you can't have duplicate file names. (like `deno://1/path/to/something`, with `1` being the identifier)",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19773,945342204,2022-08-14T21:02:07Z,runtime/lua/vim/uri.lua,"@@ -83,6 +83,14 @@ local WINDOWS_URI_SCHEME_PATTERN = '^([a-zA-Z]+[a-zA-Z0-9.+-]*):[a-zA-Z]:.*' ---@param bufnr number ---@return string URI local function uri_from_bufnr(bufnr)+  local relative_name+  vim.api.nvim_buf_call(bufnr, function()+    relative_name = vim.api.nvim_exec("":echo @%"", true)+  end)","Multiple denols instances as in multiple deno projects opened in the same neovim instance.Yes, `:` without `//` is technically correct, but it's just not handled in vim. I'm not sure where it is, you'd have to search for it in the C part of the code base.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19775,945347255,2022-08-14T21:57:05Z,src/nvim/ex_docmd.c,"@@ -721,15 +687,13 @@ int do_cmdline(char *cmdline, LineGetter fgetline, void *cookie, int flags)     // Convert an interrupt to an exception if appropriate.     (void)do_intthrow(&cstack);   }-  /*-   * Continue executing command lines when:-   * - no CTRL-C typed, no aborting error, no exception thrown or try-   *   conditionals need to be checked for executing finally clauses or-   *   catching an interrupt exception-   * - didn't get an error message or lines are not typed-   * - there is a command after '|', inside a :if, :while, :for or :try, or-   *   looping for "":source"" command or function call.-   */+  // Continue executing command lines when:+  // - no CTRL-C typed, no aborting error, no exception thrown or try+  //   conditionals need to be checked for executing finally clauses or+  //   catching an interrupt exception+  // - didn't get an error message or lines are not typed+  // - there is a command after '|', inside a :if, :while, :for or :try, or+  //   looping for "":source"" command or function call.   while (!((got_int || (did_emsg && force_abort) || current_exception)            && cstack.cs_trylevel == 0)          && !(did_emsg",I tried that but it didn't work. It seemed like the expression was too complex for the linter or something.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19775,945475032,2022-08-15T07:14:18Z,src/nvim/ex_docmd.c,"@@ -5468,16 +5349,15 @@ static void ex_pclose(exarg_T *eap) /// @param tp  NULL or the tab page ""win"" is in void ex_win_close(int forceit, win_T *win, tabpage_T *tp) {-  int need_hide;-  buf_T *buf = win->w_buffer;-   // Never close the autocommand window.   if (win == aucmd_win) {     emsg(_(e_autocmd_close));     return;   } -  need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);+  buf_T *buf = win->w_buffer;++  int need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);",```suggestion  bool need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19775,945476600,2022-08-15T07:17:15Z,src/nvim/ex_docmd.c,"@@ -6280,12 +6143,12 @@ void do_exedit(exarg_T *eap, win_T *old_curwin)                 old_curwin == NULL ? curwin : NULL) == FAIL) {       // Editing the file failed.  If the window was split, close it.       if (old_curwin != NULL) {-        need_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);+        int need_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);",```suggestion        bool need_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);```,
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19773,945616658,2022-08-15T10:57:41Z,runtime/lua/vim/uri.lua,"@@ -78,11 +78,19 @@ end  local URI_SCHEME_PATTERN = '^([a-zA-Z]+[a-zA-Z0-9.+-]*):.*' local WINDOWS_URI_SCHEME_PATTERN = '^([a-zA-Z]+[a-zA-Z0-9.+-]*):[a-zA-Z]:.*'+--https://url.spec.whatwg.org/#special-scheme+local SPECIAL_SCHEME  = {'ftp', 'file', 'http', 'https', 'ws', 'wss'}  --- Get a URI from a bufnr ---@param bufnr number ---@return string URI local function uri_from_bufnr(bufnr)+  local relative_name = vim.fn.bufname(bufnr)+  local maybe_scheme = relative_name:match(URI_SCHEME_PATTERN)","`deno:some/file` is technically compliant with the spec, vim just treats it like a normal path.Two potential solutions we have right now is to start complying with the URI spec, or translate paths to and from `deno://`",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19812,947680790,2022-08-17T09:32:48Z,src/nvim/lua/treesitter.c,"@@ -391,10 +396,12 @@ static int parser_parse(lua_State *L)     return luaL_argerror(L, 3, ""expected either string or buffer handle"");   } -  // Sometimes parsing fails (timeout, or wrong parser ABI)-  // In those case, just return an error.+  // As we ensure that the parser ABIs are correct when creating the languages,+  // we are sure that the only reason of receiving a NULL is because of a+  // timeout.   if (!new_tree) {-    return luaL_error(L, ""An error occurred when parsing."");+    ts_parser_reset(*p);","Do we really want to reset the parser unconditionally? IIRC this is only necessary if there is an edit after an incomplete parse was aborted. otherwise, next time parsing the buffer is attempted, we should just let it continue on the existing job (still having the same deadline of course).",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15391,949119461,2022-08-18T13:15:47Z,cmake.deps/cmake/BuildTreesitterParsers.cmake,"@@ -1,29 +1,32 @@-ExternalProject_Add(treesitter-c-PREFIX ${DEPS_BUILD_DIR}-URL ${TREESITTER_C_URL}-DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/treesitter-c-DOWNLOAD_COMMAND ${CMAKE_COMMAND}-  -DPREFIX=${DEPS_BUILD_DIR}-  -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/treesitter-c-  -DURL=${TREESITTER_C_URL}-  -DEXPECTED_SHA256=${TREESITTER_C_SHA256}-  -DTARGET=treesitter-c-  -DUSE_EXISTING_SRC_DIR=${USE_EXISTING_SRC_DIR}-  -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake-PATCH_COMMAND ${CMAKE_COMMAND} -E copy-  ${CMAKE_CURRENT_SOURCE_DIR}/cmake/TreesitterParserCMakeLists.txt-        ${DEPS_BUILD_DIR}/src/treesitter-c/CMakeLists.txt-CMAKE_ARGS-  -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}-  -DCMAKE_GENERATOR=${CMAKE_GENERATOR}-  -DCMAKE_GENERATOR_PLATFORM=${CMAKE_GENERATOR_PLATFORM}-  ${BUILD_TYPE_STRING}-  -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR}-  -DCMAKE_OSX_ARCHITECTURES=${CMAKE_OSX_ARCHITECTURES_ALT_SEP}-  # Pass toolchain-  -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TOOLCHAIN_FILE}-  -DPARSERLANG=c+function(BuildTSParser LANG TS_URL TS_SHA256 TS_CMAKE_FILE)+  set(NAME treesitter-${LANG})+  ExternalProject_Add(${NAME}+  PREFIX ${DEPS_BUILD_DIR}+  URL ${TREESITTER_C_URL}+  DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/${NAME}+  DOWNLOAD_COMMAND ${CMAKE_COMMAND}+    -DPREFIX=${DEPS_BUILD_DIR}+    -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/${NAME}+    -DURL=${TS_URL}+    -DEXPECTED_SHA256=${TS_SHA256}+    -DTARGET=${NAME}+    -DUSE_EXISTING_SRC_DIR=${USE_EXISTING_SRC_DIR}+    -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake+  PATCH_COMMAND ${CMAKE_COMMAND} -E copy+      ${CMAKE_CURRENT_SOURCE_DIR}/cmake/${TS_CMAKE_FILE}+      ${DEPS_BUILD_DIR}/src/${NAME}/CMakeLists.txt+  CMAKE_ARGS+    -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}+    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}",This variable is unused. Delete.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19819,949862561,2022-08-19T07:00:25Z,runtime/lua/vim/filetype.lua,"@@ -2489,7 +2489,7 @@ function M.match(args)    -- Finally, check file contents   if contents or bufnr then-    contents = contents or M.getlines(bufnr)+    contents = contents or { unpack(M.getlines(bufnr, 1, 100)), M.getlines(bufnr, -1) }",That's just how unpack works. It will only expand to multiple if it is placed in the last position.Read up on lua varargs as a second class citizen if you want to learn more.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19819,949870444,2022-08-19T07:06:40Z,runtime/lua/vim/filetype.lua,"@@ -2489,7 +2489,7 @@ function M.match(args)    -- Finally, check file contents   if contents or bufnr then-    contents = contents or M.getlines(bufnr)+    contents = contents or { unpack(M.getlines(bufnr, 1, 100)), M.getlines(bufnr, -1) }","I've seen this exact pattern on the net; should have known better than to trust the web...(Ah, probably fell for `table.unpack` not being the same as `unpack`.)",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19802,949920185,2022-08-19T08:10:35Z,src/nvim/drawscreen.c,"@@ -92,125 +89,279 @@ typedef enum {   WC_BOTTOM_RIGHT, } WindowCorner; -/// Whether to call ""ui_call_grid_resize"" in win_grid_alloc-static bool send_grid_resize = false;- #ifdef INCLUDE_GENERATED_DECLARATIONS # include ""drawscreen.c.generated.h"" #endif +static bool redraw_popupmenu = false;+static bool msg_grid_invalid = false;+static bool resizing = false;+ static char *provider_err = NULL; -/// Redraw a window later, with update_screen(type).+/// Check if the cursor line needs to be redrawn because of 'concealcursor'. ///-/// Set must_redraw only if not already set to a higher value.-/// e.g. if must_redraw is CLEAR, type NOT_VALID will do nothing.-void redraw_later(win_T *wp, int type)-  FUNC_ATTR_NONNULL_ALL+/// When cursor is moved at the same time, both lines will be redrawn regardless.+void conceal_check_cursor_line(void)","Eek, then there must be a bit of circular dependency going on. `screen.c` shouldn't have visibility to `drawscreen.c`.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19819,949940464,2022-08-19T08:32:28Z,runtime/lua/vim/filetype.lua,"@@ -2489,7 +2489,10 @@ function M.match(args)    -- Finally, check file contents   if contents or bufnr then-    contents = contents or M.getlines(bufnr)+    if contents == nil then+      contents = M.getlines(bufnr, 1, 100)+      contents[#contents + 1] = M.getlines(bufnr, -1)","No, because that would still duplicate if the length of `contents` is exactly 100 (or 99, or whatever you pick for the first `getlines`).I don't think catching all corner cases is worth it, which makes handling this at all not worth it.(Adding a comment is fine, though.)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19819,949968991,2022-08-19T08:53:38Z,runtime/lua/vim/filetype.lua,"@@ -2489,7 +2489,10 @@ function M.match(args)    -- Finally, check file contents   if contents or bufnr then-    contents = contents or M.getlines(bufnr)+    if contents == nil then+      contents = M.getlines(bufnr, 1, 100)+      contents[#contents + 1] = M.getlines(bufnr, -1)","eh, still a bit cumbersome, but that's one way to do it without extracting the full buffer contents (which is a deal-breaker).I'll come up with a better conditional using that function.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19848,950520468,2022-08-19T19:56:26Z,runtime/colors/blue.vim,"@@ -13,12 +13,12 @@ set background=dark hi clear let g:colors_name = 'blue' -let s:t_Co = exists('&t_Co') && !empty(&t_Co) && &t_Co >= 0 ? &t_Co : -1+let s:t_Co = exists('&t_Co') ? (&t_Co ? &t_Co : 0) : -1","Oh. Still, it's easy enough to update manually (and no big loss if it is forgotten)...",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19876,950835494,2022-08-21T12:09:59Z,src/nvim/cmdexpand.c,"@@ -2531,6 +2541,20 @@ int wildmenu_translate_key(CmdlineInfo *cclp, int key, expand_T *xp, int did_wil {   int c = key; +  if (cmdline_pum_active()) {+    // When the popup menu is used, Up/Down keys go to the previous and+    // next items in the menu and Left/Right keys go up/down a directory.+    if (c == K_UP) {+      c = K_LEFT;+    } else if (c == K_DOWN) {+      c = K_RIGHT;+    } else if (c == K_LEFT) {+      c = K_UP;+    } else if (c == K_RIGHT) {+      c = K_DOWN;+    }+  }","We have discussed this in an issue long before the vim patch and concluded that we do not want this, at least not by default. key mappings are _semantic_, not defined by some visual property, which also includes arrow keys. (that vim chooses to neglect this fact doesn't mean we also have to jump off the same cliff). For instance: it would break any cnoremap which is based on the actual meaning of the keys. ",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19768,950860561,2022-08-21T15:09:31Z,cmake.deps/cmake/DepsUtil.cmake,"@@ -0,0 +1,12 @@+function(construct_patch_command VARIABLE PATCH_CMD PATCH_EXE START_DIR PATCH_FILE)","I'm not sure we want to go this rabbit-hole with cmake's string parsing, how about creating a function that can handle the patching, which can be invoked similar to any other cmake script?Here's a version based on `z_vcpkg_apply_patches` (simplified error handling), which can handle multiple patches as a bonus :)```cmakefunction(apply_patches)  cmake_parse_arguments(PARSE_ARGV 0 ""arg"" """" ""SOURCE_PATH"" ""PATCHES"")  find_program(Git QUIET)  find_program(Patch QUIET)  foreach(patch IN LISTS arg_PATCHES)    message(STATUS ""Applying patch ${patch}"")    if(Git_FOUND)      execute_process(        COMMAND ""${GIT}"" -c core.longpaths=true -c core.autocrlf=false --work-tree=. --git-dir=.git apply ""${patch}"" --ignore-whitespace --whitespace=nowarn --verbose        ERROR_VARIABLE error        WORKING_DIRECTORY ""${arg_SOURCE_PATH}""        RESULT_VARIABLE error_code      )    elseif(Patch_FOUND AND UNIX)      execute_process(        COMMAND patch -d . -i ${PATCH_FILE}        ERROR_VARIABLE error        WORKING_DIRECTORY ""${arg_SOURCE_PATH}""        RESULT_VARIABLE error_code      )    else()      message(FATAL_ERROR ""Either git or patch is required to apply patches. Aborting..."")    endif()    if(error_code)      message(FATAL_ERROR ""Applying patch failed: ${error}"")    endif()  endforeach()endfunction()```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19768,950872135,2022-08-21T16:43:10Z,cmake.deps/cmake/DepsUtil.cmake,"@@ -0,0 +1,12 @@+function(construct_patch_command VARIABLE PATCH_CMD PATCH_EXE START_DIR PATCH_FILE)","you pass it as a `PATCH_COMMAND`https://github.com/neovim/neovim/blob/c54c37ee28cf380199a65c5849b3abe7aaae0afa/cmake.deps/cmake/BuildLibuv.cmake#L21-L24so it would be ```cmake  PATCH_COMMAND    ${CMAKE_COMMAND} -DSOURCE_PATH=""..."" -DPATCHES=""..."" -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/ApplyPatches.cmake```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19705,951963333,2022-08-22T22:20:34Z,runtime/lua/vim/diagnostic.lua,"@@ -853,6 +850,13 @@ function M.goto_next(opts)   return diagnostic_move_pos(opts, M.get_next_pos(opts)) end +local get_fallback_sign = function (severity)+  local sign = vim.fn.sign_getdefined(sign_highlight_map[severity])+  if sign and sign[1] and not vim.tbl_isempty(sign[1]) then+    return sign[1].text+  end",This check seems a bit over-defensive. We can trust that `sign_getdefined` will return a list (non-nil) and we also can trust that each table entry in the list will have its values populated.```suggestion  if sign[1] then    return sign[1].text  end```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19705,951967056,2022-08-22T22:27:07Z,runtime/lua/vim/diagnostic.lua,"@@ -895,22 +901,31 @@ M.handlers.signs = {     end      local ns = M.get_namespace(namespace)-    if not ns.user_data.sign_group then-      ns.user_data.sign_group = string.format('vim.diagnostic.%s', ns.name)+    if not ns.user_data.sign_ns then+      local sign_ns = string.format('vim.diagnostic.%s', ns.name)+      ns.user_data.sign_ns = vim.api.nvim_create_namespace(sign_ns)     end -    local sign_group = ns.user_data.sign_group+    local sign_ns = ns.user_data.sign_ns     for _, diagnostic in ipairs(diagnostics) do-      vim.fn.sign_place(0, sign_group, sign_highlight_map[diagnostic.severity], bufnr, {+      local lnum = diagnostic.lnum+      local sign_text = diagnostic.sign_text or opts.sign_text and opts.sign_text[diagnostic.severity]",The diagnostic object has no `sign_text` field. If you want to allow users to attach `sign_text` as an arbitrary value it should be in the `user_data` table (which is designed for this purpose).Also be sure to index into `opts.signs` for signs-specific options.```suggestion      local sign_text = diagnostic.user_data.sign_text or (opts.signs and opts.signs.sign_text and opts.signs.sign_text[diagnostic.severity])```You may want to split this up into a proper `if` statement...,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19877,952338067,2022-08-23T08:52:50Z,src/nvim/api/private/helpers.c,"@@ -476,6 +476,34 @@ bool buf_collect_lines(buf_T *buf, size_t n, int64_t start, bool replace_nl, Arr   return true; } +/// lua specialized version of buf_collect_lines that avoids string allocations+bool buf_collect_lines_lua(buf_T *buf, size_t n, int64_t start, lua_State *lstate, Error *err)+{+  lua_createtable(lstate, (int)n, 0);++  for (linenr_T i = 0; i < (linenr_T)n; i++) {+    linenr_T lnum = (linenr_T)start + i;++    if (lnum >= MAXLNUM) {+      if (err != NULL) {+        api_set_error(err, kErrorTypeValidation, ""Line index is too high"");+      }+      return false;+    }++    char *bufstr = (char *)ml_get_buf(buf, lnum, false);+    size_t len = strlen(bufstr);++    // Vim represents NULs as NLs+    strchrsub(bufstr, '\n', '\0');",This is unsafe as `ml_get_buf` is allowed to return a direct pointer to internal memline data.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19891,952615085,2022-08-23T13:16:39Z,CONTRIBUTING.md,"@@ -219,10 +219,10 @@ You can lint a single file (but this will _not_ exclude legacy errors): ### Style  - You can format files by using:-```-  make format-```-This will format changed Lua and C files with all appropriate flags set.+  ```+    make format+  ```",thank you! it bugs me when the bullet lists are rendered as disjointed :),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19877,952686175,2022-08-23T14:15:10Z,src/nvim/api/private/helpers.c,"@@ -476,6 +476,39 @@ bool buf_collect_lines(buf_T *buf, size_t n, int64_t start, bool replace_nl, Arr   return true; } +/// lua specialized version of buf_collect_lines that avoids string allocations",```suggestion/// lua specialized version of buf_collect_lines that avoids string allocations (for non-binary data)```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19877,952690811,2022-08-23T14:18:58Z,src/nvim/api/private/helpers.c,"@@ -476,6 +476,39 @@ bool buf_collect_lines(buf_T *buf, size_t n, int64_t start, bool replace_nl, Arr   return true; } +/// lua specialized version of buf_collect_lines that avoids string allocations+bool buf_collect_lines_lua(buf_T *buf, size_t n, int64_t start, lua_State *lstate, Error *err)+{+  lua_createtable(lstate, (int)n, 0);++  for (linenr_T i = 0; i < (linenr_T)n; i++) {+    linenr_T lnum = (linenr_T)start + i;++    if (lnum >= MAXLNUM) {+      if (err != NULL) {+        api_set_error(err, kErrorTypeValidation, ""Line index is too high"");+      }+      return false;+    }++    char *bufstr = (char *)ml_get_buf(buf, lnum, false);+    size_t len = strlen(bufstr);++    // Vim represents NULs as NLs+    if (strchr(bufstr, '\n')) {+      char *tmp = xmemdupz(bufstr, len);+      strchrsub(tmp, '\n', '\0');+      lua_pushlstring(lstate, tmp, len);+      xfree(tmp);+    } else {+      lua_pushlstring(lstate, bufstr, len);+    }+    lua_rawseti(lstate, -2, i + 1);",looks like this could live in `buf_collect_lines` without too much complication. It might be worth trying to establish a pattern for this kind of thing so that we don't end up with many near-duplicate functions.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19877,952717496,2022-08-23T14:40:26Z,src/nvim/api/private/helpers.c,"@@ -476,6 +476,39 @@ bool buf_collect_lines(buf_T *buf, size_t n, int64_t start, bool replace_nl, Arr   return true; } +/// lua specialized version of buf_collect_lines that avoids string allocations",Doesn't collect_lines already imply non-binary data?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19667,953201789,2022-08-24T00:04:53Z,src/nvim/api/vimscript.c,"@@ -745,3 +746,294 @@ Dictionary nvim_parse_expression(String expr, String flags, Boolean highlight, E   viml_parser_destroy(&pstate);   return ret; }++/// Translates and returns allocated user function name.+static String user_function_name(ufunc_T *fp)+{+  String name;+  const size_t name_len = STRLEN(fp->uf_name);+  if (fp->uf_name[0] == K_SPECIAL) {+    // Replace [ K_SPECIAL KS_EXTRA KE_SNR ] with ""<SNR>""+    name.size = name_len + 2;+    name.data = xmalloc(name.size + 1);+    name.data[0] = '<';+    name.data[1] = 'S';+    name.data[2] = 'N';+    name.data[3] = 'R';+    name.data[4] = '>';+    memcpy(name.data + 5, fp->uf_name + 3, name_len - 3);+    name.data[name.size] = '\0';+  } else {+    name.size = name_len;+    name.data = xmalloc(name.size + 1);+    memcpy(name.data, fp->uf_name, name_len);+    name.data[name.size] = '\0';+  }+  return name;+}++/// Takes ownership of name.+static Dictionary user_function_dict(ufunc_T *fp, String name, bool details, bool lines)+{+  Dictionary dict = ARRAY_DICT_INIT;+  size_t dict_size = 2U + (details ? 8 : 0) + (lines ? 1 : 0);+  kv_resize(dict, dict_size);++  // Function name+  PUT(dict, ""name"", STRING_OBJ(name));+  PUT(dict, ""type"", CSTR_TO_OBJ(""user""));++  if (details) {+    // Arguments+    Array args = ARRAY_DICT_INIT;+    if (fp->uf_args.ga_len > 0) {+      kv_resize(args, (size_t)fp->uf_args.ga_len);+      for (int j = 0; j < fp->uf_args.ga_len; j++) {+        Dictionary arg = ARRAY_DICT_INIT;+        PUT(arg, ""name"", CSTR_TO_OBJ((const char *)FUNCARG(fp, j)));+        if (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len) {+          PUT(arg, ""default"",+              CSTR_TO_OBJ(((char **)(fp->uf_def_args.ga_data))+                          [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]));+        }+        kv_push(args, DICTIONARY_OBJ(arg));+      }+    }+    PUT(dict, ""args"", ARRAY_OBJ(args));+    PUT(dict, ""varargs"", BOOLEAN_OBJ(fp->uf_varargs));+    // Attributes+    PUT(dict, ""abort"", BOOLEAN_OBJ(fp->uf_flags & FC_ABORT));+    PUT(dict, ""range"", BOOLEAN_OBJ(fp->uf_flags & FC_RANGE));+    PUT(dict, ""dict"", BOOLEAN_OBJ(fp->uf_flags & FC_DICT));+    PUT(dict, ""closure"", BOOLEAN_OBJ(fp->uf_flags & FC_CLOSURE));+    // Script+    PUT(dict, ""sid"", INTEGER_OBJ(fp->uf_script_ctx.sc_sid));+    PUT(dict, ""lnum"", INTEGER_OBJ(fp->uf_script_ctx.sc_lnum));+  }++  // Source lines+  if (lines) {+    Array array = ARRAY_DICT_INIT;+    if (fp->uf_lines.ga_len > 0) {+      kv_resize(array, (size_t)fp->uf_lines.ga_len);+      for (int j = 0; j < fp->uf_lines.ga_len; j++) {+        kv_push(array, CSTR_TO_OBJ((const char *)FUNCLINE(fp, j)));+      }+    }+    PUT(dict, ""lines"", ARRAY_OBJ(array));+  }++  return dict;+}++/// Takes ownership of name.+static Dictionary builtin_function_dict(const EvalFuncDef *fn, String name, bool details)+{+  Dictionary dict = ARRAY_DICT_INIT;+  kv_resize(dict, details ? 7 : 2);++  PUT(dict, ""name"", STRING_OBJ(name));+  PUT(dict, ""type"", CSTR_TO_OBJ(""builtin""));++  if (details) {+    PUT(dict, ""min_argc"", INTEGER_OBJ(fn->min_argc));+    PUT(dict, ""max_argc"", INTEGER_OBJ(fn->max_argc));+    PUT(dict, ""base_arg"", INTEGER_OBJ(fn->base_arg));+    PUT(dict, ""fast"", BOOLEAN_OBJ(fn->fast));++    // Argument names+    if (fn->argnames != NULL) {+      Array overloads = ARRAY_DICT_INIT;+      Array names = ARRAY_DICT_INIT;+      char buf[64] = { 0 };+      size_t pos = 0;++      // Argument are separated with unit separator (ascii \x1F),+      // overloads with record separator (ascii \x1E).+      for (const char *p = fn->argnames;; p++) {+        if (*p == NUL || *p == '\x1F' || *p == '\x1E') {+          assert(pos < 64);+          buf[pos++] = NUL;+          String str = {+            .data = xmemdupz(buf, pos),+            .size = pos - 1,+          };+          pos = 0;++          if (*p == '\x1F') {  // unit separator: argument separator+            kv_push(names, STRING_OBJ(str));+          } else if (*p == '\x1E') {  // record separator: overload separator+            kv_push(names, STRING_OBJ(str));+            kv_push(overloads, ARRAY_OBJ(names));+            names = (Array)ARRAY_DICT_INIT;+          } else {  // NUL+            kv_push(names, STRING_OBJ(str));+            kv_push(overloads, ARRAY_OBJ(names));+            break;+          }+        } else {+          buf[pos++] = *p;+        }+      }++      PUT(dict, ""argnames"", ARRAY_OBJ(overloads));+    }+  }++  return dict;+}++/// Lists Vimscript functions.+///+/// @param query    When string gets information about the function under this name.+///                 When dictionary lists functions. The following keys are accepted:+///                 - builtin (boolean, default false) Include builtin functions.+///                 - user    (boolean, default true) Include user functions.+/// @param opts     Options dictionary:+///                 - details (boolean) Include function details.+///                 - lines   (boolean) Include user function lines. Ignored for builtin+///                           functions.+/// @param[out] err Error details, if any+/// @return A dictionary describing a function when {query} is a string, or a map of+///         function names to dictionaries describing them when {query} is a dictionary.+Dictionary nvim_get_functions(Object query, Dictionary opts, Error *err)+  FUNC_API_SINCE(10)+{+  Dictionary rv = ARRAY_DICT_INIT;++  if (query.type != kObjectTypeString && query.type != kObjectTypeDictionary+      && (query.type == kObjectTypeArray && query.data.array.size != 0)) {+    api_set_error(err, kErrorTypeValidation, ""query is not a dictionary or string %d"", query.type);+    return rv;+  }++  bool details = false;+  bool lines = false;+  for (size_t i = 0; i < opts.size; i++) {",can avoid this for-loop by updating `keysets.lua`https://github.com/neovim/neovim/blob/6cc6e11929ad76a2dc5204aed95cb9ed1dafde23/src/nvim/api/extmark.c#L618,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19667,953205326,2022-08-24T00:14:39Z,src/nvim/api/vimscript.c,"@@ -745,3 +746,294 @@ Dictionary nvim_parse_expression(String expr, String flags, Boolean highlight, E   viml_parser_destroy(&pstate);   return ret; }++/// Translates and returns allocated user function name.+static String user_function_name(ufunc_T *fp)+{+  String name;+  const size_t name_len = STRLEN(fp->uf_name);+  if (fp->uf_name[0] == K_SPECIAL) {+    // Replace [ K_SPECIAL KS_EXTRA KE_SNR ] with ""<SNR>""+    name.size = name_len + 2;+    name.data = xmalloc(name.size + 1);+    name.data[0] = '<';+    name.data[1] = 'S';+    name.data[2] = 'N';+    name.data[3] = 'R';+    name.data[4] = '>';+    memcpy(name.data + 5, fp->uf_name + 3, name_len - 3);+    name.data[name.size] = '\0';+  } else {+    name.size = name_len;+    name.data = xmalloc(name.size + 1);+    memcpy(name.data, fp->uf_name, name_len);+    name.data[name.size] = '\0';+  }+  return name;+}++/// Takes ownership of name.+static Dictionary user_function_dict(ufunc_T *fp, String name, bool details, bool lines)+{+  Dictionary dict = ARRAY_DICT_INIT;+  size_t dict_size = 2U + (details ? 8 : 0) + (lines ? 1 : 0);+  kv_resize(dict, dict_size);++  // Function name+  PUT(dict, ""name"", STRING_OBJ(name));+  PUT(dict, ""type"", CSTR_TO_OBJ(""user""));++  if (details) {+    // Arguments+    Array args = ARRAY_DICT_INIT;+    if (fp->uf_args.ga_len > 0) {+      kv_resize(args, (size_t)fp->uf_args.ga_len);+      for (int j = 0; j < fp->uf_args.ga_len; j++) {+        Dictionary arg = ARRAY_DICT_INIT;+        PUT(arg, ""name"", CSTR_TO_OBJ((const char *)FUNCARG(fp, j)));+        if (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len) {+          PUT(arg, ""default"",+              CSTR_TO_OBJ(((char **)(fp->uf_def_args.ga_data))+                          [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]));+        }+        kv_push(args, DICTIONARY_OBJ(arg));+      }+    }+    PUT(dict, ""args"", ARRAY_OBJ(args));+    PUT(dict, ""varargs"", BOOLEAN_OBJ(fp->uf_varargs));+    // Attributes+    PUT(dict, ""abort"", BOOLEAN_OBJ(fp->uf_flags & FC_ABORT));+    PUT(dict, ""range"", BOOLEAN_OBJ(fp->uf_flags & FC_RANGE));+    PUT(dict, ""dict"", BOOLEAN_OBJ(fp->uf_flags & FC_DICT));+    PUT(dict, ""closure"", BOOLEAN_OBJ(fp->uf_flags & FC_CLOSURE));+    // Script+    PUT(dict, ""sid"", INTEGER_OBJ(fp->uf_script_ctx.sc_sid));+    PUT(dict, ""lnum"", INTEGER_OBJ(fp->uf_script_ctx.sc_lnum));+  }++  // Source lines+  if (lines) {+    Array array = ARRAY_DICT_INIT;+    if (fp->uf_lines.ga_len > 0) {+      kv_resize(array, (size_t)fp->uf_lines.ga_len);+      for (int j = 0; j < fp->uf_lines.ga_len; j++) {+        kv_push(array, CSTR_TO_OBJ((const char *)FUNCLINE(fp, j)));+      }+    }+    PUT(dict, ""lines"", ARRAY_OBJ(array));+  }++  return dict;+}++/// Takes ownership of name.+static Dictionary builtin_function_dict(const EvalFuncDef *fn, String name, bool details)+{+  Dictionary dict = ARRAY_DICT_INIT;+  kv_resize(dict, details ? 7 : 2);++  PUT(dict, ""name"", STRING_OBJ(name));+  PUT(dict, ""type"", CSTR_TO_OBJ(""builtin""));++  if (details) {+    PUT(dict, ""min_argc"", INTEGER_OBJ(fn->min_argc));+    PUT(dict, ""max_argc"", INTEGER_OBJ(fn->max_argc));+    PUT(dict, ""base_arg"", INTEGER_OBJ(fn->base_arg));+    PUT(dict, ""fast"", BOOLEAN_OBJ(fn->fast));","This info comes from `funcs.generated.h` generated by `gen_eval.lua`, which reads `eval.lua`.## ProposalSimilar to https://github.com/neovim/neovim/issues/8029#issuecomment-1175146743 : 1. move `eval.lua` to ~~`runtime/lua/core/eval.lua`~~ `runtime/lua/inspect/eval.lua`2. we could make the field names a bit nicer like you've done here, e.g.    - `assert_equal={args_min=2, args_max=3, base=2},`    - instead of: `assert_equal={args={2, 3}, base=2},`3. users can then can use both `require('vim.inspect.eval')` and `nvim_get_functions(builtin)`, and they return the same form.## Benefits- eliminates `builtin_function_dict()` ; becomes a Lua call in `nvim_get_functions()`.- single source of truth: `eval.lua` is both the source and the final form. Helps with discovery.- helps establish a pattern we've wanted for similar future work",X
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19667,953644235,2022-08-24T10:50:03Z,src/nvim/api/vimscript.c,"@@ -745,3 +746,294 @@ Dictionary nvim_parse_expression(String expr, String flags, Boolean highlight, E   viml_parser_destroy(&pstate);   return ret; }++/// Translates and returns allocated user function name.+static String user_function_name(ufunc_T *fp)+{+  String name;+  const size_t name_len = STRLEN(fp->uf_name);+  if (fp->uf_name[0] == K_SPECIAL) {+    // Replace [ K_SPECIAL KS_EXTRA KE_SNR ] with ""<SNR>""+    name.size = name_len + 2;+    name.data = xmalloc(name.size + 1);+    name.data[0] = '<';+    name.data[1] = 'S';+    name.data[2] = 'N';+    name.data[3] = 'R';+    name.data[4] = '>';+    memcpy(name.data + 5, fp->uf_name + 3, name_len - 3);+    name.data[name.size] = '\0';+  } else {+    name.size = name_len;+    name.data = xmalloc(name.size + 1);+    memcpy(name.data, fp->uf_name, name_len);+    name.data[name.size] = '\0';+  }+  return name;+}++/// Takes ownership of name.+static Dictionary user_function_dict(ufunc_T *fp, String name, bool details, bool lines)+{+  Dictionary dict = ARRAY_DICT_INIT;+  size_t dict_size = 2U + (details ? 8 : 0) + (lines ? 1 : 0);+  kv_resize(dict, dict_size);++  // Function name+  PUT(dict, ""name"", STRING_OBJ(name));+  PUT(dict, ""type"", CSTR_TO_OBJ(""user""));++  if (details) {+    // Arguments+    Array args = ARRAY_DICT_INIT;+    if (fp->uf_args.ga_len > 0) {+      kv_resize(args, (size_t)fp->uf_args.ga_len);+      for (int j = 0; j < fp->uf_args.ga_len; j++) {+        Dictionary arg = ARRAY_DICT_INIT;+        PUT(arg, ""name"", CSTR_TO_OBJ((const char *)FUNCARG(fp, j)));+        if (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len) {+          PUT(arg, ""default"",+              CSTR_TO_OBJ(((char **)(fp->uf_def_args.ga_data))+                          [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]));+        }+        kv_push(args, DICTIONARY_OBJ(arg));+      }+    }+    PUT(dict, ""args"", ARRAY_OBJ(args));+    PUT(dict, ""varargs"", BOOLEAN_OBJ(fp->uf_varargs));+    // Attributes+    PUT(dict, ""abort"", BOOLEAN_OBJ(fp->uf_flags & FC_ABORT));+    PUT(dict, ""range"", BOOLEAN_OBJ(fp->uf_flags & FC_RANGE));+    PUT(dict, ""dict"", BOOLEAN_OBJ(fp->uf_flags & FC_DICT));+    PUT(dict, ""closure"", BOOLEAN_OBJ(fp->uf_flags & FC_CLOSURE));+    // Script+    PUT(dict, ""sid"", INTEGER_OBJ(fp->uf_script_ctx.sc_sid));+    PUT(dict, ""lnum"", INTEGER_OBJ(fp->uf_script_ctx.sc_lnum));+  }++  // Source lines+  if (lines) {+    Array array = ARRAY_DICT_INIT;+    if (fp->uf_lines.ga_len > 0) {+      kv_resize(array, (size_t)fp->uf_lines.ga_len);+      for (int j = 0; j < fp->uf_lines.ga_len; j++) {+        kv_push(array, CSTR_TO_OBJ((const char *)FUNCLINE(fp, j)));+      }+    }+    PUT(dict, ""lines"", ARRAY_OBJ(array));+  }++  return dict;+}++/// Takes ownership of name.+static Dictionary builtin_function_dict(const EvalFuncDef *fn, String name, bool details)+{+  Dictionary dict = ARRAY_DICT_INIT;+  kv_resize(dict, details ? 7 : 2);++  PUT(dict, ""name"", STRING_OBJ(name));+  PUT(dict, ""type"", CSTR_TO_OBJ(""builtin""));++  if (details) {+    PUT(dict, ""min_argc"", INTEGER_OBJ(fn->min_argc));+    PUT(dict, ""max_argc"", INTEGER_OBJ(fn->max_argc));+    PUT(dict, ""base_arg"", INTEGER_OBJ(fn->base_arg));+    PUT(dict, ""fast"", BOOLEAN_OBJ(fn->fast));++    // Argument names+    if (fn->argnames != NULL) {+      Array overloads = ARRAY_DICT_INIT;+      Array names = ARRAY_DICT_INIT;+      char buf[64] = { 0 };+      size_t pos = 0;++      // Argument are separated with unit separator (ascii \x1F),+      // overloads with record separator (ascii \x1E).+      for (const char *p = fn->argnames;; p++) {+        if (*p == NUL || *p == '\x1F' || *p == '\x1E') {+          assert(pos < 64);+          buf[pos++] = NUL;+          String str = {+            .data = xmemdupz(buf, pos),+            .size = pos - 1,+          };+          pos = 0;++          if (*p == '\x1F') {  // unit separator: argument separator+            kv_push(names, STRING_OBJ(str));+          } else if (*p == '\x1E') {  // record separator: overload separator+            kv_push(names, STRING_OBJ(str));+            kv_push(overloads, ARRAY_OBJ(names));+            names = (Array)ARRAY_DICT_INIT;+          } else {  // NUL+            kv_push(names, STRING_OBJ(str));+            kv_push(overloads, ARRAY_OBJ(names));+            break;+          }+        } else {+          buf[pos++] = *p;+        }+      }++      PUT(dict, ""argnames"", ARRAY_OBJ(overloads));+    }+  }++  return dict;+}++/// Lists Vimscript functions.+///+/// @param query    When string gets information about the function under this name.+///                 When dictionary lists functions. The following keys are accepted:","Dictionary is `{ builtin = true/false, user = true/false }`, and it returns a list of functions of requested types (builtin/user).I'm also not 100% sure if switching the behavior between ""get one function"" and ""list all functions"" based on the argument type is a right thing to do here. I wonder if it wouldn't be better to take a single dictionary argument and make it consistent with `nvim_get_commands`. Both API functions could act like this:- `nvim_get_*({ name = 'foo' })` -> returns a single function/command ""foo""- `nvim_get_*({ user = true })` -> lists all user functions/commands- `nvim_get_*({ builtin = true })` -> lists all builtin functions/commands- `nvim_get_*({ user = true, builtin = true })` -> lists all functions/commands, both builtin and user- `nvim_get_*({ name = 'foo', user = true })` -> error, can't use both at the same time",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19924,953898413,2022-08-24T14:46:47Z,CONTRIBUTING.md,"@@ -266,6 +266,41 @@ For managing includes in C files, use [include-what-you-use].  See [#549][549] for more details. +Documenting+-----------++Many parts of the `:help` documentation are autogenerated from C or Lua docstrings using the `./scripts/gen_vimdoc.py` script.+You can filter the regeneration based on the target (api, lua, or lsp), or the file you changed, that need a doc refresh.++## Lua doc comments++A doc comment in Lua should roughly follow this template:++```lua+--- {Brief}+---+--- {Long explanation}+---+---@param arg1 type {description}+---@param arg2 type {description}+{...}+---+---@return type {description}+```++If possible, always add type information (`table`, `string`, `number`, ...). Multiple valid types are separated by a bar (`string|table`). Indicate optional parameters via `type|nil`.",I think longer term we should fully adopt emmylua. Right now we're inconsistently using some rough subset.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19947,955036568,2022-08-25T14:24:49Z,src/nvim/ex_eval_defs.h,"@@ -6,7 +6,7 @@ /// There is no CSF_IF, the lack of CSF_WHILE, CSF_FOR and CSF_TRY means "":if"" /// was used. enum {-  CSF_TRUE     = 0x0001,  ///< condition was TRUE+  CSF_TRUE     = 0x0001,  ///< condition was true","```						*TRUE* *FALSE* *Boolean*For boolean operators Numbers are used.  Zero is FALSE, non-zero is TRUE.You can also use |v:false| and |v:true|, in Vim9 script |false| and |true|.When TRUE is returned from a function it is the Number one, FALSE is thenumber zero.``````						*false* *true* *null* *E1034*In Vim9 script one can use the following predefined values: >	true	false	null	null_blob	null_channel	null_dict	null_function	null_job	null_list	null_partial	null_string`true` is the same as `v:true`, `false` the same as `v:false`, `null` the sameas `v:null`.```",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19947,955145168,2022-08-25T15:52:14Z,src/nvim/if_cscope.c,"@@ -839,7 +839,7 @@ static int cs_create_connection(size_t i)     si.hStdOutput = stdout_wr;     si.hStdError  = stdout_wr;     si.hStdInput  = stdin_rd;-    created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,+    created = CreateProcess(NULL, cmd, NULL, NULL, true, CREATE_NEW_CONSOLE,","That's always been the case since the defines were always guarded:```c#ifndef TRUE# define FALSE  0           // note: this is an int, not a long!# define TRUE   1#endif```So I think we can assume TRUE is always defined as 1.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19877,955267172,2022-08-25T17:58:19Z,src/nvim/api/options.c,"@@ -256,10 +256,10 @@ void nvim_set_option(uint64_t channel_id, String name, Object value, Error *err) /// @param name     Option name /// @param[out] err Error details, if any /// @return         Option value (global)-Object nvim_get_option(String name, Error *err)+Object nvim_get_option(uint64_t channel_id, String name, Error *err)",for options you could remove the `uint64_t channel_id` argument and instead add `Arena* arena` argument and then use the non-allocating branch unconditionally (also for nvim_get_option_value),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17117,955581161,2022-08-26T02:09:55Z,runtime/doc/lua.txt,"@@ -1536,6 +1536,27 @@ deepcopy({orig})                                              *vim.deepcopy()*     Return: ~         (table) Table of copied keys and (nested) values. +defaulttable({create})                                    *vim.defaulttable()*","we have `vim.empty_dict`. We should try to use consistent naming. Unless this also supports list-like tables, I guess `defaultdict` is preferrable?",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17117,955727768,2022-08-26T07:10:32Z,runtime/doc/lua.txt,"@@ -1536,6 +1536,27 @@ deepcopy({orig})                                              *vim.deepcopy()*     Return: ~         (table) Table of copied keys and (nested) values. +defaulttable({create})                                    *vim.defaulttable()*","`vim.empty_dict` is for use with the viml bridge as vim has dictionaries. Lua does not have dictionaries, it has tables, a superset of dictionaries, so this is the naming we should use.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19969,956572231,2022-08-27T11:33:05Z,src/nvim/po/zh_TW.UTF-8.po,"@@ -6272,7 +6289,7 @@ msgstr ""������������ mapping ������""  #: ../undo.c:2330 msgid ""number changes  when               saved""-msgstr """"+msgstr ""���������������        ������""",Look at the output of `:undolist` in a buffer with modifications.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19993,957537953,2022-08-29T16:14:15Z,src/nvim/getchar.c,"@@ -1768,7 +1768,7 @@ static void getchar_common(typval_T *argvars, typval_T *rettv)    if (!ui_has_messages()) {     // redraw the screen after getchar()-    update_screen(UPD_CLEAR);+    update_screen(UPD_NOT_VALID);","This should just be `update_screen(0)` and also delete the useless jump `ui_cursor_goto(msg_row, msg_col)` above. Although we could do it in a follow-up PR to not mix it with the vim-patch",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/19977,957580260,2022-08-29T16:59:58Z,runtime/lua/vim/lsp/handlers.lua,"@@ -512,6 +512,64 @@ M['window/showMessage'] = function(_, result, ctx, _)   return result end +--see: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#window_showDocument+M['window/showDocument'] = function(_, result, ctx, _)+  local uri = result.uri++  if result.external then+    local cmd+    if vim.fn.has('win32') == 1 then+      cmd = { 'cmd.exe', '/c', 'start', '""""', vim.fn.shellescape(uri) }+    else+      cmd = { 'xdg-open', vim.fn.shellescape(uri) }+    end++    local res = vim.fn.system(cmd)+    if vim.v.shellerror ~= 0 then+      return {+        success = false,+        error = {+          code = protocol.ErrorCodes.UnknownErrorCode,+          message = res,+        },+      }+    end++    return { success = true }+  end++  local client_id = ctx.client_id+  local client = vim.lsp.get_client_by_id(client_id)+  local client_name = client and client.name or string.format('id=%d', client_id)+  if not client then+    err_message({ 'LSP[', client_name, '] client has shut down after sending ', ctx.method })+    return vim.NIL+  end++  local location = {+    uri = uri,+    range = result.selection or { start = { line = 0, character = 0 } },+  }++  local success+  local set_cursor = result.selection and true or false++  local prev = vim.api.nvim_get_current_win()+  if not result.takeFocus then+    local bufnr = vim.uri_to_bufnr(uri)+    if vim.fn.bufwinid(bufnr) == -1 then+      vim.cmd('new')+    end+  end++  success = util.jump_to_location(location, client.offset_encoding, true, set_cursor)",Could consider making `range` of `location` nullable as replacement for the `set_cursor` parameter.Would keep the API smaller and make it more explicit that there was no range.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20000,958075518,2022-08-30T06:55:44Z,src/nvim/eval.c,"@@ -5985,7 +5985,7 @@ void timer_due_cb(TimeWatcher *tw, void *data)   // Handle error message   if (called_emsg > called_emsg_before && did_emsg) {     timer->emsg_count++;-    if (current_exception != NULL) {+    if (did_throw) {","This is probably not what the code here is intended to do. The corresponding code in Vim (<https://github.com/vim/vim/commit/c577d813b7978345dec4310b2d8f5d5624a681f6>) saves `did_throw` and doesn't discard exception if `did_throw` is previously set. Not sure if this can happen in Nvim though, as Nvim processes timers on the main loop.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19912,960235048,2022-09-01T05:35:43Z,runtime/lua/man.lua,"@@ -152,21 +220,529 @@ local function highlight_line(line, linenr) end  local function highlight_man_page()-  local mod = vim.api.nvim_buf_get_option(0, 'modifiable')-  vim.api.nvim_buf_set_option(0, 'modifiable', true)+  local mod = vim.bo.modifiable+  vim.bo.modifiable = true -  local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)+  local lines = api.nvim_buf_get_lines(0, 0, -1, false)   for i, line in ipairs(lines) do     lines[i] = highlight_line(line, i)   end-  vim.api.nvim_buf_set_lines(0, 0, -1, false, lines)+  api.nvim_buf_set_lines(0, 0, -1, false, lines)    for _, args in ipairs(buf_hls) do-    vim.api.nvim_buf_add_highlight(unpack(args))+    api.nvim_buf_add_highlight(unpack(args))   end   buf_hls = {} -  vim.api.nvim_buf_set_option(0, 'modifiable', mod)+  vim.bo.modifiable = mod+end++-- replace spaces in a man page name with underscores+-- intended for PostgreSQL, which has man pages like 'CREATE_TABLE(7)';+-- while editing SQL source code, it's nice to visually select 'CREATE TABLE'+-- and hit 'K', which requires this transformation+local function spaces_to_underscores(str)+  local res = str:gsub('%s', '_')+  return res+end++local function get_path(sect, name, silent)+  name = name or ''+  sect = sect or ''+  -- Some man implementations (OpenBSD) return all available paths from the+  -- search command. Previously, this function would simply select the first one.+  --+  -- However, some searches will report matches that are incorrect:+  -- man -w strlen may return string.3 followed by strlen.3, and therefore+  -- selecting the first would get us the wrong page. Thus, we must find the+  -- first matching one.+  --+  -- There's yet another special case here. Consider the following:+  -- If you run man -w strlen and string.3 comes up first, this is a problem. We+  -- should search for a matching named one in the results list.+  -- However, if you search for man -w clock_gettime, you will *only* get+  -- clock_getres.2, which is the right page. Searching the resuls for+  -- clock_gettime will no longer work. In this case, we should just use the+  -- first one that was found in the correct section.+  --+  -- Finally, we can avoid relying on -S or -s here since they are very+  -- inconsistently supported. Instead, call -w with a section and a name.+  local cmd+  if not sect or sect == '' then+    cmd = { 'man', find_arg, name }+  else+    cmd = { 'man', find_arg, sect, name }+  end++  local lines = man_system(cmd, silent)+  if lines == nil then+    return nil+  end++  local results = vim.split(lines, '\n')++  if #results == 0 then+    return+  end++  -- find any that match the specified name+  local namematches = vim.tbl_filter(function(v)+    return fn.fnamemodify(v, ':t'):match(name)+  end, results) or {}+  local sectmatches = {}++  if #namematches > 0 and sect ~= '' then+    sectmatches = vim.tbl_filter(function(v)+      return fn.fnamemodify(v, ':e') == sect+    end, namematches)+  end++  return fn.substitute(sectmatches[1] or namematches[1] or results[1], [[\n\+$]], '', '')+end++local function matchstr(text, pat_or_re)+  local re = type(pat_or_re) == 'string' and vim.regex(pat_or_re) or pat_or_re++  local s, e = re:match_str(text)++  if s == nil then+    return+  end++  return text:sub(vim.str_utfindex(text, s) + 1, vim.str_utfindex(text, e)) end -return { highlight_man_page = highlight_man_page }+-- attempt to extract the name and sect out of 'name(sect)'+-- otherwise just return the largest string of valid characters in ref+local function extract_sect_and_name_ref(ref)+  ref = ref or ''+  if ref:sub(1, 1) == '-' then -- try ':Man -pandoc' with this disabled.+    man_error(""manpage name cannot start with '-'"")+  end+  local ref1 = ref:match('[^()]+%([^()]+%)')+  if not ref1 then+    local name = ref:match('[^()]+')+    if not name then+      man_error('manpage reference cannot contain only parentheses: ' .. ref)+    end+    return '', spaces_to_underscores(name)+  end+  local parts = vim.split(ref1, '(', { plain = true })+  -- see ':Man 3X curses' on why tolower.+  -- TODO(nhooyr) Not sure if this is portable across OSs+  -- but I have not seen a single uppercase section.+  local sect = vim.split(parts[2] or '', ')', { plain = true })[1]:lower()+  local name = spaces_to_underscores(parts[1])+  return sect, name+end++-- verify_exists attempts to find the path to a manpage+-- based on the passed section and name.+--+-- 1. If manpage could not be found with the given sect and name,+--    then try all the sections in b:man_default_sects.+-- 2. If it still could not be found, then we try again without a section.+-- 3. If still not found but $MANSECT is set, then we try again with $MANSECT+--    unset.+local function verify_exists(sect, name)+  if sect and sect ~= '' then+    local ret = get_path(sect, name, true)+    if ret then+      return ret+    end+  end++  if vim.b.man_default_sects ~= nil then+    local sects = vim.split(vim.b.man_default_sects, ',', { plain = true })+    for _, sec in ipairs(sects) do+      local ret = get_path(sec, name, true)+      if ret then+        return ret+      end+    end+  end++  -- if none of the above worked, we will try with no section+  local res_empty_sect = get_path('', name, true)+  if res_empty_sect then+    return res_empty_sect+  end++  -- if that still didn't work, we will check for $MANSECT and try again with it+  -- unset+  if vim.env.MANSECT then+    local mansect = vim.env.MANSECT+    vim.env.MANSECT = nil+    local res = get_path('', name, true)+    vim.env.MANSECT = mansect+    if res then+      return res+    end+  end++  -- finally, if that didn't work, there is no hope+  man_error('no manual entry for ' .. name)+end++local EXT_RE = vim.regex([[\.\%([glx]z\|bz2\|lzma\|Z\)$]])++-- Extracts the name/section from the 'path/name.sect', because sometimes the actual section is+-- more specific than what we provided to `man` (try `:Man 3 App::CLI`).+-- Also on linux, name seems to be case-insensitive. So for `:Man PRIntf`, we+-- still want the name of the buffer to be 'printf'.+local function extract_sect_and_name_path(path)+  local tail = fn.fnamemodify(path, ':t')+  if EXT_RE:match_str(path) then -- valid extensions+    tail = fn.fnamemodify(tail, ':r')+  end+  local name, sect = tail:match('^(.+)%.([^.]+)$')+  return sect, name+end++local function find_man()+  local win = 1+  while win <= fn.winnr('$') do+    local buf = fn.winbufnr(win)+    if vim.bo[buf].filetype == 'man' then+      vim.cmd(win .. 'wincmd w')+      return true+    end+    win = win + 1+  end+  return false+end++local function set_options(pager)+  vim.bo.swapfile = false+  vim.bo.buftype = 'nofile'+  vim.bo.bufhidden = 'hide'+  vim.bo.modified = false+  vim.bo.readonly = true+  vim.bo.modifiable = false+  vim.b.pager = pager+  vim.bo.filetype = 'man'+end++local function get_page(path, silent)+  -- Disable hard-wrap by using a big $MANWIDTH (max 1000 on some systems #9065).+  -- Soft-wrap: ftplugin/man.lua sets wrap/breakindent/���.+  -- Hard-wrap: driven by `man`.+  local manwidth+  if (vim.g.man_hardwrap or 1) ~= 1 then+    manwidth = 999+  elseif vim.env.MANWIDTH then+    manwidth = vim.env.MANWIDTH+  else+    manwidth = api.nvim_win_get_width(0)+  end+  -- Force MANPAGER=cat to ensure Vim is not recursively invoked (by man-db).+  -- http://comments.gmane.org/gmane.editors.vim.devel/29085+  -- Set MAN_KEEP_FORMATTING so Debian man doesn't discard backspaces.+  local cmd = { 'env', 'MANPAGER=cat', 'MANWIDTH=' .. manwidth, 'MAN_KEEP_FORMATTING=1', 'man' }+  if localfile_arg then+    cmd[#cmd + 1] = '-l'+  end+  cmd[#cmd + 1] = path+  return man_system(cmd, silent)+end++local function put_page(page)+  vim.bo.modified = true+  vim.bo.readonly = false+  vim.bo.swapfile = false++  api.nvim_buf_set_lines(0, 0, -1, false, vim.split(page, '\n'))++  while fn.getline(1):match('^%s*$') do+    api.nvim_buf_set_lines(0, 0, 1, false, {})+  end+  -- XXX: nroff justifies text by filling it with whitespace.  That interacts+  -- badly with our use of $MANWIDTH=999.  Hack around this by using a fixed+  -- size for those whitespace regions.+  vim.cmd([[silent! keeppatterns keepjumps %s/\s\{199,}/\=repeat(' ', 10)/g]])+  vim.cmd('1') -- Move cursor to first line+  highlight_man_page()+  set_options(false)+end++local function format_candidate(path, psect)+  if matchstr(path, [[\.\%(pdf\|in\)$]]) then -- invalid extensions+    return ''+  end+  local sect, name = extract_sect_and_name_path(path)+  if sect == psect then+    return name+  elseif sect and name and matchstr(sect, psect .. '.\\+$') then -- invalid extensions+    -- We include the section if the user provided section is a prefix+    -- of the actual section.+    return ('%s(%s)'):format(name, sect)+  end+  return ''+end++local function get_paths(sect, name, do_fallback)+  -- callers must try-catch this, as some `man` implementations don't support `s:find_arg`+  local ok, ret = pcall(function()+    local mandirs = table.concat(vim.split(man_system({ 'man', find_arg }), '[:\n]'), ',')+    local paths = fn.globpath(mandirs, 'man?/' .. name .. '*.' .. sect .. '*', false, true)+    pcall(function()+      -- Prioritize the result from verify_exists as it obeys b:man_default_sects.+      local first = verify_exists(sect, name)+      paths = vim.tbl_filter(function(v)+        return v ~= first+      end, paths)+      paths = { first, unpack(paths) }+    end)+    return paths+  end)++  if not ok then+    if not do_fallback then+      error(ret)+    end++    -- Fallback to a single path, with the page we're trying to find.+    ok, ret = pcall(verify_exists, sect, name)++    return { ok and ret or nil }+  end+  return ret or {}+end++local function complete(sect, psect, name)+  local pages = get_paths(sect, name, false)+  -- We remove duplicates in case the same manpage in different languages was found.+  return fn.uniq(fn.sort(vim.tbl_map(function(v)+    return format_candidate(v, psect)+  end, pages) or {}, 'i'))+end++-- see extract_sect_and_name_ref on why tolower(sect)+function M.man_complete(arg_lead, cmd_line, _)+  -- TODO(lewis6991): for some reason using vim.fn.split here makes completion very laggy+  local args = vim.split(cmd_line, '%s+')","Currently completion results contain empty strings. When I tried adding `trimempty = true` to some other `vim.split()`, empty strings no longer appear.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19912,960432516,2022-09-01T09:33:33Z,runtime/lua/man.lua,"@@ -152,21 +220,529 @@ local function highlight_line(line, linenr) end  local function highlight_man_page()-  local mod = vim.api.nvim_buf_get_option(0, 'modifiable')-  vim.api.nvim_buf_set_option(0, 'modifiable', true)+  local mod = vim.bo.modifiable+  vim.bo.modifiable = true -  local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)+  local lines = api.nvim_buf_get_lines(0, 0, -1, false)   for i, line in ipairs(lines) do     lines[i] = highlight_line(line, i)   end-  vim.api.nvim_buf_set_lines(0, 0, -1, false, lines)+  api.nvim_buf_set_lines(0, 0, -1, false, lines)    for _, args in ipairs(buf_hls) do-    vim.api.nvim_buf_add_highlight(unpack(args))+    api.nvim_buf_add_highlight(unpack(args))   end   buf_hls = {} -  vim.api.nvim_buf_set_option(0, 'modifiable', mod)+  vim.bo.modifiable = mod+end++-- replace spaces in a man page name with underscores+-- intended for PostgreSQL, which has man pages like 'CREATE_TABLE(7)';+-- while editing SQL source code, it's nice to visually select 'CREATE TABLE'+-- and hit 'K', which requires this transformation+local function spaces_to_underscores(str)+  local res = str:gsub('%s', '_')+  return res+end++local function get_path(sect, name, silent)+  name = name or ''+  sect = sect or ''+  -- Some man implementations (OpenBSD) return all available paths from the+  -- search command. Previously, this function would simply select the first one.+  --+  -- However, some searches will report matches that are incorrect:+  -- man -w strlen may return string.3 followed by strlen.3, and therefore+  -- selecting the first would get us the wrong page. Thus, we must find the+  -- first matching one.+  --+  -- There's yet another special case here. Consider the following:+  -- If you run man -w strlen and string.3 comes up first, this is a problem. We+  -- should search for a matching named one in the results list.+  -- However, if you search for man -w clock_gettime, you will *only* get+  -- clock_getres.2, which is the right page. Searching the resuls for+  -- clock_gettime will no longer work. In this case, we should just use the+  -- first one that was found in the correct section.+  --+  -- Finally, we can avoid relying on -S or -s here since they are very+  -- inconsistently supported. Instead, call -w with a section and a name.+  local cmd+  if not sect or sect == '' then+    cmd = { 'man', find_arg, name }+  else+    cmd = { 'man', find_arg, sect, name }+  end++  local lines = man_system(cmd, silent)+  if lines == nil then+    return nil+  end++  local results = vim.split(lines, '\n')++  if #results == 0 then+    return+  end++  -- find any that match the specified name+  local namematches = vim.tbl_filter(function(v)+    return fn.fnamemodify(v, ':t'):match(name)+  end, results) or {}+  local sectmatches = {}++  if #namematches > 0 and sect ~= '' then+    sectmatches = vim.tbl_filter(function(v)+      return fn.fnamemodify(v, ':e') == sect+    end, namematches)+  end++  return fn.substitute(sectmatches[1] or namematches[1] or results[1], [[\n\+$]], '', '')+end++local function matchstr(text, pat_or_re)+  local re = type(pat_or_re) == 'string' and vim.regex(pat_or_re) or pat_or_re++  local s, e = re:match_str(text)++  if s == nil then+    return+  end++  return text:sub(vim.str_utfindex(text, s) + 1, vim.str_utfindex(text, e)) end -return { highlight_man_page = highlight_man_page }+-- attempt to extract the name and sect out of 'name(sect)'+-- otherwise just return the largest string of valid characters in ref+local function extract_sect_and_name_ref(ref)+  ref = ref or ''+  if ref:sub(1, 1) == '-' then -- try ':Man -pandoc' with this disabled.+    man_error(""manpage name cannot start with '-'"")+  end+  local ref1 = ref:match('[^()]+%([^()]+%)')+  if not ref1 then+    local name = ref:match('[^()]+')+    if not name then+      man_error('manpage reference cannot contain only parentheses: ' .. ref)+    end+    return '', spaces_to_underscores(name)+  end+  local parts = vim.split(ref1, '(', { plain = true })+  -- see ':Man 3X curses' on why tolower.+  -- TODO(nhooyr) Not sure if this is portable across OSs+  -- but I have not seen a single uppercase section.+  local sect = vim.split(parts[2] or '', ')', { plain = true })[1]:lower()+  local name = spaces_to_underscores(parts[1])+  return sect, name+end++-- verify_exists attempts to find the path to a manpage+-- based on the passed section and name.+--+-- 1. If manpage could not be found with the given sect and name,+--    then try all the sections in b:man_default_sects.+-- 2. If it still could not be found, then we try again without a section.+-- 3. If still not found but $MANSECT is set, then we try again with $MANSECT+--    unset.+local function verify_exists(sect, name)+  if sect and sect ~= '' then+    local ret = get_path(sect, name, true)+    if ret then+      return ret+    end+  end++  if vim.b.man_default_sects ~= nil then+    local sects = vim.split(vim.b.man_default_sects, ',', { plain = true })+    for _, sec in ipairs(sects) do+      local ret = get_path(sec, name, true)+      if ret then+        return ret+      end+    end+  end++  -- if none of the above worked, we will try with no section+  local res_empty_sect = get_path('', name, true)+  if res_empty_sect then+    return res_empty_sect+  end++  -- if that still didn't work, we will check for $MANSECT and try again with it+  -- unset+  if vim.env.MANSECT then+    local mansect = vim.env.MANSECT+    vim.env.MANSECT = nil+    local res = get_path('', name, true)+    vim.env.MANSECT = mansect+    if res then+      return res+    end+  end++  -- finally, if that didn't work, there is no hope+  man_error('no manual entry for ' .. name)+end++local EXT_RE = vim.regex([[\.\%([glx]z\|bz2\|lzma\|Z\)$]])++-- Extracts the name/section from the 'path/name.sect', because sometimes the actual section is+-- more specific than what we provided to `man` (try `:Man 3 App::CLI`).+-- Also on linux, name seems to be case-insensitive. So for `:Man PRIntf`, we+-- still want the name of the buffer to be 'printf'.+local function extract_sect_and_name_path(path)+  local tail = fn.fnamemodify(path, ':t')+  if EXT_RE:match_str(path) then -- valid extensions+    tail = fn.fnamemodify(tail, ':r')+  end+  local name, sect = tail:match('^(.+)%.([^.]+)$')+  return sect, name+end++local function find_man()+  local win = 1+  while win <= fn.winnr('$') do+    local buf = fn.winbufnr(win)+    if vim.bo[buf].filetype == 'man' then+      vim.cmd(win .. 'wincmd w')+      return true+    end+    win = win + 1+  end+  return false+end++local function set_options(pager)+  vim.bo.swapfile = false+  vim.bo.buftype = 'nofile'+  vim.bo.bufhidden = 'hide'+  vim.bo.modified = false+  vim.bo.readonly = true+  vim.bo.modifiable = false+  vim.b.pager = pager+  vim.bo.filetype = 'man'+end++local function get_page(path, silent)+  -- Disable hard-wrap by using a big $MANWIDTH (max 1000 on some systems #9065).+  -- Soft-wrap: ftplugin/man.lua sets wrap/breakindent/���.+  -- Hard-wrap: driven by `man`.+  local manwidth+  if (vim.g.man_hardwrap or 1) ~= 1 then+    manwidth = 999+  elseif vim.env.MANWIDTH then+    manwidth = vim.env.MANWIDTH+  else+    manwidth = api.nvim_win_get_width(0)+  end+  -- Force MANPAGER=cat to ensure Vim is not recursively invoked (by man-db).+  -- http://comments.gmane.org/gmane.editors.vim.devel/29085+  -- Set MAN_KEEP_FORMATTING so Debian man doesn't discard backspaces.+  local cmd = { 'env', 'MANPAGER=cat', 'MANWIDTH=' .. manwidth, 'MAN_KEEP_FORMATTING=1', 'man' }+  if localfile_arg then+    cmd[#cmd + 1] = '-l'+  end+  cmd[#cmd + 1] = path+  return man_system(cmd, silent)+end++local function put_page(page)+  vim.bo.modified = true+  vim.bo.readonly = false+  vim.bo.swapfile = false++  api.nvim_buf_set_lines(0, 0, -1, false, vim.split(page, '\n'))++  while fn.getline(1):match('^%s*$') do+    api.nvim_buf_set_lines(0, 0, 1, false, {})+  end+  -- XXX: nroff justifies text by filling it with whitespace.  That interacts+  -- badly with our use of $MANWIDTH=999.  Hack around this by using a fixed+  -- size for those whitespace regions.+  vim.cmd([[silent! keeppatterns keepjumps %s/\s\{199,}/\=repeat(' ', 10)/g]])+  vim.cmd('1') -- Move cursor to first line+  highlight_man_page()+  set_options(false)+end++local function format_candidate(path, psect)+  if matchstr(path, [[\.\%(pdf\|in\)$]]) then -- invalid extensions+    return ''+  end+  local sect, name = extract_sect_and_name_path(path)+  if sect == psect then+    return name+  elseif sect and name and matchstr(sect, psect .. '.\\+$') then -- invalid extensions+    -- We include the section if the user provided section is a prefix+    -- of the actual section.+    return ('%s(%s)'):format(name, sect)+  end+  return ''+end++local function get_paths(sect, name, do_fallback)+  -- callers must try-catch this, as some `man` implementations don't support `s:find_arg`+  local ok, ret = pcall(function()+    local mandirs = table.concat(vim.split(man_system({ 'man', find_arg }), '[:\n]'), ',')+    local paths = fn.globpath(mandirs, 'man?/' .. name .. '*.' .. sect .. '*', false, true)+    pcall(function()+      -- Prioritize the result from verify_exists as it obeys b:man_default_sects.+      local first = verify_exists(sect, name)+      paths = vim.tbl_filter(function(v)+        return v ~= first+      end, paths)+      paths = { first, unpack(paths) }+    end)+    return paths+  end)++  if not ok then+    if not do_fallback then+      error(ret)+    end++    -- Fallback to a single path, with the page we're trying to find.+    ok, ret = pcall(verify_exists, sect, name)++    return { ok and ret or nil }","We don't want to return a list of a list here.If `ok` we return `{ ret }`, if `not ok` we return `{}`.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/14537,960743465,2022-09-01T14:42:30Z,src/nvim/lua/xdiff.c,"@@ -61,20 +66,90 @@ static int hunk_locations_cb(long start_a, long count_a, long start_b, long coun   if (count_b > 0) {     start_b += 1;   }-   lua_State *lstate = (lua_State *)cb_data;-  lua_createtable(lstate, 0, 0);+  if (linematch) {+    const char **diff_begin = xmalloc(sizeof(char *) * 2);+    int *diff_length = xmalloc(sizeof(int) * 2);+    diff_begin[0] = sma.ptr;",You should be able to pass this via `cb_data` to avoid making it static. At the moment we just use `cb_data` to pass through `lstate`.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19419,961593920,2022-09-02T11:51:45Z,src/nvim/spell.c,"@@ -1309,22 +1310,32 @@ size_t spell_move_to(win_T *wp, int dir, bool allwords, bool curline, hlf_T *att                             ? p - buf + (ptrdiff_t)len                             : p - buf) > wp->w_cursor.col)) {             bool can_spell;++            char *decor_error = NULL;++            col = (colnr_T)(p - buf);++            (void)decor_provider_spell(wp, lnum - 1, col, &decor_error);+            DecorState tmp_state = { 0 };+            decor_redraw_start(wp->w_buffer, lnum - 1, &tmp_state);+            decor_redraw_line(wp->w_buffer, lnum - 1, &tmp_state);+            decor_redraw_col(wp->w_buffer, col, col, false, &tmp_state);","This makes sense. One note, however. In the context of our current TS highlighter, you need to do pretty much everything `on_line` does already (unless you make spell its own query), the only waste is the additional marks that get added to the temporary decor_state.Also only decor_providers with `spell = true` are called so it's not that expensive.This means you can emulate an `on_spell` callback with 2 decor providers:```luaa.nvim_set_decoration_provider(ns, {  on_line = on_line,  spell = false,})a.nvim_set_decoration_provider(ns2, {  on_line = on_spell,  spell = true,})```So either method works well IMO, it's just a case of which one has a nicer API.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20052,962098072,2022-09-03T03:45:21Z,src/nvim/option.c,"@@ -215,6 +216,29 @@ void set_init_1(bool clean_arg)     }   } +  /*+   * Find default value for 'spelllang' option.+   * Don't use it if it is empty.+   */+  {+    const char *lang = os_getenv(""LANG"");","there is already code checking for current locale. it's tricky. parsing an env var in the middle of the options logic is not a good start.and this suggests what I suspected, which is that this is not worth the effort.there is a cost also: documentation and troubleshooting become less predictable.",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/19419,962126650,2022-09-03T09:00:02Z,src/nvim/decoration_provider.c,"@@ -47,11 +48,32 @@ static bool decor_provider_invoke(NS ns_id, const char *name, LuaRef ref, Array   return false; } +bool decor_provider_invoke_spell(win_T *wp, linenr_T lnum, colnr_T col, char **err)+{+  bool ret = false;+  for (size_t i = 0; i < kv_size(decor_providers); i++) {+    DecorProvider *p = &kv_A(decor_providers, i);+    if (!p->active) {+      continue;+    }++    if (p->is_spell != LUA_NOREF) {+      MAXSIZE_TEMP_ARRAY(args, 4);+      ADD_C(args, INTEGER_OBJ(wp->handle));+      ADD_C(args, INTEGER_OBJ(wp->w_buffer->handle));+      ADD_C(args, INTEGER_OBJ(lnum - 1));+      ADD_C(args, INTEGER_OBJ(col - 1));+      ret |= decor_provider_invoke(p->ns_id, ""spell"", p->is_spell, args, true, err);+    }+  }+  return ret;+}","Given the output of the test though, this is not _that_ expensive and this is only called when a _badly spelled_ word is found.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19419,962127159,2022-09-03T09:04:49Z,src/nvim/decoration_provider.c,"@@ -47,11 +48,32 @@ static bool decor_provider_invoke(NS ns_id, const char *name, LuaRef ref, Array   return false; } +bool decor_provider_invoke_spell(win_T *wp, linenr_T lnum, colnr_T col, char **err)+{+  bool ret = false;+  for (size_t i = 0; i < kv_size(decor_providers); i++) {+    DecorProvider *p = &kv_A(decor_providers, i);+    if (!p->active) {+      continue;+    }++    if (p->is_spell != LUA_NOREF) {+      MAXSIZE_TEMP_ARRAY(args, 4);+      ADD_C(args, INTEGER_OBJ(wp->handle));+      ADD_C(args, INTEGER_OBJ(wp->w_buffer->handle));+      ADD_C(args, INTEGER_OBJ(lnum - 1));+      ADD_C(args, INTEGER_OBJ(col - 1));+      ret |= decor_provider_invoke(p->ns_id, ""spell"", p->is_spell, args, true, err);+    }+  }+  return ret;+}","I think we can be a little more general. Instead of once per line, we can provide a start position and an end line (or position, not sure). If `end < start` then it means go backwards. When called it basically means, ""I need to find the closest spelling error in this direction, populate me some extmarks so I can find them"".However, in practice, we will only call it per line until we can refactor `spell_move_to` more. This will slightly couple the ts highlighter to `spell_move_to` but that's fine since they are in the same codebase.> Given the output of the test though, this is not that expensive and this is only called when a badly spelled word is found.This assumes the implementation stays as it is. What if we wanted to find the marks first and then spell check?",
32016110,zbirenbaum,https://api.github.com/repos/neovim/neovim/pulls/19705,962187940,2022-09-03T18:14:14Z,runtime/lua/vim/diagnostic.lua,"@@ -879,7 +893,9 @@ M.handlers.signs = {       diagnostics = filter_by_severity(opts.signs.severity, diagnostics)     end -    define_default_signs()+    if opts.signs and opts.signs.filter then+      diagnostics = vim.tbl_map(opts.signs.filter, diagnostics)","I heavily considered making a filter taking all diagnostics as a parameter, but the last set of review notes was rather lengthy, and I wanted to prioritize getting things into a decent state before trying to figure out what the best way to do that would be. The issues is mostly consistency, since other handlers currently provide individual diagnostics. Maybe an option in the diagnostic config would be a good way to flag handlers to send the whole list, but I think that may need to be implemented  in another PR as clason said. @akinsho If you open a issue for discussing potential implementations and tag me on it, I'll PR it after we finish up with this one.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19705,962193815,2022-09-03T19:23:06Z,runtime/lua/vim/diagnostic.lua,"@@ -901,22 +917,54 @@ M.handlers.signs = {     end      local ns = M.get_namespace(namespace)-    if not ns.user_data.sign_group then-      ns.user_data.sign_group = string.format('vim.diagnostic.%s', ns.name)+    if not ns.user_data.sign_ns then+      local _sign_ns = string.format('vim.diagnostic.%s', ns.name)+      ns.user_data.sign_ns = vim.api.nvim_create_namespace(_sign_ns)+    end++    local sign_ns = ns.user_data.sign_ns++    local function resolve_sign(diagnostic)     end -    local sign_group = ns.user_data.sign_group     for _, diagnostic in ipairs(diagnostics) do-      vim.fn.sign_place(0, sign_group, sign_highlight_map[diagnostic.severity], bufnr, {-        priority = get_priority(diagnostic.severity),-        lnum = diagnostic.lnum + 1,-      })+      local sign_text+      if diagnostic.user_data.sign_text then+        sign_text = diagnostic.user_data.sign_text+      elseif opts.sign_text and opts.sign_text[diagnostic.severity] then+        sign_text = opts.sign_text[diagnostic.severity]+      else+        sign_text = get_fallback_sign(diagnostic.severity) or M.severity[diagnostic.severity]:sub(1,1)+      end++      local sign_hl_group+      if diagnostic.user_data.sign_hl_group then+        sign_hl_group = diagnostic.user_data.sign_hl_group+      else+        sign_hl_group = sign_highlight_map[diagnostic.severity]+      end++      if diagnostic.user_data.priority then+        priority = diagnostic.user_data.priority+      else+        priority = get_priority(diagnostic.severity)+      end","`user_data` is a catch-all table, to avoid potential collisions call this `sign_priority`.```suggestion      if diagnostic.user_data.sign_priority then        priority = diagnostic.user_data.sign_priority      else        priority = get_priority(diagnostic.severity)      end```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/19705,962194908,2022-09-03T19:37:28Z,runtime/lua/vim/diagnostic.lua,"@@ -643,6 +619,36 @@ end ---                * priority: (number, default 10) Base priority to use for signs. When ---                {severity_sort} is used, the priority of a sign is adjusted based on ---                its severity. Otherwise, all signs use the same priority.+---                * sign_text: (table) Table of vim.diagnostic.severity symbol pairs.+---                Text values in this table take priority over existing sign definitions+---                but will not be prioritized over a sign_text field in the user data of an individual+---                diagnostic. Individual diagnostic's sign_text can be set within a function+---                passed to the filter parameter.+---                * filter: (function) A function which will be run prior to determining the signs+---                This function takes an individual diagnostic as a parameter and can be used to filter+---                or otherwise customize how signs will appear by setting the sign_text, sign_hl_group or+---                priority fields for the diagnostic. If a diagnostic is not returned, no sign will be created","```suggestion---                * filter: (function) A function which takes an individual diagnostic as its---                single argument and optionally returns a diagnostic. It can be used to filter or---                otherwise customize how signs will appear by setting the ""sign_text"",---                ""sign_hl_group"", or ""sign_priority"" fields in the diagnostic's ""user_data"" table.---                If nil is returned, no sign is created for the given diagnostic.```",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/13389,962320117,2022-09-04T14:07:01Z,runtime/lua/vim/treesitter.lua,"@@ -96,4 +98,38 @@ function M.get_string_parser(str, lang, opts)   return LanguageTree.new(str, lang, opts) end +local function setup_highlight_for_buf(bufnr)+    -- Setup treesitter highlighting for new buffer+    local ft = a.nvim_buf_get_option(bufnr, ""ft"")+    if not pcall(language.require_language, ft) then return end++    local tree = M.get_parser(bufnr, ft)+    M.highlighter.new(tree)","still, `:set treesitter=hl` should not cause `syntax=off`. Both should be changed independently from each otherWhat I mean is that this line should be removed https://github.com/theHamsta/neovim/blob/0946958b7327d53bfbf9bbf87e03326bea3d8fa2/runtime/lua/vim/treesitter/highlighter.lua#L89 as `:set treesitter=hl` will implicitly influence `syntax`",X
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15391,962341228,2022-09-04T16:43:43Z,cmake.deps/cmake/BuildTreesitterParsers.cmake,"@@ -1,29 +1,32 @@-ExternalProject_Add(treesitter-c-PREFIX ${DEPS_BUILD_DIR}-URL ${TREESITTER_C_URL}-DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/treesitter-c-DOWNLOAD_COMMAND ${CMAKE_COMMAND}-  -DPREFIX=${DEPS_BUILD_DIR}-  -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/treesitter-c-  -DURL=${TREESITTER_C_URL}-  -DEXPECTED_SHA256=${TREESITTER_C_SHA256}-  -DTARGET=treesitter-c-  -DUSE_EXISTING_SRC_DIR=${USE_EXISTING_SRC_DIR}-  -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake-PATCH_COMMAND ${CMAKE_COMMAND} -E copy-  ${CMAKE_CURRENT_SOURCE_DIR}/cmake/TreesitterParserCMakeLists.txt-        ${DEPS_BUILD_DIR}/src/treesitter-c/CMakeLists.txt-CMAKE_ARGS-  -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}-  -DCMAKE_GENERATOR=${CMAKE_GENERATOR}-  -DCMAKE_GENERATOR_PLATFORM=${CMAKE_GENERATOR_PLATFORM}-  ${BUILD_TYPE_STRING}-  -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR}-  -DCMAKE_OSX_ARCHITECTURES=${CMAKE_OSX_ARCHITECTURES_ALT_SEP}-  # Pass toolchain-  -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TOOLCHAIN_FILE}-  -DPARSERLANG=c+function(BuildTSParser LANG TS_URL TS_SHA256 TS_CMAKE_FILE)+  set(NAME treesitter-${LANG})+  ExternalProject_Add(${NAME}+  PREFIX ${DEPS_BUILD_DIR}+  URL ${TREESITTER_C_URL}+  DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/${NAME}+  DOWNLOAD_COMMAND ${CMAKE_COMMAND}+    -DPREFIX=${DEPS_BUILD_DIR}+    -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/${NAME}+    -DURL=${TS_URL}+    -DEXPECTED_SHA256=${TS_SHA256}+    -DTARGET=${NAME}+    -DUSE_EXISTING_SRC_DIR=${USE_EXISTING_SRC_DIR}+    -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake+  PATCH_COMMAND ${CMAKE_COMMAND} -E copy+      ${CMAKE_CURRENT_SOURCE_DIR}/cmake/${TS_CMAKE_FILE}+      ${DEPS_BUILD_DIR}/src/${NAME}/CMakeLists.txt+  CMAKE_ARGS+    -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}+    -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}","> nor is the patch command?Nah, the ""patching"" is necessary (technically not a patch, but it's the most convenient way to get cmake to work.)You can remove all arguments from `CMAKE_ARGS` (including the toolchain comment) except for `-DPARSERLANG` and `-DCMAKE_INSTALL_PREFIX`. Default for `CMAKE_INSTALL_PREFIX` is `/usr/local`.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/19705,962764590,2022-09-05T10:43:57Z,runtime/lua/vim/diagnostic.lua,"@@ -901,22 +917,54 @@ M.handlers.signs = {     end      local ns = M.get_namespace(namespace)-    if not ns.user_data.sign_group then-      ns.user_data.sign_group = string.format('vim.diagnostic.%s', ns.name)+    if not ns.user_data.sign_ns then+      local _sign_ns = string.format('vim.diagnostic.%s', ns.name)+      ns.user_data.sign_ns = vim.api.nvim_create_namespace(_sign_ns)+    end++    local sign_ns = ns.user_data.sign_ns++    local function resolve_sign(diagnostic)     end -    local sign_group = ns.user_data.sign_group     for _, diagnostic in ipairs(diagnostics) do-      vim.fn.sign_place(0, sign_group, sign_highlight_map[diagnostic.severity], bufnr, {-        priority = get_priority(diagnostic.severity),-        lnum = diagnostic.lnum + 1,-      })+      local sign_text+      if diagnostic.user_data.sign_text then+        sign_text = diagnostic.user_data.sign_text+      elseif opts.sign_text and opts.sign_text[diagnostic.severity] then+        sign_text = opts.sign_text[diagnostic.severity]+      else+        sign_text = get_fallback_sign(diagnostic.severity) or M.severity[diagnostic.severity]:sub(1,1)+      end++      local sign_hl_group+      if diagnostic.user_data.sign_hl_group then+        sign_hl_group = diagnostic.user_data.sign_hl_group+      else+        sign_hl_group = sign_highlight_map[diagnostic.severity]+      end",You can use a single assignment style here.```suggestion      local sign_hl_group = diagnostic.user_data.sign_hl_group                            or sign_highlight_map[diagnostic.severity]```,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15391,962866784,2022-09-05T12:41:04Z,runtime/CMakeLists.txt,"@@ -122,6 +122,14 @@ foreach(PROG ${RUNTIME_PROGRAMS})                  DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/nvim/runtime/${BASEDIR}) endforeach() +globrecurse_wrapper(RUNTIME_QUERIES ${CMAKE_CURRENT_SOURCE_DIR} *.scm)++foreach(QUERY ${RUNTIME_QUERIES})+  get_filename_component(BASEDIR ${QUERY} DIRECTORY)+  install_helper(FILES ${QUERY}+                 DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/nvim/runtime/${BASEDIR})+endforeach()","are these distinct from the `RUNTIME_FILES` below, or couldn't `*.scm` just be added to its list of extensions?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15391,962889368,2022-09-05T13:06:29Z,runtime/CMakeLists.txt,"@@ -122,6 +122,14 @@ foreach(PROG ${RUNTIME_PROGRAMS})                  DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/nvim/runtime/${BASEDIR}) endforeach() +globrecurse_wrapper(RUNTIME_QUERIES ${CMAKE_CURRENT_SOURCE_DIR} *.scm)++foreach(QUERY ${RUNTIME_QUERIES})+  get_filename_component(BASEDIR ${QUERY} DIRECTORY)+  install_helper(FILES ${QUERY}+                 DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/nvim/runtime/${BASEDIR})+endforeach()",Well for now it is just duplicate code. it is better to separate then only if there is some extra logic (and there are none yet).,X
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/20084,964494815,2022-09-07T07:41:25Z,runtime/lua/vim/lsp/handlers.lua,"@@ -265,20 +265,36 @@ M['textDocument/rename'] = function(_, result, ctx, _) end  --see: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_rangeFormatting-M['textDocument/rangeFormatting'] = function(_, result, ctx, _)-  if not result then+M['textDocument/rangeFormatting'] = function(err, result, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if err or not result then",This is taken care of by https://github.com/neovim/neovim/blob/ff9d2b17fb0f538b2b6d58c33c1568c699b0bb0e/runtime/lua/vim/lsp/handlers.lua#L515-L545,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19477,964837913,2022-09-07T13:23:53Z,runtime/lua/vim/_meta.lua,"@@ -198,7 +198,10 @@ end --                  Can be done in a separate PR. local key_value_options = {   fillchars = true,+  fcs = true,   listchars = true,+  lcs = true,+  winhighlight = true,   winhl = true,","Looks like the long vs. short option wasn't used consistently here, so this is good. How about the rest of this API? Does it cover both full name and abbreviation?",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19477,964874954,2022-09-07T13:52:44Z,runtime/lua/vim/_meta.lua,"@@ -198,7 +198,10 @@ end --                  Can be done in a separate PR. local key_value_options = {   fillchars = true,+  fcs = true,   listchars = true,+  lcs = true,+  winhighlight = true,   winhl = true,","It's like the comment above says, the metadata doesn't contain the information whether an option is a key-value map at the moment, so it has to be declared here. This is the only place where something like this is needed, everything else is taken from the metadata directly, and works the same for both short and full names.```lua-- TODO(tjdevries): Improve option metadata so that this doesn't have to be hardcoded.--                  Can be done in a separate PR.```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19477,964877651,2022-09-07T13:54:38Z,runtime/lua/vim/_meta.lua,"@@ -198,7 +198,10 @@ end --                  Can be done in a separate PR. local key_value_options = {   fillchars = true,+  fcs = true,   listchars = true,+  lcs = true,+  winhighlight = true,   winhl = true,","Thanks, that makes sense.And agreed, that should be reflected in the metadata (via `list='dict'` or somesuch), but that is something for 0.9.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20109,965002446,2022-09-07T15:37:11Z,src/nvim/testdir/test_window_cmd.vim,"@@ -1464,4 +1464,18 @@ func Test_win_move_statusline()   %bwipe! endfunc +func Test_win_equal_last_status()+  let save_lines = &lines+  set lines=20+  set splitbelow+  set laststatus=0++  split | split | quit+  call assert_equal(winheight(1), winheight(2))++  let &lines = save_lines+  set splitbelow&+  set laststatus&+endfunc+",`test_put.vim` does. It's better to avoid divergence from Vim in oldtest files.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17117,965440232,2022-09-08T02:13:41Z,runtime/doc/lua.txt,"@@ -1536,6 +1536,27 @@ deepcopy({orig})                                              *vim.deepcopy()*     Return: ~         (table) Table of copied keys and (nested) values. +defaulttable({create})                                    *vim.defaulttable()*","@lewis6991 not super clear which name you're in favor of. This `defaulttable()` concept doesn't apply to list-like tables, so shouldn't we name it `defaultdict()` ?We have things like `vim.list_extend`, but I agree that treating tables as tables is generally preferred.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17117,965605926,2022-09-08T07:33:47Z,runtime/doc/lua.txt,"@@ -1536,6 +1536,27 @@ deepcopy({orig})                                              *vim.deepcopy()*     Return: ~         (table) Table of copied keys and (nested) values. +defaulttable({create})                                    *vim.defaulttable()*","I think we could be better in general in the Lua API (especially `vim.tbl_*`) in distinguishing* list-like (integer-indexed, may have holes)* array-like (integer-indexed, must start at 1 and not have holes)* dict-like (key-indexed)tables.May be worth a general cleanup PR.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17117,965610065,2022-09-08T07:38:11Z,runtime/doc/lua.txt,"@@ -1536,6 +1536,27 @@ deepcopy({orig})                                              *vim.deepcopy()*     Return: ~         (table) Table of copied keys and (nested) values. +defaulttable({create})                                    *vim.defaulttable()*",Pretty sure this does work for list-like tables.```luaA[1][1][1] = 1```Should work.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17117,965611087,2022-09-08T07:39:02Z,runtime/doc/lua.txt,"@@ -1536,6 +1536,27 @@ deepcopy({orig})                                              *vim.deepcopy()*     Return: ~         (table) Table of copied keys and (nested) values. +defaulttable({create})                                    *vim.defaulttable()*","> * list-like (integer-indexed, may have holes)> * array-like (integer-indexed, must start at 1 and not have holes)This is the reverse of the terminology used in #16440",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/20118,966434482,2022-09-08T21:24:40Z,runtime/lua/vim/lsp/util.lua,"@@ -443,6 +443,7 @@ function M.apply_text_edits(text_edits, bufnr, offset_encoding)     }   end)() +  local is_windows = vim.loop.os_uname().sysname == 'Windows'",All right. I haven't used windows for a long time :),
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20131,967048804,2022-09-09T13:04:16Z,cmake/FindHunspell.cmake,"@@ -0,0 +1,11 @@+# - Try to find tree-sitter",and similarly for the other copypasta below ;),
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20134,967122999,2022-09-09T14:16:30Z,runtime/lua/vim/filetype.lua,"@@ -1825,6 +1826,14 @@ local pattern = {       return 'gitconfig'     end   end,+  ['.*%.git/info/attributes'] = 'gitattributes',+  ['.*/etc/gitattributes'] = 'gitattributes',+  ['.*/%.config/git/attributes'] = 'gitattributes',+  ['.*/git/attributes'] = function(path, bufnr)+    if vim.env.XDG_CONFIG_HOME and path:find(vim.env.XDG_CONFIG_HOME .. '/git/attributes') then","Not so sure about this. This makes the filetype detection dependent on an env var, and the file we are matching might not even be the file we are reading, i.e. if `path:find(vim.env.XDG_CONFIG_HOME .. '/git/attributes')` then any `.*/git/attirbutes` file will be detected.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/20057,967251584,2022-09-09T16:19:31Z,src/nvim/drawscreen.c,"@@ -699,42 +699,42 @@ static void win_redr_border(win_T *wp)   if (adj[0]) {     grid_puts_line_start(grid, 0);     if (adj[3]) {-      grid_put_schar(grid, 0, 0, chars[0], attrs[0]);+      grid_put_schar(grid, 0, 0, (char_u *)chars[0], attrs[0]);",`grid_put_schar` should be changed to take a `char *` (along with the other schar functions you changed),
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/20137,967623640,2022-09-10T09:06:18Z,runtime/lua/vim/lsp/util.lua,"@@ -474,7 +474,20 @@ function M.apply_text_edits(text_edits, bufnr, offset_encoding)       end       has_eol_text_edit = true     end-    api.nvim_buf_set_text(bufnr, e.start_row, e.start_col, e.end_row, e.end_col, e.text)++    local last_line = get_line(bufnr, e.end_row)++    -- If the replacement is over full lines it is safer to use api.nvim_buf_set_lines+    if e.end_col >= #last_line and e.start_col == 0 then+      -- When replacing whole lines there seems to always be an extra newline at the end of the new+      -- text. So we remove it.+      if #e.text > 1 and e.text[#e.text] == '' then+        table.remove(e.text, #e.text)",Isn't this kinda similar to what is happening above in line 464 and 471?,X
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19128,967633073,2022-09-10T10:39:34Z,CMakePresets.json,"@@ -0,0 +1,173 @@+{+  ""version"": 3,+  ""configurePresets"": [+    {+      ""name"": ""base"",+      ""displayName"": ""base preset"",+      ""generator"": ""Ninja"",+      ""binaryDir"": ""${sourceDir}/build/${presetName}"",+      ""cacheVariables"": {+        ""CMAKE_EXPORT_COMPILE_COMMANDS"": true+      },+      ""environment"": {+        ""LOG_DIR"": ""${sourceDir}/build/${presetName}/logs""+      },+      ""hidden"": true+    },+    {+      ""name"": ""release"",+      ""displayName"": ""Release"",+      ""description"": ""Same as RelWithDebInfo, but disables debug information"",+      ""cacheVariables"": {+        ""CMAKE_BUILD_TYPE"": ""Release""+      },+      ""inherits"": [+        ""base""+      ]+    },+    {+      ""name"": ""relwithdebinfo"",+      ""displayName"": ""RelWithDebInfo"",+      ""description"": ""Enables optimizations (-Og or -O2) with debug information"",+      ""cacheVariables"": {+        ""CMAKE_BUILD_TYPE"": ""RelWithDebInfo""+      },+      ""inherits"": [+        ""base""+      ]+    },+    {+      ""name"": ""debug"",+      ""displayName"": ""Debug"",+      ""description"": ""Disables optimizations (-O0), enables debug information"",+      ""cacheVariables"": {+        ""CMAKE_BUILD_TYPE"": ""Debug""+      },+      ""inherits"": [+        ""base""+      ]+    },+    {+      ""name"": ""debug-clang"",+      ""displayName"": ""Debug (w/ clang toolchain)"",+      ""environment"": {+        ""CC"": ""clang"",+        ""CXX"": ""clang++""+      },+      ""inherits"": [+        ""debug""+      ]+    },+    {+      ""name"": ""asan"",+      ""displayName"": ""Debug (w/ ASAN/UBSAN support)"",+      ""cacheVariables"": {+        ""CLANG_ASAN_UBSAN"": ""ON""+      },+      ""environment"": {+        ""ASAN_OPTIONS"": ""'detect_leaks=0;log_path=$env{LOG_DIR}'"",+        ""UBSAN_OPTIONS"": ""'print_stacktrace=1'""+      },+      ""inherits"": [+        ""debug-clang""+      ]+    },+    {+      ""name"": ""tsan"",+      ""displayName"": ""Debug (w/ TSAN support)"",+      ""cacheVariables"": {+        ""CLANG_TSAN"": ""ON""+      },+      ""environment"": {+        ""TSAN_OPTIONS"": ""'log_path=$env{LOG_DIR}'""+      },+      ""inherits"": [+        ""debug-clang""+      ]+    },+    {+      ""name"": ""msan"",+      ""displayName"": ""Debug (w/ MSAN support)"",+      ""cacheVariables"": {+        ""CLANG_MSAN"": ""ON""+      },+      ""environment"": {+        ""MSAN_OPTIONS"": ""'log_path=$env{LOG_DIR}'""+      },+      ""inherits"": [+        ""debug-clang""+      ]+    },+    {+      ""name"": ""win-x64"",+      ""displayName"": ""Windows MSVC x64 (/w VS2019)"",+      ""generator"": ""Visual Studio 17 2022"",+      ""architecture"": {+        ""value"": ""x64"",+        ""strategy"": ""set""+      },+      ""cacheVariables"":{+        ""CMAKE_BUILD_TYPE"": ""RelWithDebInfo""+      },+      ""inherits"": ""base"",+      ""condition"": {+        ""type"": ""equals"",+        ""lhs"": ""${hostSystemName}"",+        ""rhs"": ""Windows""+      }+    },+    {+      ""name"": ""win-ninja-x64"",+      ""displayName"": ""Windows x64 (/w Ninja)"",+      ""generator"": ""Ninja"",+      ""cacheVariables"":{+        ""CMAKE_BUILD_TYPE"": ""RelWithDebInfo""+      },+      ""inherits"": ""base"",+      ""condition"": {+        ""type"": ""equals"",+        ""lhs"": ""${hostSystemName}"",+        ""rhs"": ""Windows""+      }+    }+  ],+  ""buildPresets"": [","MSBuild only supports project-level parallelism if I recall correctly, so it doesn't really benefit us at all. I think this build presets can safely be removed.",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/20142,967636405,2022-09-10T11:11:18Z,runtime/doc/treesitter.txt,"@@ -584,57 +590,63 @@ add_directive({name}, {handler}, {force})                    *add_directive()*     `metadata[capture_id].key = value`      Parameters: ~-        {name}     the name of the directive, without leading #-        {handler}  the handler function to be used signature will be (match,-                   pattern, bufnr, predicate, metadata)+        {name}     (string) Name of the directive, without leading #+        {handler}  (function) with signature (match, pattern, bufnr,+                   predicate, metadata)  add_predicate({name}, {handler}, {force})                    *add_predicate()*     Adds a new predicate to be used in queries      Parameters: ~-        {name}     the name of the predicate, without leading #-        {handler}  the handler function to be used signature will be (match,-                   pattern, bufnr, predicate)+        {name}     (string) Name of the predicate, without leading #+        {handler}  (function) with Signature (match, pattern, bufnr,","Does it make sense to write this as `fun(match:string, pattern:string, bufnr:number, predicate:function)` as that seems to be supported by Emmylua? ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20145,967676163,2022-09-10T16:43:56Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN","Maybe add a comment here how the table works? It's almost-but-not-entirely obvious...Maybe something like``` -- file paths using environment variables: an entry -- `[""pattern""] = { 'filetype', 'VAR'} -- means that files matching `$VAR/pattern` are detected as `filetype` ```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20145,967676705,2022-09-10T16:49:11Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN+local env_pattern = {+  ['/cabal%.config'] = { 'cabalconfig', 'HOME' },","Hmm, maybe we can use a placeholder instead? Something like```['$HOME/git/ignore'] = 'gitignore'```and then in the helper function, replace it `$HOME` by `vim.env['$HOME']` in the key?(Maybe not worth it, but would be neat, and maybe allow us to support patterns involving variables elsewhere in the pattern.)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20145,967681807,2022-09-10T17:31:07Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN+local env_pattern = {+  ['/cabal%.config'] = { 'cabalconfig', 'HOME' },",I like this idea too. Couldn���t we just do this in the existing `pattern` table rather than creating a separate `env_pattern` table?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20145,967683115,2022-09-10T17:44:37Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN+local env_pattern = {+  ['/cabal%.config'] = { 'cabalconfig', 'HOME' },","Hmm, I worry a bit about performance implications if we have to check that for every pattern. And I kina like having these special patterns all in one place.But otherwise no objections!",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20145,967686125,2022-09-10T18:15:54Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN+local env_pattern = {+  ['/cabal%.config'] = { 'cabalconfig', 'HOME' },",">Hmm, I worry a bit about performance implications if we have to check that for every pattern.That seems like a reasonable justification to me ���� ",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/20142,967797391,2022-09-11T09:58:08Z,runtime/lua/vim/treesitter/query.lua,"@@ -424,12 +423,13 @@ function M.add_directive(name, handler, force) end  --- Lists the currently available directives to use in queries.----@return The list of supported directives.+---@return table List of supported directives.",This is a string list.,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/20142,967797408,2022-09-11T09:58:20Z,runtime/lua/vim/treesitter/query.lua,"@@ -424,12 +423,13 @@ function M.add_directive(name, handler, force) end  --- Lists the currently available directives to use in queries.----@return The list of supported directives.+---@return table List of supported directives. function M.list_directives()   return vim.tbl_keys(directive_handlers) end ----@return The list of supported predicates.+--- Lists the currently available predicates to use in queries.+---@return table List of supported predicates.","Here too, we return a string list.",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/20145,967829343,2022-09-11T13:30:36Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN+local env_pattern = {+  ['/cabal%.config'] = { 'cabalconfig', 'HOME' },",I've now come up with a solution that avoids the performance implications clason mentioned by making the expansion of environment patterns opt-in while also not requiring a separate `env_patterns` table. A disadvantage is that it only works for `patterns` and not for `filename` (though there is only one pattern currently which is affected by this). What do you think?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20145,967829944,2022-09-11T13:34:58Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN+local env_pattern = {+  ['/cabal%.config'] = { 'cabalconfig', 'HOME' },","Nice!Personally, I think I'd still prefer a separate table over adding a new options mechanism, but either way is OK for me .And a filename is just a pattern without (or with specific) wildcards, isn't it ;)",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/20145,967830138,2022-09-11T13:36:42Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN+local env_pattern = {+  ['/cabal%.config'] = { 'cabalconfig', 'HOME' },","> And a filename is just a pattern without (or with specific) wildcards, isn't it ;)That's true ;) Then I will move the `vim.env.HOME` pattern to `patterns`. ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20145,967864717,2022-09-11T17:53:11Z,runtime/lua/vim/filetype.lua,"@@ -2213,6 +2186,19 @@ local pattern = {   end,   -- END PATTERN }++-- BEGIN ENV_PATTERN+local env_pattern = {+  ['/cabal%.config'] = { 'cabalconfig', 'HOME' },","Yes, that should be available for `filetype.add` as well. The question is only whether we want1. a separate table for `pattern_env`2. a separate option for every patternEither is fine; 1. seems cleaner, but 2. is more future-proof.",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/20187,969931396,2022-09-13T17:53:24Z,src/nvim/eval.c,"@@ -3676,37 +3677,22 @@ int get_option_tv(const char **const arg, typval_T *const rettv, const bool eval     return OK;   } -  long numval;-  char *stringval;   int ret = OK;-+  bool hidden;   char c = *option_end;   *option_end = NUL;-  getoption_T opt_type = get_option_value(*arg, &numval,-                                          rettv == NULL ? NULL : &stringval, opt_flags);+  Object val = get_option_value(*arg, &hidden, opt_flags); -  if (opt_type == gov_unknown) {+  if (val.type == kObjectTypeNil) {     if (rettv != NULL) {       semsg(_(""E113: Unknown option: %s""), *arg);     }     ret = FAIL;   } else if (rettv != NULL) {-    if (opt_type == gov_hidden_string) {-      rettv->v_type = VAR_STRING;-      rettv->vval.v_string = NULL;-    } else if (opt_type == gov_hidden_bool || opt_type == gov_hidden_number) {-      rettv->v_type = VAR_NUMBER;-      rettv->vval.v_number = 0;-    } else if (opt_type == gov_bool || opt_type == gov_number) {-      rettv->v_type = VAR_NUMBER;-      rettv->vval.v_number = numval;-    } else {                          // string option-      rettv->v_type = VAR_STRING;-      rettv->vval.v_string = stringval;-    }-  } else if (working && (opt_type == gov_hidden_bool-                         || opt_type == gov_hidden_number-                         || opt_type == gov_hidden_string)) {+    Error err;+    object_to_vim(val, rettv, &err);+    assert(err.type == kErrorTypeNone);+  } else if (working && hidden) {",This is actually necessary for the PR. The PR is very incomplete so making review comments right now doesn't really make much sense,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20187,969936790,2022-09-13T17:59:37Z,src/nvim/eval.c,"@@ -3676,37 +3677,22 @@ int get_option_tv(const char **const arg, typval_T *const rettv, const bool eval     return OK;   } -  long numval;-  char *stringval;   int ret = OK;-+  bool hidden;   char c = *option_end;   *option_end = NUL;-  getoption_T opt_type = get_option_value(*arg, &numval,-                                          rettv == NULL ? NULL : &stringval, opt_flags);+  Object val = get_option_value(*arg, &hidden, opt_flags); -  if (opt_type == gov_unknown) {+  if (val.type == kObjectTypeNil) {     if (rettv != NULL) {       semsg(_(""E113: Unknown option: %s""), *arg);     }     ret = FAIL;   } else if (rettv != NULL) {-    if (opt_type == gov_hidden_string) {-      rettv->v_type = VAR_STRING;-      rettv->vval.v_string = NULL;-    } else if (opt_type == gov_hidden_bool || opt_type == gov_hidden_number) {-      rettv->v_type = VAR_NUMBER;-      rettv->vval.v_number = 0;-    } else if (opt_type == gov_bool || opt_type == gov_number) {-      rettv->v_type = VAR_NUMBER;-      rettv->vval.v_number = numval;-    } else {                          // string option-      rettv->v_type = VAR_STRING;-      rettv->vval.v_string = stringval;-    }-  } else if (working && (opt_type == gov_hidden_bool-                         || opt_type == gov_hidden_number-                         || opt_type == gov_hidden_string)) {+    Error err;+    object_to_vim(val, rettv, &err);+    assert(err.type == kErrorTypeNone);+  } else if (working && hidden) {","I only mentioned because we specifically talked about this on matrix.This is a big PR and will be hard to review, so even though it is unfinished, you should appreciate early feedback.",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/20194,970271099,2022-09-14T03:26:40Z,src/nvim/eval/typval.h,"@@ -469,7 +84,7 @@ static inline void list_log(const list_T *const l, const listitem_T *const li1, # define list_free_log() #endif -// In a hashtab item ""hi_key"" points to ""di_key"" in a dictitem.+/// Ref// In a hashtab item ""hi_key"" points to ""di_key"" in a dictitem.",Oof it seems like an accidental copy/paste. Fixed.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19243,970736112,2022-09-14T12:23:03Z,src/nvim/window.c,"@@ -6248,7 +6366,7 @@ void win_comp_scroll(win_T *wp) {   const long old_w_p_scr = wp->w_p_scr; -  wp->w_p_scr = wp->w_height / 2;+  wp->w_p_scr = wp->w_height_inner / 2;",The options code looks fine. `if_false` only has effect when `condition` is present.,
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/20184,971025943,2022-09-14T16:07:21Z,src/nvim/api/win_config.c,"@@ -330,7 +333,80 @@ static bool parse_float_bufpos(Array bufpos, lpos_T *out)   return true; } -static void parse_border_style(Object style, FloatConfig *fconfig, Error *err)+static void parse_border_title(Object title, Object title_pos, Object width, FloatConfig *fconfig, Error *err)+{+  if (!parse_title_pos(title_pos, fconfig, err)) {+    return;+  }++  if (title.type == kObjectTypeString) {+    fconfig->title_text = xstrdup(title.data.string.data);+    int hl_id = object_to_hl_id(title, ""border title highlight"", err);+    fconfig->title_hi_id = hl_id;+    fconfig->title = true;+    return;+  }++  if (title.type != kObjectTypeArray) {+    api_set_error(err, kErrorTypeValidation, ""title must be string or dictionary"");+    return;+  }++  if (title.type == kObjectTypeArray && title.data.array.size == 0) {+    api_set_error(err, kErrorTypeValidation, ""title must not be an empty dictionary"");","You're checking the type above, `title.type` is always `kObjectTypeArray` here.```suggestion  if (title.data.array.size == 0) {    api_set_error(err, kErrorTypeValidation, ""title cannot be an empty array"");```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20184,973492184,2022-09-16T22:47:26Z,src/nvim/api/win_config.c,"@@ -330,7 +341,88 @@ static bool parse_float_bufpos(Array bufpos, lpos_T *out)   return true; } -static void parse_border_style(Object style, FloatConfig *fconfig, Error *err)+static void parse_border_title(Object title, Object title_pos, Object width, FloatConfig *fconfig,+                               Error *err)+{+  if (!parse_title_pos(title_pos, fconfig, err)) {+    return;+  }++  int win_width = (int)width.data.integer;++  if (title.type == kObjectTypeString) {+    fconfig->title_text = xstrdup(title.data.string.data);+    int len = (int)strlen(fconfig->title_text);+    if (len > win_width) {+      api_set_error(err, kErrorTypeException, ""title length must be less than win width"");+      return;+    }++    int hl_id = object_to_hl_id(title, ""border title highlight"", err);+    fconfig->title_hi_id = hl_id;+    fconfig->title = true;+    return;+  }++  if (title.type != kObjectTypeArray) {+    api_set_error(err, kErrorTypeValidation, ""title must be string or array"");+    return;+  }++  if (title.type == kObjectTypeArray && title.data.array.size == 0) {+    api_set_error(err, kErrorTypeValidation, ""title cannot be an empty array"");+    return;+  }++  Array arr = title.data.array;+  size_t size = arr.size;+  for (size_t i = 0; i < size; i++) {+    Object iytem = arr.items[i];+    if (iytem.type != kObjectTypeArray || iytem.data.array.size == 0) {+      api_set_error(err, kErrorTypeValidation, ""not allow empty array in title"");+      return;+    }++    if (iytem.data.array.items[0].type != kObjectTypeString) {+      api_set_error(err, kErrorTypeValidation, ""missing title string in title array"");+      return;+    }+  }++  fconfig->title_texts = parse_virt_text(title.data.array, err, &win_width);++  fconfig->title = true;+  return;+}++static bool parse_title_pos(Object title_pos, FloatConfig *fconfig, Error *err)+{+  if (!HAS_KEY(title_pos)) {+    fconfig->title_pos = kBorderTitleLeft;+    return true;+  }++  if (title_pos.type != kObjectTypeString) {+    api_set_error(err, kErrorTypeValidation, ""title_pos must be string"");+    return false;+  }++  char *pos = title_pos.data.string.data;++  if (striequal(pos, ""left"")) {",why case-insensitive? better to be restrictive and precise unless there is a reason to accept variants. Loose casing is extra complexity.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20184,973493264,2022-09-16T22:51:17Z,src/nvim/buffer_defs.h,"@@ -1046,6 +1048,12 @@ typedef enum {   kWinStyleMinimal,  /// Minimal UI: no number column, eob markers, etc } WinStyle; +typedef enum {+  kBorderTitleLeft   = 0,+  kBorderTitleCenter = 1,+  kBorderTitleRight  = 2,+} BorderTitlePos;","there is a lot of special-case code in this PR. Let's try to re-use concepts where possible. ""left/right/center/..."" is not a unique concept. Is there not already an enum similar to this? If not, maybe a generic `kAlignLeft`/`kAlignCenter`'/... makes sense.",X
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/20184,973586633,2022-09-17T13:31:54Z,src/nvim/api/win_config.c,"@@ -273,6 +281,24 @@ Dictionary nvim_win_get_config(Window window, Error *err)         }       }       PUT(rv, ""border"", ARRAY_OBJ(border));+      if (config->title) {+        if (config->title_text != NULL) {+          String s = cstr_to_string((const char *)config->title_text);+          PUT(rv, ""title"", STRING_OBJ(s));+        } else {+          Array titles = ARRAY_DICT_INIT;+          VirtText title_datas = config->title_texts;+          for (size_t i = 0; i < title_datas.size; i++) {+            Array tuple = ARRAY_DICT_INIT;+            String s = cstr_to_string((const char *)title_datas.items[i].text);+            ADD(tuple, STRING_OBJ(s));","```suggestion            ADD(tuple, CSTR_TO_OBJ((const char *)title_datas.items[i].text));```",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/20184,973587238,2022-09-17T13:38:46Z,src/nvim/api/win_config.c,"@@ -330,7 +356,81 @@ static bool parse_float_bufpos(Array bufpos, lpos_T *out)   return true; } -static void parse_border_style(Object style, FloatConfig *fconfig, Error *err)+static void parse_border_title(Object title, Object title_pos, Object width, FloatConfig *fconfig,+                               Error *err)+{+  if (!parse_title_pos(title_pos, fconfig, err)) {+    return;+  }++  if (title.type == kObjectTypeString) {+    fconfig->title_text = xstrdup(title.data.string.data);+    int hl_id = object_to_hl_id(title, ""border title highlight"", err);+    fconfig->title_hi_id = hl_id;+    fconfig->title = true;+    return;+  }++  if (title.type != kObjectTypeArray) {+    api_set_error(err, kErrorTypeValidation, ""title must be string or array"");+    return;+  }++  if (title.type == kObjectTypeArray && title.data.array.size == 0) {+    api_set_error(err, kErrorTypeValidation, ""title cannot be an empty array"");+    return;+  }++  Array arr = title.data.array;+  size_t size = arr.size;+  for (size_t i = 0; i < size; i++) {+    Object iytem = arr.items[i];+    if (iytem.type != kObjectTypeArray || iytem.data.array.size == 0) {+      api_set_error(err, kErrorTypeValidation, ""not allow empty array in title"");+      return;+    }++    if (iytem.data.array.items[0].type != kObjectTypeString) {","Typo```suggestion    Object item = arr.items[i];    if (item.type != kObjectTypeArray || item.data.array.size == 0) {      api_set_error(err, kErrorTypeValidation, ""not allow empty array in title"");      return;    }    if (item.data.array.items[0].type != kObjectTypeString) {```",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/20184,973630244,2022-09-17T21:26:13Z,src/nvim/drawscreen.c,"@@ -681,6 +683,39 @@ int update_screen(int type)   return OK; } +static int get_title_texts_len(VirtText title_texts)+{+  int len = 0;+  for (size_t i = 0; i < title_texts.size; i++) {+    char *text = title_texts.items[i].text;+    len += (int)strlen(text);+  }+  return len;+}++static void redr_title_texts(win_T *wp, ScreenGrid *grid, int col)+{+  char *text;+  int len, attr;",oh just want this variable can be reused in a for loop. instead of creating a new temporary variable each time,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20238,973744716,2022-09-18T16:22:18Z,src/nvim/tui/tui.c,"@@ -1658,6 +1659,37 @@ static void out(void *ctx, const char *str, size_t len)   data->bufpos += len; } +/// Called by unibi_format() for padding.","hard to find the docs for `unibi_format` and its `pad` param. Here are the full docs from https://github.com/neovim/unibilium/blob/6688d83c91501d81fec9a1a0fbf67993d2d338f0/doc/unibi_format.pod#L32```I<pad> is used when the format string contains C<< $<...> >> paddinginstructions. In the calls to I<pad> the first argument is always I<ctx2>, thesecond argument is the delay in tenths of milliseconds, the third argument is aboolean flag indicating whether C<*> (proportional delay) was specified in theformat string, and the fourth argument is a boolean flag indicating whetherC</> (forced padding) was specified in the format string. Thus a format stringof C<< $<5/> >> would translate into C<pad(ctx2, 50, 0, 1)>. You may pass anull pointer for I<pad>; in that case padding instructions are silentlyskipped.```can we summarize the relevant part here (very concisely)? Something like:> The `pad` parameter of `unibi_format` handles padding instructions. If it is NULL then padding instructions are silently skipped.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20238,973745066,2022-09-18T16:24:43Z,src/nvim/tui/tui.c,"@@ -1658,6 +1659,37 @@ static void out(void *ctx, const char *str, size_t len)   data->bufpos += len; } +/// Called by unibi_format() for padding.+static void pad(void *ctx, size_t delay, int scale, int force)",// TODO: the delay impl is mostly copied from loop_poll_events(). Can we extract this pattern to a common function?,X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20238,973795987,2022-09-18T23:28:07Z,src/nvim/tui/tui.c,"@@ -1658,6 +1659,37 @@ static void out(void *ctx, const char *str, size_t len)   data->bufpos += len; } +/// Called by unibi_format() for padding.",I guess it is better to add doxygen comments for the parameters instead.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20145,976827717,2022-09-21T17:50:32Z,runtime/lua/vim/filetype.lua,"@@ -2376,8 +2361,28 @@ local function dispatch(ft, path, bufnr, ...)   end end +-- Caches calls to string.find","Expand on this comment a bit more, it is not at all obvious what this is for if you are just reading for the first timeSuggestion:```suggestion-- Lookup table/cache for patterns that contain an environment variable pattern, e.g. ${SOME_VAR}.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20145,976829271,2022-09-21T17:52:23Z,runtime/lua/vim/filetype.lua,"@@ -2376,8 +2361,28 @@ local function dispatch(ft, path, bufnr, ...)   end end +-- Caches calls to string.find+local expand_env_lookup = {}+ ---@private local function match_pattern(name, path, tail, pat)+  if expand_env_lookup[pat] == nil then+    expand_env_lookup[pat] = pat:find('%$') ~= nil","This should check for `${` (or maybe even the full `%${(%S-)}`), because a plain `$` could be used to mark the end of a pattern, e.g. `vimrc$`.```suggestion    expand_env_lookup[pat] = pat:find('%${') ~= nil```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11967,977611159,2022-09-22T12:46:09Z,cmake.deps/cmake/BuildTreesitterParsers.cmake,"@@ -23,3 +23,4 @@ endfunction() BuildTSParser(c ${TREESITTER_C_URL} ${TREESITTER_C_SHA256} TreesitterParserCMakeLists.txt) BuildTSParser(lua ${TREESITTER_LUA_URL} ${TREESITTER_LUA_SHA256} TreesitterParserCMakeLists.txt) BuildTSParser(vim ${TREESITTER_VIM_URL} ${TREESITTER_VIM_SHA256} TreesitterParserCMakeLists.txt)+BuildTSParser(vimdoc ${TREESITTER_VIMDOC_URL} ${TREESITTER_VIMDOC_SHA256} TreesitterParserCMakeLists.txt)","Thanks! `./build/lib/nvim/parser/help.so` exists now, but still `vim.treesitter.require_language('help')` and `vim.treesitter.get_parser(buf, 'help')` fails.It works for `parser_spec` ... https://github.com/neovim/neovim/blob/2c1f221e73f7101c8131519d6432227fbce5de2b/test/functional/treesitter/parser_spec.lua#L23```|| test/functional/helpers.lua:106: Error executing lua: ...dev/neovim/runtime/lua/vim/treesitter/language.lua:26: no parser for 'help' language, see :help treesitter-parsers|| stack traceback:|| 	[C]: in function 'error'|| 	...dev/neovim/runtime/lua/vim/treesitter/language.lua:26: in function 'require_language'|| 	./scripts/gen_help_html.lua:452: in function 'parse_buf'|| 	./scripts/gen_help_html.lua:467: in function 'validate_one'|| 	./scripts/gen_help_html.lua:824: in function <./scripts/gen_help_html.lua:813>",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/20157,978552997,2022-09-23T11:50:45Z,src/nvim/os/lang.c,"@@ -5,18 +5,13 @@ # define Boolean CFBoolean  // Avoid conflict with API's Boolean # define FileInfo CSFileInfo  // Avoid conflict with API's Fileinfo # include <CoreServices/CoreServices.h>+ # undef Boolean # undef FileInfo #endif -#include ""auto/config.h""--#ifdef HAVE_LOCALE_H-# include <locale.h>-#endif-",I'll move the includes into the `#ifdef __APPLE__` then so it's only removed if it's not needed on osx. Should probably do this for all os-dependent includes now that I think about it.,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/20154,979238223,2022-09-24T12:38:11Z,cmake.deps/cmake/BuildLibtermkey.cmake,"@@ -4,8 +4,6 @@ if(WIN32)       ${DEPS_BUILD_DIR}/src/libtermkey/CMakeLists.txt     COMMAND ${CMAKE_COMMAND} ${DEPS_BUILD_DIR}/src/libtermkey       -DCMAKE_INSTALL_PREFIX=${DEPS_INSTALL_DIR}-      # Pass toolchain-      -DCMAKE_TOOLCHAIN_FILE=${TOOLCHAIN}","The git blame doesn't really show anything other than a generic ""added dependency"". But toolchains are for cross-compilation. Also we don't have any toolchains to pass anymore since they were deleted.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/20330,979336695,2022-09-25T01:00:42Z,runtime/doc/starting.txt,"@@ -110,7 +110,10 @@ argument. 		This can be used to find out where time is spent while loading 		your |config|, plugins and opening the first file. 		When {fname} already exists new messages are appended.-+		If your profiler script needs to know when to quit, use:+>+		nvim --startuptime nvim.log +'set ut=0 | au CursorHold * qa!'","So to be clear, by ""doesn't work"" I mean that neovim quits before `--- NVIM IDLE ---` message.IIRC `+`/`-c` commands are executed after the config, so I believe this should overwrite it. In worst case scenario if the user still manages to change `'updatetime'` to a higher value from the config, it will just take a little bit longer for neovim to quit.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20345,979460650,2022-09-25T21:00:21Z,runtime/doc/api.txt,"@@ -1396,8 +1396,8 @@ nvim_set_hl({ns_id}, {name}, {*val})                           *nvim_set_hl()*                  ��� link: name of another highlight group to link to, see                    |:hi-link|.                  ��� default: Don't override existing definition |:hi-default|-                 ��� ctermfg: Sets foreground of cterm color |highlight-ctermfg|-                 ��� ctermbg: Sets background of cterm color |highlight-ctermbg|+                 ��� ctermfg: Sets foreground of cterm color |ctermfg|+                 ��� ctermbg: Sets background of cterm color |ctermbg|","Since ""ctermbg"", ""guifg"", etc. are common and unambiguous, I opted to remove the `highlight-` prefix.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/20157,980309610,2022-09-26T17:14:36Z,Makefile,"@@ -135,6 +135,14 @@ lintlua lintsh lintpy lintuncrustify lintc lintcfull check-single-includes gener  test: functionaltest unittest +iwyu: build/.ran-cmake+	cmake --preset iwyu+	cmake --build --preset iwyu > iwyu.log+	iwyu-fix-includes --only_re=""src/nvim"" --ignore_re=""src/nvim/(auto|map.h)"" < iwyu.log+	# IWYU adds an anonymous struct to map.h which gives an error when+	# building. Skip fixing map.h for now until we figure out why this+	# happens.+","Sure, but why do you think it should be removed entirely? A suboptimal solution is still better than no solution.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20352,982480089,2022-09-28T14:27:27Z,runtime/doc/ui.txt,"@@ -23,40 +23,37 @@ screen grid with a size of width �� height cells. This is typically done by an embedder at startup (see |ui-startup|), but UIs can also connect to a running Nvim instance and invoke nvim_ui_attach(). The `options` parameter is a map with these (optional) keys:+ 							*ui-rgb*-	`rgb`			Decides the color format.-				true:	(default) 24-bit RGB colors-				false:	Terminal colors (8-bit, max 256)+- `rgb`			Decides the color format.+			- true:	(default) 24-bit RGB colors+			- false:	Terminal colors (8-bit, max 256) 							*ui-override*-	`override`		Decides how UI capabilities are resolved.-				true:	Enable requested UI capabilities, even-					if not supported by all connected UIs-					(including |TUI|).-				false:	(default) Disable UI capabilities not-					supported by all connected UIs-					(including TUI).+- `override`		Decides how UI capabilities are resolved.+			- true:	Enable requested UI capabilities, even if not+			  supported by all connected UIs (including |TUI|).+			- false: (default) Disable UI capabilities not+			  supported by all connected UIs (including TUI). 							*ui-ext-options*-	`ext_cmdline`		Externalize the cmdline. |ui-cmdline|-	`ext_hlstate`		Detailed highlight state. |ui-hlstate|-				Sets `ext_linegrid` implicitly.-	`ext_linegrid`		Line-based grid events. |ui-linegrid|-				Deactivates |ui-grid-old| implicitly.-	`ext_messages`		Externalize messages. |ui-messages|-				Sets `ext_linegrid` and `ext_cmdline` implicitly.-	`ext_multigrid`		Per-window grid events. |ui-multigrid|-				Sets `ext_linegrid` implicitly.-	`ext_popupmenu`		Externalize |popupmenu-completion| and-				'wildmenu'. |ui-popupmenu|-	`ext_tabline`		Externalize the tabline. |ui-tabline|-	`ext_termcolors`	Use external default colors.-	`term_name`		Sets the name of the terminal 'term'.-	`term_colors`		Sets the number of supported colors 't_Co'.-	`term_background`	Sets the default value of 'background'.-	`stdin_fd`		Read buffer from `fd` as if it was a stdin pipe-				This option can only used by |--embed| ui,-				see |ui-startup-stdin|.--+- `ext_cmdline`		Externalize the cmdline. |ui-cmdline|+- `ext_hlstate`		Detailed highlight state. |ui-hlstate|","Use lists to list things... otherwise we are stuck with ""hardwrap"" / preformatted format.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/20378,982865474,2022-09-28T21:11:02Z,runtime/doc/lua.txt,"@@ -1697,14 +1697,14 @@ split({s}, {sep}, {kwargs})                                      *vim.split()*     Parameters: ~         {s}       (string) String to split         {sep}     (string) Separator or pattern-        {kwargs}  (table) Keyword arguments:+        {kwargs}  {plain: boolean, trimempty: boolean}|nil Keyword arguments:",@clason for that we would need to add a comment with @class and the correct fields. Is that also how it works in doxygen?I think for now the current changes are ok and the fields could be a further imrovement?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20378,982867318,2022-09-28T21:13:30Z,runtime/doc/lua.txt,"@@ -1697,14 +1697,14 @@ split({s}, {sep}, {kwargs})                                      *vim.split()*     Parameters: ~         {s}       (string) String to split         {sep}     (string) Separator or pattern-        {kwargs}  (table) Keyword arguments:+        {kwargs}  {plain: boolean, trimempty: boolean}|nil Keyword arguments:","Sure, no need to fix all the issues at once (if they get fixed eventually ;))`---@class` works, see the treesitter docs, e.g., `query.lua`, but probably  `---@field` is not the right annotation then.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/20378,982869296,2022-09-28T21:16:29Z,runtime/doc/lua.txt,"@@ -1697,14 +1697,14 @@ split({s}, {sep}, {kwargs})                                      *vim.split()*     Parameters: ~         {s}       (string) String to split         {sep}     (string) Separator or pattern-        {kwargs}  (table) Keyword arguments:+        {kwargs}  {plain: boolean, trimempty: boolean}|nil Keyword arguments:","With proper lua annotations, we would add something like:```lua---@class vim.split.Options---@field plain boolean some comment---@field trimempty boolean another comment---@param opts vim.split.Options options for split...function split(opts)```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20378,982870697,2022-09-28T21:18:20Z,runtime/doc/lua.txt,"@@ -1697,14 +1697,14 @@ split({s}, {sep}, {kwargs})                                      *vim.split()*     Parameters: ~         {s}       (string) String to split         {sep}     (string) Separator or pattern-        {kwargs}  (table) Keyword arguments:+        {kwargs}  {plain: boolean, trimempty: boolean}|nil Keyword arguments:","Yeah, that would work! It's a bit verbose in the code, and we'd have to agree to a reasonable convention for the class name, but it's not the worst option by far.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20393,983413958,2022-09-29T11:17:19Z,scripts/lintcommit.lua,"@@ -86,12 +86,33 @@ local function validate_commit(commit_message)       vim.inspect(allowed_types))   end -  -- Check if scope is empty+  -- Check if scope is appropriate   if before_colon:match(""%("") then     local scope = vim.trim(before_colon:match(""%((.*)%)""))+     if scope == '' then       return [[Scope can't be empty.]]     end++    if scope == ""ts"" or scope == ""tree-sitter"" then+      return [[Scope should be ""treesitter""]]+    end++    if scope == ""hl"" then+      return [[Scope should be ""highlight""]]+    end++    if vim.startswith(scope, ""nvim_"") then+        return [[Scope should be ""api""]]+    end++    if scope == ""doc"" or scope == ""docs"" then+        return [[Prefer to use ""docs"" as a type rather than a scope. Example: docs(treesitter):...]]+    end++    if scope == ""filetype.vim"" or scope == ""filetype.lua"" then","instead of lots of if-else, could define a ""misspelling"" table like this:```local misspelling = {  ['filetype.vim'] = 'filetype',  ['filetype.lua'] = 'filetype',  ['doc'] = 'docs',  ['tree-sitter'] = 'treesitter',  ['ts'] = 'treesitter',}if misspelling[scope] then    return ('scope should be ""%s"" instead of ""%s""'):format(misspelling[scope], scope)end```Eventually, we probably want to define a strict list of allowed scopes. That will really help the changelog.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20426,985104691,2022-10-01T14:16:45Z,runtime/doc/news.txt,"@@ -0,0 +1,39 @@+*news.txt*    Nvim+++			    NVIM REFERENCE MANUAL+++Notable changes in Nvim 0.9 from 0.8                                     *news*++                                       Type |gO| to see the table of contents.++==============================================================================+BREAKING CHANGES                                                *news-breaking*","I'm not 100% sure on that; the issue has the (significant!) advantage that you can subscribe to it and get notifications of breaking changes instead of needing to check a file.On the other hand; the issue is growing unbounded, so that's clearly not sustainable long-term (and pruning comments after a release is tedious).",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19315,985149205,2022-10-01T21:58:06Z,src/nvim/channel.c,"@@ -563,6 +603,10 @@ size_t channel_send(uint64_t id, char *data, size_t len, bool data_owned, const     goto retfree;   } +  if (chan->term) {+    len += newline_adjust(&data);","instead of doing this here, can we find where `data` is prepared and change its logic? similar to the simple change from https://github.com/neovim/neovim/pull/18723There are 2 places that call channel_send:1. `f_chansend`, which calls `save_tv_as_string` on the list input. I think only the list-input should be changed, not raw string input. So we could send a flag to `save_tv_as_string` that changes its separator char from `\n` to `\r\n` ?2. `nvim_chan_send`, which only accepts String. I don't think we should be modifying raw string input--it's up to the caller to decide what raw data they want to send, right? ",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19315,985179809,2022-10-02T05:09:54Z,src/nvim/channel.c,"@@ -563,6 +603,10 @@ size_t channel_send(uint64_t id, char *data, size_t len, bool data_owned, const     goto retfree;   } +  if (chan->term) {+    len += newline_adjust(&data);","> So we could send a flag to `save_tv_as_string` that changes its separator char from `\n` to `\r\n` ?That's what I did at first (see updates 4 and 5 in this [comment][1]). But `save_tv_as_string` handles putting text in general, so converting `\n` to `\r\n` will convert them when putting text in non-terminal buffers, too, which is undesired. We _could_ send a flag to determine if it's for a term channel, but: 1) I thought changing parameters of an existing function was too much of a hassle for a newbie in the codebase, and 2) I couldn't figure out if I should use `id`[2] or something else to figure out if it's a `chan->term` [3]. It's kind of about code design. I didn't wanna make big changes by shifting code around. Need guidance.> `nvim_chan_send`, which only accepts String. I don't think we should be modifying raw string input--it's up to the caller to decide what raw data they want to send, right?I actually didn't even see this. If we handle `\n` -> `\r\n` in `save_tv_as_string`, then this would be fixed (as you said).---Sorry about adding links weirdly. GH is processing my links, prepending other links and stuff. Donno what that's about. Thought it best to paste it as text.[1]: https://github.com/neovim/neovim/issues/18501#issuecomment-11741060592: https://github.com/3N4N/neovim/blob/85754dcdd992/src/nvim/eval/funcs.c#L8733: https://github.com/3N4N/neovim/blob/85754dcdd992/src/nvim/channel.c#L586",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19315,985221077,2022-10-02T11:04:21Z,src/nvim/channel.c,"@@ -563,6 +603,10 @@ size_t channel_send(uint64_t id, char *data, size_t len, bool data_owned, const     goto retfree;   } +  if (chan->term) {+    len += newline_adjust(&data);",@justinmk I pushed a second commit (thought we should keep the changes available until merged) following your suggestion: only converting LF to CRLF when joining list items.Looks like it's crashing. I've probably bungled up the calculation of `len`. Can't figure out how to fix it.,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15601,985221899,2022-10-02T11:10:39Z,Makefile,"@@ -148,6 +148,16 @@ distclean: install: checkprefix nvim 	+$(BUILD_TOOL) -C build install +clang-tidy: generate-compilation-db+	clang-tidy --config-file .clang-tidy -p build $(FILE)++clang-tidy-full: generate-compilation-db+	+$(BUILD_CMD) -C build clang-tidy-full++generate-compilation-db: build/.ran-cmake+	ninja -C build -t compdb C_COMPILER__nvim_$(CMAKE_BUILD_TYPE) > build/compile_commands.json",Is this needed anymore? Doesn't cmake automatically create a compilation database now?,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,985222318,2022-10-02T11:14:00Z,Makefile,"@@ -148,6 +148,16 @@ distclean: install: checkprefix nvim 	+$(BUILD_TOOL) -C build install +clang-tidy: generate-compilation-db+	clang-tidy --config-file .clang-tidy -p build $(FILE)++clang-tidy-full: generate-compilation-db+	+$(BUILD_CMD) -C build clang-tidy-full++generate-compilation-db: build/.ran-cmake+	ninja -C build -t compdb C_COMPILER__nvim_$(CMAKE_BUILD_TYPE) > build/compile_commands.json","this is specifically for filtering that database, see https://github.com/neovim/neovim/issues/10632",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15601,985223272,2022-10-02T11:22:00Z,Makefile,"@@ -148,6 +148,16 @@ distclean: install: checkprefix nvim 	+$(BUILD_TOOL) -C build install +clang-tidy: generate-compilation-db+	clang-tidy --config-file .clang-tidy -p build $(FILE)++clang-tidy-full: generate-compilation-db+	+$(BUILD_CMD) -C build clang-tidy-full++generate-compilation-db: build/.ran-cmake+	ninja -C build -t compdb C_COMPILER__nvim_$(CMAKE_BUILD_TYPE) > build/compile_commands.json","Wait, that's a completely separate issue. This PR is about introducing clang-tidy, that issue is about ""massing"" the compilation database for whatever reason.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15601,985265906,2022-10-02T16:47:14Z,Makefile,"@@ -148,6 +148,14 @@ distclean: install: checkprefix nvim 	+$(BUILD_TOOL) -C build install +clang-tidy: build/.ran-cmake+	@test $(FILE) \+		&& clang-tidy --config-file .clang-tidy -p build $(FILE) \+		|| $(MAKE) clang-tidy-full++clang-tidy-full: build/.ran-cmake+	+$(BUILD_TOOL) -C build clang-tidy-full",You can replace this by adding `clang-tidy-full` to the list with `lintlua lintsh lintuncrustify ...`,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15601,985266439,2022-10-02T16:51:22Z,Makefile,"@@ -148,6 +148,14 @@ distclean: install: checkprefix nvim 	+$(BUILD_TOOL) -C build install +clang-tidy: build/.ran-cmake+	@test $(FILE) \+		&& clang-tidy --config-file .clang-tidy -p build $(FILE) \+		|| $(MAKE) clang-tidy-full++clang-tidy-full: build/.ran-cmake+	+$(BUILD_TOOL) -C build clang-tidy-full","Actually, is a make target to run `clang-tidy-full` even needed? There's no way anyone will run this locally since it takes such a long time so I don't think there's much point.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20428,985270246,2022-10-02T17:22:57Z,runtime/doc/filetype.txt,"@@ -176,125 +176,16 @@ This means that the contents of compressed files are not inspected. 							*new-filetype* If a file type that you want to use is not detected yet, there are a few ways to add it.  In any way, it's better not to modify the $VIMRUNTIME/filetype.lua-or $VIMRUNTIME/filetype.vim files.  They will be overwritten when installing a-new version of Nvim. The following explains the legacy Vim mechanism (enabled-if |g:do_legacy_filetype| is set). For Nvim's default mechanism, see-|vim.filetype.add()|.--A. If you want to overrule all default file type checks.-   This works by writing one file for each filetype.  The disadvantage is that-   there can be many files.  The advantage is that you can simply drop this -   file in the right directory to make it work.-							*ftdetect*-   1. Create your user runtime directory.  You would normally use the first-      item of the 'runtimepath' option.  Then create the directory ""ftdetect""-      inside it.  Example for Unix: >-	:!mkdir -p ~/.config/nvim/ftdetect-<-   2. Create a file that contains an autocommand to detect the file type.-      Example: >-	au BufRead,BufNewFile *.mine		set filetype=mine-<     Note that there is no ""augroup"" command, this has already been done-      when sourcing your file.  You could also use the pattern ""*"" and then-      check the contents of the file to recognize it.-      Write this file as ""mine.vim"" in the ""ftdetect"" directory in your user-      runtime directory.  For example, for Unix: >-	:w ~/.config/nvim/ftdetect/mine.vim","I don't see this opt-in runtimepath approach as deprecated. Just like Lua plugins, we might also look for `ftdetect/foo.lua`, but the general idea of passively discovering overrides on the user's config path seems like a standard approach that should remain.Though certainly this deleted area can be greatly abbreviated.",X
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19315,985270444,2022-10-02T17:24:56Z,src/nvim/eval.c,"@@ -6177,9 +6177,15 @@ bool read_blob(FILE *const fd, blob_T *const blob) /// @param[in]  endnl If true, the output will end in a newline (if a list). /// @returns an allocated string if `tv` represents a VimL string, list, or ///          number; NULL otherwise.-char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl)+char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl, bool is_chanterm)   FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL {+#ifdef UNIX+  bool crlf = false;+#else+  bool crlf = is_chanterm ? true: false;+#endif","> Can we add a crlf paramter to save_tv_as_string which is set to true by f_chansend?Did something similar^. But I can do crlf as parameter directly as well, if you want.",
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/20473,986379541,2022-10-04T02:25:59Z,runtime/lua/vim/lsp.lua,"@@ -871,7 +873,7 @@ function lsp.start(config, opts)   if not config.name and type(config.cmd) == 'table' then     config.name = config.cmd[1] and vim.fs.basename(config.cmd[1]) or nil   end-  local bufnr = api.nvim_get_current_buf()+  local bufnr = opts.bufnr or api.nvim_get_current_buf()","As far as I can tell, the more common pattern is to do this over multiple lines:```lualocal bufnr = opts.bufnrif bufnr == nil or bufnr == 0 then  bufnr = api.nvim_get_current_buf()end```You can see that pattern in multiple places in the neovim source code.",
31262046,levouh,https://api.github.com/repos/neovim/neovim/pulls/20473,986382257,2022-10-04T02:33:26Z,runtime/lua/vim/lsp.lua,"@@ -871,7 +873,7 @@ function lsp.start(config, opts)   if not config.name and type(config.cmd) == 'table' then     config.name = config.cmd[1] and vim.fs.basename(config.cmd[1]) or nil   end-  local bufnr = api.nvim_get_current_buf()+  local bufnr = opts.bufnr or api.nvim_get_current_buf()","Cool, updated to use that pattern for now. Will see where that goes.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20412,986968238,2022-10-04T14:47:49Z,runtime/CMakeLists.txt,"@@ -75,8 +75,10 @@ add_custom_command(OUTPUT ${GENERATED_HELP_TAGS} )  +# TODO: This doesn't work. wait for ""nvim -l"" to land? add_custom_target(doc_html-  COMMAND make html+  COMMAND ""${PROJECT_BINARY_DIR}/bin/nvim""+    -V1 -es --clean -c ""lua require('scripts.gen_help_html').gen('./build/runtime/doc', './build/doc_html', nil, 'todo_commit_id')"" -c ""0cq""","@dundargoc forgive me, this is a ""dead"" target: it doesn't work at the moment. Just leaving it here for reference, should be easy to fix once `nvim -l` lands.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20412,986976139,2022-10-04T14:53:02Z,cmake.deps/CMakeLists.txt,"@@ -201,8 +201,8 @@ set(TREESITTER_LUA_SHA256 564594fe0ffd2f2fb3578a15019b723e1bc94ac82cb6a0103a6b3b set(TREESITTER_VIM_URL https://github.com/vigoux/tree-sitter-viml/archive/v0.2.0.tar.gz) set(TREESITTER_VIM_SHA256 608dcc31a7948cb66ae7f45494620e2e9face1af75598205541f80d782ec4501) -set(TREESITTER_HELP_URL https://github.com/neovim/tree-sitter-vimdoc/archive/v1.1.0.tar.gz)-set(TREESITTER_HELP_SHA256 4c0ef80c6dc09acab362478950ec6be58a4ab1cbf2d95754b8fbb566e4c647a1)+set(TREESITTER_HELP_URL https://github.com/neovim/tree-sitter-vimdoc/archive/c27e3e21a54f6d90dfb791f37d90eab5b28de971.tar.gz)+set(TREESITTER_HELP_SHA256 54a6a5b52a395097775f06f96ac1e1c9efdab10243550a467e1198a286b8c59c)","Treesitter support is still experimental; help doubly so. So this is fine; my point was just that we should treat these more like binary dependency than runtime files (which they both have aspects of), so in the long run the ""default"" should be that we use tagged versions, in particular for releases.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20426,987743552,2022-10-05T09:55:10Z,README.md,"@@ -116,6 +117,7 @@ Apache 2.0 license, except for contributions copied from Vim (identified by the  [license-commit]: https://github.com/neovim/neovim/commit/b17d9691a24099c9210289f16afb1a498a89d803 [nvim-features]: https://neovim.io/doc/user/vim_diff.html#nvim-features+[nvim-news]: https://neovim.io/doc/user/news.html","this file can use the ""flow"" layout, so let's add it to this opt-in list: https://github.com/neovim/neovim/blob/06f4edc864479fb121d514ec1e7253dba85b740d/scripts/gen_help_html.lua#L42",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20498,988020720,2022-10-05T14:54:26Z,runtime/doc/starting.txt,"@@ -1182,7 +1182,7 @@ exactly four MessagePack objects:                        encoding   Binary, effective 'encoding' value.                        max_kbyte  Integer, effective |shada-s| limit value.                        pid        Integer, instance process ID.-                       *          It is allowed to have any number of+                       `*`          It is allowed to have any number of","TODO: I'm thinking https://github.com/neovim/tree-sitter-vimdoc should only support `-` and `���` as listitem prefixes. Not `+` nor `*`, which are not commonly used as list prefixes in :help docs (and `*` has other special purpose in :help docs).",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20498,988025802,2022-10-05T14:58:08Z,runtime/doc/starting.txt,"@@ -1182,7 +1182,7 @@ exactly four MessagePack objects:                        encoding   Binary, effective 'encoding' value.                        max_kbyte  Integer, effective |shada-s| limit value.                        pid        Integer, instance process ID.-                       *          It is allowed to have any number of+                       `*`          It is allowed to have any number of","+1 on pruning the wild, wild west of alternative help formats for our docs (as long as it doesn't require a full rewrite of the upstream docs).",
484155,jpalus,https://api.github.com/repos/neovim/neovim/pulls/20489,988036013,2022-10-05T15:04:37Z,src/nvim/memory.h,"@@ -45,7 +45,16 @@ typedef struct consumed_blk {   struct consumed_blk *prev; } *ArenaMem; -#define ARENA_ALIGN sizeof(void *)+#ifdef __GNUC__+# if defined(__i386__)+#  define ARENA_ALIGN 16+# else+#  define ARENA_ALIGN ((2 * sizeof(size_t)) < \+                       __alignof__(long double) ? __alignof__(long double) : (2 * sizeof(size_t)))","Above logic is based purely on:https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/generic/malloc-alignment.h;h=ef0f381f772088d3e8a8648410bba85b1a970451;hb=c804cd1c00adde061ca51711f63068c103e94eefhttps://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/generic/malloc-alignment.h;h=ef0f381f772088d3e8a8648410bba85b1a970451;hb=c804cd1c00adde061ca51711f63068c103e94eef> just hardcoding `ARENA_ALIGN` to `MAX(sizeof(void *), sizeof(double))` would have be been simpler.I don't really know what are neovim's alignment requirements hence PR attempts to be as generic as possible. If you're sure it will never reach maximum then I guess it's fine.> Also `__GNUC__` looks fishy. we only care what the CPU wants, not about gcc/glibc's ideas.`__GNUC__` is there to make sure `__i386__` and `__alignof__` are available.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15601,989923342,2022-10-07T10:07:30Z,.clangd,"@@ -1,2 +1,32 @@ CompileFlags:-  CompilationDatabase: build/       # Search build/ directory for compile_commands.json+  # Search build/ directory for compile_commands.json+  CompilationDatabase: build+Diagnostics:+  # Additional checks that are useful but too noisy to be included in .clang-tidy+  ClangTidy:+    Add:+      - google-*+      - misc-*+      - performance-*+      - readability-*+    Remove:+      - misc-no-recursion+      - misc-unused-parameters+      - readability-function-*+      - readability-identifier-length+      - readability-magic-numbers+      - readability-redundant-function-ptr-dereference",I still think the warnings are too noisy. I propose we add the following warnings as well.```suggestion      - readability-redundant-function-ptr-dereference      - readability-isolate-declaration      - bugprone-assignment-in-if-condition      - readability-suspicious-call-argument      - performance-no-int-to-ptr      - readability-else-after-return      - google-readability-function-size      - cert-err33-c```,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,990083773,2022-10-07T13:20:54Z,.clangd,"@@ -1,2 +1,32 @@ CompileFlags:-  CompilationDatabase: build/       # Search build/ directory for compile_commands.json+  # Search build/ directory for compile_commands.json+  CompilationDatabase: build+Diagnostics:+  # Additional checks that are useful but too noisy to be included in .clang-tidy+  ClangTidy:+    Add:+      - google-*+      - misc-*+      - performance-*+      - readability-*+    Remove:+      - misc-no-recursion+      - misc-unused-parameters+      - readability-function-*+      - readability-identifier-length+      - readability-magic-numbers+      - readability-redundant-function-ptr-dereference","- `bugprone-assignment-in-if-condition` how often does this even come up and it's not a bug? unless it's some macro- `cert-err33-c` is pretty serious, see [ERR33-C. Detect and handle standard library errors](https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors)the rest are style guide related, so I don't mind removing them, although we could only enable them for certain folders/files if they're too noisy for upstream vim files",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15601,990092719,2022-10-07T13:29:50Z,.clangd,"@@ -1,2 +1,32 @@ CompileFlags:-  CompilationDatabase: build/       # Search build/ directory for compile_commands.json+  # Search build/ directory for compile_commands.json+  CompilationDatabase: build+Diagnostics:+  # Additional checks that are useful but too noisy to be included in .clang-tidy+  ClangTidy:+    Add:+      - google-*+      - misc-*+      - performance-*+      - readability-*+    Remove:+      - misc-no-recursion+      - misc-unused-parameters+      - readability-function-*+      - readability-identifier-length+      - readability-magic-numbers+      - readability-redundant-function-ptr-dereference","> how often does this even come up and it's not a bug?Literally the entire codebase. Did you not test the PR lol?> cert-err33-c is pretty serious, see [ERR33-C. Detect and handle standard library errors](https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors)Same thing, it's a valid but it will create massive amounts of noise. This will just result in all of the functions getting a `(void)` slapped on them instead of any error checking.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,990669445,2022-10-08T17:48:44Z,Makefile,"@@ -148,6 +148,9 @@ distclean: install: checkprefix nvim 	+$(BUILD_TOOL) -C build install +clang-tidy: generated-sources+	+clang-tidy --config-file .clang-tidy -p build $(FILE)","After some testing I figured it's not worth it, since clang-tidy will not run in parallel on its own. We can iterate on this further later on.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12823,990769514,2022-10-09T10:25:55Z,runtime/doc/lua.txt,"@@ -11,30 +11,126 @@ Lua engine                                                           *lua* *Lua* ============================================================================== INTRODUCTION                                                       *lua-intro* -The Lua 5.1 language is builtin and always available. Try this command to get-an idea of what lurks beneath: >+The Lua 5.1 script engine is builtin and always available. Try this command to+get an idea of what lurks beneath: >      :lua print(vim.inspect(package.loaded))++Nvim includes a ""standard library"" |lua-stdlib| for Lua.  It complements the+""editor stdlib"" (|builtin-functions| and |Ex-commands|) and the |API|, all of+which can be used from Lua code (|lua-vimscript| |vim.api|). Together these+""namespaces"" form the Nvim programming interface.++The |:source| and |:runtime| commands can run Lua scripts. Lua modules can be+loaded with `require('name')`, which by convention usually returns a table.+See |lua-require| for how Nvim finds and loads Lua modules.++See this page for more insight into Nvim Lua:+    https://github.com/nanotee/nvim-lua-guide++                                                                  *lua-compat*+Lua 5.1 is the permanent interface for Nvim Lua.  Plugins need only consider+Lua 5.1, not worry about forward-compatibility with future Lua versions.  If+Nvim ever ships with Lua 5.4+, a Lua 5.1 compatibility shim will be provided+so that old plugins continue to work transparently.++------------------------------------------------------------------------------+LUA CONCEPTS AND IDIOMS                                         *lua-concepts*",Added `:help lua-concepts` to introduce key ideas and patterns of Lua. And moved the existing `lua-syntax-help` section here.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/12823,990770014,2022-10-09T10:31:04Z,CONTRIBUTING.md,"@@ -47,21 +47,19 @@ Pull requests (PRs) - Your PR must include [test coverage][run-tests]. - Avoid cosmetic changes to unrelated files in the same commit. - Use a [feature branch][git-feature-branch] instead of the master branch.-- Use a **rebase workflow** for small PRs.-  - After addressing review comments, it's fine to rebase and force-push.-- Use a **merge workflow** for big, high-risk PRs.+- Use a _rebase workflow_ for small PRs.+  - After addressing review comments, it's fine to force-push.+- Use a _merge workflow_ (as opposed to ""rebase"") for big, high-risk PRs.   - Merge `master` into your PR when there are conflicts or when master     introduces breaking changes.","Are we sure we want to encourage people merging `master` into a PR, _especially_ a big one that is likely to get merged as opposed to squashed?Since we now have a separate section on ""Merging to master"", we could remove these lines (or, better, replace them with a recommendation for contributors to ""rebase on master instead of merging master into PR"").",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20551,990778448,2022-10-09T11:50:46Z,.luacheckrc,"@@ -19,6 +19,8 @@ cache = true ignore = {   ""631"",  -- max_line_length   ""212/_.*"",  -- unused argument, for vars with ""_"" prefix+  ""121"", -- setting read-only global variable 'vim'+  ""122"", -- setting read-only field of global variable 'vim'",Will this allow cases that should be caught? Can we special case `vim` with something similar to `read_globals` (just below here)?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/19315,990842654,2022-10-09T21:31:08Z,src/nvim/eval.c,"@@ -6234,20 +6235,23 @@ char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl)   // Pre-calculate the resulting length.   list_T *list = tv->vval.v_list;   TV_LIST_ITER_CONST(list, li, {-    *len += (ptrdiff_t)strlen(tv_get_string(TV_LIST_ITEM_TV(li))) + 1;+    *len += (ptrdiff_t)strlen(tv_get_string(TV_LIST_ITEM_TV(li))) + (crlf ? 2 : 1);   });    if (*len == 0) {     return NULL;   } -  char *ret = xmalloc((size_t)(*len) + endnl);+  char *ret = xmalloc((size_t)(*len) + (size_t)endnl * (crlf ? 2 : 1));","> False evaluating to 0, etc.maybe, but technically there are some places where we cast int to `bool`. Doesn't matter in this case but it seems unnecessarily clever. In any case, it's moot because it seems like a good idea to change the `endnl` to `int` instead of adding a new `crlf` param.",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19315,990843329,2022-10-09T21:36:38Z,src/nvim/eval.c,"@@ -6175,9 +6175,10 @@ bool read_blob(FILE *const fd, blob_T *const blob) /// @param[in]  tv   Value to store as a string. /// @param[out] len  Length of the resulting string or -1 on error. /// @param[in]  endnl If true, the output will end in a newline (if a list).+/// @param[in]  crlf  If true, list items will be joined with CRLF (if a list). /// @returns an allocated string if `tv` represents a VimL string, list, or ///          number; NULL otherwise.-char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl)+char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl, bool crlf)",">     if crlf=true and endnl=false, that doesn't make sense.But this condition may exist, can't it? In L6238, we're checking only for CRLF vs LF; the value of `endnl` doesn't enter here. What should be the value of the TriState var for this line when `endnl=false`?",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19315,990846566,2022-10-09T22:05:22Z,src/nvim/eval/funcs.c,"@@ -791,22 +791,29 @@ static void f_chansend(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)    ptrdiff_t input_len = 0;   char *input = NULL;+  uint64_t id = (uint64_t)argvars[0].vval.v_number;+#ifdef UNIX+  bool crlf = false;+#else+  Channel *chan = find_channel(id);+  bool crlf = (chan != NULL && chan->term) ? true: false;+#endif",Tried in MSys2 and MSys2/MinGW64 shells in mintty shell. Works. But that's because the shells tested all require CRLF line-ending. So you're right. We need a mapping table or similar to decide based on `shell`.,
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/19315,990847601,2022-10-09T22:14:16Z,src/nvim/eval.c,"@@ -6175,9 +6175,10 @@ bool read_blob(FILE *const fd, blob_T *const blob) /// @param[in]  tv   Value to store as a string. /// @param[out] len  Length of the resulting string or -1 on error. /// @param[in]  endnl If true, the output will end in a newline (if a list).+/// @param[in]  crlf  If true, list items will be joined with CRLF (if a list). /// @returns an allocated string if `tv` represents a VimL string, list, or ///          number; NULL otherwise.-char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl)+char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl, bool crlf)","Sadly, still confused.There are two places where `endnl` and `crlf` are used.```    *len += (ptrdiff_t)strlen(tv_get_string(TV_LIST_ITEM_TV(li))) + (crlf ? 2 : 1);  // Ln6238<snip>  char *ret = xmalloc((size_t)(*len) + (endnl ? (crlf ? 2 : 1) : 0));                          // Ln6245```In the second case, I understand there are three possible values, so a tristate variable. But if `endnl` is 0, which _is_ the case with the two places this function is called from<sup>[1],[2]</sup>, how am I to know whether to use `CRLF` or `LF` in Ln6238?I may be completely missing your point.[1]: https://github.com/3N4N/neovim/blob/05d3625486a7/src/nvim/eval/funcs.c#L809[2]: https://github.com/3N4N/neovim/blob/05d3625486a7/src/nvim/eval.c#L5691",X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19175,991436378,2022-10-10T15:51:11Z,src/nvim/globals.h,"@@ -224,7 +224,7 @@ EXTERN dict_T vimvardict;                   // Dictionary with v: variables EXTERN dict_T globvardict;                  // Dictionary with g: variables /// g: value #define globvarht globvardict.dv_hashtab-EXTERN int did_emsg;                        // set by emsg() when the message+EXTERN bool did_emsg;                       // set by emsg() when the message",Because it can be larger than 1 and compared with a smaller value.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/19175,991453388,2022-10-10T16:11:57Z,src/nvim/globals.h,"@@ -224,7 +224,7 @@ EXTERN dict_T vimvardict;                   // Dictionary with v: variables EXTERN dict_T globvardict;                  // Dictionary with g: variables /// g: value #define globvarht globvardict.dv_hashtab-EXTERN int did_emsg;                        // set by emsg() when the message+EXTERN bool did_emsg;                       // set by emsg() when the message","It can cause duplicate error messages in expression parsing, and it is causing a unit test failure in #20574.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20545,991997302,2022-10-11T08:23:05Z,runtime/doc/news.txt,"@@ -13,6 +13,23 @@ BREAKING CHANGES                                                *news-breaking*  The following changes may require adaptations in user config or plugins. +Cscope (and all its relations) were removed:",This reads a little ambiguous to me. A link from where to where?,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,992118610,2022-10-11T10:04:42Z,.clangd,"@@ -1,2 +1,39 @@ CompileFlags:-  CompilationDatabase: build/       # Search build/ directory for compile_commands.json+  # Search build/ directory for compile_commands.json+  CompilationDatabase: build+---+# Additional useful checks that are too noisy to be included in .clang-tidy+If:+  PathMatch: src/nvim/api/.*","just so we're on the same page, this `If` only restricts the following fragments, this means: - src/nvim/api: all configured clang-tidy checks +  these defined here (misc, perf, etc)- everything else: only use configured clang-tidy checks<details><summary>Demo: notice how the ""readability-identifier-naming"" is only firing for the file in ""src/nvim/api""</summary>![image](https://user-images.githubusercontent.com/59826753/195060549-cdc633ed-b344-4ff8-b086-69e41053154e.png)</details>given the above,  you still want me to revert this and make these checks global?",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/20578,992143430,2022-10-11T10:29:49Z,cmake/GenerateVersion.cmake,"@@ -1,33 +1,33 @@-if(NVIM_VERSION_MEDIUM)-  message(STATUS ""USING NVIM_VERSION_MEDIUM: ${NVIM_VERSION_MEDIUM}"")-  return()-endif()--set(NVIM_VERSION_MEDIUM+set(NVIM_VERSION     ""v${NVIM_VERSION_MAJOR}.${NVIM_VERSION_MINOR}.${NVIM_VERSION_PATCH}${NVIM_VERSION_PRERELEASE}"")  execute_process(   COMMAND git describe --first-parent --dirty --always   OUTPUT_VARIABLE GIT_TAG+  OUTPUT_STRIP_TRAILING_WHITESPACE   RESULT_VARIABLE RES)  if(RES AND NOT RES EQUAL 0)-  message(STATUS ""Using NVIM_VERSION_MEDIUM: ${NVIM_VERSION_MEDIUM}"")-  file(WRITE ""${OUTPUT}"" ""${NVIM_VERSION_STRING}"")+  message(STATUS ""Using NVIM_VERSION: ${NVIM_VERSION}"")+  file(WRITE ""${OUTPUT}"" """")   return() endif() -string(STRIP ""${GIT_TAG}"" GIT_TAG)-string(REGEX REPLACE ""^v[0-9]+.[0-9]+.[0-9]+-"" """" NVIM_VERSION_GIT ""${GIT_TAG}"")-set(NVIM_VERSION_MEDIUM ""${NVIM_VERSION_MEDIUM}-${NVIM_VERSION_GIT}"")-set(NVIM_VERSION_STRING ""#define NVIM_VERSION_MEDIUM \""${NVIM_VERSION_MEDIUM}\""\n"")+# `git describe` annotates the most recent tagged release; for pre-release+# builds we append that to the dev version.+if(NVIM_VERSION_PRERELEASE)+  string(REGEX REPLACE ""^v[0-9]+.[0-9]+.[0-9]+-"" """" NVIM_VERSION_GIT ""${GIT_TAG}"")+  set(NVIM_VERSION ""${NVIM_VERSION}+${NVIM_VERSION_GIT}"")","This PR will make the version look like```v0.9.0-dev+67-g625ba79be```, which is how it used to look with `scripts/update_version_stamp.lua` while the one in master currently looks like```v0.9.0-dev-67-g625ba79be```I didn't mention this in the commit message because I thought it was purely a stylistic choice. I will update the commit message.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20578,992145914,2022-10-11T10:32:32Z,cmake/GenerateVersion.cmake,"@@ -1,33 +1,33 @@-if(NVIM_VERSION_MEDIUM)-  message(STATUS ""USING NVIM_VERSION_MEDIUM: ${NVIM_VERSION_MEDIUM}"")-  return()-endif()--set(NVIM_VERSION_MEDIUM+set(NVIM_VERSION     ""v${NVIM_VERSION_MAJOR}.${NVIM_VERSION_MINOR}.${NVIM_VERSION_PATCH}${NVIM_VERSION_PRERELEASE}"")  execute_process(   COMMAND git describe --first-parent --dirty --always   OUTPUT_VARIABLE GIT_TAG+  OUTPUT_STRIP_TRAILING_WHITESPACE   RESULT_VARIABLE RES)  if(RES AND NOT RES EQUAL 0)-  message(STATUS ""Using NVIM_VERSION_MEDIUM: ${NVIM_VERSION_MEDIUM}"")-  file(WRITE ""${OUTPUT}"" ""${NVIM_VERSION_STRING}"")+  message(STATUS ""Using NVIM_VERSION: ${NVIM_VERSION}"")+  file(WRITE ""${OUTPUT}"" """")   return() endif() -string(STRIP ""${GIT_TAG}"" GIT_TAG)-string(REGEX REPLACE ""^v[0-9]+.[0-9]+.[0-9]+-"" """" NVIM_VERSION_GIT ""${GIT_TAG}"")-set(NVIM_VERSION_MEDIUM ""${NVIM_VERSION_MEDIUM}-${NVIM_VERSION_GIT}"")-set(NVIM_VERSION_STRING ""#define NVIM_VERSION_MEDIUM \""${NVIM_VERSION_MEDIUM}\""\n"")+# `git describe` annotates the most recent tagged release; for pre-release+# builds we append that to the dev version.+if(NVIM_VERSION_PRERELEASE)+  string(REGEX REPLACE ""^v[0-9]+.[0-9]+.[0-9]+-"" """" NVIM_VERSION_GIT ""${GIT_TAG}"")+  set(NVIM_VERSION ""${NVIM_VERSION}+${NVIM_VERSION_GIT}"")","Wouldn't```v0.9.0-dev-67+g625ba79be```be the correct format then (`67` is a strictly increasing commit counter, so larger == later, but `g625ba79be` is a commit hash that shouldn't be compared for ordering purposes)?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20596,992435505,2022-10-11T14:53:32Z,src/nvim/mark.c,"@@ -645,31 +645,28 @@ fmark_T *getnextmark(pos_T *startpos, int dir, int begin_line) // until the mark is used to avoid a long startup delay. static void fname2fnum(xfmark_T *fm) {-  char_u *p;-   if (fm->fname != NULL) {     // First expand ""~/"" in the file name to the home directory.     // Don't expand the whole name, it may contain other '~' chars.-    if (fm->fname[0] == '~' && (fm->fname[1] == '/' #ifdef BACKSLASH_IN_FILENAME-                                || fm->fname[1] == '\\'+    if (fm->fname[0] == '~' && (fm->fname[1] == '/' || fm->fname[1] == '\\')) {+#else+    if (fm->fname[0] == '~' && (fm->fname[1] == '/')) { #endif",I have thought about this several times: Is it really worthy to create duplicate code to fix lint failures? Or is it better to add `// NOLINT` instead?,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20596,992442211,2022-10-11T14:58:53Z,src/nvim/mark.c,"@@ -645,31 +645,28 @@ fmark_T *getnextmark(pos_T *startpos, int dir, int begin_line) // until the mark is used to avoid a long startup delay. static void fname2fnum(xfmark_T *fm) {-  char_u *p;-   if (fm->fname != NULL) {     // First expand ""~/"" in the file name to the home directory.     // Don't expand the whole name, it may contain other '~' chars.-    if (fm->fname[0] == '~' && (fm->fname[1] == '/' #ifdef BACKSLASH_IN_FILENAME-                                || fm->fname[1] == '\\'+    if (fm->fname[0] == '~' && (fm->fname[1] == '/' || fm->fname[1] == '\\')) {+#else+    if (fm->fname[0] == '~' && (fm->fname[1] == '/')) { #endif","Even though there is a bit of duplicate code, I find it so much easier to read.The trailing `)) {` is very ugly.",X
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15601,992480948,2022-10-11T15:31:40Z,.clangd,"@@ -1,2 +1,39 @@ CompileFlags:-  CompilationDatabase: build/       # Search build/ directory for compile_commands.json+  # Search build/ directory for compile_commands.json+  CompilationDatabase: build+---+# Additional useful checks that are too noisy to be included in .clang-tidy+If:+  PathMatch: src/nvim/api/.*",For example I no longer get any warnings about unnecessary casts.I also still don't understand why we should separate files from `src/nvim/api` from the rest of the files.,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,992529102,2022-10-11T16:11:01Z,.clangd,"@@ -1,2 +1,39 @@ CompileFlags:-  CompilationDatabase: build/       # Search build/ directory for compile_commands.json+  # Search build/ directory for compile_commands.json+  CompilationDatabase: build+---+# Additional useful checks that are too noisy to be included in .clang-tidy+If:+  PathMatch: src/nvim/api/.*","oh, okay I think I can see that you mean `readability-non-const-parameter` is useful, where you'd still want it on for all the files.either way, I'll remove the guard since we can always put it back if it's too noisy.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20600,993352803,2022-10-12T11:48:20Z,src/nvim/option.c,"@@ -2042,10 +2042,9 @@ static char *set_bool_option(const int opt_idx, char_u *const varp, const int va     }     redraw_titles();     modified_was_set = value;-  }  #ifdef BACKSLASH_IN_FILENAME-  else if ((int *)varp == &p_ssl) {+  } else if ((int *)varp == &p_ssl) {","This is changing the scope. To make sure this does not change the semantics, we need to check all permutations if the `#ifdef` layers. Even if you did that, it could cause a subtle bug when merging a vim patch later. That's why I don't think this change is worth the risk.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20600,993356167,2022-10-12T11:51:24Z,src/nvim/option.c,"@@ -2042,10 +2042,9 @@ static char *set_bool_option(const int opt_idx, char_u *const varp, const int va     }     redraw_titles();     modified_was_set = value;-  }  #ifdef BACKSLASH_IN_FILENAME-  else if ((int *)varp == &p_ssl) {+  } else if ((int *)varp == &p_ssl) {","How is it changing the scope?> To make sure this does not change the semantics, we need to check all permutations if the #ifdef layers.There is only one layer here.We are just shifting the `}` down.If you look at this not in diff mode, you'll see it is now easier to read.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20619,993396466,2022-10-12T12:32:45Z,src/clint.py,"@@ -2547,22 +2547,23 @@ def CheckStyle(filename, clean_lines, linenum, error):     # if(match(prev, "" +for \\("")) complain = 0;     # if(prevodd && match(prevprev, "" +for \\("")) complain = 0;     initial_spaces = 0-    cleansed_line = clean_lines.elided[linenum]+    # cleansed_line = clean_lines.elided[linenum]      while initial_spaces < len(line) and line[initial_spaces] == ' ':         initial_spaces += 1 -    if (cleansed_line.count(';') > 1 and-        # for loops are allowed two ;'s (and may run over two lines).-        cleansed_line.find('for') == -1 and-        (GetPreviousNonBlankLine(clean_lines, linenum)[0].find('for') == -1 or-         GetPreviousNonBlankLine(clean_lines, linenum)[0].find(';') != -1) and-        # It's ok to have many commands in a switch case that fits in 1 line-        not ((cleansed_line.find('case ') != -1 or-              cleansed_line.find('default:') != -1) and-             cleansed_line.find('break;') != -1)):-        error(filename, linenum, 'whitespace/newline', 0,-              'More than one command on the same line')+    # Disable this check as it is mostly covered by uncrustify",why not use simply use `--filter=-whitespace/newline` as an argument?seehttps://github.com/neovim/neovim/blob/eeeb6c80d8f32efee8d13ec4a56a7d487a28eba0/src/clint.py#L86-L97,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20619,993409999,2022-10-12T12:42:19Z,src/clint.py,"@@ -2547,22 +2547,23 @@ def CheckStyle(filename, clean_lines, linenum, error):     # if(match(prev, "" +for \\("")) complain = 0;     # if(prevodd && match(prevprev, "" +for \\("")) complain = 0;     initial_spaces = 0-    cleansed_line = clean_lines.elided[linenum]+    # cleansed_line = clean_lines.elided[linenum]      while initial_spaces < len(line) and line[initial_spaces] == ' ':         initial_spaces += 1 -    if (cleansed_line.count(';') > 1 and-        # for loops are allowed two ;'s (and may run over two lines).-        cleansed_line.find('for') == -1 and-        (GetPreviousNonBlankLine(clean_lines, linenum)[0].find('for') == -1 or-         GetPreviousNonBlankLine(clean_lines, linenum)[0].find(';') != -1) and-        # It's ok to have many commands in a switch case that fits in 1 line-        not ((cleansed_line.find('case ') != -1 or-              cleansed_line.find('default:') != -1) and-             cleansed_line.find('break;') != -1)):-        error(filename, linenum, 'whitespace/newline', 0,-              'More than one command on the same line')+    # Disable this check as it is mostly covered by uncrustify","@lewis6991, be sure to remove this one as wellhttps://github.com/neovim/neovim/blob/eeeb6c80d8f32efee8d13ec4a56a7d487a28eba0/src/clint.py#L179",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20595,993476805,2022-10-12T13:40:24Z,runtime/lua/vim/fs.lua,"@@ -133,7 +134,7 @@ function M.find(names, opts)         local t = {}         for name, type in M.dir(p) do           if names(name) and (not opts.type or opts.type == type) then-            table.insert(t, p .. '/' .. name)+            table.insert(t, p .. path_sep .. name)","Using ""/"" was an intentional choice of vim.fs.If there are some `\` separators coming from somewhere, those can be normalized.For purposes of https://github.com/neovim/neovim/issues/20594 , forget about 'shellslash' and anything else in this PR. Let's focus on normalizing `\` slashes to `/` slashes.In the future, if there's some use-case where people really need `\` slashes, we can provide a parameter to `vim.fs.normalize()` that allows them to do that in the caller. We aren't going to do it internally (i.e. in fs.lua).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20621,993500162,2022-10-12T13:56:06Z,src/nvim/drawline.c,"@@ -391,21 +392,34 @@ static bool use_cursor_line_nr(win_T *wp, linenr_T lnum, int row, int startrow, static inline void get_line_number_str(win_T *wp, linenr_T lnum, char_u *buf, size_t buf_len) {   long num;+  long rnum = -1;   char *fmt = ""%*ld "";    if (wp->w_p_nu && !wp->w_p_rnu) {     // 'number' + 'norelativenumber'     num = (long)lnum;   } else {     // 'relativenumber', don't use negative numbers-    num = labs((long)get_cursor_rel_lnum(wp, lnum));+    rnum = num = labs((long)get_cursor_rel_lnum(wp, lnum));","nit: I think we usually prefer this:```suggestion    num = labs((long)get_cursor_rel_lnum(wp, lnum));    rnum = num;```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20621,993510629,2022-10-12T14:03:56Z,runtime/doc/options.txt,"@@ -4390,6 +4390,27 @@ A jump table for the options with a short description can be found at |Q_op|. 	    |nobody         |  3 nobody     |  0 nobody     |3   nobody 	    |there          |  4 there      |  1 there      |  1 there +				*'numberformat'* *'nuf'*+'numberformat' 'nuf'	string	(default: empty)+			local to window+	When this option is not empty, it determines the content of the number+	column. The format of this option is like that of 'statusline'. The+	variables *g:nuflnum* and *g:nufrnum* will be set to the to be printed line","can/should they be `v:` vars? Similar to `v:event`, maybe a common container like `v:redraw` is a good pattern. So these would be `v:redraw.lnum` and `v:redraw.relnum`.Related to performance, accessing vimscript dicts (`g:`, `v:`) is slow, but we might be able to optimize `v:` vars because they are readonly.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,993544221,2022-10-12T14:31:37Z,src/nvim/statusline.c,"@@ -653,8 +653,9 @@ void win_redr_custom(win_T *wp, bool draw_winbar, bool draw_ruler) /// @param tabtab  Tab clicks definition (can be NULL). /// /// @return  The final width of the statusline-int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, int use_sandbox, int fillchar,-                     int maxwidth, stl_hlrec_t **hltab, StlClickRecord **tabtab)+int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, char *opt_name,+                     int use_sandbox, int fillchar, int maxwidth, int *truncate,+                     stl_hlrec_t **hltab, StlClickRecord **tabtab)",I changed this function signature before realizing it was an API function. It's not strictly necessary I think. I could find a different solution if preferred but passing in the option name that the `fmt` format string belongs to allows us to remove some code duplication. Rather than checking for `did_emsg` around each `build_stl_str_hl()` call we can do it in the function and reset the option there.I am returning the truncated width to make sure that the returned string fits in the number column (up to a maximum of 20). Made sense to me to dynamically make the number column wider when necessary but if we cannot change this function signature(API contract?) a different approach would be needed. Making a best guess of the format string width in `'number_width()` would seems to be the best next option to me. But this could result in unnecessary truncation if the format string width is not proportionate to the line number width.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,993553961,2022-10-12T14:39:24Z,src/nvim/drawline.c,"@@ -391,21 +392,34 @@ static bool use_cursor_line_nr(win_T *wp, linenr_T lnum, int row, int startrow, static inline void get_line_number_str(win_T *wp, linenr_T lnum, char_u *buf, size_t buf_len) {   long num;+  long rnum = -1;   char *fmt = ""%*ld "";    if (wp->w_p_nu && !wp->w_p_rnu) {     // 'number' + 'norelativenumber'     num = (long)lnum;   } else {     // 'relativenumber', don't use negative numbers-    num = labs((long)get_cursor_rel_lnum(wp, lnum));+    rnum = num = labs((long)get_cursor_rel_lnum(wp, lnum));     if (num == 0 && wp->w_p_nu && wp->w_p_rnu) {       // 'number' + 'relativenumber'       num = lnum;       fmt = ""%-*ld "";     }   } +  if (*wp->w_p_nuf != NUL) {+    // 'numberformat', set variables+    typval_T tv = { .v_type = VAR_NUMBER };++    num = ' ';+    fmt = ""%*c "";+    tv.vval.v_number = wp->w_p_nu ? lnum : 0;+    set_var(S_LEN(""g:nuflnum""), &tv, false);+    tv.vval.v_number = rnum;+    set_var(S_LEN(""g:nufrnum""), &tv, false);",Set global variables to be used in the format expression eval block `%{}`. We could also add new format expression items containing the to be printed (relative)number. To do so we would have to pass along these values to `build_stl_str_hl()` or store them in the window structure or make them an internal global variable instead. Should allow for better performance for more simple cases that then don't require an eval block. More complicated cases need to be evaluated inside an eval block anyways though.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,993698140,2022-10-12T16:51:28Z,src/nvim/statusline.c,"@@ -653,8 +653,9 @@ void win_redr_custom(win_T *wp, bool draw_winbar, bool draw_ruler) /// @param tabtab  Tab clicks definition (can be NULL). /// /// @return  The final width of the statusline-int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, int use_sandbox, int fillchar,-                     int maxwidth, stl_hlrec_t **hltab, StlClickRecord **tabtab)+int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, char *opt_name,+                     int use_sandbox, int fillchar, int maxwidth, int *truncate,+                     stl_hlrec_t **hltab, StlClickRecord **tabtab)","I see, I take it the change is fine then? I did look around on github, seems lualine uses it for [testing](https://github.com/nvim-lualine/lualine.nvim/blob/8a9c97d111142216c53f83d69030fd9bfe753bb7/tests/statusline.lua#L94), guess they will have to adapt.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20621,993746054,2022-10-12T17:48:53Z,src/nvim/statusline.c,"@@ -653,8 +653,9 @@ void win_redr_custom(win_T *wp, bool draw_winbar, bool draw_ruler) /// @param tabtab  Tab clicks definition (can be NULL). /// /// @return  The final width of the statusline-int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, int use_sandbox, int fillchar,-                     int maxwidth, stl_hlrec_t **hltab, StlClickRecord **tabtab)+int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, char *opt_name,+                     int use_sandbox, int fillchar, int maxwidth, int *truncate,+                     stl_hlrec_t **hltab, StlClickRecord **tabtab)","> seems lualine uses it for [testing](https://github.com/nvim-lualine/lualine.nvim/blob/8a9c97d111142216c53f83d69030fd9bfe753bb7/tests/statusline.lua#L94), guess they will have to adapt.There is no API contract for FFI consumers, yet. That is 100% unsupported.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20545,994588028,2022-10-13T12:37:39Z,runtime/doc/news.txt,"@@ -13,6 +13,23 @@ BREAKING CHANGES                                                *news-breaking*  The following changes may require adaptations in user config or plugins. +Cscope (and all its relations) were removed:","* In the same breath we should mention that `ctags will NEVER be removed, only cscope was removed.`* Instead of listing all these things here we could link to `:help cscope` or `:help nvim-features-removed` ?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20545,994747952,2022-10-13T14:47:23Z,runtime/doc/vim_diff.txt,"@@ -578,6 +582,13 @@ Options:   conskey (MS-DOS)   *'cp'* *'nocompatible'* *'nocp'* *'compatible'* (Nvim is always ""nocompatible"".)   'cpoptions' (gjkHw<*- and all POSIX flags were removed)+  *'cscopepathcomp'*+  *'cscopeprg'*+  *'cscopequickfix'*+  *'cscoperelative'*+  *'cscopetag'*+  *'cscopetagorder'*+  *'cscopeverbose'*","oh god, why.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20545,994808578,2022-10-13T15:33:34Z,runtime/doc/news.txt,"@@ -13,6 +13,23 @@ BREAKING CHANGES                                                *news-breaking*  The following changes may require adaptations in user config or plugins. +Cscope (and all its relations) were removed:","> In the same breath we should mention that ctags will NEVER be removed, only cscope was removed.""never"" is very strong, but I'll mention there are no plans to remove it.> Instead of listing all these things here we could link to :help cscope or :help nvim-features-removed ?The items here are a bit scattered in `vim_diff.txt`, so I think it's there's value in having them grouped here.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20621,995233573,2022-10-14T00:42:27Z,src/nvim/statusline.c,"@@ -1804,5 +1811,14 @@ int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, int use_san     curwin->w_redr_type = save_redr_type;   } +  // Check for an error.  If there is one we would loop in redrawing the screen.+  // Avoid that by making the corresponding option empty. Pass OPT_LOCAL for+  // 'numberformat' and 'statusline' if appropriate.+  if (did_emsg != save_did_emsg) {+    int scope = *opt_name == 'n' || (*opt_name == 's' && *wp->w_p_stl != NUL)","The purpose is to avoid accidental bugs if a new `opt` is used which also starts with ""n"" or ""s"".",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20599,995524109,2022-10-14T08:58:05Z,src/nvim/shada.c,"@@ -1191,17 +1189,15 @@ static void shada_read(ShaDaReadDef *const sd_reader, const int flags)     case kSDItemSearchPattern:       if (!force) {         SearchPattern pat;-        (cur_entry.data.search_pattern.is_substitute_pattern-           ? &get_substitute_pattern-           : &get_search_pattern)(&pat);+        (cur_entry.data.search_pattern.is_substitute_pattern ?+         &get_substitute_pattern : &get_search_pattern)(&pat);","actually, I think ternary is a bad choice here",
35012635,matveyt,https://api.github.com/repos/neovim/neovim/pulls/20637,995654524,2022-10-14T11:25:06Z,runtime/colors/blue.vim,"@@ -18,6 +18,13 @@ let s:t_Co = &t_Co if (has('termguicolors') && &termguicolors) || has('gui_running')   let g:terminal_ansi_colors = ['#000000', '#cd0000', '#00cd00', '#cdcd00', '#0000ee', '#cd00cd', '#00cdcd', '#e5e5e5', '#7f7f7f', '#ff0000', '#00ff00', '#ffff00', '#5c5cff', '#ff00ff', '#00ffff', '#ffffff'] endif++if exists('g:terminal_ansi_colors')+  for color in g:terminal_ansi_colors+    "" convert to Nvim's highlight groups for terminal buffers+    execute 'let g:terminal_color_' .. index(g:terminal_ansi_colors, color) .. ' = ' .. 'color'","> may be better?Iterating over `items()` is much more compact but, unfortunately, Neovim doesn't (yet) support calling `items(list)` .",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20664,996366310,2022-10-15T23:37:46Z,runtime/doc/dev_style.txt,"@@ -789,55 +789,6 @@ example, `""\uFEFF""`, is the Unicode zero-width no-break space character, which would be invisible if included in the source as straight UTF-8.  -Function Declarations and Definitions ~","+1 These guidelines are really verbose, so good to remove. Later we might play with having very terse guidelines in `:help dev-style`, but for now, just cutting out all of this verbosity for things covered by automated rules, makes it easier to find an optimum. Noise is harmful to users because it hides valuable parts; and that's why we remove old, dead features.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19615,996409181,2022-10-16T08:31:37Z,runtime/doc/supported_platforms.txt,"@@ -0,0 +1,55 @@+*supported_platforms.txt*          Nvim+++                            NVIM REFERENCE MANUAL+++Supported platforms					*supported-platform*++This is a list of supported platforms for neovim.",```suggestionThis is a list of supported platforms for Nvim.```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/19615,996418862,2022-10-16T09:52:17Z,README.md,"@@ -53,7 +53,7 @@ Pre-built packages for Windows, macOS, and Linux are found on the Install from source ------------------- -See the [Building Neovim](https://github.com/neovim/neovim/wiki/Building-Neovim) wiki page for details.+See the [Building Neovim](https://github.com/neovim/neovim/wiki/Building-Neovim) wiki page and [Support](https://neovim.io/doc/user/support.html) for details.",I would like to keep the explicit link to the list of supported platforms here.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20704,997565468,2022-10-17T22:38:31Z,src/nvim/testdir/test_filetype.vim,"@@ -1962,4 +1962,36 @@ func Test_inc_file()   filetype off endfunc +func Test_lsl_file()+  filetype on++  call writefile(['looks like Linden Scripting Language'], 'Xfile.lsl')","Another way to deal with this that I can think of is to just make `D` flag no-op. That avoids divergence in tests, but leaves files behind. Not sure what to do here.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/20184,997927555,2022-10-18T09:01:54Z,src/nvim/api/win_config.c,"@@ -330,7 +354,90 @@ static bool parse_float_bufpos(Array bufpos, lpos_T *out)   return true; } -static void parse_border_style(Object style, FloatConfig *fconfig, Error *err)+static void parse_border_title(Object title, Object title_pos, Object width, FloatConfig *fconfig,+                               Error *err)+{+  if (!parse_title_pos(title_pos, fconfig, err)) {+    return;+  }++  if (title.type == kObjectTypeString) {+    if (title.data.string.size == 0) {+      fconfig->title = false;+      return;+    }+    fconfig->title_text = xstrdup(title.data.string.data);+    int hl_id = object_to_hl_id(title, ""border title highlight"", err);+    fconfig->title_hi_id = hl_id;","as a simplification of the data structure, We could manually allocate a VirtText of size one and put a single chunk with the title_text + hl_id of ""FloatBorderTitle"", then we don't need to deal with this case outside of this function.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20157,1000036093,2022-10-20T00:23:24Z,src/nvim/generators/gen_eval.lua,"@@ -27,6 +27,20 @@ local hashy = require'generators.hashy'  local hashpipe = io.open(funcsfname, 'wb') +hashpipe:write([[+#include ""nvim/arglist.h""+#include ""nvim/cmdhist.h""+#include ""nvim/digraph.h""+#include ""nvim/fold.h""+#include ""nvim/insexpand.h""+#include ""nvim/mapping.h""+#include ""nvim/match.h""+#include ""nvim/quickfix.h""+#include ""nvim/sign.h""+#include ""nvim/testing.h""","```suggestion#include ""nvim/arglist.h""#include ""nvim/cmdexpand.h""#include ""nvim/cmdhist.h""#include ""nvim/digraph.h""#include ""nvim/eval/funcs.h""#include ""nvim/eval/typval.h""#include ""nvim/eval/vars.h""#include ""nvim/ex_docmd.h""#include ""nvim/ex_getln.h""#include ""nvim/fold.h""#include ""nvim/getchar.h""#include ""nvim/insexpand.h""#include ""nvim/mapping.h""#include ""nvim/match.h""#include ""nvim/mbyte.h""#include ""nvim/menu.h""#include ""nvim/move.h""#include ""nvim/quickfix.h""#include ""nvim/search.h""#include ""nvim/sign.h""#include ""nvim/testing.h""```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20157,1000036586,2022-10-20T00:24:43Z,src/nvim/generators/gen_ex_cmds.lua,"@@ -49,6 +49,24 @@ enumfile:write([[ typedef enum CMD_index { ]]) defsfile:write(string.format([[+#include ""nvim/cmdhist.h""+#include ""nvim/diff.h""+#include ""nvim/eval/vars.h""+#include ""nvim/ex_eval.h""+#include ""nvim/ex_session.h""+#include ""nvim/hardcopy.h""+#include ""nvim/help.h""+#include ""nvim/locale.h""+#include ""nvim/lua/executor.h""+#include ""nvim/mapping.h""+#include ""nvim/match.h""+#include ""nvim/menu.h""+#include ""nvim/sign.h""+#include ""nvim/spell.h""+#include ""nvim/spellfile.h""+#include ""nvim/syntax.h""+#include ""nvim/version.h""","```suggestion#include ""nvim/arglist.h""#include ""nvim/autocmd.h""#include ""nvim/buffer.h""#include ""nvim/cmdhist.h""#include ""nvim/debugger.h""#include ""nvim/diff.h""#include ""nvim/digraph.h""#include ""nvim/eval.h""#include ""nvim/eval/userfunc.h""#include ""nvim/eval/vars.h""#include ""nvim/ex_cmds.h""#include ""nvim/ex_cmds2.h""#include ""nvim/ex_docmd.h""#include ""nvim/ex_eval.h""#include ""nvim/ex_session.h""#include ""nvim/hardcopy.h""#include ""nvim/help.h""#include ""nvim/locale.h""#include ""nvim/lua/executor.h""#include ""nvim/mapping.h""#include ""nvim/mark.h""#include ""nvim/match.h""#include ""nvim/menu.h""#include ""nvim/message.h""#include ""nvim/ops.h""#include ""nvim/option.h""#include ""nvim/profile.h""#include ""nvim/quickfix.h""#include ""nvim/runtime.h""#include ""nvim/sign.h""#include ""nvim/spell.h""#include ""nvim/spellfile.h""#include ""nvim/syntax.h""#include ""nvim/undo.h""#include ""nvim/usercmd.h""#include ""nvim/version.h""```",
1217449,ychin,https://api.github.com/repos/neovim/neovim/pulls/20690,1000037558,2022-10-20T00:27:13Z,scripts/gen_help_html.lua,"@@ -512,6 +532,8 @@ local function visit_node(root, level, lang_tree, headings, opt, stats)     end     local el = in_heading and 'span' or 'code'     local s = ('%s<a name=""%s""></a><%s class=""%s"">%s</%s>'):format(ws(), url_encode(tagname), el, cssclass, trimmed, el)+    s = fix_tab_after_conceal(s, node_text(root:next_sibling()))","Yeah I was being a little lazy there. I think with or without the two-space insertion it still generates the same rendered output but then it's not necessary to add the two spaces for new-style ones then. Added the check. Just to confirm, after my change, now we can see that the new style docs weren't changed:```��� ychin ~/Dev/external/neovim/target% diff dir/api.html dir_clean/api.html 5064c5064<         Generated at 2022-10-19 17:23 from <code><a href=""https://github.com/neovim/neovim/commit/?"">?</a></code>--->         Generated at 2022-10-19 17:22 from <code><a href=""https://github.com/neovim/neovim/commit/?"">?</a></code>��� ychin ~/Dev/external/neovim/target% diff dir/nvim.html dir_clean/nvim.html169c169<         Generated at 2022-10-19 17:23 from <code><a href=""https://github.com/neovim/neovim/commit/?"">?</a></code>--->         Generated at 2022-10-19 17:22 from <code><a href=""https://github.com/neovim/neovim/commit/?"">?</a></code>```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20157,1000037574,2022-10-20T00:27:15Z,src/nvim/fileio.c,"@@ -6,62 +6,67 @@ #include <assert.h> #include <errno.h> #include <fcntl.h>+#include <iconv.h> #include <inttypes.h>+#include <limits.h> #include <stdbool.h>+#include <stdio.h> #include <string.h>+#include <sys/stat.h>+#include <uv.h> -#include ""nvim/api/private/helpers.h""+#include ""auto/config.h"" #include ""nvim/ascii.h""+#include ""nvim/autocmd.h"" #include ""nvim/buffer.h""+#include ""nvim/buffer_defs.h"" #include ""nvim/buffer_updates.h"" #include ""nvim/change.h""-#include ""nvim/charset.h"" #include ""nvim/cursor.h"" #include ""nvim/diff.h"" #include ""nvim/drawscreen.h"" #include ""nvim/edit.h"" #include ""nvim/eval.h""-#include ""nvim/eval/typval.h""-#include ""nvim/eval/userfunc.h"" #include ""nvim/ex_cmds.h""-#include ""nvim/ex_docmd.h"" #include ""nvim/ex_eval.h"" #include ""nvim/fileio.h"" #include ""nvim/fold.h""-#include ""nvim/func_attr.h"" #include ""nvim/garray.h"" #include ""nvim/getchar.h""-#include ""nvim/hashtab.h""+#include ""nvim/gettext.h""+#include ""nvim/highlight_defs.h"" #include ""nvim/iconv.h"" #include ""nvim/input.h""+#include ""nvim/log.h""+#include ""nvim/macros.h"" #include ""nvim/mbyte.h"" #include ""nvim/memfile.h"" #include ""nvim/memline.h"" #include ""nvim/memory.h"" #include ""nvim/message.h"" #include ""nvim/move.h""-#include ""nvim/normal.h"" #include ""nvim/option.h"" #include ""nvim/optionstr.h""+#include ""nvim/os/fs_defs.h"" #include ""nvim/os/input.h"" #include ""nvim/os/os.h""-#include ""nvim/os/os_defs.h"" #include ""nvim/os/time.h"" #include ""nvim/os_unix.h"" #include ""nvim/path.h""-#include ""nvim/quickfix.h""+#include ""nvim/pos.h"" #include ""nvim/regexp.h""-#include ""nvim/search.h""+#include ""nvim/screen.h"" #include ""nvim/sha256.h"" #include ""nvim/shada.h""-#include ""nvim/state.h"" #include ""nvim/strings.h"" #include ""nvim/types.h"" #include ""nvim/ui.h""-#include ""nvim/ui_compositor.h"" #include ""nvim/undo.h"" #include ""nvim/vim.h""-#include ""nvim/window.h""++#if defined(__APPLE__) || defined(BSD)",This `#if` condition doesn't look right. Looking at the code I guess it should be `#ifdef BACKSLASH_IN_FILENAME`.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20578,1000457874,2022-10-20T10:37:38Z,cmake/GenerateVersion.cmake,"@@ -1,33 +1,34 @@-if(NVIM_VERSION_MEDIUM)-  message(STATUS ""USING NVIM_VERSION_MEDIUM: ${NVIM_VERSION_MEDIUM}"")-  return()-endif()--set(NVIM_VERSION_MEDIUM+set(NVIM_VERSION     ""v${NVIM_VERSION_MAJOR}.${NVIM_VERSION_MINOR}.${NVIM_VERSION_PATCH}${NVIM_VERSION_PRERELEASE}"")  execute_process(   COMMAND git describe --first-parent --dirty --always   OUTPUT_VARIABLE GIT_TAG+  OUTPUT_STRIP_TRAILING_WHITESPACE   RESULT_VARIABLE RES)  if(RES AND NOT RES EQUAL 0)-  message(STATUS ""Using NVIM_VERSION_MEDIUM: ${NVIM_VERSION_MEDIUM}"")-  file(WRITE ""${OUTPUT}"" ""${NVIM_VERSION_STRING}"")+  message(STATUS ""Using NVIM_VERSION: ${NVIM_VERSION}"")+  file(WRITE ""${OUTPUT}"" """")   return() endif() -string(STRIP ""${GIT_TAG}"" GIT_TAG)-string(REGEX REPLACE ""^v[0-9]+.[0-9]+.[0-9]+-"" """" NVIM_VERSION_GIT ""${GIT_TAG}"")-set(NVIM_VERSION_MEDIUM ""${NVIM_VERSION_MEDIUM}-${NVIM_VERSION_GIT}"")-set(NVIM_VERSION_STRING ""#define NVIM_VERSION_MEDIUM \""${NVIM_VERSION_MEDIUM}\""\n"")+# `git describe` annotates the most recent tagged release; for pre-release+# builds we append that to the dev version.+if(NVIM_VERSION_PRERELEASE)+  string(REGEX REPLACE ""^v[0-9]+.[0-9]+.[0-9]+-"" """" NVIM_VERSION_GIT ""${GIT_TAG}"")+  string(REGEX REPLACE ""^([0-9]+)-([a-z0-9]+)"" ""\\1+\\2"" NVIM_VERSION_GIT ""${NVIM_VERSION_GIT}"")+  set(NVIM_VERSION ""${NVIM_VERSION}-${NVIM_VERSION_GIT}"")+endif()++set(NVIM_VERSION_STRING ""#define NVIM_VERSION_MEDIUM \""${NVIM_VERSION}\""\n"")",~~Do we even need NVIM_VERSION_MEDIUM now? Looks like it holds the full version string.~~Used here (no changes needed): https://github.com/neovim/neovim/blob/10ab7489ebb2bcbc7c1b5360921978c1ca2d0a4b/src/nvim/version.c#L32-L36,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20747,1000590627,2022-10-20T12:57:42Z,runtime/doc/help.txt,"@@ -38,169 +38,126 @@ Get specific help:  It is possible to go directly to whatever you want help Vim stands for Vi IMproved.  Most of Vim was made by Bram Moolenaar, but only through the help of many others.  See |credits|. -------------------------------------------------------------------------------						*doc-file-list* *Q_ct*-BASIC:-|quickref|	Overview of the most common commands you will use-|tutor|		30-minute interactive course for beginners-|copying|	About copyrights-|iccf|		Helping poor children in Uganda-|sponsor|	Sponsor Vim development, become a registered Vim user-|www|		Vim on the World Wide Web-|bugs|		Where to send bug reports--USER MANUAL: These files explain how to accomplish an editing task.--|usr_toc.txt|	Table Of Contents--Getting Started ~-|usr_01.txt|  About the manuals-|usr_02.txt|  The first steps in Vim-|usr_03.txt|  Moving around-|usr_04.txt|  Making small changes-|usr_05.txt|  Set your settings-|usr_06.txt|  Using syntax highlighting-|usr_07.txt|  Editing more than one file-|usr_08.txt|  Splitting windows-|usr_09.txt|  Using the GUI-|usr_10.txt|  Making big changes-|usr_11.txt|  Recovering from a crash-|usr_12.txt|  Clever tricks--Editing Effectively ~-|usr_20.txt|  Typing command-line commands quickly-|usr_21.txt|  Go away and come back-|usr_22.txt|  Finding the file to edit-|usr_23.txt|  Editing other files-|usr_24.txt|  Inserting quickly-|usr_25.txt|  Editing formatted text-|usr_26.txt|  Repeating-|usr_27.txt|  Search commands and patterns-|usr_28.txt|  Folding-|usr_29.txt|  Moving through programs-|usr_30.txt|  Editing programs-|usr_31.txt|  Exploiting the GUI-|usr_32.txt|  The undo tree--Tuning Vim ~-|usr_40.txt|  Make new commands-|usr_41.txt|  Write a Vim script-|usr_42.txt|  Add new menus-|usr_43.txt|  Using filetypes-|usr_44.txt|  Your own syntax highlighted-|usr_45.txt|  Select your language---REFERENCE MANUAL: These files explain every detail of Vim.	*reference_toc*--General subjects ~-|intro.txt|	general introduction to Vim; notation used in help files-|nvim.txt|	Transitioning from Vim-|help.txt|	overview and quick reference (this file)-|helphelp.txt|	about using the help files-|index.txt|	alphabetical index of all commands-|tips.txt|	various tips on using Vim-|message.txt|	(error) messages and explanations-|develop.txt|	development of Nvim-|debug.txt|	debugging Vim itself-|uganda.txt|	Vim distribution conditions and what to do with your money+					*reference_toc* *doc-file-list* *Q_ct*+Meta ~","What's the difference between ""Meta"" and ""General""?Might be confusing; maybe simpler to have a combined list but broken up into digestible chunks by empty lines? (Then people will at least not be distracted by trying to interpret the meaning of the section headings.)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20717,1000726083,2022-10-20T14:37:49Z,runtime/lua/vim/lsp.lua,"@@ -1522,6 +1522,7 @@ function lsp.start_client(config)     nvim_exec_autocmds('LspAttach', {       buffer = bufnr,       modeline = false,+      client = client,",This should be in the `data` table,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20717,1000727384,2022-10-20T14:38:48Z,runtime/doc/lsp.txt,"@@ -89,7 +89,7 @@ calls behind capability checks: >     vim.api.nvim_create_autocmd('LspAttach', {       callback = function(args)-        local client = vim.lsp.get_client_by_id(args.data.client_id)+        local client = args.client",```suggestion        local client = args.data.client```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20717,1000727526,2022-10-20T14:38:55Z,runtime/doc/lsp.txt,"@@ -492,7 +492,7 @@ callback in the ""data"" table. Example: >     vim.api.nvim_create_autocmd(""LspAttach"", {       callback = function(args)         local bufnr = args.buf-        local client = vim.lsp.get_client_by_id(args.data.client_id)+        local client = args.client",```suggestion        local client = args.data.client```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20751,1000859165,2022-10-20T16:25:04Z,runtime/lua/vim/shared.lua,"@@ -62,7 +62,7 @@ end)() --- ---@param s string String to split ---@param sep string Separator or pattern----@param plain boolean If `true` use `sep` literally (passed to string.find)+---@param plain? boolean If `true` use `sep` literally (passed to string.find)",```suggestion---@param (plain|nil) boolean If `true` use `sep` literally (passed to string.find)```(That's the convention we've adopted throughout the codebase for optional parameters.),
82267684,uga-rosa,https://api.github.com/repos/neovim/neovim/pulls/20751,1000984521,2022-10-20T18:28:24Z,runtime/lua/vim/shared.lua,"@@ -62,7 +62,7 @@ end)() --- ---@param s string String to split ---@param sep string Separator or pattern----@param plain boolean If `true` use `sep` literally (passed to string.find)+---@param plain? boolean If `true` use `sep` literally (passed to string.find)","The same reason why nil in vim.tbl_islist is changed to false, nil is not a boolean. If nil should be returned here, modify the annotation to boolean|nil.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20683,1001536663,2022-10-21T08:49:35Z,src/nvim/version.c,"@@ -2218,7 +2218,7 @@ void intro_message(int colon)   int sponsor;   char *p;   static char *(lines[]) = {-    N_(NVIM_VERSION_LONG),+    N_(NVIM_VERSION_LONG),  // NOLINT(bugprone-suspicious-missing-comma)","shouldn't this be done at the definition, i.e. here (and must use `/* */` comment because it's a macro): https://github.com/neovim/neovim/blob/ba887da97708545f1174e387b4807119ad5a40f6/src/nvim/version.c#L37",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/19812,1001854198,2022-10-21T14:25:41Z,src/nvim/lua/treesitter.c,"@@ -362,6 +375,9 @@ static int parser_parse(lua_State *L)   buf_T *buf;   TSInput input; +  // Use redrawtime to determine the timeout+  ts_parser_set_timeout_micros(*p, (uint64_t)p_rdt * 1000);",Shouldn't the time be tracked on the Lua side. Redraw consists of multiple parsing and questing attempts (injections). When the first parsing attempt finishes the time needed should be subtracted from the deadline of the remaining tasks so that the total time budget doesn't get overly exceeded. But this PR would of course be good enough enough for a first iteration.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16270,1002270448,2022-10-22T00:19:00Z,src/nvim/syntax.c,"@@ -18,7 +18,9 @@ #include ""nvim/cursor_shape.h"" #include ""nvim/drawscreen.h"" #include ""nvim/eval.h""+#include ""nvim/eval/typval.h"" #include ""nvim/eval/vars.h""+#include ""nvim/ex_cmds2.h""",The two added headers are no longer needed.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16270,1002270474,2022-10-22T00:19:11Z,src/nvim/syntax.h,"@@ -4,6 +4,7 @@ #include <stdbool.h>  #include ""nvim/buffer_defs.h""+#include ""nvim/eval/funcs.h""",This is no longer needed.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16270,1002274054,2022-10-22T00:30:26Z,src/nvim/highlight_group.c,"@@ -2901,6 +2901,387 @@ RgbValue name_to_color(const char *name, int *idx)   return -1; } +// Convert each of the highlight attribute bits (bold, standout, underline,+// etc.) set in 'hlattr' into a separate boolean item in a Dictionary with+// the attribute name as the key.++static dict_T *highlight_get_attr_dict(int hlattr)+{+  dict_T *dict;+  int i;++  dict = tv_dict_alloc();++  for (i = 0; hl_attr_table[i] != 0; i++) {+    if (hlattr & hl_attr_table[i]) {+      tv_dict_add_bool(dict, hl_name_table[i], strlen(hl_name_table[i]), kBoolVarTrue);+      hlattr &= ~hl_attr_table[i];        // don't want ""inverse""+    }+  }++  return dict;+}++// Return the attributes of the highlight group at index 'hl_idx' as a+// Dictionary. If 'resolve_link' is true, then resolves the highlight group+// links recursively.++static dict_T *highlight_get_info(int hl_idx, bool resolve_link)+{+  dict_T *dict;+  HlGroup *sgp;+  dict_T *attr_dict;+  int hlgid;++  dict = tv_dict_alloc();++  sgp = &hl_table[hl_idx];+  // highlight group id is 1-based+  hlgid = hl_idx + 1;++  if (tv_dict_add_str(dict, S_LEN(""name""), (const char *)sgp->sg_name) == FAIL) {+    goto error;+  }+  if (tv_dict_add_nr(dict, S_LEN(""id""), hlgid) == FAIL) {+    goto error;+  }++  if (sgp->sg_link && resolve_link) {+    // resolve the highlight group link recursively+    while (sgp->sg_link) {+      hlgid = sgp->sg_link;+      sgp = &hl_table[sgp->sg_link - 1];+    }+  }++  if (sgp->sg_cterm != 0) {+    attr_dict = highlight_get_attr_dict(sgp->sg_cterm);+    if (attr_dict != NULL) {+      if (tv_dict_add_dict(dict, S_LEN(""cterm""), attr_dict) == FAIL) {+        goto error;+      }+    }+  }+  if (sgp->sg_cterm_fg != 0) {+    if (tv_dict_add_str(dict, S_LEN(""ctermfg""),+                        highlight_color(hlgid, (const char *)""fg"", 'c')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_cterm_bg != 0) {+    if (tv_dict_add_str(dict, S_LEN(""ctermbg""),+                        highlight_color(hlgid, (const char *)""bg"", 'c')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_gui != 0) {+    attr_dict = highlight_get_attr_dict(sgp->sg_gui);+    if (attr_dict != NULL) {+      if (tv_dict_add_dict(dict, S_LEN(""gui""), attr_dict) == FAIL) {+        goto error;+      }+    }+  }+  if (sgp->sg_rgb_fg_idx != kColorIdxNone) {+    if (tv_dict_add_str(dict, S_LEN(""guifg""),+                        highlight_color(hlgid, (const char *)""fg"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_rgb_bg_idx != kColorIdxNone) {+    if (tv_dict_add_str(dict, S_LEN(""guibg""),+                        highlight_color(hlgid, (const char *)""bg"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_rgb_sp_idx != kColorIdxNone) {+    if (tv_dict_add_str(dict, S_LEN(""guisp""),+                        highlight_color(hlgid, (const char *)""sp"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_link) {+    char_u *link;++    link = hl_table[sgp->sg_link - 1].sg_name;+    if (link != NULL && tv_dict_add_str(dict, S_LEN(""linksto""), (char *)link) == FAIL) {+      goto error;+    }+  }+  if (dict->dv_hashtab.ht_used == 2) {+    // If only 'name' is present, then the highlight group is cleared.+    tv_dict_add_bool(dict, S_LEN(""cleared""), kBoolVarTrue);+  }++  return dict;++error:+  xfree(dict);+  return NULL;+}++// ""hlget([name])"" function+// Return the attributes of a specific highlight group (if specified) or all+// the highlight groups.++void f_hlget(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)+{+  list_T *list;+  dict_T *dict;+  int i;+  const char *hlarg = NULL;+  bool resolve_link = false;++  tv_list_alloc_ret(rettv, kListLenMayKnow);++  if (argvars[0].v_type != VAR_UNKNOWN) {+    if (argvars[0].v_type != VAR_STRING) {+      emsg(""E1174: String required for argument 0"");+      return;+    } else if (argvars[1].v_type != VAR_UNKNOWN+               && (argvars[1].v_type != VAR_BOOL+                   && !(argvars[1].v_type == VAR_NUMBER+                        && (argvars[1].vval.v_number == 0+                            || argvars[1].vval.v_number == 1)))) {+      emsg(""E1212: Bool required for argument 1"");+      return;+    }+  }++  if (argvars[0].v_type != VAR_UNKNOWN) {+    // highlight group name supplied+    hlarg = tv_get_string_chk(&argvars[0]);+    if (hlarg == NULL) {+      return;+    }++    if (argvars[1].v_type != VAR_UNKNOWN) {+      if (argvars[1].v_type == VAR_BOOL) {+        resolve_link = argvars[1].vval.v_bool == kBoolVarTrue ? true : false;+      } else if (argvars[1].v_type == VAR_NUMBER) {+        resolve_link = argvars[1].vval.v_number == 1 ? true : false;",This is obviously wrong as it treats a number larger than 1 as `false`. Not sure what to do here. Maybe just `#define tv_get_bool_chk tv_get_number_chk`?,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16270,1002281098,2022-10-22T00:32:33Z,src/nvim/highlight_group.c,"@@ -2901,6 +2901,387 @@ RgbValue name_to_color(const char *name, int *idx)   return -1; } +// Convert each of the highlight attribute bits (bold, standout, underline,+// etc.) set in 'hlattr' into a separate boolean item in a Dictionary with+// the attribute name as the key.++static dict_T *highlight_get_attr_dict(int hlattr)+{+  dict_T *dict;+  int i;++  dict = tv_dict_alloc();++  for (i = 0; hl_attr_table[i] != 0; i++) {+    if (hlattr & hl_attr_table[i]) {+      tv_dict_add_bool(dict, hl_name_table[i], strlen(hl_name_table[i]), kBoolVarTrue);+      hlattr &= ~hl_attr_table[i];        // don't want ""inverse""+    }+  }++  return dict;+}++// Return the attributes of the highlight group at index 'hl_idx' as a+// Dictionary. If 'resolve_link' is true, then resolves the highlight group+// links recursively.++static dict_T *highlight_get_info(int hl_idx, bool resolve_link)+{+  dict_T *dict;+  HlGroup *sgp;+  dict_T *attr_dict;+  int hlgid;++  dict = tv_dict_alloc();++  sgp = &hl_table[hl_idx];+  // highlight group id is 1-based+  hlgid = hl_idx + 1;++  if (tv_dict_add_str(dict, S_LEN(""name""), (const char *)sgp->sg_name) == FAIL) {+    goto error;+  }+  if (tv_dict_add_nr(dict, S_LEN(""id""), hlgid) == FAIL) {+    goto error;+  }++  if (sgp->sg_link && resolve_link) {+    // resolve the highlight group link recursively+    while (sgp->sg_link) {+      hlgid = sgp->sg_link;+      sgp = &hl_table[sgp->sg_link - 1];+    }+  }++  if (sgp->sg_cterm != 0) {+    attr_dict = highlight_get_attr_dict(sgp->sg_cterm);+    if (attr_dict != NULL) {+      if (tv_dict_add_dict(dict, S_LEN(""cterm""), attr_dict) == FAIL) {+        goto error;+      }+    }+  }+  if (sgp->sg_cterm_fg != 0) {+    if (tv_dict_add_str(dict, S_LEN(""ctermfg""),+                        highlight_color(hlgid, (const char *)""fg"", 'c')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_cterm_bg != 0) {+    if (tv_dict_add_str(dict, S_LEN(""ctermbg""),+                        highlight_color(hlgid, (const char *)""bg"", 'c')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_gui != 0) {+    attr_dict = highlight_get_attr_dict(sgp->sg_gui);+    if (attr_dict != NULL) {+      if (tv_dict_add_dict(dict, S_LEN(""gui""), attr_dict) == FAIL) {+        goto error;+      }+    }+  }+  if (sgp->sg_rgb_fg_idx != kColorIdxNone) {+    if (tv_dict_add_str(dict, S_LEN(""guifg""),+                        highlight_color(hlgid, (const char *)""fg"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_rgb_bg_idx != kColorIdxNone) {+    if (tv_dict_add_str(dict, S_LEN(""guibg""),+                        highlight_color(hlgid, (const char *)""bg"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_rgb_sp_idx != kColorIdxNone) {+    if (tv_dict_add_str(dict, S_LEN(""guisp""),+                        highlight_color(hlgid, (const char *)""sp"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_link) {+    char_u *link;++    link = hl_table[sgp->sg_link - 1].sg_name;+    if (link != NULL && tv_dict_add_str(dict, S_LEN(""linksto""), (char *)link) == FAIL) {+      goto error;+    }+  }+  if (dict->dv_hashtab.ht_used == 2) {+    // If only 'name' is present, then the highlight group is cleared.+    tv_dict_add_bool(dict, S_LEN(""cleared""), kBoolVarTrue);+  }++  return dict;++error:+  xfree(dict);+  return NULL;+}++// ""hlget([name])"" function+// Return the attributes of a specific highlight group (if specified) or all+// the highlight groups.++void f_hlget(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)+{+  list_T *list;+  dict_T *dict;+  int i;+  const char *hlarg = NULL;+  bool resolve_link = false;++  tv_list_alloc_ret(rettv, kListLenMayKnow);++  if (argvars[0].v_type != VAR_UNKNOWN) {+    if (argvars[0].v_type != VAR_STRING) {+      emsg(""E1174: String required for argument 0"");+      return;+    } else if (argvars[1].v_type != VAR_UNKNOWN+               && (argvars[1].v_type != VAR_BOOL+                   && !(argvars[1].v_type == VAR_NUMBER+                        && (argvars[1].vval.v_number == 0+                            || argvars[1].vval.v_number == 1)))) {+      emsg(""E1212: Bool required for argument 1"");+      return;+    }+  }++  if (argvars[0].v_type != VAR_UNKNOWN) {+    // highlight group name supplied+    hlarg = tv_get_string_chk(&argvars[0]);+    if (hlarg == NULL) {+      return;+    }++    if (argvars[1].v_type != VAR_UNKNOWN) {+      if (argvars[1].v_type == VAR_BOOL) {+        resolve_link = argvars[1].vval.v_bool == kBoolVarTrue ? true : false;+      } else if (argvars[1].v_type == VAR_NUMBER) {+        resolve_link = argvars[1].vval.v_number == 1 ? true : false;+      } else {+        return;+      }+    }+  }++  list = rettv->vval.v_list;+  for (i = 0; i < highlight_ga.ga_len && !got_int; i++) {+    if (hlarg == NULL || STRICMP(hlarg, hl_table[i].sg_name) == 0) {+      dict = highlight_get_info(i, resolve_link);+      if (dict != NULL) {+        tv_list_append_dict(list, dict);+      }+    }+  }+}++// Returns the string value at 'dict[key]'. Returns NULL, if 'key' is not in+// 'dict' or the value is not a string type. If the value is not a string type+// or is NULL, then 'error' is set to true.++static char_u *hldict_get_string(dict_T *dict, char_u *key, int *error)+{+  dictitem_T *di;++  *error = false;+  di = tv_dict_find(dict, (const char *)key, -1);+  if (di == NULL) {+    return NULL;+  }++  if (di->di_tv.v_type != VAR_STRING || di->di_tv.vval.v_string == NULL) {+    emsg(_(e_stringreq));+    *error = true;+    return NULL;+  }++  return (char_u *)di->di_tv.vval.v_string;+}++// Convert the highlight attribute Dictionary at 'dict[key]' into a string+// value in 'attr_str' of length 'len'. Returns false if 'dict[key]' is not a+// Dictionary or is NULL.++static int hldict_attr_to_str(dict_T *dict, char_u *key, char_u *attr_str, int len)+{+  dictitem_T *di;+  dict_T *attrdict;+  int i;++  attr_str[0] = NUL;+  di = tv_dict_find(dict, (const char *)key, -1);+  if (di == NULL) {+    return true;+  }++  if (di->di_tv.v_type != VAR_DICT || di->di_tv.vval.v_dict == NULL) {+    emsg(_(e_dictreq));+    return false;+  }++  attrdict = di->di_tv.vval.v_dict;++  // If the attribute dict is empty, then return NONE to clear the attributes+  if (attrdict->dv_hashtab.ht_used == 0) {+    STRCAT(attr_str, (char_u *)""NONE"");+    return true;+  }++  for (i = 0; i < (int)(sizeof(hl_name_table)/sizeof(hl_name_table[0])); i++) {+    if (tv_dict_get_number(attrdict, (const char *)hl_name_table[i]) == 1) {",This also treats numbers larger than 1 as `false`.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20785,1002695090,2022-10-23T11:34:38Z,src/nvim/diff.c,"@@ -2627,26 +2620,67 @@ void ex_diffgetput(exarg_T *eap)     }   } +  diffgetput(eap->addr_count, idx_cur, idx_from, idx_to, eap->line1, eap->line2);++  // restore curwin/curbuf and a few other things+  if (eap->cmdidx != CMD_diffget) {+    // Syncing undo only works for the current buffer, but we change+    // another buffer.  Sync undo if the command was typed.  This isn't+    // 100% right when "":diffput"" is used in a function or mapping.+    if (KeyTyped) {+      u_sync(false);+    }+    aucmd_restbuf(&aco);+  }++theend:+  diff_busy = false;++  if (diff_need_update) {+    ex_diffupdate(NULL);+  }++  // Check that the cursor is on a valid character and update its+  // position.  When there were filler lines the topline has become+  // invalid.+  check_cursor();+  changed_line_abv_curs();++  if (diff_need_update) {+    // redraw already done by ex_diffupdate()+    diff_need_update = false;+  } else {+    // Also need to redraw the other buffers.+    diff_redraw(false);+    apply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, false, curbuf);+  }+}++// Apply diffget/diffput to buffers and difflbocks","```suggestion/// Apply diffget/diffput to buffers and diffblocks////// @param idx_cur   index in the list of diff buffers of ""curbuf"" before aucmd_prepbuf()/// @param idx_from  index in the list of diff buffers of the buffer to read from/// @param idx_to    index in the list of diff buffers of the buffer to modify```",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1003157194,2022-10-24T10:39:36Z,src/nvim/drawscreen.c,"@@ -1799,6 +1799,12 @@ static void win_update(win_T *wp, DecorProviders *providers)       did_update = DID_NONE;     } +    if (wp->w_redr_numcol) {+      wp->w_redr_numcol = false;+      changed_line_abv_curs_win(wp);+      goto win_update_start;+    }","Yes, this is done in the current PR:https://github.com/luukvbaal/neovim/blob/080dc0def7c47556ab4338607dffc21950347250/src/nvim/statusline.c#L552-L556",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20751,1003261214,2022-10-24T12:35:54Z,runtime/lua/vim/shared.lua,"@@ -544,7 +542,8 @@ end ---@return string %-escaped pattern string function vim.pesc(s)   vim.validate({ s = { s, 's' } })-  return s:gsub('[%(%)%.%%%+%-%*%?%[%]%^%$]', '%%%1')+  local result = s:gsub('[%(%)%.%%%+%-%*%?%[%]%^%$]', '%%%1')+  return result",Also needs a test https://github.com/neovim/neovim/blob/373fef462bc3d23f8b38b6fb3ab942bbf1b283c0/test/functional/lua/vim_spec.lua#L430,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19189,1004687366,2022-10-25T16:09:03Z,test/CMakeLists.txt,"@@ -0,0 +1,148 @@+add_subdirectory(includes)+add_subdirectory(functional/fixtures)++if(POLICY CMP0012)+  # Handle CI=true, without dev warnings.+  cmake_policy(SET CMP0012 NEW)+endif()++find_program(NVIM_PRG nvim)+if(NOT NVIM_PRG)+  set(NVIM_PRG $<TARGET_FILE:nvim>)+endif()++set(test_env)+list(+  APPEND test_env+  ""LC_ALL=en_US.UTF-8""+)++add_test(+  NAME lintcommit+  COMMAND ${NVIM_PRG} -u NONE --headless -es -c [==[lua require('scripts.lintcommit').main({trace=false})]==]+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++get_target_property(NVIM_SOURCES nvim_sources INTERFACE_SOURCES)+get_target_property(NVIM_HEADERS nvim_headers INTERFACE_SOURCES)","OOF, this one hurts bad. These variables were relatively self-contained before, now we're defining these in one subdirectory and using it in another, which kinda breaks the purpose of subdirectories IMO. We might need to rethink this.Do we really need to move these to `test/`? I mean it makes sense that tests are located in `test/`, but maybe we should just replace the lint targets with tests on their current location?",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19189,1004695387,2022-10-25T16:16:43Z,test/CMakeLists.txt,"@@ -0,0 +1,148 @@+add_subdirectory(includes)+add_subdirectory(functional/fixtures)++if(POLICY CMP0012)+  # Handle CI=true, without dev warnings.+  cmake_policy(SET CMP0012 NEW)+endif()++find_program(NVIM_PRG nvim)+if(NOT NVIM_PRG)+  set(NVIM_PRG $<TARGET_FILE:nvim>)+endif()++set(test_env)+list(+  APPEND test_env+  ""LC_ALL=en_US.UTF-8""+)++add_test(+  NAME lintcommit+  COMMAND ${NVIM_PRG} -u NONE --headless -es -c [==[lua require('scripts.lintcommit').main({trace=false})]==]+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++get_target_property(NVIM_SOURCES nvim_sources INTERFACE_SOURCES)+get_target_property(NVIM_HEADERS nvim_headers INTERFACE_SOURCES)","we can create a function that will add a bunch of tests for a list of source files, what do you think?",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19189,1004698915,2022-10-25T16:20:17Z,test/CMakeLists.txt,"@@ -0,0 +1,148 @@+add_subdirectory(includes)+add_subdirectory(functional/fixtures)++if(POLICY CMP0012)+  # Handle CI=true, without dev warnings.+  cmake_policy(SET CMP0012 NEW)+endif()++find_program(NVIM_PRG nvim)+if(NOT NVIM_PRG)+  set(NVIM_PRG $<TARGET_FILE:nvim>)+endif()++set(test_env)+list(+  APPEND test_env+  ""LC_ALL=en_US.UTF-8""+)++add_test(+  NAME lintcommit+  COMMAND ${NVIM_PRG} --headless --clean -es -c [==[lua require('scripts.lintcommit').main({trace=false})]==]+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++get_target_property(NVIM_SOURCES nvim_sources INTERFACE_SOURCES)+get_target_property(NVIM_HEADERS nvim_headers INTERFACE_SOURCES)++list(APPEND LINT_NVIM_C_FILES ${NVIM_SOURCES} ${NVIM_HEADERS})++find_program(GIT_EXECUTABLE git)++find_program(LUACHECK_PRG luacheck)+find_program(STYLUA_PRG stylua)+find_program(FLAKE8_PRG flake8)+find_program(UNCRUSTIFY_PRG uncrustify)+find_program(SHELLCHECK_PRG shellcheck)+set(CLINT_PRG ${PROJECT_SOURCE_DIR}/src/clint.py)+set(CLINT_SUPPRESSIONS_DIR ${PROJECT_BINARY_DIR}/errors)++# used for detecting changed files+if(DEFINED ENV{NVIM_GIT_BASEREF})+  set(NVIM_GIT_BASEREF ""$ENV{NVIM_GIT_BASEREF}"")+else()+  set(NVIM_GIT_BASEREF ""HEAD^1"")+endif()++# this one is used to populate lint-changed-only+# could also be used as part of a REQUIRED_FIXTURES+add_test(+  NAME check_changed_files+  COMMAND ${CMAKE_COMMAND} -E echo ""${changed_files}""+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++set_tests_properties(+  check_changed_files PROPERTIES+  LABELS lint-changed-only+)++include(FetchErrorSuppressions)+FetchErrorSuppressions(+  TARGET clint-reports+  DOWNLOAD_DIR ${CLINT_SUPPRESSIONS_DIR}+)++add_dependencies(nvim clint-reports)++if(CI_BUILD)+  set(CLINT_OUTPUT_FORMAT gh_action)+else()+  set(CLINT_OUTPUT_FORMAT vs7)+endif()++# add a seprate test for each file for easier invocation+# e.g. `ctest --test-dir build -R lintuncrustify-src-nvim-window-h`+foreach(f ${LINT_NVIM_C_FILES})+  file(RELATIVE_PATH rfile ${PROJECT_SOURCE_DIR} ${f})+  file(RELATIVE_PATH testname ""${PROJECT_SOURCE_DIR}/src/nvim"" ${f})+  string(REGEX REPLACE ""[/.]"" ""-"" testname ${testname})+  set(unc_testname lintuncrustify-${testname})+  set(clint_testname lintc-${testname})+  # FIXME(kylo252): this should probably be replaced with a FIXTURES_SETUP+  if(UNCRUSTIFY_PRG)+    add_test(+      NAME ${unc_testname}+      COMMAND ${UNCRUSTIFY_PRG} -c ${PROJECT_SOURCE_DIR}/src/uncrustify.cfg -q --check ${rfile}+      WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+    )+    set_tests_properties(+      ${unc_testname} PROPERTIES+      LABELS ""lint-all;lintcfull""+      REQUIRED_FILES ${f}+    )+  endif()+  add_test(+    NAME ${clint_testname}+    COMMAND ${CLINT_PRG} --suppress-errors ${CLINT_SUPPRESSIONS_DIR}/${testname}.json --output ${CLINT_OUTPUT_FORMAT} ${rfile}+    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+  )+  set_tests_properties(+    ${clint_testname} PROPERTIES+    LABELS ""lint-all;lintcfull""+    REQUIRED_FILES ${f}+  )+endforeach()++add_test(+  NAME lintlua-luacheck+  COMMAND ${LUACHECK_PRG} -q --no-color runtime/ scripts/ src/ test/+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++add_test(+  NAME lintlua-stylua+  COMMAND ${STYLUA_PRG}  --color=always --check runtime/+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++add_test(+  NAME lintpy+  COMMAND ${FLAKE8_PRG} contrib scripts src test+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++add_test(+  NAME lintsh+  COMMAND ${SHELLCHECK_PRG} scripts/vim-patch.sh+  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}+)++set_tests_properties(+  lintcommit lintlua-stylua lintlua-luacheck lintpy lintsh PROPERTIES+  LABELS lint-all+)++add_custom_target(lintc-changed-only)+add_custom_command(TARGET lintc-changed-only+  COMMAND bash -c [==[git diff --name-only --relative=src/nvim HEAD | sed 's@[/.]@-@g' | xargs -n1 ctest --test-dir build -L 'lintc' -R]==]","actually, we should rework/(maybe split?) `cmake/Format.cmake`  so that `get_changed_files` can be used herehttps://github.com/neovim/neovim/blob/6da2271a04540f6f3bd6d3cae1895bb1ea1b5011/cmake/Format.cmake#L3-L4",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/20184,1006826122,2022-10-27T12:46:26Z,src/nvim/api/win_config.c,"@@ -273,6 +281,17 @@ Dictionary nvim_win_get_config(Window window, Error *err)         }       }       PUT(rv, ""border"", ARRAY_OBJ(border));+      if (config->title) {+        Array titles = ARRAY_DICT_INIT;+        VirtText title_datas = config->title_chunks;+        for (size_t i = 0; i < title_datas.size; i++) {+          Array tuple = ARRAY_DICT_INIT;+          ADD(tuple, CSTR_TO_OBJ((const char *)title_datas.items[i].text));+          ADD(titles, ARRAY_OBJ(tuple));","also need highlight, similar to existing code in `extmark_to_array` : ```        if (vtc->hl_id > 0) {          ADD(chunk,              STRING_OBJ(cstr_to_string((const char *)syn_id2name(vtc->hl_id))));        }```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20539,1006995035,2022-10-27T14:59:31Z,.github/actions/install_deps/action.yml,"@@ -0,0 +1,62 @@+name: 'Install dependencies'","maybe a reusable workflow is a good middle-ground here?it's generally useful when a workflow is doing a few different things, in this case: always cache artifacts after pulling updates and installing deps. see https://docs.github.com/en/actions/using-workflows/reusing-workflows",
48864055,Viblanc,https://api.github.com/repos/neovim/neovim/pulls/20835,1008101170,2022-10-28T14:01:50Z,src/nvim/os/fs.c,"@@ -946,6 +946,31 @@ int os_mkdir_recurse(const char *const dir, int32_t mode, char **const failed_di   return 0; } +/// Create the parent directory of a file if it does not exist+///+/// @param[in] fname Full path of the file name whose parent directories+///                  we want to create+///+/// @return `0` for success, libuv error code for failure.+int os_mkdir_if_absent(char *fname)","Alright, I was also wondering if it would be best to also pass the file mode as a parameter ? It's hard coded here and set to `0755`, perhaps it'd be better to actually have it as a parameter ?",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20821,1008146570,2022-10-28T14:44:09Z,.clang-tidy,"@@ -32,6 +28,7 @@ Checks: >   -misc-unused-parameters,   -modernize-macro-to-enum,   -performance-no-int-to-ptr,+  -readability-avoid-const-params-in-decls,",here's the answer```bash# see currently implemented checks$ clang-tidy --list-checks | grep '^readability'    readability-const-return-type    readability-container-contains # C++ only    readability-container-data-pointer # C++ only    readability-container-size-empty # C++ only    readability-convert-member-functions-to-static # C++ only    readability-delete-null-pointer # C++ only    readability-duplicate-include    readability-identifier-naming    readability-implicit-bool-conversion    readability-inconsistent-declaration-parameter-name    readability-make-member-function-const # C++ only    readability-misplaced-array-index    readability-named-parameter # C++ only    readability-non-const-parameter    readability-qualified-auto # C++ only    readability-redundant-access-specifiers    readability-redundant-control-flow    readability-redundant-member-init # C++ only    readability-redundant-preprocessor    readability-redundant-smartptr-get # C++ only    readability-redundant-string-cstr # C++ only    readability-redundant-string-init # C++ only    readability-simplify-boolean-expr    readability-simplify-subscript-expr    readability-static-accessed-through-instance # C++ only    readability-static-definition-in-anonymous-namespace # C++ only    readability-string-compare # C++ only    readability-uniqueptr-delete-release # C++ only    readability-uppercase-literal-suffix    readability-use-anyofallof # C++ only```,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20846,1008172261,2022-10-28T15:09:35Z,.github/workflows/ci.yml,"@@ -274,14 +274,6 @@ jobs:             exit 1           } -      - name: Install new clang",should update the matrix labels as well ���� _(since clang-14 is already available)_https://github.com/neovim/neovim/blob/887e935c5e344511d1aec85f116bed558654a219/.github/workflows/ci.yml#L215-L220,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20821,1008187063,2022-10-28T15:24:16Z,.clang-tidy,"@@ -32,6 +28,7 @@ Checks: >   -misc-unused-parameters,   -modernize-macro-to-enum,","> Most of them, yes, but not all.did you actually check? lol```console��� clang-tidy --list-checksEnabled checks:    modernize-avoid-bind    modernize-avoid-c-arrays    modernize-concat-nested-namespaces    modernize-deprecated-headers    modernize-deprecated-ios-base-aliases    modernize-loop-convert    modernize-make-shared    modernize-make-unique    modernize-pass-by-value    modernize-raw-string-literal    modernize-redundant-void-arg    modernize-replace-auto-ptr    modernize-replace-disallow-copy-and-assign-macro    modernize-replace-random-shuffle    modernize-return-braced-init-list    modernize-shrink-to-fit    modernize-unary-static-assert    modernize-use-auto    modernize-use-bool-literals    modernize-use-default-member-init    modernize-use-emplace    modernize-use-equals-default    modernize-use-equals-delete    modernize-use-nodiscard    modernize-use-noexcept    modernize-use-nullptr    modernize-use-override    modernize-use-trailing-return-type    modernize-use-transparent-functors    modernize-use-uncaught-exceptions    modernize-use-using```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20846,1008197861,2022-10-28T15:35:31Z,.github/workflows/ci.yml,"@@ -274,14 +274,6 @@ jobs:             exit 1           } -      - name: Install new clang","Just write `name: Install clang 13`, I guess, since clang-13 is no longer ""new"". (Pointless bikeshedding, if you ask me.)",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20821,1008198324,2022-10-28T15:35:52Z,.clang-tidy,"@@ -32,6 +28,7 @@ Checks: >   -misc-unused-parameters,   -modernize-macro-to-enum,","hell, I just realized that you've turned that one off anyway :')https://github.com/neovim/neovim/blob/d9dce2d955b0359d1555bfa86aa641f26ad6e8bc/.clang-tidy#L33",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20846,1008233548,2022-10-28T16:11:10Z,.github/workflows/ci.yml,"@@ -274,14 +274,6 @@ jobs:             exit 1           } -      - name: Install new clang","> But we explicitly set it to clang version 13?currently, yes that's the case: https://github.com/neovim/neovim/blob/d9dce2d955b0359d1555bfa86aa641f26ad6e8bc/.github/workflows/ci.yml#L245so I'm suggesting skipping this (arbitrary) restriction, which I assume only existed since `13` was the newest version that the installer supported, see https://github.com/neovim/neovim/commit/6a932f68e6853e4fdcb49621fb1d89829a23238b",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19189,1008669541,2022-10-29T09:32:17Z,Makefile,"@@ -130,9 +131,24 @@ src/nvim/testdir/%.vim: phony_force functionaltest functionaltest-lua unittest benchmark: | nvim 	$(BUILD_TOOL) -C build $@ -lintlua lintsh lintpy lintuncrustify lintc lintcfull check-single-includes generated-sources lintcommit lint formatc formatlua format: | build/.ran-cmake+check-single-includes generated-sources formatc formatlua format: | build/.ran-cmake 	$(CMAKE_PRG) --build build --target $@ +build/CTestTestfile.cmake:+	$(CMAKE_PRG) -S . -B build++lintlua lintsh lintpy lintcommit: build/CTestTestfile.cmake+	ctest --test-dir build $(CTEST_EXTRA_FLAG) -R $@++lint: build/CTestTestfile.cmake+	ctest --test-dir build $(CTEST_EXTRA_FLAG) -L 'lint-all'++lintc: build/CTestTestfile.cmake check-single-includes+	ctest --test-dir build $(CTEST_EXTRA_FLAG) -R lintc-changed-only++lintcfull: build/CTestTestfile.cmake+	ctest --test-dir build $(CTEST_EXTRA_FLAG) -L 'lintcfull'",Shouldn't these have `-j` to parallelize them?,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1008674746,2022-10-29T10:14:22Z,runtime/doc/options.txt,"@@ -4364,6 +4364,50 @@ A jump table for the options with a short description can be found at |Q_op|. 	    |nobody         |  3 nobody     |  0 nobody     |3   nobody 	    |there          |  4 there      |  1 there      |  1 there +				*'numbercolumn'* *'nuc'*+'numbercolumn' 'nuc'	string	(default: empty)+			local to window+	EXPERIMENTAL+	When this option is not empty, it determines the content of the number+	column. The format of this option is like that of 'statusline'. The+	variables *v:redraw_lnum* and *v:redraw_relnum* will be set to the to be+	printed line number and relative line number respectively. These can be+	evaluated in an expression inside a 'statusline' %{} block.++	Some of the items from the 'statusline' format are different+	'numbercolumn':++	%l	v:redraw_lnum, can be used inside %{} block",It's not wrong in this PR. I have altered the `%{}` eval block to substitute `v:redraw_lnum` and `v:redraw_relnum` for `%l` and `%r` respectively: https://github.com/luukvbaal/neovim/blob/93a9277b76b76e0a0028ebf5aa5136b6418ce1e7/src/nvim/statusline.c#L1152-L1158 (see https://github.com/neovim/neovim/pull/20621#discussion_r998503306)This allows you to write e.g. `set nuc=%{%r?%r:%l}` instead of `set nuc=%{v:redraw_relnum?v:redraw_relnum:v:redraw_lnum}`. Might not be worth it.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1008675490,2022-10-29T10:20:08Z,src/nvim/drawline.c,"@@ -322,10 +326,8 @@ static void get_sign_display_info(bool nrcol, win_T *wp, linenr_T lnum, SignText           STRCAT(extra, *pp_extra);           STRCAT(extra, "" "");           *pp_extra = extra;-          *n_extrap = (int)STRLEN(*pp_extra);+          *n_extrap = (int)symbol_blen + width + 1;",Not strictly necessary but since I needed the larger scope for `symbol_blen` I thought I would avoid calling `strlen` again here. Might be irrelevant if we intend to refactor.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20621,1008676814,2022-10-29T10:32:04Z,src/nvim/screen.c,"@@ -956,16 +957,7 @@ void draw_tabline(void)    // Use the 'tabline' option if it's set.   if (*p_tal != NUL) {-    int saved_did_emsg = did_emsg;--    // Check for an error.  If there is one we would loop in redrawing the-    // screen.  Avoid that by making 'tabline' empty.-    did_emsg = false;-    win_redr_custom(NULL, false, false);-    if (did_emsg) {-      set_string_option_direct(""tabline"", -1, """", OPT_FREE, SID_ERROR);-    }-    did_emsg |= saved_did_emsg;",Sounds like a refactor that can be reviewed independently? ����,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19189,1008683985,2022-10-29T11:23:59Z,.gitignore,"@@ -75,3 +75,5 @@ tags /vim-*.patch  /CMakeUserPresets.json+# ctest artifacts+Testing","removed by who? it will just be an annoying folder that gets in the way, same as any other cache foldersee: https://github.com/Kitware/CMake/blob/a3252ac53eeb9f0663a9410e3d48340741c348ea/.gitignore#L12",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/19189,1008687917,2022-10-29T11:53:42Z,.gitignore,"@@ -75,3 +75,5 @@ tags /vim-*.patch  /CMakeUserPresets.json+# ctest artifacts+Testing","But it's not a cache folder, you said it shows up if you use the wrong command like `ctest --show-only`. If I accidentally write `mkdir random_dir` then the correct solution isn't to add `random_dir` to `.gitignore`, it's to not write wrong commands. I don't see your point here.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/19189,1008693683,2022-10-29T12:33:00Z,.gitignore,"@@ -75,3 +75,5 @@ tags /vim-*.patch  /CMakeUserPresets.json+# ctest artifacts+Testing","> But it's not a cache folder, you said it shows up if you use the wrong command like `ctest --show-only`.it's still a cache folder, just in the wrong directory. when used correctly it shows up in test-dir, in our case it's under `build/`> If I accidentally write `mkdir random_dir` then the correct solution isn't to add `random_dir` to `.gitignore`, it's to not write wrong commands.Your example doesn't apply here.- we're adding a new tool that is known to generate a folder that should not be tracked- this folder has a very _specific_ name, it's always _Testing_- this makes it a perfect candidate to be added to `.gitignore`- it will help users realize that this folder is safe to ignore/delete as well- It's not worth it to try to figure out why and how `ctest` has this bug/feature/behavior- no file/folder called _Testing_ is currently tracked, and I doubt there will ever be oneso all in all this ranks an easy 9/10 on my scale for QoL/effort",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/20860,1008703239,2022-10-29T13:45:59Z,runtime/doc/scroll.txt,"@@ -251,4 +251,12 @@ scrolled. This allows you to scroll inactive windows. Note that when scroll keys are remapped to keyboard keys, the active window is affected regardless of the current cursor position. +							*mouse-scrolling-off*+If you do not want the mouse to cause scrolling (e.g. because resting your+palm on the touchpad causes scroll events), you can disable that with: >+	:map <ScrollWheelDown> <Nop>+	:map! <ScrollWheelDown> <Nop>+	:map <ScrollWheelUp> <Nop>+	:map! <ScrollWheelUp> <Nop>","Nvim technically suggests `:set mousescroll=hor:0,ver:0` in `:h 'mousescroll'` to disable mouse scrolling, but it seems to still move the cursor. This mapping imo works a bit better as it doesn't do that. :shrug: ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20835,1008742493,2022-10-29T18:41:33Z,src/nvim/eval.c,"@@ -7058,6 +7061,11 @@ char *set_cmdarg(exarg_T *eap, char *oldarg)     snprintf(newval + strlen(newval), newval_len, "" ++bad=%c"",              eap->bad_char);   }++  if (eap->mkdir_p) {+    STRCAT(newval, "" ++p"");",if STRCAT is used where it isn't needed that's just code that hasn't been cleaned up. We don't want to repeat that pattern in new code :),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20835,1008742631,2022-10-29T18:42:58Z,src/nvim/os/fs.c,"@@ -946,6 +946,31 @@ int os_mkdir_recurse(const char *const dir, int32_t mode, char **const failed_di   return 0; } +/// Create the parent directory of a file if it does not exist+///+/// @param[in] fname Full path of the file name whose parent directories+///                  we want to create+///+/// @return `0` for success, libuv error code for failure.+int os_mkdir_if_absent(char *fname)","> also pass the file mode as a parameter ?sure, a parameter to os_file_mkdir() is a good idea. But not as a parameter to `:write`  (maybe a followup PR/feature-request, idk).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20880,1008938006,2022-10-30T22:35:50Z,src/clint.py,"@@ -2305,213 +2304,36 @@ def CheckBraces(filename, clean_lines, linenum, error):         prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]         if (not Search(r'[,;:}{(]\s*$', prevline) and                 not Match(r'\s*#', prevline)):-            error(filename, linenum, 'whitespace/braces', 4,-                  '{ should almost always be at the end'-                  ' of the previous line')+            return      # Brace must appear after function signature, but on the *next* line     if Match(r'^(?:\w+(?: ?\*+)? )+\w+\(', line):         pos = line.find('(')-        (endline, end_linenum, endpos) = CloseExpression(-            clean_lines, linenum, pos)+        (endline, end_linenum, _) = CloseExpression(clean_lines, linenum, pos)         if endline.endswith('{'):-            error(filename, end_linenum, 'readability/braces', 5,-                  'Brace starting function body must be placed on its own line')-        else:-            func_start_linenum = end_linenum + 1-            while not clean_lines.lines[func_start_linenum] == ""{"":-                attrline = Match(-                    r'^((?!# *define).*?)'-                    r'(?:FUNC_ATTR|FUNC_API|REAL_FATTR)_\w+'-                    r'(?:\(\d+(, \d+)*\))?',-                    clean_lines.lines[func_start_linenum],-                )-                if attrline:-                    if len(attrline.group(1)) != 2:-                        error(filename, func_start_linenum,-                              'whitespace/indent', 5,-                              'Function attribute line should have 2-space '-                              'indent')--                    func_start_linenum += 1-                else:-                    func_start = clean_lines.lines[func_start_linenum]-                    if not func_start.startswith('enum ') and func_start.endswith('{'):-                        error(filename, func_start_linenum,-                              'readability/braces', 5,-                              'Brace starting function body must be placed '-                              'after the function signature')-                    break--    # An else clause should be on the same line as the preceding closing brace.-    # If there is no preceding closing brace, there should be one.-    if Match(r'\s*else\s*', line):-        prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0]-        if Match(r'\s*}\s*$', prevline):-            error(filename, linenum, 'whitespace/newline', 4,-                  'An else should appear on the same line as the preceding }')-        else:-            error(filename, linenum, 'readability/braces', 5,-                  'An else should always have braces before it')--    # If should always have a brace-    for blockstart in ('if', 'while', 'for'):-        if Match(r'\s*{0}(?!\w)[^{{]*$'.format(blockstart), line):-            pos = line.find(blockstart)-            pos = line.find('(', pos)-            if pos > 0:-                (endline, _, endpos) = CloseExpression(-                    clean_lines, linenum, pos)-                if endline[endpos:].find('{') == -1:-                    error(filename, linenum, 'readability/braces', 5,-                          '{} should always use braces'.format(blockstart))--    # If braces come on one side of an else, they should be on both.-    # However, we have to worry about ""else if"" that spans multiple lines!-    if Search(r'}\s*else[^{]*$', line) or Match(r'[^}]*else\s*{', line):-        if Search(r'}\s*else if([^{]*)$', line):       # could be multi-line if-            # find the ( after the if-            pos = line.find('else if')-            pos = line.find('(', pos)-            if pos > 0:-                (endline, _, endpos) = CloseExpression(-                    clean_lines, linenum, pos)-                # must be brace after if-                if endline[endpos:].find('{') == -1:-                    error(filename, linenum, 'readability/braces', 5,-                          'If an else has a brace on one side,'-                          ' it should have it on both')","Is uncrustify catching this ? similar question for most of these. If most are caught then yes, let's remove the clint rule.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/20889,1009420628,2022-10-31T13:29:52Z,src/nvim/normal.c,"@@ -5697,6 +5697,10 @@ static void nv_gomark(cmdarg_T *cap) {   int name;   MarkMove flags = jop_flags & JOP_VIEW ? kMarkSetView : 0;  // flags for moving to the mark+  if (cap->oap->op_type != OP_NOP) {+    // When there is a pending operator, do not restore the view as this is usually unexpected.+    flags = 0;","I think moving this logic to `nv_mark_move_to` would be better, overwriting the passes flags. https://github.com/neovim/neovim/blob/3e17f5eab365e79929bfa65ce48cb533026a504f/src/nvim/normal.c#L5611It would then also apply to `nv_pcmark`, `nv_brackets`.",X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20884,1009571359,2022-10-31T15:42:53Z,.github/workflows/stale.yml,"@@ -0,0 +1,18 @@+name: 'Close stale issues and PRs'+on:+  schedule:+    - cron: '30 1 * * *'++jobs:+  stale:+    runs-on: ubuntu-latest+    permissions:+      issues: write+      pull-requests: write+    steps:+      - uses: actions/stale@v6+        with:+          days-before-close: 60","I think we should have an explicit discussion about a reasonable time before closing, which should be based on _why_ exactly we want this bot to close stale issues/PRs.(Not saying that 60 days is bad; just that it should be a reasoned choice rather than a ""eh, sounds alright to me"" default.)",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/20884,1009606203,2022-10-31T16:14:43Z,.github/workflows/stale.yml,"@@ -0,0 +1,18 @@+name: 'Close stale issues and PRs'+on:+  schedule:+    - cron: '30 1 * * *'++jobs:+  stale:+    runs-on: ubuntu-latest+    permissions:+      issues: write+      pull-requests: write+    steps:+      - uses: actions/stale@v6+        with:+          days-before-close: 60","> which should be based on why exactly we want this bot to close stale issues/PRs.To automate busywork that we're already doing: removing old issues/PRs that have hit a dead end where we need more information. This is just a programmatic way of doing that.I chose 60 days because it sounded alright to me :). We could bump it up to 6 months to only remove super old stuff. I don't really know how to come up with a ""reasonable"" time honestly. Any ideas?",X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/20884,1009611976,2022-10-31T16:20:12Z,.github/workflows/stale.yml,"@@ -0,0 +1,18 @@+name: 'Close stale issues and PRs'+on:+  schedule:+    - cron: '30 1 * * *'++jobs:+  stale:+    runs-on: ubuntu-latest+    permissions:+      issues: write+      pull-requests: write+    steps:+      - uses: actions/stale@v6+        with:+          days-before-close: 60","If it's _only_ occasional spring cleaning rather than aggressively keeping issue count down, a longer period is indeed more reasonable. (I would have picked 30 days as ""sounds good to me"" default, myself.)Rough guesstimate: anything that hasn't seen any action since the last release is probably dead -- either hasn't been reproduced, or needs so much rebasing that it's better to start from scratch.",
1009873,wookayin,https://api.github.com/repos/neovim/neovim/pulls/20883,1010081078,2022-11-01T05:21:50Z,runtime/lua/vim/ui.lua,"@@ -88,11 +88,15 @@ function M.input(opts, on_confirm)   })    opts = (opts and not vim.tbl_isempty(opts)) and opts or vim.empty_dict()+  opts = vim.tbl_extend('keep', opts, { cancelreturn = vim.NIL })+   local input = vim.fn.input(opts)-  if #input > 0 then+  if input == vim.NIL then+    on_confirm(opts.cancelreturn) -- canceled+  elseif #input >= 0 then","Hmm you are right. I think I no longer need the else statement below. A corner case is that if a user specifies `cancelreturn = nil`, it will throw an error. Let me fix this.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20884,1010495743,2022-11-01T14:31:04Z,.github/workflows/stale.yml,"@@ -0,0 +1,18 @@+name: 'Close stale issues and PRs'+on:+  schedule:+    - cron: '30 1 * * *'++jobs:+  stale:+    runs-on: ubuntu-latest+    permissions:+      issues: write+      pull-requests: write+    steps:+      - uses: actions/stale@v6+        with:+          days-before-close: 60","30 days or less is good. More than that means we spent time responding to an issue that the reporter has lost context on, and we also have to reload the context we just spent triaging it.6 months is far too long.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20858,1010528437,2022-11-01T14:56:35Z,scripts/git-log-pretty-since.sh,"@@ -40,13 +40,13 @@ _format_ticketnums() { }  for commit in $(git log --format='%H' --first-parent ""$__SINCE""..HEAD); do-  if is_merge_commit ${commit} ; then-      if [ -z ""$__INVMATCH"" ] || ! git log --oneline ${commit}^1..${commit}^2 \+  if is_merge_commit ""${commit}"" ; then+      if [ -z ""$__INVMATCH"" ] || ! git log --oneline ""${commit}""^1..""${commit}""^2 \","nit (similar cases below): ```suggestion      if [ -z ""$__INVMATCH"" ] || ! git log --oneline ""${commit}^1..${commit}^2"" \```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20890,1010575847,2022-11-01T15:35:50Z,test/functional/ex_cmds/grep_spec.lua,"@@ -18,4 +18,20 @@ describe(':grep', function()     feed('<cr>')  -- Press ENTER     ok(eval('len(getqflist())') > 9000)  -- IT'S OVER 9000!!1   end)++  it('works when both shellpipe and makeef are unset', function()+    if eval(""executable('grep')"") == 0 then+      pending('missing ""grep"" command')+      return+    end++    feed_command([[set grepprg=grep\ -r]])+    feed_command([[set shellpipe=]])+    feed_command([[set makeef=]])+    -- Change to test directory so that the test does not run too long.+    feed_command('cd test')+    feed_command('grep a **/*')+    feed('<cr>')  -- Press ENTER+    ok(eval('len(getqflist())') > 9000)  -- IT'S OVER 9000!!1","this test is not for UI performance so we could use a more restricted `grep` pattern above. So this test will take less time, and we can assert something more explicit.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/20925,1014163630,2022-11-04T15:23:43Z,src/nvim/runtime.c,"@@ -1841,6 +1845,183 @@ static void cmd_source_buffer(const exarg_T *const eap)   ga_clear(&ga); } +/// Read a file, prompting the user if the file should be trusted or not.+///+/// Maintain a ""trust database"" at stdpath('state')/trust containing a sequence+/// of [path, hash] pairs. A path can be marked as blacklisted by using a '!'","```suggestion/// of [hash, path] pairs. A path can be marked as blacklisted by using a '!'```",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/20925,1014269101,2022-11-04T17:01:39Z,src/nvim/lua/stdlib.c,"@@ -541,6 +542,32 @@ static int nlua_iconv(lua_State *lstate)  #endif +int nlua_read_secure(lua_State *L)+{+  if (lua_gettop(L) < 1) {+    return luaL_error(L, ""Expected 1 argument"");+  }++  if (lua_type(L, 1) != LUA_TSTRING) {+    luaL_argerror(L, 1, ""expected string"");+  }++  const char *contents = NULL;+  size_t len = 0;+  const char *path = lua_tolstring(L, 1, &len);+  if (path != NULL) {+    contents = read_secure(path, &len);+  }++  if (contents != NULL) {+    lua_pushlstring(L, contents, len);+    xfree((void *)contents);","When `read_secure` no longer returns `const`, `contents` can just be `char*` and the cast here will no longer be necessary.```suggestion    xfree(contents);```",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/20956,1014756236,2022-11-06T01:51:00Z,runtime/lua/vim/_editor.lua,"@@ -892,6 +892,108 @@ function vim._init_default_mappings()   ]]) end +--- Attempt to read the file at {path} prompting the user if the file should be+--- trusted. The user's choice is persisted in a trust database at+--- $XDG_STATE_HOME/nvim/trust.+---+---@param path (string) Path to a file to read.+---@param opts (table|nil) Options (currently unused).","Since this is just a lua function, is having `opts` necessary if it's unused? Adding it later on if needed won't break anything.",
2947276,leiserfg,https://api.github.com/repos/neovim/neovim/pulls/20971,1014870310,2022-11-06T18:05:35Z,src/nvim/api/keysets.lua,"@@ -50,6 +50,7 @@ return {     ""callback"";     ""desc"";     ""replace_keycodes"";+    ""is_abbrev"";","I just used it to keep compatibility with the internal naming, if that's not a problem, I can commit the suggestion.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20184,1014894345,2022-11-06T21:22:01Z,src/nvim/highlight_group.c,"@@ -131,6 +131,7 @@ static const char *highlight_init_both[] = {   ""default link MsgSeparator StatusLine"",   ""default link NormalFloat Pmenu"",   ""default link FloatBorder WinSeparator"",+  ""default link FloatBorderTitle Title"",","This should be `FloatTitle`. There is no risk of ambiguity. And if we ever support a title in a place other than the border, then it makes no sense to have two different highlights for title. ""Border"" is an irrelevant detail here.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20976,1014906112,2022-11-06T22:44:47Z,runtime/doc/lua.txt,"@@ -2306,10 +2307,13 @@ find({names}, {opts})                                          *vim.fs.find()*         (table) The paths of all matching files or directories  normalize({path})                                         *vim.fs.normalize()*-    Normalize a path to a standard format. A tilde (~) character at the-    beginning of the path is expanded to the user's home directory and any-    backslash (\) characters are converted to forward slashes (/). Environment-    variables are also expanded.+    Normalize a path to a standard format.++    A tilde (~) character at the beginning of the path is expanded to the+    user's home directory and any backslash (\) characters are converted to","Perhaps we should do these kind of ""resolve"" tasks in `vim.fs.realpath`, or `vim.fs.resolve`.For comparison, - python has    - [abspath](https://docs.python.org/3/library/os.path.html#os.path.abspath)    - [normpath](https://docs.python.org/3/library/os.path.html#os.path.normpath)    - [realpath](https://docs.python.org/3/library/os.path.html#os.path.realpath)- nodejs has    - [resolve](https://nodejs.org/api/path.html#pathresolvepaths)    - [normalize](https://nodejs.org/api/path.html#pathnormalizepath)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20976,1014910067,2022-11-06T23:11:22Z,runtime/lua/vim/fs.lua,"@@ -227,7 +231,20 @@ end ---@return (string) Normalized path function M.normalize(path)   vim.validate({ path = { path, 's' } })-  return (path:gsub('^~/', vim.env.HOME .. '/'):gsub('%$([%w_]+)', vim.env):gsub('\\', '/'))+  local p = (path:gsub('^~/', vim.env.HOME .. '/'):gsub('%$([%w_]+)', vim.env):gsub('\\', '/'))++  -- Try to also convert the path to an absolute path with symlinks resolved, but if the path does+  -- not yet exist simply return it as-is.+  return M.realpath(p) or p+end++--- Convert a path to an absolute path, resolving symlinks.+---+---@param path (string) Path to convert to an absolute path+---@return (string|nil) Absolute path, or nil if the file or directory does not+---        exist.+function M.realpath(path)+  return vim.loop.fs_realpath(path)","> quite concerning since many plugins are using vim.loopNothing to be concerned about, but it is similar story as FFI: we exposed a low-level thing that we don't own. > Was it then a mistake to include the luv documentation in our runtime?No, it's useful and used :)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20956,1014933027,2022-11-07T01:16:07Z,runtime/doc/lua.txt,"@@ -2353,4 +2353,20 @@ parents({start})                                            *vim.fs.parents()*     Return: ~         (function) Iterator ++==============================================================================+Lua module: secure                                                *lua-secure*","I see that `vim.readsecure()` https://github.com/neovim/neovim/pull/20925 was closed but don't see a rationale. Why introduce a new module for this? Do we plan to have many more functions in `vim.secure`? The current functionality at least seems to be covered by a parameter on `vim.read({secure=true, path=...})`. Otherwise `vim.readsecure()` works, if the interface is expected to be different than `vim.read()`.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20956,1014950754,2022-11-07T02:16:48Z,runtime/doc/lua.txt,"@@ -2353,4 +2353,20 @@ parents({start})                                            *vim.fs.parents()*     Return: ~         (function) Iterator ++==============================================================================+Lua module: secure                                                *lua-secure*","See @ii14's [comment](https://github.com/neovim/neovim/pull/20956#discussion_r1014756332). The thinking was there may be other useful APIs that could fall under the ""secure"" umbrella (e.g. an interface to add or remove items from the trust database).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20976,1014951509,2022-11-07T02:19:01Z,runtime/doc/lua.txt,"@@ -2306,10 +2307,13 @@ find({names}, {opts})                                          *vim.fs.find()*         (table) The paths of all matching files or directories  normalize({path})                                         *vim.fs.normalize()*-    Normalize a path to a standard format. A tilde (~) character at the-    beginning of the path is expanded to the user's home directory and any-    backslash (\) characters are converted to forward slashes (/). Environment-    variables are also expanded.+    Normalize a path to a standard format.++    A tilde (~) character at the beginning of the path is expanded to the+    user's home directory and any backslash (\) characters are converted to",Maybe we don't need `realpath` at all and just use `normalize` for that purpose. One benefit of `realpath` is that it returns `nil` if the file does not exist which is useful in some situations. We could have `normalize` return a second boolean parameter that covers this use-case.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20956,1014956314,2022-11-07T02:33:35Z,runtime/doc/lua.txt,"@@ -2353,4 +2353,20 @@ parents({start})                                            *vim.fs.parents()*     Return: ~         (function) Iterator ++==============================================================================+Lua module: secure                                                *lua-secure*","""vim.secure"" is a lofty  name for this :) Maybe `vim.localrc` or `vim.exrc`. Not trying to bikeshed, but thinking of `trust()` and looking at https://github.com/ii14/exrc.vim/blob/master/doc/exrc.txt and related plugins, clearly the direction is to support the features of these ""local vimrc"" plugins. `vim.secure` doesn't seem like the theme here.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20956,1015559370,2022-11-07T15:25:22Z,runtime/doc/lua.txt,"@@ -2353,4 +2353,20 @@ parents({start})                                            *vim.fs.parents()*     Return: ~         (function) Iterator ++==============================================================================+Lua module: secure                                                *lua-secure*",">The current functionality at least seems to be covered by a parameter on vim.read({secure=true, path=...}). Otherwise vim.readsecure() works, if the interface is expected to be different than vim.read().I do think that the ""readsecure"" interface might be different enough to warrant being separate from a more generic `read` function. For example, we might want to expose the ability to specify the prompt text, or modify some parameters of how the file is displayed when the user wants to view it (e.g. setting the buffer filetype). None of these would make sense for a generic `read` function.Re: `vim.secure.read()` vs `vim.readsecure()`: I don't have a dog in that fight, but I'd prefer we just pick something and not bikeshed too long. It sounds like @ii14 already has some ideas on other functions that would fit in a ""secure"" module. We also have plenty of time until the next release cycle if we want to just throw it under `vim.readsecure()` for now and refactor into a separate module later on when we have more use cases.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20992,1015960605,2022-11-07T22:27:36Z,src/nvim/statusline.c,"@@ -647,6 +634,10 @@ int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, int use_san     stl_separator_locations = xmalloc(sizeof(int) * stl_items_len);   } +  // if ""fmt"" was set insecurely it needs to be evaluated in the sandbox+  const int use_sandbox = opt_name ? was_set_insecurely(wp, opt_name, opt_scope)",API function `nvim_eval_statusline()` will not pass along an option name. Opted to pass along NULL instead and null check here. This patch didn't end up porting as cleanly as I would have hoped but I guess it's still an improvement.,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/20976,1016420845,2022-11-08T10:15:31Z,runtime/lua/vim/fs.lua,"@@ -227,7 +231,20 @@ end ---@return (string) Normalized path function M.normalize(path)   vim.validate({ path = { path, 's' } })-  return (path:gsub('^~/', vim.env.HOME .. '/'):gsub('%$([%w_]+)', vim.env):gsub('\\', '/'))+  local p = (path:gsub('^~/', vim.env.HOME .. '/'):gsub('%$([%w_]+)', vim.env):gsub('\\', '/'))++  -- Try to also convert the path to an absolute path with symlinks resolved, but if the path does+  -- not yet exist simply return it as-is.+  return M.realpath(p) or p+end++--- Convert a path to an absolute path, resolving symlinks.+---+---@param path (string) Path to convert to an absolute path+---@return (string|nil) Absolute path, or nil if the file or directory does not+---        exist.","I think that `fs_realpath` requires a deeper look, since we're not handling all the cases where this function can fail._see https://github.com/isaacs/fs.realpath/blob/c1a831d877138d9ee66f4dfbf2a8a80e0a899268/index.js#L16-L22 for a potential solution_from https://docs.libuv.org/en/v1.x/fs.html#c.uv_fs_realpath> >  **Warning**:  This function has certain platform-specific caveats that were discovered when used in Node.> >   * macOS and other BSDs: this function will fail with UV_ELOOP if more than 32 symlinks are>     found while resolving the given path.  This limit is hardcoded and cannot be sidestepped.>   * Windows: while this function works in the common case, there are a number of corner cases>     where it doesn't:>     - Paths in ramdisk volumes created by tools which sidestep the Volume Manager (such as ImDisk)>       cannot be resolved.>     - Inconsistent casing when using drive letters.>     - Resolved path bypasses subst'd drives.> >     While this function can still be used, it's not recommended if scenarios such as the>     above need to be supported.>     The background story and some more details on these issues can be checked [here](https://github.com/nodejs/node/issues/7726).",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/19877,1016644158,2022-11-08T13:38:11Z,src/nvim/api/private/helpers_lua.c,"@@ -0,0 +1,82 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check","this filename is a little weird. The long term goal is to get rid of the arbitrary namespace of ""helper"" functions (like misc1/misc2.c all over again) and instead group utility functions together with the API functions that use them. Nothing else changed, these functions would now belong in `api/buffer.c` which is still a bit big, but no longer painfully so. ",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/21008,1017652440,2022-11-09T09:03:36Z,src/nvim/drawscreen.c,"@@ -165,14 +165,6 @@ bool default_grid_alloc(void)   // size is wrong.    grid_alloc(&default_grid, Rows, Columns, true, true);-  StlClickDefinition *new_tab_page_click_defs =-    xcalloc((size_t)Columns, sizeof(*new_tab_page_click_defs));--  stl_clear_click_defs(tab_page_click_defs, tab_page_click_defs_size);-  xfree(tab_page_click_defs);--  tab_page_click_defs = new_tab_page_click_defs;-  tab_page_click_defs_size = Columns;","Do this in `redraw_tabline()` instead, similarly to how this is done in `win_redr_custom()` for statusline and winbar(using `clear/alloc_click_defs()`).",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21024,1020141172,2022-11-11T11:37:38Z,runtime/lua/vim/treesitter/highlighter.lua,"@@ -265,6 +265,59 @@ function TSHighlighter._on_win(_, _win, buf, _topline)   return true end +--- Highlights a region of the buffer with a given language+---@param buf buffer buffer to highlight. Defaults to the current buffer if 0+---@param ns number namespace for the highlights+---@param region {[1]:number, [2]:number, [3]: number, [4]: number} (table) Region to highlight {start_row, start_col, end_row, end_col}+---@param lang string treesitter language+function TSHighlighter.highlight_region(buf, ns, region, lang)+  buf = (buf == 0 or buf == nil) and vim.api.nvim_get_current_buf() or buf+  vim.fn.bufload(buf)++  vim.api.nvim_buf_clear_namespace(buf, ns, region[1], region[3] + 1)++  local language = require('vim.treesitter.language')+  language.require_language(lang)++  -- we can't use a cached parser here since that could interfer with the existing parser of the buffer+  local LanguageTree = require('vim.treesitter.languagetree')+  local parser = LanguageTree.new(buf, lang)+  parser:set_included_regions({ { region } })+  parser:parse()++  parser:for_each_tree(function(tstree, tree)+    if not tstree then+      return+    end++    local highlighter_query = TSHighlighterQuery.new(tree:lang())++    -- Some injected languages may not have highlight queries.+    if not highlighter_query:query() then+      return+    end++    local iter = highlighter_query:query():iter_captures(tstree:root(), buf, region[1], region[3])++    for capture, node, metadata in iter do+      local start_row, start_col, end_row, end_col = node:range()++      local hl = highlighter_query.hl_cache[capture]+      local is_spell = highlighter_query:query().captures[capture] == 'spell'++      if hl and not is_spell then+        vim.api.nvim_buf_set_extmark(buf, ns, start_row, start_col, {+          end_line = end_row,+          end_col = end_col,+          hl_group = hl,+          priority = (tonumber(metadata.priority) or 100) + 10, -- add 10, so it will be higher than the standard highlighter of the buffer+          conceal = metadata.conceal,+        })+      end+    end+  end, true)",This is all duplicated from the highlighters `on_line` callback.Can you DRY this up?,X
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/21024,1020145994,2022-11-11T11:44:47Z,runtime/lua/vim/treesitter/highlighter.lua,"@@ -265,6 +265,59 @@ function TSHighlighter._on_win(_, _win, buf, _topline)   return true end +--- Highlights a region of the buffer with a given language+---@param buf buffer buffer to highlight. Defaults to the current buffer if 0+---@param ns number namespace for the highlights+---@param region {[1]:number, [2]:number, [3]: number, [4]: number} (table) Region to highlight {start_row, start_col, end_row, end_col}+---@param lang string treesitter language+function TSHighlighter.highlight_region(buf, ns, region, lang)+  buf = (buf == 0 or buf == nil) and vim.api.nvim_get_current_buf() or buf+  vim.fn.bufload(buf)++  vim.api.nvim_buf_clear_namespace(buf, ns, region[1], region[3] + 1)++  local language = require('vim.treesitter.language')+  language.require_language(lang)++  -- we can't use a cached parser here since that could interfer with the existing parser of the buffer+  local LanguageTree = require('vim.treesitter.languagetree')+  local parser = LanguageTree.new(buf, lang)+  parser:set_included_regions({ { region } })+  parser:parse()++  parser:for_each_tree(function(tstree, tree)+    if not tstree then+      return+    end++    local highlighter_query = TSHighlighterQuery.new(tree:lang())++    -- Some injected languages may not have highlight queries.+    if not highlighter_query:query() then+      return+    end++    local iter = highlighter_query:query():iter_captures(tstree:root(), buf, region[1], region[3])++    for capture, node, metadata in iter do+      local start_row, start_col, end_row, end_col = node:range()++      local hl = highlighter_query.hl_cache[capture]+      local is_spell = highlighter_query:query().captures[capture] == 'spell'++      if hl and not is_spell then+        vim.api.nvim_buf_set_extmark(buf, ns, start_row, start_col, {+          end_line = end_row,+          end_col = end_col,+          hl_group = hl,+          priority = (tonumber(metadata.priority) or 100) + 10, -- add 10, so it will be higher than the standard highlighter of the buffer+          conceal = metadata.conceal,+        })+      end+    end+  end, true)","I thought about that, but while it is similar, it also has a lot of differences.",X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21024,1020210681,2022-11-11T13:16:45Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -11,6 +11,7 @@ local language = require('vim.treesitter.language') ---@field _regions table List of regions this tree should manage and parse ---@field _lang string Language name ---@field _regions table+---@field _custom_injections table<string, table> table of lang to list of regions","```suggestion---@field _custom_injections table<string, table> table of lang to list of regions```(while you're touching that code)Wouldn't using `regions` be better here?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21020,1020769001,2022-11-12T14:44:25Z,test/functional/api/proc_spec.lua,"@@ -62,7 +62,7 @@ describe('API', function()     it('returns process info', function()       local pid = funcs.getpid()       local pinfo = request('nvim_get_proc', pid)-      eq((iswin() and 'nvim.exe' or 'nvim'), pinfo.name)+      eq((is.os.win and 'nvim.exe' or 'nvim'), pinfo.name)","This is too clever and too nested. We need to stop this ""builder pattern""-like cleverness and adding submodules just to have english-like statements. `is_os` and `is_ci` are not really related except in their shared ""verb"".The major, major problem with these clever English-like submodules is that the APIs are all constant guesswork for users. What English sentence do I have to mimic now? Which clever module contains what I'm looking for? (""is"" has nothing to do with anything except it's the start of an English sentence)I suggest two functions: `is_os` and `is_ci`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21020,1020769774,2022-11-12T14:52:14Z,test/helpers.lua,"@@ -816,6 +812,21 @@ function module.read_nvim_log(logfile, ci_rename)   return log end +module.is = {+  os = {+    bsd = is_os('bsd'),+    freebsd = is_os('freebsd'),+    mac = is_os('mac'),+    openbsd = is_os('openbsd'),+    win = is_os('win'),","I can see that this probably helps with code-completion. But if we go down this road of crafting tables/submodules for code-completion engines, that establishes a (noisy) forever-pattern just to solve the current limitations of code-completion engines. Instead, can code-completion engines discover the available keys using something like emmy lua docstring synstax? E.g. (fictional syntax):```-- @param name string: 'bsd'|'mac'|'win'function is_os(name)```",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21010,1020771002,2022-11-12T15:03:04Z,test/functional/api/server_notifications_spec.lua,"@@ -78,13 +79,7 @@ describe('notify', function()   end)    it('cancels stale events on channel close', function()-    if isCI() then-      pending('hangs on CI #14083 #15251')-      return-    elseif helpers.skip_fragile(pending) then-      return-    end-    if helpers.pending_win32(pending) then return end+    skip(isCI(), 'hangs on CI #14083 #15251')","I think returns are only needed when used outside of `it`, not inside. I think this is true even for `pending`. It's in my todo list to investigate and to correct the test readme.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21020,1020772730,2022-11-12T15:18:13Z,test/helpers.lua,"@@ -816,6 +812,21 @@ function module.read_nvim_log(logfile, ci_rename)   return log end +module.is = {+  os = {+    bsd = is_os('bsd'),+    freebsd = is_os('freebsd'),+    mac = is_os('mac'),+    openbsd = is_os('openbsd'),+    win = is_os('win'),","> Instead, can code-completion engines discover the available keys using something like emmy lua docstring synstax?Given enough time, probably yeah. I don't mind this pattern regardless, so works for me.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21020,1020781815,2022-11-12T16:45:01Z,test/helpers.lua,"@@ -816,6 +812,21 @@ function module.read_nvim_log(logfile, ci_rename)   return log end +module.is = {+  os = {+    bsd = is_os('bsd'),+    freebsd = is_os('freebsd'),+    mac = is_os('mac'),+    openbsd = is_os('openbsd'),+    win = is_os('win'),","Principles/conventions I generally go by:- less stringy code should be preferred- function calls should be minimised- constant information should be calculated up front> that establishes a (noisy) forever-pattern just to solve the current limitations of code-completion engines.If anything, this is less noisy than what was there before.> Instead, can code-completion engines discover the available keys using something like emmy lua docstring synstax? E.g. (fictional syntax):Sumneko can already do this, but the point is we don't **need** to when we can just define this stuff statically. Code is always better than comments.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/20890,1020902348,2022-11-13T13:21:09Z,test/functional/ex_cmds/grep_spec.lua,"@@ -18,4 +18,20 @@ describe(':grep', function()     feed('<cr>')  -- Press ENTER     ok(eval('len(getqflist())') > 9000)  -- IT'S OVER 9000!!1   end)++  it('works when both shellpipe and makeef are unset', function()+    if eval(""executable('grep')"") == 0 then+      pending('missing ""grep"" command')+      return+    end++    feed_command([[set grepprg=grep\ -r]])+    feed_command([[set shellpipe=]])+    feed_command([[set makeef=]])+    -- Change to test directory so that the test does not run too long.+    feed_command('cd test')+    feed_command('grep a **/*')+    feed('<cr>')  -- Press ENTER+    ok(eval('len(getqflist())') > 9000)  -- IT'S OVER 9000!!1","The description of the test includes ""large output"" though. Can you tell what the minimum thing is we should test? Regardless, I'd prefer fixing that up in a separate commit.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21051,1022682297,2022-11-15T11:37:27Z,src/nvim/channel.h,"@@ -53,6 +53,7 @@ typedef struct {   garray_T buffer;   bool eof;   bool buffered;+  char __pad[6];","Yes it does exactly that. However, to remove the warnings introduced by `-Wpadded` the padding needs to be added manually.**I don't plan to merge any of the manual padding.**The goal here is to just re-arrange some fields in existing structs to use less memory.E.g.```cstruct {    int a;    long b;    int c;}```Uses 24 bytes in memory since the compiler will pad this to:```cstruct {    int a;    char _pad0[4];    long b;    int c;    char _pad1[4];}```However, if we re-arrange the fields to:```cstruct {    int a;    int c;    long b;}```This now uses only 16 bytes of memory (30% reduction) and has zero padding.The goal of this PR is to find which structs have fields which can be re-arranged like this.I'd like to add some checks to enforce this, but I can't find anything concrete.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20621,1024186942,2022-11-16T15:51:05Z,src/nvim/drawline.c,"@@ -1155,13 +1229,17 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange,                                 startrow, filler_lines, filler_todo,                                 &c_extra, &c_final, extra, sizeof(extra),                                 &p_extra, &n_extra, &char_attr, sign_idx,-                                sign_cul_attr);+                                sign_cul_attr, &statuscol);           sign_idx++;           if (sign_idx < wp->w_scwidth) {             draw_state = WL_SIGN - 1;           } else {             sign_idx = 0;           }+          if (statuscol.draw) {+            n_extra = 0;+            continue;+          }",This block is a bit hacky:- avoid using `continue`. Wouldn't `draw_state = WL_SIGN - 1;` work?- `get_sign_display_info` is setting `n_extra` and then you reset it here. This kind of data flow has contributed to the complexity of this function.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21090,1025377506,2022-11-17T15:53:21Z,src/nvim/memline.c,"@@ -131,7 +131,8 @@ struct data_block {   unsigned db_free;             // free space available   unsigned db_txt_start;        // byte where text starts   unsigned db_txt_end;          // byte just after data block-  linenr_T db_line_count;       // number of lines in this block+  // linenr_T db_line_count;+  long db_line_count;           // number of lines in this block","I guess this needs to have the same size as `b0_magic_long`. Maybe changing some other variables to `linenr_T` can work too, but I haven't figured out how.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21097,1025916042,2022-11-18T02:02:13Z,src/nvim/buffer.c,"@@ -3961,30 +3961,6 @@ char *buf_spname(buf_T *buf)   return NULL; } -/// Find a window for buffer ""buf"".-/// If found true is returned and ""wp"" and ""tp"" are set to-/// the window and tabpage.-/// If not found, false is returned.-///-/// @param       buf  buffer to find a window for-/// @param[out]  wp   stores the found window-/// @param[out]  tp   stores the found tabpage-///-/// @return  true if a window was found for the buffer.-bool find_win_for_buf(buf_T *buf, win_T **wp, tabpage_T **tp)","This function is no longer used in Nvim, probably because all its usages have been replaced by `aucmd_prepbuf()`.",X
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21100,1025961213,2022-11-18T03:51:00Z,src/nvim/auevents.lua,"@@ -72,6 +72,7 @@ return {     'InsertLeavePre',         -- just before leaving Insert mode     'LspAttach',              -- after an LSP client attaches to a buffer     'LspDetach',              -- after an LSP client detaches from a buffer+    'LspSemanticTokens',      -- after an LSP semantic tokens request is processed","We are already using `LspRequest` as a User autocommand, maybe we should just promote that to a first class autocmd and make the autocommand pattern match on the request type.So rather than a new `LspSemanticTokens` autocommand, one would use `autocmd LspRequest textDocument/semanticTokens/*`.",X
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1025962015,2022-11-18T03:53:03Z,src/nvim/auevents.lua,"@@ -72,6 +72,7 @@ return {     'InsertLeavePre',         -- just before leaving Insert mode     'LspAttach',              -- after an LSP client attaches to a buffer     'LspDetach',              -- after an LSP client detaches from a buffer+    'LspSemanticTokens',      -- after an LSP semantic tokens request is processed",Can you direct a patterned autocmd to a specific buffer? Documentation (and reality) seems to imply you can���t mix them.,X
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21100,1025972022,2022-11-18T04:18:09Z,src/nvim/auevents.lua,"@@ -72,6 +72,7 @@ return {     'InsertLeavePre',         -- just before leaving Insert mode     'LspAttach',              -- after an LSP client attaches to a buffer     'LspDetach',              -- after an LSP client detaches from a buffer+    'LspSemanticTokens',      -- after an LSP semantic tokens request is processed","Correct, you cannot. The pattern needs to be a filename in order to do that.However, we now have support for passing arbitrary data to Lua autocommand callbacks. So we could use that to pass the request to the autocommand callback. We already do this for `LspAttach` and `LspDetach`.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1025985232,2022-11-18T04:50:37Z,src/nvim/auevents.lua,"@@ -72,6 +72,7 @@ return {     'InsertLeavePre',         -- just before leaving Insert mode     'LspAttach',              -- after an LSP client attaches to a buffer     'LspDetach',              -- after an LSP client detaches from a buffer+    'LspSemanticTokens',      -- after an LSP semantic tokens request is processed","So you're suggesting adding a ""pattern"" to the arbitrary data table so consumers of the generic autocmd can distinguish one for semantic tokens? Something like:```luaapi.nvim_exec_autocmds('LspResponse', {  buffer = bufnr,  data = {    method = 'textDocument/semanticTokens', -- add /full? /full/*? Not sure what this should be exactly assuming range requests are added at some point     highlights = buf_state.highlights,  }})````LspRequest` itself doesn't work because that's fired when requests are sent; not when responses are received. We could promote both for symmetry.However, that precludes us from being able to do generic response autocmds in core--we wouldn't want to fire a generic one _and_ one in the semantic tokens handler. This was also why I made a special autocmd just for this, but I'm open to counter arguments. ",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21100,1026148130,2022-11-18T08:29:49Z,src/nvim/auevents.lua,"@@ -72,6 +72,7 @@ return {     'InsertLeavePre',         -- just before leaving Insert mode     'LspAttach',              -- after an LSP client attaches to a buffer     'LspDetach',              -- after an LSP client detaches from a buffer+    'LspSemanticTokens',      -- after an LSP semantic tokens request is processed","I don't think `LspRequest` is a good match here, it maps 1:1 to lsp requests, but the token event is synthesized.If we're going to use autocmds I think we'll need a new dedicated event.An alternative could be to move away from the extensiblity/semantic-token abstraction level, and instead go for a  high level LSP highlighting API/functionality. Without allowing access to tokens and also hiding the LSP semantic token semantics. E.g. something like `vim.lsp.hl_attach(client, buf)` that you can call within a `LspAttach` event and that keeps everything else implementation detail, without any other public API.I'm not sure if that's better or worse, but it would focus the API more on the common case users are going to use it for, and plugins who really want to use the tokens could still use the lsp client's request functions directly to retrieve them.> Determine if core should provide basic highlighting supportYes I think it should. ",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1026351185,2022-11-18T11:55:21Z,src/nvim/drawscreen.c,"@@ -1833,6 +1833,12 @@ static void win_update(win_T *wp, DecorProviders *providers)       did_update = DID_NONE;     } +    if (wp->w_redr_statuscol) {+      wp->w_redr_statuscol = false;+      changed_line_abv_curs_win(wp);+      goto win_update_start;","I see, that does sound problematic(I'll see if I can reproduce the issue somehow). Though for this purpose `b_mod_top/bot` should be 0 anyways, we want to redraw the entire window.I just want to force a recursive redraw, I don't care how it happens����. Is there another recommended way to do so? There is already a recursive redraw block at the end of `win_update()`  but this is dependent on `cpoptions` which also doesn't seem ideal.If not, I think the `goto` or loop reset should be fine, perhaps also resetting `b_mod_top/bot` but I think these should already be 0.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1026361416,2022-11-18T12:08:09Z,src/nvim/drawscreen.c,"@@ -1833,6 +1833,12 @@ static void win_update(win_T *wp, DecorProviders *providers)       did_update = DID_NONE;     } +    if (wp->w_redr_statuscol) {+      wp->w_redr_statuscol = false;+      changed_line_abv_curs_win(wp);+      goto win_update_start;","Yes, it seems irrelevant because this block will force an entire window update(we have changed `wp->w_nrwidth_width`):https://github.com/neovim/neovim/blob/21ff00c06d34a8880b506e48943daaa172338370/src/nvim/drawscreen.c#L1046-L1048",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21020,1026533323,2022-11-18T14:52:46Z,test/helpers.lua,"@@ -269,43 +269,39 @@ function module.check_logs()     table.concat(runtime_errors, ', '))) end -function module.iswin()-  return package.config:sub(1,1) == '\\'-end---- Gets (lowercase) OS name from CMake, uname, or ""win"" if iswin().-module.uname = (function()-  local platform = nil-  return (function()",This closed over the `platform` local so that we don't keep shelling out for every call. Not a big deal but why reverse that?,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/13503,1026539788,2022-11-18T14:58:40Z,src/nvim/main.c,"@@ -1797,9 +1797,16 @@ static bool do_user_initialization(void)       EMSG3(_(""Conflicting configs: \""%s\"" \""%s\""""), init_lua_path, vimrc_path);     } +    do_exrc = p_exrc;+    if (do_exrc) {+      do_exrc = (path_full_compare((char_u *)VIMRC_FILE, init_lua_path,+                                   false, true)+                 != kEqualFiles);+    }+",This is not needed. This condition (`path_full_compare(...) != kEqualFiles`) will always be true in this case.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21020,1026541124,2022-11-18T14:59:56Z,test/helpers.lua,"@@ -816,6 +812,21 @@ function module.read_nvim_log(logfile, ci_rename)   return log end +module.is = {+  os = {+    bsd = is_os('bsd'),+    freebsd = is_os('freebsd'),+    mac = is_os('mac'),+    openbsd = is_os('openbsd'),+    win = is_os('win'),","> Code is always better than comments.Sure, but these type declarations _are code_ that happens to ""fail gracefully"" into an inert comment depending on tooling.> If anything, this is less noisy than what was there before.I'm not seeing much noise when I look at the `is_os` usages. The noise I'm referring to is the cute `an.english.sentence` pattern that inverts the idea of putting things in meaningful buckets. That pattern used by busted/luassert isn't found in our codebase and is a complete departure and not necessarily desirable for the reasons mentioned in https://github.com/neovim/neovim/pull/21020#discussion_r1020769001",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1026863847,2022-11-18T20:45:38Z,src/nvim/auevents.lua,"@@ -72,6 +72,7 @@ return {     'InsertLeavePre',         -- just before leaving Insert mode     'LspAttach',              -- after an LSP client attaches to a buffer     'LspDetach',              -- after an LSP client detaches from a buffer+    'LspSemanticTokens',      -- after an LSP semantic tokens request is processed",Closing since this comment is no longer relevant to the design.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1026954704,2022-11-18T22:48:32Z,runtime/lua/vim/secure.lua,"@@ -86,21 +111,57 @@ function M.read(path)     trust[fullpath] = hash   end +  write_trust(trust)++  return contents+end++--- Update the trust status of file at path in the trust database at+--- $XDG_STATE_HOME/nvim/trust.+---+--- @param path (string) Path to a file to update status for.+--- @param allow (boolean) If true, set status to allow, otherwise set to deny.+function M.trust(path, allow)+  vim.validate({ path = { path, 's' } })+  vim.validate({ allow = { allow, 'b' } })++  local fullpath = vim.loop.fs_realpath(vim.fs.normalize(path))+  if not fullpath then+    return+  end","I think if the user is explicitly adding a file to the trust db then we want some kind of indication if the file does not exist. Doesn't need to be an error necessarily, but we could use the Lua pattern of returning multiple values: `true, nil` on success, and `false, msg` on failure (where `msg` is a string indicating what failed, in this case that the file doesn't exist).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1026955010,2022-11-18T22:49:15Z,runtime/lua/vim/secure.lua,"@@ -86,21 +111,57 @@ function M.read(path)     trust[fullpath] = hash   end +  write_trust(trust)++  return contents+end++--- Update the trust status of file at path in the trust database at+--- $XDG_STATE_HOME/nvim/trust.+---+--- @param path (string) Path to a file to update status for.+--- @param allow (boolean) If true, set status to allow, otherwise set to deny.+function M.trust(path, allow)","We also want the ability to remove a file from the trust database completely, so this API will need to reflect that.This could be represented as a `:trust forget <file>` command.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21020,1026957680,2022-11-18T22:53:49Z,test/helpers.lua,"@@ -269,43 +269,39 @@ function module.check_logs()     table.concat(runtime_errors, ', '))) end -function module.iswin()-  return package.config:sub(1,1) == '\\'-end---- Gets (lowercase) OS name from CMake, uname, or ""win"" if iswin().-module.uname = (function()-  local platform = nil-  return (function()","If we want to avoid the ` = (function() ... end)()` pattern (which I agree is a little _too_ clever), just use a `do ... end` block:```luado  local platform = nil  function module.uname()    ...  endend```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21117,1027049321,2022-11-19T07:25:48Z,test/functional/terminal/helpers.lua,"@@ -4,19 +4,28 @@ local helpers = require('test.functional.helpers')(nil) local Screen = require('test.functional.ui.screen') local testprg = helpers.testprg+local exec_lua = helpers.exec_lua local feed_command, nvim = helpers.feed_command, helpers.nvim  local function feed_data(data)-  -- A string containing NUL bytes is not converted to a Blob when-  -- calling nvim_set_var() API, so convert it using Lua instead.-  nvim('exec_lua', 'vim.g.term_data = ...', {data})-  nvim('command', 'call jobsend(b:terminal_job_id, term_data)')+  exec_lua('vim.api.nvim_chan_send(vim.b.terminal_job_id, ...)', data) end  local function feed_termcode(data)-  -- feed with the job API-  nvim('command', 'call jobsend(b:terminal_job_id, ""\\x1b'..data..'"")')+  feed_data('\x1b' .. data)",This does not work with Lua 5.1. Use `'\027'` instead.```suggestion  feed_data('\027' .. data)```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21117,1027050469,2022-11-19T07:38:29Z,test/functional/terminal/helpers.lua,"@@ -4,19 +4,28 @@ local helpers = require('test.functional.helpers')(nil) local Screen = require('test.functional.ui.screen') local testprg = helpers.testprg+local exec_lua = helpers.exec_lua local feed_command, nvim = helpers.feed_command, helpers.nvim  local function feed_data(data)-  -- A string containing NUL bytes is not converted to a Blob when-  -- calling nvim_set_var() API, so convert it using Lua instead.-  nvim('exec_lua', 'vim.g.term_data = ...', {data})-  nvim('command', 'call jobsend(b:terminal_job_id, term_data)')+  exec_lua('vim.api.nvim_chan_send(vim.b.terminal_job_id, ...)', data)","`chansend()` (`jobsend()`) can accept either a list or a string, while `nvim_chan_send` only accepts a string, so `table.concat` is needed here when `data` is a table.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21117,1027055131,2022-11-19T08:20:35Z,test/functional/terminal/helpers.lua,"@@ -4,19 +4,31 @@ local helpers = require('test.functional.helpers')(nil) local Screen = require('test.functional.ui.screen') local testprg = helpers.testprg+local exec_lua = helpers.exec_lua local feed_command, nvim = helpers.feed_command, helpers.nvim  local function feed_data(data)-  -- A string containing NUL bytes is not converted to a Blob when-  -- calling nvim_set_var() API, so convert it using Lua instead.-  nvim('exec_lua', 'vim.g.term_data = ...', {data})-  nvim('command', 'call jobsend(b:terminal_job_id, term_data)')+  if type(data) == 'table' then+      data = table.concat(data)","```suggestion      data = table.concat(data, '\n')```",
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1027080314,2022-11-19T11:51:38Z,runtime/lua/vim/secure.lua,"@@ -86,21 +111,57 @@ function M.read(path)     trust[fullpath] = hash   end +  write_trust(trust)++  return contents+end++--- Update the trust status of file at path in the trust database at+--- $XDG_STATE_HOME/nvim/trust.+---+--- @param path (string) Path to a file to update status for.+--- @param allow (boolean) If true, set status to allow, otherwise set to deny.+function M.trust(path, allow)","I think assuming `secure` would be responsible only for the limited access to certain files, like it is now, `vim.secure.allow` and `vim.secure.deny` are self-explanatory. I do prefer having a single `trust` function with a parameter as the public api, though.",X
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1027101590,2022-11-19T14:49:36Z,test/functional/lua/secure_spec.lua,"@@ -168,4 +168,84 @@ describe('vim.secure', function()       eq(false, curbufmeths.get_option('modifiable'))     end)   end)++  describe('trust()', function()+    local xstate = 'Xstate'++    setup(function()+      helpers.mkdir_p(xstate .. pathsep .. (iswin and 'nvim-data' or 'nvim'))+    end)++    teardown(function()+      helpers.rmdir(xstate)+    end)++    before_each(function()+      helpers.write_file('test_file', 'test')+    end)++    after_each(function()+      os.remove('test_file')+    end)++    it('sets file as trusted then denied', function()+      local cwd = funcs.getcwd()+      local hash = funcs.sha256(helpers.read_file('test_file'))++      eq({true, nil}, exec_lua([[return {vim.secure.trust('test_file', 'allow')}]]))",Not sure if this is the correct way to assert on return values from a lua func? I've been looking through the test for a similar use-case and this is the only way to achieve this I found.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20801,1027102233,2022-11-19T14:55:35Z,runtime/lua/vim/_watch.lua,"@@ -0,0 +1,170 @@+-- Create a file watcher, each watcher is identified by the buffer number of the file it is watching.++local uv = vim.loop++local M = {}+M.__index = M+local WatcherList = {}++-- Checks if a buffer should have a M attached to it.+local function buf_isvalid(bufnr)+  if bufnr == nil or not vim.api.nvim_buf_is_valid(bufnr) then+    return false+  end++  local buflisted = vim.api.nvim_buf_get_option(bufnr, 'buflisted')","Prefer `vim.bo[bufnr].buflisted` or `vim.api.nvim_get_optin_value('buflisted', {buffer=bufnr})`",X
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1027151453,2022-11-19T22:23:21Z,src/nvim/lua/executor.c,"@@ -2217,3 +2217,17 @@ char *nlua_read_secure(const char *path)    return buf; }++void nlua_trust(const char *set, const char *path)+{+  lua_State *const lstate = global_lstate;+  lua_getglobal(lstate, ""vim"");+  lua_getfield(lstate, -1, ""secure"");+  lua_getfield(lstate, -1, ""trust"");+  lua_pushstring(lstate, path);+  if (strcmp(set, ""allow""))+    lua_pushboolean(lstate, 1);+  else if (strcmp(set, ""deny""))+    lua_pushboolean(lstate, 0);",If statement no longer there - resolved.,
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1027152911,2022-11-19T22:31:25Z,test/functional/ex_cmds/trust_spec.lua,"@@ -0,0 +1,67 @@+local helpers = require('test.functional.helpers')(after_each)++local eq = helpers.eq+local clear = helpers.clear+local command = helpers.command+local pathsep = helpers.get_pathsep()+local iswin = helpers.iswin()+local curbufmeths = helpers.curbufmeths+local exec_lua = helpers.exec_lua+local feed_command = helpers.feed_command+local feed = helpers.feed+local funcs = helpers.funcs+local pcall_err = helpers.pcall_err++describe(':trust', function()+  local xstate = 'Xstate'++  setup(function()+    helpers.mkdir_p(xstate .. pathsep .. (iswin and 'nvim-data' or 'nvim'))+  end)++  teardown(function()+    helpers.rmdir(xstate)+  end)++  before_each(function()+    helpers.write_file('test_file', 'test')+  end)++  after_each(function()+    os.remove('test_file')+  end)++  it('allow then deny then forget a file', function()+    local cwd = funcs.getcwd()","It might be the late hour, but it seems like I'm missing something here, and I can't figure what it is :). This test file is very similar to `secure_spec.lua`, yet here `getcwd()` throws an error for me```ERROR    test/functional/ex_cmds/trust_spec.lua @ 51: :trust deny then allow then forget a filetest/functional/helpers.lua:103: attempt to index upvalue 'session' (a nil value)stack traceback:	test/functional/helpers.lua:103: in function 'getcwd'	test/functional/ex_cmds/trust_spec.lua:52: in function <test/functional/ex_cmds/trust_spec.lua:51>```",X
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/21107,1027155594,2022-11-19T22:58:09Z,runtime/lua/vim/secure.lua,"@@ -86,21 +113,75 @@ function M.read(path)     trust[fullpath] = hash   end +  write_trust(trust)++  return contents+end++--- Update the trust status of file at path in the trust database at+--- $XDG_STATE_HOME/nvim/trust.+---+--- @param path (string) Path to a file to update status for.+--- @param mode (string) One of the following:+---   - 'allow': Add file to trust database and set it as trusted+---   - 'deny': Add file to trust database and set it as denied+---   - 'forget': Remove file from trust database+--- @return (boolean, string|nil) success, errmsg: true and nil if the operation was successful,+---   otherwise false and an error message.+function M.trust(path, mode)+  vim.validate({ path = { path, 's' } })+  vim.validate({ allow = { mode, 's' } })","As long as the linter is not complaining, it's probably fine either way.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1027174598,2022-11-20T02:26:50Z,src/nvim/ex_cmds.c,"@@ -4960,3 +4961,20 @@ void ex_oldfiles(exarg_T *eap)     }   } }++void ex_trust(exarg_T *eap)+{+  char *p = skiptowhite(eap->arg);+  size_t len = (size_t)(p - eap->arg);+  char *mode = xcalloc(len + 1, sizeof(char));+  memcpy(mode, eap->arg, len);++  char *path = skipwhite(p);+  char *errmsg = nlua_trust(path, mode);","I actually prefer the original approach. Functions should be grouped by interface, not implementation, and since `ex_trust` is an ex command it should be with the other ex commands. The fact that it's implemented using a Lua function is just an implementation detail, so I don't think it belongs in `executor.c`.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21132,1027294899,2022-11-20T13:57:21Z,runtime/lua/vim/fs.lua,"@@ -67,23 +67,24 @@ end  --- Find files or directories in the given path. ------- Finds any files or directories given in {names} starting from {path}. If+--- Finds any files or directories given in {names} starting from {path} (if given). If --- {upward} is ""true"" then the search traverses upward through parent --- directories; otherwise, the search traverses downward. Note that downward --- searches are recursive and may search through many directories! If {stop}---- is non-nil, then the search stops when the directory given in {stop} is---- reached. The search terminates when {limit} (default 1) matches are found.+--- is omitted, then the search stops when the directory given in {stop} is+--- reached. The search terminates when {limit} (1 if omitted) matches are found. --- The search can be narrowed to find only files or or only directories by---- specifying {type} to be ""file"" or ""directory"", respectively.+--- specifying {type} to be either ""file"" or ""directory"", respectively. --- ---@param names (string|table|fun(name: string): boolean) Names of the files ---             and directories to find. ---             Must be base names, paths and globs are not supported.----             If a function it is called per file and dir within the----             traversed directories to test if they match.+---             The function is called per file and directory within the+---             traversed directories to test if they match {names}.+--- ---@param opts (table) Optional keyword arguments: ---                       - path (string): Path to begin searching from. If----                              omitted, the current working directory is used.+---                              omitted, the current working directory (""nvim"" executable) is used.","The fact that we're talking about the working directory of Neovim is implied and does not need to be stated. However, it may not be a bad idea to add a link to `|current-directory|`.```suggestion---                              omitted, the |current-directory| is used.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21132,1027295195,2022-11-20T13:58:57Z,runtime/lua/vim/fs.lua,"@@ -67,23 +67,24 @@ end  --- Find files or directories in the given path. ------- Finds any files or directories given in {names} starting from {path}. If+--- Finds any files or directories given in {names} starting from {path} (if given). If --- {upward} is ""true"" then the search traverses upward through parent --- directories; otherwise, the search traverses downward. Note that downward --- searches are recursive and may search through many directories! If {stop}---- is non-nil, then the search stops when the directory given in {stop} is---- reached. The search terminates when {limit} (default 1) matches are found.+--- is omitted, then the search stops when the directory given in {stop} is+--- reached. The search terminates when {limit} (1 if omitted) matches are found. --- The search can be narrowed to find only files or or only directories by---- specifying {type} to be ""file"" or ""directory"", respectively.+--- specifying {type} to be either ""file"" or ""directory"", respectively. ---","Does ""omitted"" provide any technical clarity over ""non-nil""? Same question for ""X if omitted"" versus ""default X""? We can hem-haw for eternity on pedantic style differences, but this is a technical reference manual where unambiguous clarity of semantics is more important than style. Unless you or someone else can make a case for it, this just seems like stylistic preference.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21137,1027325495,2022-11-20T17:32:04Z,runtime/doc/lua.txt,"@@ -9,24 +9,11 @@ Lua engine                                                           *lua* *Lua*                                        Type |gO| to see the table of contents.  ==============================================================================-INTRODUCTION                                                       *lua-intro*+INTRODUCTION -The Lua 5.1 script engine is builtin and always available. Try this command to-get an idea of what lurks beneath: >--    :lua print(vim.inspect(package.loaded))--Nvim includes a ""standard library"" |lua-stdlib| for Lua.  It complements the-""editor stdlib"" (|builtin-functions| and |Ex-commands|) and the |API|, all of-which can be used from Lua code (|lua-vimscript| |vim.api|). Together these-""namespaces"" form the Nvim programming interface.--The |:source| and |:runtime| commands can run Lua scripts. Lua modules can be-loaded with `require('name')`, which by convention usually returns a table.-See |lua-require| for how Nvim finds and loads Lua modules.--See this page for more insight into Nvim Lua:-    https://github.com/nanotee/nvim-lua-guide+The Lua 5.1 script engine is builtin and always available. Nvim also includes+a ""standard library"" |lua-stdlib| for Lua. See |lua-intro| for a quick","I think we should keep a bit more; the whole paragraph about the ""standard library"" seems relevant.(The rest can indeed be punted to `lua-intro`.)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1027361515,2022-11-20T22:07:42Z,runtime/lua/vim/secure.lua,"@@ -86,21 +110,77 @@ function M.read(path)     trust[fullpath] = hash   end +  write_trust(trust)++  return contents+end++--- Update the trust status of file at path in the trust database at",```suggestion--- Update the trust status of file at {path} in the trust database at```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21137,1028091988,2022-11-21T14:14:08Z,runtime/doc/lua-intro.txt,"@@ -0,0 +1,107 @@+*lua-intro.txt*	Nvim++		       NVIM REFERENCE MANUAL++			Introduction to Lua+++This chapter will give you the basics of using Lua in Neovim.++                                      Type |gO| to see the table of contents.++==============================================================================+Introduction							     *lua-intro*++COMMON QUESTIONS++Maybe this section isn't needed. We'll see.++- Is vimscript being deprecated?++NEVER! (idk write something fancy)",```suggestionNope. Vimscript is being promoted. Vim9script however is deprecated.```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21107,1028507137,2022-11-21T20:55:19Z,runtime/doc/lua.txt,"@@ -2370,4 +2370,19 @@ read({path})                                               *vim.secure.read()*         (string|nil) The contents of the given file if it exists and is         trusted, or nil otherwise. +trust({path}, {mode})                                     *vim.secure.trust()*+    Update the trust status of file at {path} in the trust database at+    $XDG_STATE_HOME/nvim/trust.++    Parameters: ~+      ��� {path}  (string) Path to a file to update status for.+      ��� {mode}  (string) One of the following:+                ��� 'allow': Add file to trust database and set it as trusted+                ��� 'deny': Add file to trust database and set it as denied+                ��� 'forget': Remove file from trust database","nit: any reason not to use more common wording? `remove` / `delete`  ```suggestion                ��� ""remove"": Remove file from trust database```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21107,1028509690,2022-11-21T20:58:49Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',","- AFAIK Vim's decided convention for command option-args is the `++` prefix. Thus `:trust ++allow ...`, `:trust ++deny`.     - I'm basing this on discussion from when `:autocmd ... ++nested` was added.    - Other than the old `:cscope` command, are there other prominent cases of the ""subcommand"" pattern in vim ex commands? If not, we should probably stick to the `++arg` convention.- Could we get away with aliasing `:trust foo` to mean `:trust ++allow foo` or is that too clever? ",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1028516308,2022-11-21T21:08:25Z,runtime/lua/vim/secure.lua,"@@ -86,21 +110,77 @@ function M.read(path)     trust[fullpath] = hash   end +  write_trust(trust)++  return contents+end++--- Update the trust status of file at {path} in the trust database at+--- $XDG_STATE_HOME/nvim/trust.+---+---@param path (string) Path to a file to update status for.+---@param mode (string) One of the following:+---   - 'allow': Add file to trust database and set it as trusted+---   - 'deny': Add file to trust database and set it as denied+---   - 'forget': Remove file from trust database","In the Vim help syntax, words between single quotes are interpreted as links to options (e.g. `'textwidth'`). Use double quotes here to prevent that.```suggestion---   - ""allow"": Add file to trust database and set it as trusted---   - ""deny"": Add file to trust database and set it as denied---   - ""forget"": Remove file from trust database```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1028524593,2022-11-21T21:20:03Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',","I think there are a couple of pain points with the interface we need to work out.For one thing, there is an issue with time-of-check to time-of-use (TOCTOU) with a simple non-interactive `:trust` command. For example, user manually inspects `foo`, decides to trust it, then runs `:trust foo`, but the file was changed between the time they read it and the time they ran the `:trust` command. `vim.secure.read()` gets around this by first reading the file into memory and _then_ allowing the user to view the in-memory contents. If the user decides the file is trusted, then the SHA hash of the file as it exists in memory is added to the trust database. If the file is changed on disk anywhere during that process then there will be a hash mismatch.So I wonder if the `:trust` command should be interactive by default and show a similar prompt as `vim.read.secure()`, something like:```foo is untrusted.[a]llow, [d]eny, [v]iew: ```The prompt could change based on the current status of the file in the database:```foo is trusted with hash abcdef01234, but the current file has hash fedcba43210.[d]eny, [a]llow, [f]orget, [v]iew:``````foo is denied.[a]llow, [f]orget, [v]iew:```A bang `:trust!` would be non-interactive for the ""I know what I'm doing, leave me alone"" use case. Though I'm not sure how we add the ""deny"" and ""forget""/""delete"" actions to this (maybe the `++` syntax is the way to go).In addition/alternatively, we could have a `:trust {file} [{sha256}]` form that allows a user to calculate the SHA256 hash of a file separately and use that hash for the file, regardless of what the file's current contents are. This would also avoid the TOCTOU problem (or at least greatly mitigate it). This form would always be non-interactive.Sorry for the wall of text, I'm just thinking through the best way to approach this. The whole motivation for providing this trust architecture is to provide a higher security baseline, so we should make sure we are providing that with the `:trust` ex command as well.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/21107,1028540324,2022-11-21T21:41:45Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',","@gpanders I think this could be solved by opening a buffer with the contents, somehow associating the hash with the buffer, and then making `:trust` save that exact hash. Something similar to this:```lualocal path, text, hash -- path, contents, calculated hash from vim.secure.readvim.cmd('enew')vim.api.nvim_buf_set_lines(0, 0, -1, false, text)vim.api.nvim_buf_create_user_command(0, 'Trust', function()  vim.secure.trust(path, hash)end, {})```",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/21107,1028579753,2022-11-21T22:39:57Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',","Sure, but the command is my entire point :) The user command is just for demonstration purposes, the lowercase `:trust` could do that to make sure that you know exactly what you're whitelisting.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21107,1028580363,2022-11-21T22:41:01Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',","> ""subcommand"" patternThere are `:sign`, `:syntax`, `:filetype`",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1028590867,2022-11-21T22:58:06Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',","@Jlll1 After some discussion on Matrix, I think we want to keep it simple and have `:trust` take no arguments and simply (1) calculate the hash of the current buffer contents (as they exist in memory, **not** on-disk), and (2) update the trust database with the calculated hash and file path.* `:trust` returns an error for buffers with `buftype=nofile` or for which `nvim_buf_get_name()` returns an empty string* In order to manually trust a file, a user can first `:edit` or `:view` it to open the buffer in Neovim, and then just use `:trust`* To deny a file, use `:trust ++deny [{file}]`. To ""forget"" a file use `:trust ++forget [{file}]`. These both take optional file paths, defaulting to the file of the current buffer if omitted.Also I think we should update the interface of `vim.secure.trust()` to accept a buffer number rather than a file path. There is always the possibility that the contents of a buffer do not match the contents of the file on disk, so by using buffer numbers we can ensure that the hash that is calculated is using the contents of the _buffer_, not the contents of the _file_ (a subtle but important difference).Basically this means that `:trust` just runs `vim.secure.trust(<current buffer>, 'allow')`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21133,1029320554,2022-11-22T13:22:15Z,test/functional/helpers.lua,"@@ -959,7 +959,8 @@ end  module = global_helpers.tbl_extend('error', module, global_helpers) -return function(after_each)+return function()+  local after_each = getfenv(2).after_each","Looks like we can't avoid needing to run this function for every test file. So avoiding the argument doesn't really make things less hacky, and has the disadvantage of being less explicit.We might be able to avoid this by using a busted event handler: https://github.com/neovim/neovim/blob/904d0056d520ef01e2873bbaa91a4693e8dfd226/test/busted/outputHandlers/nvim.lua#L272but I think in an event handler `getfenv()` may be less predictable.",
15057271,andrewwillette,https://api.github.com/repos/neovim/neovim/pulls/21147,1029735065,2022-11-22T19:18:43Z,src/nvim/ui_compositor.c,"@@ -716,6 +716,11 @@ static void ui_comp_event(UI *ui, char *name, Array args)       handled = true;     }   })+  if (err.type != kErrorTypeNone) {","@bfredl, thanks for reviewing the PR.I saw the iteration issue when I first made the change, and tried the below:```Cmap_foreach_value(&ui_event_cbs, event_cb, {  Error err = ERROR_INIT;  Object res = nlua_call_ref(event_cb->cb, name, args, false, &err);  if (res.type == kObjectTypeBoolean && res.data.boolean == true) {    handled = true;  }  if (err.type != kErrorTypeNone) {    ELOG(""Error while executing ui_comp_event callback: %s"", err.msg);  }  api_clear_error(&err);})```but I was getting the compiler error of `too many arguments provided to function-like macro invocation`. I'm a C novice and wasn't sure how to approach it. I punted on this problem because of it. With your review, I've made an attempt at handling the error for each iteration. I still don't understand the nature of the compiler error regarding declaring the Error in the `foreach` call (I'm guessing it has something to do with calling a macro/function in the `block`?), but it works now. Please let me know if there's a better way to do it. I really value learning about these things.Thank you for your time, I appreciate it.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1030638772,2022-11-23T16:18:07Z,runtime/doc/lsp.txt,"@@ -1321,6 +1321,58 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()*       ��� {client_id}  (number)  +==============================================================================+Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens*++                                           *vim.lsp.semantic_tokens.on_attach()*","These will be overwritten by the docstrings in your implementation.Also, I don't think we should officially expose them. If you need to use them in other modules, that's ok, but we should still mark them as `---@private`. The idea is that nothing here is user-facing (although plugins may use the functions under a big, fat NO WARRANTY disclaimer).",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1030644762,2022-11-23T16:23:21Z,runtime/doc/lsp.txt,"@@ -1321,6 +1321,58 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()*       ��� {client_id}  (number)  +==============================================================================+Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens*++                                           *vim.lsp.semantic_tokens.on_attach()*","I just fixed the docstring generation stuff. I can mark everything private if we want, but I did want to revisit how much is actually hidden. We want _some_ sort of documentation for how to disable semantic token highlighting if someone doesn't want it. And force_refresh() is something we should probably expose and create as a public API from day one. If there's no way to ""fix"" an unforeseen issue this will provide a way to clear the state and re-request.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1030654341,2022-11-23T16:30:06Z,runtime/doc/lsp.txt,"@@ -1321,6 +1321,58 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()*       ��� {client_id}  (number)  +==============================================================================+Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens*++                                           *vim.lsp.semantic_tokens.on_attach()*","Yes, we should document semantic tokens (including how to disable it), but that can be done in the static part of `lsp.txt`; doesn't have to be via the generated module documentation.If that is the only way to refresh tokens (i.e., `<ctrl-l>`, `:redraw` or `:e` doesn't work), then we indeed should expose the refresh method -- although it's probably even better to hook this into the standard ""refresh"" code.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1030725024,2022-11-23T17:36:00Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,522 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+--- @field offset_encoding ""utf-8""|""utf-16""|""utf-32""+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(client, bufnr, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+        offset_encoding = client.offset_encoding,+      }+    end+  end++  return ranges+end++---@private+---@param client_id number+---@param bufnr number+---@return nil|STState+---@return nil|STBufferState+local function get_state(client_id, bufnr)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`++---This function will parse the semantic token responses and set up the cache+---(current_result). It also performs document synchronization by checking the+---version of the document associated with the resulting request_id and only+---performing work if the response is not out-of-date.+---+---Delta edits are applied if necessary, and new highlight ranges are calculated+---and stored in the buffer state.+---+---Finally, a redraw command is issued to force nvim to redraw the screen to+---pick up changed highlight tokens.+--+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(client.id, ctx.bufnr)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.request_id ~= buf_state.active_request.request_id then+    return+  end++  -- reset active request+  local response_version = buf_state.active_request.version+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = response_version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(client, ctx.bufnr, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+--- The LSP spec doesn't provide the document version used for the tokens in the+--- response, so we have to track that manually. This function will return early+--- if there is an already an active request in flight for the same version. If+--- there is a stale request in flight, that is cancelled prior to sending a new+--- one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param client table+---@param bufnr number+local function request_all_tokens(client, bufnr)+  local _, buf_state = get_state(client.id, bufnr)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(client, bufnr)+  local state, buf_state = get_state(client.id, bufnr)+  if not state or not buf_state then+    return+  end++  -- Only reset the version. This will force the next token request to be sent+  -- (even if the document version hasn't changed) and won't add new+  -- highlights, but will allow us to still send a delta request for servers+  -- that support them.+  buf_state.current_result.version = nil++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+--- see: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(client, bufnr)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(client, bufnr)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(client.id, bufnr)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_add_highlight(+            bufnr,+            state.namespace,+            '@' .. token.type,+            token.line,+            token.start_col,+            token.end_col+          )+          token.extmark_added = true+        end++        --TODO(jdrouhard): do something with the modifiers+      end+    end+  end+end++local M = {}++--- Start the semantic token highlighting engine for the given buffer with the+--- given client.+---+--- NOTE: This is currently called automatically by |buf_attach_client|. To+--- opt-out of semantic highlighting with a server that supports it, you can+--- delete the semanticTokensProvider table from the {server_capabilities} of+--- your client in your |LspAttach| callback or your configuration's+--- `on_attach` callback.+---+--- <pre>+---    client.server_capabilities.semanticTokensProvider = nil",```suggestion--- <pre>---  client.server_capabilities.semanticTokensProvider = nil```,
7416158,craigmac,https://api.github.com/repos/neovim/neovim/pulls/21137,1030789289,2022-11-23T18:58:12Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,392 @@+*lua-guide.txt*	Nvim++			    NVIM REFERENCE MANUAL++			  Guide to using Lua in Nvim+++This chapter will give you the basics of using Lua in Neovim.++				       Type |gO| to see the table of contents.++==============================================================================+Introduction							     *lua-guide*++------------------------------------------------------------------------------+Api vs Lua api++Before diving into how to use Lua in Neovim, it's important to first+understand the distinction between the different api's as they drive a lot of+the design decisions.++Neovim has two api's, we call these the ""api"" and the ""lua api"". You may think+of these as two different groups of functions. The api functions, which are+the function listed in |api.txt|, are bound by a so called |api-contract|. The+""Lua api"" functions, listed in |lua.txt|, have no such contract.","```suggestion""Lua API"" functions, listed in |lua.txt|, have no such contract.```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21137,1031400097,2022-11-24T11:24:09Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,311 @@+*lua-guide.txt*	Nvim++			    NVIM REFERENCE MANUAL++			  Guide to using Lua in Nvim+++This chapter will give you the basics of using Lua in Neovim.++				       Type |gO| to see the table of contents.++==============================================================================+Introduction							     *lua-guide*++TODO: Clarify this isn't a guide on the Lua language itself, this is+additional Lua libraries and functions Neovim provides on top of the Lua+language. For an introduction to Lua itself, refer to |luaref|.++------------------------------------------------------------------------------+Nvim API vs Lua API++Before diving into how to use Lua in Neovim, it's important to first+understand the distinction between the different APIs as they drive a lot of+the design decisions.++Neovim has two APIs, we call these the ""Nvim API"" (or just ""API"") and the ""Lua+API"". You may think of these as two different groups of functions. The API+functions, which are the function listed in |api.txt|, are bound by a so+called |api-contract|. The Lua API functions, listed in |lua.txt|, have no+such contract.++The |api-contract| is just a formal way of saying ""these functions are stable+and expected to work for a very long time"". Plugin authors and users can+expect anything they write with these functions to work for a long time.++This stability and rigidity comes at a cost however. Not only does it make it+near impossible to improve previous design decisions as it would break the+contract, it may also lead to overly abstract functions for the more common+use cases.++The solution for this is the Lua API. It has no contract, which means that we+are free to improve and fix previous design blunders. These functions are+typically higher-level functions with simpler syntax and saner defaults. Often+times these are simply wrappers over the API functions meant for casual usage.++By combining these two approaches, we are able to provide the stability plugin+authors require with the API as well as provide the improvements and the+simplicity the casual user wishes for with the Lua API. There is of course+nothing wrong with plugin authors using the Lua API nor casual users using the+API, the important part is that they're aware of the tradeoff.++This guide will primarily focus on using the Lua API functions if possible, as+they tend to be more convenient and more accessible. Not all API functions+have a Lua API equivalent wrapper. This means you'll need to use the API for+these cases.++==============================================================================+Using Lua from Neovim+TODO: write++You can use `:lua` to run Lua code. >lua++	:lua print(""Hello!"")++You can also use `:lua=`, which is same as `:lua print(vim.inspect(expr))`, to+conveniently check the value of a variable or a table. >lua++	:lua= package++- Mention heredocs?+- putting Lua files in rtp+- :source vs. :luafile vs. require++==============================================================================+Calling Vim script from Lua+TODO: write++- vim.cmd+- vim.fn+- vim.api++==============================================================================+Setting variables++The most convenient way to set vim variables is to use the `vim.*` wrappers:++- |vim.g|   - global variables (|g:|)+- |vim.b|   - buffer variables (|b:|)+- |vim.w|   - window variables (|w:|)+- |vim.t|   - tabpage variables (|t:|)+- |vim.v|   - predefined Vim variables (|v:|)+- |vim.env| - environment variables >lua++	vim.g.some_global_variable = {+	    key1 = 'value',+	    key2 = 300+	}++	print(vim.inspect(vim.g.some_global_variable)) -- { key1 = ""value"", key2 = 300 }++	-- target a specific buffer/window/tabpage+	vim.b[2].myvar = 1++Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using this syntax:+`vim.g['my#variable']`.++To delete one of these variables, simply assign `nil` to it: >lua++	vim.g.some_global_variable = nil++See also:+- |lua-vim-variables|++==============================================================================+Setting options++The simplest way to set options is to use the `vim.*o` and `vim.opt*` Lua API+wrappers. These are wrappers for the API functions described in |api-options|.++------------------------------------------------------------------------------+vim.*o++These wrappers allow you to manipulate options as if they were variables:++- |vim.o|  - behaves like |:set|+- |vim.go| - behaves like |:setglobal|+- |vim.bo| - behaves like |:setlocal| for buffer-local options+- |vim.wo| - behaves like |:setlocal| for window-local options >lua++	vim.o.smarttab = false -- :set nosmarttab+	print(vim.o.smarttab) -- false+	vim.o.isfname = vim.o.isfname .. ',@-@' -- on Linux: :set isfname+=@-@+	print(vim.o.isfname) -- '@,48-57,/,.,-,_,+,,,#,$,%,~,=,@-@'++	vim.bo.shiftwidth = 4+	print(vim.bo.shiftwidth) -- 4++You can specify a buffer or window number for buffer-local and window-local+options. If no number is given, the current buffer/window is used: >lua++	vim.bo[4].expandtab = true -- sets expandtab to true in buffer 4+	vim.wo.number = true -- sets number to true in current window++------------------------------------------------------------------------------+vim.opt*++These wrappers are a more programmatic way to set options which are more suited+for plugin authors.++- |vim.opt|: behaves like |:set|+- |vim.opt_global|: behaves like |:setglobal|+- |vim.opt_local|: behaves like |:setlocal| >lua++	vim.opt.smarttab = false+	print(vim.opt.smarttab:get()) -- false++Some options can be set using Lua tables: >lua++	vim.opt.completeopt = {'menuone', 'noselect'}+	print(vim.inspect(vim.opt.completeopt:get())) -- { ""menuone"", ""noselect"" }++Wrappers for list-like, map-like and set-like options also come with methods+and metamethods that work similarly to their |:set+=|, |:set^=| and |:set-=|+counterparts in Vim script. >lua++	vim.opt.shortmess:append({ I = true })+	-- alternative form:+	vim.opt.shortmess = vim.opt.shortmess + { I = true }++	vim.opt.whichwrap:remove({ 'b', 's' })+	-- alternative form:+	vim.opt.whichwrap = vim.opt.whichwrap - { 'b', 's' }++Be sure to look at |vim.opt| for more information.++==============================================================================+Defining mappings++Neovim provides two functions to set and delete mappings, |vim.keymap.set()|+and |vim.keymap.del()|.++vim.keymap.set()+-------------------------------------------------------------------------------++|vim.keymap.set()| is a convenience function of API functions+vim.api.|nvim_set_keymap()| and vim.api.|nvim_buf_set_keymap()|++The first argument is a string or a table of strings containing the mode+prefix for which the mapping will take effect: >lua++	-- Normal mode+	vim.keymap.set('n', '<Leader>ex1', '<Cmd>lua vim.notify(""Example 1"")<CR>')+	-- Normal and Command-line mode+	vim.keymap.set({'n', 'c'}, '<Leader>ex2', '<Cmd>lua vim.notify(""Example 2"")<CR>')++The prefixes are the ones listed in |:map-arguments|, as well as ""!"" and and+empty string """":++| String value           | Help page     | Affected modes                           | Vim script equivalent |+| ---------------------- | ------------- | ---------------------------------------- | --------------------- |+| """" (empty string)      | |mapmode-nvo|   | Normal, Visual, Select, Operator-pending | |:map|                  |+| `""n""`                    | |mapmode-n|     | Normal                                   | |:nmap|                 |+| `""v""`                    | |mapmode-v|     | Visual and Select                        | |:vmap|                 |+| `""s""`                    | |mapmode-s|     | Select                                   | |:smap|                 |+| `""x""`                    | |mapmode-x|     | Visual                                   | |:xmap|                 |+| `""o""`                    | |mapmode-o|     | Operator-pending                         | |:omap|                 |+| `""!""`                    | |mapmode-ic|    | Insert and Command-line                  | |:map!|                 |+| `""i""`                    | |mapmode-i|     | Insert                                   | |:imap|                 |+| `""l""`                    | |mapmode-l|     | Insert, Command-line, Lang-Arg           | |:lmap|                 |+| `""c""`                    | |mapmode-c|     | Command-line                             | |:cmap|                 |+| `""t""`                    | |mapmode-t|     | Terminal                                 | |:tmap|                 |",Do we want to duplicate Vim manual information? I'd say focus on the Lua specifics and link to the corresponding Vim help for basic information. (I don't think the goal is to give an introduction to Vim _and_ Neovim's Lua at the same time.),
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21137,1031405372,2022-11-24T11:30:10Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,311 @@+*lua-guide.txt*	Nvim++			    NVIM REFERENCE MANUAL++			  Guide to using Lua in Nvim+++This chapter will give you the basics of using Lua in Neovim.++				       Type |gO| to see the table of contents.++==============================================================================+Introduction							     *lua-guide*++TODO: Clarify this isn't a guide on the Lua language itself, this is+additional Lua libraries and functions Neovim provides on top of the Lua+language. For an introduction to Lua itself, refer to |luaref|.++------------------------------------------------------------------------------+Nvim API vs Lua API++Before diving into how to use Lua in Neovim, it's important to first+understand the distinction between the different APIs as they drive a lot of+the design decisions.++Neovim has two APIs, we call these the ""Nvim API"" (or just ""API"") and the ""Lua+API"". You may think of these as two different groups of functions. The API+functions, which are the function listed in |api.txt|, are bound by a so+called |api-contract|. The Lua API functions, listed in |lua.txt|, have no+such contract.++The |api-contract| is just a formal way of saying ""these functions are stable+and expected to work for a very long time"". Plugin authors and users can+expect anything they write with these functions to work for a long time.++This stability and rigidity comes at a cost however. Not only does it make it+near impossible to improve previous design decisions as it would break the+contract, it may also lead to overly abstract functions for the more common+use cases.++The solution for this is the Lua API. It has no contract, which means that we+are free to improve and fix previous design blunders. These functions are+typically higher-level functions with simpler syntax and saner defaults. Often+times these are simply wrappers over the API functions meant for casual usage.++By combining these two approaches, we are able to provide the stability plugin+authors require with the API as well as provide the improvements and the+simplicity the casual user wishes for with the Lua API. There is of course+nothing wrong with plugin authors using the Lua API nor casual users using the+API, the important part is that they're aware of the tradeoff.++This guide will primarily focus on using the Lua API functions if possible, as+they tend to be more convenient and more accessible. Not all API functions+have a Lua API equivalent wrapper. This means you'll need to use the API for+these cases.++==============================================================================+Using Lua from Neovim+TODO: write++You can use `:lua` to run Lua code. >lua++	:lua print(""Hello!"")++You can also use `:lua=`, which is same as `:lua print(vim.inspect(expr))`, to+conveniently check the value of a variable or a table. >lua++	:lua= package++- Mention heredocs?+- putting Lua files in rtp+- :source vs. :luafile vs. require++==============================================================================+Calling Vim script from Lua+TODO: write++- vim.cmd+- vim.fn+- vim.api++==============================================================================+Setting variables++The most convenient way to set vim variables is to use the `vim.*` wrappers:++- |vim.g|   - global variables (|g:|)+- |vim.b|   - buffer variables (|b:|)+- |vim.w|   - window variables (|w:|)+- |vim.t|   - tabpage variables (|t:|)+- |vim.v|   - predefined Vim variables (|v:|)+- |vim.env| - environment variables >lua++	vim.g.some_global_variable = {+	    key1 = 'value',+	    key2 = 300+	}++	print(vim.inspect(vim.g.some_global_variable)) -- { key1 = ""value"", key2 = 300 }++	-- target a specific buffer/window/tabpage+	vim.b[2].myvar = 1++Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using this syntax:+`vim.g['my#variable']`.++To delete one of these variables, simply assign `nil` to it: >lua++	vim.g.some_global_variable = nil++See also:+- |lua-vim-variables|++==============================================================================+Setting options++The simplest way to set options is to use the `vim.*o` and `vim.opt*` Lua API+wrappers. These are wrappers for the API functions described in |api-options|.++------------------------------------------------------------------------------+vim.*o++These wrappers allow you to manipulate options as if they were variables:++- |vim.o|  - behaves like |:set|+- |vim.go| - behaves like |:setglobal|+- |vim.bo| - behaves like |:setlocal| for buffer-local options+- |vim.wo| - behaves like |:setlocal| for window-local options >lua++	vim.o.smarttab = false -- :set nosmarttab+	print(vim.o.smarttab) -- false+	vim.o.isfname = vim.o.isfname .. ',@-@' -- on Linux: :set isfname+=@-@+	print(vim.o.isfname) -- '@,48-57,/,.,-,_,+,,,#,$,%,~,=,@-@'++	vim.bo.shiftwidth = 4+	print(vim.bo.shiftwidth) -- 4++You can specify a buffer or window number for buffer-local and window-local+options. If no number is given, the current buffer/window is used: >lua++	vim.bo[4].expandtab = true -- sets expandtab to true in buffer 4+	vim.wo.number = true -- sets number to true in current window++------------------------------------------------------------------------------+vim.opt*++These wrappers are a more programmatic way to set options which are more suited+for plugin authors.++- |vim.opt|: behaves like |:set|+- |vim.opt_global|: behaves like |:setglobal|+- |vim.opt_local|: behaves like |:setlocal| >lua++	vim.opt.smarttab = false+	print(vim.opt.smarttab:get()) -- false++Some options can be set using Lua tables: >lua++	vim.opt.completeopt = {'menuone', 'noselect'}+	print(vim.inspect(vim.opt.completeopt:get())) -- { ""menuone"", ""noselect"" }++Wrappers for list-like, map-like and set-like options also come with methods+and metamethods that work similarly to their |:set+=|, |:set^=| and |:set-=|+counterparts in Vim script. >lua++	vim.opt.shortmess:append({ I = true })+	-- alternative form:+	vim.opt.shortmess = vim.opt.shortmess + { I = true }++	vim.opt.whichwrap:remove({ 'b', 's' })+	-- alternative form:+	vim.opt.whichwrap = vim.opt.whichwrap - { 'b', 's' }++Be sure to look at |vim.opt| for more information.++==============================================================================+Defining mappings++Neovim provides two functions to set and delete mappings, |vim.keymap.set()|+and |vim.keymap.del()|.++vim.keymap.set()+-------------------------------------------------------------------------------++|vim.keymap.set()| is a convenience function of API functions+vim.api.|nvim_set_keymap()| and vim.api.|nvim_buf_set_keymap()|++The first argument is a string or a table of strings containing the mode+prefix for which the mapping will take effect: >lua++	-- Normal mode+	vim.keymap.set('n', '<Leader>ex1', '<Cmd>lua vim.notify(""Example 1"")<CR>')+	-- Normal and Command-line mode+	vim.keymap.set({'n', 'c'}, '<Leader>ex2', '<Cmd>lua vim.notify(""Example 2"")<CR>')++The prefixes are the ones listed in |:map-arguments|, as well as ""!"" and and+empty string """":++| String value           | Help page     | Affected modes                           | Vim script equivalent |+| ---------------------- | ------------- | ---------------------------------------- | --------------------- |+| """" (empty string)      | |mapmode-nvo|   | Normal, Visual, Select, Operator-pending | |:map|                  |+| `""n""`                    | |mapmode-n|     | Normal                                   | |:nmap|                 |+| `""v""`                    | |mapmode-v|     | Visual and Select                        | |:vmap|                 |+| `""s""`                    | |mapmode-s|     | Select                                   | |:smap|                 |+| `""x""`                    | |mapmode-x|     | Visual                                   | |:xmap|                 |+| `""o""`                    | |mapmode-o|     | Operator-pending                         | |:omap|                 |+| `""!""`                    | |mapmode-ic|    | Insert and Command-line                  | |:map!|                 |+| `""i""`                    | |mapmode-i|     | Insert                                   | |:imap|                 |+| `""l""`                    | |mapmode-l|     | Insert, Command-line, Lang-Arg           | |:lmap|                 |+| `""c""`                    | |mapmode-c|     | Command-line                             | |:cmap|                 |+| `""t""`                    | |mapmode-t|     | Terminal                                 | |:tmap|                 |","Yeah, was thinking this table is a bit much but decided last minute to not remove it. Will a simple""The prefixes are the ones listed in |:map-modes|, or ""!"" for |:map!|, or empty string for |:map|.""suffice?",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21174,1031416202,2022-11-24T11:42:47Z,runtime/lua/vim/filetype/detect.lua,"@@ -1172,7 +1172,8 @@ function M.sh(path, contents, name)       vim.b[b].is_kornshell = nil       vim.b[b].is_sh = nil     end-  elseif matchregex(name, [[\<sh\>]]) then+    -- Ubuntu links sh to dash","(And I don't think the Vim comment contains any more information; it is just longer. We port the logic, not the code.)",X
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21180,1031562119,2022-11-24T14:17:40Z,.github/labeler.yml,"@@ -63,3 +63,4 @@  ""filetype"":   - runtime/lua/vim/filetype.lua+  - runtime/lua/vim/filetype/detect.lua",Slight nitpick: could also use `runtime/lua/vim/filetype/*` if we anticipate more files in the future.,
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1031694539,2022-11-24T16:36:19Z,runtime/doc/lsp.txt,"@@ -1321,6 +1321,51 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()*       ��� {client_id}  (number)  +==============================================================================+Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens*++                                     *vim.lsp.semantic_tokens.force_refresh()*+force_refresh({bufnr}, {client_id})+    Force a refresh of all semantic tokens++    Only has an effect if the buffer is currently active for semantic token+    highlighting (attach_client() has been called for it)++    Parameters: ~+      ��� {bufnr}      (nil|number) default: current buffer+      ��� {client_id}  (nil|number) default: all attached LSP clients++start({bufnr}, {client_id})                  *vim.lsp.semantic_tokens.start()*+    Start the semantic token highlighting engine for the given buffer with the+    given client.++    NOTE: This is currently called automatically by |buf_attach_client|. To+    opt-out of semantic highlighting with a server that supports it, you can+    delete the semanticTokensProvider table from the {server_capabilities} of+    your client in your |LspAttach| callback or your configuration's+    `on_attach` callback.","This feature (semantic token highlighting) could very easily be opt-in instead of opt-out. API-wise, this now matches the way tree sitter works (start/stop methods) and seems like something that is safe to expose publicly from the beginning.Making it opt in would simplify some of the changes in lsp.lua and wouldn't require a ""hack"" to disable it if someone doesn't want it. The explicit calls to start and stop in the lsp module could just disappear.Opt-in is easy:```luaapi.nvim_create_autocmd('LspAttach', {    group = ...,    callback = function(args) {        vim.lsp.semantic_tokens.start(args.bufnr, args.data.client_id)    }})```When the client detaches from the buffer, the semantic token engine will automatically detach itself as well (the check in the `on_lines` callback), so this is all anyone would need in their config to enable it.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1031701087,2022-11-24T16:45:30Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,573 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_add_highlight(+            bufnr,+            state.namespace,+            '@' .. token.type,+            token.line,+            token.start_col,+            token.end_col+          )+          token.extmark_added = true+        end++        --TODO(jdrouhard): do something with the modifiers+      end+    end+  end+end++local M = {}++--- Start the semantic token highlighting engine for the given buffer with the+--- given client.+---+--- NOTE: This is currently called automatically by |buf_attach_client|. To+--- opt-out of semantic highlighting with a server that supports it, you can+--- delete the semanticTokensProvider table from the {server_capabilities} of+--- your client in your |LspAttach| callback or your configuration's+--- `on_attach` callback.+---+--- <pre>+--- client.server_capabilities.semanticTokensProvider = nil+--- </pre>+---+---@param bufnr number+---@param client_id number+function M.start(bufnr, client_id)+  vim.validate({+    bufnr = { bufnr, 'n', false },+    client_id = { client_id, 'n', false }+  })++  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    vim.notify(""No LSP server configured with client_id "" .. client_id)+    return+  end+  if not vim.tbl_get(client.server_capabilities, 'semanticTokensProvider', 'full') then+    vim.notify('Language server does not support semantic tokens')+    return+  end++  active_buffers[bufnr] = true+  local state = state_by_client[client_id]+  if not state then+    state = {+      buffers = {},+      namespace = api.nvim_create_namespace('vim_lsp_semantic_tokens:' .. client_id)+    }+    state_by_client[client_id] = state+  end++  local buf_state = {+    current_result = {},+    active_request = {},+  }+  state.buffers[bufnr] = buf_state++  api.nvim_buf_attach(bufnr, false, {+    on_lines = function()+      -- detach if the LSP client detached from this buffer or on_detach() was+      -- called manually+      local s, bs = get_state(bufnr, client_id)+      if not s or not bs or not vim.lsp.buf_is_attached(bufnr, client_id) then+        return true+      end+    end,+    on_reload = function()+      api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+      reset_buf_state(bufnr, client, true)+      request_all_tokens(bufnr, client_id)+    end,+    on_detach = function()+      M.stop(bufnr, client_id)+    end,+  })++  -- Add a BufWinEnter event to re-highlight buffers whose state was reset+  -- without a document version change, such as after receiving a refresh+  -- request from the server while the buffer was hidden+  local augroup_str = ('vim_lsp_c_%d_b_%d_semantic_tokens'):format(client_id, bufnr)+  local augroup = api.nvim_create_augroup(augroup_str, { clear = true })+  api.nvim_create_autocmd({ 'BufWinEnter' }, {+    buffer = bufnr,+    group = augroup,+    callback = function()+      request_all_tokens(bufnr, client_id)+    end,+  })++  request_all_tokens(bufnr, client_id)+end++--- Stop the semantic token highlighting engine for the given buffer with the+--- given client.+---+--- NOTE: This is currently called automatically by |buf_detach_client|. You+--- shouldn't need to call this function manually if semantic highlighting was+--- started automatically by |buf_attach_client|.+---+---@param bufnr number+---@param client_id number+function M.stop(bufnr, client_id)+  vim.validate({+    bufnr = { bufnr, 'n', false },+    client_id = { client_id, 'n', false }+  })++  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local state, buf_state = get_state(bufnr, client_id)+  if not state or not buf_state then+    return+  end++  api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+  reset_buf_state(bufnr, client, false)++  state.buffers[bufnr] = nil+  if #state.buffers == 0 then+    state_by_client[client_id] = nil+  end++  for _, test in pairs(vim.lsp.buf_get_clients(bufnr)) do+    if client_id ~= test.id then+      return+    end+  end+  active_buffers[bufnr] = nil+end++--- Used by the `textDocument/didChange` handler to notify the semantic token+--- highlighting engine that a change was sent to the LSP server. Currently it+--- will just send new request for semantic tokens to the server.+---+---@private+---@param bufnr number+---@param client_id number+function M.on_did_change(bufnr, client_id)+  -- TODO: we want to keep as much of this API private as possible, but the main+  -- lsp module needs access in its send_changes() function to be able to request+  -- tokens on a buffer sync event. The alternative is to set up our own debounce+  -- timer attached to on_lines, or wait for #15275.","This is the other part I'm not 100% sure on. Two things about this I'm not a huge fan of:1. Requires a callback when the `textDocument/didChange` notification is sent. #15275 would ""fix"" this and no longer require a special call to the semantic token module inside the `send_changes()` call in the main lsp module. This also means we have to have an API function accessible outside this module that sends the semantic tokens request.2. Sending a semantic tokens request for every didChange notification can be excessive.I allude to it in the TODO here, but we can do this a couple different ways.1. We can manage our own debounce timer that we can start in `on_lines`. I have an alternate branch that does this and it works well. We'd need a configuration option (per client? take it from cursor hold? not sure) for the actual debounce time. If we did this, I might also add a new autocmd for `InsertLeave` that cancels the timer and sends the request immediately.2. We can add more autocmd hooks for things like `CursorHold`, `CursorHoldI`, etc and not worry about timers at all. This is a bit less flexible and could cause more delay than actually necessary in getting new tokens.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/21100,1031740292,2022-11-24T17:40:28Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,577 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++local priority = 125++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_set_extmark(+            bufnr,+            state.namespace,+            token.line,+            token.start_col, {+              hl_group = '@' .. token.type,",`@` were introduced for tree-sitter with some magic to support fallback with scopes. Would it make sense to add a different kind of magic highlight groups that is different from the tree-sitter ones and that might take into account token modifiers. Maybe similar to https://vscode-westeu.azurewebsites.net/api/language-extensions/semantic-highlight-guide#semantic-coloring-in-color-themes > `variable.readonly:java` is called a selector and has the form `(*|tokenType)(.tokenModifier)*(:tokenLanguage)?`this could also be realized using the `@` fallbacks.It might be easier for users to tell that `Type` probably comes from `syntax`. `@type.lua` probably from tree-sitter and maybe something new for Lsp (`#variable.readonly.java`)? This might enable the user to map LSP highlighting only for certain things were they expect that tree-sitter/syntax is insufficient (though the default could of course be to set default for all built-in tokens),
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1031741745,2022-11-24T17:43:05Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,577 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++local priority = 125++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_set_extmark(+            bufnr,+            state.namespace,+            token.line,+            token.start_col, {+              hl_group = '@' .. token.type,","No. We don't want to add yet a third type of highlight names. In particular, we _want_ to use the same highlight groups as for treesitter for tokens of the same name.(And yes, one way of realizing modifiers similar to how VS Code does it is to support globs in highlight groups like `@foo.*.baz`, but I don't know if that's possible -- @bfredl ?)",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/21100,1031764816,2022-11-24T18:26:20Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,577 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++local priority = 125++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_set_extmark(+            bufnr,+            state.namespace,+            token.line,+            token.start_col, {+              hl_group = '@' .. token.type,",@clason VSCode does not support globs. The star just stands for having arbitrary modifiers in you mapping. E.g. `variable.readonly.global` matches a token of type `variable` with modifiers `readonly` and `global`. When the token is variable and has at least the two modifiers. VScode uses this notation just in configuration tables (or just consider token type for now). Neovim could do the same and then just use built-in highlight groups like `Type`. I was just confused why `@` was chosen. `@` from captures and names from LSP are two completely different sources and the same name might have different meanings. I would expect them to be mapped independently form each other. Color schemes would need to consider a union of tree-sitter captures and LSP token types. We could then at least provide a list of that union as the `@` groups that have a default mapping in built-in Nvim. So the planned the default experience with semantic token is that only the groups that have the same name as tree-sitter captures get a default mapping?,X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1031766571,2022-11-24T18:31:07Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,577 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++local priority = 125++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_set_extmark(+            bufnr,+            state.namespace,+            token.line,+            token.start_col, {+              hl_group = '@' .. token.type,","> @clason VSCode does not support globs. The star just stands for having arbitrary modifiers in you mapping.I know; what I'm saying is that globs is how _we_ would probably realize that.> I was just confused why @ was chosen. @ from captures and names from LSP are two completely different sources and the same name might have different meanings.No. They refer to the same basic structures. More names is just more confusion.> I would expect them to be mapped independently form each other. Why?> Color schemes would need to consider a union of tree-sitter captures and LSP token typesYes. Luckily the vast majority of tokens already exist as tree-sitter captures (with the same meaning).> So the planned the default experience with semantic token is that only the groups that have the same name as tree-sitter captures get a default mapping?Of course we'd add links for the missing semantic tokens.(And, again, we're not talking about modifiers yet in this PR.)",X
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1031770736,2022-11-24T18:41:46Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,577 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++local priority = 125++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_set_extmark(+            bufnr,+            state.namespace,+            token.line,+            token.start_col, {+              hl_group = '@' .. token.type,","To @theHamsta 's point, it does reduce flexibility by not having an LSP specific group in the mix.The original way I wanted to do this was what he's talking about--create hlgroups for each semantic token type and default link them to tree sitter highlight groups where it makes sense. Generally the meanings are the same but forcing them together without any possible way to configure them differently seems unnecessarily prohibitive.Doing this would give the same out of the box experience but gives more flexibility to colorscheme authors to tweak tree sitter and LSP toke s independently. If a colorscheme author doesn't care, the default links would still give semantic tokens meaningful highlights.However, this is something we can explore in a future PR, as this one doesn't actually introduce that many _new_ highlight groups that we may want to break later (`@typeParameter` and `@enumMember` are new, for example, but most tokens line up). ",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1031774456,2022-11-24T18:52:20Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,577 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++local priority = 125++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_set_extmark(+            bufnr,+            state.namespace,+            token.line,+            token.start_col, {+              hl_group = '@' .. token.type,","The most compelling reason is simply that we'll need some links anyway, because not all semantic token type names directly map to a tree sitter capture name. If we need some, then it's actually more maintenance burden (IMO) to determine which token types need mappings because there isn't a tree sitter capture with the same name, and which do. Just create special LSP ones for all of them and map them all to something or nothing.Again, future PR. Let's leave this one as is for now. ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1031776725,2022-11-24T18:57:59Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,577 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++local priority = 125++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_set_extmark(+            bufnr,+            state.namespace,+            token.line,+            token.start_col, {+              hl_group = '@' .. token.type,","> The most compelling reason is simply that we'll need some links anyway, because not all semantic token type names directly map to a tree sitter capture name. No, we already have links: `@function` links to `Function`. We'd just add the missing ones to that (even if nvim-treesitter doesn't use them -- yet). The whole point is that we do _not_ want to add another layer of indirection, where LSP highlights map to treesitter highlights map to default (Vim) highlights.",X
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/21100,1031850095,2022-11-24T21:24:32Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,577 @@+local api = vim.api+local util = require('vim.lsp.util')+local handlers = require('vim.lsp.handlers')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STBufferState+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult+---+--- @class STState+--- @field buffers table<number, STBufferState>+--- @field namespace number++---@private+---@type table<Client, STState>+local state_by_client = {}++---@private+---@type table<number, boolean>+local active_buffers = {}++local priority = 125++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+--+---@private+---@return STTokenRange[]+local function tokens_to_ranges(bufnr, client, data)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++---@private+---@param bufnr number+---@param client_id number+---@return nil|STState+---@return nil|STBufferState+local function get_state(bufnr, client_id)+  local state = state_by_client[client_id]+  if not state then+    return nil, nil+  end+  return state, state.buffers[bufnr]+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---+--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+local function on_full_response(err, response, ctx, _)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client or err or not response then+    return+  end++  local state, buf_state = get_state(ctx.bufnr, client.id)+  if not state or not buf_state then+    return+  end++  -- ignore stale responses+  if ctx.version ~= buf_state.active_request.version then+    return+  end++  -- reset active request+  buf_state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = buf_state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = buf_state.current_result+  current_result.version = ctx.version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(ctx.bufnr, client, tokens)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- This is the entry point for getting all the tokens in a buffer.+---+---+--- This function will return early if there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- If the server supports delta requests, that will be prioritized if we have a+--- previous requestId and token array.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+---@param bufnr number+---@param client_id number+local function request_all_tokens(bufnr, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    return+  end++  local _, buf_state = get_state(bufnr, client_id)+  if not buf_state then+    return+  end++  local current_result = buf_state.current_result+  local active_request = buf_state.active_request++  local version = util.buf_versions[bufnr]++  -- same version already has a request in flight+  if active_request.version == version then+    return+  end++  -- cancel stale in-flight request+  if active_request.request_id then+    client.cancel_request(active_request.request_id)+    active_request = {}+    buf_state.active_request = active_request+  end++  if current_result.version ~= version then+    local spec = client.server_capabilities.semanticTokensProvider.full+    local hasEditProvider = type(spec) == 'table' and spec.delta++    local params = { textDocument = util.make_text_document_params(bufnr) }+    local method = 'textDocument/semanticTokens/full'++    if hasEditProvider and current_result.result_id then+      method = 'textDocument/semanticTokens/full/delta'+      params.previousResultId = current_result.result_id+    end+    local success, request_id = client.request(method, params, on_full_response, bufnr)++    if success then+      active_request.request_id = request_id+      active_request.version = version+    end+  end+end++---@private+local function reset_buf_state(bufnr, client, keep_prev)+  local state, buf_state = get_state(bufnr, client.id)+  if not state or not buf_state then+    return+  end++  if keep_prev then+    -- Only reset the version. This will force the next token request to be sent+    -- (even if the document version hasn't changed) and won't add new+    -- highlights, but will allow us to still send a delta request for servers+    -- that support them.+    buf_state.current_result.version = nil+  else+    buf_state.current_result = {}+  end++  -- Cancel active requests if there's one in flight. It's out of date now that+  -- we've received a refresh request from the server.+  if buf_state.active_request.request_id then+    client.cancel_request(buf_state.active_request.request_id)+  end++  buf_state.active_request = {}+end++--- |lsp-handler| for the method `workspace/semanticTokens/refresh`+---+--- Refresh requests are sent by the server to indicate a project-wide change+--- that requires all tokens to be re-requested by the client. This handler will+--- invalidate the current results of all buffers and automatically kick off a+--- new request for buffers that are displayed in a window.+---+---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#semanticTokens_refreshRequest+handlers['workspace/semanticTokens/refresh'] = function(err, _, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local state = state_by_client[ctx.client_id]++  if not client or not state or err then+    return vim.NIL+  end++  for bufnr, _ in pairs(state.buffers) do+    reset_buf_state(bufnr, client, true)++    for _, win in ipairs(api.nvim_list_wins()) do+      if bufnr == api.nvim_win_get_buf(win) then+        request_all_tokens(bufnr, ctx.client_id)+        break+      end+    end+  end++  return vim.NIL+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+---If there is a current result for the buffer and the version matches the+---current document version, then the tokens are valid and can be applied. As+---the buffer is drawn, this function will add extmark highlights for every+---token in the range of visible lines. Once a highlight has been added, it+---sticks around until the document changes and there's a new set of matching+---highlight tokens available.+---+---If this is the first time a buffer is being drawn with a new set of+---highlights for the current document version, the namespace is cleared to+---remove extmarks from the last version. It's done here instead of the response+---handler to avoid the ""blink"" that occurs due to the timing between the+---response handler and the actual redraw.+---+---@private+local function do_win_highlight(_, _, bufnr, topline, botline)+  if not active_buffers[bufnr] then+    return false+  end++  for _, client in pairs(vim.lsp.buf_get_clients(bufnr)) do+    local state, buf_state = get_state(bufnr, client.id)++    if state and buf_state and buf_state.current_result.version == util.buf_versions[bufnr] then+      local current_result = buf_state.current_result+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          api.nvim_buf_set_extmark(+            bufnr,+            state.namespace,+            token.line,+            token.start_col, {+              hl_group = '@' .. token.type,","> If you feel very strongly about this, use @function.lsp (which falls back to @function). But again, let's cross that bridge when we get to it.This was the idea that I had first.  I had the feeling that it was less maintenance to not set nothing at all (or just have a simplistic mapping that can be overwritten). But probably just caring in the default experience for `@XXX` where `xxx` is already handled by tree-sitter mappings is not to bad. It doesn't have to be stable and people see something until someone convinces with something better.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21181,1032514111,2022-11-25T14:38:22Z,test/functional/core/startup_spec.lua,"@@ -576,6 +577,48 @@ describe('user config init', function()     eq(funcs.fnamemodify(init_lua_path, ':p'), eval('$MYVIMRC'))   end) ++  describe 'with existing .exrc in cwd'(function()+    local cwd = funcs.getcwd()+    local exrc_path = '.exrc'+    local xstate = 'Xstate'++    before_each(function()+      mkdir_p(xstate .. pathsep .. (is_os('win') and 'nvim-data' or 'nvim'))+      write_file(exrc_path, [[+        let g:from_exrc = 1+        ]])+    end)++    after_each(function()+      os.remove(exrc_path)+      rmdir(xstate)+    end)++    it('loads .exrc', function()+      clear{ args_rm = {'-u'}, env={ XDG_CONFIG_HOME=xconfig, XDG_STATE_HOME=xstate } }+      command('terminal nvim')+      local screen = Screen.new(80, 8)+      screen:attach()+      screen:expect{grid=string.format([[+        ^                                                                                |+                                                                                        |+                                                                                        |+                                                                                        |+                                                                                        |+        %s.exrc is not trusted.                             |",This depends on the path and can easily fail. If the path is too long it may also take multiple lines. You can use `any = ` and `helpers.pesc` in `screen:expect()` instead. There is an example in `test/functional/ex_cmds/swapfile_preserve_recover_spec.lua`.,
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1032695511,2022-11-25T21:52:48Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',","Would the command also be optional then? E.g. `trust(0)` would imply `allow`, but `trust('foo', 'deny'|'remove')` would require the command? Either way we'd still have to implement errors on calls such as `trust(0, 'deny')`/I slightly prefer separate functions, because then it's clear what's expected of you directly from the signature, while when having a single function, you need additional documentation. To @gpanders point of single `trust()` better conveying the message that this is the api to manage trust database, maybe `trust_allow`, `trust_remove` and `trust_deny`? ",X
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/21107,1032700132,2022-11-25T22:19:49Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',","I don't think the action/command should be optional, I'd keep everything explicit.- `:trust` calls `trust('allow', 0)`  Validate that it's not an unnamed buffer, and that there is a corresponding file on disk- `:trust ++deny` calls `trust('deny', 0)`  Buffer contents are ignored, just take the path of the current buffer- `:trust ++deny file.txt` calls `trust('deny', 'file.txt')`  The caveat with this is that we don't have any reliable way of expanding to absolute path if the file doesn't exist. Not a problem with `allow`, but it would be nice to just blacklist something even when there is nothing there yet. Maybe for now let's just do the buffers, and implement paths later on?- Same for `++forget`/`++remove`I'm personally okay with having multiple functions, that's why I thought a separate module would be better in the first place. I don't know about others.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1032714924,2022-11-26T00:15:03Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',",">I slightly prefer separate functions, because then it's clear what's expected of you directly from the signature, while when having a single function, you need additional documentation.True, but then you also have to document each function, and anything that is common among the three functions has to be documented three separate times.Using a single function also enables us to expand the interface in the future if we ever need to. Splitting it up into `allow`/`remove`/`deny` locks us into a less flexible position.My vote is to make `trust()` take a single table argument. This table can then accept `bufnr`, `path`, and `action`, and the combination of inputs can be validated.Examples:```lua-- OK, allows current buffervim.secure.trust({action = 'allow', bufnr = 0})-- Error, 'allow' only works on buffers (not files)vim.secure.trust({action = 'allow', path = ...})-- OK, remove the file of the current buffer from the trust databasevim.secure.trust({action = 'remove', bufnr = 0})-- OK, deny the given filevim.secure.trust({action = 'deny', path = ...})-- Error, bufnr and path are mutually exclusivevim.secure.trust({action = 'remove', bufnr = 0, path = ...})```I'd like to hear what @justinmk thinks as well.",X
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1032847063,2022-11-27T00:09:16Z,src/nvim/ex_cmds.c,"@@ -4960,3 +4961,27 @@ void ex_oldfiles(exarg_T *eap)     }   } }++void ex_trust(exarg_T *eap)+{+  char *p = skiptowhite(eap->arg);+  size_t len = (size_t)(p - eap->arg);+  char *arg1 = xcalloc(len + 1, sizeof(char));+  memcpy(arg1, eap->arg, len);++  char *errmsg;+  if (STRNCMP(arg1, ""++deny"", len) == 0) {","This is incomplete. I'm assuming `bufnr` for now, because I wanted to confirm how we want to handle distinguishing between `bufnr` and `path` arguments. I was thinking about the following:- if something is a string, then it's `path`- if something is a number, then it's `bufnr`- user can wrap the argument in quotes (e. g. `'0'`) to have it interpreted as a pathWould this be ok?",
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1032847225,2022-11-27T00:11:11Z,src/nvim/ex_cmds.lua,"@@ -2933,6 +2933,12 @@ module.cmds = {     addr_type='ADDR_OTHER',     func='ex_tag',   },+  {+    command='trust',",For now I implemented it as suggested by @gpanders in 2fe2e19ee005d228b89bad38ac711df37adbbdc3,
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1032847443,2022-11-27T00:13:52Z,runtime/doc/lua.txt,"@@ -2370,4 +2370,19 @@ read({path})                                               *vim.secure.read()*         (string|nil) The contents of the given file if it exists and is         trusted, or nil otherwise. +trust({path}, {mode})                                     *vim.secure.trust()*+    Update the trust status of file at {path} in the trust database at+    $XDG_STATE_HOME/nvim/trust.++    Parameters: ~+      ��� {path}  (string) Path to a file to update status for.+      ��� {mode}  (string) One of the following:+                ��� 'allow': Add file to trust database and set it as trusted+                ��� 'deny': Add file to trust database and set it as denied+                ��� 'forget': Remove file from trust database",Resolved in 2fe2e19ee005d228b89bad38ac711df37adbbdc3,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1032980467,2022-11-27T17:12:40Z,src/nvim/ex_cmds.c,"@@ -4960,3 +4961,27 @@ void ex_oldfiles(exarg_T *eap)     }   } }++void ex_trust(exarg_T *eap)+{+  char *p = skiptowhite(eap->arg);+  size_t len = (size_t)(p - eap->arg);+  char *arg1 = xcalloc(len + 1, sizeof(char));+  memcpy(arg1, eap->arg, len);++  char *errmsg;+  if (STRNCMP(arg1, ""++deny"", len) == 0) {","> This is incomplete. I'm assuming `bufnr` for now, because I wanted to confirm how we want to handle distinguishing between `bufnr` and `path` arguments. I was thinking about the following:> > * if something is a string, then it's `path`> * if something is a number, then it's `bufnr`> * user can wrap the argument in quotes (e. g. `'0'`) to have it interpreted as a path>   Would this be ok?This seems reasonable and matches other commands which take either a buffer number or name (e.g. `:bdelete`). Maybe take a peek at how that command handles this and see if we can re-use anything there.",
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1032994417,2022-11-27T19:00:40Z,src/nvim/ex_cmds.c,"@@ -4960,3 +4961,27 @@ void ex_oldfiles(exarg_T *eap)     }   } }++void ex_trust(exarg_T *eap)+{+  char *p = skiptowhite(eap->arg);+  size_t len = (size_t)(p - eap->arg);+  char *arg1 = xcalloc(len + 1, sizeof(char));+  memcpy(arg1, eap->arg, len);++  char *errmsg;+  if (STRNCMP(arg1, ""++deny"", len) == 0) {",You're right. My bad :) I'll leave lua function as is.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1033016970,2022-11-27T22:02:28Z,runtime/doc/editing.txt,"@@ -1651,3 +1651,21 @@ There are three different types of searching:    with depth limiter (/usr/**2) or upward search (;) notations.   vim:tw=78:ts=8:noet:ft=help:norl:++==============================================================================+11. Secure Files						*secure*++Secure Files are used to manage files that in a trust database, allowing+trusted files to be sourced via |exrc|.++							*:trust* *E5570*+:trust [++deny] [++remove] [{file}]+			Manage file in the trust database. Without any options,+			`:trust` will mark file associated with current buffer+			as trusted.+			`++deny` will mark a file as denied and you won't be+			asked if you wan't to source that file.+			`++remove` will remove the file from the trust database.+			`++deny` and `++remove` accept optional parameter+			`{file}`, that is path to the file to be denied or+			removed.","Writing this in GitHub's review UI, so you will need to re-wrap it to fit within 79 cols.```suggestion			Manage files in the trust database. Without any options or arguments,			`:trust` adds the file associated with the current buffer			to the trust database, along with the SHA256 hash of its contents.			`++deny` marks the file associated with the current buffer (or {file}, if given) as denied; no prompts will be displayed to the user and the file will never be executed.			`++remove` removes the file associated with the current buffer (or {file}, if given) from the trust database. Future attempts to read the file in a secure setting (i.e. with 'exrc' or |vim.secure.read()|) will prompt the user if the file is trusted.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1033017284,2022-11-27T22:04:42Z,runtime/lua/vim/secure.lua,"@@ -86,21 +109,79 @@ function M.read(path)     trust[fullpath] = hash   end -  do-    local f, err = io.open(vim.fn.stdpath('state') .. '/trust', 'w')-    if not f then-      error(err)+  write_trust(trust)++  return contents+end++--- Update the trust status of file at {path} in the trust database at+--- $XDG_STATE_HOME/nvim/trust.",```suggestion--- Manage the trust database.------ The trust database is located at |$XDG_STATE_HOME|/nvim/trust.```,
71319302,Jlll1,https://api.github.com/repos/neovim/neovim/pulls/21107,1033021335,2022-11-27T22:33:29Z,src/nvim/ex_cmds.c,"@@ -4960,3 +4961,54 @@ void ex_oldfiles(exarg_T *eap)     }   } }++void ex_trust(exarg_T *eap)+{+  char *p = skiptowhite(eap->arg);+  size_t len = (size_t)(p - eap->arg);+  char *arg1 = xmemdupz(eap->arg, len);++  bool success = false;+  bool action_allow = false, action_deny = false, action_remove = false;+  char *msg = NULL;++  if (len > 2 && STRNCMP(arg1, ""++deny"", len) == 0) {+    char *path = skipwhite(p);+    if (path[0] == '\0') {+      path = NULL;+    }+    success = nlua_trust(""deny"", path, &msg);+    action_deny = 1;+  } else if (len > 2 && STRNCMP(arg1, ""++remove"", len) == 0) {+    char *path = skipwhite(p);+    if (path[0] == '\0') {+      path = NULL;+    }+    success = nlua_trust(""remove"", path, &msg);+    action_remove = 1;+  } else {+    char *path = skipwhite(eap->arg);+    if (path[0] == '\0') {+      path = NULL;+    }+    success = nlua_trust(""allow"", path, &msg);+    action_allow = 1;+  }++  if (msg != NULL) {+    if (success) {+      if (action_allow) {+        smsg(""\""%s\"" trusted."", msg);+      } else if (action_deny) {+        smsg(""\""%s\"" denied."", msg);+      } else if (action_remove) {+        smsg(""\""%s\"" removed."", msg);+      }+    } else {+      semsg(e_trustfile, msg);+    }+  }","I was considering that but I wasn't sure if we wouldn't prefer to keep the wrapper ""pure"" by not having it print messages - I wasn't sure how big of a deal that was.Will update :)",
1973,will,https://api.github.com/repos/neovim/neovim/pulls/21210,1033033039,2022-11-27T23:50:07Z,CMakeLists.txt,"@@ -141,6 +141,12 @@ set(NVIM_VERSION_MAJOR 0) set(NVIM_VERSION_MINOR 9) set(NVIM_VERSION_PATCH 0) set(NVIM_VERSION_PRERELEASE ""-dev"") # for package maintainers+# Allow manually setting git tag for situations where `git describe` cannot+# work such as the nix flake.","I'm new to nix myself so I'm not fully sure. I fond the `self.shortRev or ""dirty""` pattern in the .nix file from searching how other people got git revs in their builds, so I mostly assumed it was not possible to run git commands, backed up by the calls presumably working in neovim's cmake scripts when it was in nix.I can guess at two reasons which would make `git describe` not work if either or perhaps both are true.1. The git command isn't being pulled into the environment in which the build is happening. If this is the case, then it might not be so bad to get it to work, ""just"" adding it to some list of tools to pull in. Though even that is currently beyond my nix knowledge. 2. The .git directory doesn't make it into the build environment. I could see a situation where maybe the nix functions that pull down the branch to wherever that happens only pulls the files in the branch and not the .git directory. It seems like they'd be going out of their way to do this, but it would also explain `git describe` not working. If this is the case, it would be a lot more work to fix than if it's just reason 1. It could of course be some other reason(s) too. Sorry I can't be of more help for this question.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/21107,1033036216,2022-11-28T00:09:08Z,src/nvim/ex_cmds.c,"@@ -4960,3 +4961,27 @@ void ex_oldfiles(exarg_T *eap)     }   } }++void ex_trust(exarg_T *eap)+{+  const char *const p = skiptowhite(eap->arg);+  char *arg1 = xmemdupz(eap->arg, (size_t)(p - eap->arg));+  const char *action = ""allow"";+  const char *path = eap->arg;++  if (strcmp(arg1, ""++deny"") == 0) {+    path = skipwhite(p);+    action = ""deny"";+  } else if (strcmp(arg1, ""++remove"") == 0) {+    path = skipwhite(p);+    action = ""remove"";+  }++  if (path[0] == '\0') {+    path = NULL;+  }++  nlua_trust(action, path);++  xfree(arg1);+}","More robust argument parsing, `++deny` and `++remove` are mutually exclusive, and it handles invalid or duplicate `++options`.Needs the `#include ""nvim/api/private/helpers.h""` header.@gpanders what do you think?```suggestionvoid ex_trust(exarg_T *eap){  bool deny = false;  bool remove = false;  struct {    String arg;    bool *flag;  } flags[] = {    { STATIC_CSTR_AS_STRING(""++deny""), &deny },    { STATIC_CSTR_AS_STRING(""++remove""), &remove },  };  const char *p = eap->arg;  while (p[0] != '\0' && (p[0] == '+' && p[1] == '+')) {    const char *s = p;    p = skiptowhite(p);    size_t len = (size_t)(p - s);    bool match = false;    for (size_t i = 0; i < ARRAY_SIZE(flags); i++) {      String arg = flags[i].arg;      bool *flag = flags[i].flag;      if (len == arg.size && strncmp(s, arg.data, arg.size) == 0) {        if (*flag) {          semsg(_(e_duparg2), arg.data);          return;        }        *flag = true;        match = true;      }    }    if (!match) {      semsg(_(e_invarg2), s);      return;    }    p = skipwhite(p);  }  if (deny && remove) {    emsg(_(e_invarg));  // TODO: a better error message. those are mutually exclusive    return;  }  nlua_trust(deny ? ""deny"" : remove ? ""remove"" : ""allow"", p[0] != '\0' ? p : NULL);}```",X
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1033695784,2022-11-28T15:34:43Z,runtime/doc/editing.txt,"@@ -1651,3 +1651,30 @@ There are three different types of searching:    with depth limiter (/usr/**2) or upward search (;) notations.   vim:tw=78:ts=8:noet:ft=help:norl:++==============================================================================+11. Trusted Files						*trust*++Nvim has the ability to execute arbitrary code through the 'exrc' option. In+order to prevent executing code from untrusted sources, Nvim has the concept of+""trusted files"". An untrusted file will not be executed without the user's+consent, and a user can permanently mark a file as trusted or untrusted using+the |:trust| command or the |vim.secure.read()| function.++							*:trust* *E5570*+:trust [++deny] [++remove] [{file}]++			Manage files in the trust database. Without any options+			or arguments+			`:trust` adds the file associated with the current+			buffer to the trust database, along with the SHA256+			hash of its contents.+			`++deny` marks the file associated with the current+			buffer (or {file}, if given) as denied; no prompts will+			be displayed to the user and the file will never be+			executed.+			`++remove` removes the file associated with the current+			buffer (or {file}, if given) from the trust database.+			Future attempts to read the file in a secure setting","This is my mistake.```suggestion			:trust adds the file associated with the current			buffer to the trust database, along with the SHA256			hash of its contents.			[++deny] marks the file associated with the current			buffer (or {file}, if given) as denied; no prompts will			be displayed to the user and the file will never be			executed.			[++remove] removes the file associated with the current			buffer (or {file}, if given) from the trust database.			Future attempts to read the file in a secure setting```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21107,1033790762,2022-11-28T16:49:41Z,runtime/doc/news.txt,"@@ -60,6 +60,9 @@ The following new APIs or features were added.    See https://github.com/neovim/neovim/pull/14537. +��� |vim.secure.trust()|, |:trust| allows the user to manage files in trust+  database.+","Move this to the top of the list, so far we've been adding features to news.txt in reverse-chronological order (newest features on top)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21137,1033839936,2022-11-28T17:32:54Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,714 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++This chapter will give you the basics of using Lua in Neovim.++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++Important thing to note is that this isn't a guide to the Lua language itself.+Rather, this is a guide on how to configure and modify Neovim through the Lua+language and the functions we provide to help with this. Take a look at+|luaref| and |lua-concepts| if you'd like to learn more about Lua itself.++------------------------------------------------------------------------------+Nvim API vs Lua API                                            *nvim-vs-lua-api*++Before diving into how to use Lua in Neovim, it's important to first+understand the distinction between the different APIs as they drive a lot of+the design decisions.++Neovim has two APIs, we call these the ""Nvim API"" (or just ""API"") and the ""Lua+API"". You may think of these as two different groups of functions. The API+functions, which are the functions listed in |api.txt|, are bound by a so+called |api-contract|. The Lua API functions, listed in |lua.txt|, have no+such contract.++The |api-contract| is just a formal way of saying ""these functions are stable+and expected to work for a very long time"". Plugin authors and users can+expect anything they write with these functions to work for a long time. All+of these functions start with `vim.api`.++This stability and rigidity comes at a cost however. Not only does it make it+near impossible to improve previous design decisions as it would break the+contract, it may also lead to overly abstract functions for the more common+use cases.++The solution for this is the Lua API. It has no contract, which means that we+are free to improve and fix previous design blunders. These functions are+typically higher-level functions with simpler syntax and saner defaults. Often+times these are simply wrappers over the API functions meant for casual usage.+All of these function start with `vim.*`, where `*` is not `""api""`.++By combining these two approaches, we are able to provide the stability plugin+authors require with the API as well as provide the improvements and+simplicity the casual user wishes for with the Lua API. There is of course+nothing wrong with casual users/non-plugin authors using API functions. Quite+the opposite: not all API functions have a Lua API equivalent. Either they+haven't been created yet or they simply aren't needed. A Lua API function is+only needed if it significantly simplifies using the API functions in some+aspect. Having a wrapper for the sake of it would only result in a bunch of+duplicate functions that does the same thing.++This guide will primarily focus on using the Lua API functions if possible, as+they tend to be more convenient and more accessible.++==============================================================================+Where to put your files++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |'runtimepath'|,+which is typically `~/.config/nvim` for unix-y systems and+`~/AppData/Local/nvim/` for Windows.++If you'd like to run any Lua or Vim script on startup automatically, then you+can simply put them in one of the following directories in your+|'runtimepath'|: `colors/`, `compiler/`, `ftplugin/`, `ftdetect/`, `indent/`,+`plugin/` and `syntax/`. If you're unsure where to put your script, then it+should probably be in `plugin/`.++See also:+��� |config|++------------------------------------------------------------------------------+Lua modules++Lua modules are basically standalone Lua scripts you can import. They should+be located in the `lua/` directory in you |'runtimepath'|. Let's assume you+have the following directory structure:++~/.config/nvim+|-- after/+|-- ftplugin/+|-- lua/+|  |-- myluamodule.lua+|  |-- other_modules/+|     |-- anothermodule.lua+|     |-- init.lua+|-- plugin/+|-- syntax/+|-- init.vim++The following Lua code will load myluamodule.lua: >lua++    require(""myluamodule"")++Notice the absence of a .lua extension.++Similarly, loading `other_modules/anothermodule.lua` is done like so: >lua++    require('other_modules.anothermodule')+    -- or+    require('other_modules/anothermodule')++Path separators are denoted by either a dot `.` or a slash `/`.++A folder containing an |init.lua| file can be required directly, without+having to specify the name of the file: >lua++    require('other_modules') -- loads other_modules/init.lua++Requiring a nonexistent module or a module which contains syntax errors aborts+the currently executing script. pcall() may be used to prevent errors. >lua++    local ok, _ = pcall(require, 'module_with_error')+    if not ok then+      -- not loaded+    end++See also:+��� |lua-require|++==============================================================================+Using Lua from Vim script++You can use the |:lua| command to run Lua code: >lua++    :lua print(""Hello!"")++You can also use `:lua=`, which is same as `:lua print(vim.inspect(expr))`, to+conveniently check the value of a variable or a table: >lua++    :lua= package++You may use so-called heredocs to write multi-line Lua code from Vim script:+>lua+    lua << EOF+        local tbl = {1, 2, 3}+        for k, v in ipairs(tbl) do+            print(v)+        end+    EOF++Note: each :lua command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work: >vim++    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""++You can use the |:source| command if you'd like to run an entire Lua script:+>lua+    :source ~/programs/baz/myluafile.lua++You may use both the Lua builtin |require()| or the Neovim command |:source|+to run an external script. |require()| will keep track of which modules you+have executed before, and won't run the script again if it's called. |:source|+on the other hand will always run the script regardless. Another difference is+that |require()| searches for modules in directories named `lua/` in your+|'runtimepath'|. |:source| on the other hand accepts any absolute or relative+path to the file. Choose the method you find most suitable to your situation.++See also:+��� |:lua-heredoc|++==============================================================================+Using Vim script from Lua+There are many ways to use Vim script from Lua. This section will present some+of those, which should be enough to cover the most basic usages.++------------------------------------------------------------------------------+Calling commands++To call a command from lua, use |vim.cmd()|. There are multiple ways to use+|vim.cmd()|. Take the following two commands as an example: >lua++    vim.cmd(""echo \""Hello World!\"""")+    vim.cmd([[echo ""Hello World!""]])++Both of these does the same thing: printing ""Hello World!"". The second form+(`[[]]`), the so called double bracketed strings, tends to be easier to use.+Take the following example, where both commands does the same thing: >lua++    vim.cmd(""%s/\\Vfoo/bar/g"")+    vim.cmd([[%s/\Vfoo/bar/g]])++Notice that in the first case we need an extra `\` to escape the backslash.++Another benefit of using double bracketed strings is that they support+multiline string. The following command is perfectly valid: >lua++    vim.cmd([[+        set ignorecase+        colorscheme tokyonight+    ]])++This is analogous to using Lua heredocs. It is entirely possible (except in+rare cases) to surround the contents of your `init.vim` with `vim.cmd([[]])`,+rename `init.vim` to `init.lua` and still have a working configuration. If you+wish to rewrite your configuration in Lua then this approach may be less+chaotic than a full rewrite from scratch as it allows you to incrementally+change your configuration.++There is also a third way to use |vim.cmd()|: >lua++    vim.cmd.echo(""\""Hello World!\"""")++This is essentially syntactic sugar of the non-bracketed string explained at+the start of this section.++------------------------------------------------------------------------------+Calling functions++Use |vim.fn| to call Vim script commands from Lua. Data types between Lua and+Vim script are automatically converted: >lua++    print(vim.fn.printf('Hello from %s', 'Lua'))++    local reversed_list = vim.fn.reverse({ 'a', 'b', 'c' })+    print(vim.inspect(reversed_list)) -- { ""c"", ""b"", ""a"" }++    local function print_stdout(chan_id, data, name)+        print(data[1])+    end++    vim.fn.jobstart('ls', { on_stdout = print_stdout })+    print(vim.fn.printf('Hello from %s', 'Lua'))++Hashes (`#`) are not valid characters for identifiers in Lua, so autoload+functions have to be called with this syntax: >lua++    vim.fn['my#autoload#function']()++------------------------------------------------------------------------------+See also++��� |builtin-functions| - alphabetic list of all Vim script functions+��� |function-list| - list of all Vim script functions grouped by topic++==============================================================================+Setting variables++The most convenient way to set vim variables is to use the `vim.*` wrappers:++��� |vim.g|   - global variables (|g:|)+��� |vim.b|   - buffer variables (|b:|)+��� |vim.w|   - window variables (|w:|)+��� |vim.t|   - tabpage variables (|t:|)+��� |vim.v|   - predefined Vim variables (|v:|)+��� |vim.env| - environment variables >lua++    vim.g.some_global_variable = {+        key1 = ""value"",+        key2 = 300+    }++    print(vim.inspect(vim.g.some_global_variable)) -- { key1 = ""value"", key2 = 300 }++    -- target a specific buffer/window/tabpage+    vim.b[2].myvar = 1++Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using this syntax:+`vim.g['my#variable']`.++To delete one of these variables, simply assign `nil` to it: >lua++    vim.g.some_global_variable = nil++See also:+- |lua-vim-variables|++==============================================================================+Setting options++The simplest way to set options is to use the `vim.*o` and `vim.opt*` Lua API+wrappers. These are wrappers for the API functions described in |api-options|.++------------------------------------------------------------------------------+vim.*o++These wrappers allow you to manipulate options as if they were variables:",Maybe draw the parallel here to `:let &option` in Vimscript? Or is that too advanced?,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21137,1033888706,2022-11-28T18:12:33Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,714 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++This chapter will give you the basics of using Lua in Neovim.++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++Important thing to note is that this isn't a guide to the Lua language itself.+Rather, this is a guide on how to configure and modify Neovim through the Lua+language and the functions we provide to help with this. Take a look at+|luaref| and |lua-concepts| if you'd like to learn more about Lua itself.++------------------------------------------------------------------------------+Nvim API vs Lua API                                            *nvim-vs-lua-api*++Before diving into how to use Lua in Neovim, it's important to first+understand the distinction between the different APIs as they drive a lot of+the design decisions.++Neovim has two APIs, we call these the ""Nvim API"" (or just ""API"") and the ""Lua+API"". You may think of these as two different groups of functions. The API+functions, which are the functions listed in |api.txt|, are bound by a so+called |api-contract|. The Lua API functions, listed in |lua.txt|, have no+such contract.++The |api-contract| is just a formal way of saying ""these functions are stable+and expected to work for a very long time"". Plugin authors and users can+expect anything they write with these functions to work for a long time. All+of these functions start with `vim.api`.++This stability and rigidity comes at a cost however. Not only does it make it+near impossible to improve previous design decisions as it would break the+contract, it may also lead to overly abstract functions for the more common+use cases.++The solution for this is the Lua API. It has no contract, which means that we+are free to improve and fix previous design blunders. These functions are+typically higher-level functions with simpler syntax and saner defaults. Often+times these are simply wrappers over the API functions meant for casual usage.+All of these function start with `vim.*`, where `*` is not `""api""`.++By combining these two approaches, we are able to provide the stability plugin+authors require with the API as well as provide the improvements and+simplicity the casual user wishes for with the Lua API. There is of course+nothing wrong with casual users/non-plugin authors using API functions. Quite+the opposite: not all API functions have a Lua API equivalent. Either they+haven't been created yet or they simply aren't needed. A Lua API function is+only needed if it significantly simplifies using the API functions in some+aspect. Having a wrapper for the sake of it would only result in a bunch of+duplicate functions that does the same thing.++This guide will primarily focus on using the Lua API functions if possible, as+they tend to be more convenient and more accessible.++==============================================================================+Where to put your files++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |'runtimepath'|,+which is typically `~/.config/nvim` for unix-y systems and+`~/AppData/Local/nvim/` for Windows.++If you'd like to run any Lua or Vim script on startup automatically, then you+can simply put them in one of the following directories in your+|'runtimepath'|: `colors/`, `compiler/`, `ftplugin/`, `ftdetect/`, `indent/`,+`plugin/` and `syntax/`. If you're unsure where to put your script, then it+should probably be in `plugin/`.++See also:+��� |config|++------------------------------------------------------------------------------+Lua modules++Lua modules are basically standalone Lua scripts you can import. They should+be located in the `lua/` directory in you |'runtimepath'|. Let's assume you+have the following directory structure:++~/.config/nvim+|-- after/+|-- ftplugin/+|-- lua/+|  |-- myluamodule.lua+|  |-- other_modules/+|     |-- anothermodule.lua+|     |-- init.lua+|-- plugin/+|-- syntax/+|-- init.vim++The following Lua code will load myluamodule.lua: >lua++    require(""myluamodule"")++Notice the absence of a .lua extension.++Similarly, loading `other_modules/anothermodule.lua` is done like so: >lua++    require('other_modules.anothermodule')+    -- or+    require('other_modules/anothermodule')++Path separators are denoted by either a dot `.` or a slash `/`.++A folder containing an |init.lua| file can be required directly, without+having to specify the name of the file: >lua++    require('other_modules') -- loads other_modules/init.lua++Requiring a nonexistent module or a module which contains syntax errors aborts+the currently executing script. pcall() may be used to prevent errors. >lua++    local ok, _ = pcall(require, 'module_with_error')+    if not ok then+      -- not loaded+    end++See also:+��� |lua-require|++==============================================================================+Using Lua from Vim script++You can use the |:lua| command to run Lua code: >lua++    :lua print(""Hello!"")++You can also use `:lua=`, which is same as `:lua print(vim.inspect(expr))`, to+conveniently check the value of a variable or a table: >lua++    :lua= package++You may use so-called heredocs to write multi-line Lua code from Vim script:+>lua+    lua << EOF+        local tbl = {1, 2, 3}+        for k, v in ipairs(tbl) do+            print(v)+        end+    EOF++Note: each :lua command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work: >vim++    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""++You can use the |:source| command if you'd like to run an entire Lua script:+>lua+    :source ~/programs/baz/myluafile.lua++You may use both the Lua builtin |require()| or the Neovim command |:source|+to run an external script. |require()| will keep track of which modules you+have executed before, and won't run the script again if it's called. |:source|+on the other hand will always run the script regardless. Another difference is+that |require()| searches for modules in directories named `lua/` in your+|'runtimepath'|. |:source| on the other hand accepts any absolute or relative+path to the file. Choose the method you find most suitable to your situation.++See also:+��� |:lua-heredoc|++==============================================================================+Using Vim script from Lua+There are many ways to use Vim script from Lua. This section will present some+of those, which should be enough to cover the most basic usages.++------------------------------------------------------------------------------+Calling commands++To call a command from lua, use |vim.cmd()|. There are multiple ways to use+|vim.cmd()|. Take the following two commands as an example: >lua++    vim.cmd(""echo \""Hello World!\"""")+    vim.cmd([[echo ""Hello World!""]])++Both of these does the same thing: printing ""Hello World!"". The second form+(`[[]]`), the so called double bracketed strings, tends to be easier to use.+Take the following example, where both commands does the same thing: >lua++    vim.cmd(""%s/\\Vfoo/bar/g"")+    vim.cmd([[%s/\Vfoo/bar/g]])++Notice that in the first case we need an extra `\` to escape the backslash.++Another benefit of using double bracketed strings is that they support+multiline string. The following command is perfectly valid: >lua++    vim.cmd([[+        set ignorecase+        colorscheme tokyonight+    ]])++This is analogous to using Lua heredocs. It is entirely possible (except in+rare cases) to surround the contents of your `init.vim` with `vim.cmd([[]])`,+rename `init.vim` to `init.lua` and still have a working configuration. If you+wish to rewrite your configuration in Lua then this approach may be less+chaotic than a full rewrite from scratch as it allows you to incrementally+change your configuration.++There is also a third way to use |vim.cmd()|: >lua++    vim.cmd.echo(""\""Hello World!\"""")++This is essentially syntactic sugar of the non-bracketed string explained at+the start of this section.++------------------------------------------------------------------------------+Calling functions++Use |vim.fn| to call Vim script commands from Lua. Data types between Lua and+Vim script are automatically converted: >lua++    print(vim.fn.printf('Hello from %s', 'Lua'))++    local reversed_list = vim.fn.reverse({ 'a', 'b', 'c' })+    print(vim.inspect(reversed_list)) -- { ""c"", ""b"", ""a"" }++    local function print_stdout(chan_id, data, name)+        print(data[1])+    end++    vim.fn.jobstart('ls', { on_stdout = print_stdout })+    print(vim.fn.printf('Hello from %s', 'Lua'))++Hashes (`#`) are not valid characters for identifiers in Lua, so autoload+functions have to be called with this syntax: >lua++    vim.fn['my#autoload#function']()++------------------------------------------------------------------------------+See also++��� |builtin-functions| - alphabetic list of all Vim script functions+��� |function-list| - list of all Vim script functions grouped by topic++==============================================================================+Setting variables++The most convenient way to set vim variables is to use the `vim.*` wrappers:++��� |vim.g|   - global variables (|g:|)+��� |vim.b|   - buffer variables (|b:|)+��� |vim.w|   - window variables (|w:|)+��� |vim.t|   - tabpage variables (|t:|)+��� |vim.v|   - predefined Vim variables (|v:|)+��� |vim.env| - environment variables >lua++    vim.g.some_global_variable = {+        key1 = ""value"",+        key2 = 300+    }++    print(vim.inspect(vim.g.some_global_variable)) -- { key1 = ""value"", key2 = 300 }++    -- target a specific buffer/window/tabpage+    vim.b[2].myvar = 1++Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using this syntax:+`vim.g['my#variable']`.++To delete one of these variables, simply assign `nil` to it: >lua++    vim.g.some_global_variable = nil++See also:+- |lua-vim-variables|++==============================================================================+Setting options++The simplest way to set options is to use the `vim.*o` and `vim.opt*` Lua API+wrappers. These are wrappers for the API functions described in |api-options|.++------------------------------------------------------------------------------+vim.*o++These wrappers allow you to manipulate options as if they were variables:","Hmm, do you mean draw parallel with `:let &option` as well as `:set`, or replace the `:set` parallel with the `let` parallel?",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21137,1033889298,2022-11-28T18:13:02Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,714 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++This chapter will give you the basics of using Lua in Neovim.++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++Important thing to note is that this isn't a guide to the Lua language itself.+Rather, this is a guide on how to configure and modify Neovim through the Lua+language and the functions we provide to help with this. Take a look at+|luaref| and |lua-concepts| if you'd like to learn more about Lua itself.++------------------------------------------------------------------------------+Nvim API vs Lua API                                            *nvim-vs-lua-api*++Before diving into how to use Lua in Neovim, it's important to first+understand the distinction between the different APIs as they drive a lot of+the design decisions.++Neovim has two APIs, we call these the ""Nvim API"" (or just ""API"") and the ""Lua+API"". You may think of these as two different groups of functions. The API+functions, which are the functions listed in |api.txt|, are bound by a so+called |api-contract|. The Lua API functions, listed in |lua.txt|, have no+such contract.++The |api-contract| is just a formal way of saying ""these functions are stable+and expected to work for a very long time"". Plugin authors and users can+expect anything they write with these functions to work for a long time. All+of these functions start with `vim.api`.++This stability and rigidity comes at a cost however. Not only does it make it+near impossible to improve previous design decisions as it would break the+contract, it may also lead to overly abstract functions for the more common+use cases.++The solution for this is the Lua API. It has no contract, which means that we+are free to improve and fix previous design blunders. These functions are+typically higher-level functions with simpler syntax and saner defaults. Often+times these are simply wrappers over the API functions meant for casual usage.+All of these function start with `vim.*`, where `*` is not `""api""`.++By combining these two approaches, we are able to provide the stability plugin+authors require with the API as well as provide the improvements and+simplicity the casual user wishes for with the Lua API. There is of course+nothing wrong with casual users/non-plugin authors using API functions. Quite+the opposite: not all API functions have a Lua API equivalent. Either they+haven't been created yet or they simply aren't needed. A Lua API function is+only needed if it significantly simplifies using the API functions in some+aspect. Having a wrapper for the sake of it would only result in a bunch of+duplicate functions that does the same thing.++This guide will primarily focus on using the Lua API functions if possible, as+they tend to be more convenient and more accessible.++==============================================================================+Where to put your files++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |'runtimepath'|,+which is typically `~/.config/nvim` for unix-y systems and+`~/AppData/Local/nvim/` for Windows.++If you'd like to run any Lua or Vim script on startup automatically, then you+can simply put them in one of the following directories in your+|'runtimepath'|: `colors/`, `compiler/`, `ftplugin/`, `ftdetect/`, `indent/`,+`plugin/` and `syntax/`. If you're unsure where to put your script, then it+should probably be in `plugin/`.++See also:+��� |config|++------------------------------------------------------------------------------+Lua modules++Lua modules are basically standalone Lua scripts you can import. They should+be located in the `lua/` directory in you |'runtimepath'|. Let's assume you+have the following directory structure:++~/.config/nvim+|-- after/+|-- ftplugin/+|-- lua/+|  |-- myluamodule.lua+|  |-- other_modules/+|     |-- anothermodule.lua+|     |-- init.lua+|-- plugin/+|-- syntax/+|-- init.vim++The following Lua code will load myluamodule.lua: >lua++    require(""myluamodule"")++Notice the absence of a .lua extension.++Similarly, loading `other_modules/anothermodule.lua` is done like so: >lua++    require('other_modules.anothermodule')+    -- or+    require('other_modules/anothermodule')++Path separators are denoted by either a dot `.` or a slash `/`.++A folder containing an |init.lua| file can be required directly, without+having to specify the name of the file: >lua++    require('other_modules') -- loads other_modules/init.lua++Requiring a nonexistent module or a module which contains syntax errors aborts+the currently executing script. pcall() may be used to prevent errors. >lua++    local ok, _ = pcall(require, 'module_with_error')+    if not ok then+      -- not loaded+    end++See also:+��� |lua-require|++==============================================================================+Using Lua from Vim script++You can use the |:lua| command to run Lua code: >lua++    :lua print(""Hello!"")++You can also use `:lua=`, which is same as `:lua print(vim.inspect(expr))`, to+conveniently check the value of a variable or a table: >lua++    :lua= package++You may use so-called heredocs to write multi-line Lua code from Vim script:+>lua+    lua << EOF+        local tbl = {1, 2, 3}+        for k, v in ipairs(tbl) do+            print(v)+        end+    EOF++Note: each :lua command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work: >vim++    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""++You can use the |:source| command if you'd like to run an entire Lua script:+>lua+    :source ~/programs/baz/myluafile.lua++You may use both the Lua builtin |require()| or the Neovim command |:source|+to run an external script. |require()| will keep track of which modules you+have executed before, and won't run the script again if it's called. |:source|+on the other hand will always run the script regardless. Another difference is+that |require()| searches for modules in directories named `lua/` in your+|'runtimepath'|. |:source| on the other hand accepts any absolute or relative+path to the file. Choose the method you find most suitable to your situation.++See also:+��� |:lua-heredoc|++==============================================================================+Using Vim script from Lua+There are many ways to use Vim script from Lua. This section will present some+of those, which should be enough to cover the most basic usages.++------------------------------------------------------------------------------+Calling commands++To call a command from lua, use |vim.cmd()|. There are multiple ways to use+|vim.cmd()|. Take the following two commands as an example: >lua++    vim.cmd(""echo \""Hello World!\"""")+    vim.cmd([[echo ""Hello World!""]])++Both of these does the same thing: printing ""Hello World!"". The second form+(`[[]]`), the so called double bracketed strings, tends to be easier to use.+Take the following example, where both commands does the same thing: >lua++    vim.cmd(""%s/\\Vfoo/bar/g"")+    vim.cmd([[%s/\Vfoo/bar/g]])++Notice that in the first case we need an extra `\` to escape the backslash.++Another benefit of using double bracketed strings is that they support+multiline string. The following command is perfectly valid: >lua++    vim.cmd([[+        set ignorecase+        colorscheme tokyonight+    ]])++This is analogous to using Lua heredocs. It is entirely possible (except in+rare cases) to surround the contents of your `init.vim` with `vim.cmd([[]])`,+rename `init.vim` to `init.lua` and still have a working configuration. If you+wish to rewrite your configuration in Lua then this approach may be less+chaotic than a full rewrite from scratch as it allows you to incrementally+change your configuration.++There is also a third way to use |vim.cmd()|: >lua++    vim.cmd.echo(""\""Hello World!\"""")++This is essentially syntactic sugar of the non-bracketed string explained at+the start of this section.++------------------------------------------------------------------------------+Calling functions++Use |vim.fn| to call Vim script commands from Lua. Data types between Lua and+Vim script are automatically converted: >lua++    print(vim.fn.printf('Hello from %s', 'Lua'))++    local reversed_list = vim.fn.reverse({ 'a', 'b', 'c' })+    print(vim.inspect(reversed_list)) -- { ""c"", ""b"", ""a"" }++    local function print_stdout(chan_id, data, name)+        print(data[1])+    end++    vim.fn.jobstart('ls', { on_stdout = print_stdout })+    print(vim.fn.printf('Hello from %s', 'Lua'))++Hashes (`#`) are not valid characters for identifiers in Lua, so autoload+functions have to be called with this syntax: >lua++    vim.fn['my#autoload#function']()++------------------------------------------------------------------------------+See also++��� |builtin-functions| - alphabetic list of all Vim script functions+��� |function-list| - list of all Vim script functions grouped by topic++==============================================================================+Setting variables++The most convenient way to set vim variables is to use the `vim.*` wrappers:++��� |vim.g|   - global variables (|g:|)+��� |vim.b|   - buffer variables (|b:|)+��� |vim.w|   - window variables (|w:|)+��� |vim.t|   - tabpage variables (|t:|)+��� |vim.v|   - predefined Vim variables (|v:|)+��� |vim.env| - environment variables >lua++    vim.g.some_global_variable = {+        key1 = ""value"",+        key2 = 300+    }++    print(vim.inspect(vim.g.some_global_variable)) -- { key1 = ""value"", key2 = 300 }++    -- target a specific buffer/window/tabpage+    vim.b[2].myvar = 1++Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using this syntax:+`vim.g['my#variable']`.++To delete one of these variables, simply assign `nil` to it: >lua++    vim.g.some_global_variable = nil++See also:+- |lua-vim-variables|++==============================================================================+Setting options++The simplest way to set options is to use the `vim.*o` and `vim.opt*` Lua API+wrappers. These are wrappers for the API functions described in |api-options|.++------------------------------------------------------------------------------+vim.*o++These wrappers allow you to manipulate options as if they were variables:","Maybe just add a suggestion for this one, that was too many parallels for me :)",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1034114308,2022-11-28T22:26:46Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,621 @@+local api = vim.api+local handlers = require('vim.lsp.handlers')+local util = require('vim.lsp.util')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STClientState+--- @field namespace number+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult++---@class STHighlighter+---@field active table<number, STHighlighter>+---@field bufnr number+---@field augroup number augroup for buffer events+---@field debounce number milliseconds to debounce requests for new tokens+---@field timer table uv_timer for debouncing requests for new tokens+---@field client_state table<number, STClientState>+local STHighlighter = { active = {} }++---@private+local function get_bit(n, k)+  return _G.bit.band(_G.bit.rshift(n, k), 1)+end++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++--- Extracts modifier strings from the encoded number in the token array+---+---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+---+---@private+---@return STTokenRange[]+local function tokens_to_ranges(data, bufnr, client)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = get_byte_pos(start_char)+    local end_col = get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++--- Construct a new STHighlighter for the buffer, and attach to the given client+---+---@private+---@param bufnr number+function STHighlighter.new(bufnr)+  local self = setmetatable({}, { __index = STHighlighter })++  self.bufnr = bufnr+  self.augroup = api.nvim_create_augroup('vim_lsp_semantic_tokens:' .. bufnr, { clear = true })+  self.client_state = {}++  STHighlighter.active[bufnr] = self++  api.nvim_buf_attach(bufnr, false, {+    on_lines = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if not highlighter then+        return true+      end+      highlighter:on_change()+    end,+    on_reload = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:reset()+        highlighter:send_request()+      end+    end,+    on_detach = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:destroy()+      end+    end,+  })++  api.nvim_create_autocmd({ 'BufWinEnter', 'InsertLeave' }, {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function()+      self:send_request()+    end,+  })++  api.nvim_create_autocmd('LspDetach', {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function(args)+      self:detach(args.data.client_id)+      if #vim.tbl_keys(self.client_state) then+        self:destroy()+      end+    end,+  })++  return self+end++---@private+function STHighlighter:destroy()+  for client_id, _ in pairs(self.client_state) do+    self:detach(client_id)+  end++  api.nvim_del_augroup_by_id(self.augroup)+  STHighlighter.active[self.bufnr] = nil+end++---@private+function STHighlighter:attach(client_id)+  local state = self.client_state[client_id]+  if not state then+    state = {+      namespace = api.nvim_create_namespace('vim_lsp_semantic_tokens:' .. client_id),+      active_request = {},+      current_result = {},+    }+    self.client_state[client_id] = state+  end+end++---@private+function STHighlighter:detach(client_id)+  local state = self.client_state[client_id]+  if state then+    --TODO: delete namespace if/when that becomes possible+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    self.client_state[client_id] = nil+  end+end++--- This is the entry point for getting all the tokens in a buffer.+---+--- For the given clients (or all attached, if not provided), this sends a request+--- to ask for semantic tokens. If the server supports delta requests, that will+--- be prioritized if we have a previous requestId and token array.+---+--- This function will skip servers where there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+function STHighlighter:send_request()+  local version = util.buf_versions[self.bufnr]++  self:reset_timer()++  for client_id, state in pairs(self.client_state) do+    local client = vim.lsp.get_client_by_id(client_id)++    local current_result = state.current_result+    local active_request = state.active_request++    -- Only send a request for this client if the current result is out of date and+    -- there isn't a current a request in flight for this version+    if current_result.version ~= version and active_request.version ~= version then+      -- cancel stale in-flight request+      if active_request.request_id then+        client.cancel_request(active_request.request_id)+        active_request = {}+        state.active_request = active_request+      end++      local spec = client.server_capabilities.semanticTokensProvider.full+      local hasEditProvider = type(spec) == 'table' and spec.delta++      local params = { textDocument = util.make_text_document_params(self.bufnr) }+      local method = 'textDocument/semanticTokens/full'++      if hasEditProvider and current_result.result_id then+        method = 'textDocument/semanticTokens/full/delta'+        params.previousResultId = current_result.result_id+      end+      local success, request_id = client.request(method, params, function(err, response, _)+        if not err then+          self:process_response(response, client, version)+        end+      end, self.bufnr)++      if success then+        active_request.request_id = request_id+        active_request.version = version+      end+    end+  end+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full[/delta]`+---",It _started_ as the direct handler but I changed it so I could capture the version and pass it along to a member function. :-),
15057271,andrewwillette,https://api.github.com/repos/neovim/neovim/pulls/21147,1034198356,2022-11-29T01:01:14Z,src/nvim/ui_compositor.c,"@@ -706,16 +706,21 @@ static void ui_comp_grid_resize(UI *ui, Integer grid, Integer width, Integer hei  static void ui_comp_event(UI *ui, char *name, Array args) {-  Error err = ERROR_INIT;   UIEventCallback *event_cb;   bool handled = false;-+  Error initerr = ERROR_INIT;   map_foreach_value(&ui_event_cbs, event_cb, {+    Error err = initerr;     Object res = nlua_call_ref(event_cb->cb, name, args, false, &err);     if (res.type == kObjectTypeBoolean && res.data.boolean == true) {       handled = true;     }+    if (err.type != kErrorTypeNone) {+      ELOG(""Error while executing ui_comp_event callback: %s"", err.msg);+    }+    api_clear_error(&err);   })+  api_clear_error(&initerr);","Thanks, made the update.Interesting to me that that is how it works. The [NULL declaration for](https://github.com/andrewwillette/neovim-willette/blob/2dd8befde1ace73d84edae95c25d807bec0e2d86/src/nvim/api/private/defs.h#L15) `.msg` makes sense that it wouldn't take up any memory, but I'd think `-1` for `kErrorTypeNone` ([link](https://github.com/andrewwillette/neovim-willette/blob/2dd8befde1ace73d84edae95c25d807bec0e2d86/src/nvim/api/private/defs.h#L28)) would. I trust you, you know more than I do here.",
43915420,Nero-F,https://api.github.com/repos/neovim/neovim/pulls/21189,1034756719,2022-11-29T13:31:50Z,runtime/lua/vim/ui.lua,"@@ -145,7 +145,8 @@ function M.confirm(msg, opts, on_choice)   if not ok then     on_choice(nil, nil)   else-    on_choice(choice_index, opts.choices[choice_index])+    local epurate_choice = opts.choices[choice_index]:gsub('&', '')","French word, it basically means purify, mybad I'm correcting this.",
15057271,andrewwillette,https://api.github.com/repos/neovim/neovim/pulls/21147,1034838231,2022-11-29T14:36:58Z,src/nvim/ui_compositor.c,"@@ -706,15 +706,19 @@ static void ui_comp_grid_resize(UI *ui, Integer grid, Integer width, Integer hei  static void ui_comp_event(UI *ui, char *name, Array args) {-  Error err = ERROR_INIT;   UIEventCallback *event_cb;   bool handled = false;-+  const Error initerr = ERROR_INIT;   map_foreach_value(&ui_event_cbs, event_cb, {+    Error err = initerr;","I tried the below:```C  map_foreach_value(&ui_event_cbs, event_cb, {    Error err = (Error)ERROR_INIT;    Object res = nlua_call_ref(event_cb->cb, name, args, false, &err);    if (res.type == kObjectTypeBoolean && res.data.boolean == true) {      handled = true;    }    if (ERROR_SET(&err)) {      ELOG(""Error while executing ui_comp_event callback: %s"", err.msg);    }    api_clear_error(&err);  })```but the compiler throws the error of : `Too many arguments provided to function-like macro invocation` on the `Error err` definition line. I believe it's because the preprocessor sees any comma as an arg separator to a macro, and the `ERROR_INIT` macro [has a comma in its value](https://github.com/andrewwillette/neovim-willette/blob/0ab8fa1371b59ef8d864b6ce8661fbfc4bb04fe7/src/nvim/api/private/defs.h#L15).",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/20242,1035361390,2022-11-29T22:50:13Z,src/nvim/change_defs.h,"@@ -0,0 +1,14 @@+#ifndef NVIM_CHANGE_DEFS_H+#define NVIM_CHANGE_DEFS_H",This file seems useless. I can't imagine a case where including this file without including `change.h` does anything.,X
15057271,andrewwillette,https://api.github.com/repos/neovim/neovim/pulls/21147,1035408140,2022-11-30T00:17:42Z,src/nvim/ui_compositor.c,"@@ -706,15 +706,19 @@ static void ui_comp_grid_resize(UI *ui, Integer grid, Integer width, Integer hei  static void ui_comp_event(UI *ui, char *name, Array args) {-  Error err = ERROR_INIT;   UIEventCallback *event_cb;   bool handled = false;-+  const Error initerr = ERROR_INIT;   map_foreach_value(&ui_event_cbs, event_cb, {+    Error err = initerr;","@bfredl, I don't see any examples of `map_foreach_value` with a macro with of value `{...,...}` in the repository.There is [an example](https://github.com/andrewwillette/neovim-willette/blob/0ab8fa1371b59ef8d864b6ce8661fbfc4bb04fe7/src/nvim/channel.c#L940) where the `ADD` macro([link](https://github.com/andrewwillette/neovim-willette/blob/0ab8fa1371b59ef8d864b6ce8661fbfc4bb04fe7/src/nvim/api/private/helpers.h#L77-L78)) is called in the `map_foreach_value`, but I believe this is still valid because the comma exists inside parenthesis. The preprocessor understands values inside parens are separate function args.The `ERROR_INIT` macro has a comma [inside brackets](https://github.com/andrewwillette/neovim-willette/blob/0ab8fa1371b59ef8d864b6ce8661fbfc4bb04fe7/src/nvim/api/private/defs.h#L15).I could be wrong, but it is my understanding of the issue.",
15057271,andrewwillette,https://api.github.com/repos/neovim/neovim/pulls/21147,1035417284,2022-11-30T00:37:11Z,src/nvim/ui_compositor.c,"@@ -706,15 +706,19 @@ static void ui_comp_grid_resize(UI *ui, Integer grid, Integer width, Integer hei  static void ui_comp_event(UI *ui, char *name, Array args) {-  Error err = ERROR_INIT;   UIEventCallback *event_cb;   bool handled = false;-+  const Error initerr = ERROR_INIT;   map_foreach_value(&ui_event_cbs, event_cb, {+    Error err = initerr;","So I found a solution in line with surrounding the macro in parens! I saw that `STRING_OBJECT` ([link](https://github.com/andrewwillette/neovim-willette/blob/a17b0c947ad128edb9d9c5c54a610107a71e7f0a/src/nvim/api/private/helpers.h#L33-L35)) was used inside other macros, for example `PUT` ([link](https://github.com/andrewwillette/neovim-willette/blob/a17b0c947ad128edb9d9c5c54a610107a71e7f0a/src/nvim/api/autocmd.c#L298)). I followed `STRING_OBJECT`'s pattern (of what looks to be like an anonymous function in C?) to get it to work.@bfredl / @zeertzjq please let me know if you think the prior implementation is preferable. Thank you for your time.  I really want to get this merged.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/21147,1035702785,2022-11-30T09:06:22Z,src/nvim/ui_compositor.c,"@@ -706,15 +706,19 @@ static void ui_comp_grid_resize(UI *ui, Integer grid, Integer width, Integer hei  static void ui_comp_event(UI *ui, char *name, Array args) {-  Error err = ERROR_INIT;   UIEventCallback *event_cb;   bool handled = false;-+  const Error initerr = ERROR_INIT;   map_foreach_value(&ui_event_cbs, event_cb, {+    Error err = initerr;","yes, that is the preferred pattern.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20379,1036228186,2022-11-30T17:01:30Z,runtime/lua/vim/fs.lua,"@@ -40,15 +42,34 @@ function M.dirname(file)   if file == nil then     return nil   end-  return vim.fn.fnamemodify(file, ':h')+  vim.validate({ file = { file, 's' } })+  if file:match('^%w:[\\/]?$') and iswin then","Probably is only a minor consideration, but maybe put `iswin` in the condition first, so that it fails quickly when not on Windows (otherwise, it will run `string.match()` *every* time, even if `iswin` is false).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/20379,1036228613,2022-11-30T17:01:56Z,runtime/lua/vim/fs.lua,"@@ -40,15 +42,34 @@ function M.dirname(file)   if file == nil then     return nil   end-  return vim.fn.fnamemodify(file, ':h')+  vim.validate({ file = { file, 's' } })+  if file:match('^%w:[\\/]?$') and iswin then+    return file:gsub('\\', '/')+  elseif not file:match('[\\/]') then+    return '.'+  elseif file:match('^/[^/]+$') or file == '/' then","Similar comment here, it's cheaper/easier to check `file == '/'` so put that in the condition first so that we don't call `string.match()` if we don't need to.",
21993921,nkarl,https://api.github.com/repos/neovim/neovim/pulls/21246,1036626060,2022-12-01T02:14:02Z,runtime/autoload/provider/node.vim,"@@ -71,13 +71,15 @@ function! provider#node#Detect() abort     let yarn_opts = deepcopy(s:NodeHandler)     let yarn_opts.entry_point = '/node_modules/neovim/bin/cli.js'     "" `yarn global dir` is slow (> 250ms), try the default path first-    "" XXX: The following code is not portable     "" https://github.com/yarnpkg/yarn/issues/2049#issuecomment-263183768     if has('unix')-      let yarn_default_path = $HOME . '/.config/yarn/global/' . yarn_opts.entry_point-      if filereadable(yarn_default_path)-        return [yarn_default_path, '']-      endif+      let yarn_config_dir = '/.config/yarn/'+    elseif has('win32')+      let yarn_config_dir = '/AppData/Local/Yarn/Data/'+    endif+    let yarn_default_path = $HOME . yarn_config_dir . '/global/' . yarn_opts.entry_point","$HOME should always be present given Microsoft's focus on making Windows PowerShell 7 similar to unix systems, and away from the old CMD. It's basically just `C:\\Users\\UserName`. If we use `$LOCALAPPDATA`, then it has to be `$ENV:LOCALAPPDATA`, which then will add more code and might cause confusion.",
7416158,craigmac,https://api.github.com/repos/neovim/neovim/pulls/21137,1038669906,2022-12-03T03:04:03Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,711 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++This chapter will guide you through the basics of using Lua in Neovim.++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++Important thing to note is that this isn't a guide to the Lua language itself.+Rather, this is a guide on how to configure and modify Neovim through the Lua+language and the functions we provide to help with this. Take a look at+|luaref| and |lua-concepts| if you'd like to learn more about Lua itself.++------------------------------------------------------------------------------+Nvim API vs Lua API                                            *nvim-vs-lua-api*++Before diving into how to use Lua in Neovim, it's important to first+understand the distinction between the different APIs as they drive a lot of+the design decisions.++Neovim has two APIs, we call these the ""Nvim API"" (or just ""API"") and the ""Lua+API"". You may think of these as two different groups of functions. The API+functions, which are the functions listed in |api.txt|, are bound by a so+called |api-contract|. The Lua API functions, listed in |lua.txt|, have no+such contract.++The |api-contract| is just a formal way of saying ""these functions are stable+and expected to work for a very long time"". Plugin authors and users can+expect anything they write with these functions to work for a long time. All+of these functions start with `vim.api`.++This stability and rigidity comes at a cost however. Not only does it make it+near impossible to improve previous design decisions as it would break the+contract, it may also lead to overly abstract functions for the more common+use cases.++The solution for this is the Lua API. It has no contract, which means that we+are free to improve and fix previous design blunders. These functions are+typically higher-level functions with simpler syntax and saner defaults. Often+times these are simply wrappers over the API functions meant for casual usage.+All of these function start with `vim.*`, where `*` is not `""api""`.++By combining these two approaches, we are able to provide the stability plugin+authors require with the API as well as provide the improvements and+simplicity the casual user wishes for with the Lua API. There is of course+nothing wrong with casual users/non-plugin authors using API functions. Quite+the opposite: not all API functions have a Lua API equivalent. Either they+haven't been created yet or they simply aren't needed. A Lua API function is+only needed if it significantly simplifies using the API functions in some+aspect. Having a wrapper for the sake of it would only result in a bunch of+duplicate functions that does the same thing.++This guide will primarily focus on using the Lua API functions if possible, as+they tend to be more convenient and more accessible.++==============================================================================+Where to put your files++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |'runtimepath'|,+which is typically `~/.config/nvim` for unix-y systems and+`~/AppData/Local/nvim/` for Windows.++If you'd like to run any Lua or Vim script on startup automatically, then you+can simply put them in `plugin/` in your |'runtimepath'|.++See also:+��� |config|++------------------------------------------------------------------------------+Lua modules++Lua modules are basically standalone Lua scripts you can import. They should+be located in the `lua/` directory in you |'runtimepath'|. Let's assume you+have the following directory structure:++~/.config/nvim+|-- after/+|-- ftplugin/+|-- lua/+|  |-- myluamodule.lua+|  |-- other_modules/+|     |-- anothermodule.lua+|     |-- init.lua+|-- plugin/+|-- syntax/+|-- init.vim++The following Lua code will load myluamodule.lua: >lua++    require(""myluamodule"")",```suggestion    require('myluamodule')```Following stylua settings for Neovim source code for consistency. Find them in `https://github.com/neovim/neovim/blob/master/.stylua.toml`. Will make a PR to do this to all examples in repo sometime.,
7416158,craigmac,https://api.github.com/repos/neovim/neovim/pulls/21137,1038880526,2022-12-03T22:40:01Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,756 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++An important thing to note is that this isn't a guide to the Lua language+itself. Rather, this is a guide on how to configure and modify Neovim through+the Lua language and the functions we provide to help with this. Take a look+at |luaref| and |lua-concepts| if you'd like to learn more about Lua itself.+Similarly, this guide assumes some familiarity with the basics of Neovim+(commands, options, mappings, autocommands), which are covered in the+|user-manual|.++------------------------------------------------------------------------------+Some words on the API                                            *lua-guide-api*++The purpose of this guide is to introduce the different ways of interacting+with Neovim through Lua (the ""API""). This API consists of three different+layers:++1. The ""Vim API"" inherited from Vim: |ex-commands| and |builtin| as well as+|user-function|s in Vimscript. These are accessed through |vim.cmd| and+|vim.fn| respectively, which are discussed under |lua-guide-vimscript| below.++2. The ""Neovim API"" written in C for use in remote plugins and GUIs; see |api|.+These functions are accessed through |vim.api|.++3. The ""Lua API"" written in and specifically for Lua. These are any other+functions accessible through `vim.*` not mentioned already.++This distinction is important, as API functions inherit behavior from their+original layer: For example, Neovim API functions always need all arguments to+be specified even if Lua itself allows omitting arguments (which are then+passed as `nil`); and Vim API functions can use 0-based indexing even if Lua+arrays are 1-indexed by default.++Through this, any possible interaction can be done through Lua without writing+a complete new API from scratch. For this reason, functions are usually not+duplicated between layers unless there is a significant benefit in+functionality or performance (e.g., you can map Lua functions directly through+|nvim_create_autocmd| but not through |:autocmd|). In case there are multiple+ways of achieving the same thing, this guide will only cover what is most+convenient to from Lua.++==============================================================================+Using Lua                                                  *lua-guide-using-Lua*++To run Lua code from the Neovim command line, use the |:lua| command:+>vim+    :lua print(""Hello!"")+<+Note: each `:lua` command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work:+>vim+    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""+<+You can also use `:lua =`, which is same as `:lua print(vim.inspect(expr))`, to+conveniently check the value of a variable or a table:+>lua+    :lua =package+<+To run a Lua script in an external file, you can use the |:source| command+exactly like for a Vimscript:+>vim+    :source ~/programs/baz/myluafile.lua+<+Finally, you can include Lua code in a vimscript file by putting it inside a+|lua-heredoc| block:+>vim+    lua << EOF+        local tbl = {1, 2, 3}+        for k, v in ipairs(tbl) do+            print(v)+        end+    EOF+<+------------------------------------------------------------------------------+Using Lua files on startup                                    *lua-guide-config*++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |config| directory,+which is typically `~/.config/nvim` for Linux, BSD, or macOS, and+`~/AppData/Local/nvim/` for Windows. Note that you can use Lua in `init.vim`+and Vimscript in `init.lua`, which will be covered below.++If you'd like to run any other Lua script on |startup| automatically, then you+can simply put it in `plugin/` in your |'runtimepath'|.++------------------------------------------------------------------------------+Lua modules                                                  *lua-guide-modules*++If you want to load Lua files on demand, you can place them in the `lua/`+directory in your |'runtimepath'| and load them with `require`. (This is the+Lua equivalent of Vimscript's |autoload|.)","```suggestiondirectory in your |'runtimepath'| and load them with `require()`. This is similar to the Vim script |autoload| mechanism.```Unless it's exactly the same, which I don't think it is, I don't think we should say 'equivalent' here,  aren't there lots of situations and small nuances between the two loading mechanisms?",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21137,1038883357,2022-12-03T23:15:14Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,711 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++This chapter will guide you through the basics of using Lua in Neovim.++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++Important thing to note is that this isn't a guide to the Lua language itself.+Rather, this is a guide on how to configure and modify Neovim through the Lua+language and the functions we provide to help with this. Take a look at+|luaref| and |lua-concepts| if you'd like to learn more about Lua itself.++------------------------------------------------------------------------------+Nvim API vs Lua API                                            *nvim-vs-lua-api*++Before diving into how to use Lua in Neovim, it's important to first+understand the distinction between the different APIs as they drive a lot of+the design decisions.++Neovim has two APIs, we call these the ""Nvim API"" (or just ""API"") and the ""Lua+API"". You may think of these as two different groups of functions. The API+functions, which are the functions listed in |api.txt|, are bound by a so+called |api-contract|. The Lua API functions, listed in |lua.txt|, have no+such contract.++The |api-contract| is just a formal way of saying ""these functions are stable+and expected to work for a very long time"". Plugin authors and users can+expect anything they write with these functions to work for a long time. All+of these functions start with `vim.api`.++This stability and rigidity comes at a cost however. Not only does it make it+near impossible to improve previous design decisions as it would break the+contract, it may also lead to overly abstract functions for the more common+use cases.++The solution for this is the Lua API. It has no contract, which means that we+are free to improve and fix previous design blunders. These functions are+typically higher-level functions with simpler syntax and saner defaults. Often+times these are simply wrappers over the API functions meant for casual usage.+All of these function start with `vim.*`, where `*` is not `""api""`.++By combining these two approaches, we are able to provide the stability plugin+authors require with the API as well as provide the improvements and+simplicity the casual user wishes for with the Lua API. There is of course+nothing wrong with casual users/non-plugin authors using API functions. Quite+the opposite: not all API functions have a Lua API equivalent. Either they+haven't been created yet or they simply aren't needed. A Lua API function is+only needed if it significantly simplifies using the API functions in some+aspect. Having a wrapper for the sake of it would only result in a bunch of+duplicate functions that does the same thing.++This guide will primarily focus on using the Lua API functions if possible, as+they tend to be more convenient and more accessible.++==============================================================================+Where to put your files++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |'runtimepath'|,+which is typically `~/.config/nvim` for unix-y systems and+`~/AppData/Local/nvim/` for Windows.++If you'd like to run any Lua or Vim script on startup automatically, then you+can simply put them in `plugin/` in your |'runtimepath'|.++See also:+��� |config|++------------------------------------------------------------------------------+Lua modules++Lua modules are basically standalone Lua scripts you can import. They should+be located in the `lua/` directory in you |'runtimepath'|. Let's assume you+have the following directory structure:++~/.config/nvim+|-- after/+|-- ftplugin/+|-- lua/+|  |-- myluamodule.lua+|  |-- other_modules/+|     |-- anothermodule.lua+|     |-- init.lua+|-- plugin/+|-- syntax/+|-- init.vim++The following Lua code will load myluamodule.lua: >lua++    require(""myluamodule"")","Not sure I want to do this here. The style guide is opinionated and can be confusing to newcomers (especially regarding omitting parens). In any case, it only applies to Neovim code, not user config. So as long as it's valid Lua, I don't think we need to care here.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21137,1038956788,2022-12-04T11:51:35Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,760 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++An important thing to note is that this isn't a guide to the Lua language+itself. Rather, this is a guide on how to configure and modify Neovim through+the Lua language and the functions we provide to help with this. Take a look+at |luaref| and |lua-concepts| if you'd like to learn more about Lua itself.+Similarly, this guide assumes some familiarity with the basics of Neovim+(commands, options, mappings, autocommands), which are covered in the+|user-manual|.++------------------------------------------------------------------------------+Some words on the API                                            *lua-guide-api*++The purpose of this guide is to introduce the different ways of interacting+with Neovim through Lua (the ""API""). This API consists of three different+layers:++1. The ""Vim API"" inherited from Vim: |ex-commands| and |builtin| as well as+|user-function|s in Vimscript. These are accessed through |vim.cmd()| and+|vim.fn| respectively, which are discussed under |lua-guide-vimscript| below.++2. The ""Neovim API"" written in C for use in remote plugins and GUIs; see |api|.+These functions are accessed through |vim.api|.++3. The ""Lua API"" written in and specifically for Lua. These are any other+functions accessible through `vim.*` not mentioned already.++This distinction is important, as API functions inherit behavior from their+original layer: For example, Neovim API functions always need all arguments to+be specified even if Lua itself allows omitting arguments (which are then+passed as `nil`); and Vim API functions can use 0-based indexing even if Lua+arrays are 1-indexed by default.++Through this, any possible interaction can be done through Lua without writing+a complete new API from scratch. For this reason, functions are usually not+duplicated between layers unless there is a significant benefit in+functionality or performance (e.g., you can map Lua functions directly through+|nvim_create_autocmd| but not through |:autocmd|). In case there are multiple+ways of achieving the same thing, this guide will only cover what is most+convenient to use from Lua.++==============================================================================+Using Lua                                                  *lua-guide-using-Lua*++To run Lua code from the Neovim command line, use the |:lua| command:+>vim+    :lua print(""Hello!"")+<+Note: each |:lua| command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work:+>vim+    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""+<+You can also use `:lua =`, which is the same as `:lua print(vim.inspect(expr))`,+to conveniently check the value of a variable or a table:+>lua+    :lua =package",Sure; that's just the way I always type. As long as it's consistent.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21137,1039004565,2022-12-04T17:26:57Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,758 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++An important thing to note is that this isn't a guide to the Lua language+itself. Rather, this is a guide on how to configure and modify Neovim through+the Lua language and the functions we provide to help with this. Take a look+at |luaref| and |lua-concepts| if you'd like to learn more about Lua itself.+Similarly, this guide assumes some familiarity with the basics of Neovim+(commands, options, mappings, autocommands), which are covered in the+|user-manual|.++------------------------------------------------------------------------------+Some words on the API                                            *lua-guide-api*++The purpose of this guide is to introduce the different ways of interacting+with Neovim through Lua (the ""API""). This API consists of three different+layers:++1. The ""Vim API"" inherited from Vim: |ex-commands| and |builtin-functions| as+well as |user-function|s in Vimscript. These are accessed through |vim.cmd()|+and |vim.fn| respectively, which are discussed under |lua-guide-vimscript|+below.++2. The ""Neovim API"" written in C for use in remote plugins and GUIs; see |api|.+These functions are accessed through |vim.api|.++3. The ""Lua API"" written in and specifically for Lua. These are any other+functions accessible through `vim.*` not mentioned already; see |lua-stdlib|.++This distinction is important, as API functions inherit behavior from their+original layer: For example, Neovim API functions always need all arguments to+be specified even if Lua itself allows omitting arguments (which are then+passed as `nil`); and Vim API functions can use 0-based indexing even if Lua+arrays are 1-indexed by default.++Through this, any possible interaction can be done through Lua without writing+a complete new API from scratch. For this reason, functions are usually not+duplicated between layers unless there is a significant benefit in+functionality or performance (e.g., you can map Lua functions directly through+|nvim_create_autocmd()| but not through |:autocmd|). In case there are multiple+ways of achieving the same thing, this guide will only cover what is most+convenient to use from Lua.++==============================================================================+Using Lua                                                  *lua-guide-using-Lua*++To run Lua code from the Neovim command line, use the |:lua| command:+>vim+    :lua print(""Hello!"")+<+Note: each |:lua| command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work:+>vim+    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""+<+You can also use `:lua=`, which is the same as `:lua print(vim.inspect(expr))`,+to conveniently check the value of a variable or a table:+>lua+    :lua=package+<+To run a Lua script in an external file, you can use the |:source| command+exactly like for a Vimscript file:+>vim+    :source ~/programs/baz/myluafile.lua+<+Finally, you can include Lua code in a vimscript file by putting it inside a+|lua-heredoc| block:+>vim+    lua << EOF+      local tbl = {1, 2, 3}+      for k, v in ipairs(tbl) do+        print(v)+      end+    EOF+<+------------------------------------------------------------------------------+Using Lua files on startup                                    *lua-guide-config*++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |config| directory,+which is typically `~/.config/nvim` for Linux, BSD, or macOS, and+`~/AppData/Local/nvim/` for Windows. Note that you can use Lua in `init.vim`+and Vimscript in `init.lua`, which will be covered below.++If you'd like to run any other Lua script on |startup| automatically, then you+can simply put it in `plugin/` in your |'runtimepath'|.++------------------------------------------------------------------------------+Lua modules                                                  *lua-guide-modules*++If you want to load Lua files on demand, you can place them in the `lua/`+directory in your |'runtimepath'| and load them with `require`. (This is the+Lua equivalent of Vimscript's |autoload| mechanism.)++Let's assume you have the following directory structure:+>+    ~/.config/nvim+    |-- after/+    |-- ftplugin/+    |-- lua/+    |  |-- myluamodule.lua+    |  |-- other_modules/+    |     |-- anothermodule.lua+    |     |-- init.lua+    |-- plugin/+    |-- syntax/+    |-- init.vim+<++Then the following Lua code will load `myluamodule.lua`:+>lua+    require(""myluamodule"")+<+Note the absence of a `.lua` extension.++Similarly, loading `other_modules/anothermodule.lua` is done via+>lua+    require('other_modules/anothermodule')+    -- or+    require('other_modules.anothermodule')+<++Note how ""submodules"" are just subdirectories; the `.` is equivalent to the+path separator `/` (even on Windows).++A folder containing an |init.lua| file can be required directly, without+having to specify the name of the file:+>lua+    require('other_modules') -- loads other_modules/init.lua+<+Requiring a nonexistent module or a module which contains syntax errors aborts+the currently executing script. `pcall()` may be used to catch such errors. The+following example tries to load the `module_with_error` and only calls one of+its functions if this succeeds and prints an error message otherwise:+>lua+    local ok, mymod = pcall(require, 'module_with_error')+    if not ok then+      print(""Module had an error"")+    else+      mymod.function()+    end+<+In contrast to |:source|, |require()| not only searches through all `lua/` directories+under |'runtimepath'|, it also cache the module on first use. Calling+`require()` a second time will therefore _not_ execute the script again and+instead return the cached file. To rerun the file, you need to remove it from+the cache manually first:+>lua+    package.loaded['myluamodule'] = nil+    require('myluamodule')    -- read and execute the module again from disk+<+------------------------------------------------------------------------------+See also:+��� |lua-require|+��� |luaref-pcall()|++==============================================================================+Using Vim commands and functions from Lua                  *lua-guide-vimscript*++All Vim commands and functions are accessible from Lua.++------------------------------------------------------------------------------+Vim commands                                            *lua-guide-vim-commands*++To run an arbitrary Vim command from Lua, pass it as a string to |vim.cmd()|:+>lua+    vim.cmd(""colorscheme habamax"")+<+Note that special characters will need to be escaped with backslashes:+>lua+    vim.cmd(""%s/\\Vfoo/bar/g"")+<+An alternative is to use a literal string (see |luaref-literal|) delimited by+double brackets `[[ ]]` as in+>lua+    vim.cmd([[%s/\Vfoo/bar/g]])+<+Another benefit of using literal strings is that they can be multiple lines;+this allows you to pass multiple commands to a single call of |vim.cmd()|:+>lua+    vim.cmd([[+      highlight Error guibg=red+      highlight link Warning Error+    ]])+<+This is the converse of |lua-heredoc| and allows you to include Lua code in+your `init.vim`.++If you want to build your Vim command programmatically, the following form can+be useful (all these are equivalent to the corresponding line above):+>lua+    vim.cmd.colorscheme(""habamax"")+    vim.cmd.highlight({ ""Error"", ""guibg=red"" })+    vim.cmd.highlight({ ""link"", ""Warning"", ""Error"" })+<+------------------------------------------------------------------------------+Vimscript functions                                    *lua-guide-vim-functions*++Use |vim.fn| to call Vimscript functions from Lua. Data types between Lua and+Vimscript are automatically converted:+>lua+    print(vim.fn.printf('Hello from %s', 'Lua'))++    local reversed_list = vim.fn.reverse({ 'a', 'b', 'c' })+    print(vim.inspect(reversed_list)) -- { ""c"", ""b"", ""a"" }++    local function print_stdout(chan_id, data, name)+      print(data[1])+    end++    vim.fn.jobstart('ls', { on_stdout = print_stdout })+    print(vim.fn.printf('Hello from %s', 'Lua'))+<+This works for both |builtin-functions| and |user-function|s.++Note that hashes (`#`) are not valid characters for identifiers in Lua, so,+e.g., |autoload| functions have to be called with this syntax:+>lua+    vim.fn['my#autoload#function']()+<+------------------------------------------------------------------------------+See also:+��� |builtin-functions|: alphabetic list of all Vimscript functions+��� |function-list|:     list of all Vimscript functions grouped by topic+��� |:runtime|:          run all Lua scripts matching a pattern in |'runtimepath'|+��� |package.path|:      list of all paths searched by `require()`++==============================================================================+Variables                                                  *lua-guide-variables*++Variables can be set and read using the following wrappers, which directly+correspond to their |variable-scope|:++��� |vim.g|   - global variables (|g:|)+��� |vim.b|   - variables for the current buffer (|b:|)+��� |vim.w|   - variables for the current window (|w:|)+��� |vim.t|   - variables for the current tabpage(|t:|)+��� |vim.v|   - predefined Vim variables (|v:|)+��� |vim.env| - environment variables defined in the editor session++Data types are converted automatically. For example:+>lua+    vim.g.some_global_variable = {+      key1 = ""value"",+      key2 = 300+    }++    print(vim.inspect(vim.g.some_global_variable))+    --> { key1 = ""value"", key2 = 300 }+<+You can target specific buffers (via number), windows (via |window-ID|), or+tabpages by indexing the wrappers:+>lua+    vim.b[2].myvar = 1            -- set myvar for buffer number 2+    vim.w[5].myothervar = true    -- set myothervar for window ID 5+<+Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using the syntax+>lua+    vim.g['my#variable'] = 1+<+Note that you cannot directly change fields of array variables. This won't+work:+>lua+    vim.g.some_global_variable.key2 = 400+    vim.pretty_print(vim.g.some_global_variable)+    --> { key1 = ""value"", key2 = 300 }+<+Instead, you need to create an intermediate Lua table and change this:+>lua+    local temp_table = vim.g.some_global_variable+    temp_table = keys = 400+    vim.g.some_global_variable = temp_table+    vim.pretty_print(vim.g.some_global_variable)+    --> { key1 = ""value"", key2 = 400 }+<+To delete a variable, simply set it to `nil`:+>lua+    vim.g.myvar = nil+<+------------------------------------------------------------------------------+See also:+��� |lua-vim-variables|++==============================================================================+Options                                                      *lua-guide-options*++There are two complementary ways of setting |options| via Lua.++------------------------------------------------------------------------------+vim.opt++The most convenient way for setting global and local options, e.g., in `init.lua`,+is through `vim.opt` and friends:++��� |vim.opt|        - behaves like |:set|+��� |vim.opt_global| - behaves like |:setglobal|+��� |vim.opt_local|  - behaves like |:setlocal|++For example, the Vimscript commands+>vim+    set smarttab+    set nosmarttab+<+are equivalent to+>lua+    vim.opt.smarttab = true+    vim.opt.smarttab = false+<+In particular, they allow an easy way to working with list-like, map-like, and+set-like options through Lua tables: Instead of+>vim+    set wildignore=*.o,*.a,__pycache__+    set listchars=space:_,tab:>~+    set formatoptions=njt+<+you can use+>lua+    vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }+    vim.opt.listchars = { space = '_', tab = '>~' }+    vim.opt.formatoptions = { n = true, j = true, t = true }+<+These wrappers also come with methods that work similarly to their |:set+=|,+|:set^=| and |:set-=| counterparts in Vimscript:+>lua+    vim.opt.shortmess:append({ I = true })+    vim.opt.wildignore:prepend('*.o')+    vim.opt.whichwrap:remove({ 'b', 's' })+<+The price to pay is that you cannot access the option values directly but must+use |vim.opt:get()|:+>lua+    print(vim.opt.smarttab)+    --> {...} (big table)+    print(vim.opt.smarttab:get())+    --> false+    vim.pretty_print(vim.opt.listchars:get())+    --> { space = '_', tab = '>~' }+<+------------------------------------------------------------------------------+vim.o++For this reason, there exists a more direct variable-like access using `vim.o`+and friends, similarly to how you can get and set options via `:echo &number`+and `:let &listchars='space:_,tab:>~'`:++��� |vim.o|  - behaves like |:set|+��� |vim.go| - behaves like |:setglobal|+��� |vim.bo| - for buffer-scoped options+��� |vim.wo| - for window-scoped options++For example:+>lua+    vim.o.smarttab = false -- :set nosmarttab+    print(vim.o.smarttab)+    --> false+    vim.o.listchars = 'space:_,tab:>~' -- :set listchars='space:_,tab:>~'+    print(vim.o.listchars)+    --> 'space:_,tab:>~'+    vim.o.isfname = vim.o.isfname .. ',@-@' -- :set isfname+=@-@+    print(vim.o.isfname)+    --> '@,48-57,/,.,-,_,+,,,#,$,%,~,=,@-@'+    vim.bo.shiftwidth = 4 -- :setlocal shiftwidth=4+    print(vim.bo.shiftwidth)+    --> 4+<+Just like variables, you can specify a buffer number or |window-ID| for buffer+and window options, respectively. If no number is given, the current buffer or+window is used:+>lua+    vim.bo[4].expandtab = true -- sets expandtab to true in buffer 4+    vim.wo.number = true       -- sets number to true in current window+    print(vim.wo[0].number)    --> true+<+------------------------------------------------------------------------------+See also:+��� |lua-options|++==============================================================================+Mappings                                                    *lua-guide-mappings*++You can map either Vim commands or Lua functions to key sequences.++------------------------------------------------------------------------------+Creating mappings                                       *lua-guide-mappings-set*++Mappings can be created using |vim.keymap.set()|. This function takes three+mandatory arguments:+��� {mode} is a string or a table of strings containing the mode+  prefix for which the mapping will take effect. The prefixes are the ones+  listed in |:map-modes|, or ""!"" for |:map!|, or empty string for |:map|.+��� {lhs} is a string with the key sequences that should trigger the mapping.+  An empty string is equivalent to |<Nop>|, which disables a key.+��� {rhs} is either a string with a Vim command or a Lua function that should+  be execucted when the {lhs} is entered.++Examples:+>lua+    -- Normal mode mapping for Vim command+    vim.keymap.set('n', '<Leader>ex1', '<cmd>echo ""Example 1""<cr>')+    -- Normal and Commandline mode mapping for Vim command+    vim.keymap.set({'n', 'c'}, '<Leader>ex2', '<cmd>echo ""Example 2""<cr>')+    -- Normal mode mapping for Lua function+    vim.keymap.set('n', '<Leader>ex3', vim.treesitter.start)+    -- Normal mode mapping for Lua function with arguments+    vim.keymap.set('n', '<Leader>ex4', function() print('Example 4') end)+<+You can map functions from Lua modules via+>lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action)+<+Note that this loads the plugin at the time the mapping is defined. If you+want to defer the loading to the time when the mapping is executed (as for+|autoload| functions), wrap it in `function() end`:+>lua+    vim.keymap.set('n', '<Leader>pl2', function() require('plugin').action() end)+<+The fourth, optional, argument is a table with keys that modify the behavior+of the mapping such as those from `:map-arguments`. The following are the most+useful options:+��� `buffer`: If given, only set the mapping for the buffer with the specified+  number; `0` or `true` means the current buffer. >lua+    -- set mapping for the current buffer+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = true})+    -- set mapping for the buffer number 4+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = 4})+<+��� `silent`: If set to `true`, suppress output such as error messages. >lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { silent = true})+<+��� `expr`: If set to `true`, do not execute the {rhs} but use the return value+  as input. Special |keycodes| are converted automatically. For example, the following+  mapping replaces <down> with <c-n> in the popupmenu only: >lua+    vim.keymap.set('c', '<down>', function()+      if vim.fn.pumvisible() == 1 then return '<c-n>' end+      return '<down>'+    end, { expr = true })+<+��� `desc`: A string that is shown when listing mappings with, e.g., |:map|.+  This is useful since Lua functions as {rhs} are otherwise only listed as+  `Lua: <number> <source file>:<line>`. Plugins should therefore always use this+  for mappings they create. >lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action,+      { desc = 'Execute action from plugin' })+<+��� `remap`: By default, all mappings are nonrecursive by default (i.e.,+  |vim.keymap.set()| behaves like |:noremap|). If the {rhs} is itself a mapping+  that should be executed, set `remap = true`: >lua+    vim.keymap.set('n', '<Leader>ex1', '<cmd>echo ""Example 1""<cr>')+    -- add a shorter mapping+    vim.keymap.set('n', 'e', '<Leader>ex1', { remap = true })+<+  The exception is if the {rhs} is a special |<Plug>| mapping, for which+  `remap = true` by default: >lua+    vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)')+<+------------------------------------------------------------------------------+Removing mappings                                       *lua-guide-mappings-del*++A specific mapping can be removed with |vim.keymap.del()|:+>lua+    vim.keymap.del('n', '<Leader>ex1')+    vim.keymap.del({'n', 'c'}, '<Leader>ex2', {buffer = true})+<+------------------------------------------------------------------------------+See also:+��� `vim.api.`|nvim_get_keymap()|     - return all global mapping+��� `vim.api.`|nvim_buf_get_keymap()| - return all mappings for buffer++==============================================================================+Autocommands                                            *lua-guide-autocommands*++An |autocommand| is a Vim command or a Lua function that is automatically+executed whenever one or more |events| are triggered, e.g., when a file is+read or written, or when a window is created. These are accessible from Lua+through the Neovim API.++------------------------------------------------------------------------------+Creating autocommands                             *lua-guide-autocommand-create*++Autocommands are created using `vim.api.`|nvim_create_autocmd()|, which takes+two mandatory arguments:+��� {event}: a string or table of strings containing the event(s) which should+           trigger the command or function.+��� {opts}:  a table with keys that control what should happen when the event(s)+           are triggered.++The most important options are:++��� `pattern`:  A string or table of strings containing the |autocmd-pattern|.+            Note: Environment variable like `$HOME` and `~` are not automatically+            expanded; you need to explicitly use `vim.fn.`|expand()| for this.+��� `command`:  A string containing a Vim command.+��� `callback`: A Lua function.++You must specify one and only one of `command` and `callback`. If `pattern` is+omitted, it defaults to `pattern = '*'`.+Examples:+>lua+    vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {+      pattern = {""*.c"", ""*.h""},+      command = ""echo 'Entering a C or C++ file'"",+    })++    -- Same autocommand written with a Lua function instead+    vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {+      pattern = {""*.c"", ""*.h""},+      callback = function() print(""Entering a C or C++ file"") end,+    })++    -- User event triggered by MyPlugin+    vim.api.nvim_create_autocmd(""User"", {+      pattern = ""MyPlugin"",+      callback = function() print(""My Plugin Works!"") end,+    })+<++Neovim will always call a Lua function with a single table containing information+about the triggered autocommand. The most useful keys are+��� `match`: a string that matched the `pattern` (see |<amatch>|)+��� `buf`:   the number of the buffer the event was triggered in (see |<abuf>|)+��� `file`:  the file name of the buffer the event was triggered in (see |<afile>|)+��� `data`:  a table with other relevant data that is passed for some events++For example, this allows you to set buffer-local mappings for some filetypes:+>lua+    vim.api.nvim.create_autocmd(""FileType"", {+      pattern = ""lua"",","It's a `FileType` autocommand, so the pattern _is_ the filetype, not a path glob.",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1039086091,2022-12-05T02:10:15Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,346 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = {""""}++  local path_sep = ""[/\\]""+  local non_path_sep = ""[^/\\]""++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p..chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = """"+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = """"+      else+        if c == ""{"" then+          in_braces = true+        elseif c == ""}"" then+          in_braces = false+        elseif c == ""["" then+          in_brackets = true+        elseif c == ""]"" then+          in_brackets = false+        end+        segment = segment..c+      end+    end+    if segment ~= """" then table.insert(segments, segment) end+    return segments+  end++  local function escape(c)+    if c == ""?"" or c == ""."" or c == ""("" or c == "")"" or c == ""%"" or+       c == ""["" or c == ""]"" or c == ""*"" or c == ""+"" or c == ""-"" then+      return ""%""..c+    end+    return c+  end++  local segments = split(pattern, ""/"")+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == ""**"" then+      local chunks = {+        path_sep..""-"",+        "".-""..path_sep,+      }+      if last_seg then+        chunks = { "".-"" }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = """"+      local in_brackets = false+      local bracket_val = """"+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= ""}"" and in_braces then+          brace_val = brace_val..char+        else+          if in_brackets and (char ~= ""]"" or bracket_val == """") then+            local res+            if char == ""-"" then+              res = char+            elseif bracket_val ~= """" and char == ""!"" then+              res = ""^""+            elseif char == ""**"" then+              res = """"+            else+              res = escape(char)+            end+            bracket_val = bracket_val..res+          else+            if char == ""{"" then+              in_braces = true+            elseif char == ""["" then+              in_brackets = true+            elseif char == ""}"" then+              local choices = split(brace_val, "","")+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = """"+            elseif char == ""]"" then+              append({""[""..bracket_val..""]""})+              in_brackets = false+              bracket_val = """"+            elseif char == ""?"" then+              append({non_path_sep})+            elseif char == ""*"" then+              append({non_path_sep..""-""})+            else+              append({escape(char)})+            end+          end+        end+      end++      if not last_seg and (segments[i+1] ~= ""**"" or i+1 < #segments) then+        append({path_sep})+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return bool Whether or not pattern matches s.+local function match(pattern, s)+  if type(pattern) == ""string"" then+    pattern = parse(pattern)+  end+  -- Since Lua's built-in string pattern matching does not have an alternate+  -- operator like '|', `parse` will construct one pattern for each possible+  -- alternative. Any pattern that matches thus matches the glob.+  for _, p in ipairs(pattern) do+    if s:match(""^""..p..""$"") then return true end+  end+  return false+end++---@private+--- Joins filepath elements by platform-specific separator.+---+---@param args ... The path elements. The first element must be absolute.+---@return string The joined path.+local function filepath_join(...)+  local dir = ...+  return table.concat({...}, dir:match('^([a-zA-Z]:)(.*)') and ""\\"" or ""/"")+end++-- Cache of libuv handles per directory, per LSP client, per registration ID.+local watched_dirs = {}++local change_queue = {}+local change_cache = {}+local queue_timers = {}++---@private+--- Creates callbacks invoked on watched file events.+---+---@param dir string Absolute path to the watched directory.+---@param client_id number The LSP client's ID.+---@param reg_id string The ID used to register the request.+---@return function The callback invoked on watched file events.+local function get_callback(dir, client_id, reg_id)+  return function(filename, events)+    local path = filepath_join(dir, filename)++    local type = events.change and protocol.FileChangeType.Changed or 0+    if events.rename then+      local _, err, errname = uv.fs_stat(path)+      if errname == ""ENOENT"" then+        type = protocol.FileChangeType.Deleted+      else+        assert(not err, err)+        type = protocol.FileChangeType.Created+      end+    end","This translates the libuv event into an LSP change type. There is a race here where if a file is created and deleted in quick succession, the sequence of changes might contain two ""deleted"" events if the `stat` call for the actual ""created"" event happens after the file is already gone.I wonder how big of an issue this is depending on how robust language servers are to these kinds of inconsistencies. ",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1039086418,2022-12-05T02:11:12Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,346 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = {""""}++  local path_sep = ""[/\\]""+  local non_path_sep = ""[^/\\]""++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p..chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = """"+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = """"+      else+        if c == ""{"" then+          in_braces = true+        elseif c == ""}"" then+          in_braces = false+        elseif c == ""["" then+          in_brackets = true+        elseif c == ""]"" then+          in_brackets = false+        end+        segment = segment..c+      end+    end+    if segment ~= """" then table.insert(segments, segment) end+    return segments+  end++  local function escape(c)+    if c == ""?"" or c == ""."" or c == ""("" or c == "")"" or c == ""%"" or+       c == ""["" or c == ""]"" or c == ""*"" or c == ""+"" or c == ""-"" then+      return ""%""..c+    end+    return c+  end++  local segments = split(pattern, ""/"")+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == ""**"" then+      local chunks = {+        path_sep..""-"",+        "".-""..path_sep,+      }+      if last_seg then+        chunks = { "".-"" }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = """"+      local in_brackets = false+      local bracket_val = """"+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= ""}"" and in_braces then+          brace_val = brace_val..char+        else+          if in_brackets and (char ~= ""]"" or bracket_val == """") then+            local res+            if char == ""-"" then+              res = char+            elseif bracket_val ~= """" and char == ""!"" then+              res = ""^""+            elseif char == ""**"" then+              res = """"+            else+              res = escape(char)+            end+            bracket_val = bracket_val..res+          else+            if char == ""{"" then+              in_braces = true+            elseif char == ""["" then+              in_brackets = true+            elseif char == ""}"" then+              local choices = split(brace_val, "","")+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = """"+            elseif char == ""]"" then+              append({""[""..bracket_val..""]""})+              in_brackets = false+              bracket_val = """"+            elseif char == ""?"" then+              append({non_path_sep})+            elseif char == ""*"" then+              append({non_path_sep..""-""})+            else+              append({escape(char)})+            end+          end+        end+      end++      if not last_seg and (segments[i+1] ~= ""**"" or i+1 < #segments) then+        append({path_sep})+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return bool Whether or not pattern matches s.+local function match(pattern, s)+  if type(pattern) == ""string"" then+    pattern = parse(pattern)+  end+  -- Since Lua's built-in string pattern matching does not have an alternate+  -- operator like '|', `parse` will construct one pattern for each possible+  -- alternative. Any pattern that matches thus matches the glob.+  for _, p in ipairs(pattern) do+    if s:match(""^""..p..""$"") then return true end+  end+  return false+end++---@private+--- Joins filepath elements by platform-specific separator.+---+---@param args ... The path elements. The first element must be absolute.+---@return string The joined path.+local function filepath_join(...)+  local dir = ...+  return table.concat({...}, dir:match('^([a-zA-Z]:)(.*)') and ""\\"" or ""/"")+end++-- Cache of libuv handles per directory, per LSP client, per registration ID.+local watched_dirs = {}++local change_queue = {}+local change_cache = {}+local queue_timers = {}++---@private+--- Creates callbacks invoked on watched file events.+---+---@param dir string Absolute path to the watched directory.+---@param client_id number The LSP client's ID.+---@param reg_id string The ID used to register the request.+---@return function The callback invoked on watched file events.+local function get_callback(dir, client_id, reg_id)+  return function(filename, events)+    local path = filepath_join(dir, filename)++    local type = events.change and protocol.FileChangeType.Changed or 0+    if events.rename then+      local _, err, errname = uv.fs_stat(path)+      if errname == ""ENOENT"" then+        type = protocol.FileChangeType.Deleted+      else+        assert(not err, err)+        type = protocol.FileChangeType.Created+      end+    end++    local matches_filter = false+    local filters = watched_dirs[dir].callbacks[client_id][reg_id].filters+    for _, filter in ipairs(filters) do+      if match(filter.pattern, path) and math.floor(filter.kind / (2^(type-1))) % 2 == 1 then+        matches_filter = true+        break+      end+    end+    if not matches_filter then return end++    local change = {+      uri = vim.uri_from_fname(path),+      type = type,+    }+    change_cache[client_id] = change_cache[client_id] or {}+    local last_type = change_cache[client_id][change.uri]+    if not last_type or last_type ~= change.type then+      change_queue[client_id] = change_queue[client_id] or {}+      table.insert(change_queue[client_id], change)+      change_cache[client_id][change.uri] = change.type+    end+    if not queue_timers[client_id] then+      local t = uv.new_timer()+      t:start(100, 0, function()+        t:close()+        vim.lsp.get_client_by_id(client_id).notify(""workspace/didChangeWatchedFiles"", {+          changes = change_queue[client_id],+        })+        change_queue[client_id] = nil+        change_cache[client_id] = nil+        queue_timers[client_id] = nil+      end)+      queue_timers[client_id] = t+    end+  end+end++-- Never create watchers for directories matching these patterns. Similar+-- to vscode's files.watcherExclude setting.+local excludes = {+  parse(""**/.git/objects/**""),+  parse(""**/.git/subtree-cache/**""),+  parse(""**/node_modules/*/**""),+  parse(""**/.hg/store/**""),+}++---@private+--- Creates libuv fs_events handles.+---+---@param dir string Absolute path to the directory to watch.+---@param pattern string|table The LSP glob pattern (raw or parsed) to match against.+---@param kind number The LSP WatchKind value.+---@param client_id number The LSP client's ID.+---@param reg_id string The ID used to register the request.+local function fsevent_ensure_recursive(dir, pattern, kind, client_id, reg_id)+  -- Recursive flag for libuv watcher not implemented on linux+  local recursive_watch = vim.fn.has(""mac"") == 1 or vim.fn.has(""win32"") == 1++  if not watched_dirs[dir] then+    local fsevent, fserr = uv.new_fs_event()+    assert(not fserr, fserr)+    watched_dirs[dir] = {+      fsevent = fsevent,+      callbacks = {},+    }+    fsevent:start(dir, { recursive = recursive_watch }, function(err, filename, events)+      assert(not err, err)+      for _, reg in pairs(watched_dirs[dir].callbacks[client_id]) do+        reg.callback(filename, events)+      end+    end)+  end++  watched_dirs[dir].callbacks[client_id] = watched_dirs[dir].callbacks[client_id] or {}+  watched_dirs[dir].callbacks[client_id][reg_id] = watched_dirs[dir].callbacks[client_id][reg_id] or {}+  watched_dirs[dir].callbacks[client_id][reg_id].callback = watched_dirs[dir].callbacks[client_id][reg_id].callback or get_callback(dir, client_id, reg_id)","I understand this kind of pattern to initialize nested objects is very ugly, so any pointers to clean this up are most welcome!",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1039088502,2022-12-05T02:17:05Z,test/functional/plugin/lsp_spec.lua,"@@ -3623,4 +3623,103 @@ describe('LSP', function()       eq(expected, result)     end)   end)++  describe('vim.lsp._watchfiles', function()+    it('should send workspace/didChangeWatchedFiles when watched files change', function()","At a high level, this test:1. registers the capability dynamically, pointing at a temporary directory2. generates some filesystem events3. checks that the expected events are sent4. re-registers to watch some different files5. generates more filesystem events6. checks that the expected events are received",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1039090352,2022-12-05T02:22:38Z,test/functional/fixtures/fake-lsp-server.lua,"@@ -927,6 +927,65 @@ function tests.basic_formatting()   } end +function tests.basic_watchfiles()+  skeleton {+    on_init = function()+      return {+        capabilities = {+          documentFormattingProvider = true,+        }+      }+    end;+    body = function()+      local root_dir+      root_dir = os.tmpname()","I think it makes the most sense to have created the `root_dir` in the client part of the test, but I couldn't find a simple way of sharing its location with the server without hardcoding it. Sharing it from the server to the client like this did seem to work though, but makes it less practical to use [`helpers.tmpname`](https://github.com/nojnhuh/neovim/blob/232fe82eb106ca955fa5dc4815ef3611b1ee744c/test/helpers.lua#L304) which seems preferable over `os.tmpname`.Overall, this test server is very tightly coupled with the actual test, so any advice to help make this more flexible is much appreciated.",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1039095507,2022-12-05T02:36:17Z,test/functional/plugin/lsp_spec.lua,"@@ -3623,4 +3623,103 @@ describe('LSP', function()       eq(expected, result)     end)   end)++  describe('vim.lsp._watchfiles', function()+    it('should send workspace/didChangeWatchedFiles when watched files change', function()+      local expected_handlers = {+        {NIL, {}, {method=""shutdown"", client_id=1}};+        {NIL, {}, {method=""reregister"", client_id=1}};+        {NIL, {}, {method=""register"", client_id=1}};+        {NIL, nil, {method=""get_root"", bufnr=1, client_id=1}};+      }+      local client+      local root_dir+      test_rpc_server {+        test_name = ""basic_watchfiles"";+        on_init = function(_client, _)+          client = _client+          client.request('get_root')+        end;+        on_exit = function(code, signal)+          eq(0, code, ""exit code"")+          eq(0, signal, ""exit signal"")+        end;+        on_handler = function(err, result, ctx)+          if ctx.method == 'get_root' then+            root_dir = result+            result = nil -- don't make an assertion on this value+          elseif ctx.method == 'register' then+            exec_lua([[+            local root_dir = ...+            vim.lsp.handlers[""client/registerCapability""](NIL, {+              registrations = {+                {+                  id = ""basic_watchfiles_0"",+                  method = ""workspace/didChangeWatchedFiles"",+                  registerOptions = {+                    watchers = {+                      {+                        globPattern = {+                          baseUri = vim.uri_from_fname(root_dir),+                          pattern = ""**/*.watch"",+                        },+                        kind = 7,+                      },+                    },+                  },+                },+              },+            }, {client_id=1})+            ]], root_dir)+            write_file(root_dir..'/test.nowatch', '')+            os.remove(root_dir..'/test.nowatch')+            write_file(root_dir..'/test.watch', '')+            write_file(root_dir..'/test.watch', 'some change')+            os.remove(root_dir..'/test.watch')","This sequence of events runs into the race condition I described above where a ""created"" event followed by a ""deleted"" event might end up being interpreted as a ""deleted"" event. This makes the test very flaky for me locally. Any suggestions to make this test more deterministic?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21296,1039133805,2022-12-05T04:33:56Z,runtime/doc/map.txt,"@@ -1450,14 +1454,16 @@ which by default correspond to the current line, last line and the whole buffer, relate to arguments, (loaded) buffers, windows or tab pages.  Possible values are (second column is the short name used in listing):-    -addr=lines		  line	Range of lines (this is the default)+    -addr=lines		  	Range of lines (this is the default for -range)","Mentioning `line` here is wrong. It only applies to API, not listing commands.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21283,1039886266,2022-12-05T17:30:44Z,runtime/lua/vim/secure.lua,"@@ -80,34 +80,27 @@ function M.read(path)   end    -- File either does not exist in trust database or the hash does not match-  local choice = vim.fn.confirm(+  local ok, result = pcall(+    vim.fn.confirm,     string.format('%s is not trusted.', fullpath),     '&ignore\n&view\n&deny\n&allow',     1   ) -  if choice == 0 or choice == 1 then+  if not ok and result ~= 'Keyboard interrupt' then+    error(result)+  elseif not ok or result == 0 or result == 1 then     -- Cancelled or ignored     return nil-  elseif choice == 2 then+  elseif result == 2 then     -- View-    vim.cmd('new')-    local buf = vim.api.nvim_get_current_buf()-    local lines = vim.split(string.gsub(contents, '\n$', ''), '\n')-    vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)-    vim.bo[buf].bufhidden = 'hide'-    vim.bo[buf].buftype = 'nofile'-    vim.bo[buf].swapfile = false-    vim.bo[buf].modeline = false-    vim.bo[buf].buflisted = false-    vim.bo[buf].readonly = true-    vim.bo[buf].modifiable = false+    vim.cmd('sview ' .. fullpath)","The point of showing the file is so that the user can inspect it and make a decision or not. If the file contents on disk change somehow then the user is making a decision on something different than they are actually seeing. This seems like a bad user experience to me, and I don't see what the upside is, other than saving a few lines of code.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1040784634,2022-12-06T10:31:42Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,660 @@+local api = vim.api+local handlers = require('vim.lsp.handlers')+local util = require('vim.lsp.util')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STClientState+--- @field namespace number+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult++---@class STHighlighter+---@field active table<number, STHighlighter>+---@field bufnr number+---@field augroup number augroup for buffer events+---@field debounce number milliseconds to debounce requests for new tokens+---@field timer table uv_timer for debouncing requests for new tokens+---@field client_state table<number, STClientState>+local STHighlighter = { active = {} }++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++--- Extracts modifier strings from the encoded number in the token array+---+---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  ---@private+  local function _get_bit(n, k)+    --TODO(jdrouhard): remove once `bit` module is available for non-LuaJIT+    if _G.bit then+      return _G.bit.band(_G.bit.rshift(n, k), 1)+    else+      return math.floor((n / math.pow(2, k)) % 2)+    end+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local b = _get_bit(x, i)+    if b == 1 then+      modifiers[#modifiers + 1] = modifiers_table[i + 1]+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+---+---@private+---@return STTokenRange[]+local function tokens_to_ranges(data, bufnr, client)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function _get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = _get_byte_pos(start_char)+    local end_col = _get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++--- Construct a new STHighlighter for the buffer+---+---@private+---@param bufnr number+function STHighlighter.new(bufnr)+  local self = setmetatable({}, { __index = STHighlighter })++  self.bufnr = bufnr+  self.augroup = api.nvim_create_augroup('vim_lsp_semantic_tokens:' .. bufnr, { clear = true })+  self.client_state = {}++  STHighlighter.active[bufnr] = self++  api.nvim_buf_attach(bufnr, false, {+    on_lines = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if not highlighter then+        return true+      end+      highlighter:on_change()+    end,+    on_reload = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:reset()+        highlighter:send_request()+      end+    end,+    on_detach = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:destroy()+      end+    end,+  })++  api.nvim_create_autocmd({ 'BufWinEnter', 'InsertLeave' }, {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function()+      self:send_request()+    end,+  })++  api.nvim_create_autocmd('LspDetach', {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function(args)+      self:detach(args.data.client_id)+      if vim.tbl_isempty(self.client_state) then+        self:destroy()+      end+    end,+  })++  return self+end++---@private+function STHighlighter:destroy()+  for client_id, _ in pairs(self.client_state) do+    self:detach(client_id)+  end++  api.nvim_del_augroup_by_id(self.augroup)+  STHighlighter.active[self.bufnr] = nil+end++---@private+function STHighlighter:attach(client_id)+  local state = self.client_state[client_id]+  if not state then+    state = {+      namespace = api.nvim_create_namespace('vim_lsp_semantic_tokens:' .. client_id),+      active_request = {},+      current_result = {},+    }+    self.client_state[client_id] = state+  end+end++---@private+function STHighlighter:detach(client_id)+  local state = self.client_state[client_id]+  if state then+    --TODO: delete namespace if/when that becomes possible+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    self.client_state[client_id] = nil+  end+end++--- This is the entry point for getting all the tokens in a buffer.+---+--- For the given clients (or all attached, if not provided), this sends a request+--- to ask for semantic tokens. If the server supports delta requests, that will+--- be prioritized if we have a previous requestId and token array.+---+--- This function will skip servers where there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+function STHighlighter:send_request()+  local version = util.buf_versions[self.bufnr]++  self:reset_timer()++  for client_id, state in pairs(self.client_state) do+    local client = vim.lsp.get_client_by_id(client_id)++    local current_result = state.current_result+    local active_request = state.active_request++    -- Only send a request for this client if the current result is out of date and+    -- there isn't a current a request in flight for this version+    if client and current_result.version ~= version and active_request.version ~= version then+      -- cancel stale in-flight request+      if active_request.request_id then+        client.cancel_request(active_request.request_id)+        active_request = {}+        state.active_request = active_request+      end++      local spec = client.server_capabilities.semanticTokensProvider.full+      local hasEditProvider = type(spec) == 'table' and spec.delta++      local params = { textDocument = util.make_text_document_params(self.bufnr) }+      local method = 'textDocument/semanticTokens/full'++      if hasEditProvider and current_result.result_id then+        method = method .. '/delta'+        params.previousResultId = current_result.result_id+      end+      local success, request_id = client.request(method, params, function(err, response, ctx)+        -- add captured version to ctx+        ctx.version = version++        local handler = client.handlers[method] or handlers[method]+        handler(err, response, ctx)+      end, self.bufnr)++      if success then+        active_request.request_id = request_id+        active_request.version = version+      end+    end+  end+end++--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+function STHighlighter:process_response(response, client, version)+  local state = self.client_state[client.id]+  if not state then+    return+  end++  -- ignore stale responses+  if version ~= state.active_request.version then+    return+  end++  -- reset active request+  state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function _splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = _splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = state.current_result+  current_result.version = version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(tokens, self.bufnr, client)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+--- If there is a current result for the buffer and the version matches the+--- current document version, then the tokens are valid and can be applied. As+--- the buffer is drawn, this function will add extmark highlights for every+--- token in the range of visible lines. Once a highlight has been added, it+--- sticks around until the document changes and there's a new set of matching+--- highlight tokens available.+---+--- If this is the first time a buffer is being drawn with a new set of+--- highlights for the current document version, the namespace is cleared to+--- remove extmarks from the last version. It's done here instead of the response+--- handler to avoid the ""blink"" that occurs due to the timing between the+--- response handler and the actual redraw.+---+---@private+function STHighlighter:on_win(topline, botline)+  for _, state in pairs(self.client_state) do+    local current_result = state.current_result+    if current_result.version == util.buf_versions[self.bufnr] then+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          -- `strict = false` is necessary here for the 1% of cases where the+          -- current result doesn't actually match the buffer contents. Some+          -- LSP servers can respond with stale tokens on requests if they are+          -- still processing changes from a didChange notification.+          --+          -- LSP servers that do this _should_ follow up known stale responses+          -- with a refresh notification once they've finished processing the+          -- didChange notification, which would re-synchronize the tokens from+          -- our end.+          --+          -- The server I know of that does this is clangd when the preamble of+          -- a file changes and the token request is processed with a stale+          -- preamble while the new one is still being built. Once the preamble+          -- finishes, clangd sends a refresh request which lets the client+          -- re-synchronize the tokens.+          api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {+            hl_group = '@' .. token.type,+            end_col = token.end_col,+            priority = vim.highlight.priorities.semantic_tokens,+            strict = false,+          })++          --TODO(jdrouhard): do something with the modifiers++          token.extmark_added = true+        end+      end+    end+  end+end++--- Reset the buffer's highlighting state and clears the extmark highlights.+---+---@private+function STHighlighter:reset()+  for client_id, state in pairs(self.client_state) do+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    state.current_result = {}+    if state.active_request.request_id then+      local client = vim.lsp.get_client_by_id(client_id)+      assert(client)+      client.cancel_request(state.active_request.request_id)+      state.active_request = {}+    end+  end+end++--- Mark a client's results as dirty. This method will cancel any active+--- requests to the server and pause new highlights from being added+--- in the on_win callback. The rest of the current results are saved+--- in case the server supports delta requests.+---+---@private+---@param client_id number+function STHighlighter:mark_dirty(client_id)+  local state = self.client_state[client_id]+  assert(state)++  -- if we clear the version from current_result, it'll cause the+  -- next request to be sent and will also pause new highlights+  -- from being added in on_win until a new result comes from+  -- the server+  if state.current_result then+    state.current_result.version = nil+  end++  if state.active_request.request_id then+    local client = vim.lsp.get_client_by_id(client_id)+    assert(client)+    client.cancel_request(state.active_request.request_id)+    state.active_request = {}+  end+end++---@private+function STHighlighter:on_change()+  self:reset_timer()+  if self.debounce > 0 then+    self.timer = vim.defer_fn(function()+      self:send_request()+    end, self.debounce)+  else+    self:send_request()+  end+end++---@private+function STHighlighter:reset_timer()+  local timer = self.timer+  if timer then+    self.timer = nil+    if not timer:is_closing() then+      timer:stop()+      timer:close()+    end+  end+end++local M = {}++--- Start the semantic token highlighting engine for the given buffer with the+--- given client. The client must already be attached to the buffer.+---+--- NOTE: This is currently called automatically by |vim.lsp.buf_attach_client()|. To+--- opt-out of semantic highlighting with a server that supports it, you can+--- delete the semanticTokensProvider table from the {server_capabilities} of+--- your client in your |LspAttach| callback or your configuration's+--- `on_attach` callback.+---+--- <pre>+--- client.server_capabilities.semanticTokensProvider = nil+--- </pre>",```suggestion--- <pre>lua---   client.server_capabilities.semanticTokensProvider = nil--- </pre>```(gives Lua syntax highlighting in generated docs),
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21293,1041542680,2022-12-06T22:43:10Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,346 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = {""""}++  local path_sep = ""[/\\]""+  local non_path_sep = ""[^/\\]""++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p..chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = """"+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = """"+      else+        if c == ""{"" then+          in_braces = true+        elseif c == ""}"" then+          in_braces = false+        elseif c == ""["" then+          in_brackets = true+        elseif c == ""]"" then+          in_brackets = false+        end+        segment = segment..c+      end+    end+    if segment ~= """" then table.insert(segments, segment) end+    return segments+  end++  local function escape(c)+    if c == ""?"" or c == ""."" or c == ""("" or c == "")"" or c == ""%"" or+       c == ""["" or c == ""]"" or c == ""*"" or c == ""+"" or c == ""-"" then+      return ""%""..c+    end+    return c+  end++  local segments = split(pattern, ""/"")+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == ""**"" then+      local chunks = {+        path_sep..""-"",+        "".-""..path_sep,+      }+      if last_seg then+        chunks = { "".-"" }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = """"+      local in_brackets = false+      local bracket_val = """"+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= ""}"" and in_braces then+          brace_val = brace_val..char+        else+          if in_brackets and (char ~= ""]"" or bracket_val == """") then+            local res+            if char == ""-"" then+              res = char+            elseif bracket_val ~= """" and char == ""!"" then+              res = ""^""+            elseif char == ""**"" then+              res = """"+            else+              res = escape(char)+            end+            bracket_val = bracket_val..res+          else+            if char == ""{"" then+              in_braces = true+            elseif char == ""["" then+              in_brackets = true+            elseif char == ""}"" then+              local choices = split(brace_val, "","")+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = """"+            elseif char == ""]"" then+              append({""[""..bracket_val..""]""})+              in_brackets = false+              bracket_val = """"+            elseif char == ""?"" then+              append({non_path_sep})+            elseif char == ""*"" then+              append({non_path_sep..""-""})+            else+              append({escape(char)})+            end+          end+        end+      end++      if not last_seg and (segments[i+1] ~= ""**"" or i+1 < #segments) then+        append({path_sep})+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return bool Whether or not pattern matches s.+local function match(pattern, s)+  if type(pattern) == ""string"" then+    pattern = parse(pattern)+  end+  -- Since Lua's built-in string pattern matching does not have an alternate+  -- operator like '|', `parse` will construct one pattern for each possible+  -- alternative. Any pattern that matches thus matches the glob.+  for _, p in ipairs(pattern) do+    if s:match(""^""..p..""$"") then return true end+  end+  return false+end++---@private+--- Joins filepath elements by platform-specific separator.+---+---@param args ... The path elements. The first element must be absolute.+---@return string The joined path.+local function filepath_join(...)+  local dir = ...+  return table.concat({...}, dir:match('^([a-zA-Z]:)(.*)') and ""\\"" or ""/"")+end++-- Cache of libuv handles per directory, per LSP client, per registration ID.+local watched_dirs = {}++local change_queue = {}+local change_cache = {}+local queue_timers = {}++---@private+--- Creates callbacks invoked on watched file events.+---+---@param dir string Absolute path to the watched directory.+---@param client_id number The LSP client's ID.+---@param reg_id string The ID used to register the request.+---@return function The callback invoked on watched file events.+local function get_callback(dir, client_id, reg_id)+  return function(filename, events)+    local path = filepath_join(dir, filename)++    local type = events.change and protocol.FileChangeType.Changed or 0+    if events.rename then+      local _, err, errname = uv.fs_stat(path)+      if errname == ""ENOENT"" then+        type = protocol.FileChangeType.Deleted+      else+        assert(not err, err)+        type = protocol.FileChangeType.Created+      end+    end++    local matches_filter = false+    local filters = watched_dirs[dir].callbacks[client_id][reg_id].filters+    for _, filter in ipairs(filters) do+      if match(filter.pattern, path) and math.floor(filter.kind / (2^(type-1))) % 2 == 1 then+        matches_filter = true+        break+      end+    end+    if not matches_filter then return end++    local change = {+      uri = vim.uri_from_fname(path),+      type = type,+    }+    change_cache[client_id] = change_cache[client_id] or {}+    local last_type = change_cache[client_id][change.uri]+    if not last_type or last_type ~= change.type then+      change_queue[client_id] = change_queue[client_id] or {}+      table.insert(change_queue[client_id], change)+      change_cache[client_id][change.uri] = change.type+    end+    if not queue_timers[client_id] then+      local t = uv.new_timer()+      t:start(100, 0, function()","`schedule_wrap` creates a new function that would still need to be called. There's `vim.schedule` to defer execution to the main loop. Or if it can run in the luv loop you could use `vim.defer_fn`, which is a shortcut for the timer pattern you use here. ",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1041674742,2022-12-07T02:04:16Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,346 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = {""""}++  local path_sep = ""[/\\]""+  local non_path_sep = ""[^/\\]""++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p..chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = """"+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = """"+      else+        if c == ""{"" then+          in_braces = true+        elseif c == ""}"" then+          in_braces = false+        elseif c == ""["" then+          in_brackets = true+        elseif c == ""]"" then+          in_brackets = false+        end+        segment = segment..c+      end+    end+    if segment ~= """" then table.insert(segments, segment) end+    return segments+  end++  local function escape(c)+    if c == ""?"" or c == ""."" or c == ""("" or c == "")"" or c == ""%"" or+       c == ""["" or c == ""]"" or c == ""*"" or c == ""+"" or c == ""-"" then+      return ""%""..c+    end+    return c+  end++  local segments = split(pattern, ""/"")+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == ""**"" then+      local chunks = {+        path_sep..""-"",+        "".-""..path_sep,+      }+      if last_seg then+        chunks = { "".-"" }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = """"+      local in_brackets = false+      local bracket_val = """"+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= ""}"" and in_braces then+          brace_val = brace_val..char+        else+          if in_brackets and (char ~= ""]"" or bracket_val == """") then+            local res+            if char == ""-"" then+              res = char+            elseif bracket_val ~= """" and char == ""!"" then+              res = ""^""+            elseif char == ""**"" then+              res = """"+            else+              res = escape(char)+            end+            bracket_val = bracket_val..res+          else+            if char == ""{"" then+              in_braces = true+            elseif char == ""["" then+              in_brackets = true+            elseif char == ""}"" then+              local choices = split(brace_val, "","")+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = """"+            elseif char == ""]"" then+              append({""[""..bracket_val..""]""})+              in_brackets = false+              bracket_val = """"+            elseif char == ""?"" then+              append({non_path_sep})+            elseif char == ""*"" then+              append({non_path_sep..""-""})+            else+              append({escape(char)})+            end+          end+        end+      end++      if not last_seg and (segments[i+1] ~= ""**"" or i+1 < #segments) then+        append({path_sep})+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509",Just made that change and added a few tests for this. I'll keep adding more once we're happy with the pattern there.,
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1041745082,2022-12-07T04:29:29Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,644 @@+local api = vim.api+local handlers = require('vim.lsp.handlers')+local util = require('vim.lsp.util')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STClientState+--- @field namespace number+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult++---@class STHighlighter+---@field active table<number, STHighlighter>+---@field bufnr number+---@field augroup number augroup for buffer events+---@field debounce number milliseconds to debounce requests for new tokens+---@field timer table uv_timer for debouncing requests for new tokens+---@field client_state table<number, STClientState>+local STHighlighter = { active = {} }++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++--- Extracts modifier strings from the encoded number in the token array+---+---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  ---@private+  local function _get_bit(n, k)+    --TODO(jdrouhard): remove once `bit` module is available for non-LuaJIT+    if _G.bit then+      return _G.bit.band(_G.bit.rshift(n, k), 1)+    else+      return math.floor((n / math.pow(2, k)) % 2)+    end+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local b = _get_bit(x, i)+    if b == 1 then+      modifiers[#modifiers + 1] = modifiers_table[i + 1]+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+---+---@private+---@return STTokenRange[]+local function tokens_to_ranges(data, bufnr, client)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function _get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = _get_byte_pos(start_char)+    local end_col = _get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++--- Construct a new STHighlighter for the buffer+---+---@private+---@param bufnr number+function STHighlighter.new(bufnr)+  local self = setmetatable({}, { __index = STHighlighter })++  self.bufnr = bufnr+  self.augroup = api.nvim_create_augroup('vim_lsp_semantic_tokens:' .. bufnr, { clear = true })+  self.client_state = {}++  STHighlighter.active[bufnr] = self++  api.nvim_buf_attach(bufnr, false, {+    on_lines = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if not highlighter then+        return true+      end+      highlighter:on_change()+    end,+    on_reload = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:reset()+        highlighter:send_request()+      end+    end,+    on_detach = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:destroy()+      end+    end,+  })++  api.nvim_create_autocmd({ 'BufWinEnter', 'InsertLeave' }, {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function()+      self:send_request()+    end,+  })++  api.nvim_create_autocmd('LspDetach', {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function(args)+      self:detach(args.data.client_id)+      if vim.tbl_isempty(self.client_state) then+        self:destroy()+      end+    end,+  })++  return self+end++---@private+function STHighlighter:destroy()+  for client_id, _ in pairs(self.client_state) do+    self:detach(client_id)+  end++  api.nvim_del_augroup_by_id(self.augroup)+  STHighlighter.active[self.bufnr] = nil+end++---@private+function STHighlighter:attach(client_id)+  local state = self.client_state[client_id]+  if not state then+    state = {+      namespace = api.nvim_create_namespace('vim_lsp_semantic_tokens:' .. client_id),+      active_request = {},+      current_result = {},+    }+    self.client_state[client_id] = state+  end+end++---@private+function STHighlighter:detach(client_id)+  local state = self.client_state[client_id]+  if state then+    --TODO: delete namespace if/when that becomes possible+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    self.client_state[client_id] = nil+  end+end++--- This is the entry point for getting all the tokens in a buffer.+---+--- For the given clients (or all attached, if not provided), this sends a request+--- to ask for semantic tokens. If the server supports delta requests, that will+--- be prioritized if we have a previous requestId and token array.+---+--- This function will skip servers where there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+function STHighlighter:send_request()+  local version = util.buf_versions[self.bufnr]++  self:reset_timer()++  for client_id, state in pairs(self.client_state) do+    local client = vim.lsp.get_client_by_id(client_id)++    local current_result = state.current_result+    local active_request = state.active_request++    -- Only send a request for this client if the current result is out of date and+    -- there isn't a current a request in flight for this version+    if client and current_result.version ~= version and active_request.version ~= version then+      -- cancel stale in-flight request+      if active_request.request_id then+        client.cancel_request(active_request.request_id)+        active_request = {}+        state.active_request = active_request+      end++      local spec = client.server_capabilities.semanticTokensProvider.full+      local hasEditProvider = type(spec) == 'table' and spec.delta++      local params = { textDocument = util.make_text_document_params(self.bufnr) }+      local method = 'textDocument/semanticTokens/full'++      if hasEditProvider and current_result.result_id then+        method = method .. '/delta'+        params.previousResultId = current_result.result_id+      end+      local success, request_id = client.request(method, params, function(err, response, ctx)+        -- look client up again using ctx.client_id instead of using a captured+        -- client object+        local c = vim.lsp.get_client_by_id(ctx.client_id)+        local highlighter = STHighlighter.active[ctx.bufnr]+        if not err and c and highlighter then+          highlighter:process_response(response, c, version)+        end+      end, self.bufnr)++      if success then+        active_request.request_id = request_id+        active_request.version = version+      end+    end+  end+end++--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+function STHighlighter:process_response(response, client, version)+  local state = self.client_state[client.id]+  if not state then+    return+  end++  -- ignore stale responses+  if state.active_request.version and version ~= state.active_request.version then+    return+  end++  -- reset active request+  state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function _splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = _splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = state.current_result+  current_result.version = version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(tokens, self.bufnr, client)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+--- If there is a current result for the buffer and the version matches the+--- current document version, then the tokens are valid and can be applied. As+--- the buffer is drawn, this function will add extmark highlights for every+--- token in the range of visible lines. Once a highlight has been added, it+--- sticks around until the document changes and there's a new set of matching+--- highlight tokens available.+---+--- If this is the first time a buffer is being drawn with a new set of+--- highlights for the current document version, the namespace is cleared to+--- remove extmarks from the last version. It's done here instead of the response+--- handler to avoid the ""blink"" that occurs due to the timing between the+--- response handler and the actual redraw.+---+---@private+function STHighlighter:on_win(topline, botline)+  for _, state in pairs(self.client_state) do+    local current_result = state.current_result+    if current_result.version == util.buf_versions[self.bufnr] then+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          -- `strict = false` is necessary here for the 1% of cases where the+          -- current result doesn't actually match the buffer contents. Some+          -- LSP servers can respond with stale tokens on requests if they are+          -- still processing changes from a didChange notification.+          --+          -- LSP servers that do this _should_ follow up known stale responses+          -- with a refresh notification once they've finished processing the+          -- didChange notification, which would re-synchronize the tokens from+          -- our end.+          --+          -- The server I know of that does this is clangd when the preamble of+          -- a file changes and the token request is processed with a stale+          -- preamble while the new one is still being built. Once the preamble+          -- finishes, clangd sends a refresh request which lets the client+          -- re-synchronize the tokens.+          api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {+            hl_group = '@' .. token.type,+            end_col = token.end_col,+            priority = vim.highlight.priorities.semantic_tokens,+            strict = false,+          })++          --TODO(jdrouhard): do something with the modifiers++          token.extmark_added = true+        end+      end+    end+  end+end++--- Reset the buffer's highlighting state and clears the extmark highlights.+---+---@private+function STHighlighter:reset()+  for client_id, state in pairs(self.client_state) do+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    state.current_result = {}+    if state.active_request.request_id then+      local client = vim.lsp.get_client_by_id(client_id)+      assert(client)+      client.cancel_request(state.active_request.request_id)+      state.active_request = {}+    end+  end+end++--- Mark a client's results as dirty. This method will cancel any active+--- requests to the server and pause new highlights from being added+--- in the on_win callback. The rest of the current results are saved+--- in case the server supports delta requests.+---+---@private+---@param client_id number+function STHighlighter:mark_dirty(client_id)+  local state = self.client_state[client_id]+  assert(state)++  -- if we clear the version from current_result, it'll cause the+  -- next request to be sent and will also pause new highlights+  -- from being added in on_win until a new result comes from+  -- the server+  if state.current_result then+    state.current_result.version = nil+  end++  if state.active_request.request_id then+    local client = vim.lsp.get_client_by_id(client_id)+    assert(client)+    client.cancel_request(state.active_request.request_id)+    state.active_request = {}+  end+end++---@private+function STHighlighter:on_change()+  self:reset_timer()+  if self.debounce > 0 then+    self.timer = vim.defer_fn(function()+      self:send_request()+    end, self.debounce)+  else+    self:send_request()+  end+end++---@private+function STHighlighter:reset_timer()+  local timer = self.timer+  if timer then+    self.timer = nil+    if not timer:is_closing() then+      timer:stop()+      timer:close()+    end+  end+end++local M = {}++--- Start the semantic token highlighting engine for the given buffer with the+--- given client. The client must already be attached to the buffer.+---+--- NOTE: This is currently called automatically by |vim.lsp.buf_attach_client()|. To+--- opt-out of semantic highlighting with a server that supports it, you can+--- delete the semanticTokensProvider table from the {server_capabilities} of+--- your client in your |LspAttach| callback or your configuration's+--- `on_attach` callback.+---+--- <pre>lua+---   client.server_capabilities.semanticTokensProvider = nil+--- </pre>+---+---@param bufnr number+---@param client_id number+---@param opts (nil|table) Optional keyword arguments+---  - debounce (number, default: 200): Debounce token requests+---        to the server by the given number in milliseconds+function M.start(bufnr, client_id, opts)+  vim.validate({+    bufnr = { bufnr, 'n', false },+    client_id = { client_id, 'n', false },+  })++  opts = opts or {}+  assert(+    (not opts.debounce or type(opts.debounce) == 'number'),+    'opts.debounce must be a number with the debounce time in milliseconds'+  )++  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    vim.notify('[LSP] No client with id ' .. client_id, vim.log.levels.ERROR)+    return+  end++  if not vim.lsp.buf_is_attached(bufnr, client_id) then+    vim.notify(+      '[LSP] Client with id ' .. client_id .. ' not attached to buffer ' .. bufnr,+      vim.log.levels.WARN+    )+    return+  end++  if not vim.tbl_get(client.server_capabilities, 'semanticTokensProvider', 'full') then+    vim.notify('[LSP] Server does not support semantic tokens', vim.log.levels.WARN)+    return+  end++  local highlighter = STHighlighter.active[bufnr]++  if not highlighter then+    highlighter = STHighlighter.new(bufnr)+    highlighter.debounce = opts.debounce or 200+  else+    highlighter.debounce = math.max(highlighter.debounce, opts.debounce or 200)","Instead of taking the highest debounce of all attached clients in a buffer, we could also just use separate timers per client/per buffer (and that way they could be individually timed/configured). It would complicate things slightly since currently `send_request()` aggregates the clients and sends the request to all of them simultaneously.In practice, this will almost never matter. I am not aware of any actual use-case for having multiple LSP servers provide semantic tokens at the same time.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1042116255,2022-12-07T11:57:17Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,644 @@+local api = vim.api+local handlers = require('vim.lsp.handlers')+local util = require('vim.lsp.util')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STClientState+--- @field namespace number+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult++---@class STHighlighter+---@field active table<number, STHighlighter>+---@field bufnr number+---@field augroup number augroup for buffer events+---@field debounce number milliseconds to debounce requests for new tokens+---@field timer table uv_timer for debouncing requests for new tokens+---@field client_state table<number, STClientState>+local STHighlighter = { active = {} }++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++--- Extracts modifier strings from the encoded number in the token array+---+---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  ---@private+  local function _get_bit(n, k)+    --TODO(jdrouhard): remove once `bit` module is available for non-LuaJIT+    if _G.bit then+      return _G.bit.band(_G.bit.rshift(n, k), 1)+    else+      return math.floor((n / math.pow(2, k)) % 2)+    end+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local b = _get_bit(x, i)+    if b == 1 then+      modifiers[#modifiers + 1] = modifiers_table[i + 1]+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+---+---@private+---@return STTokenRange[]+local function tokens_to_ranges(data, bufnr, client)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function _get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = _get_byte_pos(start_char)+    local end_col = _get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++--- Construct a new STHighlighter for the buffer+---+---@private+---@param bufnr number+function STHighlighter.new(bufnr)+  local self = setmetatable({}, { __index = STHighlighter })++  self.bufnr = bufnr+  self.augroup = api.nvim_create_augroup('vim_lsp_semantic_tokens:' .. bufnr, { clear = true })+  self.client_state = {}++  STHighlighter.active[bufnr] = self++  api.nvim_buf_attach(bufnr, false, {+    on_lines = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if not highlighter then+        return true+      end+      highlighter:on_change()+    end,+    on_reload = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:reset()+        highlighter:send_request()+      end+    end,+    on_detach = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:destroy()+      end+    end,+  })++  api.nvim_create_autocmd({ 'BufWinEnter', 'InsertLeave' }, {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function()+      self:send_request()+    end,+  })++  api.nvim_create_autocmd('LspDetach', {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function(args)+      self:detach(args.data.client_id)+      if vim.tbl_isempty(self.client_state) then+        self:destroy()+      end+    end,+  })++  return self+end++---@private+function STHighlighter:destroy()+  for client_id, _ in pairs(self.client_state) do+    self:detach(client_id)+  end++  api.nvim_del_augroup_by_id(self.augroup)+  STHighlighter.active[self.bufnr] = nil+end++---@private+function STHighlighter:attach(client_id)+  local state = self.client_state[client_id]+  if not state then+    state = {+      namespace = api.nvim_create_namespace('vim_lsp_semantic_tokens:' .. client_id),+      active_request = {},+      current_result = {},+    }+    self.client_state[client_id] = state+  end+end++---@private+function STHighlighter:detach(client_id)+  local state = self.client_state[client_id]+  if state then+    --TODO: delete namespace if/when that becomes possible+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    self.client_state[client_id] = nil+  end+end++--- This is the entry point for getting all the tokens in a buffer.+---+--- For the given clients (or all attached, if not provided), this sends a request+--- to ask for semantic tokens. If the server supports delta requests, that will+--- be prioritized if we have a previous requestId and token array.+---+--- This function will skip servers where there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+function STHighlighter:send_request()+  local version = util.buf_versions[self.bufnr]++  self:reset_timer()++  for client_id, state in pairs(self.client_state) do+    local client = vim.lsp.get_client_by_id(client_id)++    local current_result = state.current_result+    local active_request = state.active_request++    -- Only send a request for this client if the current result is out of date and+    -- there isn't a current a request in flight for this version+    if client and current_result.version ~= version and active_request.version ~= version then+      -- cancel stale in-flight request+      if active_request.request_id then+        client.cancel_request(active_request.request_id)+        active_request = {}+        state.active_request = active_request+      end++      local spec = client.server_capabilities.semanticTokensProvider.full+      local hasEditProvider = type(spec) == 'table' and spec.delta++      local params = { textDocument = util.make_text_document_params(self.bufnr) }+      local method = 'textDocument/semanticTokens/full'++      if hasEditProvider and current_result.result_id then+        method = method .. '/delta'+        params.previousResultId = current_result.result_id+      end+      local success, request_id = client.request(method, params, function(err, response, ctx)+        -- look client up again using ctx.client_id instead of using a captured+        -- client object+        local c = vim.lsp.get_client_by_id(ctx.client_id)+        local highlighter = STHighlighter.active[ctx.bufnr]+        if not err and c and highlighter then+          highlighter:process_response(response, c, version)+        end+      end, self.bufnr)++      if success then+        active_request.request_id = request_id+        active_request.version = version+      end+    end+  end+end++--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+function STHighlighter:process_response(response, client, version)+  local state = self.client_state[client.id]+  if not state then+    return+  end++  -- ignore stale responses+  if state.active_request.version and version ~= state.active_request.version then+    return+  end++  -- reset active request+  state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function _splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = _splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = state.current_result+  current_result.version = version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(tokens, self.bufnr, client)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+--- If there is a current result for the buffer and the version matches the+--- current document version, then the tokens are valid and can be applied. As+--- the buffer is drawn, this function will add extmark highlights for every+--- token in the range of visible lines. Once a highlight has been added, it+--- sticks around until the document changes and there's a new set of matching+--- highlight tokens available.+---+--- If this is the first time a buffer is being drawn with a new set of+--- highlights for the current document version, the namespace is cleared to+--- remove extmarks from the last version. It's done here instead of the response+--- handler to avoid the ""blink"" that occurs due to the timing between the+--- response handler and the actual redraw.+---+---@private+function STHighlighter:on_win(topline, botline)+  for _, state in pairs(self.client_state) do+    local current_result = state.current_result+    if current_result.version == util.buf_versions[self.bufnr] then+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          -- `strict = false` is necessary here for the 1% of cases where the+          -- current result doesn't actually match the buffer contents. Some+          -- LSP servers can respond with stale tokens on requests if they are+          -- still processing changes from a didChange notification.+          --+          -- LSP servers that do this _should_ follow up known stale responses+          -- with a refresh notification once they've finished processing the+          -- didChange notification, which would re-synchronize the tokens from+          -- our end.+          --+          -- The server I know of that does this is clangd when the preamble of+          -- a file changes and the token request is processed with a stale+          -- preamble while the new one is still being built. Once the preamble+          -- finishes, clangd sends a refresh request which lets the client+          -- re-synchronize the tokens.+          api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {+            hl_group = '@' .. token.type,+            end_col = token.end_col,+            priority = vim.highlight.priorities.semantic_tokens,+            strict = false,+          })++          --TODO(jdrouhard): do something with the modifiers++          token.extmark_added = true+        end+      end+    end+  end+end++--- Reset the buffer's highlighting state and clears the extmark highlights.+---+---@private+function STHighlighter:reset()+  for client_id, state in pairs(self.client_state) do+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    state.current_result = {}+    if state.active_request.request_id then+      local client = vim.lsp.get_client_by_id(client_id)+      assert(client)+      client.cancel_request(state.active_request.request_id)+      state.active_request = {}+    end+  end+end++--- Mark a client's results as dirty. This method will cancel any active+--- requests to the server and pause new highlights from being added+--- in the on_win callback. The rest of the current results are saved+--- in case the server supports delta requests.+---+---@private+---@param client_id number+function STHighlighter:mark_dirty(client_id)+  local state = self.client_state[client_id]+  assert(state)++  -- if we clear the version from current_result, it'll cause the+  -- next request to be sent and will also pause new highlights+  -- from being added in on_win until a new result comes from+  -- the server+  if state.current_result then+    state.current_result.version = nil+  end++  if state.active_request.request_id then+    local client = vim.lsp.get_client_by_id(client_id)+    assert(client)+    client.cancel_request(state.active_request.request_id)+    state.active_request = {}+  end+end++---@private+function STHighlighter:on_change()+  self:reset_timer()+  if self.debounce > 0 then+    self.timer = vim.defer_fn(function()+      self:send_request()+    end, self.debounce)+  else+    self:send_request()+  end+end++---@private+function STHighlighter:reset_timer()+  local timer = self.timer+  if timer then+    self.timer = nil+    if not timer:is_closing() then+      timer:stop()+      timer:close()+    end+  end+end++local M = {}++--- Start the semantic token highlighting engine for the given buffer with the+--- given client. The client must already be attached to the buffer.+---+--- NOTE: This is currently called automatically by |vim.lsp.buf_attach_client()|. To+--- opt-out of semantic highlighting with a server that supports it, you can+--- delete the semanticTokensProvider table from the {server_capabilities} of+--- your client in your |LspAttach| callback or your configuration's+--- `on_attach` callback.+---+--- <pre>lua+---   client.server_capabilities.semanticTokensProvider = nil+--- </pre>+---+---@param bufnr number+---@param client_id number+---@param opts (nil|table) Optional keyword arguments+---  - debounce (number, default: 200): Debounce token requests+---        to the server by the given number in milliseconds+function M.start(bufnr, client_id, opts)+  vim.validate({+    bufnr = { bufnr, 'n', false },+    client_id = { client_id, 'n', false },+  })++  opts = opts or {}+  assert(+    (not opts.debounce or type(opts.debounce) == 'number'),+    'opts.debounce must be a number with the debounce time in milliseconds'+  )++  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    vim.notify('[LSP] No client with id ' .. client_id, vim.log.levels.ERROR)+    return+  end++  if not vim.lsp.buf_is_attached(bufnr, client_id) then+    vim.notify(+      '[LSP] Client with id ' .. client_id .. ' not attached to buffer ' .. bufnr,+      vim.log.levels.WARN+    )+    return+  end++  if not vim.tbl_get(client.server_capabilities, 'semanticTokensProvider', 'full') then+    vim.notify('[LSP] Server does not support semantic tokens', vim.log.levels.WARN)+    return+  end++  local highlighter = STHighlighter.active[bufnr]++  if not highlighter then+    highlighter = STHighlighter.new(bufnr)+    highlighter.debounce = opts.debounce or 200+  else+    highlighter.debounce = math.max(highlighter.debounce, opts.debounce or 200)",">  I am not aware of any actual use-case for having multiple LSP servers provide semantic tokens at the same time.When has that ever stopped anyone?But you're right, having multiple language servers and possibly wanting more control over which one gets to paint the buffer is a convincing argument for making semantic highlighting opt-in. Let's go with your suggestion then (and add how to do this to the `news.txt` entry).",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21137,1042128049,2022-12-07T12:10:33Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,758 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++An important thing to note is that this isn't a guide to the Lua language+itself. Rather, this is a guide on how to configure and modify Neovim through+the Lua language and the functions we provide to help with this. Take a look+at |luaref| and |lua-concepts| if you'd like to learn more about Lua itself.+Similarly, this guide assumes some familiarity with the basics of Neovim+(commands, options, mappings, autocommands), which are covered in the+|user-manual|.++------------------------------------------------------------------------------+Some words on the API                                            *lua-guide-api*++The purpose of this guide is to introduce the different ways of interacting+with Neovim through Lua (the ""API""). This API consists of three different+layers:++1. The ""Vim API"" inherited from Vim: |ex-commands| and |builtin-functions| as+well as |user-function|s in Vimscript. These are accessed through |vim.cmd()|+and |vim.fn| respectively, which are discussed under |lua-guide-vimscript|+below.++2. The ""Neovim API"" written in C for use in remote plugins and GUIs; see |api|.+These functions are accessed through |vim.api|.++3. The ""Lua API"" written in and specifically for Lua. These are any other+functions accessible through `vim.*` not mentioned already; see |lua-stdlib|.++This distinction is important, as API functions inherit behavior from their+original layer: For example, Neovim API functions always need all arguments to+be specified even if Lua itself allows omitting arguments (which are then+passed as `nil`); and Vim API functions can use 0-based indexing even if Lua+arrays are 1-indexed by default.++Through this, any possible interaction can be done through Lua without writing+a complete new API from scratch. For this reason, functions are usually not+duplicated between layers unless there is a significant benefit in+functionality or performance (e.g., you can map Lua functions directly through+|nvim_create_autocmd()| but not through |:autocmd|). In case there are multiple+ways of achieving the same thing, this guide will only cover what is most+convenient to use from Lua.++==============================================================================+Using Lua                                                  *lua-guide-using-Lua*++To run Lua code from the Neovim command line, use the |:lua| command:+>vim+    :lua print(""Hello!"")+<+Note: each |:lua| command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work:+>vim+    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""+<+You can also use `:lua=`, which is the same as `:lua vim.pretty_print(...)`,+to conveniently check the value of a variable or a table:+>lua+    :lua=package+<+To run a Lua script in an external file, you can use the |:source| command+exactly like for a Vimscript file:+>vim+    :source ~/programs/baz/myluafile.lua+<+Finally, you can include Lua code in a vimscript file by putting it inside a+|lua-heredoc| block:+>vim+    lua << EOF+      local tbl = {1, 2, 3}+      for k, v in ipairs(tbl) do+        print(v)+      end+    EOF+<+------------------------------------------------------------------------------+Using Lua files on startup                                    *lua-guide-config*++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |config| directory,+which is typically `~/.config/nvim` for Linux, BSD, or macOS, and+`~/AppData/Local/nvim/` for Windows. Note that you can use Lua in `init.vim`+and Vimscript in `init.lua`, which will be covered below.++If you'd like to run any other Lua script on |startup| automatically, then you+can simply put it in `plugin/` in your |'runtimepath'|.++------------------------------------------------------------------------------+Lua modules                                                  *lua-guide-modules*++If you want to load Lua files on demand, you can place them in the `lua/`+directory in your |'runtimepath'| and load them with `require`. (This is the+Lua equivalent of Vimscript's |autoload| mechanism.)++Let's assume you have the following directory structure:+>+    ~/.config/nvim+    |-- after/+    |-- ftplugin/+    |-- lua/+    |  |-- myluamodule.lua+    |  |-- other_modules/+    |     |-- anothermodule.lua+    |     |-- init.lua+    |-- plugin/+    |-- syntax/+    |-- init.vim+<++Then the following Lua code will load `myluamodule.lua`:+>lua+    require(""myluamodule"")+<+Note the absence of a `.lua` extension.++Similarly, loading `other_modules/anothermodule.lua` is done via+>lua+    require('other_modules/anothermodule')+    -- or+    require('other_modules.anothermodule')+<++Note how ""submodules"" are just subdirectories; the `.` is equivalent to the+path separator `/` (even on Windows).++A folder containing an |init.lua| file can be required directly, without+having to specify the name of the file:+>lua+    require('other_modules') -- loads other_modules/init.lua+<+Requiring a nonexistent module or a module which contains syntax errors aborts+the currently executing script. `pcall()` may be used to catch such errors. The+following example tries to load the `module_with_error` and only calls one of+its functions if this succeeds and prints an error message otherwise:+>lua+    local ok, mymod = pcall(require, 'module_with_error')+    if not ok then+      print(""Module had an error"")+    else+      mymod.function()+    end+<+In contrast to |:source|, |require()| not only searches through all `lua/` directories+under |'runtimepath'|, it also cache the module on first use. Calling+`require()` a second time will therefore _not_ execute the script again and+instead return the cached file. To rerun the file, you need to remove it from+the cache manually first:+>lua+    package.loaded['myluamodule'] = nil+    require('myluamodule')    -- read and execute the module again from disk+<+------------------------------------------------------------------------------+See also:+��� |lua-require|+��� |luaref-pcall()|++==============================================================================+Using Vim commands and functions from Lua                  *lua-guide-vimscript*++All Vim commands and functions are accessible from Lua.++------------------------------------------------------------------------------+Vim commands                                            *lua-guide-vim-commands*++To run an arbitrary Vim command from Lua, pass it as a string to |vim.cmd()|:+>lua+    vim.cmd(""colorscheme habamax"")+<+Note that special characters will need to be escaped with backslashes:+>lua+    vim.cmd(""%s/\\Vfoo/bar/g"")+<+An alternative is to use a literal string (see |luaref-literal|) delimited by+double brackets `[[ ]]` as in+>lua+    vim.cmd([[%s/\Vfoo/bar/g]])+<+Another benefit of using literal strings is that they can be multiple lines;+this allows you to pass multiple commands to a single call of |vim.cmd()|:+>lua+    vim.cmd([[+      highlight Error guibg=red+      highlight link Warning Error+    ]])+<+This is the converse of |lua-heredoc| and allows you to include Lua code in+your `init.vim`.++If you want to build your Vim command programmatically, the following form can+be useful (all these are equivalent to the corresponding line above):+>lua+    vim.cmd.colorscheme(""habamax"")+    vim.cmd.highlight({ ""Error"", ""guibg=red"" })+    vim.cmd.highlight({ ""link"", ""Warning"", ""Error"" })+<+------------------------------------------------------------------------------+Vimscript functions                                    *lua-guide-vim-functions*++Use |vim.fn| to call Vimscript functions from Lua. Data types between Lua and+Vimscript are automatically converted:+>lua+    print(vim.fn.printf('Hello from %s', 'Lua'))++    local reversed_list = vim.fn.reverse({ 'a', 'b', 'c' })+    print(vim.inspect(reversed_list)) -- { ""c"", ""b"", ""a"" }++    local function print_stdout(chan_id, data, name)+      print(data[1])+    end++    vim.fn.jobstart('ls', { on_stdout = print_stdout })+    print(vim.fn.printf('Hello from %s', 'Lua'))+<+This works for both |builtin-functions| and |user-function|s.++Note that hashes (`#`) are not valid characters for identifiers in Lua, so,+e.g., |autoload| functions have to be called with this syntax:+>lua+    vim.fn['my#autoload#function']()+<+------------------------------------------------------------------------------+See also:+��� |builtin-functions|: alphabetic list of all Vimscript functions+��� |function-list|:     list of all Vimscript functions grouped by topic+��� |:runtime|:          run all Lua scripts matching a pattern in |'runtimepath'|+��� |package.path|:      list of all paths searched by `require()`++==============================================================================+Variables                                                  *lua-guide-variables*++Variables can be set and read using the following wrappers, which directly+correspond to their |variable-scope|:++��� |vim.g|   - global variables (|g:|)+��� |vim.b|   - variables for the current buffer (|b:|)+��� |vim.w|   - variables for the current window (|w:|)+��� |vim.t|   - variables for the current tabpage(|t:|)+��� |vim.v|   - predefined Vim variables (|v:|)+��� |vim.env| - environment variables defined in the editor session++Data types are converted automatically. For example:+>lua+    vim.g.some_global_variable = {+      key1 = ""value"",+      key2 = 300+    }++    print(vim.inspect(vim.g.some_global_variable))+    --> { key1 = ""value"", key2 = 300 }+<+You can target specific buffers (via number), windows (via |window-ID|), or+tabpages by indexing the wrappers:+>lua+    vim.b[2].myvar = 1            -- set myvar for buffer number 2+    vim.w[5].myothervar = true    -- set myothervar for window ID 5+<+Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using the syntax+>lua+    vim.g['my#variable'] = 1+<+Note that you cannot directly change fields of array variables. This won't+work:+>lua+    vim.g.some_global_variable.key2 = 400+    vim.pretty_print(vim.g.some_global_variable)+    --> { key1 = ""value"", key2 = 300 }+<+Instead, you need to create an intermediate Lua table and change this:+>lua+    local temp_table = vim.g.some_global_variable+    temp_table = keys = 400+    vim.g.some_global_variable = temp_table+    vim.pretty_print(vim.g.some_global_variable)+    --> { key1 = ""value"", key2 = 400 }+<+To delete a variable, simply set it to `nil`:+>lua+    vim.g.myvar = nil+<+------------------------------------------------------------------------------+See also:+��� |lua-vim-variables|++==============================================================================+Options                                                      *lua-guide-options*++There are two complementary ways of setting |options| via Lua.++------------------------------------------------------------------------------+vim.opt++The most convenient way for setting global and local options, e.g., in `init.lua`,+is through `vim.opt` and friends:++��� |vim.opt|        - behaves like |:set|+��� |vim.opt_global| - behaves like |:setglobal|+��� |vim.opt_local|  - behaves like |:setlocal|++For example, the Vimscript commands+>vim+    set smarttab+    set nosmarttab+<+are equivalent to+>lua+    vim.opt.smarttab = true+    vim.opt.smarttab = false+<+In particular, they allow an easy way to working with list-like, map-like, and+set-like options through Lua tables: Instead of+>vim+    set wildignore=*.o,*.a,__pycache__+    set listchars=space:_,tab:>~+    set formatoptions=njt+<+you can use+>lua+    vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }+    vim.opt.listchars = { space = '_', tab = '>~' }+    vim.opt.formatoptions = { n = true, j = true, t = true }+<+These wrappers also come with methods that work similarly to their |:set+=|,+|:set^=| and |:set-=| counterparts in Vimscript:+>lua+    vim.opt.shortmess:append({ I = true })+    vim.opt.wildignore:prepend('*.o')+    vim.opt.whichwrap:remove({ 'b', 's' })+<+The price to pay is that you cannot access the option values directly but must+use |vim.opt:get()|:+>lua+    print(vim.opt.smarttab)+    --> {...} (big table)+    print(vim.opt.smarttab:get())+    --> false+    vim.pretty_print(vim.opt.listchars:get())+    --> { space = '_', tab = '>~' }+<+------------------------------------------------------------------------------+vim.o++For this reason, there exists a more direct variable-like access using `vim.o`+and friends, similarly to how you can get and set options via `:echo &number`+and `:let &listchars='space:_,tab:>~'`:++��� |vim.o|  - behaves like |:set|+��� |vim.go| - behaves like |:setglobal|+��� |vim.bo| - for buffer-scoped options+��� |vim.wo| - for window-scoped options++For example:+>lua+    vim.o.smarttab = false -- :set nosmarttab+    print(vim.o.smarttab)+    --> false+    vim.o.listchars = 'space:_,tab:>~' -- :set listchars='space:_,tab:>~'+    print(vim.o.listchars)+    --> 'space:_,tab:>~'+    vim.o.isfname = vim.o.isfname .. ',@-@' -- :set isfname+=@-@+    print(vim.o.isfname)+    --> '@,48-57,/,.,-,_,+,,,#,$,%,~,=,@-@'+    vim.bo.shiftwidth = 4 -- :setlocal shiftwidth=4+    print(vim.bo.shiftwidth)+    --> 4+<+Just like variables, you can specify a buffer number or |window-ID| for buffer+and window options, respectively. If no number is given, the current buffer or+window is used:+>lua+    vim.bo[4].expandtab = true -- sets expandtab to true in buffer 4+    vim.wo.number = true       -- sets number to true in current window+    print(vim.wo[0].number)    --> true+<+------------------------------------------------------------------------------+See also:+��� |lua-options|++==============================================================================+Mappings                                                    *lua-guide-mappings*++You can map either Vim commands or Lua functions to key sequences.++------------------------------------------------------------------------------+Creating mappings                                       *lua-guide-mappings-set*++Mappings can be created using |vim.keymap.set()|. This function takes three+mandatory arguments:+��� {mode} is a string or a table of strings containing the mode+  prefix for which the mapping will take effect. The prefixes are the ones+  listed in |:map-modes|, or ""!"" for |:map!|, or empty string for |:map|.+��� {lhs} is a string with the key sequences that should trigger the mapping.+  An empty string is equivalent to |<Nop>|, which disables a key.+��� {rhs} is either a string with a Vim command or a Lua function that should+  be execucted when the {lhs} is entered.++Examples:+>lua+    -- Normal mode mapping for Vim command+    vim.keymap.set('n', '<Leader>ex1', '<cmd>echo ""Example 1""<cr>')+    -- Normal and Commandline mode mapping for Vim command+    vim.keymap.set({'n', 'c'}, '<Leader>ex2', '<cmd>echo ""Example 2""<cr>')+    -- Normal mode mapping for Lua function+    vim.keymap.set('n', '<Leader>ex3', vim.treesitter.start)+    -- Normal mode mapping for Lua function with arguments+    vim.keymap.set('n', '<Leader>ex4', function() print('Example 4') end)+<+You can map functions from Lua modules via+>lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action)+<+Note that this loads the plugin at the time the mapping is defined. If you+want to defer the loading to the time when the mapping is executed (as for+|autoload| functions), wrap it in `function() end`:+>lua+    vim.keymap.set('n', '<Leader>pl2', function() require('plugin').action() end)+<+The fourth, optional, argument is a table with keys that modify the behavior+of the mapping such as those from `:map-arguments`. The following are the most+useful options:+��� `buffer`: If given, only set the mapping for the buffer with the specified+  number; `0` or `true` means the current buffer. >lua+    -- set mapping for the current buffer+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = true })+    -- set mapping for the buffer number 4+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = 4 })+<+��� `silent`: If set to `true`, suppress output such as error messages. >lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { silent = true })+<+��� `expr`: If set to `true`, do not execute the {rhs} but use the return value+  as input. Special |keycodes| are converted automatically. For example, the following+  mapping replaces <down> with <c-n> in the popupmenu only: >lua+    vim.keymap.set('c', '<down>', function()+      if vim.fn.pumvisible() == 1 then return '<c-n>' end+      return '<down>'+    end, { expr = true })+<+��� `desc`: A string that is shown when listing mappings with, e.g., |:map|.+  This is useful since Lua functions as {rhs} are otherwise only listed as+  `Lua: <number> <source file>:<line>`. Plugins should therefore always use this+  for mappings they create. >lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action,+      { desc = 'Execute action from plugin' })+<+��� `remap`: By default, all mappings are nonrecursive by default (i.e.,+  |vim.keymap.set()| behaves like |:noremap|). If the {rhs} is itself a mapping+  that should be executed, set `remap = true`: >lua+    vim.keymap.set('n', '<Leader>ex1', '<cmd>echo ""Example 1""<cr>')+    -- add a shorter mapping+    vim.keymap.set('n', 'e', '<Leader>ex1', { remap = true })+<+  The exception is if the {rhs} is a special |<Plug>| mapping, for which+  `remap = true` by default: >lua+    vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)')",There is no such exception in the Lua API```suggestion```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21137,1042131228,2022-12-07T12:13:53Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,758 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++An important thing to note is that this isn't a guide to the Lua language+itself. Rather, this is a guide on how to configure and modify Neovim through+the Lua language and the functions we provide to help with this. Take a look+at |luaref| and |lua-concepts| if you'd like to learn more about Lua itself.+Similarly, this guide assumes some familiarity with the basics of Neovim+(commands, options, mappings, autocommands), which are covered in the+|user-manual|.++------------------------------------------------------------------------------+Some words on the API                                            *lua-guide-api*++The purpose of this guide is to introduce the different ways of interacting+with Neovim through Lua (the ""API""). This API consists of three different+layers:++1. The ""Vim API"" inherited from Vim: |ex-commands| and |builtin-functions| as+well as |user-function|s in Vimscript. These are accessed through |vim.cmd()|+and |vim.fn| respectively, which are discussed under |lua-guide-vimscript|+below.++2. The ""Neovim API"" written in C for use in remote plugins and GUIs; see |api|.+These functions are accessed through |vim.api|.++3. The ""Lua API"" written in and specifically for Lua. These are any other+functions accessible through `vim.*` not mentioned already; see |lua-stdlib|.++This distinction is important, as API functions inherit behavior from their+original layer: For example, Neovim API functions always need all arguments to+be specified even if Lua itself allows omitting arguments (which are then+passed as `nil`); and Vim API functions can use 0-based indexing even if Lua+arrays are 1-indexed by default.++Through this, any possible interaction can be done through Lua without writing+a complete new API from scratch. For this reason, functions are usually not+duplicated between layers unless there is a significant benefit in+functionality or performance (e.g., you can map Lua functions directly through+|nvim_create_autocmd()| but not through |:autocmd|). In case there are multiple+ways of achieving the same thing, this guide will only cover what is most+convenient to use from Lua.++==============================================================================+Using Lua                                                  *lua-guide-using-Lua*++To run Lua code from the Neovim command line, use the |:lua| command:+>vim+    :lua print(""Hello!"")+<+Note: each |:lua| command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work:+>vim+    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""+<+You can also use `:lua=`, which is the same as `:lua vim.pretty_print(...)`,+to conveniently check the value of a variable or a table:+>lua+    :lua=package+<+To run a Lua script in an external file, you can use the |:source| command+exactly like for a Vimscript file:+>vim+    :source ~/programs/baz/myluafile.lua+<+Finally, you can include Lua code in a vimscript file by putting it inside a+|lua-heredoc| block:+>vim+    lua << EOF+      local tbl = {1, 2, 3}+      for k, v in ipairs(tbl) do+        print(v)+      end+    EOF+<+------------------------------------------------------------------------------+Using Lua files on startup                                    *lua-guide-config*++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |config| directory,+which is typically `~/.config/nvim` for Linux, BSD, or macOS, and+`~/AppData/Local/nvim/` for Windows. Note that you can use Lua in `init.vim`+and Vimscript in `init.lua`, which will be covered below.++If you'd like to run any other Lua script on |startup| automatically, then you+can simply put it in `plugin/` in your |'runtimepath'|.++------------------------------------------------------------------------------+Lua modules                                                  *lua-guide-modules*++If you want to load Lua files on demand, you can place them in the `lua/`+directory in your |'runtimepath'| and load them with `require`. (This is the+Lua equivalent of Vimscript's |autoload| mechanism.)++Let's assume you have the following directory structure:+>+    ~/.config/nvim+    |-- after/+    |-- ftplugin/+    |-- lua/+    |  |-- myluamodule.lua+    |  |-- other_modules/+    |     |-- anothermodule.lua+    |     |-- init.lua+    |-- plugin/+    |-- syntax/+    |-- init.vim+<++Then the following Lua code will load `myluamodule.lua`:+>lua+    require(""myluamodule"")+<+Note the absence of a `.lua` extension.++Similarly, loading `other_modules/anothermodule.lua` is done via+>lua+    require('other_modules/anothermodule')+    -- or+    require('other_modules.anothermodule')+<++Note how ""submodules"" are just subdirectories; the `.` is equivalent to the+path separator `/` (even on Windows).++A folder containing an |init.lua| file can be required directly, without+having to specify the name of the file:+>lua+    require('other_modules') -- loads other_modules/init.lua+<+Requiring a nonexistent module or a module which contains syntax errors aborts+the currently executing script. `pcall()` may be used to catch such errors. The+following example tries to load the `module_with_error` and only calls one of+its functions if this succeeds and prints an error message otherwise:+>lua+    local ok, mymod = pcall(require, 'module_with_error')+    if not ok then+      print(""Module had an error"")+    else+      mymod.function()+    end+<+In contrast to |:source|, |require()| not only searches through all `lua/` directories+under |'runtimepath'|, it also cache the module on first use. Calling+`require()` a second time will therefore _not_ execute the script again and+instead return the cached file. To rerun the file, you need to remove it from+the cache manually first:+>lua+    package.loaded['myluamodule'] = nil+    require('myluamodule')    -- read and execute the module again from disk+<+------------------------------------------------------------------------------+See also:+��� |lua-require|+��� |luaref-pcall()|++==============================================================================+Using Vim commands and functions from Lua                  *lua-guide-vimscript*++All Vim commands and functions are accessible from Lua.++------------------------------------------------------------------------------+Vim commands                                            *lua-guide-vim-commands*++To run an arbitrary Vim command from Lua, pass it as a string to |vim.cmd()|:+>lua+    vim.cmd(""colorscheme habamax"")+<+Note that special characters will need to be escaped with backslashes:+>lua+    vim.cmd(""%s/\\Vfoo/bar/g"")+<+An alternative is to use a literal string (see |luaref-literal|) delimited by+double brackets `[[ ]]` as in+>lua+    vim.cmd([[%s/\Vfoo/bar/g]])+<+Another benefit of using literal strings is that they can be multiple lines;+this allows you to pass multiple commands to a single call of |vim.cmd()|:+>lua+    vim.cmd([[+      highlight Error guibg=red+      highlight link Warning Error+    ]])+<+This is the converse of |lua-heredoc| and allows you to include Lua code in+your `init.vim`.++If you want to build your Vim command programmatically, the following form can+be useful (all these are equivalent to the corresponding line above):+>lua+    vim.cmd.colorscheme(""habamax"")+    vim.cmd.highlight({ ""Error"", ""guibg=red"" })+    vim.cmd.highlight({ ""link"", ""Warning"", ""Error"" })+<+------------------------------------------------------------------------------+Vimscript functions                                    *lua-guide-vim-functions*++Use |vim.fn| to call Vimscript functions from Lua. Data types between Lua and+Vimscript are automatically converted:+>lua+    print(vim.fn.printf('Hello from %s', 'Lua'))++    local reversed_list = vim.fn.reverse({ 'a', 'b', 'c' })+    print(vim.inspect(reversed_list)) -- { ""c"", ""b"", ""a"" }++    local function print_stdout(chan_id, data, name)+      print(data[1])+    end++    vim.fn.jobstart('ls', { on_stdout = print_stdout })+    print(vim.fn.printf('Hello from %s', 'Lua'))+<+This works for both |builtin-functions| and |user-function|s.++Note that hashes (`#`) are not valid characters for identifiers in Lua, so,+e.g., |autoload| functions have to be called with this syntax:+>lua+    vim.fn['my#autoload#function']()+<+------------------------------------------------------------------------------+See also:+��� |builtin-functions|: alphabetic list of all Vimscript functions+��� |function-list|:     list of all Vimscript functions grouped by topic+��� |:runtime|:          run all Lua scripts matching a pattern in |'runtimepath'|+��� |package.path|:      list of all paths searched by `require()`++==============================================================================+Variables                                                  *lua-guide-variables*++Variables can be set and read using the following wrappers, which directly+correspond to their |variable-scope|:++��� |vim.g|   - global variables (|g:|)+��� |vim.b|   - variables for the current buffer (|b:|)+��� |vim.w|   - variables for the current window (|w:|)+��� |vim.t|   - variables for the current tabpage(|t:|)+��� |vim.v|   - predefined Vim variables (|v:|)+��� |vim.env| - environment variables defined in the editor session++Data types are converted automatically. For example:+>lua+    vim.g.some_global_variable = {+      key1 = ""value"",+      key2 = 300+    }++    print(vim.inspect(vim.g.some_global_variable))+    --> { key1 = ""value"", key2 = 300 }+<+You can target specific buffers (via number), windows (via |window-ID|), or+tabpages by indexing the wrappers:+>lua+    vim.b[2].myvar = 1            -- set myvar for buffer number 2+    vim.w[5].myothervar = true    -- set myothervar for window ID 5+<+Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using the syntax+>lua+    vim.g['my#variable'] = 1+<+Note that you cannot directly change fields of array variables. This won't+work:+>lua+    vim.g.some_global_variable.key2 = 400+    vim.pretty_print(vim.g.some_global_variable)+    --> { key1 = ""value"", key2 = 300 }+<+Instead, you need to create an intermediate Lua table and change this:+>lua+    local temp_table = vim.g.some_global_variable+    temp_table = keys = 400+    vim.g.some_global_variable = temp_table+    vim.pretty_print(vim.g.some_global_variable)+    --> { key1 = ""value"", key2 = 400 }+<+To delete a variable, simply set it to `nil`:+>lua+    vim.g.myvar = nil+<+------------------------------------------------------------------------------+See also:+��� |lua-vim-variables|++==============================================================================+Options                                                      *lua-guide-options*++There are two complementary ways of setting |options| via Lua.++------------------------------------------------------------------------------+vim.opt++The most convenient way for setting global and local options, e.g., in `init.lua`,+is through `vim.opt` and friends:++��� |vim.opt|        - behaves like |:set|+��� |vim.opt_global| - behaves like |:setglobal|+��� |vim.opt_local|  - behaves like |:setlocal|++For example, the Vimscript commands+>vim+    set smarttab+    set nosmarttab+<+are equivalent to+>lua+    vim.opt.smarttab = true+    vim.opt.smarttab = false+<+In particular, they allow an easy way to working with list-like, map-like, and+set-like options through Lua tables: Instead of+>vim+    set wildignore=*.o,*.a,__pycache__+    set listchars=space:_,tab:>~+    set formatoptions=njt+<+you can use+>lua+    vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }+    vim.opt.listchars = { space = '_', tab = '>~' }+    vim.opt.formatoptions = { n = true, j = true, t = true }+<+These wrappers also come with methods that work similarly to their |:set+=|,+|:set^=| and |:set-=| counterparts in Vimscript:+>lua+    vim.opt.shortmess:append({ I = true })+    vim.opt.wildignore:prepend('*.o')+    vim.opt.whichwrap:remove({ 'b', 's' })+<+The price to pay is that you cannot access the option values directly but must+use |vim.opt:get()|:+>lua+    print(vim.opt.smarttab)+    --> {...} (big table)+    print(vim.opt.smarttab:get())+    --> false+    vim.pretty_print(vim.opt.listchars:get())+    --> { space = '_', tab = '>~' }+<+------------------------------------------------------------------------------+vim.o++For this reason, there exists a more direct variable-like access using `vim.o`+and friends, similarly to how you can get and set options via `:echo &number`+and `:let &listchars='space:_,tab:>~'`:++��� |vim.o|  - behaves like |:set|+��� |vim.go| - behaves like |:setglobal|+��� |vim.bo| - for buffer-scoped options+��� |vim.wo| - for window-scoped options++For example:+>lua+    vim.o.smarttab = false -- :set nosmarttab+    print(vim.o.smarttab)+    --> false+    vim.o.listchars = 'space:_,tab:>~' -- :set listchars='space:_,tab:>~'+    print(vim.o.listchars)+    --> 'space:_,tab:>~'+    vim.o.isfname = vim.o.isfname .. ',@-@' -- :set isfname+=@-@+    print(vim.o.isfname)+    --> '@,48-57,/,.,-,_,+,,,#,$,%,~,=,@-@'+    vim.bo.shiftwidth = 4 -- :setlocal shiftwidth=4+    print(vim.bo.shiftwidth)+    --> 4+<+Just like variables, you can specify a buffer number or |window-ID| for buffer+and window options, respectively. If no number is given, the current buffer or+window is used:+>lua+    vim.bo[4].expandtab = true -- sets expandtab to true in buffer 4+    vim.wo.number = true       -- sets number to true in current window+    print(vim.wo[0].number)    --> true+<+------------------------------------------------------------------------------+See also:+��� |lua-options|++==============================================================================+Mappings                                                    *lua-guide-mappings*++You can map either Vim commands or Lua functions to key sequences.++------------------------------------------------------------------------------+Creating mappings                                       *lua-guide-mappings-set*++Mappings can be created using |vim.keymap.set()|. This function takes three+mandatory arguments:+��� {mode} is a string or a table of strings containing the mode+  prefix for which the mapping will take effect. The prefixes are the ones+  listed in |:map-modes|, or ""!"" for |:map!|, or empty string for |:map|.+��� {lhs} is a string with the key sequences that should trigger the mapping.+  An empty string is equivalent to |<Nop>|, which disables a key.+��� {rhs} is either a string with a Vim command or a Lua function that should+  be execucted when the {lhs} is entered.++Examples:+>lua+    -- Normal mode mapping for Vim command+    vim.keymap.set('n', '<Leader>ex1', '<cmd>echo ""Example 1""<cr>')+    -- Normal and Commandline mode mapping for Vim command+    vim.keymap.set({'n', 'c'}, '<Leader>ex2', '<cmd>echo ""Example 2""<cr>')+    -- Normal mode mapping for Lua function+    vim.keymap.set('n', '<Leader>ex3', vim.treesitter.start)+    -- Normal mode mapping for Lua function with arguments+    vim.keymap.set('n', '<Leader>ex4', function() print('Example 4') end)+<+You can map functions from Lua modules via+>lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action)+<+Note that this loads the plugin at the time the mapping is defined. If you+want to defer the loading to the time when the mapping is executed (as for+|autoload| functions), wrap it in `function() end`:+>lua+    vim.keymap.set('n', '<Leader>pl2', function() require('plugin').action() end)+<+The fourth, optional, argument is a table with keys that modify the behavior+of the mapping such as those from `:map-arguments`. The following are the most+useful options:+��� `buffer`: If given, only set the mapping for the buffer with the specified+  number; `0` or `true` means the current buffer. >lua+    -- set mapping for the current buffer+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = true })+    -- set mapping for the buffer number 4+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = 4 })+<+��� `silent`: If set to `true`, suppress output such as error messages. >lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { silent = true })+<+��� `expr`: If set to `true`, do not execute the {rhs} but use the return value+  as input. Special |keycodes| are converted automatically. For example, the following+  mapping replaces <down> with <c-n> in the popupmenu only: >lua+    vim.keymap.set('c', '<down>', function()+      if vim.fn.pumvisible() == 1 then return '<c-n>' end+      return '<down>'+    end, { expr = true })+<+��� `desc`: A string that is shown when listing mappings with, e.g., |:map|.+  This is useful since Lua functions as {rhs} are otherwise only listed as+  `Lua: <number> <source file>:<line>`. Plugins should therefore always use this+  for mappings they create. >lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action,+      { desc = 'Execute action from plugin' })+<+��� `remap`: By default, all mappings are nonrecursive by default (i.e.,+  |vim.keymap.set()| behaves like |:noremap|). If the {rhs} is itself a mapping+  that should be executed, set `remap = true`: >lua+    vim.keymap.set('n', '<Leader>ex1', '<cmd>echo ""Example 1""<cr>')+    -- add a shorter mapping+    vim.keymap.set('n', 'e', '<Leader>ex1', { remap = true })+<+  The exception is if the {rhs} is a special |<Plug>| mapping, for which+  `remap = true` by default: >lua+    vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)')",There is no such exception,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21137,1042134779,2022-12-07T12:17:53Z,runtime/doc/lua-guide.txt,"@@ -0,0 +1,758 @@+*lua-guide.txt*                        Nvim++                            NVIM REFERENCE MANUAL++                          Guide to using Lua in Nvim+++                                       Type |gO| to see the table of contents.++==============================================================================+Introduction                                                         *lua-guide*++This guide will go through the basics of using Lua in Neovim. It is not meant+to be a comprehensive encyclopedia of all available features, nor will it+detail all intricacies. Think of it as a survival kit - the bare minimum+needed to know to comfortably get started on using Lua in Neovim.++An important thing to note is that this isn't a guide to the Lua language+itself. Rather, this is a guide on how to configure and modify Neovim through+the Lua language and the functions we provide to help with this. Take a look+at |luaref| and |lua-concepts| if you'd like to learn more about Lua itself.+Similarly, this guide assumes some familiarity with the basics of Neovim+(commands, options, mappings, autocommands), which are covered in the+|user-manual|.++------------------------------------------------------------------------------+Some words on the API                                            *lua-guide-api*++The purpose of this guide is to introduce the different ways of interacting+with Neovim through Lua (the ""API""). This API consists of three different+layers:++1. The ""Vim API"" inherited from Vim: |ex-commands| and |builtin-functions| as+well as |user-function|s in Vimscript. These are accessed through |vim.cmd()|+and |vim.fn| respectively, which are discussed under |lua-guide-vimscript|+below.++2. The ""Neovim API"" written in C for use in remote plugins and GUIs; see |api|.+These functions are accessed through |vim.api|.++3. The ""Lua API"" written in and specifically for Lua. These are any other+functions accessible through `vim.*` not mentioned already; see |lua-stdlib|.++This distinction is important, as API functions inherit behavior from their+original layer: For example, Neovim API functions always need all arguments to+be specified even if Lua itself allows omitting arguments (which are then+passed as `nil`); and Vim API functions can use 0-based indexing even if Lua+arrays are 1-indexed by default.++Through this, any possible interaction can be done through Lua without writing+a complete new API from scratch. For this reason, functions are usually not+duplicated between layers unless there is a significant benefit in+functionality or performance (e.g., you can map Lua functions directly through+|nvim_create_autocmd()| but not through |:autocmd|). In case there are multiple+ways of achieving the same thing, this guide will only cover what is most+convenient to use from Lua.++==============================================================================+Using Lua                                                  *lua-guide-using-Lua*++To run Lua code from the Neovim command line, use the |:lua| command:+>vim+    :lua print(""Hello!"")+<+Note: each |:lua| command has its own scope and variables declared with the+local keyword are not accessible outside of the command. This won't work:+>vim+    :lua local foo = 1+    :lua print(foo)+    "" prints ""nil"" instead of ""1""+<+You can also use `:lua=`, which is the same as `:lua vim.pretty_print(...)`,+to conveniently check the value of a variable or a table:+>lua+    :lua=package+<+To run a Lua script in an external file, you can use the |:source| command+exactly like for a Vimscript file:+>vim+    :source ~/programs/baz/myluafile.lua+<+Finally, you can include Lua code in a vimscript file by putting it inside a+|lua-heredoc| block:+>vim+    lua << EOF+      local tbl = {1, 2, 3}+      for k, v in ipairs(tbl) do+        print(v)+      end+    EOF+<+------------------------------------------------------------------------------+Using Lua files on startup                                    *lua-guide-config*++Neovim supports using `init.vim` or `init.lua` as the configuration file, but+not both at the same time. This should be placed in your |config| directory,+which is typically `~/.config/nvim` for Linux, BSD, or macOS, and+`~/AppData/Local/nvim/` for Windows. Note that you can use Lua in `init.vim`+and Vimscript in `init.lua`, which will be covered below.++If you'd like to run any other Lua script on |startup| automatically, then you+can simply put it in `plugin/` in your |'runtimepath'|.++------------------------------------------------------------------------------+Lua modules                                                  *lua-guide-modules*++If you want to load Lua files on demand, you can place them in the `lua/`+directory in your |'runtimepath'| and load them with `require`. (This is the+Lua equivalent of Vimscript's |autoload| mechanism.)++Let's assume you have the following directory structure:+>+    ~/.config/nvim+    |-- after/+    |-- ftplugin/+    |-- lua/+    |  |-- myluamodule.lua+    |  |-- other_modules/+    |     |-- anothermodule.lua+    |     |-- init.lua+    |-- plugin/+    |-- syntax/+    |-- init.vim+<++Then the following Lua code will load `myluamodule.lua`:+>lua+    require(""myluamodule"")+<+Note the absence of a `.lua` extension.++Similarly, loading `other_modules/anothermodule.lua` is done via+>lua+    require('other_modules/anothermodule')+    -- or+    require('other_modules.anothermodule')+<++Note how ""submodules"" are just subdirectories; the `.` is equivalent to the+path separator `/` (even on Windows).++A folder containing an |init.lua| file can be required directly, without+having to specify the name of the file:+>lua+    require('other_modules') -- loads other_modules/init.lua+<+Requiring a nonexistent module or a module which contains syntax errors aborts+the currently executing script. `pcall()` may be used to catch such errors. The+following example tries to load the `module_with_error` and only calls one of+its functions if this succeeds and prints an error message otherwise:+>lua+    local ok, mymod = pcall(require, 'module_with_error')+    if not ok then+      print(""Module had an error"")+    else+      mymod.function()+    end+<+In contrast to |:source|, |require()| not only searches through all `lua/` directories+under |'runtimepath'|, it also cache the module on first use. Calling+`require()` a second time will therefore _not_ execute the script again and+instead return the cached file. To rerun the file, you need to remove it from+the cache manually first:+>lua+    package.loaded['myluamodule'] = nil+    require('myluamodule')    -- read and execute the module again from disk+<+------------------------------------------------------------------------------+See also:+��� |lua-require|+��� |luaref-pcall()|++==============================================================================+Using Vim commands and functions from Lua                  *lua-guide-vimscript*++All Vim commands and functions are accessible from Lua.++------------------------------------------------------------------------------+Vim commands                                            *lua-guide-vim-commands*++To run an arbitrary Vim command from Lua, pass it as a string to |vim.cmd()|:+>lua+    vim.cmd(""colorscheme habamax"")+<+Note that special characters will need to be escaped with backslashes:+>lua+    vim.cmd(""%s/\\Vfoo/bar/g"")+<+An alternative is to use a literal string (see |luaref-literal|) delimited by+double brackets `[[ ]]` as in+>lua+    vim.cmd([[%s/\Vfoo/bar/g]])+<+Another benefit of using literal strings is that they can be multiple lines;+this allows you to pass multiple commands to a single call of |vim.cmd()|:+>lua+    vim.cmd([[+      highlight Error guibg=red+      highlight link Warning Error+    ]])+<+This is the converse of |lua-heredoc| and allows you to include Lua code in+your `init.vim`.++If you want to build your Vim command programmatically, the following form can+be useful (all these are equivalent to the corresponding line above):+>lua+    vim.cmd.colorscheme(""habamax"")+    vim.cmd.highlight({ ""Error"", ""guibg=red"" })+    vim.cmd.highlight({ ""link"", ""Warning"", ""Error"" })+<+------------------------------------------------------------------------------+Vimscript functions                                    *lua-guide-vim-functions*++Use |vim.fn| to call Vimscript functions from Lua. Data types between Lua and+Vimscript are automatically converted:+>lua+    print(vim.fn.printf('Hello from %s', 'Lua'))++    local reversed_list = vim.fn.reverse({ 'a', 'b', 'c' })+    print(vim.inspect(reversed_list)) -- { ""c"", ""b"", ""a"" }++    local function print_stdout(chan_id, data, name)+      print(data[1])+    end++    vim.fn.jobstart('ls', { on_stdout = print_stdout })+    print(vim.fn.printf('Hello from %s', 'Lua'))+<+This works for both |builtin-functions| and |user-function|s.++Note that hashes (`#`) are not valid characters for identifiers in Lua, so,+e.g., |autoload| functions have to be called with this syntax:+>lua+    vim.fn['my#autoload#function']()+<+------------------------------------------------------------------------------+See also:+��� |builtin-functions|: alphabetic list of all Vimscript functions+��� |function-list|:     list of all Vimscript functions grouped by topic+��� |:runtime|:          run all Lua scripts matching a pattern in |'runtimepath'|+��� |package.path|:      list of all paths searched by `require()`++==============================================================================+Variables                                                  *lua-guide-variables*++Variables can be set and read using the following wrappers, which directly+correspond to their |variable-scope|:++��� |vim.g|   - global variables (|g:|)+��� |vim.b|   - variables for the current buffer (|b:|)+��� |vim.w|   - variables for the current window (|w:|)+��� |vim.t|   - variables for the current tabpage(|t:|)+��� |vim.v|   - predefined Vim variables (|v:|)+��� |vim.env| - environment variables defined in the editor session++Data types are converted automatically. For example:+>lua+    vim.g.some_global_variable = {+      key1 = ""value"",+      key2 = 300+    }++    print(vim.inspect(vim.g.some_global_variable))+    --> { key1 = ""value"", key2 = 300 }+<+You can target specific buffers (via number), windows (via |window-ID|), or+tabpages by indexing the wrappers:+>lua+    vim.b[2].myvar = 1            -- set myvar for buffer number 2+    vim.w[5].myothervar = true    -- set myothervar for window ID 5+<+Some variable names may contain characters that cannot be used for identifiers+in Lua. You can still manipulate these variables by using the syntax+>lua+    vim.g['my#variable'] = 1+<+Note that you cannot directly change fields of array variables. This won't+work:+>lua+    vim.g.some_global_variable.key2 = 400+    vim.pretty_print(vim.g.some_global_variable)+    --> { key1 = ""value"", key2 = 300 }+<+Instead, you need to create an intermediate Lua table and change this:+>lua+    local temp_table = vim.g.some_global_variable+    temp_table = keys = 400+    vim.g.some_global_variable = temp_table+    vim.pretty_print(vim.g.some_global_variable)+    --> { key1 = ""value"", key2 = 400 }+<+To delete a variable, simply set it to `nil`:+>lua+    vim.g.myvar = nil+<+------------------------------------------------------------------------------+See also:+��� |lua-vim-variables|++==============================================================================+Options                                                      *lua-guide-options*++There are two complementary ways of setting |options| via Lua.++------------------------------------------------------------------------------+vim.opt++The most convenient way for setting global and local options, e.g., in `init.lua`,+is through `vim.opt` and friends:++��� |vim.opt|        - behaves like |:set|+��� |vim.opt_global| - behaves like |:setglobal|+��� |vim.opt_local|  - behaves like |:setlocal|++For example, the Vimscript commands+>vim+    set smarttab+    set nosmarttab+<+are equivalent to+>lua+    vim.opt.smarttab = true+    vim.opt.smarttab = false+<+In particular, they allow an easy way to working with list-like, map-like, and+set-like options through Lua tables: Instead of+>vim+    set wildignore=*.o,*.a,__pycache__+    set listchars=space:_,tab:>~+    set formatoptions=njt+<+you can use+>lua+    vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }+    vim.opt.listchars = { space = '_', tab = '>~' }+    vim.opt.formatoptions = { n = true, j = true, t = true }+<+These wrappers also come with methods that work similarly to their |:set+=|,+|:set^=| and |:set-=| counterparts in Vimscript:+>lua+    vim.opt.shortmess:append({ I = true })+    vim.opt.wildignore:prepend('*.o')+    vim.opt.whichwrap:remove({ 'b', 's' })+<+The price to pay is that you cannot access the option values directly but must+use |vim.opt:get()|:+>lua+    print(vim.opt.smarttab)+    --> {...} (big table)+    print(vim.opt.smarttab:get())+    --> false+    vim.pretty_print(vim.opt.listchars:get())+    --> { space = '_', tab = '>~' }+<+------------------------------------------------------------------------------+vim.o++For this reason, there exists a more direct variable-like access using `vim.o`+and friends, similarly to how you can get and set options via `:echo &number`+and `:let &listchars='space:_,tab:>~'`:++��� |vim.o|  - behaves like |:set|+��� |vim.go| - behaves like |:setglobal|+��� |vim.bo| - for buffer-scoped options+��� |vim.wo| - for window-scoped options++For example:+>lua+    vim.o.smarttab = false -- :set nosmarttab+    print(vim.o.smarttab)+    --> false+    vim.o.listchars = 'space:_,tab:>~' -- :set listchars='space:_,tab:>~'+    print(vim.o.listchars)+    --> 'space:_,tab:>~'+    vim.o.isfname = vim.o.isfname .. ',@-@' -- :set isfname+=@-@+    print(vim.o.isfname)+    --> '@,48-57,/,.,-,_,+,,,#,$,%,~,=,@-@'+    vim.bo.shiftwidth = 4 -- :setlocal shiftwidth=4+    print(vim.bo.shiftwidth)+    --> 4+<+Just like variables, you can specify a buffer number or |window-ID| for buffer+and window options, respectively. If no number is given, the current buffer or+window is used:+>lua+    vim.bo[4].expandtab = true -- sets expandtab to true in buffer 4+    vim.wo.number = true       -- sets number to true in current window+    print(vim.wo[0].number)    --> true+<+------------------------------------------------------------------------------+See also:+��� |lua-options|++==============================================================================+Mappings                                                    *lua-guide-mappings*++You can map either Vim commands or Lua functions to key sequences.++------------------------------------------------------------------------------+Creating mappings                                       *lua-guide-mappings-set*++Mappings can be created using |vim.keymap.set()|. This function takes three+mandatory arguments:+��� {mode} is a string or a table of strings containing the mode+  prefix for which the mapping will take effect. The prefixes are the ones+  listed in |:map-modes|, or ""!"" for |:map!|, or empty string for |:map|.+��� {lhs} is a string with the key sequences that should trigger the mapping.+  An empty string is equivalent to |<Nop>|, which disables a key.+��� {rhs} is either a string with a Vim command or a Lua function that should+  be execucted when the {lhs} is entered.++Examples:+>lua+    -- Normal mode mapping for Vim command+    vim.keymap.set('n', '<Leader>ex1', '<cmd>echo ""Example 1""<cr>')+    -- Normal and Commandline mode mapping for Vim command+    vim.keymap.set({'n', 'c'}, '<Leader>ex2', '<cmd>echo ""Example 2""<cr>')+    -- Normal mode mapping for Lua function+    vim.keymap.set('n', '<Leader>ex3', vim.treesitter.start)+    -- Normal mode mapping for Lua function with arguments+    vim.keymap.set('n', '<Leader>ex4', function() print('Example 4') end)+<+You can map functions from Lua modules via+>lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action)+<+Note that this loads the plugin at the time the mapping is defined. If you+want to defer the loading to the time when the mapping is executed (as for+|autoload| functions), wrap it in `function() end`:+>lua+    vim.keymap.set('n', '<Leader>pl2', function() require('plugin').action() end)+<+The fourth, optional, argument is a table with keys that modify the behavior+of the mapping such as those from `:map-arguments`. The following are the most+useful options:+��� `buffer`: If given, only set the mapping for the buffer with the specified+  number; `0` or `true` means the current buffer. >lua+    -- set mapping for the current buffer+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = true })+    -- set mapping for the buffer number 4+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { buffer = 4 })+<+��� `silent`: If set to `true`, suppress output such as error messages. >lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action, { silent = true })+<+��� `expr`: If set to `true`, do not execute the {rhs} but use the return value+  as input. Special |keycodes| are converted automatically. For example, the following+  mapping replaces <down> with <c-n> in the popupmenu only: >lua+    vim.keymap.set('c', '<down>', function()+      if vim.fn.pumvisible() == 1 then return '<c-n>' end+      return '<down>'+    end, { expr = true })+<+��� `desc`: A string that is shown when listing mappings with, e.g., |:map|.+  This is useful since Lua functions as {rhs} are otherwise only listed as+  `Lua: <number> <source file>:<line>`. Plugins should therefore always use this+  for mappings they create. >lua+    vim.keymap.set('n', '<Leader>pl1', require('plugin').action,+      { desc = 'Execute action from plugin' })+<+��� `remap`: By default, all mappings are nonrecursive by default (i.e.,+  |vim.keymap.set()| behaves like |:noremap|). If the {rhs} is itself a mapping+  that should be executed, set `remap = true`: >lua+    vim.keymap.set('n', '<Leader>ex1', '<cmd>echo ""Example 1""<cr>')+    -- add a shorter mapping+    vim.keymap.set('n', 'e', '<Leader>ex1', { remap = true })+<+  The exception is if the {rhs} is a special |<Plug>| mapping, for which+  `remap = true` by default: >lua+    vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)')",There is no such exception in the Lua API. It also works in Vim script with `:noremap`.,
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/21100,1042258920,2022-12-07T14:15:56Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,644 @@+local api = vim.api+local handlers = require('vim.lsp.handlers')+local util = require('vim.lsp.util')++--- @class STTokenRange+--- @field line number line number 0-based+--- @field start_col number start column 0-based+--- @field end_col number end column 0-based+--- @field type string token type as string+--- @field modifiers string[] token modifiers as strings+--- @field extmark_added boolean whether this extmark has been added to the buffer yet+---+--- @class STCurrentResult+--- @field version number document version associated with this result+--- @field result_id string resultId from the server; used with delta requests+--- @field highlights STTokenRange[] cache of highlight ranges for this document version+--- @field tokens number[] raw token array as received by the server. used for calculating delta responses+--- @field namespace_cleared boolean whether the namespace was cleared for this result yet+---+--- @class STActiveRequest+--- @field request_id number the LSP request ID of the most recent request sent to the server+--- @field version number the document version associated with the most recent request+---+--- @class STClientState+--- @field namespace number+--- @field active_request STActiveRequest+--- @field current_result STCurrentResult++---@class STHighlighter+---@field active table<number, STHighlighter>+---@field bufnr number+---@field augroup number augroup for buffer events+---@field debounce number milliseconds to debounce requests for new tokens+---@field timer table uv_timer for debouncing requests for new tokens+---@field client_state table<number, STClientState>+local STHighlighter = { active = {} }++---@private+local function binary_search(tokens, line)+  local lo = 1+  local hi = #tokens+  while lo < hi do+    local mid = math.floor((lo + hi) / 2)+    if tokens[mid].line < line then+      lo = mid + 1+    else+      hi = mid+    end+  end+  return lo+end++--- Extracts modifier strings from the encoded number in the token array+---+---@private+---@return string[]+local function modifiers_from_number(x, modifiers_table)+  ---@private+  local function _get_bit(n, k)+    --TODO(jdrouhard): remove once `bit` module is available for non-LuaJIT+    if _G.bit then+      return _G.bit.band(_G.bit.rshift(n, k), 1)+    else+      return math.floor((n / math.pow(2, k)) % 2)+    end+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local b = _get_bit(x, i)+    if b == 1 then+      modifiers[#modifiers + 1] = modifiers_table[i + 1]+    end+  end++  return modifiers+end++--- Converts a raw token list to a list of highlight ranges used by the on_win callback+---+---@private+---@return STTokenRange[]+local function tokens_to_ranges(data, bufnr, client)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local ranges = {}++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    ---@private+    local function _get_byte_pos(char_pos)+      return util._get_line_byte_from_position(bufnr, {+        line = line,+        character = char_pos,+      }, client.offset_encoding)+    end++    local start_col = _get_byte_pos(start_char)+    local end_col = _get_byte_pos(start_char + data[i + 2])++    if token_type then+      ranges[#ranges + 1] = {+        line = line,+        start_col = start_col,+        end_col = end_col,+        type = token_type,+        modifiers = modifiers,+        extmark_added = false,+      }+    end+  end++  return ranges+end++--- Construct a new STHighlighter for the buffer+---+---@private+---@param bufnr number+function STHighlighter.new(bufnr)+  local self = setmetatable({}, { __index = STHighlighter })++  self.bufnr = bufnr+  self.augroup = api.nvim_create_augroup('vim_lsp_semantic_tokens:' .. bufnr, { clear = true })+  self.client_state = {}++  STHighlighter.active[bufnr] = self++  api.nvim_buf_attach(bufnr, false, {+    on_lines = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if not highlighter then+        return true+      end+      highlighter:on_change()+    end,+    on_reload = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:reset()+        highlighter:send_request()+      end+    end,+    on_detach = function(_, buf)+      local highlighter = STHighlighter.active[buf]+      if highlighter then+        highlighter:destroy()+      end+    end,+  })++  api.nvim_create_autocmd({ 'BufWinEnter', 'InsertLeave' }, {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function()+      self:send_request()+    end,+  })++  api.nvim_create_autocmd('LspDetach', {+    buffer = self.bufnr,+    group = self.augroup,+    callback = function(args)+      self:detach(args.data.client_id)+      if vim.tbl_isempty(self.client_state) then+        self:destroy()+      end+    end,+  })++  return self+end++---@private+function STHighlighter:destroy()+  for client_id, _ in pairs(self.client_state) do+    self:detach(client_id)+  end++  api.nvim_del_augroup_by_id(self.augroup)+  STHighlighter.active[self.bufnr] = nil+end++---@private+function STHighlighter:attach(client_id)+  local state = self.client_state[client_id]+  if not state then+    state = {+      namespace = api.nvim_create_namespace('vim_lsp_semantic_tokens:' .. client_id),+      active_request = {},+      current_result = {},+    }+    self.client_state[client_id] = state+  end+end++---@private+function STHighlighter:detach(client_id)+  local state = self.client_state[client_id]+  if state then+    --TODO: delete namespace if/when that becomes possible+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    self.client_state[client_id] = nil+  end+end++--- This is the entry point for getting all the tokens in a buffer.+---+--- For the given clients (or all attached, if not provided), this sends a request+--- to ask for semantic tokens. If the server supports delta requests, that will+--- be prioritized if we have a previous requestId and token array.+---+--- This function will skip servers where there is an already an active request in+--- flight for the same version. If there is a stale request in flight, that is+--- cancelled prior to sending a new one.+---+--- Finally, if the request was successful, the requestId and document version+--- are saved to facilitate document synchronization in the response.+---+---@private+function STHighlighter:send_request()+  local version = util.buf_versions[self.bufnr]++  self:reset_timer()++  for client_id, state in pairs(self.client_state) do+    local client = vim.lsp.get_client_by_id(client_id)++    local current_result = state.current_result+    local active_request = state.active_request++    -- Only send a request for this client if the current result is out of date and+    -- there isn't a current a request in flight for this version+    if client and current_result.version ~= version and active_request.version ~= version then+      -- cancel stale in-flight request+      if active_request.request_id then+        client.cancel_request(active_request.request_id)+        active_request = {}+        state.active_request = active_request+      end++      local spec = client.server_capabilities.semanticTokensProvider.full+      local hasEditProvider = type(spec) == 'table' and spec.delta++      local params = { textDocument = util.make_text_document_params(self.bufnr) }+      local method = 'textDocument/semanticTokens/full'++      if hasEditProvider and current_result.result_id then+        method = method .. '/delta'+        params.previousResultId = current_result.result_id+      end+      local success, request_id = client.request(method, params, function(err, response, ctx)+        -- look client up again using ctx.client_id instead of using a captured+        -- client object+        local c = vim.lsp.get_client_by_id(ctx.client_id)+        local highlighter = STHighlighter.active[ctx.bufnr]+        if not err and c and highlighter then+          highlighter:process_response(response, c, version)+        end+      end, self.bufnr)++      if success then+        active_request.request_id = request_id+        active_request.version = version+      end+    end+  end+end++--- This function will parse the semantic token responses and set up the cache+--- (current_result). It also performs document synchronization by checking the+--- version of the document associated with the resulting request_id and only+--- performing work if the response is not out-of-date.+---+--- Delta edits are applied if necessary, and new highlight ranges are calculated+--- and stored in the buffer state.+---+--- Finally, a redraw command is issued to force nvim to redraw the screen to+--- pick up changed highlight tokens.+---+---@private+function STHighlighter:process_response(response, client, version)+  local state = self.client_state[client.id]+  if not state then+    return+  end++  -- ignore stale responses+  if state.active_request.version and version ~= state.active_request.version then+    return+  end++  -- reset active request+  state.active_request = {}++  -- if we have a response to a delta request, update the state of our tokens+  -- appropriately. if it's a full response, just use that+  local tokens+  local token_edits = response.edits+  if token_edits then+    table.sort(token_edits, function(a, b)+      return a.start < b.start+    end)++    ---@private+    local function _splice(list, start, remove_count, data)+      local ret = vim.list_slice(list, 1, start)+      vim.list_extend(ret, data)+      vim.list_extend(ret, list, start + remove_count + 1)+      return ret+    end++    tokens = state.current_result.tokens+    for _, token_edit in ipairs(token_edits) do+      tokens = _splice(tokens, token_edit.start, token_edit.deleteCount, token_edit.data)+    end+  else+    tokens = response.data+  end++  -- Update the state with the new results+  local current_result = state.current_result+  current_result.version = version+  current_result.result_id = response.resultId+  current_result.tokens = tokens+  current_result.highlights = tokens_to_ranges(tokens, self.bufnr, client)+  current_result.namespace_cleared = false++  api.nvim_command('redraw!')+end++--- on_win handler for the decoration provider (see |nvim_set_decoration_provider|)+---+--- If there is a current result for the buffer and the version matches the+--- current document version, then the tokens are valid and can be applied. As+--- the buffer is drawn, this function will add extmark highlights for every+--- token in the range of visible lines. Once a highlight has been added, it+--- sticks around until the document changes and there's a new set of matching+--- highlight tokens available.+---+--- If this is the first time a buffer is being drawn with a new set of+--- highlights for the current document version, the namespace is cleared to+--- remove extmarks from the last version. It's done here instead of the response+--- handler to avoid the ""blink"" that occurs due to the timing between the+--- response handler and the actual redraw.+---+---@private+function STHighlighter:on_win(topline, botline)+  for _, state in pairs(self.client_state) do+    local current_result = state.current_result+    if current_result.version == util.buf_versions[self.bufnr] then+      if not current_result.namespace_cleared then+        api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+        current_result.namespace_cleared = true+      end++      -- We can't use ephemeral extmarks because the buffer updates are not in+      -- sync with the list of semantic tokens. There's a delay between the+      -- buffer changing and when the LSP server can respond with updated+      -- tokens, and we don't want to ""blink"" the token highlights while+      -- updates are in flight, and we don't want to use stale tokens because+      -- they likely won't line up right with the actual buffer.+      --+      -- Instead, we have to use normal extmarks that can attach to locations+      -- in the buffer and are persisted between redraws.+      local highlights = current_result.highlights+      local idx = binary_search(highlights, topline)++      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > botline then+          break+        end++        if not token.extmark_added then+          -- `strict = false` is necessary here for the 1% of cases where the+          -- current result doesn't actually match the buffer contents. Some+          -- LSP servers can respond with stale tokens on requests if they are+          -- still processing changes from a didChange notification.+          --+          -- LSP servers that do this _should_ follow up known stale responses+          -- with a refresh notification once they've finished processing the+          -- didChange notification, which would re-synchronize the tokens from+          -- our end.+          --+          -- The server I know of that does this is clangd when the preamble of+          -- a file changes and the token request is processed with a stale+          -- preamble while the new one is still being built. Once the preamble+          -- finishes, clangd sends a refresh request which lets the client+          -- re-synchronize the tokens.+          api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {+            hl_group = '@' .. token.type,+            end_col = token.end_col,+            priority = vim.highlight.priorities.semantic_tokens,+            strict = false,+          })++          --TODO(jdrouhard): do something with the modifiers++          token.extmark_added = true+        end+      end+    end+  end+end++--- Reset the buffer's highlighting state and clears the extmark highlights.+---+---@private+function STHighlighter:reset()+  for client_id, state in pairs(self.client_state) do+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)+    state.current_result = {}+    if state.active_request.request_id then+      local client = vim.lsp.get_client_by_id(client_id)+      assert(client)+      client.cancel_request(state.active_request.request_id)+      state.active_request = {}+    end+  end+end++--- Mark a client's results as dirty. This method will cancel any active+--- requests to the server and pause new highlights from being added+--- in the on_win callback. The rest of the current results are saved+--- in case the server supports delta requests.+---+---@private+---@param client_id number+function STHighlighter:mark_dirty(client_id)+  local state = self.client_state[client_id]+  assert(state)++  -- if we clear the version from current_result, it'll cause the+  -- next request to be sent and will also pause new highlights+  -- from being added in on_win until a new result comes from+  -- the server+  if state.current_result then+    state.current_result.version = nil+  end++  if state.active_request.request_id then+    local client = vim.lsp.get_client_by_id(client_id)+    assert(client)+    client.cancel_request(state.active_request.request_id)+    state.active_request = {}+  end+end++---@private+function STHighlighter:on_change()+  self:reset_timer()+  if self.debounce > 0 then+    self.timer = vim.defer_fn(function()+      self:send_request()+    end, self.debounce)+  else+    self:send_request()+  end+end++---@private+function STHighlighter:reset_timer()+  local timer = self.timer+  if timer then+    self.timer = nil+    if not timer:is_closing() then+      timer:stop()+      timer:close()+    end+  end+end++local M = {}++--- Start the semantic token highlighting engine for the given buffer with the+--- given client. The client must already be attached to the buffer.+---+--- NOTE: This is currently called automatically by |vim.lsp.buf_attach_client()|. To+--- opt-out of semantic highlighting with a server that supports it, you can+--- delete the semanticTokensProvider table from the {server_capabilities} of+--- your client in your |LspAttach| callback or your configuration's+--- `on_attach` callback.+---+--- <pre>lua+---   client.server_capabilities.semanticTokensProvider = nil+--- </pre>+---+---@param bufnr number+---@param client_id number+---@param opts (nil|table) Optional keyword arguments+---  - debounce (number, default: 200): Debounce token requests+---        to the server by the given number in milliseconds+function M.start(bufnr, client_id, opts)+  vim.validate({+    bufnr = { bufnr, 'n', false },+    client_id = { client_id, 'n', false },+  })++  opts = opts or {}+  assert(+    (not opts.debounce or type(opts.debounce) == 'number'),+    'opts.debounce must be a number with the debounce time in milliseconds'+  )++  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    vim.notify('[LSP] No client with id ' .. client_id, vim.log.levels.ERROR)+    return+  end++  if not vim.lsp.buf_is_attached(bufnr, client_id) then+    vim.notify(+      '[LSP] Client with id ' .. client_id .. ' not attached to buffer ' .. bufnr,+      vim.log.levels.WARN+    )+    return+  end++  if not vim.tbl_get(client.server_capabilities, 'semanticTokensProvider', 'full') then+    vim.notify('[LSP] Server does not support semantic tokens', vim.log.levels.WARN)+    return+  end++  local highlighter = STHighlighter.active[bufnr]++  if not highlighter then+    highlighter = STHighlighter.new(bufnr)+    highlighter.debounce = opts.debounce or 200+  else+    highlighter.debounce = math.max(highlighter.debounce, opts.debounce or 200)","I'll leave everything as-is, for now, then, though this comment specifically was about the debounce timer being aggregated for all attached clients, instead of separated out :)I'd like to leave start()/stop(). I think it's invaluable to be able to disable it (even if it's enabled for you automatically) for debugging purposes. Creating a simple toggler in my config was invaluable to be able to see the differences the semantic token highlighting was making, and I think there are probably other use cases people could come up with for being able to enable/disable the highlighting in a buffer without wholesale disabling the feature entirely.",
378760,cormacrelf,https://api.github.com/repos/neovim/neovim/pulls/21310,1043521324,2022-12-08T15:56:43Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -280,32 +337,22 @@ end --- Note: This call invalidates the tree and requires it to be parsed again. --- ---@private----@param regions table List of regions this tree should manage and parse.-function LanguageTree:set_included_regions(regions)","A couple of questions:First, is `set_included_regions` public API or not? It has `@private` luadoc so it isn't in the published docs, but it seems that it used to be. The `@private` was added in #20142. As I was writing this I thought I was free to change the signature and I think I might have to backpedal that.If it is a public API...Since we're normalising `Range4`s, that means both the setter and the getter have some undocumented functionality. I'd guess that most people would interpret these APIs as documented as a simple getter and setter combo. But that's already not how it works because we are normalising `Range4`s in-place. So `set_included_regions` currently accepts range4 + tsnode, and `included_regions` returns range6 + tsnode. It looks as though range4 support was added in order to implement the `#offset!` directive, and range6's accidentally leaked out (only on child langs). Out [in the wild][] one or two people seem to be using it a little, entirely with tsnodes and assuming tsnodes so far.There are a couple of options to rectify this:* normalise everything to range6 and document that you can supply range4s or range6s when setting and that `included_regions` will return range6 always;* stop normalising in-place, make it behave like a getter/setter for the root, document that _range4_ works for the setter, pretend range6 in the public API never happened and then, for child langs, re-normalise the return value of `included_regions` back to range4.* some other permutations of those optionsAny ideas? In any case at minimum I will probably normalise tsnodes to range6 internally. We need range6 so we can arbitrarily split them and have a convenient comparison value (the buffer byte offset), and we need uniformity lest the clipping code get really messy,.[in the wild]: https://github.com/search?type=code&q=set_included_regions+OR+included_regions+language%3Alua+path%3A%2F%5Elua%2F",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21100,1043553019,2022-12-08T16:26:17Z,src/nvim/highlight_group.c,"@@ -264,6 +264,18 @@ static const char *highlight_init_both[] = {   ""default link @preproc PreProc"",   ""default link @debug Debug"",   ""default link @tag Tag"",++  // LSP semantic tokens+  ""default link @class Type"",+  ""default link @struct Type"",+  ""default link @enum Type"",+  ""default link @enumMember Constant"",+  ""default link @event Identifier"",+  ""default link @interface Identifier"",+  ""default link @modifier Identifier"",+  ""default link @regexp SpecialChar"",+  ""default link @typeParameter Type"",+  ""default link @decorator Identifier"",","Meaning, it shouldn't block this. As long as the links are there, we can always tweak them later (and probably will have to when modifiers enter the mix).Oh, but:> ""default link @struct Type"",I'd prefer to rename the already existing `@structure` group instead -- having both is needlessly confusing.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21202,1043888844,2022-12-08T22:37:02Z,src/nvim/option_defs.h,"@@ -336,6 +336,7 @@ enum {   STL_ALTPERCENT      = 'P',  ///< Percentage as TOP BOT ALL or NN%.   STL_ARGLISTSTAT     = 'a',  ///< Argument list status as (x of y).   STL_PAGENUM         = 'N',  ///< Page number (when printing).+  STL_SHOWCMD         = 'S',  ///< Showcmd buffer.",I wonder if dot `.` is semantically closer to what Vim would choose here. Not a blocker though.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21202,1043929096,2022-12-08T23:47:29Z,src/nvim/option_defs.h,"@@ -336,6 +336,7 @@ enum {   STL_ALTPERCENT      = 'P',  ///< Percentage as TOP BOT ALL or NN%.   STL_ARGLISTSTAT     = 'a',  ///< Argument list status as (x of y).   STL_PAGENUM         = 'N',  ///< Page number (when printing).+  STL_SHOWCMD         = 'S',  ///< Showcmd buffer.","> You're suggesting `.` instead of `S`?yes> So if we want to get Bram's feedback I guess I could check if he is open to including this(decoupled from `cmdheight`)?if you're up for it, that's always a worth a check. Especially for potential naming collisions like this.",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1044058631,2022-12-09T03:26:24Z,test/functional/fixtures/fake-lsp-server.lua,"@@ -927,6 +927,65 @@ function tests.basic_formatting()   } end +function tests.basic_watchfiles()+  skeleton {+    on_init = function()+      return {+        capabilities = {+          documentFormattingProvider = true,+        }+      }+    end;+    body = function()+      local root_dir+      root_dir = os.tmpname()","Thanks for the pointer, that way is definitely much easier to reason about. Just pushed a refactored version of this test using that pattern.",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/21175,1044992690,2022-12-10T05:54:03Z,src/nvim/os/fs.c,"@@ -302,7 +302,9 @@ static bool is_executable(const char *name, char **abspath) static bool is_executable_ext(const char *name, char **abspath)   FUNC_ATTR_NONNULL_ARG(1) {-  const bool is_unix_shell = strstr((char *)path_tail(p_sh), ""sh"") != NULL;+  const bool is_unix_shell = strstr((char *)path_tail(p_sh), ""powershell"") == NULL+                             && strstr((char *)path_tail(p_sh), ""pwsh"") == NULL+                             && strstr((char *)path_tail(p_sh), ""sh"") != NULL;","No need to cast into `char *` since `path_tail` already returns a char pointer.  In Vim's source, they needed to cast because `gettail`, Vim's equivalent of `path_tail`, returns a `char_u *`<sup>[1]</sup>.```suggestion  const bool is_unix_shell = strstr(path_tail(p_sh), ""powershell"") == NULL                             && strstr(path_tail(p_sh), ""pwsh"") == NULL                             && strstr(path_tail(p_sh), ""sh"") != NULL;```[1]: https://github.com/vim/vim/blob/4ae0057308c59a0dee2b452736366e49a5a98b3a/src/filepath.c#L2886-L2887",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21374,1045211468,2022-12-11T10:50:36Z,runtime/lua/vim/treesitter.lua,"@@ -248,64 +255,57 @@ function M.get_captures_at_pos(bufnr, row, col)   return matches end ---- Returns a list of highlight capture names under the cursor+--- Shows the list of highlight capture names under the cursor --- ---@param winnr (number|nil) Window handle or 0 for current window (default)--------@return string[] List of capture names-function M.get_captures_at_cursor(winnr)+function M.show_captures_at_cursor(winnr)   winnr = winnr or 0   local bufnr = a.nvim_win_get_buf(winnr)   local cursor = a.nvim_win_get_cursor(winnr)    local data = M.get_captures_at_pos(bufnr, cursor[1] - 1, cursor[2]) -  local captures = {}-+  local msg = {}   for _, capture in ipairs(data) do-    table.insert(captures, capture.capture)+    local capture_name = '@' .. capture.capture+    msg[#msg + 1] = { capture_name, capture_name }+    msg[#msg + 1] = { ' ' }   end -  return captures+  a.nvim_echo(msg, false, {})",I set `{history}` to `false` since people may want to use this in a `CursorHold` autocommand without spamming into their `:messages` list.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21373,1045216412,2022-12-11T11:28:42Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -638,6 +647,43 @@ api.nvim_set_decoration_provider(namespace, {   end, }) +--- Show the token under the cursor+---+---@param winnr (number|nil) Window handle or 0 for current window (default)+M.show_token_at_cursor = function(winnr)+  winnr = winnr or 0+  local cursor = api.nvim_win_get_cursor(winnr)++  local highlights = STHighlighter.active[1].client_state[1].current_result.highlights",I think `state` should be indexed with the buffer number and it should probably loop over client_state because `client_state[1]` only works if the lsp client with the semantic tokens happens to have the id 1,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21373,1045221211,2022-12-11T12:02:06Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -638,6 +647,43 @@ api.nvim_set_decoration_provider(namespace, {   end, }) +--- Show the token under the cursor+---+---@param winnr (number|nil) Window handle or 0 for current window (default)+M.show_token_at_cursor = function(winnr)+  winnr = winnr or 0+  local cursor = api.nvim_win_get_cursor(winnr)++  local highlights = STHighlighter.active[1].client_state[1].current_result.highlights","> Like so?yes, I think so> Is there a usecase for specifying buffer and/or window?Not sure. If we want future proving, maybe something like a `show_token(opts)` with `bufnr`, `winnr` and `lnum/col` (defaulting to current cursor position) options would work without making it more complex. But leave it up to you as it's not documented/considered internal for now anyways",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21374,1045250541,2022-12-11T15:16:04Z,runtime/lua/vim/treesitter.lua,"@@ -197,13 +197,20 @@ end --- Each capture is represented by a table containing the capture name as a string as --- well as a table of metadata (`priority`, `conceal`, ...; empty if none are defined). -------@param bufnr number Buffer number (0 for current buffer)----@param row number Position row----@param col number Position column+--- If called without argument, returns the captures at cursor. -------@return table[] List of captures `{ capture = ""capture name"", metadata = { ... } }`+---@param bufnr number|nil Buffer number (0 for current buffer)+---@param row number Position row (default cursor position if `bufnr` is `nil)+---@param col number Position column (default cursor position if `bufnr` is `nil)+---+---@return table[] matches List of captures `{ capture = ""capture name"", metadata = { ... } }`","What does the `matches` here signify?```suggestion---@return table[] List of captures `{ capture = ""capture name"", metadata = { ... } }````",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21374,1045250997,2022-12-11T15:19:21Z,runtime/lua/vim/treesitter.lua,"@@ -197,13 +197,20 @@ end --- Each capture is represented by a table containing the capture name as a string as --- well as a table of metadata (`priority`, `conceal`, ...; empty if none are defined). -------@param bufnr number Buffer number (0 for current buffer)----@param row number Position row----@param col number Position column+--- If called without argument, returns the captures at cursor. -------@return table[] List of captures `{ capture = ""capture name"", metadata = { ... } }`+---@param bufnr number|nil Buffer number (0 for current buffer)+---@param row number Position row (default cursor position if `bufnr` is `nil)+---@param col number Position column (default cursor position if `bufnr` is `nil)","Yeah, I was planning to rework this to be similar to how I ended up implementing the semantic tokens functions.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21374,1045251129,2022-12-11T15:20:24Z,runtime/lua/vim/treesitter.lua,"@@ -197,13 +197,20 @@ end --- Each capture is represented by a table containing the capture name as a string as --- well as a table of metadata (`priority`, `conceal`, ...; empty if none are defined). -------@param bufnr number Buffer number (0 for current buffer)----@param row number Position row----@param col number Position column+--- If called without argument, returns the captures at cursor. -------@return table[] List of captures `{ capture = ""capture name"", metadata = { ... } }`+---@param bufnr number|nil Buffer number (0 for current buffer)+---@param row number Position row (default cursor position if `bufnr` is `nil)+---@param col number Position column (default cursor position if `bufnr` is `nil)+---+---@return table[] matches List of captures `{ capture = ""capture name"", metadata = { ... } }`","It's the name of the returned variable -- try removing it and looking at lua-language-server's semantic highlighting.But I agree, it looks wrong in the docs, and that is the main priority here.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21373,1045282241,2022-12-11T19:05:20Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -585,6 +585,76 @@ function M.stop(bufnr, client_id)   end end +--- Return the semantic token(s) at the given position.+--- If called without argument, returns the token under the cursor.+---+---@param bufnr number|nil Buffer number (0 for current buffer, default)+---@param row number|nil Position row (default cursor position)+---@param col number|nil Position column (default cursor position)+---+---@return table[]|nil tokens Table of tokens at position+function M.get_tokens_at_pos(bufnr, row, col)","What do you think of calling this `get` and move the args into an `opts` table, treating each option like an additive filter? Similar to `diagnostic.get`:  `get(bufnr, { lnum = ..., col = ... })` (not sure about row vs. lnum, there's afaik already both used)The `tokens` is a bit redundant as it's already in the semantics_token module.`show_tokens_at_cursor` could then be changed to either `show(tokens)` or `print(tokens)`. I'd tend to `print` to mirror `vim.pretty_print`. Show has some ""special display"" behavior in other places (.e.g `diagnostic.show` doesn't print diagnostics)One would need to compose them to print: `M.print(M.get())`",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21373,1045283119,2022-12-11T19:12:01Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -585,6 +585,76 @@ function M.stop(bufnr, client_id)   end end +--- Return the semantic token(s) at the given position.+--- If called without argument, returns the token under the cursor.+---+---@param bufnr number|nil Buffer number (0 for current buffer, default)+---@param row number|nil Position row (default cursor position)+---@param col number|nil Position column (default cursor position)+---+---@return table[]|nil tokens Table of tokens at position+function M.get_tokens_at_pos(bufnr, row, col)","Hmm, not a fan, I have to admit, but will think about it.Note that show uses `nvim_echo`  to style the tokens and not just prints them.  It's also meant to be used as an interactive (cursor hold) tool, so I want it to be directly callable. That's the big selling point here.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21373,1045292082,2022-12-11T20:28:34Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -585,6 +585,76 @@ function M.stop(bufnr, client_id)   end end +--- Return the semantic token(s) at the given position.+--- If called without argument, returns the token under the cursor.+---+---@param bufnr number|nil Buffer number (0 for current buffer, default)+---@param row number|nil Position row (default cursor position)+---@param col number|nil Position column (default cursor position)+---+---@return table[]|nil tokens Table of tokens at position+function M.get_tokens_at_pos(bufnr, row, col)","Setting aside the `show` vs. `print` question, `.get()` seems like a vast improvement over `get_tokens_at_pos()` and I strongly prefer that. As @mfussenegger said having `tokens` in the function name is repetitive, as is `_at_pos()` since we can just use a table argument for the position.Pre `vim.diagnostic` the diagnostic functions were something like `vim.lsp.diagnostic.get_line_diagnostics()` which has many of the same issues that we're discussing here. I think we should stick with the `get()` pattern which is versatile enough to cover many different use cases.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21373,1045293268,2022-12-11T20:38:58Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -585,6 +585,76 @@ function M.stop(bufnr, client_id)   end end +--- Return the semantic token(s) at the given position.+--- If called without argument, returns the token under the cursor.+---+---@param bufnr number|nil Buffer number (0 for current buffer, default)+---@param row number|nil Position row (default cursor position)+---@param col number|nil Position column (default cursor position)+---+---@return table[]|nil tokens Table of tokens at position+function M.get_tokens_at_pos(bufnr, row, col)","To be clear, the difference to me here is that it might make sense to get all diagnostics, but it doesn't make sense to get all tokens/captures/extmarks.(As diagnostics are the exception, but highlighting is the rule.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20986,1045335783,2022-12-12T01:15:34Z,runtime/doc/api.txt,"@@ -3228,89 +3228,54 @@ nvim_create_augroup({name}, {*opts})                   *nvim_create_augroup()*         |autocmd-groups|  nvim_create_autocmd({event}, {*opts})                  *nvim_create_autocmd()*-    Create an |autocommand|--    The API allows for two (mutually exclusive) types of actions to be-    executed when the autocommand triggers: a callback function (Lua or-    Vimscript), or a command (like regular autocommands).--    Example using callback: >lua-        -- Lua function-        local myluafun = function() print(""This buffer enters"") end--        -- Vimscript function name (as a string)-        local myvimfun = ""g:MyVimFunction""+    Creates an |autocommand| event handler, defined by `callback` (Lua function or Vimscript function name string) or `command` (Ex command string). +    Example using Lua callback: >lua         vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {           pattern = {""*.c"", ""*.h""},-          callback = myluafun,  -- Or myvimfun+          callback = function(ev)+            print(string.format('event fired: s', vim.inspect(ev)))+          end         }) < -    Lua functions receive a table with information about the autocmd event as-    an argument. To use a function which itself accepts another (optional)-    parameter, wrap the function in a lambda: >lua-        -- Lua function with an optional parameter.-        -- The autocmd callback would pass a table as argument but this-        -- function expects number|nil-        local myluafun = function(bufnr) bufnr = bufnr or vim.api.nvim_get_current_buf() end--        vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {-          pattern = {""*.c"", ""*.h""},-          callback = function() myluafun() end,-        })-<--    Example using command: >lua+    Example using an Ex command as the handler: >lua         vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {           pattern = {""*.c"", ""*.h""},           command = ""echo 'Entering a C or C++ file'"",         }) < -    Example values for pattern: >lua-      pattern = ""*.py""-      pattern = { ""*.py"", ""*.pyi"" }",Redundant because the other examples already have example patterns. The four different examples here looked overwhelming and distracted from the real content. We only need one or two examples showing common use case.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20986,1045335891,2022-12-12T01:16:02Z,runtime/doc/api.txt,"@@ -3228,89 +3228,54 @@ nvim_create_augroup({name}, {*opts})                   *nvim_create_augroup()*         |autocmd-groups|  nvim_create_autocmd({event}, {*opts})                  *nvim_create_autocmd()*-    Create an |autocommand|--    The API allows for two (mutually exclusive) types of actions to be-    executed when the autocommand triggers: a callback function (Lua or-    Vimscript), or a command (like regular autocommands).--    Example using callback: >lua-        -- Lua function-        local myluafun = function() print(""This buffer enters"") end--        -- Vimscript function name (as a string)-        local myvimfun = ""g:MyVimFunction""+    Creates an |autocommand| event handler, defined by `callback` (Lua function or Vimscript function name string) or `command` (Ex command string). +    Example using Lua callback: >lua         vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {           pattern = {""*.c"", ""*.h""},-          callback = myluafun,  -- Or myvimfun+          callback = function(ev)+            print(string.format('event fired: s', vim.inspect(ev)))+          end         })",There was way too much going on here. Just inline the function. And show an example of the `ev` parameter.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/20986,1045336209,2022-12-12T01:17:09Z,runtime/doc/api.txt,"@@ -3228,89 +3228,54 @@ nvim_create_augroup({name}, {*opts})                   *nvim_create_augroup()*         |autocmd-groups|  nvim_create_autocmd({event}, {*opts})                  *nvim_create_autocmd()*-    Create an |autocommand|--    The API allows for two (mutually exclusive) types of actions to be-    executed when the autocommand triggers: a callback function (Lua or-    Vimscript), or a command (like regular autocommands).--    Example using callback: >lua-        -- Lua function-        local myluafun = function() print(""This buffer enters"") end--        -- Vimscript function name (as a string)-        local myvimfun = ""g:MyVimFunction""+    Creates an |autocommand| event handler, defined by `callback` (Lua function or Vimscript function name string) or `command` (Ex command string). +    Example using Lua callback: >lua         vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {           pattern = {""*.c"", ""*.h""},-          callback = myluafun,  -- Or myvimfun+          callback = function(ev)+            print(string.format('event fired: s', vim.inspect(ev)))+          end         }) < -    Lua functions receive a table with information about the autocmd event as-    an argument. To use a function which itself accepts another (optional)-    parameter, wrap the function in a lambda: >lua-        -- Lua function with an optional parameter.-        -- The autocmd callback would pass a table as argument but this-        -- function expects number|nil-        local myluafun = function(bufnr) bufnr = bufnr or vim.api.nvim_get_current_buf() end--        vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {-          pattern = {""*.c"", ""*.h""},-          callback = function() myluafun() end,-        })-<--    Example using command: >lua+    Example using an Ex command as the handler: >lua         vim.api.nvim_create_autocmd({""BufEnter"", ""BufWinEnter""}, {           pattern = {""*.c"", ""*.h""},           command = ""echo 'Entering a C or C++ file'"",         }) < -    Example values for pattern: >lua-      pattern = ""*.py""-      pattern = { ""*.py"", ""*.pyi"" }-<--    Note: The `pattern` is passed to callbacks and commands as a literal string; environment-    variables like `$HOME` and `~` are not automatically expanded as they are by |:autocmd|. Instead,-    |expand()| such variables explicitly: >lua+    Note: `pattern` is NOT automatically expanded (unlike with |:autocmd|), thus names like+    ""$HOME"" and ""~"" must be expanded explicitly: >lua       pattern = vim.fn.expand(""~"") .. ""/some/path/*.py"" < -    Example values for event: >lua-      event = ""BufWritePre""-      event = {""CursorHold"", ""BufWritePre"", ""BufWritePost""}-<-     Parameters: ~-      ��� {event}  (string|array) The event or events to register this-                 autocommand-      ��� {opts}   Dictionary of autocommand options:-                 ��� group (string|integer) optional: the autocommand group name-                   or id to match against.-                 ��� pattern (string|array) optional: pattern or patterns to-                   match literally against |autocmd-pattern|.-                 ��� buffer (integer) optional: buffer number for buffer local+      ��� {event}  (string|array) Event(s) that will trigger the handler+                 (`callback` or `command`).+      ��� {opts}   Options dict:+                 ��� group (string|integer) optional: autocommand group name or+                   id to match against.+                 ��� pattern (string|array) optional: pattern(s) to match+                   literally |autocmd-pattern|.+                 ��� buffer (integer) optional: buffer number for buffer-local                    autocommands |autocmd-buflocal|. Cannot be used with                    {pattern}.-                 ��� desc (string) optional: description of the autocommand.-                 ��� callback (function|string) optional: if a string, the name-                   of a Vimscript function to call when this autocommand is-                   triggered. Otherwise, a Lua function which is called when-                   this autocommand is triggered. Cannot be used with","Several places in the docs mention the mutual exclusive thing. When docs are this long, that kind of stuff should be dropped--it will be caught immediately by validation, so there's no need to have so much of the docs spent on it. Let the docs point out the more important things.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20621,1046002867,2022-12-12T15:48:53Z,src/nvim/drawline.c,"@@ -2697,6 +2812,10 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange,       if (filler_todo <= 0) {         need_showbreak = true;       }+      if (statuscol.draw) {+        statuscol.draw = vim_strchr(p_cpo, CPO_NUMCOL) == NULL;+        statuscol.hl_idx = 0;+      }",Sounds ok. That information definitely belongs in a comment.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1046013846,2022-12-12T15:56:19Z,runtime/doc/options.txt,"@@ -6033,6 +6033,52 @@ A jump table for the options with a short description can be found at |Q_op|. 	In case of buffer changing commands the cursor is placed at the column 	where it was the last time the buffer was edited. +				*'statuscolumn'* *'stc'*+'statuscolumn' 'stc'	string	(default: empty)+			local to window+	EXPERIMENTAL+	When this option is not empty, it determines the content of the area to","The same wording is used for `iconstring`, `indentexpr`, `rulerformat` and `titlestring` btw, that's why I used it. `statusline` on the other hand reads:    	When non-empty, this option determines the content of the status line.I guess I'll word it similar to that.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21374,1046163289,2022-12-12T17:44:53Z,runtime/lua/vim/treesitter.lua,"@@ -248,62 +256,55 @@ function M.get_captures_at_pos(bufnr, row, col)   return matches end ---- Returns a list of highlight capture names under the cursor+--- Shows the list of highlight capture names under the cursor --- ---@param winnr (number|nil) Window handle or 0 for current window (default)--------@return string[] List of capture names-function M.get_captures_at_cursor(winnr)+function M.show_captures_at_cursor(winnr)","What would be the use case? (Adding arbitrary position would complicate/duplicate the code somewhat, so I'm a bit hesitant.)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21374,1046206895,2022-12-12T18:10:11Z,runtime/lua/vim/treesitter.lua,"@@ -248,62 +256,55 @@ function M.get_captures_at_pos(bufnr, row, col)   return matches end ---- Returns a list of highlight capture names under the cursor+--- Shows the list of highlight capture names under the cursor --- ---@param winnr (number|nil) Window handle or 0 for current window (default)--------@return string[] List of capture names-function M.get_captures_at_cursor(winnr)+function M.show_captures_at_cursor(winnr)",Would it? I think you would just add a `row` and `col` parameter like you have for `get_captures_at_pos` and forward those directly to `get_captures_at_pos` on line 267.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21373,1046371335,2022-12-12T20:43:29Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -575,6 +585,76 @@ function M.stop(bufnr, client_id)   end end +--- Return the semantic token(s) at the given position.+--- If called without argument, returns the token under the cursor.+---+---@param bufnr number|nil Buffer number (0 for current buffer, default)+---@param row number|nil Position row (default cursor position)+---@param col number|nil Position column (default cursor position)+---+---@return table[]|nil tokens Table of tokens at position+function M.get_at_pos(bufnr, row, col)+  if bufnr == nil or bufnr == 0 then+    bufnr = api.nvim_get_current_buf()+  end++  local highlighter = STHighlighter.active[bufnr]+  if not highlighter then+    return+  end++  if not (row and col) then+    local cursor = api.nvim_win_get_cursor(0)+    row = cursor[1] - 1+    col = cursor[2]+  end++  local tokens = {}+  for _, client in pairs(highlighter.client_state) do+    local highlights = client.current_result.highlights+    if highlights then+      local idx = binary_search(highlights, row)+      for i = idx, #highlights do+        local token = highlights[i]++        if token.line > row then+          break+        end++        if token.start_col <= col and token.end_col > col then+          tokens[#tokens + 1] = token+        end+      end+    end+  end+  return tokens+end++--- Show the semantic token(s) under the cursor+function M.show_at_cursor()+  local tokens = M.get_at_pos()+  if not tokens then+    return+  end","```suggestion--- Show the semantic token(s) under the cursor---@param tokens table[]|nil tokens to print, defaults to tokens at cursorfunction M.show(tokens)  tokens = tokens or M.get_at_pos()  if not tokens then    return  end```This is what I had in mind - it would allow to combine it with `M.get_at_pos` to print the tokens from another position.But I don't really have a concrete use-case for it.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1046475108,2022-12-12T22:59:31Z,src/nvim/drawline.c,"@@ -1126,7 +1223,7 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange,       }        if (draw_state == WL_FOLD - 1 && n_extra == 0) {-        int fdc = compute_foldcolumn(wp, 0);+        int fdc = statuscol.draw ? 0 : compute_foldcolumn(wp, 0);",Yeah that's cleaner. `WL_BRI` and `WL_SBR` are missing in those chains.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1046482354,2022-12-12T23:12:24Z,src/nvim/drawline.c,"@@ -395,6 +398,94 @@ static int get_sign_attrs(buf_T *buf, linenr_T lnum, SignTextAttrs *sattrs, int   return num_signs; } +static void get_statuscol_str(win_T *wp, linenr_T lnum, int row, int startrow, int filler_lines,+                              int cul_attr, int sign_num_attr, SignTextAttrs *sattrs,+                              foldinfo_T foldinfo, char_u *extra, statuscol_T *stcp)+{+  int sign_idx = 0;+  bool wrapped = row != startrow + filler_lines;+  bool use_cul = use_cursor_line_sign(wp, lnum);++  if (!wrapped) {+    // Set number and fold text and attrs+    set_vim_var_nr(VV_LNUM, lnum);+    set_vim_var_nr(VV_RELNUM, labs((long)get_cursor_rel_lnum(wp, lnum)));+    stcp->num_attr = sign_num_attr ? sign_num_attr+                     : get_line_number_attr(wp, lnum, row, startrow, filler_lines);++    if (compute_foldcolumn(wp, 0)) {+      stcp->fold_attr = win_hl_attr(wp, use_cul ? HLF_CLF : HLF_FC);+      size_t n = fill_foldcolumn((char_u *)stcp->fold_text, wp, foldinfo, lnum);+      stcp->fold_text[n] = NUL;+    }+  }+  // Set sign text and attrs, empty when wrapped+  for (; sign_idx < wp->w_scwidth; sign_idx++) {+    SignTextAttrs *sattr = wrapped ? NULL : sign_get_attr(sign_idx, sattrs, wp->w_scwidth);+    stcp->sign_text[sign_idx] = sattr && sattr->text ? sattr->text : ""  "";+    stcp->sign_attr[sign_idx] = use_cul && cul_attr ? cul_attr : sattr ? sattr->hl_attr_id : 0;+  }+  stcp->sign_text[sign_idx] = NULL;+  set_vim_var_bool(VV_WRAP, wrapped);++  StlClickRecord *clickrec;++  int width = build_stl_str_hl(wp, stcp->text, MAXPATHL, wp->w_p_stc, ""statuscolumn"",+                               OPT_LOCAL, ' ', stcp->width, &stcp->hlrec, &clickrec, stcp);++  // Force a redraw in case of error or when truncated+  if (*wp->w_p_stc == NUL || (stcp->truncate > 0 && wp->w_nrwidth < 19)) {+    if (stcp->truncate) {  // Avoid truncating 'statuscolumn'+      wp->w_nrwidth_width = MIN(19, wp->w_nrwidth_width + stcp->truncate);+    } else {  // 'statuscolumn' reset due to error+      wp->w_nrwidth_line_count = 0;+    }+    wp->w_redr_statuscol = true;+    return;+  }+  // Reset text pointer and current attr for new line+  stcp->textp = stcp->text;+  stcp->cur_attr = stcp->num_attr;+  stcp->text_len = strlen(stcp->text);++  size_t fill = (size_t)(stcp->width - width);",Done (although `stcp->width` is guaranteed to be larger than or equal to `width` by `build_stl_str_hl()`,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21393,1046585723,2022-12-13T01:56:36Z,runtime/lua/vim/highlight.lua,"@@ -151,4 +151,76 @@ function M.on_yank(opts)   end, timeout) end +-- Shows the highlights under the cursor from Treesitter, Syntax & Extmarks+function M.show()+  local buf = vim.api.nvim_get_current_buf()+  local cursor = vim.api.nvim_win_get_cursor(0)++  local highlights = {}++  -- treesitter+  for _, capture in pairs(vim.treesitter.get_captures_at_pos(buf, cursor[1] - 1, cursor[2])) do+    table.insert(highlights, { source = 'treesitter', hl = '@' .. capture.capture })+  end++  -- syntax+  for _, i1 in ipairs(vim.fn.synstack(cursor[1], cursor[2] + 1)) do+    table.insert(highlights, { source = 'syntax', hl = vim.fn.synIDattr(i1, 'name') })+  end++  -- extmarks+  for ns, nsid in pairs(vim.api.nvim_get_namespaces()) do+    local extmarks = vim.api.nvim_buf_get_extmarks(+      buf,+      nsid,+      { cursor[1] - 1, 0 },+      { cursor[1] - 1, -1 },+      { details = true }+    )+    for _, extmark in ipairs(extmarks) do+      local details = extmark[4]+      local col = extmark[3]+      if+        details.hl_group+        and (+          col == cursor[2] or (details.end_col and cursor[2] >= col and cursor[2] < details.end_col)+        )+      then+        table.insert(highlights, { source = 'extmark: ' .. ns, hl = details.hl_group or '' })+      end+    end+  end++  -- resolve links+  for _, hl in ipairs(highlights) do+    local hlid = vim.api.nvim_get_hl_id_by_name(hl.hl)+    local name = vim.fn.synIDattr(vim.fn.synIDtrans(hlid), 'name')+    if name ~= hl.hl then+      hl.link = name+    end+  end++  local width = 0+  for _, hl in ipairs(highlights) do+    width = math.max(width, vim.fn.strwidth(hl.hl))+  end++  ---@type {[1]:string, [2]:string}[]+  local chunks = {}","So this is the ""pretty printed"" form, right? And it's a stack?But the `highlights` structure could be useful too. So maybe the code before this should be extracted to `vim.get_at_pos()`--and the `highlights` should perhaps be a dict rather than a list--easier for callers to use.",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/21397,1047020106,2022-12-13T11:18:45Z,runtime/lua/vim/diagnostic.lua,"@@ -478,6 +478,10 @@ local function set_list(loclist, opts)   -- numbers beyond the end of the buffer   local diagnostics = get_diagnostics(bufnr, opts, false)   local items = M.toqflist(diagnostics)+  if #items == 0 then",I think you'd better add a test for this. refhttps://github.com/neovim/neovim/blob/a6b05cb75d330dd995d3ad21ee08bb0a2cfcae74/test/functional/lua/diagnostic_spec.lua#L1975,
8556349,leaxoy,https://api.github.com/repos/neovim/neovim/pulls/21397,1047030480,2022-12-13T11:25:59Z,runtime/lua/vim/diagnostic.lua,"@@ -478,6 +478,10 @@ local function set_list(loclist, opts)   -- numbers beyond the end of the buffer   local diagnostics = get_diagnostics(bufnr, opts, false)   local items = M.toqflist(diagnostics)+  if #items == 0 then","But I have no idea how to add tests, because new implementation does't produce any data and return directly.���� Could you give me some suggestion? ",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/21397,1047052424,2022-12-13T11:44:58Z,runtime/lua/vim/diagnostic.lua,"@@ -478,6 +478,10 @@ local function set_list(loclist, opts)   -- numbers beyond the end of the buffer   local diagnostics = get_diagnostics(bufnr, opts, false)   local items = M.toqflist(diagnostics)+  if #items == 0 then","just take a look at the test case, there is no test case for `vim.diagnostic.setqflist`  ����  maybe no need . wait the @gpanders review ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21393,1047832016,2022-12-13T22:53:35Z,runtime/lua/vim/inspector.lua,"@@ -0,0 +1,207 @@+local M = {}++---@class InspectorFilter+---@field syntax boolean include syntax based highlight groups (defaults to true)+---@field treesitter boolean include treesitter based highlight groups (defaults to true)+---@field extmarks boolean include extmarks (defaults to true)+---@field extmarks_with_hl_group boolean when false, also include extmarks without a hl_group (defaults to true)+---@field semantic_tokens boolean include semantic tokens (defaults to true)+local defaults = {+  syntax = true,+  treesitter = true,+  extmarks = true,+  extmarks_with_hl_group = true,+  semantic_tokens = true,+}++---Get all the items at a given buffer position+---@param bufnr? buffer defaults to the current buffer+---@param row? number 0-indexed row. Defaults to the current cursor+---@param col? number 0-indexed col. Defaults to the current cursor+---@param filter? InspectorFilter (table|nil) a table with key-value pairs to filter the items+---               - syntax (boolean): include syntax based highlight groups (defaults to true)+---               - treesitter (boolean): include treesitter based highlight groups (defaults to true)+---               - extmarks (boolean): include extmarks (defaults to true)+---               - extmarks_with_hl_group (boolean): when false, also include extmarks without a hl_group (defaults to true)+---               - semantic_tokens (boolean): include semantic tokens (defaults to true)+function M.get(bufnr, row, col, filter)","~~Should we leave the door open for a future `win` parameter?~~ No, we would probably want `vim.inspect_win`, because the implementation would heavily diverge.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/20621,1047841210,2022-12-13T23:09:43Z,src/nvim/drawline.c,"@@ -1098,6 +1189,12 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange,     extra_check = true;   } +  statuscol_T statuscol = { 0 };+  if (*wp->w_p_stc != NUL && (wp->w_p_nu || wp->w_p_rnu)) {","Since this option has evolved from being just a 'numberformat', I think it no longer makes sense to only draw the statuscolumn if either 'number' or 'relativenumber' is set. Removing.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21393,1048292889,2022-12-14T10:36:06Z,runtime/doc/news.txt,"@@ -39,6 +39,10 @@ NEW FEATURES                                                    *news-features*  The following new APIs or features were added. +��� |vim.inspect_pos()|, |vim.show_pos()| and |:Inspect| allows a user to get or show items+  at a given buffer postion. Currently this inlcudes treesitter captures,+  semantic tokens, syntax highlight groups and extmarks.","Doesn't this capture all syntax groups?```suggestion  semantic tokens, syntax groups and extmarks.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21393,1048796367,2022-12-14T18:04:16Z,runtime/lua/vim/_inspector.lua,"@@ -0,0 +1,220 @@+---@class InspectorFilter+---@field syntax boolean include syntax based highlight groups (defaults to true)+---@field treesitter boolean include treesitter based highlight groups (defaults to true)+---@field extmarks boolean|""all"" include extmarks. When `all`, then extmarks without a `hl_group` will also be included (defaults to true)+---@field semantic_tokens boolean include semantic tokens (defaults to true)+local defaults = {+  syntax = true,+  treesitter = true,+  extmarks = true,+  semantic_tokens = true,+}++---Get all the items at a given buffer position+---Can also be pretty printed with *:Inspect!*+---@param bufnr? number defaults to the current buffer+---@param row? number row to inspect, 0-based. Defaults to the row of the current cursor+---@param col? number col to inspect, 0-based. Defaults to the col of the current cursor+---@param filter? InspectorFilter (table|nil) a table with key-value pairs to filter the items+---               - syntax (boolean): include syntax based highlight groups (defaults to true)+---               - treesitter (boolean): include treesitter based highlight groups (defaults to true)+---               - extmarks (boolean|""all""): include extmarks. When `all`, then extmarks without a `hl_group` will also be included (defaults to true)+---               - semantic_tokens (boolean): include semantic tokens (defaults to true)+---@return {treesitter:table,syntax:table,extmarks:table,semantic_tokens:table} (table) a table with the following key-value pairs:+---               - treesitter: a list of treesitter captures+---               - syntax: a list of syntax groups+---               - semantic_tokens: a list of semantic tokens+---               - extmarks: a list of extmarks",is there an ordering guarantee we want to mention here? e.g. are the lists in z-index order?,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/21435,1050077850,2022-12-15T19:54:26Z,CMakeLists.txt,"@@ -441,32 +441,6 @@ include_directories(SYSTEM ${TreeSitter_INCLUDE_DIRS}) ",tree-sitter does not really set a version (or a meaningless) in their `pckconfig`: https://github.com/tree-sitter/tree-sitter/blob/c669e5ee159e0c59a3f094327a01dd688bc67c56/Makefile#L1 (this version didn't change since ages). This is why I didn't set a version requirement and probably why there wasn't one before. The version requirement would need to be forwarded to the pckconfig call in FindTreesitter.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/21435,1050082191,2022-12-15T19:59:58Z,CMakeLists.txt,"@@ -441,32 +441,6 @@ include_directories(SYSTEM ${TreeSitter_INCLUDE_DIRS}) ",we can also just leave the try_build commands there for longer. I think there is a open tree-sitter issue to set the version number (https://github.com/tree-sitter/tree-sitter/issues/1158),
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21436,1050199985,2022-12-15T22:29:30Z,runtime/doc/news.txt,"@@ -95,6 +95,7 @@ CHANGED FEATURES                                                 *news-changes* The following changes to existing APIs or features add new behavior.  ��� 'exrc' is no longer marked deprecated.+��� 'exrc' now supports `.nvimrc.lua` file.",Changes should be listed in reverse chronological order (so put this bullet on top).,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21407,1050271295,2022-12-16T00:49:17Z,src/nvim/tui/tui.c,"@@ -2148,10 +2169,20 @@ static void augment_terminfo(TUIData *data, const char *term, long vte_version,                && (vte_version == 0 || vte_version >= 3900)) {       // Supported in urxvt, newer VTE.       data->unibi_ext.set_cursor_color = (int)unibi_add_ext_str(ut, ""ext.set_cursor_color"",-                                                                ""\033]12;#%p1%06x\007"");+                                                                ""\033]12;%p1%s\007"");     }   }   if (-1 != data->unibi_ext.set_cursor_color) {+    /// Some terminals supporting cursor color changing specify their Cs+    /// capability to take a string parameter. Others take a numeric parameter.+    /// If and only if the format string contains `%s` we assume a string+    /// parameter. #20628",```suggestion    // Some terminals supporting cursor color changing specify their Cs    // capability to take a string parameter. Others take a numeric parameter.    // If and only if the format string contains `%s` we assume a string    // parameter. #20628```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21436,1050324210,2022-12-16T02:54:31Z,runtime/doc/news.txt,"@@ -95,6 +95,7 @@ CHANGED FEATURES                                                 *news-changes* The following changes to existing APIs or features add new behavior.  ��� 'exrc' is no longer marked deprecated.+��� 'exrc' now supports `.nvimrc.lua` file.","They will still be grouped, I meant to put the new bullet at line 96 rather than line 98.>Hmm... why?Partially because this is how new items have been added thus far, so we want to maintain ordering (assuming we care about ordering, which I think we do). For someone who checks news.txt recently for new items, it's easier to see new items at the top of each list rather than appended to the bottom (though perhaps that's subjective -- I find it more noticeable at least).",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/21436,1050676078,2022-12-16T11:57:21Z,runtime/doc/news.txt,"@@ -95,6 +95,7 @@ CHANGED FEATURES                                                 *news-changes* The following changes to existing APIs or features add new behavior.  ��� 'exrc' is no longer marked deprecated.+��� 'exrc' now supports `.nvimrc.lua` file.","If `news.txt` is to be in reverse chronological order, the exception could be related follow-up PRs. In that case grouping(and keeping the initial PR on top) might be more valuable than keeping it chronologically ordered? I think it would be if you see it as a release list but it would be less useful for someone on a dev build.",
9393486,tomcur,https://api.github.com/repos/neovim/neovim/pulls/21407,1050732293,2022-12-16T12:52:36Z,src/nvim/tui/tui.c,"@@ -2148,10 +2169,20 @@ static void augment_terminfo(TUIData *data, const char *term, long vte_version,                && (vte_version == 0 || vte_version >= 3900)) {       // Supported in urxvt, newer VTE.       data->unibi_ext.set_cursor_color = (int)unibi_add_ext_str(ut, ""ext.set_cursor_color"",-                                                                ""\033]12;#%p1%06x\007"");+                                                                ""\033]12;%p1%s\007"");     }   }   if (-1 != data->unibi_ext.set_cursor_color) {+    /// Some terminals supporting cursor color changing specify their Cs+    /// capability to take a string parameter. Others take a numeric parameter.+    /// If and only if the format string contains `%s` we assume a string+    /// parameter. #20628",Done. I checked the comment directly below to copy the stylehttps://github.com/neovim/neovim/blob/b55ccb43240c931d1a52a85b02920521a838e0a7/src/nvim/tui/tui.c#L2165-L2166Add a commit here to fix it?,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21436,1050907906,2022-12-16T15:56:25Z,src/nvim/main.c,"@@ -1972,6 +1972,35 @@ static bool do_user_initialization(void)   return do_exrc; } +// Read initialization commands from "".nvimrc.lua"", "".nvimrc"" or "".exrc"" in+// current directory.  This is only done if the 'exrc' option is set.+// Only do this if VIMRC_FILE is not the same as vimrc file sourced in+// do_user_initialization.+static void do_exrc_initialization(void)+{+  char *str;++  if (os_path_exists(VIMRC_LUA_FILE)) {+    str = nlua_read_secure(VIMRC_LUA_FILE);+    if (str != NULL) {+      nlua_exec(cstr_as_string(str), (Array)ARRAY_DICT_INIT, &ERROR_INIT);","They are different errors, the fact that one is longer than the other is not an issue.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21436,1050909896,2022-12-16T15:58:19Z,runtime/doc/news.txt,"@@ -95,6 +95,7 @@ CHANGED FEATURES                                                 *news-changes* The following changes to existing APIs or features add new behavior.  ��� 'exrc' is no longer marked deprecated.+��� 'exrc' now supports `.nvimrc.lua` file.","This may need a broader discussion, because I certainly see benefits to both.* For people following HEAD, listing changes in chronological order (reverse or otherwise) is useful to see what has changed _most recently_.* For people only updating to stable releases, chronology doesn't matter, and grouping items by ""theme"" is probably more useful.https://github.com/neovim/neovim/issues/21431 might be a way out of this. For now, I'd still recommend sticking to reverse chronological order as that is the order that every other item in news.txt has been added thus far. If we change it later to be grouped by ""theme"", we can change everything all at once.",
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/21436,1050936875,2022-12-16T16:27:07Z,src/nvim/main.c,"@@ -1972,6 +1972,35 @@ static bool do_user_initialization(void)   return do_exrc; } +// Read initialization commands from "".nvimrc.lua"", "".nvimrc"" or "".exrc"" in+// current directory.  This is only done if the 'exrc' option is set.+// Only do this if VIMRC_FILE is not the same as vimrc file sourced in+// do_user_initialization.+static void do_exrc_initialization(void)+{+  char *str;++  if (os_path_exists(VIMRC_LUA_FILE)) {+    str = nlua_read_secure(VIMRC_LUA_FILE);+    if (str != NULL) {+      nlua_exec(cstr_as_string(str), (Array)ARRAY_DICT_INIT, &ERROR_INIT);","Ah, I wasn't showing that they are different. I was just showing that I kept the first line similar. ����",
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/21436,1050970146,2022-12-16T17:04:53Z,runtime/doc/starting.txt,"@@ -453,8 +453,9 @@ accordingly, proceeding as follows: 	set or when using $VIMINIT.       c. If the 'exrc' option is on (which is NOT the default), the current-	directory is searched for two files.  The first that exists is used,-	the others are ignored.+	directory is searched for the following files.  The first that exists","Let me know if I should change the file names in this PR. Or if it'll be decided and renamed later.Personally, I don't mind the `rc` suffix. About other editors... `.idea`, `.vscode` are both directory. Also, if in future neovim wants to introduce a directory like that (e.g. `.nvim/`), renaming `.nvimrc` file to `.nvim` now would conflict with that later.",
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/21436,1050982045,2022-12-16T17:14:03Z,runtime/doc/starting.txt,"@@ -453,8 +453,9 @@ accordingly, proceeding as follows: 	set or when using $VIMINIT.       c. If the 'exrc' option is on (which is NOT the default), the current-	directory is searched for two files.  The first that exists is used,-	the others are ignored.+	directory is searched for the following files.  The first that exists","> If that's not a concernI can revert it if you want.Btw, checked the vim's file. Looks like it has some other things going on, like separate naming for windows?<img width=""687"" alt=""image"" src=""https://user-images.githubusercontent.com/8050659/208152240-dbed5ef0-a9b9-4944-8a0f-249be10211a6.png"">So this part of the doc looks like already diverged a fair bit.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21397,1051512781,2022-12-18T02:28:22Z,runtime/lua/vim/diagnostic.lua,"@@ -478,6 +478,10 @@ local function set_list(loclist, opts)   -- numbers beyond the end of the buffer   local diagnostics = get_diagnostics(bufnr, opts, false)   local items = M.toqflist(diagnostics)+  if #items == 0 then","> `#` works for serialized table . so use `next(item) == nil ` or `vim.tbl_count(item) == 0`This table is a list like table, so using `#` is fine (and preferred, as its intention is clearer than `next()`).",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/21463,1051565640,2022-12-18T09:52:09Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -331,6 +331,10 @@ function STHighlighter:process_response(response, client, version)     tokens = response.data",Probably be better to change this line instead to `tokens = response.data or {}`?,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/21210,1055924655,2022-12-22T23:23:29Z,CMakeLists.txt,"@@ -141,6 +141,12 @@ set(NVIM_VERSION_MAJOR 0) set(NVIM_VERSION_MINOR 9) set(NVIM_VERSION_PATCH 0) set(NVIM_VERSION_PRERELEASE ""-dev"") # for package maintainers+# Allow manually setting git tag for situations where `git describe` cannot+# work such as the nix flake.","after discussion with @dundargoc , doing everything in nix seems better. Looking at the code I think patching the generated file https://github.com/neovim/neovim/blob/98daaa798e018071876d026a60840991be8d8069/cmake.config/versiondef.h.in#L7 after the configurePhase to insert self.shortRev into it is the best way",
1353637,stasjok,https://api.github.com/repos/neovim/neovim/pulls/21524,1056875665,2022-12-24T21:44:10Z,runtime/lua/vim/lsp.lua,"@@ -1842,10 +1842,16 @@ function lsp.get_active_clients(filter)    local t = filter.bufnr and (all_buffer_active_clients[resolve_bufnr(filter.bufnr)] or {})     or active_clients++  if #active_clients == 0 then","`active_clients` are indexed by client id, right? So it can have holes. If client with id 1 is stopped, then this condition returns too early.",
40620903,figsoda,https://api.github.com/repos/neovim/neovim/pulls/21548,1057347383,2022-12-26T21:24:46Z,runtime/lua/vim/treesitter/query.lua,"@@ -267,6 +267,50 @@ function M.get_node_text(node, source, opts)   end end +--- Gets the text corresponding to a given query capture",`get_capture_text` also reads `text` and `range` from the metadata,
40620903,figsoda,https://api.github.com/repos/neovim/neovim/pulls/21548,1057348011,2022-12-26T21:29:56Z,runtime/lua/vim/treesitter/query.lua,"@@ -267,6 +267,50 @@ function M.get_node_text(node, source, opts)   end end +--- Gets the text corresponding to a given query capture","this should also be possible by adding `id` and `metadata` to `opts`, should I do that instead?",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/21548,1057350981,2022-12-26T21:54:06Z,runtime/lua/vim/treesitter/query.lua,"@@ -408,12 +455,24 @@ local directive_handlers = {      -- If this produces an invalid range, we just skip it.     if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      if not metadata[capture_id] then-        metadata[capture_id] = {}-      end       metadata[capture_id].range = range     end   end,++  -- Transform the content of the node+  -- Example: (#gsub! @_node "".*%.(.*)"" ""%1"")+  ['gsub!'] = function(match, _, bufnr, pred, metadata)",`gsub!` could also store it's result in metadata. This is how `#downcase!` in nvim-treesitter works. It would avoid an additional function and the need to change all usages of `get_node_text` in predicates. `#downcase!` is already used for injections where the language name is printed in uppercase.It could be complicated to mutate meaning of the capture text as it is unclear whether `#match?` should work on the preprocessed or the original result.,X
40620903,figsoda,https://api.github.com/repos/neovim/neovim/pulls/21548,1057354841,2022-12-26T22:24:24Z,runtime/lua/vim/treesitter/query.lua,"@@ -408,12 +455,24 @@ local directive_handlers = {      -- If this produces an invalid range, we just skip it.     if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      if not metadata[capture_id] then-        metadata[capture_id] = {}-      end       metadata[capture_id].range = range     end   end,++  -- Transform the content of the node+  -- Example: (#gsub! @_node "".*%.(.*)"" ""%1"")+  ['gsub!'] = function(match, _, bufnr, pred, metadata)","> gsub! could also store it's result in metadatadone> It could be complicated to mutate meaning of the capture text as it is unclear whether #match? should work on the preprocessed or the original result.currently predicates only work on the original result since `add_predicate`'s handler doesn't accept metadata, directives also need changes like https://github.com/neovim/neovim/commit/535ebbf66b644cc9ee06bc206bdf8340f765af63",
40620903,figsoda,https://api.github.com/repos/neovim/neovim/pulls/21548,1057354962,2022-12-26T22:25:29Z,runtime/lua/vim/treesitter/query.lua,"@@ -267,6 +267,50 @@ function M.get_node_text(node, source, opts)   end end +--- Gets the text corresponding to a given query capture","instead of passing both `id` and `metadata`, I opted to pass `metadata[id]` to `metadata` to simplify the logic a bit. The naming might be a little confusing but I couldn't come up with a different name",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21538,1057596149,2022-12-27T10:38:03Z,runtime/doc/lua.txt,"@@ -714,6 +714,18 @@ vim.mpack.encode({obj})                                     *vim.mpack.encode* vim.mpack.decode({str})                                     *vim.mpack.decode*     Decodes (or ""unpacks"") the msgpack-encoded {str} to a Lua object. +------------------------------------------------------------------------------+VIM.JSON                                                            *lua-json*++The *vim.json* module provides encoding and decoding of Lua objects to and+from JSON-encoded strings. Supports |vim.NIL| and |vim.empty_dict()|.++vim.json.encode({obj})                                       *vim.json.encode*+    Encodes (or ""packs"") Lua object {obj} as JSON in a Lua string.++vim.json.decode({str})                                       *vim.json.decode*","Decode also takes a second options parameter with `luanil = { object: bool, array: bool }` to control if null values should use vim.NIL or nil.See https://github.com/neovim/neovim/pull/15854/files",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/21548,1058242204,2022-12-28T10:20:50Z,runtime/lua/vim/treesitter/query.lua,"@@ -408,12 +455,24 @@ local directive_handlers = {      -- If this produces an invalid range, we just skip it.     if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      if not metadata[capture_id] then-        metadata[capture_id] = {}-      end       metadata[capture_id].range = range     end   end,++  -- Transform the content of the node+  -- Example: (#gsub! @_node "".*%.(.*)"" ""%1"")+  ['gsub!'] = function(match, _, bufnr, pred, metadata)","I was actually asking, why you want to transform the capture instead of giving the result a new name (=new metadata name unrelated to capture)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/21573,1058837517,2022-12-29T09:23:49Z,CONTRIBUTING.md,"@@ -260,6 +260,19 @@ For managing includes in C files, use [include-what-you-use].  See [#549][549] for more details. +### Lua Scripting++Neovim uses precompiled Lua bytecode, so Lua files in [`./runtime`](./runtime) won't get used if you run a newly-built Neovim.","This is not true for all lua files in runtime. While this list is subject to change, and thus the _general advice_ to use `--luamod-dev` here is the correct one, this paragraph also suggests that the absence of this flag causes no `runtime/lua` files to be used, which is not the case.",X
2452791,nobe4,https://api.github.com/repos/neovim/neovim/pulls/21573,1058855859,2022-12-29T10:00:00Z,CONTRIBUTING.md,"@@ -260,6 +260,19 @@ For managing includes in C files, use [include-what-you-use].  See [#549][549] for more details. +### Lua Scripting++Neovim uses precompiled Lua bytecode, so Lua files in [`./runtime`](./runtime) won't get used if you run a newly-built Neovim.","Thanks for the precision ���� How about:```suggestionNeovim uses precompiled Lua bytecode, some Lua files in [`./runtime`](./runtime) won't get used if you run a newly-built Neovim.```It'd be better to have the list/reference linked, but I can see that it would be confusing as well.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21586,1059490527,2022-12-30T18:43:30Z,scripts/genvimvim.lua,"@@ -112,10 +112,19 @@ for au, _ in pairs(auevents.aliases) do   end end +local function sorted_keys(tab)+    local result = {}+    for key, _ in pairs(tab) do+        table.insert(result, key)+    end+    table.sort(result)+    return result+end+ local nvimau_start = 'syn keyword nvimAutoEvent contained ' w('\n\n' .. nvimau_start) -for au, _ in pairs(auevents.nvim_specific) do+for _, au in ipairs(sorted_keys(auevents.nvim_specific)) do","similar to what's discussed in https://github.com/neovim/neovim/pull/20355#discussion_r980511837 , can the root cause be fixed instead of sorting at the ""leaf logic"" here?Similar question for LUA_GEN_PRG",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21586,1059491126,2022-12-30T18:46:29Z,CMakeLists.txt,"@@ -598,6 +598,17 @@ endif()  message(STATUS ""Using Lua interpreter: ${LUA_PRG}"") +# Some of the code generation still relies on stable table ordering in order to+# produce reproducible output - specifically the msgpack'ed data in+# funcs_metadata.generated.h and ui_events_metadata.generated.h. This should+# ideally be fixed in the generators, but until then as a workaround you may provide","If this unblocks you then perhaps it's ok as a temporary workaround, but please leave a note at https://github.com/neovim/neovim/issues/20124 and the commit message, explaining the steps needed to unwind this temporary workaround. It looks like the steps are : 1. fix the ordering of msgpack'd data in `funcs_metadata.generated.h` and `ui_events_metadata.generated.h`2. ?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21474,1059503056,2022-12-30T19:40:24Z,src/nvim/api/options.c,"@@ -254,17 +222,19 @@ void nvim_set_option(uint64_t channel_id, String name, Object value, Error *err)  /// Gets the global value of an option. ///+/// @deprecated /// @param name     Option name /// @param[out] err Error details, if any /// @return         Option value (global) Object nvim_get_option(String name, Arena *arena, Error *err)","if possible, ideally this would live in `api/deprecated.c`",
131856,raboof,https://api.github.com/repos/neovim/neovim/pulls/21586,1059630127,2022-12-31T11:24:50Z,scripts/genvimvim.lua,"@@ -112,10 +112,19 @@ for au, _ in pairs(auevents.aliases) do   end end +local function sorted_keys(tab)+    local result = {}+    for key, _ in pairs(tab) do+        table.insert(result, key)+    end+    table.sort(result)+    return result+end+ local nvimau_start = 'syn keyword nvimAutoEvent contained ' w('\n\n' .. nvimau_start) -for au, _ in pairs(auevents.nvim_specific) do+for _, au in ipairs(sorted_keys(auevents.nvim_specific)) do","> similar to what's discussed in [#20355 (comment)](https://github.com/neovim/neovim/pull/20355#discussion_r980511837) , can the root cause be fixed instead of sorting at the ""leaf logic"" here?TBH I find it hard to say whether changing the structure of `auevents.nvim_specific` to make sure the output is deterministic is ""fixing the root cause"" or ""leaking a presentation concern into the data layer"" - but happy to adapt :)> Similar question for LUA_GEN_PRGHere I completely agree we should fix the 'root cause', which is the fact that the mpack'ed data contains string-keyed tables which are not serialized deterministically.",
131856,raboof,https://api.github.com/repos/neovim/neovim/pulls/21586,1059630180,2022-12-31T11:25:17Z,CMakeLists.txt,"@@ -598,6 +598,17 @@ endif()  message(STATUS ""Using Lua interpreter: ${LUA_PRG}"") +# Some of the code generation still relies on stable table ordering in order to+# produce reproducible output - specifically the msgpack'ed data in+# funcs_metadata.generated.h and ui_events_metadata.generated.h. This should+# ideally be fixed in the generators, but until then as a workaround you may provide","AFAICS the ordering of msgpack'd data is the only remaining work that requires this workaround. Improved the commit message, happy to also add it to #20124 when this part is merged.> btw, does this _actually_ unblock you (e.g. are you packaging for a distro?), or is this only theoretical currently?Yes, this helps neovim be reproducible for nixos (https://github.com/NixOS/nixpkgs/pull/208103). Of course we could also keep the patch locally in nixpkgs, but I prefer upstreaming as much as possible - so perhaps other distro's can also leverage it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21586,1059657816,2022-12-31T15:41:35Z,scripts/genvimvim.lua,"@@ -112,10 +112,19 @@ for au, _ in pairs(auevents.aliases) do   end end +local function sorted_keys(tab)+    local result = {}+    for key, _ in pairs(tab) do+        table.insert(result, key)+    end+    table.sort(result)+    return result+end+ local nvimau_start = 'syn keyword nvimAutoEvent contained ' w('\n\n' .. nvimau_start) -for au, _ in pairs(auevents.nvim_specific) do+for _, au in ipairs(sorted_keys(auevents.nvim_specific)) do","> hard to say whether changing the structure of auevents.nvim_specific to make sure the output is deterministic is ""fixing the root cause"" or ""leaking a presentation concern into the data layer"" fair point, but if making the source structure deterministic has no downsides, better to do it there. Reduces entropy in general :)",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21586,1059660721,2022-12-31T16:21:57Z,scripts/genvimvim.lua,"@@ -112,10 +112,19 @@ for au, _ in pairs(auevents.aliases) do   end end +local function sorted_keys(tab)+    local result = {}+    for key, _ in pairs(tab) do+        table.insert(result, key)+    end+    table.sort(result)+    return result+end+ local nvimau_start = 'syn keyword nvimAutoEvent contained ' w('\n\n' .. nvimau_start) -for au, _ in pairs(auevents.nvim_specific) do+for _, au in ipairs(sorted_keys(auevents.nvim_specific)) do","> but if making the source structure deterministic has no downsidesLooking at the latest of this PR, I see a downside: having to structure e.g. `keysets.lua` as a list instead of a dict is awkward. So I agree we need something like a `sorted()` function that iterates dicts in order.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/21548,1059779010,2023-01-01T17:41:21Z,runtime/lua/vim/treesitter/query.lua,"@@ -408,12 +455,24 @@ local directive_handlers = {      -- If this produces an invalid range, we just skip it.     if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      if not metadata[capture_id] then-        metadata[capture_id] = {}-      end       metadata[capture_id].range = range     end   end,++  -- Transform the content of the node+  -- Example: (#gsub! @_node "".*%.(.*)"" ""%1"")+  ['gsub!'] = function(match, _, bufnr, pred, metadata)","No, there is no explanation in the original PR. You can dynamically inject a language with a `@language` capture but also with `.language` metadata. So why is a transformation of a capture necessary. `#down-case!` was also thought for dynamic language injection, it was first first modifying the capture and in the end we thought it would be easier to leave capture immutable. It didn't require changes to the original code and there was no ambiguity for plugins whether `@foo` would refer to the un-processed or processed version of it, which is more clear when you give input and output different names. Of course, magically transforming the capture text might be convenient as further predicates or plugins might automatically (automagically) profit from the transformed text. However, we did not have a clear answer in which order the predicates and directives run at that time and didn't dare to solve that problem at that time. When we're mutating capture, there should also be a clear documentation in which order the predicates/directives run to make clear whether they will see the transformed or untransformed text.",
40620903,figsoda,https://api.github.com/repos/neovim/neovim/pulls/21548,1059781697,2023-01-01T18:13:07Z,runtime/lua/vim/treesitter/query.lua,"@@ -408,12 +455,24 @@ local directive_handlers = {      -- If this produces an invalid range, we just skip it.     if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      if not metadata[capture_id] then-        metadata[capture_id] = {}-      end       metadata[capture_id].range = range     end   end,++  -- Transform the content of the node+  -- Example: (#gsub! @_node "".*%.(.*)"" ""%1"")+  ['gsub!'] = function(match, _, bufnr, pred, metadata)","> So why is a transformation of a capture necessaryPreviously `#down-case!` was the only directive AFAIK that does something to `@language`, which is unintuitive to me since everything works for `@content`, and it took me a lot of debbuging to realize that they don't work as I was trying to implement dynamic injections for nix. This allows so that these directives do work, and makes it possible to implement injections where you need to do more than just downcasing like the one in the description with existing tools like `#offset!` and the added `#gsub!`. This was not previously possible AFAIK without implementing less intuitive directives like I did in https://github.com/nvim-treesitter/nvim-treesitter/pull/3902.> there was no ambiguity for plugins whether @foo would refer to the un-processed or processed version of itThere was no ambiguity for `#downcase!`, but it was ambiguous to me and undocumented that all the other directives don't work as I expected.> we did not have a clear answer in which order the predicates and directives run at that time and didn't dare to solve that problem at that time`#downcase!` was the only directive that work for `@language`, and there was no other reasons for users to mix and match directives and predicates for `@language`. The behavior with predicates didn't change: they still operate on the unprocessed nodes, and I think it's a clear improvement that directives actually work even though they might be unordered - they used to not work at all. This should not break anything if it is implemented correctly.",X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21472,1060009114,2023-01-02T12:39:53Z,runtime/doc/vim_diff.txt,"@@ -732,5 +739,9 @@ Cscope:                                                                       *cscope*   Cscope support has been removed in favour of LSP based solutions. +Hardcopy:+                                                                     *hardcopy*+  `:hardcopy` was removed. Instead, use `:TOhtml` and print the resulting HTML using a web browser or some other HTML viewer.",This line is too long.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21586,1060093224,2023-01-02T15:26:00Z,src/nvim/auevents.lua,"@@ -127,25 +127,37 @@ return {     'WinScrolled',            -- after a window was scrolled or resized   },   aliases = {-    BufCreate = 'BufAdd',-    BufRead = 'BufReadPost',-    BufWrite = 'BufWritePre',-    FileEncoding = 'EncodingChanged',+    {","(just thinking out loud) re https://github.com/neovim/neovim/issues/19918 , `auevents.lua` may be a file that we want to ship in the runtime, so that plugins can discover Nvim event definitions. However these `aliases` and `nvim_specific` lists aren't too important for plugins, so they don't need to have a ""map"" structure. They could be considered ""internal details"" similar to  `keysets.lua`.iow: LGTM",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21618,1060129344,2023-01-02T16:53:06Z,runtime/lua/vim/lsp/util.lua,"@@ -1777,12 +1786,13 @@ function M.locations_to_items(locations, offset_encoding)       local pos = temp.start       local row = pos.line       local line = lines[row] or ''+      local text = (opts.format or function() return line end)(line, temp.location)","> so something like function on_item(filename, lnum, col, text)can `on_item` take the already-constructed qf item? That will save hassle for people setting the callback. Then the callback can just set whatever field it's interested in and pass it along.> 0- or 1-based indexing for that? whatever we do elsewhere in lsp.lua.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21521,1060171032,2023-01-02T19:33:22Z,runtime/lua/vim/diagnostic.lua,"@@ -429,32 +429,30 @@ local function get_diagnostics(bufnr, opts, clamp)     end   end +  local add_iterator = function(buf_nr, diag_tbl)","- prefer `local function foo()` except when there's a technical reason the `foo  = function` form is needed. I thought this was checked by lint...- ""iterator"" (or more preferred: ""iter"") in a function name implies it returns a Lua ""iterator"". this function doesn't do that, so the name is confusing.     - for ad-hoc locally-scoped functions like this, smaller names are often _less_ confusing than verbose names. Avoid ""premature explanation"".```suggestion  local function add_all_diags(buf_nr, diags)```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21586,1060174714,2023-01-02T19:52:04Z,scripts/genvimvim.lua,"@@ -115,7 +117,7 @@ end local nvimau_start = 'syn keyword nvimAutoEvent contained ' w('\n\n' .. nvimau_start) -for au, _ in pairs(auevents.nvim_specific) do+for au, _ in vim.spairs(auevents.nvim_specific) do","technically this could use `ipairs` now, right? (or we could revert the changes to auevents.lua)?Though `vim.spairs()` still seems like something we generally want.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21586,1060176101,2023-01-02T19:58:37Z,runtime/lua/vim/shared.lua,"@@ -457,6 +457,32 @@ function vim.tbl_flatten(t)   return result end +--- Enumerate a table sorted by its keys.+---+---@see Based on https://github.com/premake/premake-core/blob/master/src/base/table.lua+---+---@param t table List-like table+---@return table key-sorted copy of the given table+function vim.spairs(t)",In the future we could add a `sort` parameter to allow custom sorting.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21623,1060405935,2023-01-03T09:34:18Z,runtime/autoload/ccomplete.lua,"@@ -0,0 +1,892 @@+----------------------------------------+-- This file is generated via github.com/tjdevries/vim9jit+-- For any bugs, please first consider reporting there.+----------------------------------------++local NVIM9 = require('_vim9script')+local __VIM9_MODULE = {}+local prepended = nil+local grepCache = nil+local Complete = nil+local GetAddition = nil+local Tag2item = nil+local Dict2info = nil+local ParseTagline = nil+local Tagline2item = nil+local Tagcmd2extra = nil+local Nextitem = nil+local StructMembers = nil+local SearchMembers = nil+-- vim9script++-- # Vim completion script+-- # Language:     C+-- # Maintainer:   Bram Moolenaar <Bram@vim.org>+-- #		Rewritten in Vim9 script by github user lacygoill+-- # Last Change:  2022 Jan 31++prepended = ''+grepCache = vim.empty_dict()++-- # This function is used for the 'omnifunc' option.++Complete = function(findstart, abase)+  findstart = NVIM9.bool(findstart)+  if NVIM9.bool(findstart) then+    -- # Locate the start of the item, including ""."", ""->"" and ""[...]"".+    local line = NVIM9.fn['getline']('.')+    local start = NVIM9.fn['charcol']('.') - 1+    local lastword = -1+    while start > 0 do+      if NVIM9.ops['RegexpMatches'](NVIM9.index(line, NVIM9.ops['Minus'](start, 1)), '\\w') then+        start = start - 1+      elseif+        NVIM9.bool(+          NVIM9.ops['RegexpMatches'](NVIM9.index(line, NVIM9.ops['Minus'](start, 1)), '\\.')+        )+      then+        if lastword == -1 then+          lastword = start+        end+        start = start - 1+      elseif+        NVIM9.bool(+          start > 1+            and NVIM9.index(line, NVIM9.ops['Minus'](start, 2)) == '-'+            and NVIM9.index(line, NVIM9.ops['Minus'](start, 1)) == '>'+        )+      then+        if lastword == -1 then+          lastword = start+        end+        start = NVIM9.ops['Minus'](start, 2)+      elseif NVIM9.bool(NVIM9.index(line, NVIM9.ops['Minus'](start, 1)) == ']') then+        -- # Skip over [...].+        local n = 0+        start = start - 1+        while start > 0 do+          start = start - 1+          if NVIM9.index(line, start) == '[' then+            if n == 0 then+              break+            end+            n = n - 1+          elseif NVIM9.bool(NVIM9.index(line, start) == ']') then+            n = n + 1+          end+        end+      else+        break+      end+    end++    -- # Return the column of the last word, which is going to be changed.+    -- # Remember the text that comes before it in prepended.+    if lastword == -1 then+      prepended = ''+      return NVIM9.fn['byteidx'](line, start)+    end+    prepended = NVIM9.slice(line, start, NVIM9.ops['Minus'](lastword, 1))+    return NVIM9.fn['byteidx'](line, lastword)+  end++  -- # Return list of matches.++  local base = prepended .. abase++  -- # Don't do anything for an empty base, would result in all the tags in the+  -- # tags file.+  if base == '' then+    return {}+  end++  -- # init cache for vimgrep to empty+  grepCache = {}++  -- # Split item in words, keep empty word after ""."" or ""->"".+  -- # ""aa"" -> ['aa'], ""aa."" -> ['aa', ''], ""aa.bb"" -> ['aa', 'bb'], etc.+  -- # We can't use split, because we need to skip nested [...].+  -- # ""aa[...]"" -> ['aa', '[...]'], ""aa.bb[...]"" -> ['aa', 'bb', '[...]'], etc.+  local items = {}+  local s = 0+  local arrays = 0+  while 1 do+    local e = NVIM9.fn['charidx'](base, NVIM9.fn['match'](base, '\\.\\|->\\|\\[', s))+    if e < 0 then+      if s == 0 or NVIM9.index(base, NVIM9.ops['Minus'](s, 1)) ~= ']' then+        NVIM9.fn['add'](items, NVIM9.slice(base, s, nil))+      end+      break+    end+    if s == 0 or NVIM9.index(base, NVIM9.ops['Minus'](s, 1)) ~= ']' then+      NVIM9.fn['add'](items, NVIM9.slice(base, s, NVIM9.ops['Minus'](e, 1)))+    end+    if NVIM9.index(base, e) == '.' then+      -- # skip over '.'+      s = NVIM9.ops['Plus'](e, 1)+    elseif NVIM9.bool(NVIM9.index(base, e) == '-') then+      -- # skip over '->'+      s = NVIM9.ops['Plus'](e, 2)+    else+      -- # Skip over [...].+      local n = 0+      s = e+      e = e + 1+      while e < NVIM9.fn['strcharlen'](base) do+        if NVIM9.index(base, e) == ']' then+          if n == 0 then+            break+          end+          n = n - 1+        elseif NVIM9.bool(NVIM9.index(base, e) == '[') then+          n = n + 1+        end+        e = e + 1+      end+      e = e + 1+      NVIM9.fn['add'](items, NVIM9.slice(base, s, NVIM9.ops['Minus'](e, 1)))+      arrays = arrays + 1+      s = e+    end+  end++  -- # Find the variable items[0].+  -- # 1. in current function (like with ""gd"")+  -- # 2. in tags file(s) (like with "":tag"")+  -- # 3. in current file (like with ""gD"")+  local res = {}+  if NVIM9.fn['searchdecl'](NVIM9.index(items, 0), false, true) == 0 then+    -- # Found, now figure out the type.+    -- # TODO: join previous line if it makes sense+    local line = NVIM9.fn['getline']('.')+    local col = NVIM9.fn['charcol']('.')+    if NVIM9.fn['stridx'](NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)), ';') >= 0 then+      -- # Handle multiple declarations on the same line.+      local col2 = NVIM9.ops['Minus'](col, 1)+      while NVIM9.index(line, col2) ~= ';' do+        col2 = col2 - 1+      end+      line = NVIM9.slice(line, NVIM9.ops['Plus'](col2, 1), nil)+      col = NVIM9.ops['Minus'](col, col2)+    end+    if NVIM9.fn['stridx'](NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)), ',') >= 0 then+      -- # Handle multiple declarations on the same line in a function+      -- # declaration.+      local col2 = NVIM9.ops['Minus'](col, 1)+      while NVIM9.index(line, col2) ~= ',' do+        col2 = col2 - 1+      end+      if+        NVIM9.ops['RegexpMatches'](+          NVIM9.slice(line, NVIM9.ops['Plus'](col2, 1), NVIM9.ops['Minus'](col, 1)),+          ' *[^ ][^ ]*  *[^ ]'+        )+      then+        line = NVIM9.slice(line, NVIM9.ops['Plus'](col2, 1), nil)+        col = NVIM9.ops['Minus'](col, col2)+      end+    end+    if NVIM9.fn['len'](items) == 1 then+      -- # Completing one word and it's a local variable: May add '[', '.' or+      -- # '->'.+      local match = NVIM9.index(items, 0)+      local kind = 'v'+      if NVIM9.fn['match'](line, '\\<' .. match .. '\\s*\\[') > 0 then+        match = match .. '['+      else+        res = Nextitem(NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)), { '' }, 0, true)+        if NVIM9.fn['len'](res) > 0 then+          -- # There are members, thus add ""."" or ""->"".+          if NVIM9.fn['match'](line, '\\*[ \\t(]*' .. match .. '\\>') > 0 then+            match = match .. '->'+          else+            match = match .. '.'+          end+        end+      end+      res = { { ['match'] = match, ['tagline'] = '', ['kind'] = kind, ['info'] = line } }+    elseif NVIM9.bool(NVIM9.fn['len'](items) == NVIM9.ops['Plus'](arrays, 1)) then+      -- # Completing one word and it's a local array variable: build tagline+      -- # from declaration line+      local match = NVIM9.index(items, 0)+      local kind = 'v'+      local tagline = '\t/^' .. line .. '$/'+      res = { { ['match'] = match, ['tagline'] = tagline, ['kind'] = kind, ['info'] = line } }+    else+      -- # Completing ""var."", ""var.something"", etc.+      res = Nextitem(+        NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)),+        NVIM9.slice(items, 1, nil),+        0,+        true+      )+    end+  end++  if NVIM9.fn['len'](items) == 1 or NVIM9.fn['len'](items) == NVIM9.ops['Plus'](arrays, 1) then+    -- # Only one part, no ""."" or ""->"": complete from tags file.+    local tags = {}+    if NVIM9.fn['len'](items) == 1 then+      tags = NVIM9.fn['taglist']('^' .. base)+    else+      tags = NVIM9.fn['taglist']('^' .. NVIM9.index(items, 0) .. '$')","is it much trouble to use sugar when possible?```suggestion      tags = NVIM9.fn.taglist('^' .. NVIM9.index(items, 0) .. '$')```",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21623,1060433738,2023-01-03T10:05:49Z,runtime/autoload/ccomplete.vim,"@@ -1,639 +1,8 @@-"" Vim completion script-"" Language:	C-"" Maintainer:	Bram Moolenaar <Bram@vim.org>-"" Last Change:	2020 Nov 14--let s:cpo_save = &cpo-set cpo&vim--"" This function is used for the 'omnifunc' option.-func ccomplete#Complete(findstart, base)-  if a:findstart-    "" Locate the start of the item, including ""."", ""->"" and ""[...]"".-    let line = getline('.')-    let start = col('.') - 1-    let lastword = -1-    while start > 0-      if line[start - 1] =~ '\w'-	let start -= 1-      elseif line[start - 1] =~ '\.'-	if lastword == -1-	  let lastword = start-	endif-	let start -= 1-      elseif start > 1 && line[start - 2] == '-' && line[start - 1] == '>'-	if lastword == -1-	  let lastword = start-	endif-	let start -= 2-      elseif line[start - 1] == ']'-	"" Skip over [...].-	let n = 0-	let start -= 1-	while start > 0-	  let start -= 1-	  if line[start] == '['-	    if n == 0-	      break-	    endif-	    let n -= 1-	  elseif line[start] == ']'  "" nested []-	    let n += 1-	  endif-	endwhile-      else-	break-      endif-    endwhile--    "" Return the column of the last word, which is going to be changed.-    "" Remember the text that comes before it in s:prepended.-    if lastword == -1-      let s:prepended = ''-      return start-    endif-    let s:prepended = strpart(line, start, lastword - start)-    return lastword-  endif--  "" Return list of matches.--  let base = s:prepended . a:base--  "" Don't do anything for an empty base, would result in all the tags in the-  "" tags file.-  if base == ''-    return []-  endif--  "" init cache for vimgrep to empty-  let s:grepCache = {}--  "" Split item in words, keep empty word after ""."" or ""->"".-  "" ""aa"" -> ['aa'], ""aa."" -> ['aa', ''], ""aa.bb"" -> ['aa', 'bb'], etc.-  "" We can't use split, because we need to skip nested [...].-  "" ""aa[...]"" -> ['aa', '[...]'], ""aa.bb[...]"" -> ['aa', 'bb', '[...]'], etc.-  let items = []-  let s = 0-  let arrays = 0-  while 1-    let e = match(base, '\.\|->\|\[', s)-    if e < 0-      if s == 0 || base[s - 1] != ']'-	call add(items, strpart(base, s))-      endif-      break-    endif-    if s == 0 || base[s - 1] != ']'-      call add(items, strpart(base, s, e - s))-    endif-    if base[e] == '.'-      let s = e + 1	"" skip over '.'-    elseif base[e] == '-'-      let s = e + 2	"" skip over '->'-    else-      "" Skip over [...].-      let n = 0-      let s = e-      let e += 1-      while e < len(base)-	if base[e] == ']'-	  if n == 0-	    break-	  endif-	  let n -= 1-	elseif base[e] == '['  "" nested [...]-	  let n += 1-	endif-	let e += 1-      endwhile-      let e += 1-      call add(items, strpart(base, s, e - s))-      let arrays += 1-      let s = e-    endif-  endwhile--  "" Find the variable items[0].-  "" 1. in current function (like with ""gd"")-  "" 2. in tags file(s) (like with "":tag"")-  "" 3. in current file (like with ""gD"")-  let res = []-  if searchdecl(items[0], 0, 1) == 0-    "" Found, now figure out the type.-    "" TODO: join previous line if it makes sense-    let line = getline('.')-    let col = col('.')-    if stridx(strpart(line, 0, col), ';') != -1-      "" Handle multiple declarations on the same line.-      let col2 = col - 1-      while line[col2] != ';'-	let col2 -= 1-      endwhile-      let line = strpart(line, col2 + 1)-      let col -= col2-    endif-    if stridx(strpart(line, 0, col), ',') != -1-      "" Handle multiple declarations on the same line in a function-      "" declaration.-      let col2 = col - 1-      while line[col2] != ','-	let col2 -= 1-      endwhile-      if strpart(line, col2 + 1, col - col2 - 1) =~ ' *[^ ][^ ]*  *[^ ]'-	let line = strpart(line, col2 + 1)-	let col -= col2-      endif-    endif-    if len(items) == 1-      "" Completing one word and it's a local variable: May add '[', '.' or-      "" '->'.-      let match = items[0]-      let kind = 'v'-      if match(line, '\<' . match . '\s*\[') > 0-	let match .= '['-      else-	let res = s:Nextitem(strpart(line, 0, col), [''], 0, 1)-	if len(res) > 0-	  "" There are members, thus add ""."" or ""->"".-	  if match(line, '\*[ \t(]*' . match . '\>') > 0-	    let match .= '->'-	  else-	    let match .= '.'-	  endif-	endif-      endif-      let res = [{'match': match, 'tagline' : '', 'kind' : kind, 'info' : line}]-    elseif len(items) == arrays + 1-      "" Completing one word and it's a local array variable: build tagline-      "" from declaration line-      let match = items[0]-      let kind = 'v'-      let tagline = ""\t/^"" . line . '$/'-      let res = [{'match': match, 'tagline' : tagline, 'kind' : kind, 'info' : line}]-    else-      "" Completing ""var."", ""var.something"", etc.-      let res = s:Nextitem(strpart(line, 0, col), items[1:], 0, 1)-    endif-  endif--  if len(items) == 1 || len(items) == arrays + 1-    "" Only one part, no ""."" or ""->"": complete from tags file.-    if len(items) == 1-      let tags = taglist('^' . base)-    else-      let tags = taglist('^' . items[0] . '$')-    endif--    "" Remove members, these can't appear without something in front.-    call filter(tags, 'has_key(v:val, ""kind"") ? v:val[""kind""] != ""m"" : 1')--    "" Remove static matches in other files.-    call filter(tags, '!has_key(v:val, ""static"") || !v:val[""static""] || bufnr(""%"") == bufnr(v:val[""filename""])')--    call extend(res, map(tags, 's:Tag2item(v:val)'))-  endif--  if len(res) == 0-    "" Find the variable in the tags file(s)-    let diclist = taglist('^' . items[0] . '$')--    "" Remove members, these can't appear without something in front.-    call filter(diclist, 'has_key(v:val, ""kind"") ? v:val[""kind""] != ""m"" : 1')--    let res = []-    for i in range(len(diclist))-      "" New ctags has the ""typeref"" field.  Patched version has ""typename"".-      if has_key(diclist[i], 'typename')-	call extend(res, s:StructMembers(diclist[i]['typename'], items[1:], 1))-      elseif has_key(diclist[i], 'typeref')-	call extend(res, s:StructMembers(diclist[i]['typeref'], items[1:], 1))-      endif--      "" For a variable use the command, which must be a search pattern that-      "" shows the declaration of the variable.-      if diclist[i]['kind'] == 'v'-	let line = diclist[i]['cmd']-	if line[0] == '/' && line[1] == '^'-	  let col = match(line, '\<' . items[0] . '\>')-	  call extend(res, s:Nextitem(strpart(line, 2, col - 2), items[1:], 0, 1))-	endif-      endif-    endfor-  endif--  if len(res) == 0 && searchdecl(items[0], 1) == 0-    "" Found, now figure out the type.-    "" TODO: join previous line if it makes sense-    let line = getline('.')-    let col = col('.')-    let res = s:Nextitem(strpart(line, 0, col), items[1:], 0, 1)-  endif--  "" If the last item(s) are [...] they need to be added to the matches.-  let last = len(items) - 1-  let brackets = ''-  while last >= 0-    if items[last][0] != '['-      break-    endif-    let brackets = items[last] . brackets-    let last -= 1-  endwhile--  return map(res, 's:Tagline2item(v:val, brackets)')-endfunc--func s:GetAddition(line, match, memarg, bracket)-  "" Guess if the item is an array.-  if a:bracket && match(a:line, a:match . '\s*\[') > 0-    return '['-  endif--  "" Check if the item has members.-  if len(s:SearchMembers(a:memarg, [''], 0)) > 0-    "" If there is a '*' before the name use ""->"".-    if match(a:line, '\*[ \t(]*' . a:match . '\>') > 0-      return '->'-    else-      return '.'-    endif-  endif-  return ''-endfunc--"" Turn the tag info ""val"" into an item for completion.-"" ""val"" is is an item in the list returned by taglist().-"" If it is a variable we may add ""."" or ""->"".  Don't do it for other types,-"" such as a typedef, by not including the info that s:GetAddition() uses.-func s:Tag2item(val)-  let res = {'match': a:val['name']}--  let res['extra'] = s:Tagcmd2extra(a:val['cmd'], a:val['name'], a:val['filename'])--  let s = s:Dict2info(a:val)-  if s != ''-    let res['info'] = s-  endif--  let res['tagline'] = ''-  if has_key(a:val, ""kind"")-    let kind = a:val['kind']-    let res['kind'] = kind-    if kind == 'v'-      let res['tagline'] = ""\t"" . a:val['cmd']-      let res['dict'] = a:val-    elseif kind == 'f'-      let res['match'] = a:val['name'] . '('-    endif-  endif--  return res-endfunc--"" Use all the items in dictionary for the ""info"" entry.-func s:Dict2info(dict)-  let info = ''-  for k in sort(keys(a:dict))-    let info  .= k . repeat(' ', 10 - len(k))-    if k == 'cmd'-      let info .= substitute(matchstr(a:dict['cmd'], '/^\s*\zs.*\ze$/'), '\\\(.\)', '\1', 'g')-    else-      let info .= a:dict[k]-    endif-    let info .= ""\n""-  endfor-  return info-endfunc--"" Parse a tag line and return a dictionary with items like taglist()-func s:ParseTagline(line)-  let l = split(a:line, ""\t"")-  let d = {}-  if len(l) >= 3-    let d['name'] = l[0]-    let d['filename'] = l[1]-    let d['cmd'] = l[2]-    let n = 2-    if l[2] =~ '^/'-      "" Find end of cmd, it may contain Tabs.-      while n < len(l) && l[n] !~ '/;""$'-	let n += 1-	let d['cmd'] .= ""  "" . l[n]-      endwhile-    endif-    for i in range(n + 1, len(l) - 1)-      if l[i] == 'file:'-	let d['static'] = 1-      elseif l[i] !~ ':'-	let d['kind'] = l[i]-      else-	let d[matchstr(l[i], '[^:]*')] = matchstr(l[i], ':\zs.*')-      endif-    endfor-  endif--  return d-endfunc--"" Turn a match item ""val"" into an item for completion.-"" ""val['match']"" is the matching item.-"" ""val['tagline']"" is the tagline in which the last part was found.-func s:Tagline2item(val, brackets)-  let line = a:val['tagline']-  let add = s:GetAddition(line, a:val['match'], [a:val], a:brackets == '')-  let res = {'word': a:val['match'] . a:brackets . add }--  if has_key(a:val, 'info')-    "" Use info from Tag2item().-    let res['info'] = a:val['info']-  else-    "" Parse the tag line and add each part to the ""info"" entry.-    let s = s:Dict2info(s:ParseTagline(line))-    if s != ''-      let res['info'] = s-    endif-  endif--  if has_key(a:val, 'kind')-    let res['kind'] = a:val['kind']-  elseif add == '('-    let res['kind'] = 'f'-  else-    let s = matchstr(line, '\t\(kind:\)\=\zs\S\ze\(\t\|$\)')-    if s != ''-      let res['kind'] = s-    endif-  endif--  if has_key(a:val, 'extra')-    let res['menu'] = a:val['extra']-    return res-  endif--  "" Isolate the command after the tag and filename.-  let s = matchstr(line, '[^\t]*\t[^\t]*\t\zs\(/^.*$/\|[^\t]*\)\ze\(;""\t\|\t\|$\)')-  if s != ''-    let res['menu'] = s:Tagcmd2extra(s, a:val['match'], matchstr(line, '[^\t]*\t\zs[^\t]*\ze\t'))-  endif-  return res-endfunc--"" Turn a command from a tag line to something that is useful in the menu-func s:Tagcmd2extra(cmd, name, fname)-  if a:cmd =~ '^/^'-    "" The command is a search command, useful to see what it is.-    let x = matchstr(a:cmd, '^/^\s*\zs.*\ze$/')-    let x = substitute(x, '\<' . a:name . '\>', '@@', '')-    let x = substitute(x, '\\\(.\)', '\1', 'g')-    let x = x . ' - ' . a:fname-  elseif a:cmd =~ '^\d*$'-    "" The command is a line number, the file name is more useful.-    let x = a:fname . ' - ' . a:cmd-  else-    "" Not recognized, use command and file name.-    let x = a:cmd . ' - ' . a:fname-  endif-  return x-endfunc--"" Find composing type in ""lead"" and match items[0] with it.-"" Repeat this recursively for items[1], if it's there.-"" When resolving typedefs ""depth"" is used to avoid infinite recursion.-"" Return the list of matches.-func s:Nextitem(lead, items, depth, all)--  "" Use the text up to the variable name and split it in tokens.-  let tokens = split(a:lead, '\s\+\|\<')--  "" Try to recognize the type of the variable.  This is rough guessing...-  let res = []-  for tidx in range(len(tokens))--    "" Skip tokens starting with a non-ID character.-    if tokens[tidx] !~ '^\h'-      continue-    endif--    "" Recognize ""struct foobar"" and ""union foobar"".-    "" Also do ""class foobar"" when it's C++ after all (doesn't work very well-    "" though).-    if (tokens[tidx] == 'struct' || tokens[tidx] == 'union' || tokens[tidx] == 'class') && tidx + 1 < len(tokens)-      let res = s:StructMembers(tokens[tidx] . ':' . tokens[tidx + 1], a:items, a:all)-      break-    endif--    "" TODO: add more reserved words-    if index(['int', 'short', 'char', 'float', 'double', 'static', 'unsigned', 'extern'], tokens[tidx]) >= 0-      continue-    endif--    "" Use the tags file to find out if this is a typedef.-    let diclist = taglist('^' . tokens[tidx] . '$')-    for tagidx in range(len(diclist))-      let item = diclist[tagidx]--      "" New ctags has the ""typeref"" field.  Patched version has ""typename"".-      if has_key(item, 'typeref')-	call extend(res, s:StructMembers(item['typeref'], a:items, a:all))-	continue-      endif-      if has_key(item, 'typename')-	call extend(res, s:StructMembers(item['typename'], a:items, a:all))-	continue-      endif--      "" Only handle typedefs here.-      if item['kind'] != 't'-	continue-      endif--      "" Skip matches local to another file.-      if has_key(item, 'static') && item['static'] && bufnr('%') != bufnr(item['filename'])-	continue-      endif--      "" For old ctags we recognize ""typedef struct aaa"" and-      "" ""typedef union bbb"" in the tags file command.-      let cmd = item['cmd']-      let ei = matchend(cmd, 'typedef\s\+')-      if ei > 1-	let cmdtokens = split(strpart(cmd, ei), '\s\+\|\<')-	if len(cmdtokens) > 1-	  if cmdtokens[0] == 'struct' || cmdtokens[0] == 'union' || cmdtokens[0] == 'class'-	    let name = ''-	    "" Use the first identifier after the ""struct"" or ""union""-	    for ti in range(len(cmdtokens) - 1)-	      if cmdtokens[ti] =~ '^\w'-		let name = cmdtokens[ti]-		break-	      endif-	    endfor-	    if name != ''-	      call extend(res, s:StructMembers(cmdtokens[0] . ':' . name, a:items, a:all))-	    endif-	  elseif a:depth < 10-	    "" Could be ""typedef other_T some_T"".-	    call extend(res, s:Nextitem(cmdtokens[0], a:items, a:depth + 1, a:all))-	  endif-	endif-      endif-    endfor-    if len(res) > 0-      break-    endif-  endfor--  return res-endfunc---"" Search for members of structure ""typename"" in tags files.-"" Return a list with resulting matches.-"" Each match is a dictionary with ""match"" and ""tagline"" entries.-"" When ""all"" is non-zero find all, otherwise just return 1 if there is any-"" member.-func s:StructMembers(typename, items, all)-  "" Todo: What about local structures?-  let fnames = join(map(tagfiles(), 'escape(v:val, "" \\#%"")'))-  if fnames == ''-    return []-  endif--  let typename = a:typename-  let qflist = []-  let cached = 0-  if a:all == 0-    let n = '1'	"" stop at first found match-    if has_key(s:grepCache, a:typename)-      let qflist = s:grepCache[a:typename]-      let cached = 1-    endif-  else-    let n = ''-  endif-  if !cached-    while 1-      exe 'silent! keepj noautocmd ' . n . 'vimgrep /\t' . typename . '\(\t\|$\)/j ' . fnames--      let qflist = getqflist()-      if len(qflist) > 0 || match(typename, ""::"") < 0-	break-      endif-      "" No match for ""struct:context::name"", remove ""context::"" and try again.-      let typename = substitute(typename, ':[^:]*::', ':', '')-    endwhile--    if a:all == 0-      "" Store the result to be able to use it again later.-      let s:grepCache[a:typename] = qflist-    endif-  endif--  "" Skip over [...] items-  let idx = 0-  while 1-    if idx >= len(a:items)-      let target = ''		"" No further items, matching all members-      break-    endif-    if a:items[idx][0] != '['-      let target = a:items[idx]-      break-    endif-    let idx += 1-  endwhile-  "" Put matching members in matches[].-  let matches = []-  for l in qflist-    let memb = matchstr(l['text'], '[^\t]*')-    if memb =~ '^' . target-      "" Skip matches local to another file.-      if match(l['text'], ""\tfile:"") < 0 || bufnr('%') == bufnr(matchstr(l['text'], '\t\zs[^\t]*'))-	let item = {'match': memb, 'tagline': l['text']}--	"" Add the kind of item.-	let s = matchstr(l['text'], '\t\(kind:\)\=\zs\S\ze\(\t\|$\)')-	if s != ''-	  let item['kind'] = s-	  if s == 'f'-	    let item['match'] = memb . '('-	  endif-	endif--	call add(matches, item)-      endif-    endif-  endfor--  if len(matches) > 0-    "" Skip over next [...] items-    let idx += 1-    while 1-      if idx >= len(a:items)-	return matches		"" No further items, return the result.-      endif-      if a:items[idx][0] != '['-	break-      endif-      let idx += 1-    endwhile--    "" More items following.  For each of the possible members find the-    "" matching following members.-    return s:SearchMembers(matches, a:items[idx :], a:all)-  endif--  "" Failed to find anything.-  return []-endfunc--"" For matching members, find matches for following items.-"" When ""all"" is non-zero find all, otherwise just return 1 if there is any-"" member.-func s:SearchMembers(matches, items, all)-  let res = []-  for i in range(len(a:matches))-    let typename = ''-    if has_key(a:matches[i], 'dict')-      if has_key(a:matches[i].dict, 'typename')-	let typename = a:matches[i].dict['typename']-      elseif has_key(a:matches[i].dict, 'typeref')-	let typename = a:matches[i].dict['typeref']-      endif-      let line = ""\t"" . a:matches[i].dict['cmd']-    else-      let line = a:matches[i]['tagline']-      let e = matchend(line, '\ttypename:')-      if e < 0-	let e = matchend(line, '\ttyperef:')-      endif-      if e > 0-	"" Use typename field-	let typename = matchstr(line, '[^\t]*', e)-      endif-    endif--    if typename != ''-      call extend(res, s:StructMembers(typename, a:items, a:all))-    else-      "" Use the search command (the declaration itself).-      let s = match(line, '\t\zs/^')-      if s > 0-	let e = match(line, '\<' . a:matches[i]['match'] . '\>', s)-	if e > 0-	  call extend(res, s:Nextitem(strpart(line, s, e - s), a:items, 0, a:all))-	endif-      endif-    endif-    if a:all == 0 && len(res) > 0-      break-    endif-  endfor-  return res-endfunc--let &cpo = s:cpo_save-unlet s:cpo_save--"" vim: noet sw=2 sts=2+"" Generated vim file by vim9jit. Please do not edit+let s:PATH = expand(""<script>"")","We currently use uppercase for `vim.log.levels.[TRACE,DEBUG,INFO,...]`, and there's also the constant I added [I added ](https://github.com/neovim/neovim/blob/c3d8665851c20414007f04a481c5a542d9d139f2/runtime/lua/vim/_editor.lua#L321).Using uppercase for constants is just a simple signal that a variable isn't intended to be mutated and I think it's a particularly useful convention for scripting languages like python, lua and shell.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21548,1060443428,2023-01-03T10:17:46Z,runtime/lua/vim/treesitter/query.lua,"@@ -408,12 +425,21 @@ local directive_handlers = {      -- If this produces an invalid range, we just skip it.     if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      if not metadata[capture_id] then-        metadata[capture_id] = {}-      end       metadata[capture_id].range = range     end   end,++  -- Transform the content of the node+  -- Example: (#gsub! @_node "".*%.(.*)"" ""%1"")+  ['gsub!'] = function(match, _, bufnr, pred, metadata)+    assert(#pred == 4)++    local id = pred[2]+    local node = match[id]+    local text = M.get_node_text(node, bufnr, { metadata = metadata[id] }) or ''++    metadata[id] = text:gsub(pred[3], pred[4])","Shouldn't this behave like `offset!` where we set an explicit field in metadata?Maybe: ```luametadata[id] = metadata[id] or {}metadata[id].text = text:gsub(pred[3], pred[4])```This will better allow multiple directives to work together (even if it might require additional tweaks in other places).",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/21589,1060598270,2023-01-03T13:44:37Z,src/nvim/CMakeLists.txt,"@@ -388,80 +501,246 @@ foreach(hfile ${NVIM_GENERATED_FOR_HEADERS})   endif() endforeach() +add_library(link_lib INTERFACE) # Our dependencies come first.  if (CMAKE_SYSTEM_NAME MATCHES ""OpenBSD"")-  list(APPEND NVIM_LINK_LIBRARIES pthread c++abi)+  target_link_libraries(link_lib INTERFACE pthread c++abi) endif()  if (LibIntl_FOUND)-  list(APPEND NVIM_LINK_LIBRARIES ${LibIntl_LIBRARY})+  target_link_libraries(link_lib INTERFACE ${LibIntl_LIBRARY}) endif()  if(Iconv_LIBRARIES)-  list(APPEND NVIM_LINK_LIBRARIES ${Iconv_LIBRARIES})+  target_link_libraries(link_lib INTERFACE ${Iconv_LIBRARIES}) endif()  if(WIN32)-  list(APPEND NVIM_LINK_LIBRARIES netapi32)+  target_link_libraries(link_lib INTERFACE netapi32) endif()  # Use ""luv"" as imported library, to work around CMake using ""-lluv"" for # ""luv.so"".  #10407 add_library(luv UNKNOWN IMPORTED)-set_property(TARGET luv PROPERTY IMPORTED_LOCATION ${LIBLUV_LIBRARIES})+set_target_properties(luv PROPERTIES IMPORTED_LOCATION ${LIBLUV_LIBRARIES})  # Put these last on the link line, since multiple things may depend on them.-list(APPEND NVIM_LINK_LIBRARIES+target_link_libraries(link_lib INTERFACE   luv+  ${CMAKE_THREAD_LIBS_INIT}+  ${LIBTERMKEY_LIBRARIES}   ${LIBUV_LIBRARIES}-  ${MSGPACK_LIBRARIES}   ${LIBVTERM_LIBRARIES}-  ${LIBTERMKEY_LIBRARIES}-  ${UNIBILIUM_LIBRARIES}-  ${UTF8PROC_LIBRARIES}+  ${MSGPACK_LIBRARIES}   ${TreeSitter_LIBRARIES}-  ${CMAKE_THREAD_LIBS_INIT}-)+  ${UNIBILIUM_LIBRARIES})  if(UNIX)-  list(APPEND NVIM_LINK_LIBRARIES-    m)+  target_link_libraries(link_lib INTERFACE m)   if (NOT CMAKE_SYSTEM_NAME STREQUAL ""SunOS"")-    list(APPEND NVIM_LINK_LIBRARIES-      util)+    target_link_libraries(link_lib INTERFACE util)+  endif()+endif()++add_library(option_lib INTERFACE)++add_library(include_lib INTERFACE)+target_include_directories(include_lib INTERFACE+  ${GENERATED_DIR}+  ${GENERATED_INCLUDES_DIR}+  ${PROJECT_BINARY_DIR}/cmake.config+  ${PROJECT_SOURCE_DIR}/src)++target_include_directories(include_lib SYSTEM INTERFACE ${NVIM_INCLUDE_LIBRARIES})++if(MSVC)+  # TODO(dundargoc): increase warning level+  target_compile_options(option_lib INTERFACE -W1 -wd4311)+else()+  target_compile_options(option_lib INTERFACE+    -Wall+    -Wconversion+    -Wdouble-promotion+    -Wextra+    -Wmissing-format-attribute+    -Wmissing-noreturn+    -Wmissing-prototypes+    -Wno-unused-parameter+    -Wshadow+    -Wstrict-prototypes+    -pedantic+    -std=gnu99)+endif()++check_c_compiler_flag(-Wimplicit-fallthrough HAVE_WIMPLICIT_FALLTHROUGH_FLAG)+if(HAVE_WIMPLICIT_FALLTHROUGH_FLAG)+  target_compile_options(option_lib INTERFACE -Wimplicit-fallthrough)+endif()++option(ENABLE_COMPILER_SUGGESTIONS ""Enable -Wsuggest compiler warnings"" OFF)+if(ENABLE_COMPILER_SUGGESTIONS)+  # Clang doesn't have -Wsuggest-attribute so check for each one.+  check_c_compiler_flag(-Wsuggest-attribute=pure HAVE_WSUGGEST_ATTRIBUTE_PURE)+  if(HAVE_WSUGGEST_ATTRIBUTE_PURE)+    target_compile_options(option_lib INTERFACE -Wsuggest-attribute=pure)+  endif()++  check_c_compiler_flag(-Wsuggest-attribute=const HAVE_WSUGGEST_ATTRIBUTE_CONST)+  if(HAVE_WSUGGEST_ATTRIBUTE_CONST)+    target_compile_options(option_lib INTERFACE -Wsuggest-attribute=const)+  endif()++  check_c_compiler_flag(-Wsuggest-attribute=malloc HAVE_WSUGGEST_ATTRIBUTE_MALLOC)+  if(HAVE_WSUGGEST_ATTRIBUTE_MALLOC)+    target_compile_options(option_lib INTERFACE -Wsuggest-attribute=malloc)+  endif()++  check_c_compiler_flag(-Wsuggest-attribute=cold HAVE_WSUGGEST_ATTRIBUTE_COLD)+  if(HAVE_WSUGGEST_ATTRIBUTE_COLD)+    target_compile_options(option_lib INTERFACE -Wsuggest-attribute=cold)+  endif()+endif()++# On FreeBSD 64 math.h uses unguarded C11 extension, which taints clang+# 3.4.1 used there.+if(CMAKE_SYSTEM_NAME STREQUAL ""FreeBSD"" AND CMAKE_C_COMPILER_ID MATCHES ""Clang"")+  target_compile_options(option_lib INTERFACE -Wno-c11-extensions)+endif()++# OpenBSD's GCC (4.2.1) doesn't have -Wvla+check_c_compiler_flag(-Wvla HAS_WVLA_FLAG)+if(HAS_WVLA_FLAG)+  target_compile_options(option_lib INTERFACE -Wvla)+endif()++check_c_compiler_flag(-fno-common HAVE_FNO_COMMON)+if (HAVE_FNO_COMMON)+  target_compile_options(option_lib INTERFACE -fno-common)+endif()++check_c_compiler_flag(-fdiagnostics-color=auto HAS_DIAG_COLOR_FLAG)+if(HAS_DIAG_COLOR_FLAG)+  if(CMAKE_GENERATOR MATCHES ""Ninja"")+    target_compile_options(option_lib INTERFACE -fdiagnostics-color=always)+  else()+    target_compile_options(option_lib INTERFACE -fdiagnostics-color=auto)+  endif()+endif()++option(CI_BUILD ""CI, extra flags will be set"" OFF)+if(CI_BUILD)+  message(STATUS ""CI build enabled"")+  if(MSVC)+    target_compile_options(option_lib INTERFACE -WX)+  else()+    target_compile_options(option_lib INTERFACE -Werror)+    if(DEFINED ENV{BUILD_UCHAR})+      # Get some test coverage for unsigned char+      target_compile_options(option_lib INTERFACE -funsigned-char)+    endif()+  endif()+endif()++if(UNIX)+  # -fstack-protector breaks non Unix builds even in Mingw-w64+  check_c_compiler_flag(-fstack-protector-strong HAS_FSTACK_PROTECTOR_STRONG_FLAG)+  check_c_compiler_flag(-fstack-protector HAS_FSTACK_PROTECTOR_FLAG)++  if(HAS_FSTACK_PROTECTOR_STRONG_FLAG)+    target_compile_options(option_lib INTERFACE -fstack-protector-strong)+    target_link_libraries(link_lib INTERFACE -fstack-protector-strong)+  elseif(HAS_FSTACK_PROTECTOR_FLAG)+    target_compile_options(option_lib INTERFACE -fstack-protector --param ssp-buffer-size=4)+    target_link_libraries(link_lib INTERFACE -fstack-protector --param ssp-buffer-size=4)   endif() endif() -set(NVIM_EXEC_LINK_LIBRARIES ${NVIM_LINK_LIBRARIES} ${LUA_PREFERRED_LIBRARIES})+add_library(main_lib INTERFACE)+target_link_libraries(main_lib INTERFACE+  definition_lib+  include_lib+  link_lib+  option_lib)","If these are always used together, it can be one single library",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/21623,1060620857,2023-01-03T14:10:07Z,runtime/autoload/ccomplete.lua,"@@ -0,0 +1,892 @@+----------------------------------------+-- This file is generated via github.com/tjdevries/vim9jit+-- For any bugs, please first consider reporting there.+----------------------------------------++local NVIM9 = require('_vim9script')+local __VIM9_MODULE = {}+local prepended = nil+local grepCache = nil+local Complete = nil+local GetAddition = nil+local Tag2item = nil+local Dict2info = nil+local ParseTagline = nil+local Tagline2item = nil+local Tagcmd2extra = nil+local Nextitem = nil+local StructMembers = nil+local SearchMembers = nil+-- vim9script++-- # Vim completion script+-- # Language:     C+-- # Maintainer:   Bram Moolenaar <Bram@vim.org>+-- #		Rewritten in Vim9 script by github user lacygoill+-- # Last Change:  2022 Jan 31++prepended = ''+grepCache = vim.empty_dict()++-- # This function is used for the 'omnifunc' option.++Complete = function(findstart, abase)+  findstart = NVIM9.bool(findstart)+  if NVIM9.bool(findstart) then+    -- # Locate the start of the item, including ""."", ""->"" and ""[...]"".+    local line = NVIM9.fn['getline']('.')+    local start = NVIM9.fn['charcol']('.') - 1+    local lastword = -1+    while start > 0 do+      if NVIM9.ops['RegexpMatches'](NVIM9.index(line, NVIM9.ops['Minus'](start, 1)), '\\w') then+        start = start - 1+      elseif+        NVIM9.bool(+          NVIM9.ops['RegexpMatches'](NVIM9.index(line, NVIM9.ops['Minus'](start, 1)), '\\.')+        )+      then+        if lastword == -1 then+          lastword = start+        end+        start = start - 1+      elseif+        NVIM9.bool(+          start > 1+            and NVIM9.index(line, NVIM9.ops['Minus'](start, 2)) == '-'+            and NVIM9.index(line, NVIM9.ops['Minus'](start, 1)) == '>'+        )+      then+        if lastword == -1 then+          lastword = start+        end+        start = NVIM9.ops['Minus'](start, 2)+      elseif NVIM9.bool(NVIM9.index(line, NVIM9.ops['Minus'](start, 1)) == ']') then+        -- # Skip over [...].+        local n = 0+        start = start - 1+        while start > 0 do+          start = start - 1+          if NVIM9.index(line, start) == '[' then+            if n == 0 then+              break+            end+            n = n - 1+          elseif NVIM9.bool(NVIM9.index(line, start) == ']') then+            n = n + 1+          end+        end+      else+        break+      end+    end++    -- # Return the column of the last word, which is going to be changed.+    -- # Remember the text that comes before it in prepended.+    if lastword == -1 then+      prepended = ''+      return NVIM9.fn['byteidx'](line, start)+    end+    prepended = NVIM9.slice(line, start, NVIM9.ops['Minus'](lastword, 1))+    return NVIM9.fn['byteidx'](line, lastword)+  end++  -- # Return list of matches.++  local base = prepended .. abase++  -- # Don't do anything for an empty base, would result in all the tags in the+  -- # tags file.+  if base == '' then+    return {}+  end++  -- # init cache for vimgrep to empty+  grepCache = {}++  -- # Split item in words, keep empty word after ""."" or ""->"".+  -- # ""aa"" -> ['aa'], ""aa."" -> ['aa', ''], ""aa.bb"" -> ['aa', 'bb'], etc.+  -- # We can't use split, because we need to skip nested [...].+  -- # ""aa[...]"" -> ['aa', '[...]'], ""aa.bb[...]"" -> ['aa', 'bb', '[...]'], etc.+  local items = {}+  local s = 0+  local arrays = 0+  while 1 do+    local e = NVIM9.fn['charidx'](base, NVIM9.fn['match'](base, '\\.\\|->\\|\\[', s))+    if e < 0 then+      if s == 0 or NVIM9.index(base, NVIM9.ops['Minus'](s, 1)) ~= ']' then+        NVIM9.fn['add'](items, NVIM9.slice(base, s, nil))+      end+      break+    end+    if s == 0 or NVIM9.index(base, NVIM9.ops['Minus'](s, 1)) ~= ']' then+      NVIM9.fn['add'](items, NVIM9.slice(base, s, NVIM9.ops['Minus'](e, 1)))+    end+    if NVIM9.index(base, e) == '.' then+      -- # skip over '.'+      s = NVIM9.ops['Plus'](e, 1)+    elseif NVIM9.bool(NVIM9.index(base, e) == '-') then+      -- # skip over '->'+      s = NVIM9.ops['Plus'](e, 2)+    else+      -- # Skip over [...].+      local n = 0+      s = e+      e = e + 1+      while e < NVIM9.fn['strcharlen'](base) do+        if NVIM9.index(base, e) == ']' then+          if n == 0 then+            break+          end+          n = n - 1+        elseif NVIM9.bool(NVIM9.index(base, e) == '[') then+          n = n + 1+        end+        e = e + 1+      end+      e = e + 1+      NVIM9.fn['add'](items, NVIM9.slice(base, s, NVIM9.ops['Minus'](e, 1)))+      arrays = arrays + 1+      s = e+    end+  end++  -- # Find the variable items[0].+  -- # 1. in current function (like with ""gd"")+  -- # 2. in tags file(s) (like with "":tag"")+  -- # 3. in current file (like with ""gD"")+  local res = {}+  if NVIM9.fn['searchdecl'](NVIM9.index(items, 0), false, true) == 0 then+    -- # Found, now figure out the type.+    -- # TODO: join previous line if it makes sense+    local line = NVIM9.fn['getline']('.')+    local col = NVIM9.fn['charcol']('.')+    if NVIM9.fn['stridx'](NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)), ';') >= 0 then+      -- # Handle multiple declarations on the same line.+      local col2 = NVIM9.ops['Minus'](col, 1)+      while NVIM9.index(line, col2) ~= ';' do+        col2 = col2 - 1+      end+      line = NVIM9.slice(line, NVIM9.ops['Plus'](col2, 1), nil)+      col = NVIM9.ops['Minus'](col, col2)+    end+    if NVIM9.fn['stridx'](NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)), ',') >= 0 then+      -- # Handle multiple declarations on the same line in a function+      -- # declaration.+      local col2 = NVIM9.ops['Minus'](col, 1)+      while NVIM9.index(line, col2) ~= ',' do+        col2 = col2 - 1+      end+      if+        NVIM9.ops['RegexpMatches'](+          NVIM9.slice(line, NVIM9.ops['Plus'](col2, 1), NVIM9.ops['Minus'](col, 1)),+          ' *[^ ][^ ]*  *[^ ]'+        )+      then+        line = NVIM9.slice(line, NVIM9.ops['Plus'](col2, 1), nil)+        col = NVIM9.ops['Minus'](col, col2)+      end+    end+    if NVIM9.fn['len'](items) == 1 then+      -- # Completing one word and it's a local variable: May add '[', '.' or+      -- # '->'.+      local match = NVIM9.index(items, 0)+      local kind = 'v'+      if NVIM9.fn['match'](line, '\\<' .. match .. '\\s*\\[') > 0 then+        match = match .. '['+      else+        res = Nextitem(NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)), { '' }, 0, true)+        if NVIM9.fn['len'](res) > 0 then+          -- # There are members, thus add ""."" or ""->"".+          if NVIM9.fn['match'](line, '\\*[ \\t(]*' .. match .. '\\>') > 0 then+            match = match .. '->'+          else+            match = match .. '.'+          end+        end+      end+      res = { { ['match'] = match, ['tagline'] = '', ['kind'] = kind, ['info'] = line } }+    elseif NVIM9.bool(NVIM9.fn['len'](items) == NVIM9.ops['Plus'](arrays, 1)) then+      -- # Completing one word and it's a local array variable: build tagline+      -- # from declaration line+      local match = NVIM9.index(items, 0)+      local kind = 'v'+      local tagline = '\t/^' .. line .. '$/'+      res = { { ['match'] = match, ['tagline'] = tagline, ['kind'] = kind, ['info'] = line } }+    else+      -- # Completing ""var."", ""var.something"", etc.+      res = Nextitem(+        NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)),+        NVIM9.slice(items, 1, nil),+        0,+        true+      )+    end+  end++  if NVIM9.fn['len'](items) == 1 or NVIM9.fn['len'](items) == NVIM9.ops['Plus'](arrays, 1) then+    -- # Only one part, no ""."" or ""->"": complete from tags file.+    local tags = {}+    if NVIM9.fn['len'](items) == 1 then+      tags = NVIM9.fn['taglist']('^' .. base)+    else+      tags = NVIM9.fn['taglist']('^' .. NVIM9.index(items, 0) .. '$')+    end++    NVIM9.fn_mut(+      'filter',+      {+        NVIM9.fn_mut(+          'filter',+          {+            tags,+            function(_, v)+              return NVIM9.ternary(NVIM9.fn['has_key'](v, 'kind'), function()+                return v['kind'] ~= 'm'+              end, true)+            end,+          },+          { replace = 0 }+        ),+        function(_, v)+          return NVIM9.ops['Or'](+            NVIM9.ops['Or'](+              NVIM9.prefix['Bang'](NVIM9.fn['has_key'](v, 'static')),+              NVIM9.prefix['Bang'](NVIM9.index(v, 'static'))+            ),+            NVIM9.fn['bufnr']('%') == NVIM9.fn['bufnr'](NVIM9.index(v, 'filename'))+          )+        end,+      },+      { replace = 0 }+    )++    res = NVIM9.fn['extend'](+      res,+      NVIM9.fn['map'](+        tags,+        function(_, v)+          return Tag2item(v)+        end+      )+    )+  end++  if NVIM9.fn['len'](res) == 0 then+    -- # Find the variable in the tags file(s)+    local diclist = NVIM9.fn['filter'](+      NVIM9.fn['taglist']('^' .. NVIM9.index(items, 0) .. '$'),+      function(_, v)+        return NVIM9.ternary(NVIM9.fn['has_key'](v, 'kind'), function()+          return v['kind'] ~= 'm'+        end, true)+      end+    )++    res = {}++    for _, i in NVIM9.iter(NVIM9.fn['range'](NVIM9.fn['len'](diclist))) do+      -- # New ctags has the ""typeref"" field.  Patched version has ""typename"".+      if NVIM9.bool(NVIM9.fn['has_key'](NVIM9.index(diclist, i), 'typename')) then+        res = NVIM9.fn['extend'](+          res,+          StructMembers(+            NVIM9.index(NVIM9.index(diclist, i), 'typename'),+            NVIM9.slice(items, 1, nil),+            true+          )+        )+      elseif NVIM9.bool(NVIM9.fn['has_key'](NVIM9.index(diclist, i), 'typeref')) then+        res = NVIM9.fn['extend'](+          res,+          StructMembers(+            NVIM9.index(NVIM9.index(diclist, i), 'typeref'),+            NVIM9.slice(items, 1, nil),+            true+          )+        )+      end++      -- # For a variable use the command, which must be a search pattern that+      -- # shows the declaration of the variable.+      if NVIM9.index(NVIM9.index(diclist, i), 'kind') == 'v' then+        local line = NVIM9.index(NVIM9.index(diclist, i), 'cmd')+        if NVIM9.slice(line, nil, 1) == '/^' then+          local col = NVIM9.fn['charidx'](+            line,+            NVIM9.fn['match'](line, '\\<' .. NVIM9.index(items, 0) .. '\\>')+          )+          res = NVIM9.fn['extend'](+            res,+            Nextitem(+              NVIM9.slice(line, 2, NVIM9.ops['Minus'](col, 1)),+              NVIM9.slice(items, 1, nil),+              0,+              true+            )+          )+        end+      end+    end+  end++  if NVIM9.fn['len'](res) == 0 and NVIM9.fn['searchdecl'](NVIM9.index(items, 0), true) == 0 then+    -- # Found, now figure out the type.+    -- # TODO: join previous line if it makes sense+    local line = NVIM9.fn['getline']('.')+    local col = NVIM9.fn['charcol']('.')+    res = Nextitem(+      NVIM9.slice(line, nil, NVIM9.ops['Minus'](col, 1)),+      NVIM9.slice(items, 1, nil),+      0,+      true+    )+  end++  -- # If the last item(s) are [...] they need to be added to the matches.+  local last = NVIM9.fn['len'](items) - 1+  local brackets = ''+  while last >= 0 do+    if NVIM9.index(NVIM9.index(items, last), 0) ~= '[' then+      break+    end+    brackets = NVIM9.index(items, last) .. brackets+    last = last - 1+  end++  return NVIM9.fn['map'](+    res,+    function(_, v)+      return Tagline2item(v, brackets)+    end+  )+end+__VIM9_MODULE['Complete'] = Complete++GetAddition = function(line, match, memarg, bracket)+  bracket = NVIM9.bool(bracket)+  -- # Guess if the item is an array.+  if NVIM9.bool(NVIM9.ops['And'](bracket, NVIM9.fn['match'](line, match .. '\\s*\\[') > 0)) then+    return '['+  end++  -- # Check if the item has members.+  if NVIM9.fn['len'](SearchMembers(memarg, { '' }, false)) > 0 then+    -- # If there is a '*' before the name use ""->"".+    if NVIM9.fn['match'](line, '\\*[ \\t(]*' .. match .. '\\>') > 0 then+      return '->'+    else+      return '.'+    end+  end+  return ''+end++Tag2item = function(val)+  -- # Turn the tag info ""val"" into an item for completion.+  -- # ""val"" is is an item in the list returned by taglist().+  -- # If it is a variable we may add ""."" or ""->"".  Don't do it for other types,+  -- # such as a typedef, by not including the info that GetAddition() uses.+  local res = NVIM9.convert.decl_dict({ ['match'] = NVIM9.index(val, 'name') })++  res[NVIM9.index_expr('extra')] =+    Tagcmd2extra(NVIM9.index(val, 'cmd'), NVIM9.index(val, 'name'), NVIM9.index(val, 'filename'))++  local s = Dict2info(val)+  if s ~= '' then+    res[NVIM9.index_expr('info')] = s+  end++  res[NVIM9.index_expr('tagline')] = ''+  if NVIM9.bool(NVIM9.fn['has_key'](val, 'kind')) then+    local kind = NVIM9.index(val, 'kind')+    res[NVIM9.index_expr('kind')] = kind+    if kind == 'v' then+      res[NVIM9.index_expr('tagline')] = '\t' .. NVIM9.index(val, 'cmd')+      res[NVIM9.index_expr('dict')] = val+    elseif NVIM9.bool(kind == 'f') then+      res[NVIM9.index_expr('match')] = NVIM9.index(val, 'name') .. '('+    end+  end++  return res+end++Dict2info = function(dict)+  -- # Use all the items in dictionary for the ""info"" entry.+  local info = ''++  for _, k in NVIM9.iter(NVIM9.fn_mut('sort', { NVIM9.fn['keys'](dict) }, { replace = 0 })) do+    info = info .. k .. NVIM9.fn['repeat'](' ', 10 - NVIM9.fn['strlen'](k))+    if k == 'cmd' then+      info = info+        .. NVIM9.fn['substitute'](+          NVIM9.fn['matchstr'](NVIM9.index(dict, 'cmd'), '/^\\s*\\zs.*\\ze$/'),+          '\\\\\\(.\\)',+          '\\1',+          'g'+        )+    else+      local dictk = NVIM9.index(dict, k)+      if NVIM9.fn['typename'](dictk) ~= 'string' then+        info = info .. NVIM9.fn['string'](dictk)+      else+        info = info .. dictk+      end+    end+    info = info .. '\n'+  end++  return info+end++ParseTagline = function(line)+  -- # Parse a tag line and return a dictionary with items like taglist()+  local l = NVIM9.fn['split'](line, '\t')+  local d = vim.empty_dict()+  if NVIM9.fn['len'](l) >= 3 then+    d[NVIM9.index_expr('name')] = NVIM9.index(l, 0)+    d[NVIM9.index_expr('filename')] = NVIM9.index(l, 1)+    d[NVIM9.index_expr('cmd')] = NVIM9.index(l, 2)+    local n = 2+    if NVIM9.ops['RegexpMatches'](NVIM9.index(l, 2), '^/') then+      -- # Find end of cmd, it may contain Tabs.+      while n < NVIM9.fn['len'](l) and NVIM9.ops['NotRegexpMatches'](NVIM9.index(l, n), '/;""$') do+        n = n + 1+        d[NVIM9.index_expr('cmd')] = NVIM9.index(d, 'cmd') .. '  ' .. NVIM9.index(l, n)+      end+    end++    for _, i in NVIM9.iter(NVIM9.fn['range'](NVIM9.ops['Plus'](n, 1), NVIM9.fn['len'](l) - 1)) do+      if NVIM9.index(l, i) == 'file:' then+        d[NVIM9.index_expr('static')] = 1+      elseif NVIM9.bool(NVIM9.ops['NotRegexpMatches'](NVIM9.index(l, i), ':')) then+        d[NVIM9.index_expr('kind')] = NVIM9.index(l, i)+      else+        d[NVIM9.index_expr(NVIM9.fn['matchstr'](NVIM9.index(l, i), '[^:]*'))] =+          NVIM9.fn['matchstr'](NVIM9.index(l, i), ':\\zs.*')+      end+    end+  end++  return d+end++Tagline2item = function(val, brackets)+  -- # Turn a match item ""val"" into an item for completion.+  -- # ""val['match']"" is the matching item.+  -- # ""val['tagline']"" is the tagline in which the last part was found.+  local line = NVIM9.index(val, 'tagline')+  local add = GetAddition(line, NVIM9.index(val, 'match'), { val }, brackets == '')+  local res = NVIM9.convert.decl_dict({ ['word'] = NVIM9.index(val, 'match') .. brackets .. add })++  if NVIM9.bool(NVIM9.fn['has_key'](val, 'info')) then+    -- # Use info from Tag2item().+    res[NVIM9.index_expr('info')] = NVIM9.index(val, 'info')+  else+    -- # Parse the tag line and add each part to the ""info"" entry.+    local s = Dict2info(ParseTagline(line))+    if s ~= '' then+      res[NVIM9.index_expr('info')] = s+    end+  end++  if NVIM9.bool(NVIM9.fn['has_key'](val, 'kind')) then+    res[NVIM9.index_expr('kind')] = NVIM9.index(val, 'kind')+  elseif NVIM9.bool(add == '(') then+    res[NVIM9.index_expr('kind')] = 'f'+  else+    local s = NVIM9.fn['matchstr'](line, '\\t\\(kind:\\)\\=\\zs\\S\\ze\\(\\t\\|$\\)')+    if s ~= '' then+      res[NVIM9.index_expr('kind')] = s+    end+  end++  if NVIM9.bool(NVIM9.fn['has_key'](val, 'extra')) then+    res[NVIM9.index_expr('menu')] = NVIM9.index(val, 'extra')+    return res+  end++  -- # Isolate the command after the tag and filename.+  local s = NVIM9.fn['matchstr'](+    line,+    '[^\\t]*\\t[^\\t]*\\t\\zs\\(/^.*$/\\|[^\\t]*\\)\\ze\\(;""\\t\\|\\t\\|$\\)'+  )+  if s ~= '' then+    res[NVIM9.index_expr('menu')] = Tagcmd2extra(+      s,+      NVIM9.index(val, 'match'),+      NVIM9.fn['matchstr'](line, '[^\\t]*\\t\\zs[^\\t]*\\ze\\t')+    )+  end+  return res+end++Tagcmd2extra = function(cmd, name, fname)+  -- # Turn a command from a tag line to something that is useful in the menu+  local x = ''+  if NVIM9.ops['RegexpMatches'](cmd, '^/^') then+    -- # The command is a search command, useful to see what it is.+    x = NVIM9.fn['substitute'](+      NVIM9.fn['substitute'](+        NVIM9.fn['matchstr'](cmd, '^/^\\s*\\zs.*\\ze$/'),+        '\\<' .. name .. '\\>',+        '@@',+        ''+      ),+      '\\\\\\(.\\)',+      '\\1',+      'g'+    ) .. ' - ' .. fname+  elseif NVIM9.bool(NVIM9.ops['RegexpMatches'](cmd, '^\\d*$')) then+    -- # The command is a line number, the file name is more useful.+    x = fname .. ' - ' .. cmd+  else+    -- # Not recognized, use command and file name.+    x = cmd .. ' - ' .. fname+  end+  return x+end++Nextitem = function(lead, items, depth, all)+  all = NVIM9.bool(all)+  -- # Find composing type in ""lead"" and match items[0] with it.+  -- # Repeat this recursively for items[1], if it's there.+  -- # When resolving typedefs ""depth"" is used to avoid infinite recursion.+  -- # Return the list of matches.++  -- # Use the text up to the variable name and split it in tokens.+  local tokens = NVIM9.fn['split'](lead, '\\s\\+\\|\\<')++  -- # Try to recognize the type of the variable.  This is rough guessing...+  local res = {}++  local body = function(_, tidx)+    -- # Skip tokens starting with a non-ID character.+    if NVIM9.ops['NotRegexpMatches'](NVIM9.index(tokens, tidx), '^\\h') then+      return NVIM9.ITER_CONTINUE+    end++    -- # Recognize ""struct foobar"" and ""union foobar"".+    -- # Also do ""class foobar"" when it's C++ after all (doesn't work very well+    -- # though).+    if+      (+        NVIM9.index(tokens, tidx) == 'struct'+        or NVIM9.index(tokens, tidx) == 'union'+        or NVIM9.index(tokens, tidx) == 'class'+      ) and NVIM9.ops['Plus'](tidx, 1) < NVIM9.fn['len'](tokens)+    then+      res = StructMembers(+        NVIM9.index(tokens, tidx) .. ':' .. NVIM9.index(tokens, NVIM9.ops['Plus'](tidx, 1)),+        items,+        all+      )+      return NVIM9.ITER_BREAK+    end++    -- # TODO: add more reserved words+    if+      NVIM9.fn['index'](+        { 'int', 'short', 'char', 'float', 'double', 'static', 'unsigned', 'extern' },+        NVIM9.index(tokens, tidx)+      ) >= 0+    then+      return NVIM9.ITER_CONTINUE+    end++    -- # Use the tags file to find out if this is a typedef.+    local diclist = NVIM9.fn['taglist']('^' .. NVIM9.index(tokens, tidx) .. '$')++    local body = function(_, tagidx)+      local item = NVIM9.convert.decl_dict(NVIM9.index(diclist, tagidx))++      -- # New ctags has the ""typeref"" field.  Patched version has ""typename"".+      if NVIM9.bool(NVIM9.fn['has_key'](item, 'typeref')) then+        res = NVIM9.fn['extend'](res, StructMembers(NVIM9.index(item, 'typeref'), items, all))+        return NVIM9.ITER_CONTINUE+      end+      if NVIM9.bool(NVIM9.fn['has_key'](item, 'typename')) then+        res = NVIM9.fn['extend'](res, StructMembers(NVIM9.index(item, 'typename'), items, all))+        return NVIM9.ITER_CONTINUE+      end++      -- # Only handle typedefs here.+      if NVIM9.index(item, 'kind') ~= 't' then+        return NVIM9.ITER_CONTINUE+      end++      -- # Skip matches local to another file.+      if+        NVIM9.bool(+          NVIM9.ops['And'](+            NVIM9.ops['And'](NVIM9.fn['has_key'](item, 'static'), NVIM9.index(item, 'static')),+            NVIM9.fn['bufnr']('%') ~= NVIM9.fn['bufnr'](NVIM9.index(item, 'filename'))+          )+        )+      then+        return NVIM9.ITER_CONTINUE+      end++      -- # For old ctags we recognize ""typedef struct aaa"" and+      -- # ""typedef union bbb"" in the tags file command.+      local cmd = NVIM9.index(item, 'cmd')+      local ei = NVIM9.fn['charidx'](cmd, NVIM9.fn['matchend'](cmd, 'typedef\\s\\+'))+      if ei > 1 then+        local cmdtokens = NVIM9.fn['split'](NVIM9.slice(cmd, ei, nil), '\\s\\+\\|\\<')+        if NVIM9.fn['len'](cmdtokens) > 1 then+          if+            NVIM9.index(cmdtokens, 0) == 'struct'+            or NVIM9.index(cmdtokens, 0) == 'union'+            or NVIM9.index(cmdtokens, 0) == 'class'+          then+            local name = ''+            -- # Use the first identifier after the ""struct"" or ""union""++            for _, ti in NVIM9.iter(NVIM9.fn['range']((NVIM9.fn['len'](cmdtokens) - 1))) do+              if NVIM9.ops['RegexpMatches'](NVIM9.index(cmdtokens, ti), '^\\w') then+                name = NVIM9.index(cmdtokens, ti)+                break+              end+            end++            if name ~= '' then+              res = NVIM9.fn['extend'](+                res,+                StructMembers(NVIM9.index(cmdtokens, 0) .. ':' .. name, items, all)+              )+            end+          elseif NVIM9.bool(depth < 10) then+            -- # Could be ""typedef other_T some_T"".+            res = NVIM9.fn['extend'](+              res,+              Nextitem(NVIM9.index(cmdtokens, 0), items, NVIM9.ops['Plus'](depth, 1), all)+            )+          end+        end+      end++      return NVIM9.ITER_DEFAULT+    end++    for _, tagidx in NVIM9.iter(NVIM9.fn['range'](NVIM9.fn['len'](diclist))) do+      local nvim9_status, nvim9_ret = body(_, tagidx)+      if nvim9_status == NVIM9.ITER_BREAK then+        break+      elseif nvim9_status == NVIM9.ITER_RETURN then+        return nvim9_ret+      end+    end++    if NVIM9.fn['len'](res) > 0 then+      return NVIM9.ITER_BREAK+    end++    return NVIM9.ITER_DEFAULT+  end++  for _, tidx in NVIM9.iter(NVIM9.fn['range'](NVIM9.fn['len'](tokens))) do+    local nvim9_status, nvim9_ret = body(_, tidx)+    if nvim9_status == NVIM9.ITER_BREAK then+      break+    elseif nvim9_status == NVIM9.ITER_RETURN then+      return nvim9_ret+    end+  end++  return res+end++StructMembers = function(atypename, items, all)+  all = NVIM9.bool(all)++  -- # Search for members of structure ""typename"" in tags files.+  -- # Return a list with resulting matches.+  -- # Each match is a dictionary with ""match"" and ""tagline"" entries.+  -- # When ""all"" is true find all, otherwise just return 1 if there is any member.++  -- # Todo: What about local structures?+  local fnames = NVIM9.fn['join'](NVIM9.fn['map'](+    NVIM9.fn['tagfiles'](),+    function(_, v)+      return NVIM9.fn['escape'](v, ' \\#%')+    end+  ))+  if fnames == '' then+    return {}+  end++  local typename = atypename+  local qflist = {}+  local cached = 0+  local n = ''+  if NVIM9.bool(NVIM9.prefix['Bang'](all)) then+    n = '1'+    if NVIM9.bool(NVIM9.fn['has_key'](grepCache, typename)) then+      qflist = NVIM9.index(grepCache, typename)+      cached = 1+    end+  else+    n = ''+  end+  if NVIM9.bool(NVIM9.prefix['Bang'](cached)) then+    while 1 do+      vim.api.nvim_command(+        'silent! keepjumps noautocmd '+          .. n+          .. 'vimgrep '+          .. '/\\t'+          .. typename+          .. '\\(\\t\\|$\\)/j '+          .. fnames+      )++      qflist = NVIM9.fn['getqflist']()+      if NVIM9.fn['len'](qflist) > 0 or NVIM9.fn['match'](typename, '::') < 0 then+        break+      end+      -- # No match for ""struct:context::name"", remove ""context::"" and try again.+      typename = NVIM9.fn['substitute'](typename, ':[^:]*::', ':', '')+    end++    if NVIM9.bool(NVIM9.prefix['Bang'](all)) then+      -- # Store the result to be able to use it again later.+      grepCache[NVIM9.index_expr(typename)] = qflist+    end+  end++  -- # Skip over [...] items+  local idx = 0+  local target = ''+  while 1 do+    if idx >= NVIM9.fn['len'](items) then+      target = ''+      break+    end+    if NVIM9.index(NVIM9.index(items, idx), 0) ~= '[' then+      target = NVIM9.index(items, idx)+      break+    end+    idx = idx + 1+  end+  -- # Put matching members in matches[].+  local matches = {}++  for _, l in NVIM9.iter(qflist) do+    local memb = NVIM9.fn['matchstr'](NVIM9.index(l, 'text'), '[^\\t]*')+    if NVIM9.ops['RegexpMatches'](memb, '^' .. target) then",i'd be fine with `vim9script` or `vim9`. I can prevent naming clashes in the generation step. I'll do whichever you prefer for merging.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21623,1060675030,2023-01-03T15:08:16Z,runtime/autoload/ccomplete.vim,"@@ -1,639 +1,8 @@-"" Vim completion script-"" Language:	C-"" Maintainer:	Bram Moolenaar <Bram@vim.org>-"" Last Change:	2020 Nov 14--let s:cpo_save = &cpo-set cpo&vim--"" This function is used for the 'omnifunc' option.-func ccomplete#Complete(findstart, base)-  if a:findstart-    "" Locate the start of the item, including ""."", ""->"" and ""[...]"".-    let line = getline('.')-    let start = col('.') - 1-    let lastword = -1-    while start > 0-      if line[start - 1] =~ '\w'-	let start -= 1-      elseif line[start - 1] =~ '\.'-	if lastword == -1-	  let lastword = start-	endif-	let start -= 1-      elseif start > 1 && line[start - 2] == '-' && line[start - 1] == '>'-	if lastword == -1-	  let lastword = start-	endif-	let start -= 2-      elseif line[start - 1] == ']'-	"" Skip over [...].-	let n = 0-	let start -= 1-	while start > 0-	  let start -= 1-	  if line[start] == '['-	    if n == 0-	      break-	    endif-	    let n -= 1-	  elseif line[start] == ']'  "" nested []-	    let n += 1-	  endif-	endwhile-      else-	break-      endif-    endwhile--    "" Return the column of the last word, which is going to be changed.-    "" Remember the text that comes before it in s:prepended.-    if lastword == -1-      let s:prepended = ''-      return start-    endif-    let s:prepended = strpart(line, start, lastword - start)-    return lastword-  endif--  "" Return list of matches.--  let base = s:prepended . a:base--  "" Don't do anything for an empty base, would result in all the tags in the-  "" tags file.-  if base == ''-    return []-  endif--  "" init cache for vimgrep to empty-  let s:grepCache = {}--  "" Split item in words, keep empty word after ""."" or ""->"".-  "" ""aa"" -> ['aa'], ""aa."" -> ['aa', ''], ""aa.bb"" -> ['aa', 'bb'], etc.-  "" We can't use split, because we need to skip nested [...].-  "" ""aa[...]"" -> ['aa', '[...]'], ""aa.bb[...]"" -> ['aa', 'bb', '[...]'], etc.-  let items = []-  let s = 0-  let arrays = 0-  while 1-    let e = match(base, '\.\|->\|\[', s)-    if e < 0-      if s == 0 || base[s - 1] != ']'-	call add(items, strpart(base, s))-      endif-      break-    endif-    if s == 0 || base[s - 1] != ']'-      call add(items, strpart(base, s, e - s))-    endif-    if base[e] == '.'-      let s = e + 1	"" skip over '.'-    elseif base[e] == '-'-      let s = e + 2	"" skip over '->'-    else-      "" Skip over [...].-      let n = 0-      let s = e-      let e += 1-      while e < len(base)-	if base[e] == ']'-	  if n == 0-	    break-	  endif-	  let n -= 1-	elseif base[e] == '['  "" nested [...]-	  let n += 1-	endif-	let e += 1-      endwhile-      let e += 1-      call add(items, strpart(base, s, e - s))-      let arrays += 1-      let s = e-    endif-  endwhile--  "" Find the variable items[0].-  "" 1. in current function (like with ""gd"")-  "" 2. in tags file(s) (like with "":tag"")-  "" 3. in current file (like with ""gD"")-  let res = []-  if searchdecl(items[0], 0, 1) == 0-    "" Found, now figure out the type.-    "" TODO: join previous line if it makes sense-    let line = getline('.')-    let col = col('.')-    if stridx(strpart(line, 0, col), ';') != -1-      "" Handle multiple declarations on the same line.-      let col2 = col - 1-      while line[col2] != ';'-	let col2 -= 1-      endwhile-      let line = strpart(line, col2 + 1)-      let col -= col2-    endif-    if stridx(strpart(line, 0, col), ',') != -1-      "" Handle multiple declarations on the same line in a function-      "" declaration.-      let col2 = col - 1-      while line[col2] != ','-	let col2 -= 1-      endwhile-      if strpart(line, col2 + 1, col - col2 - 1) =~ ' *[^ ][^ ]*  *[^ ]'-	let line = strpart(line, col2 + 1)-	let col -= col2-      endif-    endif-    if len(items) == 1-      "" Completing one word and it's a local variable: May add '[', '.' or-      "" '->'.-      let match = items[0]-      let kind = 'v'-      if match(line, '\<' . match . '\s*\[') > 0-	let match .= '['-      else-	let res = s:Nextitem(strpart(line, 0, col), [''], 0, 1)-	if len(res) > 0-	  "" There are members, thus add ""."" or ""->"".-	  if match(line, '\*[ \t(]*' . match . '\>') > 0-	    let match .= '->'-	  else-	    let match .= '.'-	  endif-	endif-      endif-      let res = [{'match': match, 'tagline' : '', 'kind' : kind, 'info' : line}]-    elseif len(items) == arrays + 1-      "" Completing one word and it's a local array variable: build tagline-      "" from declaration line-      let match = items[0]-      let kind = 'v'-      let tagline = ""\t/^"" . line . '$/'-      let res = [{'match': match, 'tagline' : tagline, 'kind' : kind, 'info' : line}]-    else-      "" Completing ""var."", ""var.something"", etc.-      let res = s:Nextitem(strpart(line, 0, col), items[1:], 0, 1)-    endif-  endif--  if len(items) == 1 || len(items) == arrays + 1-    "" Only one part, no ""."" or ""->"": complete from tags file.-    if len(items) == 1-      let tags = taglist('^' . base)-    else-      let tags = taglist('^' . items[0] . '$')-    endif--    "" Remove members, these can't appear without something in front.-    call filter(tags, 'has_key(v:val, ""kind"") ? v:val[""kind""] != ""m"" : 1')--    "" Remove static matches in other files.-    call filter(tags, '!has_key(v:val, ""static"") || !v:val[""static""] || bufnr(""%"") == bufnr(v:val[""filename""])')--    call extend(res, map(tags, 's:Tag2item(v:val)'))-  endif--  if len(res) == 0-    "" Find the variable in the tags file(s)-    let diclist = taglist('^' . items[0] . '$')--    "" Remove members, these can't appear without something in front.-    call filter(diclist, 'has_key(v:val, ""kind"") ? v:val[""kind""] != ""m"" : 1')--    let res = []-    for i in range(len(diclist))-      "" New ctags has the ""typeref"" field.  Patched version has ""typename"".-      if has_key(diclist[i], 'typename')-	call extend(res, s:StructMembers(diclist[i]['typename'], items[1:], 1))-      elseif has_key(diclist[i], 'typeref')-	call extend(res, s:StructMembers(diclist[i]['typeref'], items[1:], 1))-      endif--      "" For a variable use the command, which must be a search pattern that-      "" shows the declaration of the variable.-      if diclist[i]['kind'] == 'v'-	let line = diclist[i]['cmd']-	if line[0] == '/' && line[1] == '^'-	  let col = match(line, '\<' . items[0] . '\>')-	  call extend(res, s:Nextitem(strpart(line, 2, col - 2), items[1:], 0, 1))-	endif-      endif-    endfor-  endif--  if len(res) == 0 && searchdecl(items[0], 1) == 0-    "" Found, now figure out the type.-    "" TODO: join previous line if it makes sense-    let line = getline('.')-    let col = col('.')-    let res = s:Nextitem(strpart(line, 0, col), items[1:], 0, 1)-  endif--  "" If the last item(s) are [...] they need to be added to the matches.-  let last = len(items) - 1-  let brackets = ''-  while last >= 0-    if items[last][0] != '['-      break-    endif-    let brackets = items[last] . brackets-    let last -= 1-  endwhile--  return map(res, 's:Tagline2item(v:val, brackets)')-endfunc--func s:GetAddition(line, match, memarg, bracket)-  "" Guess if the item is an array.-  if a:bracket && match(a:line, a:match . '\s*\[') > 0-    return '['-  endif--  "" Check if the item has members.-  if len(s:SearchMembers(a:memarg, [''], 0)) > 0-    "" If there is a '*' before the name use ""->"".-    if match(a:line, '\*[ \t(]*' . a:match . '\>') > 0-      return '->'-    else-      return '.'-    endif-  endif-  return ''-endfunc--"" Turn the tag info ""val"" into an item for completion.-"" ""val"" is is an item in the list returned by taglist().-"" If it is a variable we may add ""."" or ""->"".  Don't do it for other types,-"" such as a typedef, by not including the info that s:GetAddition() uses.-func s:Tag2item(val)-  let res = {'match': a:val['name']}--  let res['extra'] = s:Tagcmd2extra(a:val['cmd'], a:val['name'], a:val['filename'])--  let s = s:Dict2info(a:val)-  if s != ''-    let res['info'] = s-  endif--  let res['tagline'] = ''-  if has_key(a:val, ""kind"")-    let kind = a:val['kind']-    let res['kind'] = kind-    if kind == 'v'-      let res['tagline'] = ""\t"" . a:val['cmd']-      let res['dict'] = a:val-    elseif kind == 'f'-      let res['match'] = a:val['name'] . '('-    endif-  endif--  return res-endfunc--"" Use all the items in dictionary for the ""info"" entry.-func s:Dict2info(dict)-  let info = ''-  for k in sort(keys(a:dict))-    let info  .= k . repeat(' ', 10 - len(k))-    if k == 'cmd'-      let info .= substitute(matchstr(a:dict['cmd'], '/^\s*\zs.*\ze$/'), '\\\(.\)', '\1', 'g')-    else-      let info .= a:dict[k]-    endif-    let info .= ""\n""-  endfor-  return info-endfunc--"" Parse a tag line and return a dictionary with items like taglist()-func s:ParseTagline(line)-  let l = split(a:line, ""\t"")-  let d = {}-  if len(l) >= 3-    let d['name'] = l[0]-    let d['filename'] = l[1]-    let d['cmd'] = l[2]-    let n = 2-    if l[2] =~ '^/'-      "" Find end of cmd, it may contain Tabs.-      while n < len(l) && l[n] !~ '/;""$'-	let n += 1-	let d['cmd'] .= ""  "" . l[n]-      endwhile-    endif-    for i in range(n + 1, len(l) - 1)-      if l[i] == 'file:'-	let d['static'] = 1-      elseif l[i] !~ ':'-	let d['kind'] = l[i]-      else-	let d[matchstr(l[i], '[^:]*')] = matchstr(l[i], ':\zs.*')-      endif-    endfor-  endif--  return d-endfunc--"" Turn a match item ""val"" into an item for completion.-"" ""val['match']"" is the matching item.-"" ""val['tagline']"" is the tagline in which the last part was found.-func s:Tagline2item(val, brackets)-  let line = a:val['tagline']-  let add = s:GetAddition(line, a:val['match'], [a:val], a:brackets == '')-  let res = {'word': a:val['match'] . a:brackets . add }--  if has_key(a:val, 'info')-    "" Use info from Tag2item().-    let res['info'] = a:val['info']-  else-    "" Parse the tag line and add each part to the ""info"" entry.-    let s = s:Dict2info(s:ParseTagline(line))-    if s != ''-      let res['info'] = s-    endif-  endif--  if has_key(a:val, 'kind')-    let res['kind'] = a:val['kind']-  elseif add == '('-    let res['kind'] = 'f'-  else-    let s = matchstr(line, '\t\(kind:\)\=\zs\S\ze\(\t\|$\)')-    if s != ''-      let res['kind'] = s-    endif-  endif--  if has_key(a:val, 'extra')-    let res['menu'] = a:val['extra']-    return res-  endif--  "" Isolate the command after the tag and filename.-  let s = matchstr(line, '[^\t]*\t[^\t]*\t\zs\(/^.*$/\|[^\t]*\)\ze\(;""\t\|\t\|$\)')-  if s != ''-    let res['menu'] = s:Tagcmd2extra(s, a:val['match'], matchstr(line, '[^\t]*\t\zs[^\t]*\ze\t'))-  endif-  return res-endfunc--"" Turn a command from a tag line to something that is useful in the menu-func s:Tagcmd2extra(cmd, name, fname)-  if a:cmd =~ '^/^'-    "" The command is a search command, useful to see what it is.-    let x = matchstr(a:cmd, '^/^\s*\zs.*\ze$/')-    let x = substitute(x, '\<' . a:name . '\>', '@@', '')-    let x = substitute(x, '\\\(.\)', '\1', 'g')-    let x = x . ' - ' . a:fname-  elseif a:cmd =~ '^\d*$'-    "" The command is a line number, the file name is more useful.-    let x = a:fname . ' - ' . a:cmd-  else-    "" Not recognized, use command and file name.-    let x = a:cmd . ' - ' . a:fname-  endif-  return x-endfunc--"" Find composing type in ""lead"" and match items[0] with it.-"" Repeat this recursively for items[1], if it's there.-"" When resolving typedefs ""depth"" is used to avoid infinite recursion.-"" Return the list of matches.-func s:Nextitem(lead, items, depth, all)--  "" Use the text up to the variable name and split it in tokens.-  let tokens = split(a:lead, '\s\+\|\<')--  "" Try to recognize the type of the variable.  This is rough guessing...-  let res = []-  for tidx in range(len(tokens))--    "" Skip tokens starting with a non-ID character.-    if tokens[tidx] !~ '^\h'-      continue-    endif--    "" Recognize ""struct foobar"" and ""union foobar"".-    "" Also do ""class foobar"" when it's C++ after all (doesn't work very well-    "" though).-    if (tokens[tidx] == 'struct' || tokens[tidx] == 'union' || tokens[tidx] == 'class') && tidx + 1 < len(tokens)-      let res = s:StructMembers(tokens[tidx] . ':' . tokens[tidx + 1], a:items, a:all)-      break-    endif--    "" TODO: add more reserved words-    if index(['int', 'short', 'char', 'float', 'double', 'static', 'unsigned', 'extern'], tokens[tidx]) >= 0-      continue-    endif--    "" Use the tags file to find out if this is a typedef.-    let diclist = taglist('^' . tokens[tidx] . '$')-    for tagidx in range(len(diclist))-      let item = diclist[tagidx]--      "" New ctags has the ""typeref"" field.  Patched version has ""typename"".-      if has_key(item, 'typeref')-	call extend(res, s:StructMembers(item['typeref'], a:items, a:all))-	continue-      endif-      if has_key(item, 'typename')-	call extend(res, s:StructMembers(item['typename'], a:items, a:all))-	continue-      endif--      "" Only handle typedefs here.-      if item['kind'] != 't'-	continue-      endif--      "" Skip matches local to another file.-      if has_key(item, 'static') && item['static'] && bufnr('%') != bufnr(item['filename'])-	continue-      endif--      "" For old ctags we recognize ""typedef struct aaa"" and-      "" ""typedef union bbb"" in the tags file command.-      let cmd = item['cmd']-      let ei = matchend(cmd, 'typedef\s\+')-      if ei > 1-	let cmdtokens = split(strpart(cmd, ei), '\s\+\|\<')-	if len(cmdtokens) > 1-	  if cmdtokens[0] == 'struct' || cmdtokens[0] == 'union' || cmdtokens[0] == 'class'-	    let name = ''-	    "" Use the first identifier after the ""struct"" or ""union""-	    for ti in range(len(cmdtokens) - 1)-	      if cmdtokens[ti] =~ '^\w'-		let name = cmdtokens[ti]-		break-	      endif-	    endfor-	    if name != ''-	      call extend(res, s:StructMembers(cmdtokens[0] . ':' . name, a:items, a:all))-	    endif-	  elseif a:depth < 10-	    "" Could be ""typedef other_T some_T"".-	    call extend(res, s:Nextitem(cmdtokens[0], a:items, a:depth + 1, a:all))-	  endif-	endif-      endif-    endfor-    if len(res) > 0-      break-    endif-  endfor--  return res-endfunc---"" Search for members of structure ""typename"" in tags files.-"" Return a list with resulting matches.-"" Each match is a dictionary with ""match"" and ""tagline"" entries.-"" When ""all"" is non-zero find all, otherwise just return 1 if there is any-"" member.-func s:StructMembers(typename, items, all)-  "" Todo: What about local structures?-  let fnames = join(map(tagfiles(), 'escape(v:val, "" \\#%"")'))-  if fnames == ''-    return []-  endif--  let typename = a:typename-  let qflist = []-  let cached = 0-  if a:all == 0-    let n = '1'	"" stop at first found match-    if has_key(s:grepCache, a:typename)-      let qflist = s:grepCache[a:typename]-      let cached = 1-    endif-  else-    let n = ''-  endif-  if !cached-    while 1-      exe 'silent! keepj noautocmd ' . n . 'vimgrep /\t' . typename . '\(\t\|$\)/j ' . fnames--      let qflist = getqflist()-      if len(qflist) > 0 || match(typename, ""::"") < 0-	break-      endif-      "" No match for ""struct:context::name"", remove ""context::"" and try again.-      let typename = substitute(typename, ':[^:]*::', ':', '')-    endwhile--    if a:all == 0-      "" Store the result to be able to use it again later.-      let s:grepCache[a:typename] = qflist-    endif-  endif--  "" Skip over [...] items-  let idx = 0-  while 1-    if idx >= len(a:items)-      let target = ''		"" No further items, matching all members-      break-    endif-    if a:items[idx][0] != '['-      let target = a:items[idx]-      break-    endif-    let idx += 1-  endwhile-  "" Put matching members in matches[].-  let matches = []-  for l in qflist-    let memb = matchstr(l['text'], '[^\t]*')-    if memb =~ '^' . target-      "" Skip matches local to another file.-      if match(l['text'], ""\tfile:"") < 0 || bufnr('%') == bufnr(matchstr(l['text'], '\t\zs[^\t]*'))-	let item = {'match': memb, 'tagline': l['text']}--	"" Add the kind of item.-	let s = matchstr(l['text'], '\t\(kind:\)\=\zs\S\ze\(\t\|$\)')-	if s != ''-	  let item['kind'] = s-	  if s == 'f'-	    let item['match'] = memb . '('-	  endif-	endif--	call add(matches, item)-      endif-    endif-  endfor--  if len(matches) > 0-    "" Skip over next [...] items-    let idx += 1-    while 1-      if idx >= len(a:items)-	return matches		"" No further items, return the result.-      endif-      if a:items[idx][0] != '['-	break-      endif-      let idx += 1-    endwhile--    "" More items following.  For each of the possible members find the-    "" matching following members.-    return s:SearchMembers(matches, a:items[idx :], a:all)-  endif--  "" Failed to find anything.-  return []-endfunc--"" For matching members, find matches for following items.-"" When ""all"" is non-zero find all, otherwise just return 1 if there is any-"" member.-func s:SearchMembers(matches, items, all)-  let res = []-  for i in range(len(a:matches))-    let typename = ''-    if has_key(a:matches[i], 'dict')-      if has_key(a:matches[i].dict, 'typename')-	let typename = a:matches[i].dict['typename']-      elseif has_key(a:matches[i].dict, 'typeref')-	let typename = a:matches[i].dict['typeref']-      endif-      let line = ""\t"" . a:matches[i].dict['cmd']-    else-      let line = a:matches[i]['tagline']-      let e = matchend(line, '\ttypename:')-      if e < 0-	let e = matchend(line, '\ttyperef:')-      endif-      if e > 0-	"" Use typename field-	let typename = matchstr(line, '[^\t]*', e)-      endif-    endif--    if typename != ''-      call extend(res, s:StructMembers(typename, a:items, a:all))-    else-      "" Use the search command (the declaration itself).-      let s = match(line, '\t\zs/^')-      if s > 0-	let e = match(line, '\<' . a:matches[i]['match'] . '\>', s)-	if e > 0-	  call extend(res, s:Nextitem(strpart(line, s, e - s), a:items, 0, a:all))-	endif-      endif-    endif-    if a:all == 0 && len(res) > 0-      break-    endif-  endfor-  return res-endfunc--let &cpo = s:cpo_save-unlet s:cpo_save--"" vim: noet sw=2 sts=2+"" Generated vim file by vim9jit. Please do not edit+let s:PATH = expand(""<script>"")","> complaint is that it's very inconsistently and randomly used (cargo-cult)How exactly is it inconsistent and randomly used? > ... and doesn't actually have a purpose.As mentioned, it's just a signal to the reader that the variable is a simple value and doesn't represent state. Take the 3 cases:```luafor i = 0, 20 do ... end         -- 1for i = 0, some_max do ... end   -- 2for i = 0, SOME_MAX do           -- 3```1 should be avoided since magic numbers are bad. 2 gives no indication whether `some_max` is expected to change (and LSP can't even tell you). 3 indicates the loop is fixed and doesn't depend on any state.So overall I find this pretty valuable and certainly makes refactoring easier.> To enforce immutability, returning a value from a function seems reasonable.- A function can indicate it might perform side effects or return a different value each time.- Is much more tedious to write and reference- Is slower and harder for a compiler to optimizeEnforcing immutability isn't the thing that's particularly important. It's more about stateful vs stateless code and being able to identify that quickly without inspecting everything.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21623,1060731186,2023-01-03T16:08:01Z,runtime/autoload/ccomplete.vim,"@@ -1,639 +1,8 @@-"" Vim completion script-"" Language:	C-"" Maintainer:	Bram Moolenaar <Bram@vim.org>-"" Last Change:	2020 Nov 14--let s:cpo_save = &cpo-set cpo&vim--"" This function is used for the 'omnifunc' option.-func ccomplete#Complete(findstart, base)-  if a:findstart-    "" Locate the start of the item, including ""."", ""->"" and ""[...]"".-    let line = getline('.')-    let start = col('.') - 1-    let lastword = -1-    while start > 0-      if line[start - 1] =~ '\w'-	let start -= 1-      elseif line[start - 1] =~ '\.'-	if lastword == -1-	  let lastword = start-	endif-	let start -= 1-      elseif start > 1 && line[start - 2] == '-' && line[start - 1] == '>'-	if lastword == -1-	  let lastword = start-	endif-	let start -= 2-      elseif line[start - 1] == ']'-	"" Skip over [...].-	let n = 0-	let start -= 1-	while start > 0-	  let start -= 1-	  if line[start] == '['-	    if n == 0-	      break-	    endif-	    let n -= 1-	  elseif line[start] == ']'  "" nested []-	    let n += 1-	  endif-	endwhile-      else-	break-      endif-    endwhile--    "" Return the column of the last word, which is going to be changed.-    "" Remember the text that comes before it in s:prepended.-    if lastword == -1-      let s:prepended = ''-      return start-    endif-    let s:prepended = strpart(line, start, lastword - start)-    return lastword-  endif--  "" Return list of matches.--  let base = s:prepended . a:base--  "" Don't do anything for an empty base, would result in all the tags in the-  "" tags file.-  if base == ''-    return []-  endif--  "" init cache for vimgrep to empty-  let s:grepCache = {}--  "" Split item in words, keep empty word after ""."" or ""->"".-  "" ""aa"" -> ['aa'], ""aa."" -> ['aa', ''], ""aa.bb"" -> ['aa', 'bb'], etc.-  "" We can't use split, because we need to skip nested [...].-  "" ""aa[...]"" -> ['aa', '[...]'], ""aa.bb[...]"" -> ['aa', 'bb', '[...]'], etc.-  let items = []-  let s = 0-  let arrays = 0-  while 1-    let e = match(base, '\.\|->\|\[', s)-    if e < 0-      if s == 0 || base[s - 1] != ']'-	call add(items, strpart(base, s))-      endif-      break-    endif-    if s == 0 || base[s - 1] != ']'-      call add(items, strpart(base, s, e - s))-    endif-    if base[e] == '.'-      let s = e + 1	"" skip over '.'-    elseif base[e] == '-'-      let s = e + 2	"" skip over '->'-    else-      "" Skip over [...].-      let n = 0-      let s = e-      let e += 1-      while e < len(base)-	if base[e] == ']'-	  if n == 0-	    break-	  endif-	  let n -= 1-	elseif base[e] == '['  "" nested [...]-	  let n += 1-	endif-	let e += 1-      endwhile-      let e += 1-      call add(items, strpart(base, s, e - s))-      let arrays += 1-      let s = e-    endif-  endwhile--  "" Find the variable items[0].-  "" 1. in current function (like with ""gd"")-  "" 2. in tags file(s) (like with "":tag"")-  "" 3. in current file (like with ""gD"")-  let res = []-  if searchdecl(items[0], 0, 1) == 0-    "" Found, now figure out the type.-    "" TODO: join previous line if it makes sense-    let line = getline('.')-    let col = col('.')-    if stridx(strpart(line, 0, col), ';') != -1-      "" Handle multiple declarations on the same line.-      let col2 = col - 1-      while line[col2] != ';'-	let col2 -= 1-      endwhile-      let line = strpart(line, col2 + 1)-      let col -= col2-    endif-    if stridx(strpart(line, 0, col), ',') != -1-      "" Handle multiple declarations on the same line in a function-      "" declaration.-      let col2 = col - 1-      while line[col2] != ','-	let col2 -= 1-      endwhile-      if strpart(line, col2 + 1, col - col2 - 1) =~ ' *[^ ][^ ]*  *[^ ]'-	let line = strpart(line, col2 + 1)-	let col -= col2-      endif-    endif-    if len(items) == 1-      "" Completing one word and it's a local variable: May add '[', '.' or-      "" '->'.-      let match = items[0]-      let kind = 'v'-      if match(line, '\<' . match . '\s*\[') > 0-	let match .= '['-      else-	let res = s:Nextitem(strpart(line, 0, col), [''], 0, 1)-	if len(res) > 0-	  "" There are members, thus add ""."" or ""->"".-	  if match(line, '\*[ \t(]*' . match . '\>') > 0-	    let match .= '->'-	  else-	    let match .= '.'-	  endif-	endif-      endif-      let res = [{'match': match, 'tagline' : '', 'kind' : kind, 'info' : line}]-    elseif len(items) == arrays + 1-      "" Completing one word and it's a local array variable: build tagline-      "" from declaration line-      let match = items[0]-      let kind = 'v'-      let tagline = ""\t/^"" . line . '$/'-      let res = [{'match': match, 'tagline' : tagline, 'kind' : kind, 'info' : line}]-    else-      "" Completing ""var."", ""var.something"", etc.-      let res = s:Nextitem(strpart(line, 0, col), items[1:], 0, 1)-    endif-  endif--  if len(items) == 1 || len(items) == arrays + 1-    "" Only one part, no ""."" or ""->"": complete from tags file.-    if len(items) == 1-      let tags = taglist('^' . base)-    else-      let tags = taglist('^' . items[0] . '$')-    endif--    "" Remove members, these can't appear without something in front.-    call filter(tags, 'has_key(v:val, ""kind"") ? v:val[""kind""] != ""m"" : 1')--    "" Remove static matches in other files.-    call filter(tags, '!has_key(v:val, ""static"") || !v:val[""static""] || bufnr(""%"") == bufnr(v:val[""filename""])')--    call extend(res, map(tags, 's:Tag2item(v:val)'))-  endif--  if len(res) == 0-    "" Find the variable in the tags file(s)-    let diclist = taglist('^' . items[0] . '$')--    "" Remove members, these can't appear without something in front.-    call filter(diclist, 'has_key(v:val, ""kind"") ? v:val[""kind""] != ""m"" : 1')--    let res = []-    for i in range(len(diclist))-      "" New ctags has the ""typeref"" field.  Patched version has ""typename"".-      if has_key(diclist[i], 'typename')-	call extend(res, s:StructMembers(diclist[i]['typename'], items[1:], 1))-      elseif has_key(diclist[i], 'typeref')-	call extend(res, s:StructMembers(diclist[i]['typeref'], items[1:], 1))-      endif--      "" For a variable use the command, which must be a search pattern that-      "" shows the declaration of the variable.-      if diclist[i]['kind'] == 'v'-	let line = diclist[i]['cmd']-	if line[0] == '/' && line[1] == '^'-	  let col = match(line, '\<' . items[0] . '\>')-	  call extend(res, s:Nextitem(strpart(line, 2, col - 2), items[1:], 0, 1))-	endif-      endif-    endfor-  endif--  if len(res) == 0 && searchdecl(items[0], 1) == 0-    "" Found, now figure out the type.-    "" TODO: join previous line if it makes sense-    let line = getline('.')-    let col = col('.')-    let res = s:Nextitem(strpart(line, 0, col), items[1:], 0, 1)-  endif--  "" If the last item(s) are [...] they need to be added to the matches.-  let last = len(items) - 1-  let brackets = ''-  while last >= 0-    if items[last][0] != '['-      break-    endif-    let brackets = items[last] . brackets-    let last -= 1-  endwhile--  return map(res, 's:Tagline2item(v:val, brackets)')-endfunc--func s:GetAddition(line, match, memarg, bracket)-  "" Guess if the item is an array.-  if a:bracket && match(a:line, a:match . '\s*\[') > 0-    return '['-  endif--  "" Check if the item has members.-  if len(s:SearchMembers(a:memarg, [''], 0)) > 0-    "" If there is a '*' before the name use ""->"".-    if match(a:line, '\*[ \t(]*' . a:match . '\>') > 0-      return '->'-    else-      return '.'-    endif-  endif-  return ''-endfunc--"" Turn the tag info ""val"" into an item for completion.-"" ""val"" is is an item in the list returned by taglist().-"" If it is a variable we may add ""."" or ""->"".  Don't do it for other types,-"" such as a typedef, by not including the info that s:GetAddition() uses.-func s:Tag2item(val)-  let res = {'match': a:val['name']}--  let res['extra'] = s:Tagcmd2extra(a:val['cmd'], a:val['name'], a:val['filename'])--  let s = s:Dict2info(a:val)-  if s != ''-    let res['info'] = s-  endif--  let res['tagline'] = ''-  if has_key(a:val, ""kind"")-    let kind = a:val['kind']-    let res['kind'] = kind-    if kind == 'v'-      let res['tagline'] = ""\t"" . a:val['cmd']-      let res['dict'] = a:val-    elseif kind == 'f'-      let res['match'] = a:val['name'] . '('-    endif-  endif--  return res-endfunc--"" Use all the items in dictionary for the ""info"" entry.-func s:Dict2info(dict)-  let info = ''-  for k in sort(keys(a:dict))-    let info  .= k . repeat(' ', 10 - len(k))-    if k == 'cmd'-      let info .= substitute(matchstr(a:dict['cmd'], '/^\s*\zs.*\ze$/'), '\\\(.\)', '\1', 'g')-    else-      let info .= a:dict[k]-    endif-    let info .= ""\n""-  endfor-  return info-endfunc--"" Parse a tag line and return a dictionary with items like taglist()-func s:ParseTagline(line)-  let l = split(a:line, ""\t"")-  let d = {}-  if len(l) >= 3-    let d['name'] = l[0]-    let d['filename'] = l[1]-    let d['cmd'] = l[2]-    let n = 2-    if l[2] =~ '^/'-      "" Find end of cmd, it may contain Tabs.-      while n < len(l) && l[n] !~ '/;""$'-	let n += 1-	let d['cmd'] .= ""  "" . l[n]-      endwhile-    endif-    for i in range(n + 1, len(l) - 1)-      if l[i] == 'file:'-	let d['static'] = 1-      elseif l[i] !~ ':'-	let d['kind'] = l[i]-      else-	let d[matchstr(l[i], '[^:]*')] = matchstr(l[i], ':\zs.*')-      endif-    endfor-  endif--  return d-endfunc--"" Turn a match item ""val"" into an item for completion.-"" ""val['match']"" is the matching item.-"" ""val['tagline']"" is the tagline in which the last part was found.-func s:Tagline2item(val, brackets)-  let line = a:val['tagline']-  let add = s:GetAddition(line, a:val['match'], [a:val], a:brackets == '')-  let res = {'word': a:val['match'] . a:brackets . add }--  if has_key(a:val, 'info')-    "" Use info from Tag2item().-    let res['info'] = a:val['info']-  else-    "" Parse the tag line and add each part to the ""info"" entry.-    let s = s:Dict2info(s:ParseTagline(line))-    if s != ''-      let res['info'] = s-    endif-  endif--  if has_key(a:val, 'kind')-    let res['kind'] = a:val['kind']-  elseif add == '('-    let res['kind'] = 'f'-  else-    let s = matchstr(line, '\t\(kind:\)\=\zs\S\ze\(\t\|$\)')-    if s != ''-      let res['kind'] = s-    endif-  endif--  if has_key(a:val, 'extra')-    let res['menu'] = a:val['extra']-    return res-  endif--  "" Isolate the command after the tag and filename.-  let s = matchstr(line, '[^\t]*\t[^\t]*\t\zs\(/^.*$/\|[^\t]*\)\ze\(;""\t\|\t\|$\)')-  if s != ''-    let res['menu'] = s:Tagcmd2extra(s, a:val['match'], matchstr(line, '[^\t]*\t\zs[^\t]*\ze\t'))-  endif-  return res-endfunc--"" Turn a command from a tag line to something that is useful in the menu-func s:Tagcmd2extra(cmd, name, fname)-  if a:cmd =~ '^/^'-    "" The command is a search command, useful to see what it is.-    let x = matchstr(a:cmd, '^/^\s*\zs.*\ze$/')-    let x = substitute(x, '\<' . a:name . '\>', '@@', '')-    let x = substitute(x, '\\\(.\)', '\1', 'g')-    let x = x . ' - ' . a:fname-  elseif a:cmd =~ '^\d*$'-    "" The command is a line number, the file name is more useful.-    let x = a:fname . ' - ' . a:cmd-  else-    "" Not recognized, use command and file name.-    let x = a:cmd . ' - ' . a:fname-  endif-  return x-endfunc--"" Find composing type in ""lead"" and match items[0] with it.-"" Repeat this recursively for items[1], if it's there.-"" When resolving typedefs ""depth"" is used to avoid infinite recursion.-"" Return the list of matches.-func s:Nextitem(lead, items, depth, all)--  "" Use the text up to the variable name and split it in tokens.-  let tokens = split(a:lead, '\s\+\|\<')--  "" Try to recognize the type of the variable.  This is rough guessing...-  let res = []-  for tidx in range(len(tokens))--    "" Skip tokens starting with a non-ID character.-    if tokens[tidx] !~ '^\h'-      continue-    endif--    "" Recognize ""struct foobar"" and ""union foobar"".-    "" Also do ""class foobar"" when it's C++ after all (doesn't work very well-    "" though).-    if (tokens[tidx] == 'struct' || tokens[tidx] == 'union' || tokens[tidx] == 'class') && tidx + 1 < len(tokens)-      let res = s:StructMembers(tokens[tidx] . ':' . tokens[tidx + 1], a:items, a:all)-      break-    endif--    "" TODO: add more reserved words-    if index(['int', 'short', 'char', 'float', 'double', 'static', 'unsigned', 'extern'], tokens[tidx]) >= 0-      continue-    endif--    "" Use the tags file to find out if this is a typedef.-    let diclist = taglist('^' . tokens[tidx] . '$')-    for tagidx in range(len(diclist))-      let item = diclist[tagidx]--      "" New ctags has the ""typeref"" field.  Patched version has ""typename"".-      if has_key(item, 'typeref')-	call extend(res, s:StructMembers(item['typeref'], a:items, a:all))-	continue-      endif-      if has_key(item, 'typename')-	call extend(res, s:StructMembers(item['typename'], a:items, a:all))-	continue-      endif--      "" Only handle typedefs here.-      if item['kind'] != 't'-	continue-      endif--      "" Skip matches local to another file.-      if has_key(item, 'static') && item['static'] && bufnr('%') != bufnr(item['filename'])-	continue-      endif--      "" For old ctags we recognize ""typedef struct aaa"" and-      "" ""typedef union bbb"" in the tags file command.-      let cmd = item['cmd']-      let ei = matchend(cmd, 'typedef\s\+')-      if ei > 1-	let cmdtokens = split(strpart(cmd, ei), '\s\+\|\<')-	if len(cmdtokens) > 1-	  if cmdtokens[0] == 'struct' || cmdtokens[0] == 'union' || cmdtokens[0] == 'class'-	    let name = ''-	    "" Use the first identifier after the ""struct"" or ""union""-	    for ti in range(len(cmdtokens) - 1)-	      if cmdtokens[ti] =~ '^\w'-		let name = cmdtokens[ti]-		break-	      endif-	    endfor-	    if name != ''-	      call extend(res, s:StructMembers(cmdtokens[0] . ':' . name, a:items, a:all))-	    endif-	  elseif a:depth < 10-	    "" Could be ""typedef other_T some_T"".-	    call extend(res, s:Nextitem(cmdtokens[0], a:items, a:depth + 1, a:all))-	  endif-	endif-      endif-    endfor-    if len(res) > 0-      break-    endif-  endfor--  return res-endfunc---"" Search for members of structure ""typename"" in tags files.-"" Return a list with resulting matches.-"" Each match is a dictionary with ""match"" and ""tagline"" entries.-"" When ""all"" is non-zero find all, otherwise just return 1 if there is any-"" member.-func s:StructMembers(typename, items, all)-  "" Todo: What about local structures?-  let fnames = join(map(tagfiles(), 'escape(v:val, "" \\#%"")'))-  if fnames == ''-    return []-  endif--  let typename = a:typename-  let qflist = []-  let cached = 0-  if a:all == 0-    let n = '1'	"" stop at first found match-    if has_key(s:grepCache, a:typename)-      let qflist = s:grepCache[a:typename]-      let cached = 1-    endif-  else-    let n = ''-  endif-  if !cached-    while 1-      exe 'silent! keepj noautocmd ' . n . 'vimgrep /\t' . typename . '\(\t\|$\)/j ' . fnames--      let qflist = getqflist()-      if len(qflist) > 0 || match(typename, ""::"") < 0-	break-      endif-      "" No match for ""struct:context::name"", remove ""context::"" and try again.-      let typename = substitute(typename, ':[^:]*::', ':', '')-    endwhile--    if a:all == 0-      "" Store the result to be able to use it again later.-      let s:grepCache[a:typename] = qflist-    endif-  endif--  "" Skip over [...] items-  let idx = 0-  while 1-    if idx >= len(a:items)-      let target = ''		"" No further items, matching all members-      break-    endif-    if a:items[idx][0] != '['-      let target = a:items[idx]-      break-    endif-    let idx += 1-  endwhile-  "" Put matching members in matches[].-  let matches = []-  for l in qflist-    let memb = matchstr(l['text'], '[^\t]*')-    if memb =~ '^' . target-      "" Skip matches local to another file.-      if match(l['text'], ""\tfile:"") < 0 || bufnr('%') == bufnr(matchstr(l['text'], '\t\zs[^\t]*'))-	let item = {'match': memb, 'tagline': l['text']}--	"" Add the kind of item.-	let s = matchstr(l['text'], '\t\(kind:\)\=\zs\S\ze\(\t\|$\)')-	if s != ''-	  let item['kind'] = s-	  if s == 'f'-	    let item['match'] = memb . '('-	  endif-	endif--	call add(matches, item)-      endif-    endif-  endfor--  if len(matches) > 0-    "" Skip over next [...] items-    let idx += 1-    while 1-      if idx >= len(a:items)-	return matches		"" No further items, return the result.-      endif-      if a:items[idx][0] != '['-	break-      endif-      let idx += 1-    endwhile--    "" More items following.  For each of the possible members find the-    "" matching following members.-    return s:SearchMembers(matches, a:items[idx :], a:all)-  endif--  "" Failed to find anything.-  return []-endfunc--"" For matching members, find matches for following items.-"" When ""all"" is non-zero find all, otherwise just return 1 if there is any-"" member.-func s:SearchMembers(matches, items, all)-  let res = []-  for i in range(len(a:matches))-    let typename = ''-    if has_key(a:matches[i], 'dict')-      if has_key(a:matches[i].dict, 'typename')-	let typename = a:matches[i].dict['typename']-      elseif has_key(a:matches[i].dict, 'typeref')-	let typename = a:matches[i].dict['typeref']-      endif-      let line = ""\t"" . a:matches[i].dict['cmd']-    else-      let line = a:matches[i]['tagline']-      let e = matchend(line, '\ttypename:')-      if e < 0-	let e = matchend(line, '\ttyperef:')-      endif-      if e > 0-	"" Use typename field-	let typename = matchstr(line, '[^\t]*', e)-      endif-    endif--    if typename != ''-      call extend(res, s:StructMembers(typename, a:items, a:all))-    else-      "" Use the search command (the declaration itself).-      let s = match(line, '\t\zs/^')-      if s > 0-	let e = match(line, '\<' . a:matches[i]['match'] . '\>', s)-	if e > 0-	  call extend(res, s:Nextitem(strpart(line, s, e - s), a:items, 0, a:all))-	endif-      endif-    endif-    if a:all == 0 && len(res) > 0-      break-    endif-  endfor-  return res-endfunc--let &cpo = s:cpo_save-unlet s:cpo_save--"" vim: noet sw=2 sts=2+"" Generated vim file by vim9jit. Please do not edit+let s:PATH = expand(""<script>"")","> How exactly is it inconsistent and randomly used?there are all kinds of readonly things that are not uppercase. Local vars, parameters, etc.> 3 indicates the loop is fixed and doesn't depend on any state.yes but it's a fantasy. it _could_ change--and it is a very rare and degenerate case where a for-loop iterates something that changes, so doing ""THIS DANCE"" everywhere all the time is a noisy, distracting practice.> It's more about stateful vs stateless code and being able to identify that quickly without inspecting everything.the variable name doesn't avoid the need to inspect everything. it is a _very_ weak signal for a _strong_ property that, if it's actually important, must be enforced technically rather than cosmetically.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21548,1060756892,2023-01-03T16:35:45Z,runtime/lua/vim/treesitter/query.lua,"@@ -408,12 +425,21 @@ local directive_handlers = {      -- If this produces an invalid range, we just skip it.     if range[1] < range[3] or (range[1] == range[3] and range[2] <= range[4]) then-      if not metadata[capture_id] then-        metadata[capture_id] = {}-      end       metadata[capture_id].range = range     end   end,++  -- Transform the content of the node+  -- Example: (#gsub! @_node "".*%.(.*)"" ""%1"")+  ['gsub!'] = function(match, _, bufnr, pred, metadata)+    assert(#pred == 4)++    local id = pred[2]+    local node = match[id]+    local text = M.get_node_text(node, bufnr, { metadata = metadata[id] }) or ''++    metadata[id] = text:gsub(pred[3], pred[4])","That comment is a bit ambiguous, I didn't read it as store the result *as* the metadata, but *in* the metadata.",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21633,1060773313,2023-01-03T16:54:30Z,runtime/plugin/editorconfig.lua,"@@ -0,0 +1,12 @@+if vim.g.loaded_editorconfig then+  return+end+vim.g.loaded_editorconfig = 1","I know this is the longstanding convention for opt-ing out of builtin plugins, but is this really something we want to continue to perpetuate? Users doing `vim.g.loaded_editorconfig = 1` feels really hacky. It's like they're lying to nvim. Imagine if you're a new user and you see this in someone else's config? One could argue it looks like it's enabling something.How about something like:```luaif vim.g.loaded_editorconfig or vim.g.disable_editorconfig then```It's maybe a lil redundant to have 2 variables, but I think it pays back in the UX.",X
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21633,1060846646,2023-01-03T18:26:34Z,runtime/doc/editorconfig.txt,"@@ -0,0 +1,88 @@+*editorconfig.txt*  Nvim+++                            NVIM REFERENCE MANUAL+++EditorConfig integration                                        *editorconfig*++Nvim natively supports EditorConfig. When a file is opened, Nvim searches+upward through all of the parent directories of that file looking for+"".editorconfig"" files. Each of these is parsed and any properties that match+the opened file are applied.++For more information on EditorConfig, see https://editorconfig.org/.++                                                       *g:editorconfig_enable*+EditorConfig integration can be disabled by adding >lua++    vim.g.editorconfig_enable = false+<+to the user's |init.lua| file (or the Vimscript equivalent to |init.vim|).++                                                              *b:editorconfig*+When Nvim finds a valid .editorconfig file it will store the applied+properties in the buffer variable |b:editorconfig|.++The following properties are supported by default:","We have a link to `https://editorconfig.org` already, and the properties are listed on that page (you just have to scroll down a little).",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1061081205,2023-01-04T01:52:06Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,486 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)","Yep, that's exactly what this is. LSP specifies its own syntax for the patterns here: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern.It looks like `glob()` handles everything except the `[!...]` and `{}` syntax that LSP describes. I can take a look to see if we can leverage that for the rest, but I think some amount of finagling like this is going to be necessary to fill the gaps.",
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1061081214,2023-01-04T01:52:08Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,486 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = { '' }++  local path_sep = '[/\\]'+  local non_path_sep = '[^/\\]'++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p .. chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = ''+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = ''+      else+        if c == '{' then+          in_braces = true+        elseif c == '}' then+          in_braces = false+        elseif c == '[' then+          in_brackets = true+        elseif c == ']' then+          in_brackets = false+        end+        segment = segment .. c+      end+    end+    if segment ~= '' then+      table.insert(segments, segment)+    end+    return segments+  end++  local function escape(c)+    if+      c == '?'+      or c == '.'+      or c == '('+      or c == ')'+      or c == '%'+      or c == '['+      or c == ']'+      or c == '*'+      or c == '+'+      or c == '-'+    then+      return '%' .. c+    end+    return c+  end++  local segments = split(pattern, '/')+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == '**' then+      local chunks = {+        path_sep .. '-',+        '.-' .. path_sep,+      }+      if last_seg then+        chunks = { '.-' }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = ''+      local in_brackets = false+      local bracket_val = ''+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= '}' and in_braces then+          brace_val = brace_val .. char+        else+          if in_brackets and (char ~= ']' or bracket_val == '') then+            local res+            if char == '-' then+              res = char+            elseif bracket_val == '' and char == '!' then+              res = '^'+            elseif char == '/' then+              res = ''+            else+              res = escape(char)+            end+            bracket_val = bracket_val .. res+          else+            if char == '{' then+              in_braces = true+            elseif char == '[' then+              in_brackets = true+            elseif char == '}' then+              local choices = split(brace_val, ',')+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = ''+            elseif char == ']' then+              append({ '[' .. bracket_val .. ']' })+              in_brackets = false+              bracket_val = ''+            elseif char == '?' then+              append({ non_path_sep })+            elseif char == '*' then+              append({ non_path_sep .. '-' })+            else+              append({ escape(char) })+            end+          end+        end+      end++      if not last_seg and (segments[i + 1] ~= '**' or i + 1 < #segments) then+        append({ path_sep })+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return bool Whether or not pattern matches s.+function M._match(pattern, s)+  if type(pattern) == 'string' then+    pattern = parse(pattern)+  end+  -- Since Lua's built-in string pattern matching does not have an alternate+  -- operator like '|', `parse` will construct one pattern for each possible+  -- alternative. Any pattern that matches thus matches the glob.+  for _, p in ipairs(pattern) do+    if s:match('^' .. p .. '$') then+      return true+    end+  end+  return false+end++local path_sep++---@private+--- Joins filepath elements by platform-specific separator.+---+---@param args ... The path elements. The first element must be absolute.+---@return string The joined path.+local function filepath_join(...)+  return table.concat({ ... }, path_sep)+end++local registrations = {}++-- Cache of libuv handles per directory, per LSP client, per registration ID.+local watched_paths = {}++local change_queue = {}+local change_cache = {}+local queue_timers = {}++-- Recursive flag for libuv watcher not implemented on linux+local recursive_watch = vim.fn.has('mac') == 1 or vim.fn.has('win32') == 1++-- kqueue requires one watch for every file+local watch_each_file = vim.fn.has('bsd') == 1++---@private+--- Creates callbacks invoked on watched file events.+---+---@param watch_path string Absolute path being watched.+---@param client_id number The LSP client's ID.+---@param reg_id string The ID used to register the request.+---@return function The callback invoked on watched file events.+local function get_callback(watch_path, client_id, reg_id)+  return function(path, type)+    local matches_filter = false+    local filters = watched_paths[watch_path].callbacks[client_id][reg_id].filters+    for _, filter in ipairs(filters) do+      if M._match(filter.pattern, path) and math.floor(filter.kind / (2 ^ (type - 1))) % 2 == 1 then+        matches_filter = true+        break+      end+    end+    if not matches_filter then+      return+    end++    local change = {+      uri = vim.uri_from_fname(path),+      type = type,+    }+    change_cache[client_id] = change_cache[client_id] or {}+    local last_type = change_cache[client_id][change.uri]+    if not last_type or last_type ~= change.type then+      change_queue[client_id] = change_queue[client_id] or {}+      table.insert(change_queue[client_id], change)+      change_cache[client_id][change.uri] = change.type+    end+    if not queue_timers[client_id] then+      queue_timers[client_id] = vim.defer_fn(function()+        vim.lsp.get_client_by_id(client_id).notify('workspace/didChangeWatchedFiles', {+          changes = change_queue[client_id],+        })+        change_queue[client_id] = nil+        change_cache[client_id] = nil+        queue_timers[client_id] = nil+      end, 100)+    end+  end+end++-- Never create watchers for directories matching these patterns. Similar+-- to vscode's files.watcherExclude setting.+local excludes = {+  parse('**/.git/objects/**'),+  parse('**/.git/subtree-cache/**'),+  parse('**/node_modules/*/**'),+  parse('**/.hg/store/**'),+}++local fsevent_ensure_recursive++---@private+--- Initializes a libuv fs_event, persistent when underlying inodes change.+---+---@param path string The path to watch.+---@return uv.fs_event The started libuv fs_event handle.+local function start_watch(path)","This function does read a global list of LSP registrations to get details like LSP client and registration IDs to pass through for housekeeping purposes. But it definitely seems possible to do those things separately from the file watching.I remember seeing the first iteration of that PR, but didn't catch then that the autoread changes are driven by a general purpose file watcher that could be plugged in here. I'll start playing around with the implementation in #20801 to see if I can fit that in here.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21649,1061918472,2023-01-04T21:57:56Z,runtime/plugin/editorconfig.lua,"@@ -1,11 +1,13 @@-if vim.g.editorconfig_enable == false or vim.g.editorconfig_enable == 0 then-  return-end","We would need to create a separate variable then, as otherwise setting `editorconfig_enable` after the fact would not re-create the autocommand.The autocommand is basically a no-op with `editorconfig_enable` set to false, but if someone doesn't even want the autocommand listed at all they can always `au! editorconfig`.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21657,1062475186,2023-01-05T13:30:05Z,runtime/lua/vim/treesitter/query.lua,"@@ -414,6 +414,30 @@ local directive_handlers = {       metadata[capture_id].range = range     end   end,+  ['exclude_children!'] = function(match, _, _, pred, metadata)+    local capture_id = pred[2]+    local node = match[capture_id]+    local start_row, start_col, end_row, end_col = node:range()+    local ranges = {}+    for i = 0, node:named_child_count() - 1 do+      local child = node:named_child(i)+      local child_start_row, child_start_col, child_end_row, child_end_col = child:range()+      if child_start_row > start_row or child_start_col > start_col then+        table.insert(ranges, {+          start_row,+          start_col,+          child_start_row,+          child_start_col,+        })+      end+      start_row = child_end_row+      start_col = child_end_col+    end+    if end_row > start_row or end_col > start_col then+      table.insert(ranges, { start_row, start_col, end_row, end_col })+    end+    metadata.content = ranges","Populating `metadata.content` with random data is something we want to steer away from. I tried to tidy this somewhat with `offset` which treats `metdata` as an `arrayrecord`, where the array part is a map `capture_id -> table`. Ideally we should aim to define the set of metadata fields a directive can populate, then all our ts-stdlib functions can use that data reliably.How does this directive work? It just appears to be collecting the ranges of children for a specific capture.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21657,1062494980,2023-01-05T13:51:24Z,runtime/lua/vim/treesitter/query.lua,"@@ -414,6 +414,30 @@ local directive_handlers = {       metadata[capture_id].range = range     end   end,+  ['exclude_children!'] = function(match, _, _, pred, metadata)+    local capture_id = pred[2]+    local node = match[capture_id]+    local start_row, start_col, end_row, end_col = node:range()+    local ranges = {}+    for i = 0, node:named_child_count() - 1 do+      local child = node:named_child(i)+      local child_start_row, child_start_col, child_end_row, child_end_col = child:range()+      if child_start_row > start_row or child_start_col > start_col then+        table.insert(ranges, {+          start_row,+          start_col,+          child_start_row,+          child_start_col,+        })+      end+      start_row = child_end_row+      start_col = child_end_col+    end+    if end_row > start_row or end_col > start_col then+      table.insert(ranges, { start_row, start_col, end_row, end_col })+    end+    metadata.content = ranges","Hmm, right ok. If we're just upstreaming code then I don't want to block it on the reasons I've said.If we can somehow add a couple of tests and better document this internally (not publicly in the docs), then that'll make it much easier to re-implement later when we try to further standardize the metadata format.With that said, we do have a rough TS policy that we only upstream what we use. Is that right @clason?",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21657,1062528488,2023-01-05T14:24:18Z,runtime/lua/vim/treesitter/query.lua,"@@ -414,6 +414,30 @@ local directive_handlers = {       metadata[capture_id].range = range     end   end,+  ['exclude_children!'] = function(match, _, _, pred, metadata)+    local capture_id = pred[2]+    local node = match[capture_id]+    local start_row, start_col, end_row, end_col = node:range()+    local ranges = {}+    for i = 0, node:named_child_count() - 1 do+      local child = node:named_child(i)+      local child_start_row, child_start_col, child_end_row, child_end_col = child:range()+      if child_start_row > start_row or child_start_col > start_col then+        table.insert(ranges, {+          start_row,+          start_col,+          child_start_row,+          child_start_col,+        })+      end+      start_row = child_end_row+      start_col = child_end_col+    end+    if end_row > start_row or end_col > start_col then+      table.insert(ranges, { start_row, start_col, end_row, end_col })+    end+    metadata.content = ranges","> With that said, we do have a rough TS policy that we only upstream what we useYep, part of the motivation for opening this up is to get the discussion going how & which directives should be upstreamed. And also figure out how people are supposed to deal with directives that are not in core.  I currently have nvim-treesitter as optional dependency and if I add this directive in my own config and then `:packadd` nvim-treesitter it fails because the directive already exists. I cloud work around that by using a custom directive with a different name in my query, but that doesn't seem ideal either.  Not sure what the intentions are how different plugins are supposed to use them.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21527,1062622698,2023-01-05T15:48:35Z,runtime/doc/news.txt,"@@ -103,11 +103,15 @@ The following new APIs or features were added.    See https://github.com/neovim/neovim/pull/14537. +��� |vim.diagnostic.is_disabled()| check diagnostic disabled in given buffer or+  current buffer.","Thus far we've been adding new items to the `news` entries on top of each respective list, so that the list is read in reverse-chronological order. That may change in the future, but for now please move this item to the top of the ""New Features"" list.```suggestion��� |vim.diagnostic.is_disabled()| checks if diagnostics are disabled in a given  buffer or namespace.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21662,1062877765,2023-01-05T20:41:02Z,runtime/pack/dist/opt/cfilter/plugin/cfilter.lua,"@@ -0,0 +1,138 @@+----------------------------------------+-- This file is generated via github.com/tjdevries/vim9jit+-- For any bugs, please first consider reporting there.+----------------------------------------++-- Ignore ""value assigned to a local variable is unused"" because+--  we can't guarantee that local variables will be used by plugins+-- luacheck: ignore 311++local vim9 = require('_vim9script')+local M = {}+local Qf_filter = nil+-- vim9script++-- # cfilter.vim: Plugin to filter entries from a quickfix/location list+-- # Last Change: Jun 30, 2022+-- # Maintainer: Yegappan Lakshmanan (yegappan AT yahoo DOT com)+-- # Version: 2.0+-- #+-- # Commands to filter the quickfix list:+-- #   :Cfilter[!] /{pat}/+-- #       Create a new quickfix list from entries matching {pat} in the current+-- #       quickfix list. Both the file name and the text of the entries are+-- #       matched against {pat}. If ! is supplied, then entries not matching+-- #       {pat} are used. The pattern can be optionally enclosed using one of+-- #       the following characters: ', "", /. If the pattern is empty, then the+-- #       last used search pattern is used.+-- #   :Lfilter[!] /{pat}/+-- #       Same as :Cfilter but operates on the current location list.+-- #++Qf_filter = function(qf, searchpat, bang)+  qf = vim9.bool(qf)+  local Xgetlist = function() end+  local Xsetlist = function() end+  local cmd = ''+  local firstchar = ''+  local lastchar = ''+  local pat = ''+  local title = ''+  local Cond = function() end+  local items = {}++  if vim9.bool(qf) then+    Xgetlist = function(...)+      return vim.fn['getqflist'](...)+    end+    Xsetlist = function(...)+      return vim.fn['setqflist'](...)+    end+    cmd = ':Cfilter' .. bang+  else+    Xgetlist = function(...)+      local copied = vim.deepcopy({ 0 })+      for _, val in ipairs({ ... }) do+        table.insert(copied, val)+      end++      local funcref = 'getloclist'+      if type(funcref) == 'function' then+        return funcref(unpack(copied))+      elseif type(funcref) == 'string' then+        return vim.fn[funcref](unpack(copied))+      else+        error(string.format('unable to call funcref: %s', funcref))+      end+    end++    Xsetlist = function(...)+      local copied = vim.deepcopy({ 0 })+      for _, val in ipairs({ ... }) do+        table.insert(copied, val)+      end++      local funcref = 'setloclist'+      if type(funcref) == 'function' then+        return funcref(unpack(copied))+      elseif type(funcref) == 'string' then+        return vim.fn[funcref](unpack(copied))",can this pattern be encapsulated in _vim9script.lua or it must be inlined?,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/21649,1063529122,2023-01-06T15:23:42Z,runtime/doc/editorconfig.txt,"@@ -13,16 +13,18 @@ the opened file are applied.  For more information on EditorConfig, see https://editorconfig.org/. -                                                       *g:editorconfig_enable*-EditorConfig integration can be disabled by adding >lua+                                               *g:editorconfig* *b:editorconfig*+EditorConfig integration can be disabled globally by adding >lua -    vim.g.editorconfig_enable = false+    vim.g.editorconfig = false <-to the user's |init.lua| file (or the Vimscript equivalent to |init.vim|).+to the user's |init.lua| file (or the Vimscript equivalent to |init.vim|). It+can also be disabled per-buffer by setting the |b:editorconfig| buffer-local+variable to `false` or 0. -                                                              *b:editorconfig* When Nvim finds a valid .editorconfig file it will store the applied-properties in the buffer variable |b:editorconfig|.+properties in the buffer variable |b:editorconfig| if it was not already set to+`false` or 0 by the user.",">For establishing a convention, I think we should wait until there is a clear need for this.This convention is already well established though. `0` is false in Vimscript, and plenty of people still use `init.vim` for configuration and will write:```vimlet g:editorconfig = 0```If we don't check for zero then this will not disable editorconfig, which is surprising and (arguably) a bug, since semantically that expression is ""set `g:editorconfig` to false"".",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21649,1063761062,2023-01-06T20:19:22Z,runtime/doc/editorconfig.txt,"@@ -13,16 +13,18 @@ the opened file are applied.  For more information on EditorConfig, see https://editorconfig.org/. -                                                       *g:editorconfig_enable*-EditorConfig integration can be disabled by adding >lua+                                               *g:editorconfig* *b:editorconfig*+EditorConfig integration can be disabled globally by adding >lua -    vim.g.editorconfig_enable = false+    vim.g.editorconfig = false <-to the user's |init.lua| file (or the Vimscript equivalent to |init.vim|).+to the user's |init.lua| file (or the Vimscript equivalent to |init.vim|). It+can also be disabled per-buffer by setting the |b:editorconfig| buffer-local+variable to `false` or 0. -                                                              *b:editorconfig* When Nvim finds a valid .editorconfig file it will store the applied-properties in the buffer variable |b:editorconfig|.+properties in the buffer variable |b:editorconfig| if it was not already set to+`false` or 0 by the user.","we are establishing a new convention. people will paste into init.vim whatever we document, thus if we document:    let g:editorconfig = v:falsethen that's what will appear in init.vim files. Everywhere in the API we already require `v:false`, we don't do the ""falsy"" dance. Avoiding the ""falsy"" stuff avoids a lifetime of boilerplate and extra explanation in docs. Also, requiring `v:false` initially here, leaves the door open for changing our mind later and supporting ""falsy"". The converse is _not_ a two-way door, if we support falsy now we can't turn back.This kind of ""surface area"" stuff adds permanent debt. That's why I am insisting on it.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21663,1063937829,2023-01-07T02:11:34Z,scripts/bump_deps.lua,"@@ -1,343 +1,446 @@+#!/usr/bin/env -S nvim -l+ -- Usage:---    # bump to version---    nvim -es +""lua require('scripts.bump_deps').version(dependency, version_tag)""------    # bump to commit---    nvim -es +""lua require('scripts.bump_deps').commit(dependency, commit_hash)""------    # bump to HEAD---    nvim -es +""lua require('scripts.bump_deps').head(dependency)""------    # submit PR---    nvim -es +""lua require('scripts.bump_deps').submit_pr()""------    # create branch---    nvim -es +""lua require('scripts.bump_deps').create_branch()""+--    ./scripts/bump_deps.lua -h  local M = {}  local _trace = false-local required_branch_prefix = ""bump-""-local commit_prefix = ""build(deps): ""+local required_branch_prefix = 'bump-'+local commit_prefix = 'build(deps): '  -- Print message local function p(s)-	vim.cmd(""set verbose=1"")-	vim.api.nvim_echo({ { s, """" } }, false, {})-	vim.cmd(""set verbose=0"")+  vim.cmd('set verbose=1')+  vim.api.nvim_echo({ { s, '' } }, false, {})+  vim.cmd('set verbose=0') end  local function die()-	p("""")-	vim.cmd(""cquit 1"")+  p('')+  vim.cmd('cquit 1') end  -- Executes and returns the output of `cmd`, or nil on failure. -- if die_on_fail is true, process dies with die_msg on failure -- -- Prints `cmd` if `trace` is enabled. local function _run(cmd, die_on_fail, die_msg)-	if _trace then-		p(""run: "" .. vim.inspect(cmd))-	end-	local rv = vim.trim(vim.fn.system(cmd)) or """"-	if vim.v.shell_error ~= 0 then-		if die_on_fail then-			if _trace then-				p(rv)-			end-			p(die_msg)-			die()-		end-		return nil-	end-	return rv+  if _trace then+    p('run: ' .. vim.inspect(cmd))+  end+  local rv = vim.trim(vim.fn.system(cmd)) or ''+  if vim.v.shell_error ~= 0 then+    if die_on_fail then+      if _trace then+        p(rv)+      end+      p(die_msg)+      die()+    end+    return nil+  end+  return rv end  -- Run a command, return nil on failure local function run(cmd)-	return _run(cmd, false, """")+  return _run(cmd, false, '') end  -- Run a command, die on failure with err_msg local function run_die(cmd, err_msg)-	return _run(cmd, true, err_msg)+  return _run(cmd, true, err_msg) end  local function require_executable(cmd)-	local cmd_path = run_die({ ""command"", ""-v"", cmd }, cmd .. "" not found!"")-	run_die({ ""test"", ""-x"", cmd_path }, cmd .. "" is not executable"")+  local cmd_path = run_die({ 'command', '-v', cmd }, cmd .. ' not found!')+  run_die({ 'test', '-x', cmd_path }, cmd .. ' is not executable') end  local function rm_file_if_present(path_to_file)-	run({ ""rm"", ""-f"", path_to_file })+  run({ 'rm', '-f', path_to_file }) end  local nvim_src_dir = vim.fn.getcwd()-local temp_dir = nvim_src_dir .. ""/tmp""-run({ ""mkdir"", ""-p"", temp_dir })+local temp_dir = nvim_src_dir .. '/tmp'+run({ 'mkdir', '-p', temp_dir })  local function get_dependency(dependency_name)-	local dependency_table = {-		[""LuaJIT""] = {-			repo = ""LuaJIT/LuaJIT"",-			symbol = ""LUAJIT"",-		},-		[""libuv""] = {-			repo = ""libuv/libuv"",-			symbol = ""LIBUV"",-		},-		[""Luv""] = {-			repo = ""luvit/luv"",-			symbol = ""LUV"",-		},-		[""tree-sitter""] = {-			repo = ""tree-sitter/tree-sitter"",-			symbol = ""TREESITTER"",-		},-	}-	local dependency = dependency_table[dependency_name]-	if dependency == nil then-		p(""Not a dependency: "" .. dependency_name)-		die()-	end-	dependency.name = dependency_name-	return dependency+  local dependency_table = {+    ['LuaJIT'] = {+      repo = 'LuaJIT/LuaJIT',+      symbol = 'LUAJIT',+    },+    ['libuv'] = {+      repo = 'libuv/libuv',+      symbol = 'LIBUV',+    },+    ['Luv'] = {+      repo = 'luvit/luv',+      symbol = 'LUV',+    },+    ['tree-sitter'] = {+      repo = 'tree-sitter/tree-sitter',+      symbol = 'TREESITTER',+    },+  }+  local dependency = dependency_table[dependency_name]+  if dependency == nil then+    p('Not a dependency: ' .. dependency_name)+    die()+  end+  dependency.name = dependency_name+  return dependency end  local function get_gh_commit_sha(repo, ref)-	require_executable(""gh"")+  require_executable('gh') -	local sha = run_die(-		{ ""gh"", ""api"", ""repos/"" .. repo .. ""/commits/"" .. ref, ""--jq"", "".sha"" },-		""Failed to get commit hash from GitHub. Not a valid ref?""-	)-	return sha+  local sha = run_die(+    { 'gh', 'api', 'repos/' .. repo .. '/commits/' .. ref, '--jq', '.sha' },+    'Failed to get commit hash from GitHub. Not a valid ref?'+  )+  return sha end  local function get_archive_info(repo, ref)-	require_executable(""curl"")--	local archive_name = ref .. "".tar.gz""-	local archive_path = temp_dir .. ""/"" .. archive_name-	local archive_url = ""https://github.com/"" .. repo .. ""/archive/"" .. archive_name--	rm_file_if_present(archive_path)-	run_die({ ""curl"", ""-sL"", archive_url, ""-o"", archive_path }, ""Failed to download archive from GitHub"")--	local archive_sha = run({ ""sha256sum"", archive_path }):gmatch(""%w+"")()-	return { url = archive_url, sha = archive_sha }+  require_executable('curl')++  local archive_name = ref .. '.tar.gz'+  local archive_path = temp_dir .. '/' .. archive_name+  local archive_url = 'https://github.com/' .. repo .. '/archive/' .. archive_name++  rm_file_if_present(archive_path)+  run_die(+    { 'curl', '-sL', archive_url, '-o', archive_path },+    'Failed to download archive from GitHub'+  )++  local shacmd = (vim.fn.executable('sha256sum') == 1+    and{ 'sha256sum', archive_path }+    or { 'shasum', '-a', '256', archive_path })+  local archive_sha = run(shacmd):gmatch('%w+')()+  return { url = archive_url, sha = archive_sha } end  local function write_cmakelists_line(symbol, kind, value)-	require_executable(""sed"")--	local cmakelists_path = nvim_src_dir .. ""/"" .. ""cmake.deps/CMakeLists.txt""-	run_die({-		""sed"",-		""-i"",-		""-e"",-		""s/set("" .. symbol .. ""_"" .. kind .. "".*$"" .. ""/set("" .. symbol .. ""_"" .. kind .. "" "" .. value .. "")"" .. ""/"",-		cmakelists_path,-	}, ""Failed to write "" .. cmakelists_path)+  require_executable('sed')++  local cmakelists_path = nvim_src_dir .. '/' .. 'cmake.deps/CMakeLists.txt'+  run_die({+    'sed',+    '-i',+    '-e',+    's/set('+      .. symbol+      .. '_'+      .. kind+      .. '.*$'+      .. '/set('+      .. symbol+      .. '_'+      .. kind+      .. ' '+      .. value+      .. ')'+      .. '/',+    cmakelists_path,+  }, 'Failed to write ' .. cmakelists_path) end  local function explicit_create_branch(dep)-	require_executable(""git"")--	local checked_out_branch = run({ ""git"", ""rev-parse"", ""--abbrev-ref"", ""HEAD"" })-	if checked_out_branch ~= ""master"" then-		p(""Not on master!"")-		die()-	end-	run_die({ ""git"", ""checkout"", ""-b"", ""bump-"" .. dep }, ""git failed to create branch"")+  require_executable('git')++  local checked_out_branch = run({ 'git', 'rev-parse', '--abbrev-ref', 'HEAD' })+  if checked_out_branch ~= 'master' then+    p('Not on master!')+    die()+  end+  run_die({ 'git', 'checkout', '-b', 'bump-' .. dep }, 'git failed to create branch') end  local function verify_branch(new_branch_suffix)-	require_executable(""git"")--	local checked_out_branch = run({ ""git"", ""rev-parse"", ""--abbrev-ref"", ""HEAD"" })-	if not checked_out_branch:match(""^"" .. required_branch_prefix) then-		p(""Current branch '"" .. checked_out_branch .. ""' doesn't seem to start with "" .. required_branch_prefix)-		p(""Checking out to bump-"" .. new_branch_suffix)-		explicit_create_branch(new_branch_suffix)-	end+  require_executable('git')++  local checked_out_branch = assert(run({ 'git', 'rev-parse', '--abbrev-ref', 'HEAD' }))+  if not checked_out_branch:match('^' .. required_branch_prefix) then+    p(+      ""Current branch '""+        .. checked_out_branch+        .. ""' doesn't seem to start with ""+        .. required_branch_prefix+    )+    p('Checking out to bump-' .. new_branch_suffix)+    explicit_create_branch(new_branch_suffix)+  end end  local function update_cmakelists(dependency, archive, comment)-	require_executable(""git"")--	verify_branch(dependency.name)--	local changed_file = nvim_src_dir .. ""/"" .. ""cmake.deps/CMakeLists.txt""--	p(""Updating "" .. dependency.name .. "" to "" .. archive.url .. ""\n"")-	write_cmakelists_line(dependency.symbol, ""URL"", archive.url:gsub(""/"", ""\\/""))-	write_cmakelists_line(dependency.symbol, ""SHA256"", archive.sha)-	run_die(-		{ ""git"", ""commit"", changed_file, ""-m"", commit_prefix .. ""bump "" .. dependency.name .. "" to "" .. comment },-		""git failed to commit""-	)+  require_executable('git')++  verify_branch(dependency.name)++  local changed_file = nvim_src_dir .. '/' .. 'cmake.deps/CMakeLists.txt'++  p('Updating ' .. dependency.name .. ' to ' .. archive.url .. '\n')+  write_cmakelists_line(dependency.symbol, 'URL', archive.url:gsub('/', '\\/'))+  write_cmakelists_line(dependency.symbol, 'SHA256', archive.sha)+  run_die(+    {+      'git',+      'commit',+      changed_file,+      '-m',+      commit_prefix .. 'bump ' .. dependency.name .. ' to ' .. comment,+    },+    'git failed to commit'+  ) end  local function verify_cmakelists_committed()-	require_executable(""git"")+  require_executable('git') -	local cmakelists_path = nvim_src_dir .. ""/"" .. ""cmake.deps/CMakeLists.txt""-	run_die({ ""git"", ""diff"", ""--quiet"", ""HEAD"", ""--"", cmakelists_path }, cmakelists_path .. "" has uncommitted changes"")+  local cmakelists_path = nvim_src_dir .. '/' .. 'cmake.deps/CMakeLists.txt'+  run_die(+    { 'git', 'diff', '--quiet', 'HEAD', '--', cmakelists_path },+    cmakelists_path .. ' has uncommitted changes'+  ) end  local function warn_luv_symbol()-	p(""warning: "" .. get_dependency(""Luv"").symbol .. ""_VERSION will not be updated"")+  p('warning: ' .. get_dependency('Luv').symbol .. '_VERSION will not be updated') end  -- return first 9 chars of commit local function short_commit(commit)-	return string.sub(commit, 1, 9)+  return string.sub(commit, 1, 9) end  -- TODO: remove hardcoded fork local function gh_pr(pr_title, pr_body)-	require_executable(""gh"")--	local pr_url = run_die({-		""gh"",-		""pr"",-		""create"",-		""--title"",-		pr_title,-		""--body"",-		pr_body,-	}, ""Failed to create PR"")-	return pr_url+  require_executable('gh')++  local pr_url = run_die({+    'gh',+    'pr',+    'create',+    '--title',+    pr_title,+    '--body',+    pr_body,+  }, 'Failed to create PR')+  return pr_url end  local function find_git_remote(fork)-	require_executable(""git"")--	local remotes = run({ ""git"", ""remote"", ""-v"" })-	local git_remote = """"-	for remote in remotes:gmatch(""[^\r\n]+"") do-		local words = {}-		for word in remote:gmatch(""%w+"") do-			table.insert(words, word)-		end-		local match = words[1]:match(""/github.com[:/]neovim/neovim/"")-		if fork == ""fork"" then-			match = not match-		end-		if match and words[3] == ""(fetch)"" then-			git_remote = words[0]-			break-		end-	end-	if git_remote == """" then-		git_remote = ""origin""-	end-	return git_remote+  require_executable('git')++  local remotes = assert(run({ 'git', 'remote', '-v' }))+  local git_remote = ''+  for remote in remotes:gmatch('[^\r\n]+') do+    local words = {}+    for word in remote:gmatch('%w+') do+      table.insert(words, word)+    end+    local match = words[1]:match('/github.com[:/]neovim/neovim/')+    if fork == 'fork' then+      match = not match+    end+    if match and words[3] == '(fetch)' then+      git_remote = words[0]+      break+    end+  end+  if git_remote == '' then+    git_remote = 'origin'+  end+  return git_remote end  local function create_pr(pr_title, pr_body)-	require_executable(""git"")--	local push_first = true--	local checked_out_branch = run({ ""git"", ""rev-parse"", ""--abbrev-ref"", ""HEAD"" })-	if push_first then-		local push_remote = run({ ""git"", ""config"", ""--get"", ""branch."" .. checked_out_branch .. "".pushRemote"" })-		if push_remote == nil then-			push_remote = run({ ""git"", ""config"", ""--get"", ""remote.pushDefault"" })-			if push_remote == nil then-				push_remote = run({ ""git"", ""config"", ""--get"", ""branch."" .. checked_out_branch .. "".remote"" })-				if push_remote == nil or push_remote == find_git_remote(nil) then-					push_remote = find_git_remote(""fork"")-				end-			end-		end--		p(""Pushing to "" .. push_remote .. ""/"" .. checked_out_branch)-		run_die({ ""git"", ""push"", push_remote, checked_out_branch }, ""Git failed to push"")-	end--	local pr_url = gh_pr(pr_title, pr_body)-	p(""\nCreated PR: "" .. pr_url .. ""\n"")+  require_executable('git')++  local push_first = true++  local checked_out_branch = run({ 'git', 'rev-parse', '--abbrev-ref', 'HEAD' })+  if push_first then+    local push_remote =+      run({ 'git', 'config', '--get', 'branch.' .. checked_out_branch .. '.pushRemote' })+    if push_remote == nil then+      push_remote = run({ 'git', 'config', '--get', 'remote.pushDefault' })+      if push_remote == nil then+        push_remote =+          run({ 'git', 'config', '--get', 'branch.' .. checked_out_branch .. '.remote' })+        if push_remote == nil or push_remote == find_git_remote(nil) then+          push_remote = find_git_remote('fork')+        end+      end+    end++    p('Pushing to ' .. push_remote .. '/' .. checked_out_branch)+    run_die({ 'git', 'push', push_remote, checked_out_branch }, 'Git failed to push')+  end++  local pr_url = gh_pr(pr_title, pr_body)+  p('\nCreated PR: ' .. pr_url .. '\n') end  function M.commit(dependency_name, commit)-	local dependency = get_dependency(dependency_name)-	verify_cmakelists_committed()-	local commit_sha = get_gh_commit_sha(dependency.repo, commit)-	if commit_sha ~= commit then-		p(""Not a commit: "" .. commit .. "". Did you mean version?"")-		die()-	end-	local archive = get_archive_info(dependency.repo, commit)-	if dependency_name == ""Luv"" then-		warn_luv_symbol()-	end-	update_cmakelists(dependency, archive, short_commit(commit))+  local dependency = assert(get_dependency(dependency_name))+  verify_cmakelists_committed()+  local commit_sha = get_gh_commit_sha(dependency.repo, commit)+  if commit_sha ~= commit then+    p('Not a commit: ' .. commit .. '. Did you mean version?')+    die()+  end+  local archive = get_archive_info(dependency.repo, commit)+  if dependency_name == 'Luv' then+    warn_luv_symbol()+  end+  update_cmakelists(dependency, archive, short_commit(commit)) end  function M.version(dependency_name, version)-	local dependency = get_dependency(dependency_name)-	verify_cmakelists_committed()-	local commit_sha = get_gh_commit_sha(dependency.repo, version)-	if commit_sha == version then-		p(""Not a version: "" .. version .. "". Did you mean commit?"")-		die()-	end-	local archive = get_archive_info(dependency.repo, version)-	if dependency_name == ""Luv"" then-		write_cmakelists_line(dependency.symbol, ""VERSION"", version)-	end-	update_cmakelists(dependency, archive, version)+  vim.validate{+    dependency_name={dependency_name,'s'},+    version={version,'s'},+  }+  local dependency = assert(get_dependency(dependency_name))+  verify_cmakelists_committed()+  local commit_sha = get_gh_commit_sha(dependency.repo, version)+  if commit_sha == version then+    p('Not a version: ' .. version .. '. Did you mean commit?')+    die()+  end+  local archive = get_archive_info(dependency.repo, version)+  if dependency_name == 'Luv' then+    write_cmakelists_line(dependency.symbol, 'VERSION', version)+  end+  update_cmakelists(dependency, archive, version) end  function M.head(dependency_name)-	local dependency = get_dependency(dependency_name)-	verify_cmakelists_committed()-	local commit_sha = get_gh_commit_sha(dependency.repo, ""HEAD"")-	local archive = get_archive_info(dependency.repo, commit_sha)-	if dependency_name == ""Luv"" then-		warn_luv_symbol()-	end-	update_cmakelists(dependency, archive, ""HEAD - "" .. short_commit(commit_sha))+  local dependency = assert(get_dependency(dependency_name))+  verify_cmakelists_committed()+  local commit_sha = get_gh_commit_sha(dependency.repo, 'HEAD')+  local archive = get_archive_info(dependency.repo, commit_sha)+  if dependency_name == 'Luv' then+    warn_luv_symbol()+  end+  update_cmakelists(dependency, archive, 'HEAD - ' .. short_commit(commit_sha)) end  function M.create_branch(dep)-	explicit_create_branch(dep)+  explicit_create_branch(dep) end  function M.submit_pr()-	require_executable(""git"")--	verify_branch(""deps"")--	local nvim_remote = find_git_remote(nil)-	local relevant_commit = run_die({-		""git"",-		""log"",-		""--grep="" .. commit_prefix,-		""--reverse"",-		""--format='%s'"",-		nvim_remote .. ""/master..HEAD"",-		""-1"",-	}, ""Failed to fetch commits"")--	local pr_title-	local pr_body--	if relevant_commit == """" then-		pr_title = commit_prefix .. ""bump some dependencies""-		pr_body = ""bump some dependencies""-	else-		relevant_commit = relevant_commit:gsub(""'"", """")-		pr_title = relevant_commit-		pr_body = relevant_commit:gsub(commit_prefix:gsub(""%("", ""%%(""):gsub(""%)"", ""%%)""), """")-	end-	pr_body = pr_body .. ""\n\n(add explanations if needed)""-	p(pr_title .. ""\n"" .. pr_body .. ""\n"")-	create_pr(pr_title, pr_body)+  require_executable('git')++  verify_branch('deps')++  local nvim_remote = find_git_remote(nil)+  local relevant_commit = assert(run_die({+    'git',+    'log',+    '--grep=' .. commit_prefix,+    '--reverse',+    ""--format='%s'"",+    nvim_remote .. '/master..HEAD',+    '-1',+  }, 'Failed to fetch commits'))++  local pr_title+  local pr_body++  if relevant_commit == '' then+    pr_title = commit_prefix .. 'bump some dependencies'+    pr_body = 'bump some dependencies'+  else+    relevant_commit = relevant_commit:gsub(""'"", '')+    pr_title = relevant_commit+    pr_body = relevant_commit:gsub(commit_prefix:gsub('%(', '%%('):gsub('%)', '%%)'), '')+  end+  pr_body = pr_body .. '\n\n(add explanations if needed)'+  p(pr_title .. '\n' .. pr_body .. '\n')+  create_pr(pr_title, pr_body)+end++local function usage()+  local this_script = _G.arg[0]:match(""[^/]*.lua$"")+  print(([=[+    Bump Nvim dependencies++    Usage:  nvim -l %s [options]+        Bump to HEAD, tagged version, commit, or branch:+            nvim -l %s --dep Luv --head+            nvim -l %s --dep Luv --version 1.43.0-0+            nvim -l %s --dep Luv --commit abc123+            nvim -l %s --dep Luv --branch+        Create a PR:+            nvim -l %s --pr++    Options:+        -h                    show this message and exit.+        --pr                  submit pr for bumping deps.+        --branch <dep>        create a branch bump-<dep> from current branch.+        --dep <dependency>    bump to a specific release or tag.++    Dependency Options:+        --version <tag>       bump to a specific release or tag.+        --commit <hash>       bump to a specific commit.+        --HEAD                bump to a current head.++        <dependency> is one of:+        ""LuaJIT"", ""libuv"", ""Luv"", ""tree-sitter""+  ]=]):format(this_script, this_script, this_script, this_script, this_script, this_script))+end++local function parseargs()+  local args = {}+  for i = 1, #_G.arg do+    if _G.arg[i] == '-h' then+      args.h = true+    elseif _G.arg[i] == '--pr' then+      args.pr = true+    elseif _G.arg[i] == '--branch' then+      args.branch = _G.arg[i+1]+    elseif _G.arg[i] == '--dep' then+      args.dep = _G.arg[i+1]+    elseif _G.arg[i] == '--version' then+      args.version = _G.arg[i+1]+    elseif _G.arg[i] == '--commit' then+      args.commit = _G.arg[i+1]+    elseif _G.arg[i] == '--head' then+      args.head = true+    end+  end+  return args end -return M+local is_main = _G.arg[0]:match('bump_deps.lua')","This is not too bad but not 100% reliable. Might still want some sort of `vim.is_main()` (?) thing that scripts can use to decide whether to run like a script or like a module. Similar to python `__name__ == ""__main__""` pattern.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21677,1064194424,2023-01-08T19:57:44Z,runtime/lua/vim/_editor.lua,"@@ -871,8 +871,8 @@ function vim._init_default_mappings()   map('n', '<C-L>', '<Cmd>nohlsearch<Bar>diffupdate<Bar>normal! <C-L><CR>')   map('i', '<C-U>', '<C-G>u<C-U>')   map('i', '<C-W>', '<C-G>u<C-W>')-  map('x', '*', 'y/\\V<C-R>""<CR>')-  map('x', '#', 'y?\\V<C-R>""<CR>')+  map('x', '*', [[y/\V<C-R>=escape(@"", '/\')<CR>]])+  map('x', '#', [[y?\V<C-R>=escape(@"", '?\')<CR>]])","I just noticed that these mappings are peforming a yank, wtf. ���� Instead of another half-measure, may I request that we implement a full solution, as I linked to before: https://github.com/justinmk/config/blob/6e591bad58db8200e8eeebe20982ce3d1fc09c91/.config/nvim/init.vim#L794-L816The current mappings also don't set `@/`, but they should.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21589,1065614230,2023-01-10T10:41:01Z,cmake.config/CMakeLists.txt,"@@ -5,6 +5,26 @@ include(CheckIncludeFiles) include(CheckCSourceRuns) include(CheckCSourceCompiles) +check_c_source_compiles(""","nice. is it feasible to mention in a comment at the top of cmakelists.txt, something like> these things (`check_c_source_compiles `, foo, bar, ...) should be done in the *config* phase (cmake.config/), these other things are done in ...)or is it too situation-dependent ?",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21589,1065622926,2023-01-10T10:49:38Z,src/nvim/CMakeLists.txt,"@@ -631,29 +899,37 @@ if(CLANG_ASAN_UBSAN)   if(SANITIZE_RECOVER_ALL)     if(CI_BUILD)       # Try to recover from all sanitize issues so we get reports about all failures-      set(SANITIZE_RECOVER -fsanitize-recover=all)     # Clang 3.6++      target_compile_options(nvim PRIVATE -fsanitize-recover=all) # Clang 3.6+     else()-      set(SANITIZE_RECOVER -fno-sanitize-recover=all)  # Clang 3.6++      target_compile_options(nvim PRIVATE -fno-sanitize-recover=all) # Clang 3.6+     endif()   else()     if(CI_BUILD)       # Try to recover from all sanitize issues so we get reports about all failures-      set(SANITIZE_RECOVER -fsanitize-recover)         # Clang 3.5-+      target_compile_options(nvim PRIVATE -fsanitize-recover) # Clang 3.5-","I've already removed this in https://github.com/neovim/neovim/pull/21678 as I wanted to remove code outside of this PR so they wouldn't get lost in a massive squash.It's not adding much cost but it's not adding much benefit either. This is a dev dependency/requirement, so I think we can afford to be less conservative in what we decide to remove. We can revert it if you'd like.",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/20530,1066840609,2023-01-11T10:43:43Z,test/functional/vimscript/system_spec.lua,"@@ -660,4 +660,16 @@ describe('shell :!', function()         1]])     end   end)++  it(':{range}! with powershell without redirecting to buffer', function()+    local screen = Screen.new(500, 10)+    screen:attach()+    helpers.set_shell_powershell(true)+    insert([[ NeoVim is awesome! ]])+    feed(':4verbose %w !curl --silent --show-error http://nonexisting1234.com<cr>')","> it is quite useful to be able to test powershell behaviour from non-windows machinesMakes sense.  One thing to consider, though, is that the unix version of pwsh has several weird behaviors.  I faced two myself.  One I forgot, but one can be reproduced by these steps:```pwshprintf '2\n1' > unsorted.txtStart-Process sort -RedirectStandardInput ./unsorted.txt -RedirectStandardOutput ./sorted.txtcat sorted.txt```You'll see that the newline is vanished in `sorted.txt` file.  But if you use `sort` command directly, without invoking it through `Start-Process`, you don't have this problem.I asked about this, and the other oddity I faced, on PowerShell's discord server.  Nobody gave a legitimate reason for it.  Few even cared, because it was a behavior in non-Windows machines.More to the point for this PR, though, is that for some reason (I don't have deep understanding of how the tests are carried out, so I'll have to resort to a nebulous ""some""), my test is getting stuck _after passing_, in unix machines.  It could be one of those non-Windows oddities; it could be a problem in the test suite; it could any one of a hundred things.  My reason for not wanting to test for pwsh in unix machines is simply to relieve myself from hunting down the problem, which frankly won't even be faced by the user, because 1) no unix user is using powershell and 2) this test is passing, and nvim works perfectly when I perform the steps of the test manually.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16740,1067257246,2023-01-11T17:15:05Z,src/nvim/eval/funcs.c,"@@ -10785,21 +10785,30 @@ static void f_termopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)   }    // Terminal URI: ""term://$CWD//$PID:$CMD""-  snprintf((char *)NameBuff, sizeof(NameBuff), ""term://%s//%d:%s"",-           (char *)IObuff, pid, cmd);+  buf_name_for_term(NameBuff, sizeof(NameBuff), IObuff, pid, cmd);   // at this point the buffer has no terminal instance associated yet, so unset   // the 'swapfile' option to ensure no swap file will be created   curbuf->b_p_swf = false;   (void)setfname(curbuf, NameBuff, NULL, true);-  // Save the job id and pid in b:terminal_job_{id,pid}+  // Save the job id, pid, command and cwd in b:terminal_job_{id,pid,cmd,cwd}   Error err = ERROR_INIT;   // deprecated: use 'channel' buffer option-  dict_set_var(curbuf->b_vars, cstr_as_string(""terminal_job_id""),+  dict_set_var(curbuf->b_vars, STATIC_CSTR_AS_STRING(""terminal_job_id""),",these are deprecated (see above comment). instead the 'channel' buffer-local option holds the channel-id (job-id).,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21761,1068260878,2023-01-12T15:24:14Z,src/nvim/buffer_defs.h,"@@ -1426,7 +1426,7 @@ struct statuscol {   int sign_attr[SIGN_SHOW_MAX + 1];    ///< attributes used for signs   int truncate;                        ///< truncated width   bool draw;                           ///< draw statuscolumn or not-  char fold_text[10];                  ///< text in fold column (%C)+  char fold_text[9 * 4 + 1];           ///< text in fold column (%C)","These numbers are a big magic. Why 9, 4 and 1?",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21761,1068264597,2023-01-12T15:27:03Z,src/nvim/buffer_defs.h,"@@ -1426,7 +1426,7 @@ struct statuscol {   int sign_attr[SIGN_SHOW_MAX + 1];    ///< attributes used for signs   int truncate;                        ///< truncated width   bool draw;                           ///< draw statuscolumn or not-  char fold_text[10];                  ///< text in fold column (%C)+  char fold_text[9 * 4 + 1];           ///< text in fold column (%C)",I would those as defines similar to `SIGN_SHOW_MAX`.,X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21714,1068297281,2023-01-12T15:52:59Z,src/nvim/drawline.c,"@@ -616,16 +616,14 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange,   int c_extra = NUL;                  // extra chars, all the same   int c_final = NUL;                  // final char, mandatory if set   int extra_attr = 0;                 // attributes when n_extra != 0-  static char_u *at_end_str = (char_u *)"""";  // used for p_extra when displaying-                                             // curwin->w_p_lcs_chars.eol at-                                             // end-of-line+  static char *at_end_str = """";  // used for p_extra when displaying curwin->w_p_lcs_chars.eol at end-of-line","Hmm, this line is 109 characters long. Why isn't there a lint failure?",X
131856,raboof,https://api.github.com/repos/neovim/neovim/pulls/21586,1068303688,2023-01-12T15:58:19Z,CMakeLists.txt,"@@ -257,6 +257,17 @@ endif()  message(STATUS ""Using Lua interpreter: ${LUA_PRG}"") +# Some of the code generation still relies on stable table ordering in order to+# produce reproducible output - specifically the msgpack'ed data in+# funcs_metadata.generated.h and ui_events_metadata.generated.h. This should+# ideally be fixed in the generators, but until then as a workaround you may provide+# a specific lua implementation that provides the needed stability by setting LUA_GEN_PRG:+if(NOT LUA_GEN_PRG)+  set(LUA_GEN_PRG ""${LUA_PRG}"" CACHE FILEPATH ""Path to the lua used for code generation."")","That's of course possible, but upstream deliberatly introduced the non-determinism for security reasons (https://github.com/LuaJIT/LuaJIT/issues/626#issuecomment-707005671). While I think it's acceptable as a temporary workaround to use an 'arguably-insecure' lua for the code generation (we trust the input for the code generator, after all), but we probably shouldn't encourage users to use such lua versions with 'more untrusted' data at runtime.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21768,1070485672,2023-01-15T02:42:15Z,src/nvim/drawline.c,"@@ -400,40 +400,45 @@ static int get_sign_attrs(buf_T *buf, linenr_T lnum, SignTextAttrs *sattrs, int  /// Prepare and build the 'statuscolumn' string for line ""lnum"" in window ""wp"". /// Fill ""stcp"" with the built status column string and attributes.+/// This can be called three times per win_line(), once for virt_lines, once for+/// the start of the buffer line ""lnum"" and once for the wrapped lines. /// /// @param[out] stcp  Status column attributes static void get_statuscol_str(win_T *wp, linenr_T lnum, int row, int startrow, int filler_lines,                               int cul_attr, int sign_num_attr, int sign_cul_attr, char_u *extra,",It seems that `extra` is unused in this function and `get_statuscol_display_info`,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21786,1070585019,2023-01-15T12:52:54Z,src/nvim/path.c,"@@ -210,7 +210,7 @@ int path_head_length(void) /// @return ///   - True if path begins with a path head ///   - False otherwise-bool is_path_head(const char_u *path)+bool is_path_head(const char *path) { #ifdef MSWIN   return isalpha(path[0]) && path[1] == ':';",Actually maybe better to keep this. It is similarly used in other places.,
47630334,LhKipp,https://api.github.com/repos/neovim/neovim/pulls/21818,1070587550,2023-01-15T12:55:25Z,runtime/doc/options.txt,"@@ -5203,9 +5203,8 @@ A jump table for the options with a short description can be found at |Q_op|. 	%	When included, save and restore the buffer list.  If Vim is 		started with a file name argument, the buffer list is not 		restored.  If Vim is started without a file name argument, the-		buffer list is restored from the shada file.  Quickfix -		('buftype'), unlisted ('buflisted'), unnamed and buffers on -		removable media (|shada-r|) are not saved.+		buffer list is restored from the shada file. Quickfix ('buftype'), +		unnamed and buffers on removable media (|shada-r|) are not saved.","Removed `unlisted ('buflisted')` from `shada-%`, as `nobuflisted` files are not stored in general.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21818,1070697440,2023-01-15T21:54:48Z,runtime/doc/options.txt,"@@ -5203,9 +5203,8 @@ A jump table for the options with a short description can be found at |Q_op|. 	%	When included, save and restore the buffer list.  If Vim is","_(Edit: I was confused, this was already documented.)_Testing `:set shada+=%`, it looks like it is _already_ the case that `'nobuflisted'` buffers are _not_ saved/restored (check with `:ls!`). So the change in this PR actually just fixes a bug, maybe? Anyway, let's update the doc here:```suggestion	%	Save and restore the buffer list (only 'buflisted' buffers).  If Vim is```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21818,1070698125,2023-01-15T21:59:24Z,runtime/doc/starting.txt,"@@ -920,7 +920,7 @@ The ShaDa file is used to store: - Marks for several files. - File marks, pointing to locations in files. - Last search/substitute pattern (for 'n' and '&').-- The buffer list.+- The buffer list (without |nobuflisted| buffers).","`|nobuflisted|` is not a valid tag, but anyway let's change this to:```suggestion- The buffer list (only 'buflisted' buffers).```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21818,1070699504,2023-01-15T22:08:08Z,test/functional/shada/shada_spec.lua,"@@ -262,4 +262,14 @@ describe('ShaDa support code', function()        exc_exec('wshada'))     meths.set_option('shada', '')   end)++  it('does not store unlisted buffer', function()+    local fname = funcs.getcwd() .. '/file'+    meths.set_var('__fname', fname)+    nvim_command('silent! edit `=__fname`')+    curbufmeths.set_option('buflisted', false)+    nvim_command('wshada! ' .. shada_fname)++    eq({}, find_file(fname))","to avoid false negatives (tests that pass but shouldn't), it helps to check the reverse, so e.g. after this line add a small sanity check:    -- Set 'buflisted', then check again.    curbufmeths.set_option('buflisted', true)    nvim_command('wshada! ' .. shada_fname)    eq(..., find_file(fname))",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21832,1071086255,2023-01-16T10:40:20Z,src/nvim/version.c,"@@ -63,11 +63,7 @@ static char *features[] = {   ""-acl"", #endif -#if defined(HAVE_ICONV)   ""+iconv"",",Do we need to list this at all here?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21206,1071177215,2023-01-16T12:17:52Z,scripts/gen_help_html.lua,"@@ -60,19 +60,18 @@ local exclude_invalid = {   [""'previewpopup'""] = ""quickref.txt"",   [""'pvp'""] = ""quickref.txt"",   [""'string'""] = ""eval.txt"",-  Query = ""treesitter.txt"",-  [""eq?""] = ""treesitter.txt"",-  [""lsp-request""] = ""lsp.txt"",-  matchit = ""vim_diff.txt"",-  [""matchit.txt""] = ""help.txt"",+  Query = 'treesitter.txt',+  ['eq?'] = 'treesitter.txt',+  ['lsp-request'] = 'lsp.txt',+  matchit = 'vim_diff.txt',+  ['matchit.txt'] = 'help.txt',   [""set!""] = ""treesitter.txt"",-  [""v:_null_blob""] = ""builtin.txt"",-  [""v:_null_dict""] = ""builtin.txt"",-  [""v:_null_list""] = ""builtin.txt"",-  [""v:_null_string""] = ""builtin.txt"",-  [""vim.lsp.buf_request()""] = ""lsp.txt"",-  [""vim.lsp.util.get_progress_messages()""] = ""lsp.txt"",-  [""vim.treesitter.start()""] = ""treesitter.txt"",","removed this item, no longer needed",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21768,1071278626,2023-01-16T14:00:08Z,test/functional/ui/statuscolumn_spec.lua,"@@ -183,7 +184,7 @@ describe('statuscolumn', function()   end)    it('works with wrapped lines, signs and folds', function()-    command(""set stc=%C%s%=%{v:wrap?'':v:lnum}���\\ "")+    command(""set stc=%C%s%=%{v:virtnum?'':v:lnum}���\\ "")","Since you change the command below to use long brackets, maybe change this as well:```suggestion    command([[set stc=%C%s%=%{v:virtnum?'':v:lnum}���\ ]])```",
44343049,merrittlj,https://api.github.com/repos/neovim/neovim/pulls/21842,1071591222,2023-01-16T21:37:14Z,src/nvim/statusline.c,"@@ -1325,6 +1325,7 @@ int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, char *opt_n       stl_items[curitem].type = ClickFunc;       stl_items[curitem].start = out_p;       stl_items[curitem].cmd = xmemdupz(t, (size_t)(fmt_p - t));+      xfree(stl_items[curitem].cmd);","this was just temporary, but originally I saw the memcpy in the called function and assumed it was copied elsewhere(that does explain why the tests failed)",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/21842,1071595631,2023-01-16T21:48:59Z,src/nvim/statusline.c,"@@ -1325,6 +1325,7 @@ int build_stl_str_hl(win_T *wp, char *out, size_t outlen, char *fmt, char *opt_n       stl_items[curitem].type = ClickFunc;       stl_items[curitem].start = out_p;       stl_items[curitem].cmd = xmemdupz(t, (size_t)(fmt_p - t));+      xfree(stl_items[curitem].cmd);","https://github.com/neovim/neovim/blob/1484995a1e5ab29010878fa5ee27c935fec6522f/src/nvim/statusline.c#L2128Here is the only time when `cmd` is used, it gives away the pointer to something else. You need to do basically the same thing in the `else` branch of `tabtab != NULL`, but free the memory instead:```c  } else {    for (long l = 0; l < itemcnt; l++) {      if (stl_items[l].type == ClickFunc) {        XFREE_CLEAR(stl_items[l].cmd);      }    }  }````XFREE_CLEAR` will also set `cmd` back to `NULL`, so we don't leave a dangling pointer, just in case this is used again somewhere else.",
387896,planet36,https://api.github.com/repos/neovim/neovim/pulls/21677,1071649196,2023-01-17T00:41:51Z,runtime/lua/vim/_editor.lua,"@@ -871,8 +871,8 @@ function vim._init_default_mappings()   map('n', '<C-L>', '<Cmd>nohlsearch<Bar>diffupdate<Bar>normal! <C-L><CR>')   map('i', '<C-U>', '<C-G>u<C-U>')   map('i', '<C-W>', '<C-G>u<C-W>')-  map('x', '*', 'y/\\V<C-R>""<CR>')-  map('x', '#', 'y?\\V<C-R>""<CR>')+  map('x', '*', [[y/\V<C-R>=escape(@"", '/\')<CR>]])+  map('x', '#', [[y?\V<C-R>=escape(@"", '?\')<CR>]])","> I just noticed that these mappings are peforming a yank, wtf. ����> > Instead of another half-measure, may I request that we implement a full solution, as I linked to before: https://github.com/justinmk/config/blob/6e591bad58db8200e8eeebe20982ce3d1fc09c91/.config/nvim/init.vim#L794-L816Correct me if I'm wrong, but this doesn't work when a multibyte character is the last one in a selection.  It only gets the first byte of the last character.> > The current mappings also don't set `@/`, but they should.The `/` register gets modified with the search command (right after the yank).",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/21866,1072846237,2023-01-17T21:29:40Z,src/nvim/CMakeLists.txt,"@@ -746,74 +746,81 @@ if(WIN32)       -P ${PROJECT_SOURCE_DIR}/cmake/WindowsDllCopy.cmake)   add_dependencies(nvim_runtime_deps nvim_dll_deps) +  # option(USE_BUNDLED_NVIMQT ""Bundle neovim-qt"" OFF)+  if(USE_BUNDLED_NVIMQT)","As of now, this conditional always returns false, because it's not defined anywhere.  A variable with the same name is defined in `cmake.deps/CMakeLists.txt` but that folder isn't `add_subdirectory`'d in `src/nvim/CMakeLists.txt`.I'm leaving this patch here in case someone knows how to solve this problem.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21798,1073054088,2023-01-18T03:09:55Z,src/nvim/ex_getln.c,"@@ -2688,7 +2688,7 @@ char *getcmdline_prompt(const int firstc, const char *const prompt, const int at }  // Return current cmdline prompt-char_u *get_cmdprompt(void)+char *get_cmdprompt(void)",This function is unused and can be removed.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/21878,1073240525,2023-01-18T08:42:21Z,src/nvim/statusline.c,"@@ -894,13 +894,10 @@ int build_statuscol_str(win_T *wp, linenr_T lnum, long relnum, int maxwidth, int                                fillchar, maxwidth, hlrec, &clickrec, stcp);   xfree(stc); -  // Allocate and fill click def array if width has changed-  if (wp->w_status_click_defs_size != (size_t)width) {","Only clearing should be necessary to avoid the leak I think. This is the diff that seemed correct to me but leaked anyways which is why I left it as is until I figured it out. Nice spot on the typo:```diff@@ -887,6 +887,7 @@ int build_statuscol_str(win_T *wp, linenr_T lnum, long relnum, int maxwidth, int     set_vim_var_nr(VV_LNUM, lnum);     set_vim_var_nr(VV_RELNUM, relnum);   }+  stl_clear_click_defs(wp->w_statuscol_click_defs, wp->w_statuscol_click_defs_size);   StlClickRecord *clickrec;   char *stc = xstrdup(wp->w_p_stc);@@ -895,8 +896,7 @@ int build_statuscol_str(win_T *wp, linenr_T lnum, long relnum, int maxwidth, int   xfree(stc);   // Allocate and fill click def array if width has changed-  if (wp->w_status_click_defs_size != (size_t)width) {-    stl_clear_click_defs(wp->w_statuscol_click_defs, wp->w_statuscol_click_defs_size);+  if (wp->w_statuscol_click_defs_size != (size_t)width) {     wp->w_statuscol_click_defs = stl_alloc_click_defs(wp->w_statuscol_click_defs, width,                                                       &wp->w_statuscol_click_defs_size);     stl_fill_click_defs(wp->w_statuscol_click_defs, clickrec, buf, width, false);```Refilling the click definitions for each line still feels [redundant](https://github.com/neovim/neovim/issues/21767), unless we actually start storing the click definitions for each row.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/21878,1073253421,2023-01-18T08:53:55Z,src/nvim/statusline.c,"@@ -894,13 +894,10 @@ int build_statuscol_str(win_T *wp, linenr_T lnum, long relnum, int maxwidth, int                                fillchar, maxwidth, hlrec, &clickrec, stcp);   xfree(stc); -  // Allocate and fill click def array if width has changed-  if (wp->w_status_click_defs_size != (size_t)width) {","> Refilling the click definitions for each line still feels https://github.com/neovim/neovim/issues/21767, unless we actually start storing the click definitions for each row.Although redundant, now that the typo is fixed it no longer works properly with the above diff(as expected but worked until now due to the typo). Something more similar to the pattern used in `win_redr_custom()` might be better in the meantime, i.e. clear -> alloc -> build -> fill:```diff@@ -887,6 +887,9 @@ int build_statuscol_str(win_T *wp, linenr_T lnum, long relnum, int maxwidth, int     set_vim_var_nr(VV_LNUM, lnum);     set_vim_var_nr(VV_RELNUM, relnum);   }+  stl_clear_click_defs(wp->w_statuscol_click_defs, wp->w_statuscol_click_defs_size);+  wp->w_statuscol_click_defs = stl_alloc_click_defs(wp->w_statuscol_click_defs, maxwidth,+                                                    &wp->w_statuscol_click_defs_size);   StlClickRecord *clickrec;   char *stc = xstrdup(wp->w_p_stc);@@ -894,13 +897,7 @@ int build_statuscol_str(win_T *wp, linenr_T lnum, long relnum, int maxwidth, int                                fillchar, maxwidth, hlrec, &clickrec, stcp);   xfree(stc);-  // Allocate and fill click def array if width has changed-  if (wp->w_status_click_defs_size != (size_t)width) {-    stl_clear_click_defs(wp->w_statuscol_click_defs, wp->w_statuscol_click_defs_size);-    wp->w_statuscol_click_defs = stl_alloc_click_defs(wp->w_statuscol_click_defs, width,-                                                      &wp->w_statuscol_click_defs_size);-    stl_fill_click_defs(wp->w_statuscol_click_defs, clickrec, buf, width, false);-  }+  stl_fill_click_defs(wp->w_statuscol_click_defs, clickrec, buf, maxwidth, false);   return width;```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21838,1081247000,2023-01-19T13:17:22Z,src/nvim/regexp_nfa.c,"@@ -244,10 +244,10 @@ static int nfa_classcodes[] = {   NFA_UPPER, NFA_NUPPER }; -static char_u e_nul_found[] = N_(""E865: (NFA) Regexp end encountered prematurely"");-static char_u e_misplaced[] = N_(""E866: (NFA regexp) Misplaced %c"");-static char_u e_ill_char_class[] = N_(""E877: (NFA regexp) Invalid character class: %"" PRId64);-static char_u e_value_too_large[] = N_(""E951: \\% value too large"");+static uint8_t e_nul_found[] = N_(""E865: (NFA) Regexp end encountered prematurely"");+static uint8_t e_misplaced[] = N_(""E866: (NFA regexp) Misplaced %c"");+static uint8_t e_ill_char_class[] = N_(""E877: (NFA regexp) Invalid character class: %"" PRId64);+static uint8_t e_value_too_large[] = N_(""E951: \\% value too large"");","```suggestionstatic char e_nul_found[] = N_(""E865: (NFA) Regexp end encountered prematurely"");static char e_misplaced[] = N_(""E866: (NFA regexp) Misplaced %c"");static char e_ill_char_class[] = N_(""E877: (NFA regexp) Invalid character class: %"" PRId64);static char e_value_too_large[] = N_(""E951: \\% value too large"");```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/21902,1081531614,2023-01-19T16:35:23Z,cmake.deps/CMakeLists.txt,"@@ -107,10 +107,6 @@ endif()  set(DEPS_C_COMPILER ""${CMAKE_C_COMPILER}"") -if(CMAKE_OSX_SYSROOT)-  set(DEPS_C_COMPILER ""${DEPS_C_COMPILER} -isysroot${CMAKE_OSX_SYSROOT}"")-endif()-",Nope. That breaks dependency builds.,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/21902,1082199199,2023-01-20T07:56:00Z,cmake.deps/CMakeLists.txt,"@@ -12,13 +12,13 @@ list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"" ""${PROJECT_SOURCE_DI include(CheckCCompilerFlag) include(Util) +set_default_buildtype()+ get_property(isMultiConfig GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG) if(NOT isMultiConfig)   set(BUILD_TYPE_STRING -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE})","yeah, that's why I suggested to print it inside the condition when it's multi-config",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21902,1082245347,2023-01-20T08:50:46Z,cmake.deps/CMakeLists.txt,"@@ -12,13 +12,13 @@ list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"" ""${PROJECT_SOURCE_DI include(CheckCCompilerFlag) include(Util) +set_default_buildtype()+ get_property(isMultiConfig GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG) if(NOT isMultiConfig)   set(BUILD_TYPE_STRING -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE})","Sorry, I don't get it. The condition is `if(NOT isMultiConfig)`, so it won't be printed when it's multi-config?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/21930,1083291260,2023-01-21T13:38:43Z,src/nvim/plines.c,"@@ -51,7 +51,8 @@ int plines_win(win_T *wp, linenr_T lnum, bool winheight) /// @return Number of filler lines above lnum int win_get_fill(win_T *wp, linenr_T lnum) {-  int virt_lines = decor_virt_lines(wp, lnum, NULL);+  foldinfo_T fi = fold_info(wp, lnum);",`hasFoldingWin()` with `cache` is used for diff:https://github.com/neovim/neovim/blob/0f52e2c849cbd923fc30b8bbef088b6f7642aeab/src/nvim/diff.c#L2137-L2140,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21293,1083399063,2023-01-22T06:40:38Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,486 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = { '' }++  local path_sep = '[/\\]'+  local non_path_sep = '[^/\\]'++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p .. chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = ''+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = ''+      else+        if c == '{' then+          in_braces = true+        elseif c == '}' then+          in_braces = false+        elseif c == '[' then+          in_brackets = true+        elseif c == ']' then+          in_brackets = false+        end+        segment = segment .. c+      end+    end+    if segment ~= '' then+      table.insert(segments, segment)+    end+    return segments+  end++  local function escape(c)+    if+      c == '?'+      or c == '.'+      or c == '('+      or c == ')'+      or c == '%'+      or c == '['+      or c == ']'+      or c == '*'+      or c == '+'+      or c == '-'+    then+      return '%' .. c+    end+    return c+  end++  local segments = split(pattern, '/')+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == '**' then+      local chunks = {+        path_sep .. '-',+        '.-' .. path_sep,+      }+      if last_seg then+        chunks = { '.-' }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = ''+      local in_brackets = false+      local bracket_val = ''+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= '}' and in_braces then+          brace_val = brace_val .. char+        else+          if in_brackets and (char ~= ']' or bracket_val == '') then+            local res+            if char == '-' then+              res = char+            elseif bracket_val == '' and char == '!' then+              res = '^'+            elseif char == '/' then+              res = ''+            else+              res = escape(char)+            end+            bracket_val = bracket_val .. res+          else+            if char == '{' then+              in_braces = true+            elseif char == '[' then+              in_brackets = true+            elseif char == '}' then+              local choices = split(brace_val, ',')+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = ''+            elseif char == ']' then+              append({ '[' .. bracket_val .. ']' })+              in_brackets = false+              bracket_val = ''+            elseif char == '?' then+              append({ non_path_sep })+            elseif char == '*' then+              append({ non_path_sep .. '-' })+            else+              append({ escape(char) })+            end+          end+        end+      end++      if not last_seg and (segments[i + 1] ~= '**' or i + 1 < #segments) then+        append({ path_sep })+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return bool Whether or not pattern matches s.",```suggestion---@return boolean Whether or not pattern matches s.```,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21293,1083399395,2023-01-22T06:44:39Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,486 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = { '' }++  local path_sep = '[/\\]'+  local non_path_sep = '[^/\\]'++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p .. chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = ''+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = ''+      else+        if c == '{' then+          in_braces = true+        elseif c == '}' then+          in_braces = false+        elseif c == '[' then+          in_brackets = true+        elseif c == ']' then+          in_brackets = false+        end+        segment = segment .. c+      end+    end+    if segment ~= '' then+      table.insert(segments, segment)+    end+    return segments+  end++  local function escape(c)+    if+      c == '?'+      or c == '.'+      or c == '('+      or c == ')'+      or c == '%'+      or c == '['+      or c == ']'+      or c == '*'+      or c == '+'+      or c == '-'+    then+      return '%' .. c+    end+    return c+  end++  local segments = split(pattern, '/')+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == '**' then+      local chunks = {+        path_sep .. '-',+        '.-' .. path_sep,+      }+      if last_seg then+        chunks = { '.-' }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = ''+      local in_brackets = false+      local bracket_val = ''+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= '}' and in_braces then+          brace_val = brace_val .. char+        else+          if in_brackets and (char ~= ']' or bracket_val == '') then+            local res+            if char == '-' then+              res = char+            elseif bracket_val == '' and char == '!' then+              res = '^'+            elseif char == '/' then+              res = ''+            else+              res = escape(char)+            end+            bracket_val = bracket_val .. res+          else+            if char == '{' then+              in_braces = true+            elseif char == '[' then+              in_brackets = true+            elseif char == '}' then+              local choices = split(brace_val, ',')+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = ''+            elseif char == ']' then+              append({ '[' .. bracket_val .. ']' })+              in_brackets = false+              bracket_val = ''+            elseif char == '?' then+              append({ non_path_sep })+            elseif char == '*' then+              append({ non_path_sep .. '-' })+            else+              append({ escape(char) })+            end+          end+        end+      end++      if not last_seg and (segments[i + 1] ~= '**' or i + 1 < #segments) then+        append({ path_sep })+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return bool Whether or not pattern matches s.+function M._match(pattern, s)+  if type(pattern) == 'string' then+    pattern = parse(pattern)+  end+  -- Since Lua's built-in string pattern matching does not have an alternate+  -- operator like '|', `parse` will construct one pattern for each possible+  -- alternative. Any pattern that matches thus matches the glob.+  for _, p in ipairs(pattern) do+    if s:match('^' .. p .. '$') then+      return true+    end+  end+  return false+end++local path_sep++---@private+--- Joins filepath elements by platform-specific separator.+---+---@param args ... The path elements. The first element must be absolute.+---@return string The joined path.+local function filepath_join(...)+  return table.concat({ ... }, path_sep)+end++local registrations = {}++-- Cache of libuv handles per directory, per LSP client, per registration ID.+local watched_paths = {}++local change_queue = {}+local change_cache = {}+local queue_timers = {}++-- Recursive flag for libuv watcher not implemented on linux+local recursive_watch = vim.fn.has('mac') == 1 or vim.fn.has('win32') == 1++-- kqueue requires one watch for every file+local watch_each_file = vim.fn.has('bsd') == 1++---@private+--- Creates callbacks invoked on watched file events.+---+---@param watch_path string Absolute path being watched.+---@param client_id number The LSP client's ID.+---@param reg_id string The ID used to register the request.+---@return function The callback invoked on watched file events.+local function get_callback(watch_path, client_id, reg_id)+  return function(path, type)+    local matches_filter = false+    local filters = watched_paths[watch_path].callbacks[client_id][reg_id].filters+    for _, filter in ipairs(filters) do+      if M._match(filter.pattern, path) and math.floor(filter.kind / (2 ^ (type - 1))) % 2 == 1 then+        matches_filter = true+        break+      end+    end+    if not matches_filter then+      return+    end++    local change = {+      uri = vim.uri_from_fname(path),+      type = type,+    }+    change_cache[client_id] = change_cache[client_id] or {}+    local last_type = change_cache[client_id][change.uri]+    if not last_type or last_type ~= change.type then+      change_queue[client_id] = change_queue[client_id] or {}+      table.insert(change_queue[client_id], change)+      change_cache[client_id][change.uri] = change.type+    end+    if not queue_timers[client_id] then+      queue_timers[client_id] = vim.defer_fn(function()+        vim.lsp.get_client_by_id(client_id).notify('workspace/didChangeWatchedFiles', {+          changes = change_queue[client_id],+        })+        change_queue[client_id] = nil+        change_cache[client_id] = nil+        queue_timers[client_id] = nil+      end, 100)+    end+  end+end++-- Never create watchers for directories matching these patterns. Similar+-- to vscode's files.watcherExclude setting.+local excludes = {+  parse('**/.git/objects/**'),+  parse('**/.git/subtree-cache/**'),+  parse('**/node_modules/*/**'),+  parse('**/.hg/store/**'),+}++local fsevent_ensure_recursive++---@private+--- Initializes a libuv fs_event, persistent when underlying inodes change.+---+---@param path string The path to watch.+---@return uv.fs_event The started libuv fs_event handle.",```suggestion---@return userdata uv.fs_event The started libuv fs_event handle.```,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21293,1083400727,2023-01-22T06:58:28Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,486 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = { '' }++  local path_sep = '[/\\]'+  local non_path_sep = '[^/\\]'++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p .. chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = ''+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = ''+      else+        if c == '{' then+          in_braces = true+        elseif c == '}' then+          in_braces = false+        elseif c == '[' then+          in_brackets = true+        elseif c == ']' then+          in_brackets = false+        end+        segment = segment .. c+      end+    end+    if segment ~= '' then+      table.insert(segments, segment)+    end+    return segments+  end++  local function escape(c)+    if+      c == '?'+      or c == '.'+      or c == '('+      or c == ')'+      or c == '%'+      or c == '['+      or c == ']'+      or c == '*'+      or c == '+'+      or c == '-'+    then+      return '%' .. c+    end+    return c+  end++  local segments = split(pattern, '/')+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == '**' then+      local chunks = {+        path_sep .. '-',+        '.-' .. path_sep,+      }+      if last_seg then+        chunks = { '.-' }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = ''+      local in_brackets = false+      local bracket_val = ''+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= '}' and in_braces then+          brace_val = brace_val .. char+        else+          if in_brackets and (char ~= ']' or bracket_val == '') then+            local res+            if char == '-' then+              res = char+            elseif bracket_val == '' and char == '!' then+              res = '^'+            elseif char == '/' then+              res = ''+            else+              res = escape(char)+            end+            bracket_val = bracket_val .. res+          else+            if char == '{' then+              in_braces = true+            elseif char == '[' then+              in_brackets = true+            elseif char == '}' then+              local choices = split(brace_val, ',')+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = ''+            elseif char == ']' then+              append({ '[' .. bracket_val .. ']' })+              in_brackets = false+              bracket_val = ''+            elseif char == '?' then+              append({ non_path_sep })+            elseif char == '*' then+              append({ non_path_sep .. '-' })+            else+              append({ escape(char) })+            end+          end+        end+      end++      if not last_seg and (segments[i + 1] ~= '**' or i + 1 < #segments) then+        append({ path_sep })+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return bool Whether or not pattern matches s.+function M._match(pattern, s)+  if type(pattern) == 'string' then+    pattern = parse(pattern)+  end+  -- Since Lua's built-in string pattern matching does not have an alternate+  -- operator like '|', `parse` will construct one pattern for each possible+  -- alternative. Any pattern that matches thus matches the glob.+  for _, p in ipairs(pattern) do+    if s:match('^' .. p .. '$') then+      return true+    end+  end+  return false+end++local path_sep++---@private+--- Joins filepath elements by platform-specific separator.+---+---@param args ... The path elements. The first element must be absolute.+---@return string The joined path.+local function filepath_join(...)+  return table.concat({ ... }, path_sep)+end++local registrations = {}","```suggestion---@class Watcher---@field base_dir string---@field pattern string---@field kind lsp.WatchKind---@type table<number, table<string, Watcher[]>> client id -> registration id -> watcherslocal registrations = {}```The `lsp.WatchKind` type can be added in protocol.lua like this:```diffiff --git a/runtime/lua/vim/lsp/protocol.lua b/runtime/lua/vim/lsp/protocol.luaindex 5f8f64a27..bb8f89b5c 100644--- a/runtime/lua/vim/lsp/protocol.lua+++ b/runtime/lua/vim/lsp/protocol.lua@@ -234,10 +234,11 @@ local constants = {     -- After that only incremental updates to the document are     -- send.     Incremental = 2,   },+  ---@enum lsp.WatchKind   WatchKind = {     -- Interested in create events.     Create = 1,     -- Interested in change events     Change = 2,```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/21293,1083400897,2023-01-22T07:00:28Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,486 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = { '' }++  local path_sep = '[/\\]'+  local non_path_sep = '[^/\\]'++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p .. chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = ''+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = ''+      else+        if c == '{' then+          in_braces = true+        elseif c == '}' then+          in_braces = false+        elseif c == '[' then+          in_brackets = true+        elseif c == ']' then+          in_brackets = false+        end+        segment = segment .. c+      end+    end+    if segment ~= '' then+      table.insert(segments, segment)+    end+    return segments+  end++  local function escape(c)+    if+      c == '?'+      or c == '.'+      or c == '('+      or c == ')'+      or c == '%'+      or c == '['+      or c == ']'+      or c == '*'+      or c == '+'+      or c == '-'+    then+      return '%' .. c+    end+    return c+  end++  local segments = split(pattern, '/')+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == '**' then+      local chunks = {+        path_sep .. '-',+        '.-' .. path_sep,+      }+      if last_seg then+        chunks = { '.-' }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = ''+      local in_brackets = false+      local bracket_val = ''+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= '}' and in_braces then+          brace_val = brace_val .. char+        else+          if in_brackets and (char ~= ']' or bracket_val == '') then+            local res+            if char == '-' then+              res = char+            elseif bracket_val == '' and char == '!' then+              res = '^'+            elseif char == '/' then+              res = ''+            else+              res = escape(char)+            end+            bracket_val = bracket_val .. res+          else+            if char == '{' then+              in_braces = true+            elseif char == '[' then+              in_brackets = true+            elseif char == '}' then+              local choices = split(brace_val, ',')+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = ''+            elseif char == ']' then+              append({ '[' .. bracket_val .. ']' })+              in_brackets = false+              bracket_val = ''+            elseif char == '?' then+              append({ non_path_sep })+            elseif char == '*' then+              append({ non_path_sep .. '-' })+            else+              append({ escape(char) })+            end+          end+        end+      end++      if not last_seg and (segments[i + 1] ~= '**' or i + 1 < #segments) then+        append({ path_sep })+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return bool Whether or not pattern matches s.+function M._match(pattern, s)+  if type(pattern) == 'string' then+    pattern = parse(pattern)+  end+  -- Since Lua's built-in string pattern matching does not have an alternate+  -- operator like '|', `parse` will construct one pattern for each possible+  -- alternative. Any pattern that matches thus matches the glob.+  for _, p in ipairs(pattern) do+    if s:match('^' .. p .. '$') then+      return true+    end+  end+  return false+end++local path_sep++---@private+--- Joins filepath elements by platform-specific separator.+---+---@param args ... The path elements. The first element must be absolute.+---@return string The joined path.+local function filepath_join(...)+  return table.concat({ ... }, path_sep)+end++local registrations = {}++-- Cache of libuv handles per directory, per LSP client, per registration ID.+local watched_paths = {}++local change_queue = {}+local change_cache = {}+local queue_timers = {}++-- Recursive flag for libuv watcher not implemented on linux+local recursive_watch = vim.fn.has('mac') == 1 or vim.fn.has('win32') == 1++-- kqueue requires one watch for every file+local watch_each_file = vim.fn.has('bsd') == 1++---@private+--- Creates callbacks invoked on watched file events.+---+---@param watch_path string Absolute path being watched.+---@param client_id number The LSP client's ID.+---@param reg_id string The ID used to register the request.+---@return function The callback invoked on watched file events.+local function get_callback(watch_path, client_id, reg_id)+  return function(path, type)+    local matches_filter = false+    local filters = watched_paths[watch_path].callbacks[client_id][reg_id].filters+    for _, filter in ipairs(filters) do+      if M._match(filter.pattern, path) and math.floor(filter.kind / (2 ^ (type - 1))) % 2 == 1 then+        matches_filter = true+        break+      end+    end+    if not matches_filter then+      return+    end++    local change = {+      uri = vim.uri_from_fname(path),+      type = type,+    }+    change_cache[client_id] = change_cache[client_id] or {}+    local last_type = change_cache[client_id][change.uri]+    if not last_type or last_type ~= change.type then+      change_queue[client_id] = change_queue[client_id] or {}+      table.insert(change_queue[client_id], change)+      change_cache[client_id][change.uri] = change.type+    end+    if not queue_timers[client_id] then+      queue_timers[client_id] = vim.defer_fn(function()+        vim.lsp.get_client_by_id(client_id).notify('workspace/didChangeWatchedFiles', {+          changes = change_queue[client_id],+        })+        change_queue[client_id] = nil+        change_cache[client_id] = nil+        queue_timers[client_id] = nil+      end, 100)+    end+  end+end++-- Never create watchers for directories matching these patterns. Similar+-- to vscode's files.watcherExclude setting.+local excludes = {+  parse('**/.git/objects/**'),+  parse('**/.git/subtree-cache/**'),+  parse('**/node_modules/*/**'),+  parse('**/.hg/store/**'),+}++local fsevent_ensure_recursive++---@private+--- Initializes a libuv fs_event, persistent when underlying inodes change.+---+---@param path string The path to watch.+---@return uv.fs_event The started libuv fs_event handle.+local function start_watch(path)+  local fsevent, fserr = uv.new_fs_event()+  assert(not fserr, fserr)+  fsevent:start(path, { recursive = recursive_watch }, function(err, filename, events)+    assert(not err, err)++    local fullpath = filepath_join(path, filename)++    local change_type = events.change and protocol.FileChangeType.Changed or 0+    if events.rename then+      local _, staterr, staterrname = uv.fs_stat(fullpath)+      if staterrname == 'ENOENT' then+        change_type = protocol.FileChangeType.Deleted+      else+        assert(not staterr, staterr)+        change_type = protocol.FileChangeType.Created+      end+    end++    for _, regs in pairs(watched_paths[path].callbacks) do+      for _, reg in pairs(regs) do+        reg.callback(fullpath, change_type)+      end+    end++    local stat, staterr, staterrname = uv.fs_stat(path)+    if staterrname == 'ENOENT' then+      local _, stoperr = fsevent:stop()+      assert(not stoperr, stoperr)+      fsevent:close()+      watched_paths[path] = nil+      return+    end+    assert(not staterr, staterr)+    if stat.ino ~= watched_paths[path].inode then+      watched_paths[path].inode = stat.ino+      local _, stoperr = fsevent:stop()+      assert(not stoperr, stoperr)+      fsevent:close()+      watched_paths[path].fsevent = start_watch(path)+    end++    if not recursive_watch and stat.type == 'directory' then+      for client_id, regs in pairs(registrations) do+        for reg_id, watchers in pairs(regs) do+          for _, watcher in ipairs(watchers) do+            if vim.startswith(path .. path_sep, watcher.base_dir .. path_sep) then+              fsevent_ensure_recursive(+                path,+                watcher.pattern,+                watcher.kind,+                client_id,+                reg_id,+                stat.type+              )+            end+          end+        end+      end+    end+  end)+  return fsevent+end++---@private+--- Creates libuv fs_events handles.+---+---@param path string Absolute path to watch.+---@param pattern string|table The LSP glob pattern (raw or parsed) to match against.+---@param kind number The LSP WatchKind value.+---@param client_id number The LSP client's ID.+---@param reg_id string The ID used to register the request.+function fsevent_ensure_recursive(path, pattern, kind, client_id, reg_id, filetype)+  if filetype == 'directory' or not watch_each_file or M._match(pattern, path) then+    local new_path = false+    if not watched_paths[path] then+      new_path = true++      local stat, fserr = uv.fs_stat(path)+      assert(not fserr, fserr)+      watched_paths[path] = {+        fsevent = start_watch(path),+        inode = stat.ino,+        callbacks = {},+      }+    end++    watched_paths[path].callbacks[client_id] = watched_paths[path].callbacks[client_id] or {}+    watched_paths[path].callbacks[client_id][reg_id] = watched_paths[path].callbacks[client_id][reg_id]+      or {}+    watched_paths[path].callbacks[client_id][reg_id].callback = watched_paths[path].callbacks[client_id][reg_id].callback+      or get_callback(path, client_id, reg_id)+    watched_paths[path].callbacks[client_id][reg_id].filters = watched_paths[path].callbacks[client_id][reg_id].filters+      or {}+    local filter = { pattern = pattern, kind = kind }+    local filter_exists = false+    for _, f in ipairs(watched_paths[path].callbacks[client_id][reg_id].filters) do+      if vim.deep_equal(filter, f) then+        filter_exists = true+        break+      end+    end+    if not filter_exists then+      table.insert(watched_paths[path].callbacks[client_id][reg_id].filters, filter)+    end++    if new_path then+      watched_paths[path].callbacks[client_id][reg_id].callback(+        path,+        protocol.FileChangeType.Created+      )+    end+  end++  if recursive_watch then+    return+  end++  local scan, err, errname = uv.fs_scandir(path)+  if errname == 'ENOTDIR' or errname == 'ENOENT' then+    return+  end+  assert(not err, err)+  while true do+    local ret = { uv.fs_scandir_next(scan) }+    if #ret == 0 then+      break+    end+    if #ret == 3 then+      assert(not ret[2], ret[2])+    end -- error check+    local name, type = ret[1], ret[2]+    if watch_each_file or type == 'directory' then+      local subpath = filepath_join(path, name)+      local include = true+      for _, exclude in ipairs(excludes) do+        if M._match(exclude, subpath) then+          include = false+          break+        end+      end+      if not include then+        break+      end+      fsevent_ensure_recursive(subpath, pattern, kind, client_id, reg_id, type)+    end+  end+end++local function ensure_registrations()+  for client_id, regs in pairs(registrations) do+    for reg_id, watchers in pairs(regs) do+      for _, watcher in ipairs(watchers) do+        fsevent_ensure_recursive(+          watcher.base_dir,+          watcher.pattern,+          watcher.kind,+          client_id,+          reg_id,+          'directory'+        )+      end+    end+  end+end++--- Registers the workspace/didChangeWatchedFiles capability dynamically.+---+---@param reg table LSP Registration object.+---@param ctx table Context from the |lsp-handler|.+function M.register(reg, ctx)+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  local watchers = {}+  for _, w in ipairs(reg.registerOptions.watchers) do+    local glob_patterns = {}+    if type(w.globPattern) == 'string' then+      for _, folder in ipairs(client.workspace_folders) do+        table.insert(glob_patterns, { baseUri = folder.uri, pattern = w.globPattern })+      end+    else+      table.insert(glob_patterns, w.globPattern)+    end+    for _, glob_pattern in ipairs(glob_patterns) do+      local pattern = parse(glob_pattern.pattern)+      local base_dir = nil+      if type(glob_pattern.baseUri) == 'string' then+        base_dir = glob_pattern.baseUri+      elseif type(glob_pattern.baseUri) == 'table' then+        base_dir = glob_pattern.baseUri.uri+      end+      assert(base_dir, ""couldn't identify root of watch"")+      base_dir = vim.uri_to_fname(base_dir)+      path_sep = path_sep or base_dir:match('^([a-zA-Z]:)(.*)') and '\\' or '/'+      local kind = w.kind+        or protocol.WatchKind.Create + protocol.WatchKind.Change + protocol.WatchKind.Delete++      table.insert(watchers, {+        base_dir = base_dir,+        pattern = pattern,+        kind = kind,+      })+    end+  end+  registrations[ctx.client_id] = registrations[ctx.client_id] or {}+  registrations[ctx.client_id][reg.id] = watchers+  ensure_registrations()","Could this loop over the watchers only?```suggestion  ensure_registrations()  for _, watcher in ipairs(watchers) do    fsevent_ensure_recursive(            watcher.base_dir,            watcher.pattern,            watcher.kind,            ctx.client_id,            reg.id,            'directory'          )  end```There's afaik no need here to re-process other clients/registrations",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/21926,1083855648,2023-01-23T10:06:10Z,cmake.deps/cmake/UnibiliumCMakeLists.txt,"@@ -7,16 +7,18 @@ set_target_properties(unibilium PROPERTIES PUBLIC_HEADER ${PROJECT_SOURCE_DIR}/u   VERSION ""${VERSION_MAJOR}.${VERSION_MINOR}"")  if(NOT WIN32)-  execute_process(COMMAND ""shell ncursesw6-config --terminfo-dirs 2>/dev/null || \+  execute_process(COMMAND sh -c ""ncursesw6-config --terminfo-dirs 2>/dev/null || \","It's nonsense, it's not a thing and the above doesn't work. Likely a Makefile-ism. We didn't notice this because we don't use the the cmakelists on unix. This has already been fixed upstreams in neovim/unibilium.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21866,1083864560,2023-01-23T10:14:48Z,CMakeLists.txt,"@@ -340,14 +340,20 @@ endif() # Go down the tree. # +if(EXISTS ""${DEPS_PREFIX}/share/nvim-qt"")+  option(BUNDLE_NVIMQT ""Bundle neovim-qt"" ON)",any reason not to use the existing naming pattern: https://github.com/neovim/neovim/blob/cb757f2663e6950e655c6306d713338dfa66b18d/cmake.deps/cmake/BuildLuarocks.cmake#L99,
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/21866,1083913423,2023-01-23T10:58:31Z,CMakeLists.txt,"@@ -340,14 +340,20 @@ endif() # Go down the tree. # +if(EXISTS ""${DEPS_PREFIX}/share/nvim-qt"")+  option(BUNDLE_NVIMQT ""Bundle neovim-qt"" ON)","I used that pattern initially.  Then I thought since this variable is in a different cmake project (`USE_BUNDLED_XXX` is in 'cmake.deps' project), maybe the pattern should be different.  But maybe I was thinking too much.Will change and push soon.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20288,1083982498,2023-01-23T12:13:21Z,runtime/doc/lua.txt,"@@ -1148,20 +1148,21 @@ vim.bo[{bufnr}]                                                                *         print(vim.bo.comments)         print(vim.bo.baz)                 -- error: invalid key <-vim.wo[{winid}]                                                                *vim.wo*-    Get or set window-scoped |options| for the window with handle {winid}.-    Like `:set`. If [{winid}] is omitted then the current window is used.-    Invalid {winid} or key is an error.+vim.wo[{winid}][{bufnr}]                                                       *vim.wo*","Well the main goal is to have a more ergonomic form for `setlocal winopt` which would be `vim.wo[0][0].winopt = value` in this case. This would further reduce the need for `vim.opt_local` which we should try and remove (somehow).The alternative would be something like `vim.wlo`, but I like the idea of re-using `vim.wo` and getting the extra functionality of being able to target specific buffers for free.`vim.wo[0][0].winopt` isn't super pretty, but like I said it does make it clearer how local windows options work semantically. And overall I think it's better than just saying ""doesn't work with local options"".",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/20288,1084095305,2023-01-23T14:02:29Z,runtime/doc/lua.txt,"@@ -1148,20 +1148,21 @@ vim.bo[{bufnr}]                                                                *         print(vim.bo.comments)         print(vim.bo.baz)                 -- error: invalid key <-vim.wo[{winid}]                                                                *vim.wo*-    Get or set window-scoped |options| for the window with handle {winid}.-    Like `:set`. If [{winid}] is omitted then the current window is used.-    Invalid {winid} or key is an error.+vim.wo[{winid}][{bufnr}]                                                       *vim.wo*","Another thing to consider is that we could make all window options `global-local`, which is what I think most users expect how options to work anyway. i.e. `set number` in an `init.vim` enables line numbers by default, not, enables line numbers for the current window, from which new windows will inherit.There would be a bunch of first and second order effects of doing that, but other than it being a (big) breaking change, I don't see any obvious negatives, it'll just be **a lot** of work.One specific benefit that's relevant here is that, win-buf local options then become more of an advanced edge case, whereas now (as @clason says) are unfortunately not niche.",X
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/21885,1085177573,2023-01-24T11:44:59Z,src/nvim/optionstr.c,"@@ -656,8 +1643,7 @@ char *did_set_string_option(int opt_idx, char **varp, char *oldval, char *errbuf                             int opt_flags, int *value_checked) {",I suppose you want to pass curwin/curbuf in a future PR ? what could be done if you dont want to modify `did_set_string_option` type yet (this is a big PR after all)  is to add local variables at the start of this function like `buf = curbuf` and `win = curwin`.,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/21885,1085204200,2023-01-24T12:02:31Z,src/nvim/optionstr.c,"@@ -1261,320 +1798,78 @@ char *did_set_string_option(int opt_idx, char **varp, char *oldval, char *errbuf     } #endif   } else if (varp == &curwin->w_p_scl) {  // 'signcolumn'-    if (check_signcolumn(*varp) != OK) {-      errmsg = e_invarg;-    }-    // When changing the 'signcolumn' to or from 'number', recompute the-    // width of the number column if 'number' or 'relativenumber' is set.-    if (((*oldval == 'n' && *(oldval + 1) == 'u')-         || (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) == 'u'))-        && (curwin->w_p_nu || curwin->w_p_rnu)) {-      curwin->w_nrwidth_line_count = 0;-    }+    did_set_signcolumn(curwin, varp, oldval, &errmsg);   } else if (varp == &p_sloc) {  // 'showcmdloc'-    if (check_opt_strings(p_sloc, p_sloc_values, false) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_strings(*varp, p_sloc_values, false, &errmsg);   } else if (varp == &curwin->w_p_fdc              || varp == &curwin->w_allbuf_opt.wo_fdc) {     // 'foldcolumn'-    if (**varp == NUL || check_opt_strings(*varp, p_fdc_values, false) != OK) {-      errmsg = e_invarg;-    }-  } else if (varp == &p_pt) {-    // 'pastetoggle': translate key codes like in a mapping-    if (*p_pt) {-      p = NULL;-      (void)replace_termcodes(p_pt,-                              strlen(p_pt),-                              &p, REPTERM_FROM_PART | REPTERM_DO_LT, NULL,-                              CPO_TO_CPO_FLAGS);-      if (p != NULL) {-        free_string_option(p_pt);-        p_pt = p;-      }-    }+    did_set_foldcolumn(varp, &errmsg);+  } else if (varp == &p_pt) {  // 'pastetoggle'+    did_set_pastetoggle();   } else if (varp == &p_bs) {  // 'backspace'-    if (ascii_isdigit(*p_bs)) {-      if (*p_bs > '3' || p_bs[1] != NUL) {-        errmsg = e_invarg;-      }-    } else if (check_opt_strings(p_bs, p_bs_values, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_backspace(&errmsg);   } else if (varp == &p_bo) {-    if (opt_strings_flags(p_bo, p_bo_values, &bo_flags, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_flags(p_bo, p_bo_values, &bo_flags, true, &errmsg);   } else if (gvarp == &p_tc) {  // 'tagcase'-    unsigned int *flags;--    if (opt_flags & OPT_LOCAL) {-      p = curbuf->b_p_tc;-      flags = &curbuf->b_tc_flags;-    } else {-      p = p_tc;-      flags = &tc_flags;-    }--    if ((opt_flags & OPT_LOCAL) && *p == NUL) {-      // make the local value empty: use the global value-      *flags = 0;-    } else if (*p == NUL-               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {-      errmsg = e_invarg;-    }+    did_set_tagcase(opt_flags, &errmsg);   } else if (varp == &p_cmp) {  // 'casemap'-    if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_flags(p_cmp, p_cmp_values, &cmp_flags, true, &errmsg);   } else if (varp == &p_dip) {  // 'diffopt'-    if (diffopt_changed() == FAIL) {-      errmsg = e_invarg;-    }+    did_set_diffopt(&errmsg);   } else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {  // 'foldmethod'-    if (check_opt_strings(*varp, p_fdm_values, false) != OK-        || *curwin->w_p_fdm == NUL) {-      errmsg = e_invarg;-    } else {-      foldUpdateAll(curwin);-      if (foldmethodIsDiff(curwin)) {-        newFoldLevel();-      }-    }+    did_set_foldmethod(curwin, varp, &errmsg);   } else if (gvarp == &curwin->w_allbuf_opt.wo_fmr) {  // 'foldmarker'-    p = vim_strchr(*varp, ',');-    if (p == NULL) {-      errmsg = N_(""E536: comma required"");-    } else if (p == *varp || p[1] == NUL) {-      errmsg = e_invarg;-    } else if (foldmethodIsMarker(curwin)) {-      foldUpdateAll(curwin);-    }+    did_set_foldmarker(curwin, varp, &errmsg);   } else if (gvarp == &p_cms) {  // 'commentstring'-    if (**varp != NUL && strstr(*varp, ""%s"") == NULL) {-      errmsg = N_(""E537: 'commentstring' must be empty or contain %s"");-    }+    did_set_commentstring(varp, &errmsg);   } else if (varp == &p_fdo) {  // 'foldopen'-    if (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_flags(p_fdo, p_fdo_values, &fdo_flags, true, &errmsg);   } else if (varp == &p_fcl) {  // 'foldclose'-    if (check_opt_strings(p_fcl, p_fcl_values, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_strings(*varp, p_fcl_values, true, &errmsg);   } else if (gvarp == &curwin->w_allbuf_opt.wo_fdi) {  // 'foldignore'-    if (foldmethodIsIndent(curwin)) {-      foldUpdateAll(curwin);-    }+    did_set_foldignore(curwin);   } else if (gvarp == &p_ve) {  // 'virtualedit'-    char *ve = p_ve;-    unsigned int *flags = &ve_flags;--    if (opt_flags & OPT_LOCAL) {-      ve = curwin->w_p_ve;-      flags = &curwin->w_ve_flags;-    }--    if ((opt_flags & OPT_LOCAL) && *ve == NUL) {-      // make the local value empty: use the global value-      *flags = 0;-    } else {-      if (opt_strings_flags(ve, p_ve_values, flags, true) != OK) {-        errmsg = e_invarg;-      } else if (strcmp(p_ve, oldval) != 0) {-        // Recompute cursor position in case the new 've' setting-        // changes something.-        validate_virtcol();-        coladvance(curwin->w_virtcol);-      }-    }+    did_set_virtualedit(curwin, opt_flags, oldval, &errmsg);   } else if (gvarp == &p_cino) {  // 'cinoptions'     // TODO(vim): recognize errors     parse_cino(curbuf);   } else if (gvarp == &p_lop) {  // 'lispoptions'-    if (**varp != NUL && strcmp(*varp, ""expr:0"") != 0 && strcmp(*varp, ""expr:1"") != 0) {-      errmsg = e_invarg;-    }+    did_set_listoptions(varp, &errmsg);   } else if (varp == &p_icm) {  // 'inccommand'-    if (check_opt_strings(p_icm, p_icm_values, false) != OK) {-      errmsg = e_invarg;-    }-  } else if (gvarp == &p_ft) {-    if (!valid_filetype(*varp)) {-      errmsg = e_invarg;-    } else {-      value_changed = strcmp(oldval, *varp) != 0;--      // Since we check the value, there is no need to set P_INSECURE,-      // even when the value comes from a modeline.-      *value_checked = true;-    }-  } else if (gvarp == &p_syn) {-    if (!valid_filetype(*varp)) {-      errmsg = e_invarg;-    } else {-      value_changed = strcmp(oldval, *varp) != 0;--      // Since we check the value, there is no need to set P_INSECURE,-      // even when the value comes from a modeline.-      *value_checked = true;-    }+    did_set_opt_strings(*varp, p_icm_values, false, &errmsg);+  } else if (gvarp == &p_ft || gvarp == &p_syn) {+    did_set_filetype_or_syntax(varp, oldval, value_checked, &value_changed, &errmsg);   } else if (varp == &curwin->w_p_winhl) {-    if (!parse_winhl_opt(curwin)) {-      errmsg = e_invarg;-    }+    did_set_winhl(curwin, &errmsg);   } else if (varp == &p_tpf) {-    if (opt_strings_flags(p_tpf, p_tpf_values, &tpf_flags, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_flags(p_tpf, p_tpf_values, &tpf_flags, true, &errmsg);   } else if (varp == &(curbuf->b_p_vsts)) {  // 'varsofttabstop'-    char *cp;--    if (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1])) {-      XFREE_CLEAR(curbuf->b_p_vsts_array);-    } else {-      for (cp = *varp; *cp; cp++) {-        if (ascii_isdigit(*cp)) {-          continue;-        }-        if (*cp == ',' && cp > *varp && *(cp - 1) != ',') {-          continue;-        }-        errmsg = e_invarg;-        break;-      }-      if (errmsg == NULL) {-        long *oldarray = curbuf->b_p_vsts_array;-        if (tabstop_set(*varp, &(curbuf->b_p_vsts_array))) {-          xfree(oldarray);-        } else {-          errmsg = e_invarg;-        }-      }-    }+    did_set_varsoftabstop(curbuf, varp, &errmsg);   } else if (varp == &(curbuf->b_p_vts)) {  // 'vartabstop'-    char *cp;--    if (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1])) {-      XFREE_CLEAR(curbuf->b_p_vts_array);-    } else {-      for (cp = *varp; *cp; cp++) {-        if (ascii_isdigit(*cp)) {-          continue;-        }-        if (*cp == ',' && cp > *varp && *(cp - 1) != ',') {-          continue;-        }-        errmsg = e_invarg;-        break;-      }-      if (errmsg == NULL) {-        long *oldarray = curbuf->b_p_vts_array;-        if (tabstop_set(*varp, &(curbuf->b_p_vts_array))) {-          xfree(oldarray);-          if (foldmethodIsIndent(curwin)) {-            foldUpdateAll(curwin);-          }-        } else {-          errmsg = e_invarg;-        }-      }-    }+    did_set_vartabstop(curbuf, varp, &errmsg);   } else if (varp == &p_dex              || varp == &curwin->w_p_fde              || varp == &curwin->w_p_fdt              || gvarp == &p_fex              || gvarp == &p_inex              || gvarp == &p_inde              || varp == &p_pex) {  // '*expr' options-    char **p_opt = NULL;--    // If the option value starts with <SID> or s:, then replace that with-    // the script identifier.--    if (varp == &p_dex) {  // 'diffexpr'-      p_opt = &p_dex;-    }-    if (varp == &curwin->w_p_fde) {  // 'foldexpr'-      p_opt = &curwin->w_p_fde;-    }-    if (varp == &curwin->w_p_fdt) {  // 'foldtext'-      p_opt = &curwin->w_p_fdt;-    }-    if (gvarp == &p_fex) {  // 'formatexpr'-      p_opt = &curbuf->b_p_fex;-    }-    if (gvarp == &p_inex) {  // 'includeexpr'-      p_opt = &curbuf->b_p_inex;-    }-    if (gvarp == &p_inde) {  // 'indentexpr'-      p_opt = &curbuf->b_p_inde;-    }-    if (varp == &p_pex) {  // 'patchexpr'-      p_opt = &p_pex;-    }--    if (p_opt != NULL) {-      char *name = get_scriptlocal_funcname(*p_opt);-      if (name != NULL) {-        free_string_option(*p_opt);-        *p_opt = name;-      }-    }--    if (varp == &curwin->w_p_fde && foldmethodIsExpr(curwin)) {-      foldUpdateAll(curwin);-    }+    did_set_optexpr(curbuf, curwin, varp, gvarp);   } else if (gvarp == &p_cfu) {  // 'completefunc'-    if (set_completefunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_completefunc_option(&errmsg);   } else if (gvarp == &p_ofu) {  // 'omnifunc'-    if (set_omnifunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_omnifunc_option(&errmsg);   } else if (gvarp == &p_tsrfu) {  // 'thesaurusfunc'-    if (set_thesaurusfunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_thesaurusfunc_option(&errmsg);   } else if (varp == &p_opfunc) {  // 'operatorfunc'-    if (set_operatorfunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_operatorfunc_option(&errmsg);   } else if (varp == &p_qftf) {  // 'quickfixtextfunc'-    if (qf_process_qftf_option() == FAIL) {-      errmsg = e_invarg;-    }+    qf_process_qftf_option(&errmsg);   } else if (gvarp == &p_tfu) {  // 'tagfunc'-    if (set_tagfunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_tagfunc_option(&errmsg);   } else {-    // Options that are a list of flags.-    p = NULL;-    if (varp == &p_ww) {  // 'whichwrap'-      p = WW_ALL;-    }-    if (varp == &p_shm) {  // 'shortmess'-      p = SHM_ALL;-    } else if (varp == &(p_cpo)) {  // 'cpoptions'-      p = CPO_VI;-    } else if (varp == &(curbuf->b_p_fo)) {  // 'formatoptions'-      p = FO_ALL;-    } else if (varp == &curwin->w_p_cocu) {  // 'concealcursor'-      p = COCU_ALL;-    } else if (varp == &p_mouse) {  // 'mouse'-      p = MOUSE_ALL;-    }-    if (p != NULL) {-      for (s = *varp; *s; s++) {-        if (vim_strchr(p, (uint8_t)(*s)) == NULL) {-          errmsg = illegal_char(errbuf, errbuflen, *s);-          break;-        }-      }-    }+    did_set_option_listflags(varp, errbuf, errbuflen, &errmsg);","sometimes you add  curwin/curbuf parameters to the new function, sometimes not (as here). Is there any reasoning behind that or it's just as you go and there will be followup PRs ?",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21885,1085232330,2023-01-24T12:20:55Z,src/nvim/optionstr.c,"@@ -1261,320 +1798,78 @@ char *did_set_string_option(int opt_idx, char **varp, char *oldval, char *errbuf     } #endif   } else if (varp == &curwin->w_p_scl) {  // 'signcolumn'-    if (check_signcolumn(*varp) != OK) {-      errmsg = e_invarg;-    }-    // When changing the 'signcolumn' to or from 'number', recompute the-    // width of the number column if 'number' or 'relativenumber' is set.-    if (((*oldval == 'n' && *(oldval + 1) == 'u')-         || (*curwin->w_p_scl == 'n' && *(curwin->w_p_scl + 1) == 'u'))-        && (curwin->w_p_nu || curwin->w_p_rnu)) {-      curwin->w_nrwidth_line_count = 0;-    }+    did_set_signcolumn(curwin, varp, oldval, &errmsg);   } else if (varp == &p_sloc) {  // 'showcmdloc'-    if (check_opt_strings(p_sloc, p_sloc_values, false) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_strings(*varp, p_sloc_values, false, &errmsg);   } else if (varp == &curwin->w_p_fdc              || varp == &curwin->w_allbuf_opt.wo_fdc) {     // 'foldcolumn'-    if (**varp == NUL || check_opt_strings(*varp, p_fdc_values, false) != OK) {-      errmsg = e_invarg;-    }-  } else if (varp == &p_pt) {-    // 'pastetoggle': translate key codes like in a mapping-    if (*p_pt) {-      p = NULL;-      (void)replace_termcodes(p_pt,-                              strlen(p_pt),-                              &p, REPTERM_FROM_PART | REPTERM_DO_LT, NULL,-                              CPO_TO_CPO_FLAGS);-      if (p != NULL) {-        free_string_option(p_pt);-        p_pt = p;-      }-    }+    did_set_foldcolumn(varp, &errmsg);+  } else if (varp == &p_pt) {  // 'pastetoggle'+    did_set_pastetoggle();   } else if (varp == &p_bs) {  // 'backspace'-    if (ascii_isdigit(*p_bs)) {-      if (*p_bs > '3' || p_bs[1] != NUL) {-        errmsg = e_invarg;-      }-    } else if (check_opt_strings(p_bs, p_bs_values, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_backspace(&errmsg);   } else if (varp == &p_bo) {-    if (opt_strings_flags(p_bo, p_bo_values, &bo_flags, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_flags(p_bo, p_bo_values, &bo_flags, true, &errmsg);   } else if (gvarp == &p_tc) {  // 'tagcase'-    unsigned int *flags;--    if (opt_flags & OPT_LOCAL) {-      p = curbuf->b_p_tc;-      flags = &curbuf->b_tc_flags;-    } else {-      p = p_tc;-      flags = &tc_flags;-    }--    if ((opt_flags & OPT_LOCAL) && *p == NUL) {-      // make the local value empty: use the global value-      *flags = 0;-    } else if (*p == NUL-               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {-      errmsg = e_invarg;-    }+    did_set_tagcase(opt_flags, &errmsg);   } else if (varp == &p_cmp) {  // 'casemap'-    if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_flags(p_cmp, p_cmp_values, &cmp_flags, true, &errmsg);   } else if (varp == &p_dip) {  // 'diffopt'-    if (diffopt_changed() == FAIL) {-      errmsg = e_invarg;-    }+    did_set_diffopt(&errmsg);   } else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {  // 'foldmethod'-    if (check_opt_strings(*varp, p_fdm_values, false) != OK-        || *curwin->w_p_fdm == NUL) {-      errmsg = e_invarg;-    } else {-      foldUpdateAll(curwin);-      if (foldmethodIsDiff(curwin)) {-        newFoldLevel();-      }-    }+    did_set_foldmethod(curwin, varp, &errmsg);   } else if (gvarp == &curwin->w_allbuf_opt.wo_fmr) {  // 'foldmarker'-    p = vim_strchr(*varp, ',');-    if (p == NULL) {-      errmsg = N_(""E536: comma required"");-    } else if (p == *varp || p[1] == NUL) {-      errmsg = e_invarg;-    } else if (foldmethodIsMarker(curwin)) {-      foldUpdateAll(curwin);-    }+    did_set_foldmarker(curwin, varp, &errmsg);   } else if (gvarp == &p_cms) {  // 'commentstring'-    if (**varp != NUL && strstr(*varp, ""%s"") == NULL) {-      errmsg = N_(""E537: 'commentstring' must be empty or contain %s"");-    }+    did_set_commentstring(varp, &errmsg);   } else if (varp == &p_fdo) {  // 'foldopen'-    if (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_flags(p_fdo, p_fdo_values, &fdo_flags, true, &errmsg);   } else if (varp == &p_fcl) {  // 'foldclose'-    if (check_opt_strings(p_fcl, p_fcl_values, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_strings(*varp, p_fcl_values, true, &errmsg);   } else if (gvarp == &curwin->w_allbuf_opt.wo_fdi) {  // 'foldignore'-    if (foldmethodIsIndent(curwin)) {-      foldUpdateAll(curwin);-    }+    did_set_foldignore(curwin);   } else if (gvarp == &p_ve) {  // 'virtualedit'-    char *ve = p_ve;-    unsigned int *flags = &ve_flags;--    if (opt_flags & OPT_LOCAL) {-      ve = curwin->w_p_ve;-      flags = &curwin->w_ve_flags;-    }--    if ((opt_flags & OPT_LOCAL) && *ve == NUL) {-      // make the local value empty: use the global value-      *flags = 0;-    } else {-      if (opt_strings_flags(ve, p_ve_values, flags, true) != OK) {-        errmsg = e_invarg;-      } else if (strcmp(p_ve, oldval) != 0) {-        // Recompute cursor position in case the new 've' setting-        // changes something.-        validate_virtcol();-        coladvance(curwin->w_virtcol);-      }-    }+    did_set_virtualedit(curwin, opt_flags, oldval, &errmsg);   } else if (gvarp == &p_cino) {  // 'cinoptions'     // TODO(vim): recognize errors     parse_cino(curbuf);   } else if (gvarp == &p_lop) {  // 'lispoptions'-    if (**varp != NUL && strcmp(*varp, ""expr:0"") != 0 && strcmp(*varp, ""expr:1"") != 0) {-      errmsg = e_invarg;-    }+    did_set_listoptions(varp, &errmsg);   } else if (varp == &p_icm) {  // 'inccommand'-    if (check_opt_strings(p_icm, p_icm_values, false) != OK) {-      errmsg = e_invarg;-    }-  } else if (gvarp == &p_ft) {-    if (!valid_filetype(*varp)) {-      errmsg = e_invarg;-    } else {-      value_changed = strcmp(oldval, *varp) != 0;--      // Since we check the value, there is no need to set P_INSECURE,-      // even when the value comes from a modeline.-      *value_checked = true;-    }-  } else if (gvarp == &p_syn) {-    if (!valid_filetype(*varp)) {-      errmsg = e_invarg;-    } else {-      value_changed = strcmp(oldval, *varp) != 0;--      // Since we check the value, there is no need to set P_INSECURE,-      // even when the value comes from a modeline.-      *value_checked = true;-    }+    did_set_opt_strings(*varp, p_icm_values, false, &errmsg);+  } else if (gvarp == &p_ft || gvarp == &p_syn) {+    did_set_filetype_or_syntax(varp, oldval, value_checked, &value_changed, &errmsg);   } else if (varp == &curwin->w_p_winhl) {-    if (!parse_winhl_opt(curwin)) {-      errmsg = e_invarg;-    }+    did_set_winhl(curwin, &errmsg);   } else if (varp == &p_tpf) {-    if (opt_strings_flags(p_tpf, p_tpf_values, &tpf_flags, true) != OK) {-      errmsg = e_invarg;-    }+    did_set_opt_flags(p_tpf, p_tpf_values, &tpf_flags, true, &errmsg);   } else if (varp == &(curbuf->b_p_vsts)) {  // 'varsofttabstop'-    char *cp;--    if (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1])) {-      XFREE_CLEAR(curbuf->b_p_vsts_array);-    } else {-      for (cp = *varp; *cp; cp++) {-        if (ascii_isdigit(*cp)) {-          continue;-        }-        if (*cp == ',' && cp > *varp && *(cp - 1) != ',') {-          continue;-        }-        errmsg = e_invarg;-        break;-      }-      if (errmsg == NULL) {-        long *oldarray = curbuf->b_p_vsts_array;-        if (tabstop_set(*varp, &(curbuf->b_p_vsts_array))) {-          xfree(oldarray);-        } else {-          errmsg = e_invarg;-        }-      }-    }+    did_set_varsoftabstop(curbuf, varp, &errmsg);   } else if (varp == &(curbuf->b_p_vts)) {  // 'vartabstop'-    char *cp;--    if (!(*varp)[0] || ((*varp)[0] == '0' && !(*varp)[1])) {-      XFREE_CLEAR(curbuf->b_p_vts_array);-    } else {-      for (cp = *varp; *cp; cp++) {-        if (ascii_isdigit(*cp)) {-          continue;-        }-        if (*cp == ',' && cp > *varp && *(cp - 1) != ',') {-          continue;-        }-        errmsg = e_invarg;-        break;-      }-      if (errmsg == NULL) {-        long *oldarray = curbuf->b_p_vts_array;-        if (tabstop_set(*varp, &(curbuf->b_p_vts_array))) {-          xfree(oldarray);-          if (foldmethodIsIndent(curwin)) {-            foldUpdateAll(curwin);-          }-        } else {-          errmsg = e_invarg;-        }-      }-    }+    did_set_vartabstop(curbuf, varp, &errmsg);   } else if (varp == &p_dex              || varp == &curwin->w_p_fde              || varp == &curwin->w_p_fdt              || gvarp == &p_fex              || gvarp == &p_inex              || gvarp == &p_inde              || varp == &p_pex) {  // '*expr' options-    char **p_opt = NULL;--    // If the option value starts with <SID> or s:, then replace that with-    // the script identifier.--    if (varp == &p_dex) {  // 'diffexpr'-      p_opt = &p_dex;-    }-    if (varp == &curwin->w_p_fde) {  // 'foldexpr'-      p_opt = &curwin->w_p_fde;-    }-    if (varp == &curwin->w_p_fdt) {  // 'foldtext'-      p_opt = &curwin->w_p_fdt;-    }-    if (gvarp == &p_fex) {  // 'formatexpr'-      p_opt = &curbuf->b_p_fex;-    }-    if (gvarp == &p_inex) {  // 'includeexpr'-      p_opt = &curbuf->b_p_inex;-    }-    if (gvarp == &p_inde) {  // 'indentexpr'-      p_opt = &curbuf->b_p_inde;-    }-    if (varp == &p_pex) {  // 'patchexpr'-      p_opt = &p_pex;-    }--    if (p_opt != NULL) {-      char *name = get_scriptlocal_funcname(*p_opt);-      if (name != NULL) {-        free_string_option(*p_opt);-        *p_opt = name;-      }-    }--    if (varp == &curwin->w_p_fde && foldmethodIsExpr(curwin)) {-      foldUpdateAll(curwin);-    }+    did_set_optexpr(curbuf, curwin, varp, gvarp);   } else if (gvarp == &p_cfu) {  // 'completefunc'-    if (set_completefunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_completefunc_option(&errmsg);   } else if (gvarp == &p_ofu) {  // 'omnifunc'-    if (set_omnifunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_omnifunc_option(&errmsg);   } else if (gvarp == &p_tsrfu) {  // 'thesaurusfunc'-    if (set_thesaurusfunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_thesaurusfunc_option(&errmsg);   } else if (varp == &p_opfunc) {  // 'operatorfunc'-    if (set_operatorfunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_operatorfunc_option(&errmsg);   } else if (varp == &p_qftf) {  // 'quickfixtextfunc'-    if (qf_process_qftf_option() == FAIL) {-      errmsg = e_invarg;-    }+    qf_process_qftf_option(&errmsg);   } else if (gvarp == &p_tfu) {  // 'tagfunc'-    if (set_tagfunc_option() == FAIL) {-      errmsg = e_invarg;-    }+    set_tagfunc_option(&errmsg);   } else {-    // Options that are a list of flags.-    p = NULL;-    if (varp == &p_ww) {  // 'whichwrap'-      p = WW_ALL;-    }-    if (varp == &p_shm) {  // 'shortmess'-      p = SHM_ALL;-    } else if (varp == &(p_cpo)) {  // 'cpoptions'-      p = CPO_VI;-    } else if (varp == &(curbuf->b_p_fo)) {  // 'formatoptions'-      p = FO_ALL;-    } else if (varp == &curwin->w_p_cocu) {  // 'concealcursor'-      p = COCU_ALL;-    } else if (varp == &p_mouse) {  // 'mouse'-      p = MOUSE_ALL;-    }-    if (p != NULL) {-      for (s = *varp; *s; s++) {-        if (vim_strchr(p, (uint8_t)(*s)) == NULL) {-          errmsg = illegal_char(errbuf, errbuflen, *s);-          break;-        }-      }-    }+    did_set_option_listflags(varp, errbuf, errbuflen, &errmsg);","The sole reason is that I didn't notice the dependency on curbuf/curwin. Most of these functions are low-level, so this is the place to start removing the dependency on curbuf/curwin.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21885,1085234083,2023-01-24T12:22:04Z,src/nvim/insexpand.c,"@@ -2279,14 +2279,13 @@ void set_buflocal_cfu_callback(buf_T *buf) /// Invoked when the 'omnifunc' option is set. The option value can be a /// name of a function (string), or function(<name>) or funcref(<name>) or a /// lambda expression.-int set_omnifunc_option(void)+void set_omnifunc_option(char **errmsg)","Yep, I accidentally missed this one.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21994,1088293543,2023-01-26T20:10:17Z,src/nvim/option.c,"@@ -726,11 +726,173 @@ void ex_set(exarg_T *eap)   (void)do_set(eap->arg, flags); } +static void do_set_bool(int opt_idx, int opt_flags, int prefix, int nextchar, const char *varp,+                        char **errmsg)+{+  varnumber_T value;++  // "":set opt!"": invert+  // "":set opt&"": reset to default value+  // "":set opt<"": reset to global value+  if (nextchar == '!') {+    value = *(int *)(varp) ^ 1;+  } else if (nextchar == '&') {+    value = (int)(intptr_t)options[opt_idx].def_val;+  } else if (nextchar == '<') {+    // For 'autoread' -1 means to use global value.+    if ((int *)varp == &curbuf->b_p_ar && opt_flags == OPT_LOCAL) {+      value = -1;+    } else {+      value = *(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);+    }+  } else {+    if (prefix == 2) {                  // inv+      value = *(int *)varp ^ 1;+    } else {+      value = prefix;+    }+  }++  *errmsg = set_bool_option(opt_idx, (char_u *)varp, (int)value, opt_flags);+}++static void do_set_num(int opt_idx, int opt_flags, char **argp, int nextchar, const set_op_T op,+                       const char *varp, char *errbuf, size_t errbuflen, char **errmsg)+{+  varnumber_T value;+  char *arg = *argp;++  // Different ways to set a number option:+  // &            set to default value+  // <            set to global value+  // <xx>         accept special key codes for 'wildchar'+  // c            accept any non-digit for 'wildchar'+  // [-]0-9       set number+  // other        error+  arg++;+  if (nextchar == '&') {+    value = (long)(intptr_t)options[opt_idx].def_val;+  } else if (nextchar == '<') {+    // For 'undolevels' NO_LOCAL_UNDOLEVEL means to+    // use the global value.+    if ((long *)varp == &curbuf->b_p_ul && opt_flags == OPT_LOCAL) {+      value = NO_LOCAL_UNDOLEVEL;+    } else {+      value = *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);+    }+  } else if (((long *)varp == &p_wc+              || (long *)varp == &p_wcm)+             && (*arg == '<'+                 || *arg == '^'+                 || (*arg != NUL && (!arg[1] || ascii_iswhite(arg[1]))+                     && !ascii_isdigit(*arg)))) {+    value = string_to_key(arg);+    if (value == 0 && (long *)varp != &p_wcm) {+      *errmsg = e_invarg;+      return;+    }+  } else if (*arg == '-' || ascii_isdigit(*arg)) {+    int i;+    // Allow negative, octal and hex numbers.+    vim_str2nr(arg, NULL, &i, STR2NR_ALL, &value, NULL, 0, true);+    if (i == 0 || (arg[i] != NUL && !ascii_iswhite(arg[i]))) {+      *errmsg = e_number_required_after_equal;+      return;+    }+  } else {+    *errmsg = e_number_required_after_equal;+    return;+  }++  if (op == OP_ADDING) {+    value = *(long *)varp + value;+  }+  if (op == OP_PREPENDING) {+    value = *(long *)varp * value;+  }+  if (op == OP_REMOVING) {+    value = *(long *)varp - value;+  }+  *errmsg = set_num_option(opt_idx, (char_u *)varp, (long)value,+                           errbuf, errbuflen, opt_flags);+}++// Handle some special cases with string option values+static void munge_string_opt_val(char **varp, char **oldval, char **const origval,","Does this work?https://www.google.com/search?q=define%20munge&ie=utf-8&oe=utf-8> verb informal���Computing> verb: munge>>    manipulate (data).>    ""you could do what anti-spammers have done for years and mung the URLs""",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21994,1088755198,2023-01-27T09:38:42Z,src/nvim/option.c,"@@ -1408,24 +1415,22 @@ static void do_set_option(int opt_flags, char **argp, bool *did_show, char *errb     return;   } +  if (!(flags & P_BOOL) && vim_strchr(""=:&<"", nextchar) == NULL) {+    *errmsg = e_invarg;+    return;+  }+   int value_checked = false;-  if (flags & P_BOOL) {                       // boolean+  if (flags & P_BOOL) {        // boolean     do_set_bool(opt_idx, opt_flags, prefix, nextchar, afterchar, varp, errmsg);-  } else {  // Numeric or string.-    if (vim_strchr(""=:&<"", nextchar) == NULL || prefix != 1) {","> Why is this check split and moved to two separate places instead of one?This is the wrong position for both checks, and the checks aren't really related.> To be clearer, I don't think this should be in validate_opt_idx().How come? It's similar to other checks in that function. Not all the checks require `opt_idx`. Some just check `flags` and `opt_flags` with other random bits of state.",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/21946,1089747056,2023-01-28T14:24:33Z,src/nvim/fileio.c,"@@ -5566,9 +5502,13 @@ char *file_pat_to_reg_pat(const char *pat, const char *pat_end, char *allow_dirs     return xstrdup(""^$"");   } +  if (allow_dirs != NULL) {+    *allow_dirs = false;","Woops, really sorry about that, this was a mistake. Hope this didn't cost you too much time.I have no idea why I did this. It could have been accidental.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/22022,1089750103,2023-01-28T14:50:33Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -656,6 +704,81 @@ function M.force_refresh(bufnr)   highlighter:send_request() end +--- Add a new semantic token highlighting rule.+---+--- @param rule function Function returning highlight name as string, or nil+--- @param opts (nil|table) Optional keyword arguments:+---  - desc (string, default ""none""): Description of rule+---  - bufnr (number | nil): if specified, the rule only applies in the+---        given buffer.+---  - ft (string | nil): if specified, applies to all files with the given+---        filetype. Ignored if bufnr is specified. If neither is given,+---        the rule applies globally.+---  - pri_stack (number, default 1): how many priority levels this rule+---        uses. Used to increase the priority for the next rule added.+---  - priority (number | nil): use this priority for marks applied by+---        this rule. Implies pri_stack = 0.+---+--- @return number id of created rule+function M.add_rule(rule, opts)+  opts = opts or {}++  local id = next_rule_id+  next_rule_id = next_rule_id + 1++  local priority = opts.priority or highest_priority+  local priority_delta = opts.pri_stack or opts.priority and 0 or 1+  highest_priority = highest_priority + priority_delta++  local scope = opts.bufnr and rule_scopes.buffer[opts.bufnr]+    or opts.ft and rule_scopes.filetype[opts.ft]+    or rule_scopes.global+  scope[id] = { cb = rule, priority = priority, desc = (opts.desc or 'none') }+  scope_for_rule[id] = scope++  return id+end++--- Delete a semantic token highlighting rule.+---+--- @param id (nil|number) Rule to delete. If nil, delete all rules.+function M.delete_rule(id)+  local ids_to_delete = id and { id } or vim.tbl_keys(scope_for_rule)+  for _, deleted in ipairs(ids_to_delete) do+    scope_for_rule[deleted][deleted] = nil+    scope_for_rule[deleted] = nil+  end++  -- If all rules are deleted, reset the implicit priority.+  if not id then+    highest_priority = vim.highlight.priorities.semantic_tokens+  end+end++local default_rule = function(token, bufnr, priority, namespace)+  local ft = vim.bo[bufnr].filetype++  local mark = function(hl_group, delta)+    vim.api.nvim_buf_set_extmark(bufnr, namespace, token.line, token.start_col, {+      hl_group = hl_group,+      end_col = token.end_col,+      priority = priority + delta,+      strict = false,+    })+  end++  mark(string.format('@sem.type.%s.%s', token.type, ft), 0)++  for _, modifier in ipairs(token.modifiers) do+    mark(string.format('@sem.mod.%s.%s', modifier, ft), 1)+  end","Based on your PR description, it looks like this PR would leave the semantic highlighting engine enabled by default, but unless a colorscheme or user specifically adds highlights for these new groups, then the net effect is that this PR would make it seem like semantic highlights are no longer enabled by default.I'm not opposed to that, but I know that @mfussenegger wanted it so that some sort of basic highlighting was included out-of-the-box with no extra set up required on the user's part other than attaching an LSP client.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/22022,1089751248,2023-01-28T14:59:47Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -656,6 +704,81 @@ function M.force_refresh(bufnr)   highlighter:send_request() end +--- Add a new semantic token highlighting rule.+---+--- @param rule function Function returning highlight name as string, or nil+--- @param opts (nil|table) Optional keyword arguments:+---  - desc (string, default ""none""): Description of rule+---  - bufnr (number | nil): if specified, the rule only applies in the+---        given buffer.+---  - ft (string | nil): if specified, applies to all files with the given+---        filetype. Ignored if bufnr is specified. If neither is given,+---        the rule applies globally.+---  - pri_stack (number, default 1): how many priority levels this rule+---        uses. Used to increase the priority for the next rule added.+---  - priority (number | nil): use this priority for marks applied by+---        this rule. Implies pri_stack = 0.+---+--- @return number id of created rule+function M.add_rule(rule, opts)+  opts = opts or {}++  local id = next_rule_id+  next_rule_id = next_rule_id + 1++  local priority = opts.priority or highest_priority+  local priority_delta = opts.pri_stack or opts.priority and 0 or 1+  highest_priority = highest_priority + priority_delta++  local scope = opts.bufnr and rule_scopes.buffer[opts.bufnr]+    or opts.ft and rule_scopes.filetype[opts.ft]+    or rule_scopes.global+  scope[id] = { cb = rule, priority = priority, desc = (opts.desc or 'none') }+  scope_for_rule[id] = scope++  return id+end++--- Delete a semantic token highlighting rule.+---+--- @param id (nil|number) Rule to delete. If nil, delete all rules.+function M.delete_rule(id)+  local ids_to_delete = id and { id } or vim.tbl_keys(scope_for_rule)+  for _, deleted in ipairs(ids_to_delete) do+    scope_for_rule[deleted][deleted] = nil+    scope_for_rule[deleted] = nil+  end++  -- If all rules are deleted, reset the implicit priority.+  if not id then+    highest_priority = vim.highlight.priorities.semantic_tokens+  end+end++local default_rule = function(token, bufnr, priority, namespace)+  local ft = vim.bo[bufnr].filetype++  local mark = function(hl_group, delta)+    vim.api.nvim_buf_set_extmark(bufnr, namespace, token.line, token.start_col, {+      hl_group = hl_group,+      end_col = token.end_col,+      priority = priority + delta,+      strict = false,+    })+  end","Is the default rule applying extmarks directly (instead of returning hl_group) because it is ""more complicated"" than what a basic rule would do (applies marks for all modifiers too)?If I follow correctly, the `rule` functions _can_ return a highlight group name, which the main engine will apply, but if the rule returns nil, then it ignores it. This seems fine, but the `set_extmark` code is repeated in a couple places. Probably no way around that since making a helper function would have almost as many parameters as just calling the vim api itself.",X
926528,swarn,https://api.github.com/repos/neovim/neovim/pulls/22022,1089760663,2023-01-28T16:03:44Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -656,6 +704,81 @@ function M.force_refresh(bufnr)   highlighter:send_request() end +--- Add a new semantic token highlighting rule.+---+--- @param rule function Function returning highlight name as string, or nil+--- @param opts (nil|table) Optional keyword arguments:+---  - desc (string, default ""none""): Description of rule+---  - bufnr (number | nil): if specified, the rule only applies in the+---        given buffer.+---  - ft (string | nil): if specified, applies to all files with the given+---        filetype. Ignored if bufnr is specified. If neither is given,+---        the rule applies globally.+---  - pri_stack (number, default 1): how many priority levels this rule+---        uses. Used to increase the priority for the next rule added.+---  - priority (number | nil): use this priority for marks applied by+---        this rule. Implies pri_stack = 0.+---+--- @return number id of created rule+function M.add_rule(rule, opts)+  opts = opts or {}++  local id = next_rule_id+  next_rule_id = next_rule_id + 1++  local priority = opts.priority or highest_priority+  local priority_delta = opts.pri_stack or opts.priority and 0 or 1+  highest_priority = highest_priority + priority_delta++  local scope = opts.bufnr and rule_scopes.buffer[opts.bufnr]+    or opts.ft and rule_scopes.filetype[opts.ft]+    or rule_scopes.global+  scope[id] = { cb = rule, priority = priority, desc = (opts.desc or 'none') }+  scope_for_rule[id] = scope++  return id+end++--- Delete a semantic token highlighting rule.+---+--- @param id (nil|number) Rule to delete. If nil, delete all rules.+function M.delete_rule(id)+  local ids_to_delete = id and { id } or vim.tbl_keys(scope_for_rule)+  for _, deleted in ipairs(ids_to_delete) do+    scope_for_rule[deleted][deleted] = nil+    scope_for_rule[deleted] = nil+  end++  -- If all rules are deleted, reset the implicit priority.+  if not id then+    highest_priority = vim.highlight.priorities.semantic_tokens+  end+end++local default_rule = function(token, bufnr, priority, namespace)+  local ft = vim.bo[bufnr].filetype++  local mark = function(hl_group, delta)+    vim.api.nvim_buf_set_extmark(bufnr, namespace, token.line, token.start_col, {+      hl_group = hl_group,+      end_col = token.end_col,+      priority = priority + delta,+      strict = false,+    })+  end","Correct, the `rule_apply` function can only handle a single highlight/extmark returned from a rule. The default rule applies one highlight for each modifier, so must apply its own marks.I considered allowing rules to return more than one highlight. It sounds simple; return a highlight or a list of highlights. But then you'd probably want to be able to assign different highlights for different priorities, so now you're talking about a list of highlights and priorities. I decided to keep the rule return value as simple as possible (nil | string). The default rule itself is an example for anyone who wants to write more complex rules.There is a bit of repetition in calling `set_extmark` with the same args in multiple places, but as you say, I don't factoring that out will improve the code.Thanks, btw, for the detailed comments explaining which parameters are appropriate for the token extmarks.",X
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1090081996,2023-01-29T23:58:42Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,260 @@+local watch = require('vim._watch')+local protocol = require('vim.lsp.protocol')++local M = {}++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = { '' }++  local path_sep = '[/\\]'+  local non_path_sep = '[^/\\]'++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p .. chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = ''+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = ''+      else+        if c == '{' then+          in_braces = true+        elseif c == '}' then+          in_braces = false+        elseif c == '[' then+          in_brackets = true+        elseif c == ']' then+          in_brackets = false+        end+        segment = segment .. c+      end+    end+    if segment ~= '' then+      table.insert(segments, segment)+    end+    return segments+  end++  local function escape(c)+    if+      c == '?'+      or c == '.'+      or c == '('+      or c == ')'+      or c == '%'+      or c == '['+      or c == ']'+      or c == '*'+      or c == '+'+      or c == '-'+    then+      return '%' .. c+    end+    return c+  end++  local segments = split(pattern, '/')+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == '**' then+      local chunks = {+        path_sep .. '-',+        '.-' .. path_sep,+      }+      if last_seg then+        chunks = { '.-' }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = ''+      local in_brackets = false+      local bracket_val = ''+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= '}' and in_braces then+          brace_val = brace_val .. char+        else+          if in_brackets and (char ~= ']' or bracket_val == '') then+            local res+            if char == '-' then+              res = char+            elseif bracket_val == '' and char == '!' then+              res = '^'+            elseif char == '/' then+              res = ''+            else+              res = escape(char)+            end+            bracket_val = bracket_val .. res+          else+            if char == '{' then+              in_braces = true+            elseif char == '[' then+              in_brackets = true+            elseif char == '}' then+              local choices = split(brace_val, ',')+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = ''+            elseif char == ']' then+              append({ '[' .. bracket_val .. ']' })+              in_brackets = false+              bracket_val = ''+            elseif char == '?' then+              append({ non_path_sep })+            elseif char == '*' then+              append({ non_path_sep .. '-' })+            else+              append({ escape(char) })+            end+          end+        end+      end++      if not last_seg and (segments[i + 1] ~= '**' or i + 1 < #segments) then+        append({ path_sep })+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509+---+---@param pattern string|table The glob pattern (raw or parsed) to match.+---@param s string The string to match against pattern.+---@return boolean Whether or not pattern matches s.+function M._match(pattern, s)+  if type(pattern) == 'string' then+    pattern = parse(pattern)+  end+  -- Since Lua's built-in string pattern matching does not have an alternate+  -- operator like '|', `parse` will construct one pattern for each possible+  -- alternative. Any pattern that matches thus matches the glob.+  for _, p in ipairs(pattern) do+    if s:match('^' .. p .. '$') then+      return true+    end+  end+  return false+end++local watchfunc = (vim.fn.has('win32') == 1 or vim.fn.has('mac') == 1) and watch.watch or watch.poll++---@type table<number, table<number, function()>> client id -> registration id -> cancel function+local cancels = vim.defaulttable()++local queue_timeout_ms = 100+---@type table<number, uv_timer_t> client id -> libuv timer which will send queued changes at its timeout+local queue_timers = {}+---@type table<number, lsp.FileEvent[]> client id -> set of queued changes to send in a single LSP notification+local change_queues = {}",Leaving this as a TODO for myself to add the `change_cache` back so we can skip sending duplicate change types for the same file back-to-back.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22022,1090343268,2023-01-30T09:10:12Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -656,6 +704,81 @@ function M.force_refresh(bufnr)   highlighter:send_request() end +--- Add a new semantic token highlighting rule.+---+--- @param rule function Function returning highlight name as string, or nil+--- @param opts (nil|table) Optional keyword arguments:+---  - desc (string, default ""none""): Description of rule+---  - bufnr (number | nil): if specified, the rule only applies in the+---        given buffer.+---  - ft (string | nil): if specified, applies to all files with the given+---        filetype. Ignored if bufnr is specified. If neither is given,+---        the rule applies globally.+---  - pri_stack (number, default 1): how many priority levels this rule+---        uses. Used to increase the priority for the next rule added.+---  - priority (number | nil): use this priority for marks applied by+---        this rule. Implies pri_stack = 0.+---+--- @return number id of created rule+function M.add_rule(rule, opts)+  opts = opts or {}++  local id = next_rule_id+  next_rule_id = next_rule_id + 1++  local priority = opts.priority or highest_priority+  local priority_delta = opts.pri_stack or opts.priority and 0 or 1+  highest_priority = highest_priority + priority_delta++  local scope = opts.bufnr and rule_scopes.buffer[opts.bufnr]+    or opts.ft and rule_scopes.filetype[opts.ft]+    or rule_scopes.global+  scope[id] = { cb = rule, priority = priority, desc = (opts.desc or 'none') }+  scope_for_rule[id] = scope++  return id+end++--- Delete a semantic token highlighting rule.+---+--- @param id (nil|number) Rule to delete. If nil, delete all rules.+function M.delete_rule(id)+  local ids_to_delete = id and { id } or vim.tbl_keys(scope_for_rule)+  for _, deleted in ipairs(ids_to_delete) do+    scope_for_rule[deleted][deleted] = nil+    scope_for_rule[deleted] = nil+  end++  -- If all rules are deleted, reset the implicit priority.+  if not id then+    highest_priority = vim.highlight.priorities.semantic_tokens+  end+end++local default_rule = function(token, bufnr, priority, namespace)+  local ft = vim.bo[bufnr].filetype++  local mark = function(hl_group, delta)+    vim.api.nvim_buf_set_extmark(bufnr, namespace, token.line, token.start_col, {+      hl_group = hl_group,+      end_col = token.end_col,+      priority = priority + delta,+      strict = false,+    })+  end++  mark(string.format('@sem.type.%s.%s', token.type, ft), 0)++  for _, modifier in ipairs(token.modifiers) do+    mark(string.format('@sem.mod.%s.%s', modifier, ft), 1)+  end","Yes, the first option is preferable. If we make the change to separate semantic highlights from treesitter highlights, we should _completely_ separate them. (Users are still free to make the non-default link in case they have a different highlight for `@function` that they prefer.)",
926528,swarn,https://api.github.com/repos/neovim/neovim/pulls/22022,1090795555,2023-01-30T15:39:13Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -656,6 +704,81 @@ function M.force_refresh(bufnr)   highlighter:send_request() end +--- Add a new semantic token highlighting rule.+---+--- @param rule function Function returning highlight name as string, or nil+--- @param opts (nil|table) Optional keyword arguments:+---  - desc (string, default ""none""): Description of rule+---  - bufnr (number | nil): if specified, the rule only applies in the+---        given buffer.+---  - ft (string | nil): if specified, applies to all files with the given+---        filetype. Ignored if bufnr is specified. If neither is given,+---        the rule applies globally.+---  - pri_stack (number, default 1): how many priority levels this rule+---        uses. Used to increase the priority for the next rule added.+---  - priority (number | nil): use this priority for marks applied by+---        this rule. Implies pri_stack = 0.+---+--- @return number id of created rule+function M.add_rule(rule, opts)+  opts = opts or {}++  local id = next_rule_id+  next_rule_id = next_rule_id + 1++  local priority = opts.priority or highest_priority+  local priority_delta = opts.pri_stack or opts.priority and 0 or 1+  highest_priority = highest_priority + priority_delta++  local scope = opts.bufnr and rule_scopes.buffer[opts.bufnr]+    or opts.ft and rule_scopes.filetype[opts.ft]+    or rule_scopes.global+  scope[id] = { cb = rule, priority = priority, desc = (opts.desc or 'none') }+  scope_for_rule[id] = scope++  return id+end++--- Delete a semantic token highlighting rule.+---+--- @param id (nil|number) Rule to delete. If nil, delete all rules.+function M.delete_rule(id)+  local ids_to_delete = id and { id } or vim.tbl_keys(scope_for_rule)+  for _, deleted in ipairs(ids_to_delete) do+    scope_for_rule[deleted][deleted] = nil+    scope_for_rule[deleted] = nil+  end++  -- If all rules are deleted, reset the implicit priority.+  if not id then+    highest_priority = vim.highlight.priorities.semantic_tokens+  end+end++local default_rule = function(token, bufnr, priority, namespace)+  local ft = vim.bo[bufnr].filetype++  local mark = function(hl_group, delta)+    vim.api.nvim_buf_set_extmark(bufnr, namespace, token.line, token.start_col, {+      hl_group = hl_group,+      end_col = token.end_col,+      priority = priority + delta,+      strict = false,+    })+  end++  mark(string.format('@sem.type.%s.%s', token.type, ft), 0)++  for _, modifier in ipairs(token.modifiers) do+    mark(string.format('@sem.mod.%s.%s', modifier, ft), 1)+  end","Agreed.The relative paucity of default highlight groups is a mild downside. Token types like `@lsp.type.{parameter, variable, property}` all map to `Identifier`. But, I suppose the same was true when treesitter first arrived.",
926528,swarn,https://api.github.com/repos/neovim/neovim/pulls/22022,1090844216,2023-01-30T16:14:48Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -656,6 +704,81 @@ function M.force_refresh(bufnr)   highlighter:send_request() end +--- Add a new semantic token highlighting rule.+---+--- @param rule function Function returning highlight name as string, or nil+--- @param opts (nil|table) Optional keyword arguments:+---  - desc (string, default ""none""): Description of rule+---  - bufnr (number | nil): if specified, the rule only applies in the+---        given buffer.+---  - ft (string | nil): if specified, applies to all files with the given+---        filetype. Ignored if bufnr is specified. If neither is given,+---        the rule applies globally.+---  - pri_stack (number, default 1): how many priority levels this rule+---        uses. Used to increase the priority for the next rule added.+---  - priority (number | nil): use this priority for marks applied by+---        this rule. Implies pri_stack = 0.+---+--- @return number id of created rule+function M.add_rule(rule, opts)+  opts = opts or {}++  local id = next_rule_id+  next_rule_id = next_rule_id + 1++  local priority = opts.priority or highest_priority+  local priority_delta = opts.pri_stack or opts.priority and 0 or 1+  highest_priority = highest_priority + priority_delta++  local scope = opts.bufnr and rule_scopes.buffer[opts.bufnr]+    or opts.ft and rule_scopes.filetype[opts.ft]+    or rule_scopes.global+  scope[id] = { cb = rule, priority = priority, desc = (opts.desc or 'none') }+  scope_for_rule[id] = scope++  return id+end++--- Delete a semantic token highlighting rule.+---+--- @param id (nil|number) Rule to delete. If nil, delete all rules.+function M.delete_rule(id)+  local ids_to_delete = id and { id } or vim.tbl_keys(scope_for_rule)+  for _, deleted in ipairs(ids_to_delete) do+    scope_for_rule[deleted][deleted] = nil+    scope_for_rule[deleted] = nil+  end++  -- If all rules are deleted, reset the implicit priority.+  if not id then+    highest_priority = vim.highlight.priorities.semantic_tokens+  end+end++local default_rule = function(token, bufnr, priority, namespace)+  local ft = vim.bo[bufnr].filetype++  local mark = function(hl_group, delta)+    vim.api.nvim_buf_set_extmark(bufnr, namespace, token.line, token.start_col, {+      hl_group = hl_group,+      end_col = token.end_col,+      priority = priority + delta,+      strict = false,+    })+  end++  mark(string.format('@sem.type.%s.%s', token.type, ft), 0)++  for _, modifier in ipairs(token.modifiers) do+    mark(string.format('@sem.mod.%s.%s', modifier, ft), 1)+  end","So here's a potential mapping, but I've got reservations:| Token Type Highlight      | Linked Group || --------------------      | ------------ || `@lsp.type.namespace`     | `Identifier` || `@lsp.type.type`          | `Type`       || `@lsp.type.class`         | `Type`       || `@lsp.type.enum`          | `Type`       || `@lsp.type.interface`     | `Type`       || `@lsp.type.struct`        | `Structure`  || `@lsp.type.typeParameter` | `TypeDef`    || `@lsp.type.parameter`     | `Identifier` || `@lsp.type.variable`      | `Identifier` || `@lsp.type.property`      | `Identifier` || `@lsp.type.enumMember`    | `Constant`   || `@lsp.type.function`      | `Function`   || `@lsp.type.method`        | `Function`   || `@lsp.type.macro`         | `Macro`      || `@lsp.type.decorator`     | `Function`   |Not linked:| Token Type Highlight | Note                                                               || -------------------- | ----                                                               || `@lsp.type`          | Don't add highlights for off-spec token types                      || `@lsp.type.comment`  | This overrides `@text.todo` and other useful marks inside comments || `@lsp.type.regexp`   | Let treesitter handle literals                                     || `@lsp.type.keyword`  | ""                                                                  || `@lsp.type.string`   | ""                                                                  || `@lsp.type.number`   | ""                                                                  || `@lsp.type.operator` | ""                                                                  || `@lsp.type.event`    | Unclear to what this should link                                   || `@lsp.type.modifier` | ""                                                                  |So here's my issue: one of the simplest and most immediately-tangible benefits of semantic token highlighting is the ability to distinguish parameters, methods, and fields even when there are no syntax clues. For example, highlighting C++ fields that _aren't_ prefixed with `this->`, or correctly highlighting parameters throughout a function body.However, if we 1) want token highlighting to make a _visible_ difference by default, and 2) only use built-in highlight groups, then the result is that token highlighting makes highlighting _worse_ by default, because there are no default Parameter, Method, or Field groups. Treesitter can at least identify parameters inside function definitions, and it can also identify fields/methods after `self.`, but those differences get hidden by default links to `Function` and `Identifier` until the user adds `@lsp.type.{method, field, parameter}`.Maybe that's just the way it is, until colorschemes ship with `@lsp.type.*` groups. And, I don't have a better suggestion. But maybe someone has a better idea, or _maybe_ we skip the default links and make it opt-in.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22022,1090905468,2023-01-30T17:04:57Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -656,6 +704,81 @@ function M.force_refresh(bufnr)   highlighter:send_request() end +--- Add a new semantic token highlighting rule.+---+--- @param rule function Function returning highlight name as string, or nil+--- @param opts (nil|table) Optional keyword arguments:+---  - desc (string, default ""none""): Description of rule+---  - bufnr (number | nil): if specified, the rule only applies in the+---        given buffer.+---  - ft (string | nil): if specified, applies to all files with the given+---        filetype. Ignored if bufnr is specified. If neither is given,+---        the rule applies globally.+---  - pri_stack (number, default 1): how many priority levels this rule+---        uses. Used to increase the priority for the next rule added.+---  - priority (number | nil): use this priority for marks applied by+---        this rule. Implies pri_stack = 0.+---+--- @return number id of created rule+function M.add_rule(rule, opts)+  opts = opts or {}++  local id = next_rule_id+  next_rule_id = next_rule_id + 1++  local priority = opts.priority or highest_priority+  local priority_delta = opts.pri_stack or opts.priority and 0 or 1+  highest_priority = highest_priority + priority_delta++  local scope = opts.bufnr and rule_scopes.buffer[opts.bufnr]+    or opts.ft and rule_scopes.filetype[opts.ft]+    or rule_scopes.global+  scope[id] = { cb = rule, priority = priority, desc = (opts.desc or 'none') }+  scope_for_rule[id] = scope++  return id+end++--- Delete a semantic token highlighting rule.+---+--- @param id (nil|number) Rule to delete. If nil, delete all rules.+function M.delete_rule(id)+  local ids_to_delete = id and { id } or vim.tbl_keys(scope_for_rule)+  for _, deleted in ipairs(ids_to_delete) do+    scope_for_rule[deleted][deleted] = nil+    scope_for_rule[deleted] = nil+  end++  -- If all rules are deleted, reset the implicit priority.+  if not id then+    highest_priority = vim.highlight.priorities.semantic_tokens+  end+end++local default_rule = function(token, bufnr, priority, namespace)+  local ft = vim.bo[bufnr].filetype++  local mark = function(hl_group, delta)+    vim.api.nvim_buf_set_extmark(bufnr, namespace, token.line, token.start_col, {+      hl_group = hl_group,+      end_col = token.end_col,+      priority = priority + delta,+      strict = false,+    })+  end++  mark(string.format('@sem.type.%s.%s', token.type, ft), 0)++  for _, modifier in ipairs(token.modifiers) do+    mark(string.format('@sem.mod.%s.%s', modifier, ft), 1)+  end","That's just the way it is. Again,1. the links to default groups are just a fallback to guarantee everybody can see ""hey, it's working""2. the default groups are _not_ meant to give the best out-of-the-box experience for ""advanced highlighting""; for that personal customization is (intentionally) requiredWe may consider adding more default groups as part of the new default ""Neovim colorscheme"", but that is a future change -- and wouldn't help much for people using classical Vim colorschemes (which have gotten quite good since Vim 9.0!)Remember, it's much easier to _add_ something later than to change it, so let's not try to cover _everything_ in one PR.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22022,1092869246,2023-02-01T07:56:26Z,runtime/doc/lsp.txt,"@@ -1323,14 +1323,75 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()* ============================================================================== Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens* +add_rule({rule}, {opts})                  *vim.lsp.semantic_tokens.add_rule()*+    Add a new semantic token highlighting rule.++    Example: >lua+    -- Highlight static local variables+    vim.lsp.semantic_tokens.add_rule(function(token)+      if token.modifiers.functionScope and token.modifiers.static then+        return ""MyStaticLocalHL""+      end+    end)++    vim.api.nvim_set_hl(0, ""MyStaticLocalHL"", { fg = ""red"" })+<++    Parameters: ~+      ��� {rule}  (function) Lua callback invoked on visible tokens. Return a+                highlight group name to apply that highlight to a token. Args:+                ��� token: a table with the fields:+                  ��� type: string LSP token type, e.g. 'function' or 'variable'+                  ��� modifiers: set of LSP token modifiers, e.g. >lua++                     { defaultLibrary = true, readOnly = true }+<+                  ��� line: line number, 0-based+                  ��� start_col: start column, 0-based+                  ��� end_col: start column, 0-based++                ��� bufnr: buffer number+                ��� priority: priority assigned to highlight (see below)+                ��� namespace: the namespace managed by the semantic token+                  highlighter. If you apply extmarks inside the rule, you+                  likely want to use this namespace.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� desc (string|nil): Description of rule, default ""none""+                ��� bufnr (number|nil): If specified, the rule only applies in+                  the given buffer.+                ��� ft (string|nil): if specified, applies to all files with the+                  given filetype. Ignored if `bufnr` is specified. If neither+                  is given, the rule applies globally.+                ��� priority (number|nil): Use this priority for highlights+                  returned by this rule, and supply it as the `priority`+                  argument to `rule` callbacks. By default, this is 1 higher+                  than the last rule added with `add_rule`, so rules added+                  later have higher priority.+                ��� pri_stack (number|nil): The number of priority level levels+                  used by this rule; the default priority of the next added+                  rule is increased by this amount. Mostly useful if you are+                  setting extmarks inside a rule. Default 1, or 0 if+                  `priority` is given.++    Return: ~+        (number) id of created rule++delete_rule({id})                      *vim.lsp.semantic_tokens.delete_rule()*","I'm not 100% happy with the semantics here: this function conflates _deleting_ a single rule and _clearing_ all rules.It would probably be better to make this a```luavim.lsp.semantic_tokens.clear_rules(opts)```where `opts` is a table with keys* `id` (table): id of rule(s) to clear* `default` (boolean, default to be debated): clear default rules as welland, possibly and later, `ns` for a namespace.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22040,1092982785,2023-02-01T09:43:40Z,src/nvim/tui/tui.c,"@@ -189,12 +191,46 @@ TUIData *tui_start(int *width, int *height, char **term)                  100, 0);    loop_poll_events(&main_loop, 1);-  *width = tui->width;-  *height = tui->height;-  *term = tui->term;   return tui; } +void tui_attach(TUIData *tui)","Ideally this should be in ui_client.c. still a separate function, but then taking the width, height and term name as parameters. (doesn't really matter for 0.9, but later on we do want to refactor ui_client.c to a reusable abstraction, which is why it is separate from tui.c in the first place)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22022,1093142440,2023-02-01T12:16:23Z,runtime/doc/lsp.txt,"@@ -1323,14 +1323,75 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()* ============================================================================== Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens* +add_rule({rule}, {opts})                  *vim.lsp.semantic_tokens.add_rule()*+    Add a new semantic token highlighting rule.++    Example: >lua+    -- Highlight static local variables+    vim.lsp.semantic_tokens.add_rule(function(token)+      if token.modifiers.functionScope and token.modifiers.static then+        return ""MyStaticLocalHL""+      end+    end)++    vim.api.nvim_set_hl(0, ""MyStaticLocalHL"", { fg = ""red"" })+<++    Parameters: ~+      ��� {rule}  (function) Lua callback invoked on visible tokens. Return a+                highlight group name to apply that highlight to a token. Args:+                ��� token: a table with the fields:+                  ��� type: string LSP token type, e.g. 'function' or 'variable'+                  ��� modifiers: set of LSP token modifiers, e.g. >lua++                     { defaultLibrary = true, readOnly = true }+<+                  ��� line: line number, 0-based+                  ��� start_col: start column, 0-based+                  ��� end_col: start column, 0-based++                ��� bufnr: buffer number+                ��� priority: priority assigned to highlight (see below)+                ��� namespace: the namespace managed by the semantic token+                  highlighter. If you apply extmarks inside the rule, you+                  likely want to use this namespace.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� desc (string|nil): Description of rule, default ""none""+                ��� bufnr (number|nil): If specified, the rule only applies in+                  the given buffer.+                ��� ft (string|nil): if specified, applies to all files with the+                  given filetype. Ignored if `bufnr` is specified. If neither+                  is given, the rule applies globally.+                ��� priority (number|nil): Use this priority for highlights+                  returned by this rule, and supply it as the `priority`+                  argument to `rule` callbacks. By default, this is 1 higher+                  than the last rule added with `add_rule`, so rules added+                  later have higher priority.+                ��� pri_stack (number|nil): The number of priority level levels+                  used by this rule; the default priority of the next added+                  rule is increased by this amount. Mostly useful if you are+                  setting extmarks inside a rule. Default 1, or 0 if+                  `priority` is given.++    Return: ~+        (number) id of created rule++delete_rule({id})                      *vim.lsp.semantic_tokens.delete_rule()*","(In any case, common API naming pattern would be `del_rule`, not `delete_rule`.)",
926528,swarn,https://api.github.com/repos/neovim/neovim/pulls/22022,1093385448,2023-02-01T15:32:09Z,runtime/doc/lsp.txt,"@@ -1323,14 +1323,75 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()* ============================================================================== Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens* +add_rule({rule}, {opts})                  *vim.lsp.semantic_tokens.add_rule()*+    Add a new semantic token highlighting rule.++    Example: >lua+    -- Highlight static local variables+    vim.lsp.semantic_tokens.add_rule(function(token)+      if token.modifiers.functionScope and token.modifiers.static then+        return ""MyStaticLocalHL""+      end+    end)++    vim.api.nvim_set_hl(0, ""MyStaticLocalHL"", { fg = ""red"" })+<++    Parameters: ~+      ��� {rule}  (function) Lua callback invoked on visible tokens. Return a+                highlight group name to apply that highlight to a token. Args:+                ��� token: a table with the fields:+                  ��� type: string LSP token type, e.g. 'function' or 'variable'+                  ��� modifiers: set of LSP token modifiers, e.g. >lua++                     { defaultLibrary = true, readOnly = true }+<+                  ��� line: line number, 0-based+                  ��� start_col: start column, 0-based+                  ��� end_col: start column, 0-based++                ��� bufnr: buffer number+                ��� priority: priority assigned to highlight (see below)+                ��� namespace: the namespace managed by the semantic token+                  highlighter. If you apply extmarks inside the rule, you+                  likely want to use this namespace.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� desc (string|nil): Description of rule, default ""none""+                ��� bufnr (number|nil): If specified, the rule only applies in+                  the given buffer.+                ��� ft (string|nil): if specified, applies to all files with the+                  given filetype. Ignored if `bufnr` is specified. If neither+                  is given, the rule applies globally.+                ��� priority (number|nil): Use this priority for highlights+                  returned by this rule, and supply it as the `priority`+                  argument to `rule` callbacks. By default, this is 1 higher+                  than the last rule added with `add_rule`, so rules added+                  later have higher priority.+                ��� pri_stack (number|nil): The number of priority level levels","I also feel that the `pri_stack` argument is awkward.What it does is allow rules which return highlights and rules which set their own marks to coexist:``` luast.add_rule(function(token)  if token.modifiers.foo then    return 'Foo'  endend)st.add_rule(function(token, bufnr, priority, ns)  local mark = function(hl_group, delta)    vim.api.nvim_buf_set_extmark(bufnr, ns, token.line, token.start_col, {      hl_group = hl_group,      end_col = token.end_col,      priority = priority + delta,      strict = false,    })  end  if token.modifier.defaultLibrary then mark('SemDefaultLibrary', 0) end  if token.modifier.declaration then mark('SemDeclaration', 1) end  if token.modifier.readOnly then mark('SemReadOnly', 2) endend, { pri_stack = 3 } )st.add_rule(function(token)  if token.modifiers.bar then    return 'Bar'  endend)```In that example, the rules happily stack up and work as expected. All marks from the middle rule are higher priority than the previous rule, and lower priority than the next rule. Without `pri_stack`, any rule that sets more than one priority level of marks is immediately banished to the realm of explicit priorities.However,- That particular rule could simply be rewritten as three normal rules, and I bet that will often be the case.- Wanting to write rules that set extmarks and can also can be stacked with normal rules will probably always be an edge case, and certainly won't be immediately required.- Keeping with the ""add options as late as possible"" philosophy, I'll remove it now.Maybe there's a cleaner way to get the same ability?",
926528,swarn,https://api.github.com/repos/neovim/neovim/pulls/22022,1093434853,2023-02-01T16:09:16Z,runtime/doc/lsp.txt,"@@ -1323,14 +1323,75 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()* ============================================================================== Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens* +add_rule({rule}, {opts})                  *vim.lsp.semantic_tokens.add_rule()*+    Add a new semantic token highlighting rule.++    Example: >lua+    -- Highlight static local variables+    vim.lsp.semantic_tokens.add_rule(function(token)+      if token.modifiers.functionScope and token.modifiers.static then+        return ""MyStaticLocalHL""+      end+    end)++    vim.api.nvim_set_hl(0, ""MyStaticLocalHL"", { fg = ""red"" })+<++    Parameters: ~+      ��� {rule}  (function) Lua callback invoked on visible tokens. Return a+                highlight group name to apply that highlight to a token. Args:+                ��� token: a table with the fields:+                  ��� type: string LSP token type, e.g. 'function' or 'variable'+                  ��� modifiers: set of LSP token modifiers, e.g. >lua++                     { defaultLibrary = true, readOnly = true }+<+                  ��� line: line number, 0-based+                  ��� start_col: start column, 0-based+                  ��� end_col: start column, 0-based++                ��� bufnr: buffer number+                ��� priority: priority assigned to highlight (see below)+                ��� namespace: the namespace managed by the semantic token+                  highlighter. If you apply extmarks inside the rule, you+                  likely want to use this namespace.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� desc (string|nil): Description of rule, default ""none""+                ��� bufnr (number|nil): If specified, the rule only applies in+                  the given buffer.+                ��� ft (string|nil): if specified, applies to all files with the+                  given filetype. Ignored if `bufnr` is specified. If neither+                  is given, the rule applies globally.+                ��� priority (number|nil): Use this priority for highlights+                  returned by this rule, and supply it as the `priority`+                  argument to `rule` callbacks. By default, this is 1 higher+                  than the last rule added with `add_rule`, so rules added+                  later have higher priority.+                ��� pri_stack (number|nil): The number of priority level levels+                  used by this rule; the default priority of the next added+                  rule is increased by this amount. Mostly useful if you are+                  setting extmarks inside a rule. Default 1, or 0 if+                  `priority` is given.++    Return: ~+        (number) id of created rule++delete_rule({id})                      *vim.lsp.semantic_tokens.delete_rule()*","> I'm not 100% happy with the semantics here: this function conflates _deleting_ a single rule and _clearing_ all rules.Can you clarify? Are you recommending two functions, `del_rule` and `clear_rules`?It seems like a common pattern in the api to have `number|nil` arguments, where `number` is the thing (buffer, window, etc) and `nil` is ""all the things.""Does an API like this make sense?```del_rule({id}, {opt})```Parameters:- {id} (number|table|nil) Id of rule to delete. If table, a list of ids to delete. If nil, delete all rules.- {opt} (table|nil)  - keep_default (bool|nil): Default true, don't delete the default when deleting rules",X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22022,1093442845,2023-02-01T16:15:41Z,runtime/doc/lsp.txt,"@@ -1323,14 +1323,75 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()* ============================================================================== Lua module: vim.lsp.semantic_tokens                      *lsp-semantic_tokens* +add_rule({rule}, {opts})                  *vim.lsp.semantic_tokens.add_rule()*+    Add a new semantic token highlighting rule.++    Example: >lua+    -- Highlight static local variables+    vim.lsp.semantic_tokens.add_rule(function(token)+      if token.modifiers.functionScope and token.modifiers.static then+        return ""MyStaticLocalHL""+      end+    end)++    vim.api.nvim_set_hl(0, ""MyStaticLocalHL"", { fg = ""red"" })+<++    Parameters: ~+      ��� {rule}  (function) Lua callback invoked on visible tokens. Return a+                highlight group name to apply that highlight to a token. Args:+                ��� token: a table with the fields:+                  ��� type: string LSP token type, e.g. 'function' or 'variable'+                  ��� modifiers: set of LSP token modifiers, e.g. >lua++                     { defaultLibrary = true, readOnly = true }+<+                  ��� line: line number, 0-based+                  ��� start_col: start column, 0-based+                  ��� end_col: start column, 0-based++                ��� bufnr: buffer number+                ��� priority: priority assigned to highlight (see below)+                ��� namespace: the namespace managed by the semantic token+                  highlighter. If you apply extmarks inside the rule, you+                  likely want to use this namespace.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� desc (string|nil): Description of rule, default ""none""+                ��� bufnr (number|nil): If specified, the rule only applies in+                  the given buffer.+                ��� ft (string|nil): if specified, applies to all files with the+                  given filetype. Ignored if `bufnr` is specified. If neither+                  is given, the rule applies globally.+                ��� priority (number|nil): Use this priority for highlights+                  returned by this rule, and supply it as the `priority`+                  argument to `rule` callbacks. By default, this is 1 higher+                  than the last rule added with `add_rule`, so rules added+                  later have higher priority.+                ��� pri_stack (number|nil): The number of priority level levels+                  used by this rule; the default priority of the next added+                  rule is increased by this amount. Mostly useful if you are+                  setting extmarks inside a rule. Default 1, or 0 if+                  `priority` is given.++    Return: ~+        (number) id of created rule++delete_rule({id})                      *vim.lsp.semantic_tokens.delete_rule()*","> It seems like a common pattern in the api to have number|nil arguments, where number is the thing (buffer, window, etc) and nil is ""all the things.""Not really; usually in these instances `nil` means ""current <thing>"". For situations like these, it's more common to have explicit filters via keywords. And we're trying to be stricter about the Lua API design, so I still suggest to move the `id` into `opts`. This won't change the default invocation where `del_rule()` removes all non-default rules but avoids a source of confusion which optional argument is positional and which is keyword-style -- especially if we add more arguments later on.Also, as the default is removing all rules, the name should reflect that, so `clear` instead of `del`.(But as this is under the LSP umbrella, I defer to @mfussenegger here.)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22105,1096076670,2023-02-03T17:41:26Z,runtime/lua/vim/treesitter/query.lua,"@@ -6,16 +6,23 @@ local language = require('vim.treesitter.language') -- ---@class Query ---@field captures string[] List of captures used in query----@field info table Contains used queries, predicates, directives+---@field info QueryInfo Contains used queries, predicates, directives",Maybe remove or at least split off the lines 4-5 above this? Lua-language-server will pick them up for hover on `Query` instead of the class definition.(Or maybe improve it instead?),
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22105,1096077319,2023-02-03T17:41:52Z,runtime/lua/vim/treesitter/highlighter.lua,"@@ -1,13 +1,25 @@ local a = vim.api local query = require('vim.treesitter.query') +---@class TSHighlightState+---@field next_row integer+---@field iter function|nil+ -- support reload for quick experimentation ---@class TSHighlighter+---@field active table<integer,TSHighlighter>",similar here for line 8,X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22111,1096139898,2023-02-03T18:38:45Z,src/nvim/optionstr.c,"@@ -1594,6 +1594,8 @@ static void do_spelllang_source(win_T *win)   if (p > q) {     vim_snprintf(fname, sizeof(fname), ""spell/%.*s.vim"", (int)(p - q), q);     source_runtime(fname, DIP_ALL);+    vim_snprintf(fname, sizeof(fname), ""spell/%.*s.lua"", (int)(p - q), q);",I notice that the pattern for compilers and for colorschemes is to only load the Lua file if no Vim file is found; is this something we want for these spell files as well?(I have zero idea what these files are used for in practice...),
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/22111,1096361331,2023-02-03T23:04:44Z,src/nvim/optionstr.c,"@@ -1594,6 +1594,8 @@ static void do_spelllang_source(win_T *win)   if (p > q) {     vim_snprintf(fname, sizeof(fname), ""spell/%.*s.vim"", (int)(p - q), q);     source_runtime(fname, DIP_ALL);+    vim_snprintf(fname, sizeof(fname), ""spell/%.*s.lua"", (int)(p - q), q);","> I notice that the pattern for compilers and for colorschemes is to only load the Lua file if no Vim file is found; is this something we want for these spell files as well?If that is the case, then these patterns cannot be combined. For completion it doesn't matter as the results are sorted, but for sourcing it does.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/22108,1096555100,2023-02-04T16:15:53Z,src/nvim/fold_defs.h,"@@ -0,0 +1,17 @@+#ifndef NVIM_FOLD_DEFS_H",Why not? This can reduce recompilation and avoid future circular includes.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22108,1096555674,2023-02-04T16:20:51Z,src/nvim/fold_defs.h,"@@ -0,0 +1,17 @@+#ifndef NVIM_FOLD_DEFS_H",I was indeed running into circular includes due to introducing a `foldinfo_T` in the `statuscol_T` struct. The alternative would be (redundatly) calling `fold_info()` again in the statusline item code.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22111,1096560379,2023-02-04T16:57:01Z,src/nvim/optionstr.c,"@@ -1594,6 +1594,8 @@ static void do_spelllang_source(win_T *win)   if (p > q) {     vim_snprintf(fname, sizeof(fname), ""spell/%.*s.vim"", (int)(p - q), q);     source_runtime(fname, DIP_ALL);+    vim_snprintf(fname, sizeof(fname), ""spell/%.*s.lua"", (int)(p - q), q);",Isn't it searching over `rtp`? If so then I think that's significant enough considering a large majority of users don't use this. Especially since there's an alternative of combining them.,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/22156,1098762449,2023-02-07T14:48:34Z,.github/workflows/osx_universal.yml,"@@ -0,0 +1,28 @@+name: Universal macOS binary+on:+  pull_request:+    branches:+      - 'master'+      - 'release-[0-9]+.[0-9]+'+    paths:+      - '**.cmake'+      - '**/CMakeLists.txt'+      - '**/CMakePresets.json'+      - 'cmake.*/**'+      - '.github/scripts/build_universal_osx.sh'+      - '.github/workflow/osx_universal_yml'++jobs:+  universal-binary:+    runs-on: macos-latest","Sure. I wouldn't mind it myself. Renaming the filenames from ""osx"" to ""macos""",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/20634,1101445044,2023-02-09T13:11:59Z,src/nvim/main.c,"@@ -600,6 +588,12 @@ int main(int argc, char **argv)     TIME_MSG(""UIEnter autocommands"");   } +#ifdef MSWIN+  if (use_builtin_ui) {+    os_icon_init();","```E:\projects\neovim\master> gdb .\build\debug\bin\nvim.exeReading symbols from .\build\debug\bin\nvim.exe...gdb> b main.c:303Breakpoint 1 at 0x140001b27: file E:/projects/neovim/master/src/nvim/main.c, line 303.gdb> rStarting program: E:\projects\neovim\master\build\debug\bin\nvim.exe[New Thread 1840.0x6a8][New Thread 1840.0x12c8][New Thread 1840.0x1214][New Thread 1840.0x2070][New Thread 1840.0x17c8][New Thread 1840.0x275c]Thread 1 hit Breakpoint 1, wmain (argc=0x1, argv_w=0x11a4b3daa10) at E:/projects/neovim/master/src/nvim/main.c:303303       bool use_builtin_ui = (has_term && !headless_mode && !embedded_mode && !silent_mode);gdb> n308         server_init(params.listen_addr);gdb> p use_builtin_ui$1 = 0x1```Note that the value of `use_builtin_ui` is true.  But I noticed that this nvim process, the one gdb is attached to, runs into this line, and after executing it, the nvim window appears.  At that point, I don't have gdb's ui anymore.https://github.com/neovim/neovim/blob/2af31fc50ac20493e0e931fc0750e3d15da436ef/src/nvim/main.c#L380-L382^This line is above/before the line where Windows taskbar+console icon is set.https://github.com/neovim/neovim/blob/2af31fc50ac20493e0e931fc0750e3d15da436ef/src/nvim/main.c#L591-L596",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/22077,1101661060,2023-02-09T15:40:14Z,test/client/uv_stream.lua,"@@ -0,0 +1,164 @@+local uv = require('luv')++local StdioStream = {}+StdioStream.__index = StdioStream++function StdioStream.open()+  local self = setmetatable({+    _in = uv.new_pipe(false),+    _out = uv.new_pipe(false)+  }, StdioStream)+  self._in:open(0)+  self._out:open(1)+  return self+end++function StdioStream:write(data)+  self._out:write(data)+end++function StdioStream:read_start(cb)+  self._in:read_start(function(err, chunk)+    if err then+      error(err)+    end+    cb(chunk)+  end)+end++function StdioStream:read_stop()+  self._in:read_stop()+end++function StdioStream:close()+  self._in:close()+  self._out:close()+end++local SocketStream = {}+SocketStream.__index = SocketStream++function SocketStream.open(file)+  local socket = uv.new_pipe(false)+  local self = setmetatable({+    _socket = socket,+    _stream_error = nil+  }, SocketStream)+  uv.pipe_connect(socket, file, function (err)+    self._stream_error = self._stream_error or err+  end)+  return self+end++function SocketStream.connect(host, port)+  local socket = uv.new_tcp()+  local self = setmetatable({+    _socket = socket,+    _stream_error = nil+  }, SocketStream)+  uv.tcp_connect(socket, host, port, function (err)+    self._stream_error = self._stream_error or err+  end)+  return self+end+++function SocketStream:write(data)+  if self._stream_error then+    error(self._stream_error)+  end+  uv.write(self._socket, data, function(err)+    if err then+      error(self._stream_error or err)+    end+  end)+end++function SocketStream:read_start(cb)+  if self._stream_error then+    error(self._stream_error)+  end+  uv.read_start(self._socket, function(err, chunk)+    if err then+      error(err)+    end+    cb(chunk)+  end)+end++function SocketStream:read_stop()+  if self._stream_error then+    error(self._stream_error)+  end+  uv.read_stop(self._socket)+end++function SocketStream:close()+  uv.close(self._socket)+end++local ChildProcessStream = {}+ChildProcessStream.__index = ChildProcessStream++function ChildProcessStream.spawn(argv, env, io_extra)+  local self = setmetatable({+    _child_stdin = uv.new_pipe(false),+    _child_stdout = uv.new_pipe(false)+  }, ChildProcessStream)+  local prog = argv[1]+  local args = {}+  for i = 2, #argv do+    args[#args + 1] = argv[i]+  end+  self._proc, self._pid = uv.spawn(prog, {+    stdio = {self._child_stdin, self._child_stdout, 2, io_extra},+    args = args,+    env = env,+  }, function()+    self:close()+  end)++  if not self._proc then+    local err = self._pid+    error(err)+  end++  return self+end++function ChildProcessStream:write(data)+  self._child_stdin:write(data)+end++function ChildProcessStream:read_start(cb)+  self._child_stdout:read_start(function(err, chunk)+    if err then+      error(err)+    end+    cb(chunk)+  end)+end++function ChildProcessStream:read_stop()+  self._child_stdout:read_stop()+end++function ChildProcessStream:close(signal)+  if self._closed then+    return+  end+  self._closed = true+  self:read_stop()+  self._child_stdin:close()+  self._child_stdout:close()+  if type(signal) == 'string' then+    self._proc:kill('sig'..signal)+  end+  uv.run('nowait')+end",Does this no longer wait for the process to exit? Then the warning about session taking too long to exit (02f8ca59a80cd3570593c717ff6ceadc33239b89) in the test suite may no longer make sense.,
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/20634,1102781991,2023-02-10T13:42:24Z,src/nvim/main.c,"@@ -600,6 +588,12 @@ int main(int argc, char **argv)     TIME_MSG(""UIEnter autocommands"");   } +#ifdef MSWIN+  if (use_builtin_ui) {+    os_icon_init();",I think it should either be `if(use_builtin_ui || use_remote_ui)` or just `if(use_remote_ui)`.  But I'm struggling with understanding how the main and embedded processes are being run.  Can't tell what the conditional should be.,
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/22022,1103714912,2023-02-12T00:25:45Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -637,23 +651,58 @@ end --- Only has an effect if the buffer is currently active for semantic token --- highlighting (|vim.lsp.semantic_tokens.start()| has been called for it) -------@param bufnr (nil|number) default: current buffer+---@param bufnr (number|nil) filter by buffer. All buffers if nil, current+---       buffer if 0 function M.force_refresh(bufnr)   vim.validate({     bufnr = { bufnr, 'n', true },   }) -  if bufnr == nil or bufnr == 0 then-    bufnr = api.nvim_get_current_buf()+  local buffers = bufnr == nil and vim.tbl_keys(STHighlighter.active)+    or bufnr == 0 and { api.nvim_get_current_buf() }+    or { bufnr }++  for _, buffer in ipairs(buffers) do+    local highlighter = STHighlighter.active[buffer]+    if highlighter then+      highlighter:reset()+      highlighter:send_request()+    end   end+end +--- Highlight a semantic token by applying an extmark. This extmark will be+--- deleted by the semantic token decoration provider on the next `on_win`+--- update.+---","That's not strictly true. It'll be cleared when a new LSP document version gets an updated token response, or a refresh notification is sent by the LSP server (or if the semantic token engine is detached, etc). ",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/22022,1103715147,2023-02-12T00:29:41Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -378,52 +389,55 @@ function STHighlighter:on_win(topline, botline)       --       -- Instead, we have to use normal extmarks that can attach to locations       -- in the buffer and are persisted between redraws.+      --+      -- `strict = false` is necessary here for the 1% of cases where the+      -- current result doesn't actually match the buffer contents. Some+      -- LSP servers can respond with stale tokens on requests if they are+      -- still processing changes from a didChange notification.+      --+      -- LSP servers that do this _should_ follow up known stale responses+      -- with a refresh notification once they've finished processing the+      -- didChange notification, which would re-synchronize the tokens from+      -- our end.+      --+      -- The server I know of that does this is clangd when the preamble of+      -- a file changes and the token request is processed with a stale+      -- preamble while the new one is still being built. Once the preamble+      -- finishes, clangd sends a refresh request which lets the client+      -- re-synchronize the tokens.++      local set_mark = function(token, hl_group, delta)+        vim.api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {+          hl_group = hl_group,+          end_col = token.end_col,+          priority = vim.highlight.priorities.semantic_tokens + delta,+          strict = false,+        })+      end++      local ft = vim.bo[self.bufnr].filetype       local highlights = current_result.highlights-      local idx = binary_search(highlights, topline)+      local first = lower_bound(highlights, topline, 1, #highlights + 1)+      local last = upper_bound(highlights, botline, first, #highlights + 1) - 1",Do you think this is more performant than checking each token's row against the last visible row? It probably is since the number of visible tokens at any time is probably larger than log(total token count). Good change!,
926528,swarn,https://api.github.com/repos/neovim/neovim/pulls/22022,1103719242,2023-02-12T01:26:31Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -637,23 +651,58 @@ end --- Only has an effect if the buffer is currently active for semantic token --- highlighting (|vim.lsp.semantic_tokens.start()| has been called for it) -------@param bufnr (nil|number) default: current buffer+---@param bufnr (number|nil) filter by buffer. All buffers if nil, current+---       buffer if 0","It's definitely unusual. Most API functions use ""nil means current buffer."" Some exceptions:- `vim.lsp.codelens.clear()` uses ""nil means all buffers"".- `vim.diagnostic.enable()` uses the same ""0 is current, nil is all buffers"" as this.For the rule-based approach, I wanted to ""refresh tokens in all buffers that have them"" on rule changes. That seemed useful enough to add to the API by tweaking the arguments. But if it's too strange/inconsistent, I will revert that change.Without that change, if you do want to refresh all tokens, you either- iterate over _all_ buffers and let `force_refresh` ignore the irrelevant ones- rebuild the list of relevant buffers by iterating over clients, then buffers per client.Neither seems awful, so again, if ""nil means all, 0 means current"" is too weird, I'll delete it.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/22022,1103730238,2023-02-12T03:47:01Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -637,23 +651,58 @@ end --- Only has an effect if the buffer is currently active for semantic token --- highlighting (|vim.lsp.semantic_tokens.start()| has been called for it) -------@param bufnr (nil|number) default: current buffer+---@param bufnr (number|nil) filter by buffer. All buffers if nil, current+---       buffer if 0 function M.force_refresh(bufnr)   vim.validate({     bufnr = { bufnr, 'n', true },   }) -  if bufnr == nil or bufnr == 0 then-    bufnr = api.nvim_get_current_buf()+  local buffers = bufnr == nil and vim.tbl_keys(STHighlighter.active)+    or bufnr == 0 and { api.nvim_get_current_buf() }+    or { bufnr }++  for _, buffer in ipairs(buffers) do+    local highlighter = STHighlighter.active[buffer]+    if highlighter then+      highlighter:reset()+      highlighter:send_request()+    end   end+end +--- Highlight a semantic token by applying an extmark. This extmark will be+--- deleted by the semantic token decoration provider on the next `on_win`+--- update.+---+---@param token (table) a semantic token as returned by+---       |vim.lsp.semantic_tokens.get_at_pos()|+---@param bufnr (number) the buffer to highlight+---@param client_id (number) The ID of the |vim.lsp.client|+---@param hl_group (string) Highlight group name+---@param opts (table|nil) Optional parameters.+---       - priority: (number|nil) Priority for the applied extmark. Defaults+---         to `vim.highlight.priorities.semantic_tokens + 3`+function M.highlight_token(token, bufnr, client_id, hl_group, opts)   local highlighter = STHighlighter.active[bufnr]   if not highlighter then     return   end -  highlighter:reset()-  highlighter:send_request()+  local state = highlighter.client_state[client_id]+  if not state then",I have no idea what I was talking about. I only saw one of the checks and my brain said one was missing. Ignore me.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22207,1103776429,2023-02-12T10:37:19Z,runtime/lua/vim/treesitter/language.lua,"@@ -23,15 +23,21 @@ function M.require_language(lang, path, silent, symbol_name)       error(""'"" .. lang .. ""' is not a valid language name"")     end -    local fname = 'parser/' .. lang .. '.*'-    local paths = a.nvim_get_runtime_file(fname, false)-    if #paths == 0 then+    for _, l in ipairs {lang, symbol_name} do","I'd rather have the user decide what they want instead of nvim trying out multiple paths. If the SO-filename should be configurable, it could be an extra parameter.As I understood https://github.com/nvim-treesitter/nvim-treesitter/pull/4296#issuecomment-1426995523, this to enable `ft` to `lang` mapping like the Lua table that we have in nvim-treesitter. Please note that when you're moving the functionality of mapping `ft` to parser to the `treesitter.c` hashmap, you will load the same parser multiple times as the same SO-parser file can be loaded for multiple `lang`s (`lang` being the key for a loaded parser). Isn't this something that the caller of `require_language` can handle via a simple Lua table mapping? At nvim-treesitter, we always tried to have `ft` and `lang` be separate concepts. ",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22207,1103797576,2023-02-12T12:52:12Z,runtime/lua/vim/treesitter/language.lua,"@@ -23,15 +23,21 @@ function M.require_language(lang, path, silent, symbol_name)       error(""'"" .. lang .. ""' is not a valid language name"")     end -    local fname = 'parser/' .. lang .. '.*'-    local paths = a.nvim_get_runtime_file(fname, false)-    if #paths == 0 then+    for _, l in ipairs {lang, symbol_name} do","> I'd rather have the user decide what they want instead of nvim trying out multiple paths. If the SO-filename should be configurable, it could be an extra parameter.It already is as the second `path` argument.> Please note that when you're moving the functionality of mapping ft to parser to the treesitter.c hashmap, you will load the same parser multiple times as the same SO-parser file can be loaded for multiple langs (lang being the key for a loaded parser).I'm aware of this, and this is just a small implementation deficiency that should be easy enough to resolve. In practice, this will just mean that users with a `bash` and `zsh` buffer open in the same session will have the `sh` parser loaded multiple times. For the majority, this shouldn't be an issue since `filetype` usually maps directly to `lang`.> At nvim-treesitter, we always tried to have ft and lang be separate concepts.I've seen no benefit in keeping this distinction, and for me has only ever caused problems.For example, I've currently had to introduce some awkward logic in https://github.com/neovim/neovim/pull/22191 because `get_parser` defaults to `filetype` for `lang` despite a parser already being associated for a buffer.The end goal I'm working to is that the whole `filetype` -> `lang` relationship is encapsulated to parser installation and management. Everywhere else in any treesitter logic, only filetype should be considered.In this PR I've only looked in both paths (for when `path` isn't provided) just to maintain some compatibility for users who will continue to pass `lang` as the first argument. Once downstream has adapted, which we won't give much time for, we then only search for parsers in `parser/{symbol_name}.so`",X
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/21293,1103872756,2023-02-12T20:42:49Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -0,0 +1,346 @@+local M = {}++local protocol = require('vim.lsp.protocol')+local uv = vim.loop++---@private+---Parses the raw pattern into a number of Lua-native patterns.+---+---@param pattern string The raw glob pattern+---@return table A list of Lua patterns. A match with any of them matches the input glob pattern.+local function parse(pattern)+  local patterns = {""""}++  local path_sep = ""[/\\]""+  local non_path_sep = ""[^/\\]""++  local function append(chunks)+    local new_patterns = {}+    for _, p in ipairs(patterns) do+      for _, chunk in ipairs(chunks) do+        table.insert(new_patterns, p..chunk)+      end+    end+    patterns = new_patterns+  end++  local function split(s, sep)+    local segments = {}+    local segment = """"+    local in_braces = false+    local in_brackets = false+    for i = 1, #s do+      local c = string.sub(s, i, i)+      if c == sep and not in_braces and not in_brackets then+        table.insert(segments, segment)+        segment = """"+      else+        if c == ""{"" then+          in_braces = true+        elseif c == ""}"" then+          in_braces = false+        elseif c == ""["" then+          in_brackets = true+        elseif c == ""]"" then+          in_brackets = false+        end+        segment = segment..c+      end+    end+    if segment ~= """" then table.insert(segments, segment) end+    return segments+  end++  local function escape(c)+    if c == ""?"" or c == ""."" or c == ""("" or c == "")"" or c == ""%"" or+       c == ""["" or c == ""]"" or c == ""*"" or c == ""+"" or c == ""-"" then+      return ""%""..c+    end+    return c+  end++  local segments = split(pattern, ""/"")+  for i, segment in ipairs(segments) do+    local last_seg = i == #segments+    if segment == ""**"" then+      local chunks = {+        path_sep..""-"",+        "".-""..path_sep,+      }+      if last_seg then+        chunks = { "".-"" }+      end+      append(chunks)+    else+      local in_braces = false+      local brace_val = """"+      local in_brackets = false+      local bracket_val = """"+      for j = 1, #segment do+        local char = string.sub(segment, j, j)+        if char ~= ""}"" and in_braces then+          brace_val = brace_val..char+        else+          if in_brackets and (char ~= ""]"" or bracket_val == """") then+            local res+            if char == ""-"" then+              res = char+            elseif bracket_val ~= """" and char == ""!"" then+              res = ""^""+            elseif char == ""**"" then+              res = """"+            else+              res = escape(char)+            end+            bracket_val = bracket_val..res+          else+            if char == ""{"" then+              in_braces = true+            elseif char == ""["" then+              in_brackets = true+            elseif char == ""}"" then+              local choices = split(brace_val, "","")+              local parsed_choices = {}+              for _, choice in ipairs(choices) do+                table.insert(parsed_choices, parse(choice))+              end+              append(vim.tbl_flatten(parsed_choices))+              in_braces = false+              brace_val = """"+            elseif char == ""]"" then+              append({""[""..bracket_val..""]""})+              in_brackets = false+              bracket_val = """"+            elseif char == ""?"" then+              append({non_path_sep})+            elseif char == ""*"" then+              append({non_path_sep..""-""})+            else+              append({escape(char)})+            end+          end+        end+      end++      if not last_seg and (segments[i+1] ~= ""**"" or i+1 < #segments) then+        append({path_sep})+      end+    end+  end++  return patterns+end++---@private+--- Implementation of LSP 3.17.0's pattern matching: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern+--- Modeled after VSCode's implementation: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/common/glob.ts#L509","I was converting those to Lua by hand, nothing automated. I can't think of a good way we could automatically pull in and run VSCode's tests.For reference, these are the tests: https://github.com/microsoft/vscode/blob/0319eed971719ad48e9093daba9d65a5013ec5ab/src/vs/base/test/common/glob.test.ts",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22187,1104203938,2023-02-13T09:35:37Z,src/nvim/api/private/validate.h,"@@ -0,0 +1,44 @@+#ifndef NVIM_API_PRIVATE_VALIDATE_H",introducing a validate.h module in anticipation that we will have more sophisticated validation things for C API in the future.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22187,1104205054,2023-02-13T09:36:35Z,src/nvim/api/vim.c,"@@ -2009,20 +1980,16 @@ Boolean nvim_del_mark(String name, Error *err)   FUNC_API_SINCE(8) {   bool res = false;-  if (name.size != 1) {-    api_set_error(err, kErrorTypeValidation,-                  ""Mark name must be a single character"");+  VALIDATE_S((name.size == 1), ""mark name (must be a single char)"", name.data, {     return res;-  }+  });   // Only allow file/uppercase marks   // TODO(muniter): Refactor this ASCII_ISUPPER macro to a proper function-  if (ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)) {-    res = set_mark(NULL, name, 0, 0, err);-  } else {-    api_set_error(err, kErrorTypeValidation,-                  ""Only file/uppercase marks allowed, invalid mark name: '%c'"",-                  *name.data);-  }+  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),+             ""mark name (must be file/uppercase)"", name.data, {+    return res;+  });+  res = set_mark(NULL, name, 0, 0, err);",this is a nice readability win from inverting the validation condition,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/22260,1106127488,2023-02-14T17:20:48Z,cmake/WindowsDllCopy.cmake,"@@ -23,8 +30,9 @@ foreach(DLL_NAME ${DLLS})     message(FATAL_ERROR ""Unable to find dependency ${DLL_NAME}"")   endif() -  message(""Copying ${DLL_NAME} to ${DST}"")+  if($ENV{CI})","What the? You're right. Weird, I thought I tried this. My bad.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22207,1106318849,2023-02-14T20:08:34Z,runtime/lua/vim/treesitter/language.lua,"@@ -2,19 +2,66 @@ local a = vim.api  local M = {} +---@type table<string,string>+local ft_to_lang = {}++---@param filetype string+---@return string|nil+function M.get_lang(filetype)+  return ft_to_lang[filetype]+end++---@deprecated+function M.require_language(lang, path, silent, symbol_name)",deprecate() ?,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22207,1106347880,2023-02-14T20:41:16Z,runtime/doc/treesitter.txt,"@@ -678,24 +708,12 @@ inspect_language({lang})          *vim.treesitter.language.inspect_language()*     Return: ~         (table) -                                  *vim.treesitter.language.require_language()*-require_language({lang}, {path}, {silent}, {symbol_name})-    Asserts that a parser for the language {lang} is installed.--    Parsers are searched in the `parser` runtime directory, or the provided-    {path}+register({lang}, {filetype})              *vim.treesitter.language.register()*+    Register a lang to be used for a filetype (or list of filetypes).","> Is this something that would be done by filetype plugins?Yes, and also nvim-treesitter / any parser management plugin. But also by the user, e.g: `vim.treesitter.language.register('bash', 'myniche_sh')`. I guess it shares some similarities with `filetype.lua`.>  Is this a ""many to many"" mapping?No, I want this to be a multiple filetypes to a single lang mapping (mentioned in the OP). I really don't think there is a justifiable (or existing) use case for any filetype needing to use multiple parsers at the top level. Every exotic application I've seen would be handled by a complicated parser and/or language injections.> Any way to make this passive (via some file in 'runtimepath')? Instead of ""active"" state managed at runtime.The problem with the files in runtimepath method is that it makes it very difficult to redefine/override. I believe this is why `after/` was created. Also, I don't know what a ""passive"" mechanism would look like, though open to suggestions or discussion. I can only think of a method where maybe `ftplugin` files have some directive to say what parser they should use (maybe setting a future `'lang'` option), and this would be set per buffer as opposed to what I've done here which keeps a separate side table.I guess the way to look at it is, ""I want to provide this parser. This is what filetypes it can work with"" as opposed to ""setting up filetype, use this parser"". I think this makes more sense since the filetypes are sort of standardized.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22207,1106886838,2023-02-15T09:42:19Z,runtime/doc/treesitter.txt,"@@ -678,24 +708,12 @@ inspect_language({lang})          *vim.treesitter.language.inspect_language()*     Return: ~         (table) -                                  *vim.treesitter.language.require_language()*-require_language({lang}, {path}, {silent}, {symbol_name})-    Asserts that a parser for the language {lang} is installed.--    Parsers are searched in the `parser` runtime directory, or the provided-    {path}+register({lang}, {filetype})              *vim.treesitter.language.register()*",Would an interface like `vim.treesitter.config()` similar to `vim.diagnostic.config()` make sense? Perhaps that helps discoverability.,
6927259,mliszcz,https://api.github.com/repos/neovim/neovim/pulls/22267,1106963505,2023-02-15T10:49:25Z,runtime/lua/vim/lsp.lua,"@@ -1093,19 +1093,29 @@ function lsp.start_client(config)     end   end +  ---@private+  -- Determines whether the given option can be set by `set_defaults`.+  local function is_empty_or_default(bufnr, option)+    if vim.bo[bufnr][option] == '' then+      return true+    end+    local last_set_from = vim.fn.gettext('\n\tLast set from ')+    return not not vim.fn.execute('verbose set ' .. option .. '?'):match(last_set_from .. '.*ftplugin')","@clasonWhere should `-V1` go? This is not mentioned in the docs (https://neovim.io/doc/user/api.html).The second parameter (opts) is either scope, buf or win.```:lua print(vim.api.nvim_get_option_value('omnifunc', {})) ```@glepnirYes it if is set from lua file it does work as you say. However, the goal of this PR is to overwrite only values set by builtin ftplugins shipped with neovim. All of them are implemented in vimscript right now. I think those are inherited from vim and will stay as vimscript files, right? You can find the list of impacted languages in the corresponding issue.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22128,1106964551,2023-02-15T10:50:27Z,test/functional/options/defaults_spec.lua,"@@ -583,6 +587,23 @@ describe('stdpath()', function()     assert_alive()  -- Check for crash. #8393   end) +  it('reacts to #NVIM_APPNAME', function()+    local appname = ""NVIM_APPNAME_TEST""","also need to test a very long name, to check that buffer overflow is handled",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22267,1106975209,2023-02-15T10:59:41Z,runtime/lua/vim/lsp.lua,"@@ -1093,19 +1093,29 @@ function lsp.start_client(config)     end   end +  ---@private+  -- Determines whether the given option can be set by `set_defaults`.+  local function is_empty_or_default(bufnr, option)+    if vim.bo[bufnr][option] == '' then+      return true+    end+    local last_set_from = vim.fn.gettext('\n\tLast set from ')+    return not not vim.fn.execute('verbose set ' .. option .. '?'):match(last_set_from .. '.*ftplugin')","checking `$VIMRUNTIME` seems like a good idea.Also need a test exercising this. Hopefully just add some checks in here : https://github.com/neovim/neovim/blob/2e450efb9525308708dd9e26d6ea1d029ac781b8/test/functional/plugin/lsp_spec.lua#L278 or, alas, maybe need to copy-paste that test and create a `it('sets defaults')` test.",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22207,1107032695,2023-02-15T11:58:41Z,runtime/doc/treesitter.txt,"@@ -678,24 +708,12 @@ inspect_language({lang})          *vim.treesitter.language.inspect_language()*     Return: ~         (table) -                                  *vim.treesitter.language.require_language()*-require_language({lang}, {path}, {silent}, {symbol_name})-    Asserts that a parser for the language {lang} is installed.--    Parsers are searched in the `parser` runtime directory, or the provided-    {path}+register({lang}, {filetype})              *vim.treesitter.language.register()*","Maybe. We could have something like: `vim.treesitter.config([lang}, {opts})`:```luavim.treesitter.config('bash', {  filetype = {'bash', 'sh'},  ???})```I think this only works though if a specific language can be configured once. This won't be ideal If a user also wants to further setup the `bash` language to also handle the `PKGBUILD` filetype.I think most configuration points for treesitter are actually configured passively by the presence of query files: highlights, indent, folding.As an example that this could be similar too, here's what I have to configure nvim-treesitter:```luarequire'nvim-treesitter.configs'.setup {  ensure_installed = {    ""bash"", ""c"", ""help"", ""html"", ""json"", ""lua"", ""make""  },  highlight = {    enable = true,  },  indent = {    enable = true,    is_supported = function(lang)      return ({        lua = true,        c = true,        tcl = true      })[lang] or false    end  },  incremental_selection = {    enable = true,    keymaps = {      init_selection    = ""gnn"",      node_incremental  = ""grn"",      scope_incremental = ""grc"",      node_decremental  = ""grm"",    },  },  fold = {    enable = true,    disable = {'rst', 'make'}  },  playground = { enable = true },  context_commentstring = { enable = true },  query_linter = {    enable = true,    use_virtual_text = true,    lint_events = {""BufWrite"", ""CursorMoved""},  },}```I'm not sure this kind of config makes sense for a language provider.Currently, a language provider provides:- A parser (either directly or indirectly).- A collection of queries under `queries/{lang}/`.- Custom directives and predicates for queries (via `plugin/` I'd imagine).- [This PR] a directive which says what filetypes the language aims to target.Regardless, despite whether `vim.treesitter.config()` is a good idea, I think adding something like `register` should be fine as it is more low level (and can be removed if we change our minds).",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22207,1107044958,2023-02-15T12:10:58Z,runtime/doc/treesitter.txt,"@@ -678,24 +708,12 @@ inspect_language({lang})          *vim.treesitter.language.inspect_language()*     Return: ~         (table) -                                  *vim.treesitter.language.require_language()*-require_language({lang}, {path}, {silent}, {symbol_name})-    Asserts that a parser for the language {lang} is installed.--    Parsers are searched in the `parser` runtime directory, or the provided-    {path}+register({lang}, {filetype})              *vim.treesitter.language.register()*","In nvim-treesitter, we also first had the approach that the user could provide a parser config with filetype associated. Internally, we had to invert the mapping similar way as it is done in this PR, because we actually we needed a filetype to lang mapping. Users sometimes had problems configuring the parser for one specific filetype. To do that they had to remove that filetype from the one parser config and add it to the other. Often they only added it to the alternative parser config and had then semi-random behavior (depending on which parser config registered first).We ended up exposing the formally private map and discouraged setting filetypes on parser configs. As this was a more direct way for the users to express what should happen with each filetype.Probably, this won't repeat with this API as users would then just do their register calls after nvim-treesitter which would then just overwrite what nvim-treesitter didn't before. Which should avoid the mentioned confusion. There is still the risks that a user by mistake has a filetype in two of their parser configs.  ",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22207,1107147656,2023-02-15T13:47:49Z,runtime/doc/treesitter.txt,"@@ -678,24 +708,12 @@ inspect_language({lang})          *vim.treesitter.language.inspect_language()*     Return: ~         (table) -                                  *vim.treesitter.language.require_language()*-require_language({lang}, {path}, {silent}, {symbol_name})-    Asserts that a parser for the language {lang} is installed.--    Parsers are searched in the `parser` runtime directory, or the provided-    {path}+register({lang}, {filetype})              *vim.treesitter.language.register()*","> Can't config() start out with the impl of register() here? I'm hoping we can avoid the extra surface area. This is a configuration task, after all.The existing `config` model doesn't work well with multiple sources, so I'm unsure about introducing that right now without a more thought out design. I'd assume config would exist at `vim.treesitter.config()` (higher level) as opposed to `vim.treesitter.language.register()` (low level).As far as surface area is concerned, I think a more pragmatic approach for treesitter should be more (but not totally) white-box for the time being, I.e. more things are accessible from the outside as this allows more experimentation from downstream. We can do this until we can figure out the exact shape we want things to take, and at that point we can begin to deprecate and private parts we want to unexpose. We may even need to iterate several times in some areas (like we already have). What's important is that we maintain progress.My desired goal is that `register` becomes internal only and that `lang` becomes a mostly unimportant detail that's only needed when managing the parsers and queries.>  register does have this problem and would preferably be called in ftplugins so a filetype can select their parser rather than having parsers select their filetype.You're right. I was vaguely aware of this when putting this together and considered adding extra validation to detect such conflicts. For now, I decided on a passive approach of last wins, with the prospect of tightening this up in the future if it continues to be a problem. We have a similar problem with highlight groups (mostly solved with `default`), and syntax files (kind of solved with `after`).",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22207,1108392876,2023-02-16T12:16:03Z,runtime/lua/vim/treesitter/language.lua,"@@ -2,19 +2,66 @@ local a = vim.api  local M = {} +---@type table<string,string>+local ft_to_lang = {}++---@param filetype string+---@return string|nil+function M.get_lang(filetype)+  return ft_to_lang[filetype]+end++---@deprecated+function M.require_language(lang, path, silent, symbol_name)",Our doc flow seems to only recognize `@deprecated`,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22207,1108399337,2023-02-16T12:22:43Z,runtime/lua/vim/treesitter/language.lua,"@@ -2,19 +2,66 @@ local a = vim.api  local M = {} +---@type table<string,string>+local ft_to_lang = {}++---@param filetype string+---@return string|nil+function M.get_lang(filetype)+  return ft_to_lang[filetype]+end++---@deprecated+function M.require_language(lang, path, silent, symbol_name)","Oh, you mean use `vim.deprecate()`",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22207,1110974795,2023-02-18T09:53:10Z,runtime/lua/vim/treesitter/language.lua,"@@ -2,19 +2,66 @@ local a = vim.api  local M = {} +---@type table<string,string>+local ft_to_lang = {}++---@param filetype string+---@return string|nil+function M.get_lang(filetype)+  return ft_to_lang[filetype]+end++---@deprecated+function M.require_language(lang, path, silent, symbol_name)",I added a call to `vim.deprecate` but I think the notify is a bit been obtrusive. We can add it later when at least nvim-treesitter adapts. `require_language` is just an alias for `add` anyway.,
67451164,sekerez,https://api.github.com/repos/neovim/neovim/pulls/20801,1111377995,2023-02-20T01:43:29Z,runtime/plugin/autoread.vim,"@@ -0,0 +1,7 @@+"" autocommands for starting filesystem based file watcher++augroup autoread+    autocmd!+    au BufRead,BufWritePost,FileWritePost,FileAppendPost * call v:lua.vim._watch.start(expand(""<abuf>""))+    au BufDelete,BufUnload,BufWritePre,FileWritePre,FileAppendPre * call v:lua.vim._watch.stop(expand(""<abuf>""))+augroup END","If `start` and `stop` took in a number rather than a string, I think something like the following could work:```lua-- autocommands for starting filesystem based file watcherlocal watcher_callback = function(handler)  return function() handler(tonumber(vim.fn.expand(""<abuf>""))) endendlocal watchgroup = vim.api.nvim_create_augroup(""watchgroup"", { clear = true })vim.api.nvim_create_autocmd({  ""BufRead"", ""BufWritePost"", ""FileWritePost"", ""FileAppendPost""}, {  pattern = ""*"",  group = watchgroup,  callback = watcher_callback(vim._watch.start)})vim.api.nvim_create_autocmd({  ""BufDelete"", ""BufUnload"", ""BufWritePre"", ""FileWritePre"", ""FileAppendPre""}, {  pattern = ""*"",  group = watchgroup,  callback = watcher_callback(vim._watch.stop)})```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22299,1112973638,2023-02-21T12:15:01Z,runtime/lua/vim/treesitter/_fold.lua,"@@ -0,0 +1,156 @@+local api = vim.api++local M = {}++--- Memoizes a function based on the buffer tick of the provided bufnr.+--- The cache entry is cleared when the buffer is detached to avoid memory leaks.+---@generic F: function+---@param fn F fn to memoize, taking the bufnr as first argument+---@return F+local function memoize_by_changedtick(fn)","Out of scope for this PR, but this could be useful as a generic stdlib feature. Similar to python's [lru_cache](https://docs.python.org/3/library/functools.html#functools.lru_cache).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22325,1113755198,2023-02-22T02:14:27Z,runtime/lua/vim/semver.lua,"@@ -0,0 +1,263 @@+local M = {}++---@private+--- Compares the prerelease component of the two versions.+---@param v1_parsed table Parsed version.+---@param v2_parsed table Parsed version.+---@return integer `-1` if `v1_parsed < v2_parsed`, `0` if `v1_parsed == v2_parsed`, `1` if `v1_parsed > v2_parsed`.+local function cmp_prerelease(v1_parsed, v2_parsed)+  if v1_parsed.prerelease and not v2_parsed.prerelease then+    return -1+  end+  if not v1_parsed.prerelease and v2_parsed.prerelease then+    return 1+  end+  if not v1_parsed.prerelease and not v2_parsed.prerelease then+    return 0+  end++  local v1_identifiers = vim.split(v1_parsed.prerelease, '.', { plain = true })+  local v2_identifiers = vim.split(v2_parsed.prerelease, '.', { plain = true })+  local i = 1+  local max = math.max(vim.tbl_count(v1_identifiers), vim.tbl_count(v2_identifiers))+  while i <= max do+    local v1_identifier = v1_identifiers[i]+    local v2_identifier = v2_identifiers[i]+    if v1_identifier ~= v2_identifier then+      local v1_num = tonumber(v1_identifier)+      local v2_num = tonumber(v2_identifier)+      local is_number = v1_num and v2_num+      if is_number then+        -- Number comparisons+        if not v1_num and v2_num then+          return -1+        end+        if v1_num and not v2_num then+          return 1+        end+        if v1_num == v2_num then+          return 0+        end+        if v1_num > v2_num then+          return 1+        end+        if v1_num < v2_num then+          return -1+        end+      else+        -- String comparisons+        if v1_identifier and not v2_identifier then+          return 1+        end+        if not v1_identifier and v2_identifier then+          return -1+        end+        if v1_identifier < v2_identifier then+          return -1+        end+        if v1_identifier > v2_identifier then+          return 1+        end+        if v1_identifier == v2_identifier then+          return 0+        end+      end+    end+    i = i + 1+  end++  return 0+end++---@private+--- Compares the version core component of the two versions.+---@param v1_parsed table Parsed version.+---@param v2_parsed table Parsed version.+---@return integer `-1` if `v1_parsed < v2_parsed`, `0` if `v1_parsed == v2_parsed`, `1` if `v1_parsed > v2_parsed`.+local function cmp_version_core(v1_parsed, v2_parsed)+  if+    v1_parsed.major == v2_parsed.major+    and v1_parsed.minor == v2_parsed.minor+    and v1_parsed.patch == v2_parsed.patch+  then+    return 0+  end++  if+    v1_parsed.major > v2_parsed.major+    or v1_parsed.minor > v2_parsed.minor+    or v1_parsed.patch > v2_parsed.patch+  then+    return 1+  end++  return -1+end++--- Compares two strings (`v1` and `v2`) in semver format.+---@param v1 string Version.+---@param v2 string Version to be compared with v1.+---@param opts table|nil Optional keyword arguments:+---                      - strict (boolean):  see `semver.parse` for details. Defaults to false.+---@return integer `-1` if `v1 < v2`, `0` if `v1 == v2`, `1` if `v1 > v2`.+function M.cmp(v1, v2, opts)+  opts = opts or { strict = false }+  local v1_parsed = M.parse(v1, opts)+  local v2_parsed = M.parse(v2, opts)++  local result = cmp_version_core(v1_parsed, v2_parsed)+  if result == 0 then+    result = cmp_prerelease(v1_parsed, v2_parsed)+  end+  return result+end++---@private+---@param labels string Prerelease and build component of semantic version string e.g. ""-rc1+build.0"".+---@return string|nil+local function parse_prerelease(labels)+  -- This pattern matches ""-(alpha)+build.15"".+  local result = labels:match('^-([^+]+)+.+$')+  if result then+    return result+  end+  -- This pattern matches ""-(alpha)"".+  result = labels:match('^-([^+]+)$')+  if result then+    return result+  end++  return nil+end++---@private+---@param labels string Prerelease and build component of semantic version string e.g. ""-rc1+build.0"".+---@return string|nil+local function parse_build(labels)+  -- Pattern matches ""-alpha+(build.15)"".+  local result = labels:match('^-[^+]++(.+)$')+  if result then+    return result+  end++  -- Pattern matches ""+(build.15)"".+  result = labels:match('^%+(%w[%.%w-]*)$')+  if result then+    return result+  end++  return nil+end++---@private+--- Extracts the major, minor, patch and preprelease and build components from+--- `version`.+---@param version string Version string+local function extract_components_strict(version)+  local major, minor, patch, prerelease_and_build = version:match('^v?(%d+)%.(%d+)%.(%d+)(.*)$')+  return tonumber(major), tonumber(minor), tonumber(patch), prerelease_and_build+end++---@private+--- Extracts the major, minor, patch and preprelease and build components from+--- `version`. When `minor` and `patch` components are not found (nil), coerce+--- them to 0.+---@param version string Version string+local function extract_components_loose(version)+  local major, minor, patch, prerelease_and_build = version:match('^v?(%d+)%.?(%d*)%.?(%d*)(.*)$')+  major = tonumber(major)+  minor = tonumber(minor) or 0+  patch = tonumber(patch) or 0+  return major, minor, patch, prerelease_and_build+end++---@private+--- Validates the prerelease and build string e.g. ""-rc1+build.0"". If the+--- prerelease, build or both are valid forms then it will return true, if it+--- is not of any valid form, it will return false.+---@param prerelease_and_build string+---@return boolean+local function is_prerelease_and_build_valid(prerelease_and_build)+  local has_build = prerelease_and_build:match('^%+[%w%.]+$')+  local has_prerelease = prerelease_and_build:match('^%-[%w%.]+$')+  local has_prerelease_and_build = prerelease_and_build:match('^%-[%w%.]+%+[%w%.]+')+  return has_build or has_prerelease or has_prerelease_and_build+end++---@private+---@param prerelease_and_build string+---@return boolean+local function has_prerelease_and_build(prerelease_and_build)+  return prerelease_and_build ~= nil and prerelease_and_build ~= ''+end++---@private+---@param version string+---@return string+local function create_err_msg(version)+  return string.format('%s is not a valid version', version)+end++--- Parses a semantically formatted version string into a table.+---+--- Supports leading ""v"" and leading and trailing whitespace in the version+--- string. e.g. `"" v1.0.1-rc1+build.2""` , `""1.0.1-rc1+build.2""`, `""v1.0.1-rc1+build.2""`+--- and `""v1.0.1-rc1+build.2 ""` will be parsed as:+---+--- `{ major = 1, minor = 0, patch = 1, prerelease = 'rc1', build = 'build.2' }`+---+---@param version string Version string to be parsed.+---@param opts table|nil Optional keyword arguments:+---                      - strict (boolean):  when set to `true` an error will be thrown for version+---                      strings which are not conforming to semver sepecifications (v2.0.0), (see+---                      semver.org/spec/v2.0.0.html for details), this means that+---                      `semver.parse('v1.2)` will throw an error. When set to `false`,+---                      `semver.parse('v1.2)` will coerce 'v1.2' to 'v1.2.0' and return the table:+---                      `{ major = 1, minor = 2, patch = 0 }`. Defaults to false.+---@return table parsed_version Parsed version table+function M.parse(version, opts)+  if type(version) ~= 'string' then+    error(create_err_msg(version))+  end++  opts = opts or { strict = false }++  version = vim.trim(version)++  local major, minor, patch, prerelease_and_build+  if opts.strict then+    major, minor, patch, prerelease_and_build = extract_components_strict(version)+  else+    major, minor, patch, prerelease_and_build = extract_components_loose(version)+  end","ternary saves space, eliminates redundant code, and helps readability```suggestion  local major, minor, patch, prerelease_and_build = (opts.strict    and extract_components_strict(version)    or extract_components_loose(version))```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22357,1114121215,2023-02-22T10:19:39Z,runtime/lua/vim/treesitter.lua,"@@ -153,7 +153,7 @@ end  --- Returns the node's range or an unpacked range table -------@param node_or_range (TSNode|table) Node or table of positions+---@param node_or_range (TSNode | table) Node or table of positions","Those links are a bit helpful, though -- and I did a similar thing manually for `LanguageTree`, which makes me wonder whether it's worth looking at a more generic approach for ""Lua objects"" that can be made robust?",
19686599,kelly-lin,https://api.github.com/repos/neovim/neovim/pulls/22325,1114164008,2023-02-22T10:55:37Z,runtime/lua/vim/semver.lua,"@@ -0,0 +1,263 @@+local M = {}++---@private+--- Compares the prerelease component of the two versions.+---@param v1_parsed table Parsed version.+---@param v2_parsed table Parsed version.+---@return integer `-1` if `v1_parsed < v2_parsed`, `0` if `v1_parsed == v2_parsed`, `1` if `v1_parsed > v2_parsed`.+local function cmp_prerelease(v1_parsed, v2_parsed)+  if v1_parsed.prerelease and not v2_parsed.prerelease then+    return -1+  end+  if not v1_parsed.prerelease and v2_parsed.prerelease then+    return 1+  end+  if not v1_parsed.prerelease and not v2_parsed.prerelease then+    return 0+  end++  local v1_identifiers = vim.split(v1_parsed.prerelease, '.', { plain = true })+  local v2_identifiers = vim.split(v2_parsed.prerelease, '.', { plain = true })+  local i = 1+  local max = math.max(vim.tbl_count(v1_identifiers), vim.tbl_count(v2_identifiers))+  while i <= max do+    local v1_identifier = v1_identifiers[i]+    local v2_identifier = v2_identifiers[i]+    if v1_identifier ~= v2_identifier then+      local v1_num = tonumber(v1_identifier)+      local v2_num = tonumber(v2_identifier)+      local is_number = v1_num and v2_num+      if is_number then+        -- Number comparisons+        if not v1_num and v2_num then+          return -1+        end+        if v1_num and not v2_num then+          return 1+        end+        if v1_num == v2_num then+          return 0+        end+        if v1_num > v2_num then+          return 1+        end+        if v1_num < v2_num then+          return -1+        end+      else+        -- String comparisons+        if v1_identifier and not v2_identifier then+          return 1+        end+        if not v1_identifier and v2_identifier then+          return -1+        end+        if v1_identifier < v2_identifier then+          return -1+        end+        if v1_identifier > v2_identifier then+          return 1+        end+        if v1_identifier == v2_identifier then+          return 0+        end+      end+    end+    i = i + 1+  end++  return 0+end++---@private+--- Compares the version core component of the two versions.+---@param v1_parsed table Parsed version.+---@param v2_parsed table Parsed version.+---@return integer `-1` if `v1_parsed < v2_parsed`, `0` if `v1_parsed == v2_parsed`, `1` if `v1_parsed > v2_parsed`.+local function cmp_version_core(v1_parsed, v2_parsed)+  if+    v1_parsed.major == v2_parsed.major+    and v1_parsed.minor == v2_parsed.minor+    and v1_parsed.patch == v2_parsed.patch+  then+    return 0+  end++  if+    v1_parsed.major > v2_parsed.major+    or v1_parsed.minor > v2_parsed.minor+    or v1_parsed.patch > v2_parsed.patch+  then+    return 1+  end++  return -1+end++--- Compares two strings (`v1` and `v2`) in semver format.+---@param v1 string Version.+---@param v2 string Version to be compared with v1.+---@param opts table|nil Optional keyword arguments:+---                      - strict (boolean):  see `semver.parse` for details. Defaults to false.+---@return integer `-1` if `v1 < v2`, `0` if `v1 == v2`, `1` if `v1 > v2`.+function M.cmp(v1, v2, opts)+  opts = opts or { strict = false }+  local v1_parsed = M.parse(v1, opts)+  local v2_parsed = M.parse(v2, opts)++  local result = cmp_version_core(v1_parsed, v2_parsed)+  if result == 0 then+    result = cmp_prerelease(v1_parsed, v2_parsed)+  end+  return result+end++---@private+---@param labels string Prerelease and build component of semantic version string e.g. ""-rc1+build.0"".+---@return string|nil+local function parse_prerelease(labels)+  -- This pattern matches ""-(alpha)+build.15"".+  local result = labels:match('^-([^+]+)+.+$')+  if result then+    return result+  end+  -- This pattern matches ""-(alpha)"".+  result = labels:match('^-([^+]+)$')+  if result then+    return result+  end++  return nil+end++---@private+---@param labels string Prerelease and build component of semantic version string e.g. ""-rc1+build.0"".+---@return string|nil+local function parse_build(labels)+  -- Pattern matches ""-alpha+(build.15)"".+  local result = labels:match('^-[^+]++(.+)$')+  if result then+    return result+  end++  -- Pattern matches ""+(build.15)"".+  result = labels:match('^%+(%w[%.%w-]*)$')+  if result then+    return result+  end++  return nil+end++---@private+--- Extracts the major, minor, patch and preprelease and build components from+--- `version`.+---@param version string Version string+local function extract_components_strict(version)+  local major, minor, patch, prerelease_and_build = version:match('^v?(%d+)%.(%d+)%.(%d+)(.*)$')+  return tonumber(major), tonumber(minor), tonumber(patch), prerelease_and_build+end++---@private+--- Extracts the major, minor, patch and preprelease and build components from+--- `version`. When `minor` and `patch` components are not found (nil), coerce+--- them to 0.+---@param version string Version string+local function extract_components_loose(version)+  local major, minor, patch, prerelease_and_build = version:match('^v?(%d+)%.?(%d*)%.?(%d*)(.*)$')+  major = tonumber(major)+  minor = tonumber(minor) or 0+  patch = tonumber(patch) or 0+  return major, minor, patch, prerelease_and_build+end++---@private+--- Validates the prerelease and build string e.g. ""-rc1+build.0"". If the+--- prerelease, build or both are valid forms then it will return true, if it+--- is not of any valid form, it will return false.+---@param prerelease_and_build string+---@return boolean+local function is_prerelease_and_build_valid(prerelease_and_build)+  local has_build = prerelease_and_build:match('^%+[%w%.]+$')+  local has_prerelease = prerelease_and_build:match('^%-[%w%.]+$')+  local has_prerelease_and_build = prerelease_and_build:match('^%-[%w%.]+%+[%w%.]+')+  return has_build or has_prerelease or has_prerelease_and_build+end++---@private+---@param prerelease_and_build string+---@return boolean+local function has_prerelease_and_build(prerelease_and_build)+  return prerelease_and_build ~= nil and prerelease_and_build ~= ''+end++---@private+---@param version string+---@return string+local function create_err_msg(version)+  return string.format('%s is not a valid version', version)+end++--- Parses a semantically formatted version string into a table.+---+--- Supports leading ""v"" and leading and trailing whitespace in the version+--- string. e.g. `"" v1.0.1-rc1+build.2""` , `""1.0.1-rc1+build.2""`, `""v1.0.1-rc1+build.2""`+--- and `""v1.0.1-rc1+build.2 ""` will be parsed as:+---+--- `{ major = 1, minor = 0, patch = 1, prerelease = 'rc1', build = 'build.2' }`+---+---@param version string Version string to be parsed.+---@param opts table|nil Optional keyword arguments:+---                      - strict (boolean):  when set to `true` an error will be thrown for version+---                      strings which are not conforming to semver sepecifications (v2.0.0), (see+---                      semver.org/spec/v2.0.0.html for details), this means that+---                      `semver.parse('v1.2)` will throw an error. When set to `false`,+---                      `semver.parse('v1.2)` will coerce 'v1.2' to 'v1.2.0' and return the table:+---                      `{ major = 1, minor = 2, patch = 0 }`. Defaults to false.+---@return table parsed_version Parsed version table+function M.parse(version, opts)+  if type(version) ~= 'string' then+    error(create_err_msg(version))+  end++  opts = opts or { strict = false }++  version = vim.trim(version)++  local major, minor, patch, prerelease_and_build+  if opts.strict then+    major, minor, patch, prerelease_and_build = extract_components_strict(version)+  else+    major, minor, patch, prerelease_and_build = extract_components_loose(version)+  end","An alternative might be:```  local extract = opts.strict and extract_components_strict or extract_components_loose  local major, minor, patch, prerelease_and_build = extract(version)```Thoughts?",
926528,swarn,https://api.github.com/repos/neovim/neovim/pulls/22022,1115882788,2023-02-23T15:40:51Z,runtime/lua/vim/_inspector.lua,"@@ -177,13 +184,8 @@ function vim.show_pos(bufnr, row, col, filter)   if #items.semantic_tokens > 0 then     append('Semantic Tokens', 'Title')     nl()-    for _, token in ipairs(items.semantic_tokens) do-      local client = vim.lsp.get_client_by_id(token.client_id)-      client = client and (' (' .. client.name .. ')') or ''-      item(token.hl_groups.type, 'type' .. client)-      for _, modifier in ipairs(token.hl_groups.modifiers) do-        item(modifier, 'modifier' .. client)","It does display the modifiers. Here is a sample of the current output of `:Inspect`:![inspect_output](https://user-images.githubusercontent.com/926528/220954105-506eb563-2ddb-4e27-afa7-fbd7afbed8d3.png)I modified the inspector logic: instead of replicating the token-to-highlight logic from `semantic_tokens.lua`, it now simply finds all extmarks set by the semantic token engine (as determined by their namespace). In addition to avoiding repetition, this has the practical benefit of showing any non-default token highlights set by the user.I also made a minor tweak to show the highlight priorities for the semantic tokens, which will hopefully reduce any future confusion about ""why is my highlight not showing?""",X
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/22378,1117171181,2023-02-24T15:19:16Z,runtime/doc/lua.txt,"@@ -2359,26 +2359,33 @@ find({names}, {opts})                                          *vim.fs.find()*     The search can be narrowed to find only files or only directories by     specifying {type} to be ""file"" or ""directory"", respectively. +    If {names} is a function, it is called for each file and directory within+    the traversed directory and it would be passed the base name of each file+    or directory and the path of the directory being traversed. The function+    should return `true` if the given file or directory is considered a match.","Sorry if I wasn't clear, I was suggesting that this should be in the description of the `{names}` parameter below.My suggestion was a bit prolix, feel free to condense it. Really all I want to see is that someone who's never used this function before can read the docstring and have clarity on what it means for `{names}` to be a function and how that function works (i.e. it takes two arguments, what those arguments are, and what the function should return).This is also a case where an example is worth a thousand words.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22394,1117780442,2023-02-24T22:54:34Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -174,16 +179,19 @@ function LanguageTree:parse()         vim.list_extend(changes, tree_changes)","Upstream tree-sitter does not define anything about multiple trees or multiple languages, at all. It is up to us to decide what high level concepts we want here. Forcing multiple regions of the same language to be in the the same parse tree might simplify some stuff but it would imply a parse error in region A will affect independent region B even if they are far apart, just because they are in the same language (think multiple unrelated `vim.cmd` embeddings of vim script inside lua)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22397,1117900325,2023-02-25T10:29:43Z,runtime/lua/vim/lsp.lua,"@@ -1967,7 +1964,7 @@ end --  Unlike `buf_request`, this will collect all the responses from each server instead of handling them. --  A map of client_id:request_result will be provided to the callback ------@returns (function) A function that will cancel all requests which is the same as the one returned from `buf_request`.+---@return fun() # A function that will cancel all requests which is the same as the one returned from `buf_request`.","> But maybe worth adding some extra logic to the doc generator to strip such a prefix.Yes, that would be best. There's a bunch of other places in the code with a similar problem.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22401,1117904533,2023-02-25T11:07:53Z,runtime/doc/treesitter.txt,"@@ -180,6 +196,9 @@ TSNode:descendant_for_range({start_row}, {start_col}, {end_row}, {end_col}) TSNode:named_descendant_for_range({start_row}, {start_col}, {end_row}, {end_col})     Get the smallest named node within this node that spans the given range of     (row, column) positions+                                                        *TSNode:equal()*+TSNode:equal({node})+    Check if two nodes are identical.",How about```Check if {node} is part of the same |TSTree| and has the same `id`.```https://github.com/tree-sitter/tree-sitter/blob/c51896d32dcc11a38e41f36e3deb1a6a9c4f4b14/lib/src/node.c#L430-L432,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22401,1117906422,2023-02-25T11:23:29Z,runtime/doc/treesitter.txt,"@@ -180,6 +196,9 @@ TSNode:descendant_for_range({start_row}, {start_col}, {end_row}, {end_col}) TSNode:named_descendant_for_range({start_row}, {start_col}, {end_row}, {end_col})     Get the smallest named node within this node that spans the given range of     (row, column) positions+                                                        *TSNode:equal()*+TSNode:equal({node})+    Check if two nodes are identical.",That sounds too technical. The point is they refer to _the same_ node within the same tree. checking the id is just the efficient way to verify that.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22401,1117906495,2023-02-25T11:23:58Z,runtime/doc/treesitter.txt,"@@ -180,6 +196,9 @@ TSNode:descendant_for_range({start_row}, {start_col}, {end_row}, {end_col}) TSNode:named_descendant_for_range({start_row}, {start_col}, {end_row}, {end_col})     Get the smallest named node within this node that spans the given range of     (row, column) positions+                                                        *TSNode:equal()*+TSNode:equal({node})+    Check if two nodes are identical.","Dam, this makes it basically useless. I'll keep it in, but I don't have a use for this. Thanks for looking into it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22431,1118823941,2023-02-27T14:30:34Z,runtime/lua/vim/treesitter/health.lua,"@@ -2,33 +2,32 @@ local M = {} local ts = vim.treesitter local health = require('vim.health') ---- Lists the parsers currently installed--------@return string[] list of parser files-function M.list_parsers()-  return vim.api.nvim_get_runtime_file('parser/*', true)-end- --- Performs a healthcheck for treesitter integration function M.check()-  local parsers = M.list_parsers()+  local parsers = vim.api.nvim_get_runtime_file('parser/*', true)    health.report_info(string.format('Nvim runtime ABI version: %d', ts.language_version))    for _, parser in pairs(parsers) do     local parsername = vim.fn.fnamemodify(parser, ':t:r')-    local is_loadable, ret = pcall(ts.language.add, parsername)+    local is_loadable, err_or_nil = pcall(ts.language.add, parsername) -    if not is_loadable or not ret then+    if not is_loadable then       health.report_error(-        string.format('Parser ""%s"" failed to load (path: %s): %s', parsername, parser, ret or '?')-      )-    elseif ret then-      local lang = ts.language.inspect_language(parsername)-      health.report_ok(-        string.format('Parser: %-10s ABI: %d, path: %s', parsername, lang._abi_version, parser)+        string.format(+          'Parser ""%s"" failed to load (path: %s): %s',+          parsername,+          parser,+          err_or_nil or '?'+        )       )+      return",return here means not all parsers will be listed if one fails,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22431,1118840414,2023-02-27T14:42:19Z,runtime/lua/vim/treesitter/health.lua,"@@ -2,33 +2,32 @@ local M = {} local ts = vim.treesitter local health = require('vim.health') ---- Lists the parsers currently installed--------@return string[] list of parser files-function M.list_parsers()-  return vim.api.nvim_get_runtime_file('parser/*', true)-end- --- Performs a healthcheck for treesitter integration function M.check()-  local parsers = M.list_parsers()+  local parsers = vim.api.nvim_get_runtime_file('parser/*', true)    health.report_info(string.format('Nvim runtime ABI version: %d', ts.language_version))    for _, parser in pairs(parsers) do     local parsername = vim.fn.fnamemodify(parser, ':t:r')-    local is_loadable, ret = pcall(ts.language.add, parsername)+    local is_loadable, err_or_nil = pcall(ts.language.add, parsername) -    if not is_loadable or not ret then+    if not is_loadable then       health.report_error(-        string.format('Parser ""%s"" failed to load (path: %s): %s', parsername, parser, ret or '?')-      )-    elseif ret then-      local lang = ts.language.inspect_language(parsername)-      health.report_ok(-        string.format('Parser: %-10s ABI: %d, path: %s', parsername, lang._abi_version, parser)+        string.format(+          'Parser ""%s"" failed to load (path: %s): %s',+          parsername,+          parser,+          err_or_nil or '?'+        )       )+      return",ah my bad. Didn't realize this was in a loop,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22382,1119055109,2023-02-27T17:23:38Z,src/nvim/api/ui.c,"@@ -351,6 +348,7 @@ static void ui_set_option(UI *ui, bool init, String name, Object value, Error *e     });      stdin_fd = (int)value.data.integer;+    ui->stdin_fd = (int)value.data.integer;",not sure if this is useful in `nvim_list_uis` ?,
21310755,vimpostor,https://api.github.com/repos/neovim/neovim/pulls/22338,1119982586,2023-02-28T12:20:10Z,runtime/doc/eval.txt,"@@ -1794,7 +1794,7 @@ v:event		Dictionary of event data for the current |autocommand|.  Valid 			abort		Whether the event triggered during 					an aborting condition (e.g. |c_Esc| or 					|c_CTRL-C| for |CmdlineLeave|).-			chan		|channel-id| or 0 for ""internal"".+			chan		|channel-id|","@zeertzjq Is there any plan to add an alternative way to detect if neovim is using the builtin UI?According to https://github.com/vimpostor/vim-tpipeline/issues/46#issuecomment-1432140242 the only way in nightly is to test for `nvim_list_uis()[0].ext_termcolors`, which feels a bit hacky and I have a hunch it will break in the future.I think it would be important to add official API for this before the next neovim release, as otherwise users would need to add an extra condition just for neovim 0.9.Perhaps the elements of `nvim_list_uis()` could have a bool for that, or we could add a `name` field, so that we are able to identify UIs and the internal UI would set `name` to `""internal""`?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22022,1123134054,2023-03-02T13:53:43Z,runtime/doc/lsp.txt,"@@ -482,6 +482,70 @@ LspSignatureActiveParameter     Used to highlight the active parameter in the signature help. See     |vim.lsp.handlers.signature_help()|. +------------------------------------------------------------------------------+LSP SEMANTIC HIGHLIGHTS                               *lsp-semantic-highlight*++When available, neovim's LSP client highlights source code using ""semantic","```suggestionWhen available, Nvim's LSP client highlights source code using |lsp-semantic_tokens|```or just ""the LSP client""",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22476,1123346305,2023-03-02T16:07:16Z,runtime/lua/vim/treesitter/language.lua,"@@ -60,6 +60,10 @@ function M.add(lang, opts)     filetype = { filetype, { 'string', 'table' }, true },   }) +  if filetype == '' then+    error(string.format(""'%s' is not a valid filetype"", filetype))","Just tried it, and couldn't get it to give a nice enough error message:```Passed in:(string) '.../language.lua:0: filetype: expected filetype or list of filetypes, got 'Expected:(string) '.../language.lua:0: '' is not a valid filetype'```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22476,1123359488,2023-03-02T16:12:58Z,runtime/lua/vim/treesitter/language.lua,"@@ -60,6 +60,10 @@ function M.add(lang, opts)     filetype = { filetype, { 'string', 'table' }, true },   }) +  if filetype == '' then+    error(string.format(""'%s' is not a valid filetype"", filetype))","> filetype: expected filetype or list of filetypes, got This is our standard error format, it's nice because it shows the parameter name clearly as the first item, with the variable part at the end. We could enhance vim.validate() to put quotes around string values, so that it looks like this?> filetype: expected filetype or list of filetypes, got """"",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22477,1123365505,2023-03-02T16:16:37Z,runtime/lua/vim/treesitter.lua,"@@ -424,6 +424,8 @@ end --- display of the source language of each node, and press <Enter> to jump to the node under the --- cursor in the source buffer. ---+--- Can also be shown with `:InspectTree`. *InspectTree*","Yup, typo (I no longer see too well.)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22483,1123679348,2023-03-02T20:51:31Z,runtime/queries/query/injections.scm,"@@ -0,0 +1,6 @@+((predicate +  name: (identifier) @_name+  parameters: (parameters (string) @regex))+ (#match? @_name ""^#?(not-)?(match|vim-match|lua-match)$""))","does ""regex"" lang also handle lua patterns (i e `lua-match` here) reasonably well?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22483,1123740427,2023-03-02T21:34:47Z,runtime/queries/query/injections.scm,"@@ -0,0 +1,6 @@+((predicate +  name: (identifier) @_name+  parameters: (parameters (string) @regex))+ (#match? @_name ""^#?(not-)?(match|vim-match|lua-match)$""))","it would still be a more conservative estimate that `regex` parser at least handles regexes, if not regexes + lua patterns (which are significantly more different than say, pcre regex vs vim regex)",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22483,1124213150,2023-03-03T09:27:25Z,runtime/queries/query/injections.scm,"@@ -0,0 +1,6 @@+((predicate +  name: (identifier) @_name+  parameters: (parameters (string) @regex))+ (#match? @_name ""^#?(not-)?(match|vim-match|lua-match)$""))++(comment) @comment","I think longer term we might want the injections for the comment parser to be kept together in a single package. Since `@comment` is standardized (unlike the node names), we could probably use that as an injection point somehow.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22493,1124309762,2023-03-03T11:01:58Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -38,6 +38,8 @@ local LanguageTree = {}  LanguageTree.__index = LanguageTree +--- @private+--- --- A |LanguageTree| holds the treesitter parser for a given language {lang} used","It seems like `LanguageTree.new` and `TSHighlighter.new` were being used as ""module-level docstrings"". Do we not have something like `\defgroup` for Lua modules? https://github.com/neovim/neovim/blob/6d4f48182131c36d57589eefd4cefe3c70256d04/src/nvim/api/buffer.c#L47",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22498,1124522684,2023-03-03T14:21:57Z,scripts/lua2dox.lua,"@@ -315,6 +315,34 @@ function TLua2DoX_filter.filter(this, AppStamp, Filename)     local line     local fn_magic -- function name/def from  magic comment +    outStream:writeln([=[+++#include <assert.h>++#include ""klib/kvec.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/buffer.c.generated.h""+#endif++/// @defgroup lua-treesitter-languagetree",Doesn't work :( Also tried `\defgroup`.But it works in api/buffer.c ... https://github.com/neovim/neovim/blob/ef52592cf8bc158a91b276017d1d2e68a620e7e0/src/nvim/api/buffer.c#L47-L49,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22394,1124693897,2023-03-03T16:24:07Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -174,16 +179,19 @@ function LanguageTree:parse()         vim.list_extend(changes, tree_changes)","Just a point of terminology: ""upstream"" here can mean two different things:1. the tree-sitter C library (which we use)2. the tree-sitter Rust reference implementation (which Helix uses but we obviously don't)I suspect that @theHamsta is referring to 2. while @bfredl is referring to 1. It would help if we made that distinction clearly (e.g., by talking about ""upstream library"" and ""upstream implementation"", respectively) to avoid misunderstandings.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22394,1124900274,2023-03-03T19:02:17Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -174,16 +179,19 @@ function LanguageTree:parse()         vim.list_extend(changes, tree_changes)","> Well 1 is our upstream here, and is what limits what we can do (without going into any upstream code).Yes, that is clear. All I'm doing is pointing out that there's danger of miscommunication here; I'm not interested in finger-pointing or deciding who is ""right"". (I''m thinking as much of later readers as of the people involved, who presumably are well aware of what they mean.)>  Helix does not use the highlighter ""reference implementation""At the very least, it has verbatim copied parts of it, and from what I've seen of its injection queries behaves as similarly to it as I can distinguish.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22022,1125628600,2023-03-05T09:24:32Z,runtime/doc/lsp.txt,"@@ -482,6 +482,70 @@ LspSignatureActiveParameter     Used to highlight the active parameter in the signature help. See     |vim.lsp.handlers.signature_help()|. +------------------------------------------------------------------------------+LSP SEMANTIC HIGHLIGHTS                               *lsp-semantic-highlight*++When available, the LSP client highlights code using |lsp-semantic_tokens|,+which are another way that LSP servers can provide information about source+code.  Note that this is in addition to treesitter syntax highlighting;+semantic highlighting does not replace syntax highlighting.++The server will typically provide one token per identifier in the source code.+The token will have a `type` such as ""function"" or ""variable"", and 0 or more+`modifier`s such as ""readonly"" or ""deprecated."" The standard types and+modifiers are described here:+https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_semanticTokens+LSP servers may also use off-spec types and modifiers.++The LSP client adds one or more highlights for each token. The highlight+groups are derived from the token type and modifiers:+  ��� `@lsp.type.<type>.<ft>` for the token type, and+  ��� `@lsp.mod.<mod>.<ft>` and `@lsp.both.<type>.<mod>.<ft>` for each modifier.",this would look clearer with three ��� items for the three patterns instead of jumbling the last two together,
31443074,Biswa96,https://api.github.com/repos/neovim/neovim/pulls/22538,1125694622,2023-03-05T16:22:21Z,cmake/GenerateVersion.cmake,"@@ -1,11 +1,13 @@ set(NVIM_VERSION     ""v${NVIM_VERSION_MAJOR}.${NVIM_VERSION_MINOR}.${NVIM_VERSION_PATCH}${NVIM_VERSION_PRERELEASE}"") +if(EXISTS ""${NVIM_SOURCE_DIR}/.git"") execute_process(   COMMAND git --git-dir=${NVIM_SOURCE_DIR}/.git --work-tree=${NVIM_SOURCE_DIR} describe --first-parent --dirty --always   OUTPUT_VARIABLE GIT_TAG   OUTPUT_STRIP_TRAILING_WHITESPACE",I have added the change as you suggested.> your PR gives v0.9.0-dev- without a .git repoIt could be fixed by adding the same check with the `if (NVIM_VERSION_PRERELEASE)` condition. Or checking `GIT_TAG` after execute_process.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/22022,1125705583,2023-03-05T17:36:58Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -372,52 +393,55 @@ function STHighlighter:on_win(topline, botline)       --       -- Instead, we have to use normal extmarks that can attach to locations       -- in the buffer and are persisted between redraws.+      --+      -- `strict = false` is necessary here for the 1% of cases where the+      -- current result doesn't actually match the buffer contents. Some+      -- LSP servers can respond with stale tokens on requests if they are+      -- still processing changes from a didChange notification.+      --+      -- LSP servers that do this _should_ follow up known stale responses+      -- with a refresh notification once they've finished processing the+      -- didChange notification, which would re-synchronize the tokens from+      -- our end.+      --+      -- The server I know of that does this is clangd when the preamble of+      -- a file changes and the token request is processed with a stale+      -- preamble while the new one is still being built. Once the preamble+      -- finishes, clangd sends a refresh request which lets the client+      -- re-synchronize the tokens.++      local set_mark = function(token, hl_group, delta)+        vim.api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {+          hl_group = hl_group,+          end_col = token.end_col,+          priority = vim.highlight.priorities.semantic_tokens + delta,+          strict = false,+        })+      end++      local ft = vim.bo[self.bufnr].filetype       local highlights = current_result.highlights-      local idx = binary_search(highlights, topline)+      local first = lower_bound(highlights, topline, 1, #highlights + 1)+      local last = upper_bound(highlights, botline, first, #highlights + 1) - 1 -      for i = idx, #highlights do+      for i = first, last do         local token = highlights[i]--        if token.line > botline then-          break-        end--        if not token.extmark_added then-          -- `strict = false` is necessary here for the 1% of cases where the-          -- current result doesn't actually match the buffer contents. Some-          -- LSP servers can respond with stale tokens on requests if they are-          -- still processing changes from a didChange notification.-          ---          -- LSP servers that do this _should_ follow up known stale responses-          -- with a refresh notification once they've finished processing the-          -- didChange notification, which would re-synchronize the tokens from-          -- our end.-          ---          -- The server I know of that does this is clangd when the preamble of-          -- a file changes and the token request is processed with a stale-          -- preamble while the new one is still being built. Once the preamble-          -- finishes, clangd sends a refresh request which lets the client-          -- re-synchronize the tokens.-          api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {-            hl_group = '@' .. token.type,-            end_col = token.end_col,-            priority = vim.highlight.priorities.semantic_tokens,-            strict = false,-          })--          -- TODO(bfredl) use single extmark when hl_group supports table-          if #token.modifiers > 0 then-            for _, modifier in pairs(token.modifiers) do-              api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {-                hl_group = '@' .. modifier,-                end_col = token.end_col,-                priority = vim.highlight.priorities.semantic_tokens + 1,-                strict = false,-              })-            end+        if not token.marked then+          set_mark(token, string.format('@lsp.type.%s.%s', token.type, ft), 0)+          for modifier, _ in pairs(token.modifiers) do+            set_mark(token, string.format('@lsp.mod.%s.%s', modifier, ft), 1)+            set_mark(token, string.format('@lsp.both.%s.%s.%s', token.type, modifier, ft), 2)           end--          token.extmark_added = true+          token.marked = true++          api.nvim_exec_autocmds('LspTokenUpdate', {","Wouldn't this also mean that as soon as you want to have a single customisation you'd also need to apply all defaults as well if color schemes start using these? I'd think it's more confusing if other highlights disappear. Afaik this was also discussed before. If there are no new substantial new arguments for a behaviour change I'd say we go ahead with this and let people actually try and use it before having another round of discussion going back and forth---> Bikeshed, while we're at it: not crazy about both -- maybe typemod or combined or combination or somesuch would be more descriptive.+1 for typemod ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22547,1126101159,2023-03-06T08:49:43Z,src/nvim/statusline.c,"@@ -279,7 +279,8 @@ static void win_redr_custom(win_T *wp, bool draw_winbar, bool draw_ruler)   // There is a tiny chance that this gets called recursively: When   // redrawing a status line triggers redrawing the ruler or tabline.   // Avoid trouble by not allowing recursion.-  if (entered) {+  if (entered || skip_redr_custom_k_event) {+    skip_redr_custom_k_event = false;",Related globals `redraw_tabline` and `redraw_cmdline` look very similar in nature. Would it make sense to name this one `redraw_win_custom` ?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22325,1126258563,2023-03-06T11:08:43Z,runtime/lua/vim/_init_packages.lua,"@@ -69,6 +69,14 @@ setmetatable(vim, {         t[key] = val         return t[key]       end+    elseif key == 'version' then+      local version = require('vim.version')+      t[key] = setmetatable({ cmp = version.cmp, parse = version.parse }, {+        __call = function()+          return vim.fn.api_info().version+        end,+      })","We could use `setmetatable(M, { stuff })` inside `runtime/lua/vim/version.lua`, instead of hiding it here.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22325,1126328207,2023-03-06T12:07:48Z,runtime/lua/vim/_init_packages.lua,"@@ -69,6 +69,9 @@ setmetatable(vim, {         t[key] = val         return t[key]       end+    elseif key == 'version' then+      t[key] = require('vim.version')",`version` can now be added to `vim._submodules` instead as it is no longer a special case.,
926528,swarn,https://api.github.com/repos/neovim/neovim/pulls/22022,1126562201,2023-03-06T15:07:59Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -372,52 +393,55 @@ function STHighlighter:on_win(topline, botline)       --       -- Instead, we have to use normal extmarks that can attach to locations       -- in the buffer and are persisted between redraws.+      --+      -- `strict = false` is necessary here for the 1% of cases where the+      -- current result doesn't actually match the buffer contents. Some+      -- LSP servers can respond with stale tokens on requests if they are+      -- still processing changes from a didChange notification.+      --+      -- LSP servers that do this _should_ follow up known stale responses+      -- with a refresh notification once they've finished processing the+      -- didChange notification, which would re-synchronize the tokens from+      -- our end.+      --+      -- The server I know of that does this is clangd when the preamble of+      -- a file changes and the token request is processed with a stale+      -- preamble while the new one is still being built. Once the preamble+      -- finishes, clangd sends a refresh request which lets the client+      -- re-synchronize the tokens.++      local set_mark = function(token, hl_group, delta)+        vim.api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {+          hl_group = hl_group,+          end_col = token.end_col,+          priority = vim.highlight.priorities.semantic_tokens + delta,+          strict = false,+        })+      end++      local ft = vim.bo[self.bufnr].filetype       local highlights = current_result.highlights-      local idx = binary_search(highlights, topline)+      local first = lower_bound(highlights, topline, 1, #highlights + 1)+      local last = upper_bound(highlights, botline, first, #highlights + 1) - 1 -      for i = idx, #highlights do+      for i = first, last do         local token = highlights[i]--        if token.line > botline then-          break-        end--        if not token.extmark_added then-          -- `strict = false` is necessary here for the 1% of cases where the-          -- current result doesn't actually match the buffer contents. Some-          -- LSP servers can respond with stale tokens on requests if they are-          -- still processing changes from a didChange notification.-          ---          -- LSP servers that do this _should_ follow up known stale responses-          -- with a refresh notification once they've finished processing the-          -- didChange notification, which would re-synchronize the tokens from-          -- our end.-          ---          -- The server I know of that does this is clangd when the preamble of-          -- a file changes and the token request is processed with a stale-          -- preamble while the new one is still being built. Once the preamble-          -- finishes, clangd sends a refresh request which lets the client-          -- re-synchronize the tokens.-          api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {-            hl_group = '@' .. token.type,-            end_col = token.end_col,-            priority = vim.highlight.priorities.semantic_tokens,-            strict = false,-          })--          -- TODO(bfredl) use single extmark when hl_group supports table-          if #token.modifiers > 0 then-            for _, modifier in pairs(token.modifiers) do-              api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {-                hl_group = '@' .. modifier,-                end_col = token.end_col,-                priority = vim.highlight.priorities.semantic_tokens + 1,-                strict = false,-              })-            end+        if not token.marked then+          set_mark(token, string.format('@lsp.type.%s.%s', token.type, ft), 0)+          for modifier, _ in pairs(token.modifiers) do+            set_mark(token, string.format('@lsp.mod.%s.%s', modifier, ft), 1)+            set_mark(token, string.format('@lsp.both.%s.%s.%s', token.type, modifier, ft), 2)           end--          token.extmark_added = true+          token.marked = true++          api.nvim_exec_autocmds('LspTokenUpdate', {","I agree that this would be useful and straightforward to implement, but I am fine with leaving it for a future PR.I imagine that the `opts` argument would add a second field; something like:``` lua---@param opts (table|nil) Optional parameters.---       - priority: (number|nil) Priority for the applied extmark. Defaults---         to `vim.highlight.priorities.semantic_tokens + 3`---       - keep_default (boolean|nil) Defaults to true. If true, apply the---         default `@lsp.*` highlights as usual. If false, do not apply the---         default highlights for this token.```I don't think this is the same as previous discussion about ""disabling the default rule.""  That was about disabling all default semantic highlighting, rather than allowing you to disable it per-token using the callback.There was also speculation about a hypothetical change enabling return values from autocommand callbacks, and how that would obviate the need for a separate `highlight_token()` function. Adding more logic to `highlight_token()` doesn't make that impossible, but maybe less clean.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/22022,1126750109,2023-03-06T16:50:38Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -372,52 +393,55 @@ function STHighlighter:on_win(topline, botline)       --       -- Instead, we have to use normal extmarks that can attach to locations       -- in the buffer and are persisted between redraws.+      --+      -- `strict = false` is necessary here for the 1% of cases where the+      -- current result doesn't actually match the buffer contents. Some+      -- LSP servers can respond with stale tokens on requests if they are+      -- still processing changes from a didChange notification.+      --+      -- LSP servers that do this _should_ follow up known stale responses+      -- with a refresh notification once they've finished processing the+      -- didChange notification, which would re-synchronize the tokens from+      -- our end.+      --+      -- The server I know of that does this is clangd when the preamble of+      -- a file changes and the token request is processed with a stale+      -- preamble while the new one is still being built. Once the preamble+      -- finishes, clangd sends a refresh request which lets the client+      -- re-synchronize the tokens.++      local set_mark = function(token, hl_group, delta)+        vim.api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {+          hl_group = hl_group,+          end_col = token.end_col,+          priority = vim.highlight.priorities.semantic_tokens + delta,+          strict = false,+        })+      end++      local ft = vim.bo[self.bufnr].filetype       local highlights = current_result.highlights-      local idx = binary_search(highlights, topline)+      local first = lower_bound(highlights, topline, 1, #highlights + 1)+      local last = upper_bound(highlights, botline, first, #highlights + 1) - 1 -      for i = idx, #highlights do+      for i = first, last do         local token = highlights[i]--        if token.line > botline then-          break-        end--        if not token.extmark_added then-          -- `strict = false` is necessary here for the 1% of cases where the-          -- current result doesn't actually match the buffer contents. Some-          -- LSP servers can respond with stale tokens on requests if they are-          -- still processing changes from a didChange notification.-          ---          -- LSP servers that do this _should_ follow up known stale responses-          -- with a refresh notification once they've finished processing the-          -- didChange notification, which would re-synchronize the tokens from-          -- our end.-          ---          -- The server I know of that does this is clangd when the preamble of-          -- a file changes and the token request is processed with a stale-          -- preamble while the new one is still being built. Once the preamble-          -- finishes, clangd sends a refresh request which lets the client-          -- re-synchronize the tokens.-          api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {-            hl_group = '@' .. token.type,-            end_col = token.end_col,-            priority = vim.highlight.priorities.semantic_tokens,-            strict = false,-          })--          -- TODO(bfredl) use single extmark when hl_group supports table-          if #token.modifiers > 0 then-            for _, modifier in pairs(token.modifiers) do-              api.nvim_buf_set_extmark(self.bufnr, state.namespace, token.line, token.start_col, {-                hl_group = '@' .. modifier,-                end_col = token.end_col,-                priority = vim.highlight.priorities.semantic_tokens + 1,-                strict = false,-              })-            end+        if not token.marked then+          set_mark(token, string.format('@lsp.type.%s.%s', token.type, ft), 0)+          for modifier, _ in pairs(token.modifiers) do+            set_mark(token, string.format('@lsp.mod.%s.%s', modifier, ft), 1)+            set_mark(token, string.format('@lsp.both.%s.%s.%s', token.type, modifier, ft), 2)           end--          token.extmark_added = true+          token.marked = true++          api.nvim_exec_autocmds('LspTokenUpdate', {","> I don't think this is the same as previous discussion about ""disabling the default rule."" That was about disabling all default semantic highlighting, rather than allowing you to disable it per-token using the callback.Oh right. I don't have a strong opinion on this but I'd really like to defer changing this to a separate PR. If there are no other objections I'll go ahead and merge this in a bit",
90338990,eriks47,https://api.github.com/repos/neovim/neovim/pulls/22503,1126813359,2023-03-06T17:44:49Z,runtime/lua/man.lua,"@@ -432,7 +433,7 @@ local function verify_exists(sect, name, silent)    if not silent then     -- finally, if that didn't work, there is no hope-    man_error('no manual entry for ' .. name)+    return nil","Renamed it to `search_for_path`, however I am not sure about this as it adds some ambiguity because now there are three functions with simillar names: `get_path`, `get_paths` and `search_for_path`.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/20327,1126842626,2023-03-06T18:13:26Z,runtime/lua/vim/lsp/util.lua,"@@ -352,17 +352,22 @@ local function get_line_byte_from_position(bufnr, position, offset_encoding) end  --- Process and return progress reports from lsp server----@private+---",I thought some more about this and now think we should actually deprecate + remove `get_progress_messages` and replace it with a `vim.lsp.status()` or something like that.We should probably also stop storing the progress messages in `client.messages` per token but instead have a small ringbuffer. I think otherwise memory usage grows unbounded if the user doesn't consume them.If users want to customize the progress display they can still override the handler.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22559,1127545275,2023-03-07T08:57:28Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -419,10 +419,10 @@ function STHighlighter:on_win(topline, botline)         })       end -      local ft = vim.bo[self.bufnr].filetype","and even if so, `nvim_buf_get_option` is deprecated in favor of `nvim_buf_get_option_value` (which these Lua functions use under the hood)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22518,1127856411,2023-03-07T13:28:39Z,runtime/doc/news.txt,"@@ -189,6 +189,10 @@ The following new APIs or features were added.   disabled by default and can be enabled by setting the   `workspace.didChangeWatchedFiles.dynamicRegistration=true` capability. +��� Treesitter injection queries now use the format described at+  https://tree-sitter.github.io/tree-sitter/syntax-highlighting#language-injection .+  Support for the previous format will be removed in a future release.","This is a strong signal that this is the right change. When you can just point to upstream spec and say ""we support [this]"" instead of ""[big paragraph about differences]"", that is a gain for both developers and users.An early, analogous case was in 2014 when we debated a variation of msgpack-rpc. https://github.com/neovim/neovim/pull/1121",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/22561,1128060738,2023-03-07T15:33:15Z,runtime/CMakeLists.txt,"@@ -120,19 +120,17 @@ install_helper(   FILES ${CMAKE_CURRENT_SOURCE_DIR}/neovim.ico   DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/nvim/runtime) -globrecurse_wrapper(RUNTIME_PROGRAMS ${CMAKE_CURRENT_SOURCE_DIR} *.awk *.sh *.bat)--foreach(PROG ${RUNTIME_PROGRAMS})-  get_filename_component(BASEDIR ${PROG} DIRECTORY)-  install_helper(PROGRAMS ${PROG}-                 DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/nvim/runtime/${BASEDIR})+glob_wrapper(RUNTIME_ROOT_FILES *.vim *.lua)+foreach(F ${RUNTIME_ROOT_FILES})+  install_helper(FILES ${F}+                 DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/nvim/runtime/) endforeach() -globrecurse_wrapper(RUNTIME_FILES ${CMAKE_CURRENT_SOURCE_DIR}-  *.vim *.lua *.scm *.dict *.py *.rb *.ps *.spl *.tutor *.tutor.json)--foreach(F ${RUNTIME_FILES})-  get_filename_component(BASEDIR ${F} DIRECTORY)-  install_helper(FILES ${F}-                 DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/nvim/runtime/${BASEDIR})+glob_wrapper(RUNTIME_DIRS */)+foreach(D ${RUNTIME_DIRS})+  if(IS_DIRECTORY ${D})+    get_filename_component(BASEDIR ${F} DIRECTORY)",This seems unused```suggestion```,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22547,1130239277,2023-03-09T00:44:12Z,src/nvim/drawscreen.c,"@@ -733,28 +734,53 @@ void show_cursor_info(bool always)     return;   } -  win_check_ns_hl(curwin);-  if ((*p_stl != NUL || *curwin->w_p_stl != NUL)-      && (curwin->w_status_height || global_stl_height())) {-    redraw_custom_statusline(curwin);-  } else {-    win_redr_ruler(curwin, always);-  }-  if (*p_wbr != NUL || *curwin->w_p_wbr != NUL) {-    win_redr_winbar(curwin);-  }+  int state = get_real_state();+  int empty_line = (State & MODE_INSERT) == 0+                   && *ml_get_buf(curwin->w_buffer, curwin->w_cursor.lnum, false) == NUL;++  // Only draw when something changed.+  validate_virtcol_win(curwin);+  if (always+      || curwin->w_cursor.lnum != curwin->w_stl_cursor.lnum+      || curwin->w_cursor.col != curwin->w_stl_cursor.col+      || curwin->w_virtcol != curwin->w_stl_virtcol+      || curwin->w_cursor.coladd != curwin->w_stl_cursor.coladd+      || curwin->w_topline != curwin->w_stl_topline+      || curwin->w_buffer->b_ml.ml_line_count != curwin->w_stl_line_count+      || curwin->w_topfill != curwin->w_stl_topfill+      || empty_line != curwin->w_stl_empty+      || state != curwin->w_stl_state) {+    win_check_ns_hl(curwin);+    if ((*p_stl != NUL || *curwin->w_p_stl != NUL)+        && (curwin->w_status_height || global_stl_height())) {+      redraw_custom_statusline(curwin);+    } else {+      win_redr_ruler(curwin);+    }+    if (*p_wbr != NUL || *curwin->w_p_wbr != NUL) {+      win_redr_winbar(curwin);+    } -  if (need_maketitle-      || (p_icon && (stl_syntax & STL_IN_ICON))-      || (p_title && (stl_syntax & STL_IN_TITLE))) {-    maketitle();-  }+    if (need_maketitle","Why are this and the `draw_tabline()` below conditional on `need_maketitle/redraw_tabline`? Either we want to support showing the cursor(and mode) information in the title/tabline or we don't. If we do they should be unconditionally called here I think, `set tal=%{mode()}` will not show the mode changes for example. Them being present in `show_cursor_info()` seems to indicate that we want to support this.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22547,1130751101,2023-03-09T10:01:09Z,src/nvim/drawscreen.c,"@@ -733,28 +734,53 @@ void show_cursor_info(bool always)     return;   } -  win_check_ns_hl(curwin);-  if ((*p_stl != NUL || *curwin->w_p_stl != NUL)-      && (curwin->w_status_height || global_stl_height())) {-    redraw_custom_statusline(curwin);-  } else {-    win_redr_ruler(curwin, always);-  }-  if (*p_wbr != NUL || *curwin->w_p_wbr != NUL) {-    win_redr_winbar(curwin);-  }+  int state = get_real_state();+  int empty_line = (State & MODE_INSERT) == 0+                   && *ml_get_buf(curwin->w_buffer, curwin->w_cursor.lnum, false) == NUL;++  // Only draw when something changed.+  validate_virtcol_win(curwin);+  if (always+      || curwin->w_cursor.lnum != curwin->w_stl_cursor.lnum+      || curwin->w_cursor.col != curwin->w_stl_cursor.col+      || curwin->w_virtcol != curwin->w_stl_virtcol+      || curwin->w_cursor.coladd != curwin->w_stl_cursor.coladd+      || curwin->w_topline != curwin->w_stl_topline+      || curwin->w_buffer->b_ml.ml_line_count != curwin->w_stl_line_count+      || curwin->w_topfill != curwin->w_stl_topfill+      || empty_line != curwin->w_stl_empty+      || state != curwin->w_stl_state) {+    win_check_ns_hl(curwin);+    if ((*p_stl != NUL || *curwin->w_p_stl != NUL)+        && (curwin->w_status_height || global_stl_height())) {+      redraw_custom_statusline(curwin);+    } else {+      win_redr_ruler(curwin);+    }+    if (*p_wbr != NUL || *curwin->w_p_wbr != NUL) {+      win_redr_winbar(curwin);+    } -  if (need_maketitle-      || (p_icon && (stl_syntax & STL_IN_ICON))-      || (p_title && (stl_syntax & STL_IN_TITLE))) {-    maketitle();-  }+    if (need_maketitle",although maybe the alternate `stl_syntax & STL_IN_TITLE)` condition handles this? too many magic variables..,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22577,1130784674,2023-03-09T10:29:13Z,.github/workflows/test.yml,"@@ -360,3 +359,48 @@ jobs:           $env:PATH = ""C:\msys64\usr\bin;$env:PATH""           & ""C:\msys64\mingw64\bin\mingw32-make.exe"" -C $(Convert-Path test\old\testdir) VERBOSE=1           $env:PATH = $OldPath++  with-external-deps:+    runs-on: ubuntu-22.04+    timeout-minutes: 10+    steps:+      - uses: actions/checkout@v3++      - name: Install dependencies+        run: |+          sudo add-apt-repository ppa:neovim-ppa/stable+          ./.github/scripts/install_deps.sh+          sudo apt-get install -y \+            libluajit-5.1-dev \+            libmsgpack-dev \+            libtermkey-dev \+            libtree-sitter-dev \+            libunibilium-dev \+            libuv1-dev \+            lua-busted \+            lua-filesystem \+            lua-inspect \","off-topic for this PR, but I wonder if we can eliminate lua-inspect (or is it a transitive dependency of some other luarocks package?)Probably can eliminate others too, since we use Nvim as the test runner now.Edit: note that this likely require some fixups to the test code. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22577,1130990050,2023-03-09T12:56:43Z,.github/workflows/build.yml,"@@ -71,46 +71,3 @@ jobs:        - name: Install         run: make install--  with-external-deps:-    runs-on: ubuntu-22.04-    timeout-minutes: 10-    steps:-      - uses: actions/checkout@v3--      - name: Install dependencies-        run: |-          sudo add-apt-repository ppa:neovim-ppa/stable-          ./.github/scripts/install_deps.sh-          sudo apt-get install -y \-            libluajit-5.1-dev \-            libmsgpack-dev \-            libtermkey-dev \-            libtree-sitter-dev \-            libunibilium-dev \-            libuv1-dev \-            lua-busted \-            lua-filesystem \","Technically we still use `require('lfs')` in several places, but I think we accidentally get it from e.g. busted.I think we could eliminate all those `require('lfs')` eventually, and use `vim.fs` instead.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22566,1131024376,2023-03-09T13:23:15Z,test/functional/terminal/buffer_spec.lua,"@@ -170,6 +176,30 @@ describe(':terminal buffer', function()       ^                                                  |       :6put a                                           |     ]])+  end++  it('sends data to the terminal when the ""put"" operator is used', function()+    test_terminal_put_operator()+  end)++  it('sends data to the powershell terminal when the ""put"" operator is used', function()","Avoiding over-verbose test names helps with reading logs. Similar for the other tests```suggestion  it('""put"" operator sends data to powershell terminal', function()```",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/22566,1131106159,2023-03-09T14:28:16Z,test/functional/terminal/buffer_spec.lua,"@@ -170,6 +176,30 @@ describe(':terminal buffer', function()       ^                                                  |       :6put a                                           |     ]])+  end++  it('sends data to the terminal when the ""put"" operator is used', function()+    test_terminal_put_operator()+  end)++  it('sends data to the powershell terminal when the ""put"" operator is used', function()+    if not helpers.has_powershell() then+      pending(""powershell not found"", function() end)+      return+    end","> merge the powershell tests into the non-powershell testsSomething like this?```  it('sends data to the terminal when the ""put"" operator is used', function()    test_terminal_put_operator()    if helpers.has_powershell() then      helpers.set_shell_powershell(false)      test_terminal_put_operator()    end  end)```This^ fails.  Probably needs to clear the terminal window in between the two tests.Or did you mean something else?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22566,1131400365,2023-03-09T17:58:20Z,src/nvim/terminal.c,"@@ -724,7 +724,11 @@ void terminal_paste(long count, char **y_array, size_t y_size)     for (size_t j = 0; j < y_size; j++) {       if (j) {         // terminate the previous line+#ifdef MSWIN+        terminal_send(curbuf->terminal, ""\r\n"", 2);","These tests use https://github.com/neovim/neovim/blob/64d3f68c07f7e67bbbd5db11b289705f7569b949/test/functional/terminal/helpers.lua#L54Maybe `feed_command()` in the tests isn't sending multi-line input, or maybe `tty-test.c` is not being ""strict"" enough about CRLF vs LF: https://github.com/neovim/neovim/blob/64d3f68c07f7e67bbbd5db11b289705f7569b949/test/functional/fixtures/tty-test.c#L128-L132Actually, it looks like `tty-test.c` is being invoked once per line, which does not test what we want. Confirmed by this change:```diffdiff --git a/test/functional/fixtures/tty-test.c b/test/functional/fixtures/tty-test.cindex 6ee77150213d..81398cb77768 100644--- a/test/functional/fixtures/tty-test.c+++ b/test/functional/fixtures/tty-test.c@@ -110,6 +110,7 @@ static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf)   };   uv_write(&req, STRUCT_CAST(uv_stream_t, &out), &b, 1, NULL);   uv_run(&write_loop, UV_RUN_DEFAULT);+  fprintf(stderr, ""xxxxxxxxx\n"");    uv_close(STRUCT_CAST(uv_handle_t, &out), NULL);   uv_run(&write_loop, UV_RUN_DEFAULT);```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22613,1132578671,2023-03-10T16:16:58Z,runtime/lua/vim/treesitter/query.lua,"@@ -256,39 +236,48 @@ function M.parse_query(lang, query)   local cached = query_cache[lang][query]   if cached then     return cached-  else-    local self = setmetatable({}, Query)-    self.query = vim._ts_parse_query(lang, query)-    self.info = self.query:inspect()-    self.captures = self.info.captures-    query_cache[lang][query] = self-    return self   end++  local self = setmetatable({}, Query)+  self.query = vim._ts_parse_query(lang, query)+  self.info = self.query:inspect()+  self.captures = self.info.captures+  query_cache[lang][query] = self+  return self+end++---@param node TSNode+---@param source integer|string+---@param metadata TSMetadata+---@return Range6+function M.get_range_from_metadata(node, source, metadata)","Could be named `get_range`. What other kinds of ""get range"" cases do we anticipate in the future?",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22598,1132691103,2023-03-10T17:55:46Z,runtime/lua/vim/_editor.lua,"@@ -948,6 +948,63 @@ function vim._init_defaults()   vim._init_default_autocmds() end +table.pack = table.pack or function(...) return { n = select(""#"", ...), ... } end","But note that LuaJIT may be compiled with 5.2 extensions, in which case it already has `table.{un}pack`, so that would have to be checked first.If we do go that route, we could also (conditionally) add useful extensions from openResty's LuaJIT2 like `table.isempty`, `table.isarray`, `table.nkeys`, and `table.clone` (which means we could deprecate `vim.tbl_isempty` etc., or at least offer LuaJIT2 users access to the compiled version).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22618,1132997345,2023-03-11T00:55:46Z,runtime/lua/vim/lsp/util.lua,"@@ -743,6 +743,19 @@ local function bufwinid(bufnr)   end end +local function get_directory_buffers(path)+    local buffers = vim.api.nvim_exec('buffers', true)",`vim.api.nvim_list_bufs()`,
19489738,tomtomjhj,https://api.github.com/repos/neovim/neovim/pulls/22621,1133052655,2023-03-11T08:23:46Z,runtime/lua/vim/lsp.lua,"@@ -1058,7 +1058,7 @@ function lsp.start_client(config)   --- Returns the default handler if the user hasn't set a custom one.   ---   ---@param method (string) LSP method name-  ---@return function|nil The handler for the given method, if defined, or the default from |vim.lsp.handlers|+  ---@return lsp-handler|nil The handler for the given method, if defined, or the default from |vim.lsp.handlers|",https://github.com/neovim/neovim/blob/236c20795eb9f11e21e0719b735ea741711acc08/runtime/lua/vim/lsp/types.lua#L3,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22621,1133056453,2023-03-11T09:01:20Z,runtime/doc/lsp.txt,"@@ -697,9 +696,8 @@ buf_request_sync({bufnr}, {method}, {params}, {timeout_ms})                       result. Defaults to 1000      Return: ~-        table<integer, any>|nil result, string|nil err Map of-        client_id:request_result. On timeout, cancel or error, returns `(nil,-        err)` where `err` is a string describing the failure reason.+        table<integer, {err: lsp.ResponseError , result: any}>|nil result, string|nil err Map of+        client_id:request_result. On timeout, cancel or error, returns `(nil, err)` where `err` is a string describing the failure reason.","Exactly. Try separating the `|` with spaces (which is not legal for taglinks, which this conflicts with).If this becomes too cumbersome, we could switch to `foo?` for optional parameters.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/22598,1133063161,2023-03-11T10:04:26Z,runtime/lua/vim/_editor.lua,"@@ -948,6 +948,63 @@ function vim._init_defaults()   vim._init_default_autocmds() end +table.pack = table.pack or function(...) return { n = select(""#"", ...), ... } end","> If we do go that route, we could also (conditionally) add useful extensions from openResty's LuaJIT2 like table.isempty, table.isarray, table.nkeys, and table.clone (which means we could deprecate vim.tbl_isempty etc., or at least offer LuaJIT2 users access to the compiled version).Sounds appealing. Would this play nicely with luals?",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/22566,1133081989,2023-03-11T13:05:45Z,src/nvim/terminal.c,"@@ -724,7 +724,11 @@ void terminal_paste(long count, char **y_array, size_t y_size)     for (size_t j = 0; j < y_size; j++) {       if (j) {         // terminate the previous line+#ifdef MSWIN+        terminal_send(curbuf->terminal, ""\r\n"", 2);","It is clear from the following code that even after calling `set_shell_powershell()`, the command that `thelper.screen_setup()` executes is `tty-test.exe`.https://github.com/neovim/neovim/blob/8065fc9aaeff734f38109aec52bf852379a5a183/test/functional/terminal/helpers.lua#L54-L58Therefore, if you want to test pasting into PowerShell, you need to pass `powershell.exe` as the command argument to pass to `thelper.screen_setup()`.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/20874,1133132907,2023-03-11T18:46:32Z,test/old/testdir/runnvim.vim,"@@ -23,11 +23,13 @@ function Main()   set lines=25   set columns=80   enew-  let job = termopen(args, s:logger)+  "" FIXME: using termopen() hangs on Windows CI+  let job = has('win32') ? jobstart(args, s:logger) : termopen(args, s:logger)","Nope```Failures: 	From test_writefile.vim:	Found errors in Test_writefile_sync_dev_stdout():	Caught exception in Test_writefile_sync_dev_stdout(): Vim(call):E482: Can't open file /dev/stdout for writing: no such device or address @ command line..script /home/runner/work/neovim/neovim/test/old/testdir/runtest.vim[437]..function RunTheTest[44]..Test_writefile_sync_dev_stdout, line 4```",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22634,1133148594,2023-03-11T21:12:59Z,runtime/lua/vim/treesitter.lua,"@@ -664,4 +664,35 @@ function M.foldexpr(lnum)   return require('vim.treesitter._fold').foldexpr(lnum) end +---Get the commentstring for a buffer and position taking into account+---language injections.+---@param opts table|nil Optional keyword arguments:+---             - bufnr integer|nil Buffer number (nil or 0 for current buffer)+---             - pos table|nil 0-indexed (row, col) tuple. Defaults to cursor position in the+---                             current window. Required if {bufnr} is not the current buffer+---@return string+function M.commentstring(opts)+  opts = opts or {}++  local bufnr = opts.bufnr+  if not bufnr or bufnr == 0 then+    bufnr = a.nvim_get_current_buf()+  end++  local parser = M.get_parser(opts.bufnr)+  local range = resolve_pos(bufnr, opts.pos)+  local commentstring+  parser:for_each_child(function(tree, lang)+    if tree:contains(range) then+      local buf = a.nvim_create_buf(false, true)+      vim.bo[buf].filetype = lang",Just define a commentstring for markdown_inline then. It hasn't a big problem.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22598,1133183196,2023-03-12T04:09:03Z,runtime/doc/lua.txt,"@@ -2464,6 +2464,73 @@ parents({start})                                            *vim.fs.parents()*         (function) Iterator  +==============================================================================+Lua module: func                                                    *lua-func*++on_fun({container}, {key}, {fn})                           *vim.func.on_fun()*+    Sets function `container[key]` to a new (wrapper) function that calls+    `fn()` before optionally calling the original (""base"") function.++    The result of `fn()` decides how the base function is invoked. Given `fn()` : >lua","Instead of this ""control via return values"" approach, `fn()` could simply take the base function as the first arg, and the parameters are in a `table.pack()` table named `args`.  Then everything is much more natural.- pro/con of ""control via return values"" approach:    - pro: wrapper doesn't need to explicitly call the base function:      ```      vim.on_fun(vim, 'paste', function()        counter = counter + 1      end)      ```    - con: less obvious what's going on, more to explain in docs.    - con: if the wrapper wants to modify the args, it's less readable/obvious- pro/con of `fn(basefn, args)` approach:    - pro: easy and obvious how to modify args, ""cancel"", or ""go after"".    - pro: simpler docs and impl    - pro: wrapper funcs are future-proof if the base function adds more parameters!      ```      basefn(unpack(args))      ```",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/22566,1133240588,2023-03-12T11:52:11Z,src/nvim/terminal.c,"@@ -724,7 +724,11 @@ void terminal_paste(long count, char **y_array, size_t y_size)     for (size_t j = 0; j < y_size; j++) {       if (j) {         // terminate the previous line+#ifdef MSWIN+        terminal_send(curbuf->terminal, ""\r\n"", 2);","I remember a long time ago that `libuv` used to convert newline codes. I don't think a way to change that behavior (like `_setmode`) was provided. Therefore, it is easier to use `PowerShell`.https://github.com/neovim/neovim/blob/d15abd1be4ae85b10174e3ee139d3b7605e87577/src/nvim/tui/tui.c#L1775",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/22647,1133324459,2023-03-12T21:20:18Z,runtime/optwin.vim,"@@ -230,14 +218,6 @@ call <SID>AddOption(""compatible"", gettext(""behave very Vi compatible (not advisa call <SID>BinOptionG(""cp"", &cp) call <SID>AddOption(""cpoptions"", gettext(""list of flags to specify Vi compatibility"")) call <SID>OptionG(""cpo"", &cpo)-call <SID>AddOption(""paste"", gettext(""paste mode, insert typed text literally""))-call <SID>BinOptionG(""paste"", &paste)",Do we keep deprecated options in optwin?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22647,1133324483,2023-03-12T21:20:34Z,runtime/doc/news.txt,"@@ -55,6 +55,8 @@ The following changes may require adaptations in user config or plugins.   - The `concat` option has been removed as it was not consistently applied.   - Invalid ranges now cause an error instead of returning `nil`. +��� 'paste' option is now deprecated and 'pastetoggle' is removed",```suggestion��� 'paste' option is now deprecated and 'pastetoggle' is removed. |paste| works  automatically in GUI and terminal (TUI) Nvim.  Just Paste It.���```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22566,1133855443,2023-03-13T12:24:35Z,src/nvim/terminal.c,"@@ -724,7 +724,11 @@ void terminal_paste(long count, char **y_array, size_t y_size)     for (size_t j = 0; j < y_size; j++) {       if (j) {         // terminate the previous line+#ifdef MSWIN+        terminal_send(curbuf->terminal, ""\r\n"", 2);","> pwsh starts with a unique prompt, containing current working directory and other stuff. I thought I could change the prompt to a simple `PS> `,for variable content, screen:expect() supports `MATCH`, example: https://github.com/neovim/neovim/blob/673d2b52fa4335aa083c52e6686f0728e25b8ebd/test/functional/ui/bufhl_spec.lua#L458",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/22566,1133879082,2023-03-13T12:42:52Z,src/nvim/terminal.c,"@@ -724,7 +724,11 @@ void terminal_paste(long count, char **y_array, size_t y_size)     for (size_t j = 0; j < y_size; j++) {       if (j) {         // terminate the previous line+#ifdef MSWIN+        terminal_send(curbuf->terminal, ""\r\n"", 2);","I don't think `test_terminal_put_operator()`, etc. can be used as is for `PowerShell`. Therefore, why not try using a separate `describe` clause such as the following  (I haven't tried it to see if it works because the MinGW test is broken and I haven't actually run it)? I'm doing something weird like `[char]0x3E` due to quoting, but the prompt should be `>`.```luadescribe('powershell on terminal', function()  local screen  before_each(function()    clear()    feed_command('set modifiable swapfile undolevels=20')    poke_eventloop()    local command = '[""' .. is_os('win') and 'powershell' or 'pwsh' .. '"", ""-NoLogo"", ""-NoProfile"", ""-NoExit"", ""-Command"", ""function Prompt{[char]0x3E}""]'    screen = thelpers.screen_setup(nil, command)  end)  it('"":put"" command sends data normally', function()    if not has_powershell() then      return    end    feed('<c-\\><c-n>gg""ayj')    feed_command('let @a = ""1\n2\n3\n""')    feed_command('put a')    screen:expect([[    ���    ]])  end)  it('send data normally when ""put"" operator is used', function()  ���  end)end)```",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/22566,1135057444,2023-03-14T06:46:37Z,src/nvim/terminal.c,"@@ -724,7 +724,11 @@ void terminal_paste(long count, char **y_array, size_t y_size)     for (size_t j = 0; j < y_size; j++) {       if (j) {         // terminate the previous line+#ifdef MSWIN+        terminal_send(curbuf->terminal, ""\r\n"", 2);","Thanks.  I didn't realize I can pass args in the list/dictionary of `command`.  Massively useful.Unfortunately, the results of `:put a` or `""ap` aren't what's expected.Here's the snapshot of `:put a`.  ""1\n2\n3"" doesn't appear on screen.```screen:expect{grid=[[                                                    |  {2: }                                                 |                                                    |                                                    |                                                    |  ^                                                  |  :put a                                            |]]}```If I remove `feed('<c-\\><c-n>gg""ayj')` from your example, the output contains more stuff but not ""1\n2\n3"":```screen:expect{grid=[[  :let @a = ""1                                      |  2                                                 |  3                                                 |  ""                                                 |  :put a                                            |  {1: }                                                 |  {3:-- TERMINAL --}                                    |]]}```You might think the @a has been put somewhere above visible screen.  But I extended `extra_rows` arg of `screen_setup()` and it just shows empty rows below, not ""1\n2\n3"".Any idea?",
15110622,Ursescu,https://api.github.com/repos/neovim/neovim/pulls/22267,1135525297,2023-03-14T13:15:48Z,runtime/lua/vim/lsp.lua,"@@ -1112,19 +1112,43 @@ function lsp.start_client(config)     end   end +  ---@private+  -- Determines whether the given option can be set by `set_defaults`.+  local function is_empty_or_default(bufnr, option)+    if vim.bo[bufnr][option] == '' then+      return true+    end++    local old_bufnr = vim.fn.bufnr('')+    local last_set_from = vim.fn.gettext('\n\tLast set from ')+    local line = vim.fn.gettext(' line ')++    vim.cmd.buffer(bufnr)+    local scriptname = vim.fn+      .execute('verbose set ' .. option .. '?')+      :match(last_set_from .. '(.*)' .. line .. '%d+')+    vim.cmd.buffer(old_bufnr)","I copy-pasted the `noautocmd` variant, but it doesn't work... I am not sure why, because this made sense. I will investigate further and get back to you. To clarify, the issue seems to be the same the buffer is deleted exactly after `vim.cmd.buffer`:```    vim.print(vim.api.nvim_list_bufs()) -> good         vim.print(vim.api.nvim_list_bufs())    vim.print(vim.api.nvim_list_bufs())    vim.print(vim.api.nvim_list_bufs())    vim.print(vim.api.nvim_list_bufs())    vim.print(vim.api.nvim_list_bufs())    vim.print(vim.api.nvim_list_bufs())    vim.print(vim.api.nvim_list_bufs())    vim.print(vim.api.nvim_list_bufs()) -> all good    vim.cmd.buffer{ args = { bufnr } , mods = { noautocmd = true }}    vim.print(vim.api.nvim_list_bufs()) -> 1 buffer deleted    ```",X
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1135568323,2023-03-14T13:44:19Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class CacheFindOpts+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---@field paths? string[] Extra paths to search for modname++M.VERSION = 2+M.path = vim.fn.stdpath('cache') .. '/luac'+M.enabled = false+---@type table<string, {total:number, time:number, [string]:number?}?>+M.stats = {+  find = { total = 0, time = 0, not_found = 0 },+}++---@class ModuleCache+---@field _rtp string[]+---@field _rtp_pure string[]+---@field _rtp_key string+local Cache = {+  ---@type table<string, table<string,true>>+  _indexed = {},+  ---@type table<string, string[]>+  _topmods = {},+  _loadfile = loadfile,+}++--- Tracks the time spent in a function+---@private+function M.track(stat, start)+  M.stats[stat] = M.stats[stat] or { total = 0, time = 0 }+  M.stats[stat].total = M.stats[stat].total + 1+  M.stats[stat].time = M.stats[stat].time + uv.hrtime() - start+end++--- slightly faster/different version than vim.fs.normalize+--- we also need to have it here, since the cache will load vim.fs+---@private+function Cache.normalize(path)+  if path:sub(1, 1) == '~' then+    local home = vim.loop.os_homedir() or '~'+    if home:sub(-1) == '\\' or home:sub(-1) == '/' then+      home = home:sub(1, -2)+    end+    path = home .. path:sub(2)+  end+  path = path:gsub('\\', '/'):gsub('/+', '/')+  return path:sub(-1) == '/' and path:sub(1, -2) or path+end++--- Gets the rtp excluding after directories.+--- The result is cached, and will be updated if the runtime path changes.+--- When called from a fast event, the cached value will be returned.+--- @return string[] rtp, boolean updated+---@private+function Cache.get_rtp()+  local start = uv.hrtime()+  if vim.in_fast_event() then+    M.track('get_rtp', start)+    return (Cache._rtp or {}), false+  end+  local updated = false+  local key = vim.go.rtp+  if key ~= Cache._rtp_key then+    Cache._rtp = {}+    for _, path in ipairs(vim.api.nvim_get_runtime_file('', true)) do+      path = Cache.normalize(path)+      -- skip after directories+      if+        path:sub(-6, -1) ~= '/after'+        and not (Cache._indexed[path] and vim.tbl_isempty(Cache._indexed[path]))+      then+        Cache._rtp[#Cache._rtp + 1] = path+      end+    end+    updated = true+    Cache._rtp_key = key+  end+  M.track('get_rtp', start)+  return Cache._rtp, updated+end++--- Returns the cache file name+---@param name string can be a module name, or a file name+---@return string file_name+---@private+function Cache.cache_file(name)+  local ret = M.path .. '/' .. name:gsub('[/\\:]', '%%')+  return ret:sub(-4) == '.lua' and (ret .. 'c') or (ret .. '.luac')+end++--- Saves the cache entry for a given module or file+---@param name string module name or filename+---@param entry CacheEntry+---@private+function Cache.write(name, entry)+  local cname = Cache.cache_file(name)+  local f = assert(uv.fs_open(cname, 'w', 438))+  local header = {+    M.VERSION,+    entry.hash.size,+    entry.hash.mtime.sec,+    entry.hash.mtime.nsec,+  }+  uv.fs_write(f, ffi.string(ffi.new('const uint32_t[4]', header), 16))+  uv.fs_write(f, entry.chunk)+  uv.fs_close(f)+end++--- Loads the cache entry for a given module or file+---@param name string module name or filename+---@return CacheEntry?+---@private+function Cache.read(name)+  local start = uv.hrtime()+  local cname = Cache.cache_file(name)+  local f = uv.fs_open(cname, 'r', 438)+  if f then+    local hash = uv.fs_fstat(f) --[[@as CacheHash]]+    local data = uv.fs_read(f, hash.size, 0) --[[@as string]]+    uv.fs_close(f)++    ---@type integer[]|{[0]:integer}+    local header = ffi.cast('uint32_t*', ffi.new('const char[16]', data:sub(1, 16)))+    if header[0] ~= M.VERSION then+      return+    end+    M.track('read', start)+    return {+      hash = { size = header[1], mtime = { sec = header[2], nsec = header[3] } },+      chunk = data:sub(16 + 1),+    }+  end+  M.track('read', start)+end++--- The `package.loaders` loader for lua files using the cache.+---@param modname string module name+---@return string|function+---@private+function Cache.loader(modname)+  local start = uv.hrtime()+  local modpath, hash = M.find(modname)+  if modpath then+    local chunk, err = M.load(modpath, { hash = hash })+    M.track('loader', start)+    return chunk or error(err)+  end+  M.track('loader', start)+  return '\ncache_loader: module ' .. modname .. ' not found'+end++--- The `package.loaders` loader for libs+---@param modname string module name+---@return string|function+---@private+function Cache.loader_lib(modname)+  local start = uv.hrtime()+  local modpath = M.find(modname, { patterns = jit.os:find('Windows') and { '.dll' } or { '.so' } })+  ---@type function?, string?+  if modpath then+    -- Making function name in Lua 5.1 (see src/loadlib.c:mkfuncname) is+    -- a) strip prefix up to and including the first dash, if any+    -- b) replace all dots by underscores+    -- c) prepend ""luaopen_""+    -- So ""foo-bar.baz"" should result in ""luaopen_bar_baz""+    local dash = modname:find('-', 1, true)+    local funcname = dash and modname:sub(dash + 1) or modname+    local chunk, err = package.loadlib(modpath, 'luaopen_' .. funcname:gsub('%.', '_'))+    M.track('loader_lib', start)+    return chunk or error(err)+  end+  M.track('loader_lib', start)+  return '\ncache_loader_lib: module ' .. modname .. ' not found'+end++--- `loadfile` using the cache+---@param filename? string+---@param mode? ""b""|""t""|""bt""+---@param env? table+---@return function?, string?  error_message+---@private+-- luacheck: ignore 312+function Cache.loadfile(filename, mode, env)+  local start = uv.hrtime()+  filename = Cache.normalize(filename)+  mode = nil -- ignore mode, since we byte-compile the lua source files+  local chunk, err = M.load(filename, { mode = mode, env = env })+  M.track('loadfile', start)+  return chunk, err+end++--- Checks whether two cache hashes are the same based on:+--- * file size+--- * mtime in seconds+--- * mtime in nanoseconds+---@param h1 CacheHash+---@param h2 CacheHash+---@private+function Cache.eq(h1, h2)+  return h1+    and h2+    and h1.size == h2.size+    and h1.mtime.sec == h2.mtime.sec+    and h1.mtime.nsec == h2.mtime.nsec+end++--- Loads the given module path using the cache+---@param modpath string+---@param opts? {hash?: CacheHash, mode?: ""b""|""t""|""bt"", env?:table} (table|nil) Options for loading the module:+---    - hash: (table) the hash of the file to load if it is already known. (defaults to `vim.loop.fs_stat({modpath})`)+---    - mode: (string) the mode to load the module with. ""b""|""t""|""bt"" (defaults to `nil`)+---    - env: (table) the environment to load the module in. (defaults to `nil`)+---@see |luaL_loadfile()|+---@return function?, string? error_message+function M.load(modpath, opts)+  local start = uv.hrtime()++  opts = opts or {}+  local hash = opts.hash or uv.fs_stat(modpath)+  ---@type function?, string?+  local chunk, err++  if not hash then+    -- trigger correct error+    chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+    M.track('load', start)+    return chunk, err+  end++  local entry = Cache.read(modpath)+  if entry and Cache.eq(entry.hash, hash) then+    -- found in cache and up to date+    -- selene: allow(incorrect_standard_library_use)+    chunk, err = load(entry.chunk --[[@as string]], '@' .. modpath, opts.mode, opts.env)+    if not (err and err:find('cannot load incompatible bytecode', 1, true)) then+      M.track('load', start)+      return chunk, err+    end+  end+  entry = { hash = hash, modpath = modpath }++  chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+  if chunk then+    entry.chunk = string.dump(chunk)+    Cache.write(modpath, entry)+  end+  M.track('load', start)+  return chunk, err+end++--- Finds the module path for the given module name+---@param modname string+---@param opts? CacheFindOpts (table|nil) Options for finding a module:+---    - rtp: (boolean) Search for modname in the runtime path (defaults to `true`)+---    - patterns: (string[]) Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---    - paths: (string[]) Extra paths to search for modname (defaults to `{}`)+---@return string? modpath, CacheHash? hash (string|nil) modpath for the module+function M.find(modname, opts)","It checks the rtp by default, unless `rtp=false`. Is that what you mean?I use it in lazy to find modules from plugins that are not yet loaded. For that I pass `rtp=false` and `paths=paths_of_unloaded_plugins`",
5160701,seblj,https://api.github.com/repos/neovim/neovim/pulls/22634,1135660404,2023-03-14T14:39:02Z,runtime/doc/treesitter.txt,"@@ -547,6 +547,21 @@ get_captures_at_pos({bufnr}, {row}, {col})     Return: ~         table[] List of captures `{ capture = ""name"", metadata = { ... } }` +get_lang({opts})                                   *vim.treesitter.get_lang()*",Could this take in an option to ignore specific langs (or ignore `comment` by default) ? I have something similar in my config for getting the commentstring. I'm not sure it would work correctly when uncommenting in a lua-block in a markdown file for example. It would then get the `comment` lang and not `lua` which I would expect,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22668,1135771763,2023-03-14T15:47:33Z,runtime/lua/vim/cache.lua,,"fwiw, adding a `@defgroup` block at the top is a way to also generate module-level docs (as opposed to function-level). Example: https://github.com/neovim/neovim/blob/d1e0f7454b5fc61d26db5af5ce00c1894e7c49fc/runtime/lua/vim/treesitter/languagetree.lua#L1the group name must match the generated section name, which in this case is `lua-cache`.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22668,1135814620,2023-03-14T16:14:09Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')",> i wouldn't use mpack for the file-based cache.Is there a technical reason why?,
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1135816402,2023-03-14T16:15:05Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')","Alright, nevermind. Will change the implementation so it no longer needs ffi and also won't need mpack",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22634,1135858020,2023-03-14T16:27:56Z,runtime/lua/vim/treesitter.lua,"@@ -658,4 +658,36 @@ function M.foldexpr(lnum)   return require('vim.treesitter._fold').foldexpr(lnum) end +---Get the lang for a buffer and position taking into account+---language injections.+---@param opts table|nil Optional keyword arguments:+---             - bufnr integer|nil Buffer number (nil or 0 for current buffer)+---             - pos table|nil 0-indexed (row, col) tuple. Defaults to cursor position in the+---                             current window. Required if {bufnr} is not the current buffer+---@return string|nil+function M.get_lang(opts)",This function already exists elsewhere:https://github.com/neovim/neovim/blob/d1e0f7454b5fc61d26db5af5ce00c1894e7c49fc/runtime/lua/vim/treesitter/language.lua#L8-L12(Guess who added that last month ;)),
15110622,Ursescu,https://api.github.com/repos/neovim/neovim/pulls/22267,1135861653,2023-03-14T16:30:08Z,runtime/lua/vim/lsp.lua,"@@ -1112,19 +1112,43 @@ function lsp.start_client(config)     end   end +  ---@private+  -- Determines whether the given option can be set by `set_defaults`.+  local function is_empty_or_default(bufnr, option)+    if vim.bo[bufnr][option] == '' then+      return true+    end++    local old_bufnr = vim.fn.bufnr('')+    local last_set_from = vim.fn.gettext('\n\tLast set from ')+    local line = vim.fn.gettext(' line ')++    vim.cmd.buffer(bufnr)+    local scriptname = vim.fn+      .execute('verbose set ' .. option .. '?')+      :match(last_set_from .. '(.*)' .. line .. '%d+')+    vim.cmd.buffer(old_bufnr)","After doing some tests I concluded that the command itself will cause the NvimTree buffer to be unloaded. I am not sure how `:buffer` really works under the hood and what interactions are between unlisted buffers and normal buffers. Even if I wrap the whole thing with `eventignore` to stop the events (I actually added prints on each autocmd registered and none is triggered), still the buffer is unloaded. I tried the command `:buffer 4` (some random existing buffer) while current buffer == NvimTree buffer and I see the same behavior (buffer unloaded).```:buffers!                                                                                                                                                                                                             2u h   ""[Scratch]""                    line 0                                                                                                                                                                        3  a   ""init.lua""                     line 175                                                                                                                                                                      4      ""stuff.txt""                    line 1                                                                                                                                                                        5      ""lua/autocmds.lua""             line 27                                                                                                                                                                       6 #a   ""~/.config/nvim/lua/plugins.lua"" line 101                                                                                                                                                                    8u%a-  ""NvimTree_1""                   line 4    ```  So in the end I think the issue is more or less dependent on the setup/plugins/configuration and not necessarily due to this PR. Still it would be awesome to not rely on buffer switching here.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22634,1135894443,2023-03-14T16:49:59Z,runtime/lua/vim/treesitter.lua,"@@ -658,4 +658,36 @@ function M.foldexpr(lnum)   return require('vim.treesitter._fold').foldexpr(lnum) end +---Get the lang for a buffer and position taking into account+---language injections.+---@param opts table|nil Optional keyword arguments:+---             - bufnr integer|nil Buffer number (nil or 0 for current buffer)+---             - pos table|nil 0-indexed (row, col) tuple. Defaults to cursor position in the+---                             current window. Required if {bufnr} is not the current buffer+---@return string|nil+function M.get_lang(opts)","> get_lang() gets removed in https://github.com/neovim/neovim/pull/22643. Instead, we will use vim.filetype.get_option(filetype, 'parser') as a direct replacement.So that PR is a prerequisite for this one? (Asking because that duplication is what's failing all the builds.)",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1135896313,2023-03-14T16:51:22Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class CacheFindOpts+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---@field paths? string[] Extra paths to search for modname++M.VERSION = 2+M.path = vim.fn.stdpath('cache') .. '/luac'+M.enabled = false+---@type table<string, {total:number, time:number, [string]:number?}?>+M.stats = {+  find = { total = 0, time = 0, not_found = 0 },+}++---@class ModuleCache+---@field _rtp string[]+---@field _rtp_pure string[]+---@field _rtp_key string+local Cache = {+  ---@type table<string, table<string,true>>+  _indexed = {},+  ---@type table<string, string[]>+  _topmods = {},+  _loadfile = loadfile,+}++--- Tracks the time spent in a function+---@private+function M.track(stat, start)+  M.stats[stat] = M.stats[stat] or { total = 0, time = 0 }+  M.stats[stat].total = M.stats[stat].total + 1+  M.stats[stat].time = M.stats[stat].time + uv.hrtime() - start+end++--- slightly faster/different version than vim.fs.normalize+--- we also need to have it here, since the cache will load vim.fs+---@private+function Cache.normalize(path)+  if path:sub(1, 1) == '~' then+    local home = vim.loop.os_homedir() or '~'+    if home:sub(-1) == '\\' or home:sub(-1) == '/' then+      home = home:sub(1, -2)+    end+    path = home .. path:sub(2)+  end+  path = path:gsub('\\', '/'):gsub('/+', '/')+  return path:sub(-1) == '/' and path:sub(1, -2) or path+end++--- Gets the rtp excluding after directories.+--- The result is cached, and will be updated if the runtime path changes.+--- When called from a fast event, the cached value will be returned.+--- @return string[] rtp, boolean updated+---@private+function Cache.get_rtp()+  local start = uv.hrtime()+  if vim.in_fast_event() then+    M.track('get_rtp', start)+    return (Cache._rtp or {}), false+  end+  local updated = false+  local key = vim.go.rtp+  if key ~= Cache._rtp_key then+    Cache._rtp = {}+    for _, path in ipairs(vim.api.nvim_get_runtime_file('', true)) do+      path = Cache.normalize(path)+      -- skip after directories+      if+        path:sub(-6, -1) ~= '/after'+        and not (Cache._indexed[path] and vim.tbl_isempty(Cache._indexed[path]))+      then+        Cache._rtp[#Cache._rtp + 1] = path+      end+    end+    updated = true+    Cache._rtp_key = key+  end+  M.track('get_rtp', start)+  return Cache._rtp, updated+end++--- Returns the cache file name+---@param name string can be a module name, or a file name+---@return string file_name+---@private+function Cache.cache_file(name)+  local ret = M.path .. '/' .. name:gsub('[/\\:]', '%%')+  return ret:sub(-4) == '.lua' and (ret .. 'c') or (ret .. '.luac')+end++--- Saves the cache entry for a given module or file+---@param name string module name or filename+---@param entry CacheEntry+---@private+function Cache.write(name, entry)+  local cname = Cache.cache_file(name)+  local f = assert(uv.fs_open(cname, 'w', 438))+  local header = {+    M.VERSION,+    entry.hash.size,+    entry.hash.mtime.sec,+    entry.hash.mtime.nsec,+  }+  uv.fs_write(f, ffi.string(ffi.new('const uint32_t[4]', header), 16))+  uv.fs_write(f, entry.chunk)+  uv.fs_close(f)+end++--- Loads the cache entry for a given module or file+---@param name string module name or filename+---@return CacheEntry?+---@private+function Cache.read(name)+  local start = uv.hrtime()+  local cname = Cache.cache_file(name)+  local f = uv.fs_open(cname, 'r', 438)+  if f then+    local hash = uv.fs_fstat(f) --[[@as CacheHash]]+    local data = uv.fs_read(f, hash.size, 0) --[[@as string]]+    uv.fs_close(f)++    ---@type integer[]|{[0]:integer}+    local header = ffi.cast('uint32_t*', ffi.new('const char[16]', data:sub(1, 16)))+    if header[0] ~= M.VERSION then+      return+    end+    M.track('read', start)+    return {+      hash = { size = header[1], mtime = { sec = header[2], nsec = header[3] } },+      chunk = data:sub(16 + 1),+    }+  end+  M.track('read', start)+end++--- The `package.loaders` loader for lua files using the cache.+---@param modname string module name+---@return string|function+---@private+function Cache.loader(modname)+  local start = uv.hrtime()+  local modpath, hash = M.find(modname)+  if modpath then+    local chunk, err = M.load(modpath, { hash = hash })+    M.track('loader', start)+    return chunk or error(err)+  end+  M.track('loader', start)+  return '\ncache_loader: module ' .. modname .. ' not found'+end++--- The `package.loaders` loader for libs+---@param modname string module name+---@return string|function+---@private+function Cache.loader_lib(modname)+  local start = uv.hrtime()+  local modpath = M.find(modname, { patterns = jit.os:find('Windows') and { '.dll' } or { '.so' } })+  ---@type function?, string?+  if modpath then+    -- Making function name in Lua 5.1 (see src/loadlib.c:mkfuncname) is+    -- a) strip prefix up to and including the first dash, if any+    -- b) replace all dots by underscores+    -- c) prepend ""luaopen_""+    -- So ""foo-bar.baz"" should result in ""luaopen_bar_baz""+    local dash = modname:find('-', 1, true)+    local funcname = dash and modname:sub(dash + 1) or modname+    local chunk, err = package.loadlib(modpath, 'luaopen_' .. funcname:gsub('%.', '_'))+    M.track('loader_lib', start)+    return chunk or error(err)+  end+  M.track('loader_lib', start)+  return '\ncache_loader_lib: module ' .. modname .. ' not found'+end++--- `loadfile` using the cache+---@param filename? string+---@param mode? ""b""|""t""|""bt""+---@param env? table+---@return function?, string?  error_message+---@private+-- luacheck: ignore 312+function Cache.loadfile(filename, mode, env)+  local start = uv.hrtime()+  filename = Cache.normalize(filename)+  mode = nil -- ignore mode, since we byte-compile the lua source files+  local chunk, err = M.load(filename, { mode = mode, env = env })+  M.track('loadfile', start)+  return chunk, err+end++--- Checks whether two cache hashes are the same based on:+--- * file size+--- * mtime in seconds+--- * mtime in nanoseconds+---@param h1 CacheHash+---@param h2 CacheHash+---@private+function Cache.eq(h1, h2)+  return h1+    and h2+    and h1.size == h2.size+    and h1.mtime.sec == h2.mtime.sec+    and h1.mtime.nsec == h2.mtime.nsec+end++--- Loads the given module path using the cache+---@param modpath string+---@param opts? {hash?: CacheHash, mode?: ""b""|""t""|""bt"", env?:table} (table|nil) Options for loading the module:+---    - hash: (table) the hash of the file to load if it is already known. (defaults to `vim.loop.fs_stat({modpath})`)+---    - mode: (string) the mode to load the module with. ""b""|""t""|""bt"" (defaults to `nil`)+---    - env: (table) the environment to load the module in. (defaults to `nil`)+---@see |luaL_loadfile()|+---@return function?, string? error_message+function M.load(modpath, opts)+  local start = uv.hrtime()++  opts = opts or {}+  local hash = opts.hash or uv.fs_stat(modpath)+  ---@type function?, string?+  local chunk, err++  if not hash then+    -- trigger correct error+    chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+    M.track('load', start)+    return chunk, err+  end++  local entry = Cache.read(modpath)+  if entry and Cache.eq(entry.hash, hash) then+    -- found in cache and up to date+    -- selene: allow(incorrect_standard_library_use)+    chunk, err = load(entry.chunk --[[@as string]], '@' .. modpath, opts.mode, opts.env)+    if not (err and err:find('cannot load incompatible bytecode', 1, true)) then+      M.track('load', start)+      return chunk, err+    end+  end+  entry = { hash = hash, modpath = modpath }++  chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+  if chunk then+    entry.chunk = string.dump(chunk)+    Cache.write(modpath, entry)+  end+  M.track('load', start)+  return chunk, err+end++--- Finds the module path for the given module name+---@param modname string+---@param opts? CacheFindOpts (table|nil) Options for finding a module:+---    - rtp: (boolean) Search for modname in the runtime path (defaults to `true`)+---    - patterns: (string[]) Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---    - paths: (string[]) Extra paths to search for modname (defaults to `{}`)+---@return string? modpath, CacheHash? hash (string|nil) modpath for the module+function M.find(modname, opts)+  local start = uv.hrtime()+  opts = opts or {}++  modname = modname:gsub('/', '.')+  local basename = modname:gsub('%.', '/')+  local idx = modname:find('.', 1, true)++  -- HACK: fix incorrect require statements. Really not a fan of keeping this,+  -- but apparently the regular lua loader also allows this+  if idx == 1 then+    modname = modname:gsub('^%.+', '')+    basename = modname:gsub('%.', '/')+    idx = modname:find('.', 1, true)+  end++  -- get the top-level module name+  local topmod = idx and modname:sub(1, idx - 1) or modname++  -- OPTIM: search for a directory first when topmod == modname+  local patterns = opts.patterns+    or (topmod == modname and { '/init.lua', '.lua' } or { '.lua', '/init.lua' })+  for p, pattern in ipairs(patterns) do+    patterns[p] = '/lua/' .. basename .. pattern+  end++  -- Checks if the given paths contain the top-level module.+  -- If so, it tries to find the module path for the given module name.+  ---@param paths string[]+  ---@return string? modpath, CacheHash? hash+  ---@private+  local function _find(paths)+    for _, path in ipairs(paths) do+      if M.lsmod(path)[topmod] then+        for _, pattern in ipairs(patterns) do+          local modpath = path .. pattern+          M.stats.find.stat = (M.stats.find.stat or 0) + 1+          local hash = uv.fs_stat(modpath)+          if hash then+            return modpath, hash+          end+        end+      end+    end+  end++  ---@type string?, CacheHash?+  local modpath, hash++  -- always check the rtp first+  if opts.rtp ~= false then+    modpath, hash = _find(Cache._rtp or {})+    if not modpath then+      local rtp, updated = Cache.get_rtp()+      if updated then+        modpath, hash = _find(rtp)+      end+    end+  end++  -- check any additional paths+  if (not modpath) and opts.paths then+    modpath, hash = _find(opts.paths)+  end++  M.track('find', start)+  if modpath then+    return modpath, hash+  end+  -- module not found+  M.stats.find.not_found = M.stats.find.not_found + 1+end++--- Resets the topmods cache for the path+---@param path string path to reset+function M.reset(path)+  Cache._indexed[Cache.normalize(path)] = nil+end++--- Enables the cache:+--- * override loadfile+--- * adds the lua loader+--- * adds the libs loader+--- * remove the Neovim loader+function M.enable()+  if M.enabled then+    return+  end+  M.enabled = true+  vim.fn.mkdir(vim.fn.fnamemodify(M.path, ':p'), 'p')+  -- selene: allow(global_usage)+  _G.loadfile = Cache.loadfile+  -- add lua loader+  table.insert(package.loaders, 2, Cache.loader)+  -- add libs loader+  table.insert(package.loaders, 3, Cache.loader_lib)+  -- remove Neovim loader+  for l, loader in ipairs(package.loaders) do+    if loader == vim._load_package then+      table.remove(package.loaders, l)+      break+    end+  end+  -- TODO: add an autocmd on BufWritePost that checks if its in a /lua folder+  -- if thats the case, then reset the plugin path.+  -- This will make sure we can properly load new top-level lua modules+end++--- Disables the cache:+--- * removes the cache loaders+--- * adds the Neovim loader+function M.disable()+  if not M.enabled then+    return+  end+  M.enabled = false+  -- selene: allow(global_usage)+  _G.loadfile = Cache._loadfile+  ---@diagnostic disable-next-line: no-unknown+  for l, loader in ipairs(package.loaders) do+    if loader == Cache.loader or loader == Cache.loader_lib then+      table.remove(package.loaders, l)+    end+  end+  table.insert(package.loaders, 2, vim._load_package)+end++--- Return the top-level `/lua/*` modules for this path+---@param path string path to check for top-level lua modules+---@return string[]+function M.lsmod(path)+  if not Cache._indexed[path] then+    local start = uv.hrtime()+    Cache._indexed[path] = {}+    local handle = vim.loop.fs_scandir(path .. '/lua')+    while handle do+      local name, t = vim.loop.fs_scandir_next(handle)+      if not name then+        break+      end+      -- HACK: type is not always returned due to a bug in luv+      t = t or uv.fs_stat(path .. '/lua/' .. name).type+      ---@type string+      local topname+      local ext = name:sub(-4)+      if ext == '.lua' or ext == '.dll' then+        topname = name:sub(1, -5)+      elseif name:sub(-3) == '.so' then+        topname = name:sub(1, -4)+      elseif t == 'link' or t == 'directory' then+        topname = name+      end+      if topname then+        Cache._indexed[path][topname] = true+        Cache._topmods[topname] = Cache._topmods[topname] or {}+        if not vim.tbl_contains(Cache._topmods[topname], path) then+          table.insert(Cache._topmods[topname], path)+        end+      end+    end+    M.track('lsmod', start)+  end+  return Cache._indexed[path]+end++--- Debug function that wrapps all loaders and tracks stats+function M.profile_loaders()+  for l, loader in pairs(package.loaders) do+    local loc = debug.getinfo(loader, 'Sn').source:sub(2)+    package.loaders[l] = function(modname)+      local start = vim.loop.hrtime()+      local ret = loader(modname)+      M.track('loader ' .. l .. ': ' .. loc, start)+      M.track('loader_all', start)+      return ret+    end+  end+end++--- Prints all cache stats+function M.inspect()","I'd rather keep this, since it's similar to other inspect methods we have?",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22634,1135897613,2023-03-14T16:52:19Z,runtime/lua/vim/treesitter.lua,"@@ -658,4 +658,36 @@ function M.foldexpr(lnum)   return require('vim.treesitter._fold').foldexpr(lnum) end +---Get the lang for a buffer and position taking into account+---language injections.+---@param opts table|nil Optional keyword arguments:+---             - bufnr integer|nil Buffer number (nil or 0 for current buffer)+---             - pos table|nil 0-indexed (row, col) tuple. Defaults to cursor position in the+---                             current window. Required if {bufnr} is not the current buffer+---@return string|nil+function M.get_lang(opts)","> So that PR is a prerequisite for this one? (Asking because that duplication is what's failing all the builds.)They are linked, both are draft remember ���� ",X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22634,1135899249,2023-03-14T16:53:36Z,runtime/lua/vim/treesitter.lua,"@@ -658,4 +658,36 @@ function M.foldexpr(lnum)   return require('vim.treesitter._fold').foldexpr(lnum) end +---Get the lang for a buffer and position taking into account+---language injections.+---@param opts table|nil Optional keyword arguments:+---             - bufnr integer|nil Buffer number (nil or 0 for current buffer)+---             - pos table|nil 0-indexed (row, col) tuple. Defaults to cursor position in the+---                             current window. Required if {bufnr} is not the current buffer+---@return string|nil+function M.get_lang(opts)","As long as people coming from treesitter can make the connection (and vice versa, if someone needs to look up upstream docs).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22668,1135943291,2023-03-14T17:23:33Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class CacheFindOpts+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---@field paths? string[] Extra paths to search for modname++M.VERSION = 2+M.path = vim.fn.stdpath('cache') .. '/luac'+M.enabled = false+---@type table<string, {total:number, time:number, [string]:number?}?>+M.stats = {+  find = { total = 0, time = 0, not_found = 0 },+}++---@class ModuleCache+---@field _rtp string[]+---@field _rtp_pure string[]+---@field _rtp_key string+local Cache = {+  ---@type table<string, table<string,true>>+  _indexed = {},+  ---@type table<string, string[]>+  _topmods = {},+  _loadfile = loadfile,+}++--- Tracks the time spent in a function+---@private+function M.track(stat, start)+  M.stats[stat] = M.stats[stat] or { total = 0, time = 0 }+  M.stats[stat].total = M.stats[stat].total + 1+  M.stats[stat].time = M.stats[stat].time + uv.hrtime() - start+end++--- slightly faster/different version than vim.fs.normalize+--- we also need to have it here, since the cache will load vim.fs+---@private+function Cache.normalize(path)+  if path:sub(1, 1) == '~' then+    local home = vim.loop.os_homedir() or '~'+    if home:sub(-1) == '\\' or home:sub(-1) == '/' then+      home = home:sub(1, -2)+    end+    path = home .. path:sub(2)+  end+  path = path:gsub('\\', '/'):gsub('/+', '/')+  return path:sub(-1) == '/' and path:sub(1, -2) or path+end++--- Gets the rtp excluding after directories.+--- The result is cached, and will be updated if the runtime path changes.+--- When called from a fast event, the cached value will be returned.+--- @return string[] rtp, boolean updated+---@private+function Cache.get_rtp()+  local start = uv.hrtime()+  if vim.in_fast_event() then+    M.track('get_rtp', start)+    return (Cache._rtp or {}), false+  end+  local updated = false+  local key = vim.go.rtp+  if key ~= Cache._rtp_key then+    Cache._rtp = {}+    for _, path in ipairs(vim.api.nvim_get_runtime_file('', true)) do+      path = Cache.normalize(path)+      -- skip after directories+      if+        path:sub(-6, -1) ~= '/after'+        and not (Cache._indexed[path] and vim.tbl_isempty(Cache._indexed[path]))+      then+        Cache._rtp[#Cache._rtp + 1] = path+      end+    end+    updated = true+    Cache._rtp_key = key+  end+  M.track('get_rtp', start)+  return Cache._rtp, updated+end++--- Returns the cache file name+---@param name string can be a module name, or a file name+---@return string file_name+---@private+function Cache.cache_file(name)+  local ret = M.path .. '/' .. name:gsub('[/\\:]', '%%')+  return ret:sub(-4) == '.lua' and (ret .. 'c') or (ret .. '.luac')+end++--- Saves the cache entry for a given module or file+---@param name string module name or filename+---@param entry CacheEntry+---@private+function Cache.write(name, entry)+  local cname = Cache.cache_file(name)+  local f = assert(uv.fs_open(cname, 'w', 438))+  local header = {+    M.VERSION,+    entry.hash.size,+    entry.hash.mtime.sec,+    entry.hash.mtime.nsec,+  }+  uv.fs_write(f, ffi.string(ffi.new('const uint32_t[4]', header), 16))+  uv.fs_write(f, entry.chunk)+  uv.fs_close(f)+end++--- Loads the cache entry for a given module or file+---@param name string module name or filename+---@return CacheEntry?+---@private+function Cache.read(name)+  local start = uv.hrtime()+  local cname = Cache.cache_file(name)+  local f = uv.fs_open(cname, 'r', 438)+  if f then+    local hash = uv.fs_fstat(f) --[[@as CacheHash]]+    local data = uv.fs_read(f, hash.size, 0) --[[@as string]]+    uv.fs_close(f)++    ---@type integer[]|{[0]:integer}+    local header = ffi.cast('uint32_t*', ffi.new('const char[16]', data:sub(1, 16)))+    if header[0] ~= M.VERSION then+      return+    end+    M.track('read', start)+    return {+      hash = { size = header[1], mtime = { sec = header[2], nsec = header[3] } },+      chunk = data:sub(16 + 1),+    }+  end+  M.track('read', start)+end++--- The `package.loaders` loader for lua files using the cache.+---@param modname string module name+---@return string|function+---@private+function Cache.loader(modname)+  local start = uv.hrtime()+  local modpath, hash = M.find(modname)+  if modpath then+    local chunk, err = M.load(modpath, { hash = hash })+    M.track('loader', start)+    return chunk or error(err)+  end+  M.track('loader', start)+  return '\ncache_loader: module ' .. modname .. ' not found'+end++--- The `package.loaders` loader for libs+---@param modname string module name+---@return string|function+---@private+function Cache.loader_lib(modname)+  local start = uv.hrtime()+  local modpath = M.find(modname, { patterns = jit.os:find('Windows') and { '.dll' } or { '.so' } })+  ---@type function?, string?+  if modpath then+    -- Making function name in Lua 5.1 (see src/loadlib.c:mkfuncname) is+    -- a) strip prefix up to and including the first dash, if any+    -- b) replace all dots by underscores+    -- c) prepend ""luaopen_""+    -- So ""foo-bar.baz"" should result in ""luaopen_bar_baz""+    local dash = modname:find('-', 1, true)+    local funcname = dash and modname:sub(dash + 1) or modname+    local chunk, err = package.loadlib(modpath, 'luaopen_' .. funcname:gsub('%.', '_'))+    M.track('loader_lib', start)+    return chunk or error(err)+  end+  M.track('loader_lib', start)+  return '\ncache_loader_lib: module ' .. modname .. ' not found'+end++--- `loadfile` using the cache+---@param filename? string+---@param mode? ""b""|""t""|""bt""+---@param env? table+---@return function?, string?  error_message+---@private+-- luacheck: ignore 312+function Cache.loadfile(filename, mode, env)+  local start = uv.hrtime()+  filename = Cache.normalize(filename)+  mode = nil -- ignore mode, since we byte-compile the lua source files+  local chunk, err = M.load(filename, { mode = mode, env = env })+  M.track('loadfile', start)+  return chunk, err+end++--- Checks whether two cache hashes are the same based on:+--- * file size+--- * mtime in seconds+--- * mtime in nanoseconds+---@param h1 CacheHash+---@param h2 CacheHash+---@private+function Cache.eq(h1, h2)+  return h1+    and h2+    and h1.size == h2.size+    and h1.mtime.sec == h2.mtime.sec+    and h1.mtime.nsec == h2.mtime.nsec+end++--- Loads the given module path using the cache+---@param modpath string+---@param opts? {hash?: CacheHash, mode?: ""b""|""t""|""bt"", env?:table} (table|nil) Options for loading the module:+---    - hash: (table) the hash of the file to load if it is already known. (defaults to `vim.loop.fs_stat({modpath})`)+---    - mode: (string) the mode to load the module with. ""b""|""t""|""bt"" (defaults to `nil`)+---    - env: (table) the environment to load the module in. (defaults to `nil`)+---@see |luaL_loadfile()|+---@return function?, string? error_message+function M.load(modpath, opts)+  local start = uv.hrtime()++  opts = opts or {}+  local hash = opts.hash or uv.fs_stat(modpath)+  ---@type function?, string?+  local chunk, err++  if not hash then+    -- trigger correct error+    chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+    M.track('load', start)+    return chunk, err+  end++  local entry = Cache.read(modpath)+  if entry and Cache.eq(entry.hash, hash) then+    -- found in cache and up to date+    -- selene: allow(incorrect_standard_library_use)+    chunk, err = load(entry.chunk --[[@as string]], '@' .. modpath, opts.mode, opts.env)+    if not (err and err:find('cannot load incompatible bytecode', 1, true)) then+      M.track('load', start)+      return chunk, err+    end+  end+  entry = { hash = hash, modpath = modpath }++  chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+  if chunk then+    entry.chunk = string.dump(chunk)+    Cache.write(modpath, entry)+  end+  M.track('load', start)+  return chunk, err+end++--- Finds the module path for the given module name+---@param modname string+---@param opts? CacheFindOpts (table|nil) Options for finding a module:+---    - rtp: (boolean) Search for modname in the runtime path (defaults to `true`)+---    - patterns: (string[]) Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---    - paths: (string[]) Extra paths to search for modname (defaults to `{}`)+---@return string? modpath, CacheHash? hash (string|nil) modpath for the module+function M.find(modname, opts)+  local start = uv.hrtime()+  opts = opts or {}++  modname = modname:gsub('/', '.')+  local basename = modname:gsub('%.', '/')+  local idx = modname:find('.', 1, true)++  -- HACK: fix incorrect require statements. Really not a fan of keeping this,+  -- but apparently the regular lua loader also allows this+  if idx == 1 then+    modname = modname:gsub('^%.+', '')+    basename = modname:gsub('%.', '/')+    idx = modname:find('.', 1, true)+  end++  -- get the top-level module name+  local topmod = idx and modname:sub(1, idx - 1) or modname++  -- OPTIM: search for a directory first when topmod == modname+  local patterns = opts.patterns+    or (topmod == modname and { '/init.lua', '.lua' } or { '.lua', '/init.lua' })+  for p, pattern in ipairs(patterns) do+    patterns[p] = '/lua/' .. basename .. pattern+  end++  -- Checks if the given paths contain the top-level module.+  -- If so, it tries to find the module path for the given module name.+  ---@param paths string[]+  ---@return string? modpath, CacheHash? hash+  ---@private+  local function _find(paths)+    for _, path in ipairs(paths) do+      if M.lsmod(path)[topmod] then+        for _, pattern in ipairs(patterns) do+          local modpath = path .. pattern+          M.stats.find.stat = (M.stats.find.stat or 0) + 1+          local hash = uv.fs_stat(modpath)+          if hash then+            return modpath, hash+          end+        end+      end+    end+  end++  ---@type string?, CacheHash?+  local modpath, hash++  -- always check the rtp first+  if opts.rtp ~= false then+    modpath, hash = _find(Cache._rtp or {})+    if not modpath then+      local rtp, updated = Cache.get_rtp()+      if updated then+        modpath, hash = _find(rtp)+      end+    end+  end++  -- check any additional paths+  if (not modpath) and opts.paths then+    modpath, hash = _find(opts.paths)+  end++  M.track('find', start)+  if modpath then+    return modpath, hash+  end+  -- module not found+  M.stats.find.not_found = M.stats.find.not_found + 1+end++--- Resets the topmods cache for the path+---@param path string path to reset+function M.reset(path)+  Cache._indexed[Cache.normalize(path)] = nil+end++--- Enables the cache:+--- * override loadfile+--- * adds the lua loader+--- * adds the libs loader+--- * remove the Neovim loader+function M.enable()+  if M.enabled then+    return+  end+  M.enabled = true+  vim.fn.mkdir(vim.fn.fnamemodify(M.path, ':p'), 'p')+  -- selene: allow(global_usage)+  _G.loadfile = Cache.loadfile+  -- add lua loader+  table.insert(package.loaders, 2, Cache.loader)+  -- add libs loader+  table.insert(package.loaders, 3, Cache.loader_lib)+  -- remove Neovim loader+  for l, loader in ipairs(package.loaders) do+    if loader == vim._load_package then+      table.remove(package.loaders, l)+      break+    end+  end+  -- TODO: add an autocmd on BufWritePost that checks if its in a /lua folder+  -- if thats the case, then reset the plugin path.+  -- This will make sure we can properly load new top-level lua modules+end++--- Disables the cache:+--- * removes the cache loaders+--- * adds the Neovim loader+function M.disable()+  if not M.enabled then+    return+  end+  M.enabled = false+  -- selene: allow(global_usage)+  _G.loadfile = Cache._loadfile+  ---@diagnostic disable-next-line: no-unknown+  for l, loader in ipairs(package.loaders) do+    if loader == Cache.loader or loader == Cache.loader_lib then+      table.remove(package.loaders, l)+    end+  end+  table.insert(package.loaders, 2, vim._load_package)+end++--- Return the top-level `/lua/*` modules for this path+---@param path string path to check for top-level lua modules+---@return string[]+function M.lsmod(path)+  if not Cache._indexed[path] then+    local start = uv.hrtime()+    Cache._indexed[path] = {}+    local handle = vim.loop.fs_scandir(path .. '/lua')+    while handle do+      local name, t = vim.loop.fs_scandir_next(handle)+      if not name then+        break+      end+      -- HACK: type is not always returned due to a bug in luv+      t = t or uv.fs_stat(path .. '/lua/' .. name).type+      ---@type string+      local topname+      local ext = name:sub(-4)+      if ext == '.lua' or ext == '.dll' then+        topname = name:sub(1, -5)+      elseif name:sub(-3) == '.so' then+        topname = name:sub(1, -4)+      elseif t == 'link' or t == 'directory' then+        topname = name+      end+      if topname then+        Cache._indexed[path][topname] = true+        Cache._topmods[topname] = Cache._topmods[topname] or {}+        if not vim.tbl_contains(Cache._topmods[topname], path) then+          table.insert(Cache._topmods[topname], path)+        end+      end+    end+    M.track('lsmod', start)+  end+  return Cache._indexed[path]+end++--- Debug function that wrapps all loaders and tracks stats+function M.profile_loaders()+  for l, loader in pairs(package.loaders) do+    local loc = debug.getinfo(loader, 'Sn').source:sub(2)+    package.loaders[l] = function(modname)+      local start = vim.loop.hrtime()+      local ret = loader(modname)+      M.track('loader ' .. l .. ': ' .. loc, start)+      M.track('loader_all', start)+      return ret+    end+  end+end++--- Prints all cache stats+function M.inspect()","> I'd rather keep this, since it's similar to other inspect methods we have?+1 but mark it as private and/or ""experimental"" so that we don't have to think much about future-proofing it yet? I assume that was @lewis6991 's main concern (which I agree with). ",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1135966695,2023-03-14T17:39:33Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')",Just changed the implementation so it no longer needs ffi (or mpack). Performance is the same.,
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1135980089,2023-03-14T17:50:06Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class CacheFindOpts+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---@field paths? string[] Extra paths to search for modname++M.VERSION = 2+M.path = vim.fn.stdpath('cache') .. '/luac'+M.enabled = false+---@type table<string, {total:number, time:number, [string]:number?}?>+M.stats = {+  find = { total = 0, time = 0, not_found = 0 },+}++---@class ModuleCache+---@field _rtp string[]+---@field _rtp_pure string[]+---@field _rtp_key string+local Cache = {+  ---@type table<string, table<string,true>>+  _indexed = {},+  ---@type table<string, string[]>+  _topmods = {},+  _loadfile = loadfile,+}++--- Tracks the time spent in a function+---@private+function M.track(stat, start)+  M.stats[stat] = M.stats[stat] or { total = 0, time = 0 }+  M.stats[stat].total = M.stats[stat].total + 1+  M.stats[stat].time = M.stats[stat].time + uv.hrtime() - start+end++--- slightly faster/different version than vim.fs.normalize+--- we also need to have it here, since the cache will load vim.fs+---@private+function Cache.normalize(path)+  if path:sub(1, 1) == '~' then+    local home = vim.loop.os_homedir() or '~'+    if home:sub(-1) == '\\' or home:sub(-1) == '/' then+      home = home:sub(1, -2)+    end+    path = home .. path:sub(2)+  end+  path = path:gsub('\\', '/'):gsub('/+', '/')+  return path:sub(-1) == '/' and path:sub(1, -2) or path+end++--- Gets the rtp excluding after directories.+--- The result is cached, and will be updated if the runtime path changes.+--- When called from a fast event, the cached value will be returned.+--- @return string[] rtp, boolean updated+---@private+function Cache.get_rtp()+  local start = uv.hrtime()+  if vim.in_fast_event() then+    M.track('get_rtp', start)+    return (Cache._rtp or {}), false+  end+  local updated = false+  local key = vim.go.rtp+  if key ~= Cache._rtp_key then+    Cache._rtp = {}+    for _, path in ipairs(vim.api.nvim_get_runtime_file('', true)) do+      path = Cache.normalize(path)+      -- skip after directories+      if+        path:sub(-6, -1) ~= '/after'+        and not (Cache._indexed[path] and vim.tbl_isempty(Cache._indexed[path]))+      then+        Cache._rtp[#Cache._rtp + 1] = path+      end+    end+    updated = true+    Cache._rtp_key = key+  end+  M.track('get_rtp', start)+  return Cache._rtp, updated+end++--- Returns the cache file name+---@param name string can be a module name, or a file name+---@return string file_name+---@private+function Cache.cache_file(name)+  local ret = M.path .. '/' .. name:gsub('[/\\:]', '%%')+  return ret:sub(-4) == '.lua' and (ret .. 'c') or (ret .. '.luac')+end++--- Saves the cache entry for a given module or file+---@param name string module name or filename+---@param entry CacheEntry+---@private+function Cache.write(name, entry)+  local cname = Cache.cache_file(name)+  local f = assert(uv.fs_open(cname, 'w', 438))+  local header = {+    M.VERSION,+    entry.hash.size,+    entry.hash.mtime.sec,+    entry.hash.mtime.nsec,+  }+  uv.fs_write(f, ffi.string(ffi.new('const uint32_t[4]', header), 16))+  uv.fs_write(f, entry.chunk)+  uv.fs_close(f)+end++--- Loads the cache entry for a given module or file+---@param name string module name or filename+---@return CacheEntry?+---@private+function Cache.read(name)+  local start = uv.hrtime()+  local cname = Cache.cache_file(name)+  local f = uv.fs_open(cname, 'r', 438)+  if f then+    local hash = uv.fs_fstat(f) --[[@as CacheHash]]+    local data = uv.fs_read(f, hash.size, 0) --[[@as string]]+    uv.fs_close(f)++    ---@type integer[]|{[0]:integer}+    local header = ffi.cast('uint32_t*', ffi.new('const char[16]', data:sub(1, 16)))+    if header[0] ~= M.VERSION then+      return+    end+    M.track('read', start)+    return {+      hash = { size = header[1], mtime = { sec = header[2], nsec = header[3] } },+      chunk = data:sub(16 + 1),+    }+  end+  M.track('read', start)+end++--- The `package.loaders` loader for lua files using the cache.+---@param modname string module name+---@return string|function+---@private+function Cache.loader(modname)+  local start = uv.hrtime()+  local modpath, hash = M.find(modname)+  if modpath then+    local chunk, err = M.load(modpath, { hash = hash })+    M.track('loader', start)+    return chunk or error(err)+  end+  M.track('loader', start)+  return '\ncache_loader: module ' .. modname .. ' not found'+end++--- The `package.loaders` loader for libs+---@param modname string module name+---@return string|function+---@private+function Cache.loader_lib(modname)+  local start = uv.hrtime()+  local modpath = M.find(modname, { patterns = jit.os:find('Windows') and { '.dll' } or { '.so' } })+  ---@type function?, string?+  if modpath then+    -- Making function name in Lua 5.1 (see src/loadlib.c:mkfuncname) is+    -- a) strip prefix up to and including the first dash, if any+    -- b) replace all dots by underscores+    -- c) prepend ""luaopen_""+    -- So ""foo-bar.baz"" should result in ""luaopen_bar_baz""+    local dash = modname:find('-', 1, true)+    local funcname = dash and modname:sub(dash + 1) or modname+    local chunk, err = package.loadlib(modpath, 'luaopen_' .. funcname:gsub('%.', '_'))+    M.track('loader_lib', start)+    return chunk or error(err)+  end+  M.track('loader_lib', start)+  return '\ncache_loader_lib: module ' .. modname .. ' not found'+end++--- `loadfile` using the cache+---@param filename? string+---@param mode? ""b""|""t""|""bt""+---@param env? table+---@return function?, string?  error_message+---@private+-- luacheck: ignore 312+function Cache.loadfile(filename, mode, env)+  local start = uv.hrtime()+  filename = Cache.normalize(filename)+  mode = nil -- ignore mode, since we byte-compile the lua source files+  local chunk, err = M.load(filename, { mode = mode, env = env })+  M.track('loadfile', start)+  return chunk, err+end++--- Checks whether two cache hashes are the same based on:+--- * file size+--- * mtime in seconds+--- * mtime in nanoseconds+---@param h1 CacheHash+---@param h2 CacheHash+---@private+function Cache.eq(h1, h2)+  return h1+    and h2+    and h1.size == h2.size+    and h1.mtime.sec == h2.mtime.sec+    and h1.mtime.nsec == h2.mtime.nsec+end++--- Loads the given module path using the cache+---@param modpath string+---@param opts? {hash?: CacheHash, mode?: ""b""|""t""|""bt"", env?:table} (table|nil) Options for loading the module:+---    - hash: (table) the hash of the file to load if it is already known. (defaults to `vim.loop.fs_stat({modpath})`)+---    - mode: (string) the mode to load the module with. ""b""|""t""|""bt"" (defaults to `nil`)+---    - env: (table) the environment to load the module in. (defaults to `nil`)+---@see |luaL_loadfile()|+---@return function?, string? error_message+function M.load(modpath, opts)+  local start = uv.hrtime()++  opts = opts or {}+  local hash = opts.hash or uv.fs_stat(modpath)+  ---@type function?, string?+  local chunk, err++  if not hash then+    -- trigger correct error+    chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+    M.track('load', start)+    return chunk, err+  end++  local entry = Cache.read(modpath)+  if entry and Cache.eq(entry.hash, hash) then+    -- found in cache and up to date+    -- selene: allow(incorrect_standard_library_use)+    chunk, err = load(entry.chunk --[[@as string]], '@' .. modpath, opts.mode, opts.env)+    if not (err and err:find('cannot load incompatible bytecode', 1, true)) then+      M.track('load', start)+      return chunk, err+    end+  end+  entry = { hash = hash, modpath = modpath }++  chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+  if chunk then+    entry.chunk = string.dump(chunk)+    Cache.write(modpath, entry)+  end+  M.track('load', start)+  return chunk, err+end++--- Finds the module path for the given module name+---@param modname string+---@param opts? CacheFindOpts (table|nil) Options for finding a module:+---    - rtp: (boolean) Search for modname in the runtime path (defaults to `true`)+---    - patterns: (string[]) Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---    - paths: (string[]) Extra paths to search for modname (defaults to `{}`)+---@return string? modpath, CacheHash? hash (string|nil) modpath for the module+function M.find(modname, opts)+  local start = uv.hrtime()+  opts = opts or {}++  modname = modname:gsub('/', '.')+  local basename = modname:gsub('%.', '/')+  local idx = modname:find('.', 1, true)++  -- HACK: fix incorrect require statements. Really not a fan of keeping this,+  -- but apparently the regular lua loader also allows this+  if idx == 1 then+    modname = modname:gsub('^%.+', '')+    basename = modname:gsub('%.', '/')+    idx = modname:find('.', 1, true)+  end++  -- get the top-level module name+  local topmod = idx and modname:sub(1, idx - 1) or modname++  -- OPTIM: search for a directory first when topmod == modname+  local patterns = opts.patterns+    or (topmod == modname and { '/init.lua', '.lua' } or { '.lua', '/init.lua' })+  for p, pattern in ipairs(patterns) do+    patterns[p] = '/lua/' .. basename .. pattern+  end++  -- Checks if the given paths contain the top-level module.+  -- If so, it tries to find the module path for the given module name.+  ---@param paths string[]+  ---@return string? modpath, CacheHash? hash+  ---@private+  local function _find(paths)+    for _, path in ipairs(paths) do+      if M.lsmod(path)[topmod] then+        for _, pattern in ipairs(patterns) do+          local modpath = path .. pattern+          M.stats.find.stat = (M.stats.find.stat or 0) + 1+          local hash = uv.fs_stat(modpath)+          if hash then+            return modpath, hash+          end+        end+      end+    end+  end++  ---@type string?, CacheHash?+  local modpath, hash++  -- always check the rtp first+  if opts.rtp ~= false then+    modpath, hash = _find(Cache._rtp or {})+    if not modpath then+      local rtp, updated = Cache.get_rtp()+      if updated then+        modpath, hash = _find(rtp)+      end+    end+  end++  -- check any additional paths+  if (not modpath) and opts.paths then+    modpath, hash = _find(opts.paths)+  end++  M.track('find', start)+  if modpath then+    return modpath, hash+  end+  -- module not found+  M.stats.find.not_found = M.stats.find.not_found + 1+end++--- Resets the topmods cache for the path+---@param path string path to reset+function M.reset(path)+  Cache._indexed[Cache.normalize(path)] = nil+end++--- Enables the cache:+--- * override loadfile+--- * adds the lua loader+--- * adds the libs loader+--- * remove the Neovim loader+function M.enable()+  if M.enabled then+    return+  end+  M.enabled = true+  vim.fn.mkdir(vim.fn.fnamemodify(M.path, ':p'), 'p')+  -- selene: allow(global_usage)+  _G.loadfile = Cache.loadfile+  -- add lua loader+  table.insert(package.loaders, 2, Cache.loader)+  -- add libs loader+  table.insert(package.loaders, 3, Cache.loader_lib)+  -- remove Neovim loader+  for l, loader in ipairs(package.loaders) do+    if loader == vim._load_package then+      table.remove(package.loaders, l)+      break+    end+  end+  -- TODO: add an autocmd on BufWritePost that checks if its in a /lua folder+  -- if thats the case, then reset the plugin path.+  -- This will make sure we can properly load new top-level lua modules+end++--- Disables the cache:+--- * removes the cache loaders+--- * adds the Neovim loader+function M.disable()+  if not M.enabled then+    return+  end+  M.enabled = false+  -- selene: allow(global_usage)+  _G.loadfile = Cache._loadfile+  ---@diagnostic disable-next-line: no-unknown+  for l, loader in ipairs(package.loaders) do+    if loader == Cache.loader or loader == Cache.loader_lib then+      table.remove(package.loaders, l)+    end+  end+  table.insert(package.loaders, 2, vim._load_package)+end++--- Return the top-level `/lua/*` modules for this path+---@param path string path to check for top-level lua modules+---@return string[]+function M.lsmod(path)","used by lazy, so I don't think it's a good idea to make this private",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1135980255,2023-03-14T17:50:12Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class CacheFindOpts+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---@field paths? string[] Extra paths to search for modname++M.VERSION = 2+M.path = vim.fn.stdpath('cache') .. '/luac'+M.enabled = false+---@type table<string, {total:number, time:number, [string]:number?}?>+M.stats = {+  find = { total = 0, time = 0, not_found = 0 },+}++---@class ModuleCache+---@field _rtp string[]+---@field _rtp_pure string[]+---@field _rtp_key string+local Cache = {+  ---@type table<string, table<string,true>>+  _indexed = {},+  ---@type table<string, string[]>+  _topmods = {},+  _loadfile = loadfile,+}++--- Tracks the time spent in a function+---@private+function M.track(stat, start)+  M.stats[stat] = M.stats[stat] or { total = 0, time = 0 }+  M.stats[stat].total = M.stats[stat].total + 1+  M.stats[stat].time = M.stats[stat].time + uv.hrtime() - start+end++--- slightly faster/different version than vim.fs.normalize+--- we also need to have it here, since the cache will load vim.fs+---@private+function Cache.normalize(path)+  if path:sub(1, 1) == '~' then+    local home = vim.loop.os_homedir() or '~'+    if home:sub(-1) == '\\' or home:sub(-1) == '/' then+      home = home:sub(1, -2)+    end+    path = home .. path:sub(2)+  end+  path = path:gsub('\\', '/'):gsub('/+', '/')+  return path:sub(-1) == '/' and path:sub(1, -2) or path+end++--- Gets the rtp excluding after directories.+--- The result is cached, and will be updated if the runtime path changes.+--- When called from a fast event, the cached value will be returned.+--- @return string[] rtp, boolean updated+---@private+function Cache.get_rtp()+  local start = uv.hrtime()+  if vim.in_fast_event() then+    M.track('get_rtp', start)+    return (Cache._rtp or {}), false+  end+  local updated = false+  local key = vim.go.rtp+  if key ~= Cache._rtp_key then+    Cache._rtp = {}+    for _, path in ipairs(vim.api.nvim_get_runtime_file('', true)) do+      path = Cache.normalize(path)+      -- skip after directories+      if+        path:sub(-6, -1) ~= '/after'+        and not (Cache._indexed[path] and vim.tbl_isempty(Cache._indexed[path]))+      then+        Cache._rtp[#Cache._rtp + 1] = path+      end+    end+    updated = true+    Cache._rtp_key = key+  end+  M.track('get_rtp', start)+  return Cache._rtp, updated+end++--- Returns the cache file name+---@param name string can be a module name, or a file name+---@return string file_name+---@private+function Cache.cache_file(name)+  local ret = M.path .. '/' .. name:gsub('[/\\:]', '%%')+  return ret:sub(-4) == '.lua' and (ret .. 'c') or (ret .. '.luac')+end++--- Saves the cache entry for a given module or file+---@param name string module name or filename+---@param entry CacheEntry+---@private+function Cache.write(name, entry)+  local cname = Cache.cache_file(name)+  local f = assert(uv.fs_open(cname, 'w', 438))+  local header = {+    M.VERSION,+    entry.hash.size,+    entry.hash.mtime.sec,+    entry.hash.mtime.nsec,+  }+  uv.fs_write(f, ffi.string(ffi.new('const uint32_t[4]', header), 16))+  uv.fs_write(f, entry.chunk)+  uv.fs_close(f)+end++--- Loads the cache entry for a given module or file+---@param name string module name or filename+---@return CacheEntry?+---@private+function Cache.read(name)+  local start = uv.hrtime()+  local cname = Cache.cache_file(name)+  local f = uv.fs_open(cname, 'r', 438)+  if f then+    local hash = uv.fs_fstat(f) --[[@as CacheHash]]+    local data = uv.fs_read(f, hash.size, 0) --[[@as string]]+    uv.fs_close(f)++    ---@type integer[]|{[0]:integer}+    local header = ffi.cast('uint32_t*', ffi.new('const char[16]', data:sub(1, 16)))+    if header[0] ~= M.VERSION then+      return+    end+    M.track('read', start)+    return {+      hash = { size = header[1], mtime = { sec = header[2], nsec = header[3] } },+      chunk = data:sub(16 + 1),+    }+  end+  M.track('read', start)+end++--- The `package.loaders` loader for lua files using the cache.+---@param modname string module name+---@return string|function+---@private+function Cache.loader(modname)+  local start = uv.hrtime()+  local modpath, hash = M.find(modname)+  if modpath then+    local chunk, err = M.load(modpath, { hash = hash })+    M.track('loader', start)+    return chunk or error(err)+  end+  M.track('loader', start)+  return '\ncache_loader: module ' .. modname .. ' not found'+end++--- The `package.loaders` loader for libs+---@param modname string module name+---@return string|function+---@private+function Cache.loader_lib(modname)+  local start = uv.hrtime()+  local modpath = M.find(modname, { patterns = jit.os:find('Windows') and { '.dll' } or { '.so' } })+  ---@type function?, string?+  if modpath then+    -- Making function name in Lua 5.1 (see src/loadlib.c:mkfuncname) is+    -- a) strip prefix up to and including the first dash, if any+    -- b) replace all dots by underscores+    -- c) prepend ""luaopen_""+    -- So ""foo-bar.baz"" should result in ""luaopen_bar_baz""+    local dash = modname:find('-', 1, true)+    local funcname = dash and modname:sub(dash + 1) or modname+    local chunk, err = package.loadlib(modpath, 'luaopen_' .. funcname:gsub('%.', '_'))+    M.track('loader_lib', start)+    return chunk or error(err)+  end+  M.track('loader_lib', start)+  return '\ncache_loader_lib: module ' .. modname .. ' not found'+end++--- `loadfile` using the cache+---@param filename? string+---@param mode? ""b""|""t""|""bt""+---@param env? table+---@return function?, string?  error_message+---@private+-- luacheck: ignore 312+function Cache.loadfile(filename, mode, env)+  local start = uv.hrtime()+  filename = Cache.normalize(filename)+  mode = nil -- ignore mode, since we byte-compile the lua source files+  local chunk, err = M.load(filename, { mode = mode, env = env })+  M.track('loadfile', start)+  return chunk, err+end++--- Checks whether two cache hashes are the same based on:+--- * file size+--- * mtime in seconds+--- * mtime in nanoseconds+---@param h1 CacheHash+---@param h2 CacheHash+---@private+function Cache.eq(h1, h2)+  return h1+    and h2+    and h1.size == h2.size+    and h1.mtime.sec == h2.mtime.sec+    and h1.mtime.nsec == h2.mtime.nsec+end++--- Loads the given module path using the cache+---@param modpath string+---@param opts? {hash?: CacheHash, mode?: ""b""|""t""|""bt"", env?:table} (table|nil) Options for loading the module:+---    - hash: (table) the hash of the file to load if it is already known. (defaults to `vim.loop.fs_stat({modpath})`)+---    - mode: (string) the mode to load the module with. ""b""|""t""|""bt"" (defaults to `nil`)+---    - env: (table) the environment to load the module in. (defaults to `nil`)+---@see |luaL_loadfile()|+---@return function?, string? error_message+function M.load(modpath, opts)+  local start = uv.hrtime()++  opts = opts or {}+  local hash = opts.hash or uv.fs_stat(modpath)+  ---@type function?, string?+  local chunk, err++  if not hash then+    -- trigger correct error+    chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+    M.track('load', start)+    return chunk, err+  end++  local entry = Cache.read(modpath)+  if entry and Cache.eq(entry.hash, hash) then+    -- found in cache and up to date+    -- selene: allow(incorrect_standard_library_use)+    chunk, err = load(entry.chunk --[[@as string]], '@' .. modpath, opts.mode, opts.env)+    if not (err and err:find('cannot load incompatible bytecode', 1, true)) then+      M.track('load', start)+      return chunk, err+    end+  end+  entry = { hash = hash, modpath = modpath }++  chunk, err = Cache._loadfile(modpath, opts.mode, opts.env)+  if chunk then+    entry.chunk = string.dump(chunk)+    Cache.write(modpath, entry)+  end+  M.track('load', start)+  return chunk, err+end++--- Finds the module path for the given module name+---@param modname string+---@param opts? CacheFindOpts (table|nil) Options for finding a module:+---    - rtp: (boolean) Search for modname in the runtime path (defaults to `true`)+---    - patterns: (string[]) Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---    - paths: (string[]) Extra paths to search for modname (defaults to `{}`)+---@return string? modpath, CacheHash? hash (string|nil) modpath for the module+function M.find(modname, opts)+  local start = uv.hrtime()+  opts = opts or {}++  modname = modname:gsub('/', '.')+  local basename = modname:gsub('%.', '/')+  local idx = modname:find('.', 1, true)++  -- HACK: fix incorrect require statements. Really not a fan of keeping this,+  -- but apparently the regular lua loader also allows this+  if idx == 1 then+    modname = modname:gsub('^%.+', '')+    basename = modname:gsub('%.', '/')+    idx = modname:find('.', 1, true)+  end++  -- get the top-level module name+  local topmod = idx and modname:sub(1, idx - 1) or modname++  -- OPTIM: search for a directory first when topmod == modname+  local patterns = opts.patterns+    or (topmod == modname and { '/init.lua', '.lua' } or { '.lua', '/init.lua' })+  for p, pattern in ipairs(patterns) do+    patterns[p] = '/lua/' .. basename .. pattern+  end++  -- Checks if the given paths contain the top-level module.+  -- If so, it tries to find the module path for the given module name.+  ---@param paths string[]+  ---@return string? modpath, CacheHash? hash+  ---@private+  local function _find(paths)+    for _, path in ipairs(paths) do+      if M.lsmod(path)[topmod] then+        for _, pattern in ipairs(patterns) do+          local modpath = path .. pattern+          M.stats.find.stat = (M.stats.find.stat or 0) + 1+          local hash = uv.fs_stat(modpath)+          if hash then+            return modpath, hash+          end+        end+      end+    end+  end++  ---@type string?, CacheHash?+  local modpath, hash++  -- always check the rtp first+  if opts.rtp ~= false then+    modpath, hash = _find(Cache._rtp or {})+    if not modpath then+      local rtp, updated = Cache.get_rtp()+      if updated then+        modpath, hash = _find(rtp)+      end+    end+  end++  -- check any additional paths+  if (not modpath) and opts.paths then+    modpath, hash = _find(opts.paths)+  end++  M.track('find', start)+  if modpath then+    return modpath, hash+  end+  -- module not found+  M.stats.find.not_found = M.stats.find.not_found + 1+end++--- Resets the topmods cache for the path+---@param path string path to reset+function M.reset(path)+  Cache._indexed[Cache.normalize(path)] = nil+end++--- Enables the cache:+--- * override loadfile+--- * adds the lua loader+--- * adds the libs loader+--- * remove the Neovim loader+function M.enable()+  if M.enabled then+    return+  end+  M.enabled = true+  vim.fn.mkdir(vim.fn.fnamemodify(M.path, ':p'), 'p')+  -- selene: allow(global_usage)+  _G.loadfile = Cache.loadfile+  -- add lua loader+  table.insert(package.loaders, 2, Cache.loader)+  -- add libs loader+  table.insert(package.loaders, 3, Cache.loader_lib)+  -- remove Neovim loader+  for l, loader in ipairs(package.loaders) do+    if loader == vim._load_package then+      table.remove(package.loaders, l)+      break+    end+  end+  -- TODO: add an autocmd on BufWritePost that checks if its in a /lua folder+  -- if thats the case, then reset the plugin path.+  -- This will make sure we can properly load new top-level lua modules+end++--- Disables the cache:+--- * removes the cache loaders+--- * adds the Neovim loader+function M.disable()+  if not M.enabled then+    return+  end+  M.enabled = false+  -- selene: allow(global_usage)+  _G.loadfile = Cache._loadfile+  ---@diagnostic disable-next-line: no-unknown+  for l, loader in ipairs(package.loaders) do+    if loader == Cache.loader or loader == Cache.loader_lib then+      table.remove(package.loaders, l)+    end+  end+  table.insert(package.loaders, 2, vim._load_package)+end++--- Return the top-level `/lua/*` modules for this path+---@param path string path to check for top-level lua modules+---@return string[]+function M.lsmod(path)+  if not Cache._indexed[path] then+    local start = uv.hrtime()+    Cache._indexed[path] = {}+    local handle = vim.loop.fs_scandir(path .. '/lua')+    while handle do+      local name, t = vim.loop.fs_scandir_next(handle)+      if not name then+        break+      end+      -- HACK: type is not always returned due to a bug in luv+      t = t or uv.fs_stat(path .. '/lua/' .. name).type+      ---@type string+      local topname+      local ext = name:sub(-4)+      if ext == '.lua' or ext == '.dll' then+        topname = name:sub(1, -5)+      elseif name:sub(-3) == '.so' then+        topname = name:sub(1, -4)+      elseif t == 'link' or t == 'directory' then+        topname = name+      end+      if topname then+        Cache._indexed[path][topname] = true+        Cache._topmods[topname] = Cache._topmods[topname] or {}+        if not vim.tbl_contains(Cache._topmods[topname], path) then+          table.insert(Cache._topmods[topname], path)+        end+      end+    end+    M.track('lsmod', start)+  end+  return Cache._indexed[path]+end++--- Debug function that wrapps all loaders and tracks stats+function M.profile_loaders()","used by lazy, so I don't think it's a good idea to make this private",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1135980696,2023-03-14T17:50:35Z,runtime/lua/vim/cache.lua,"@@ -0,0 +1,481 @@+-- interop with the native Neovim cache+if type(package.loaded['vim.cache']) == 'table' then+  return package.loaded['vim.cache']+end++local ffi = require('ffi')+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class CacheFindOpts+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---@field paths? string[] Extra paths to search for modname++M.VERSION = 2+M.path = vim.fn.stdpath('cache') .. '/luac'+M.enabled = false+---@type table<string, {total:number, time:number, [string]:number?}?>+M.stats = {+  find = { total = 0, time = 0, not_found = 0 },+}++---@class ModuleCache+---@field _rtp string[]+---@field _rtp_pure string[]+---@field _rtp_key string+local Cache = {+  ---@type table<string, table<string,true>>+  _indexed = {},+  ---@type table<string, string[]>+  _topmods = {},+  _loadfile = loadfile,+}++--- Tracks the time spent in a function+---@private+function M.track(stat, start)+  M.stats[stat] = M.stats[stat] or { total = 0, time = 0 }+  M.stats[stat].total = M.stats[stat].total + 1+  M.stats[stat].time = M.stats[stat].time + uv.hrtime() - start+end++--- slightly faster/different version than vim.fs.normalize+--- we also need to have it here, since the cache will load vim.fs+---@private+function Cache.normalize(path)+  if path:sub(1, 1) == '~' then+    local home = vim.loop.os_homedir() or '~'+    if home:sub(-1) == '\\' or home:sub(-1) == '/' then+      home = home:sub(1, -2)+    end+    path = home .. path:sub(2)+  end+  path = path:gsub('\\', '/'):gsub('/+', '/')+  return path:sub(-1) == '/' and path:sub(1, -2) or path+end++--- Gets the rtp excluding after directories.+--- The result is cached, and will be updated if the runtime path changes.+--- When called from a fast event, the cached value will be returned.+--- @return string[] rtp, boolean updated+---@private+function Cache.get_rtp()+  local start = uv.hrtime()+  if vim.in_fast_event() then+    M.track('get_rtp', start)+    return (Cache._rtp or {}), false+  end+  local updated = false+  local key = vim.go.rtp+  if key ~= Cache._rtp_key then+    Cache._rtp = {}+    for _, path in ipairs(vim.api.nvim_get_runtime_file('', true)) do+      path = Cache.normalize(path)+      -- skip after directories+      if+        path:sub(-6, -1) ~= '/after'+        and not (Cache._indexed[path] and vim.tbl_isempty(Cache._indexed[path]))+      then+        Cache._rtp[#Cache._rtp + 1] = path+      end+    end+    updated = true+    Cache._rtp_key = key+  end+  M.track('get_rtp', start)+  return Cache._rtp, updated+end++--- Returns the cache file name+---@param name string can be a module name, or a file name+---@return string file_name+---@private+function Cache.cache_file(name)+  local ret = M.path .. '/' .. name:gsub('[/\\:]', '%%')+  return ret:sub(-4) == '.lua' and (ret .. 'c') or (ret .. '.luac')+end++--- Saves the cache entry for a given module or file+---@param name string module name or filename+---@param entry CacheEntry+---@private+function Cache.write(name, entry)+  local cname = Cache.cache_file(name)+  local f = assert(uv.fs_open(cname, 'w', 438))+  local header = {+    M.VERSION,+    entry.hash.size,+    entry.hash.mtime.sec,+    entry.hash.mtime.nsec,+  }+  uv.fs_write(f, ffi.string(ffi.new('const uint32_t[4]', header), 16))+  uv.fs_write(f, entry.chunk)+  uv.fs_close(f)+end++--- Loads the cache entry for a given module or file+---@param name string module name or filename+---@return CacheEntry?+---@private+function Cache.read(name)+  local start = uv.hrtime()+  local cname = Cache.cache_file(name)+  local f = uv.fs_open(cname, 'r', 438)+  if f then+    local hash = uv.fs_fstat(f) --[[@as CacheHash]]+    local data = uv.fs_read(f, hash.size, 0) --[[@as string]]+    uv.fs_close(f)++    ---@type integer[]|{[0]:integer}+    local header = ffi.cast('uint32_t*', ffi.new('const char[16]', data:sub(1, 16)))+    if header[0] ~= M.VERSION then+      return+    end+    M.track('read', start)+    return {+      hash = { size = header[1], mtime = { sec = header[2], nsec = header[3] } },+      chunk = data:sub(16 + 1),+    }+  end+  M.track('read', start)+end++--- The `package.loaders` loader for lua files using the cache.+---@param modname string module name+---@return string|function+---@private+function Cache.loader(modname)+  local start = uv.hrtime()+  local modpath, hash = M.find(modname)+  if modpath then+    local chunk, err = M.load(modpath, { hash = hash })+    M.track('loader', start)+    return chunk or error(err)+  end+  M.track('loader', start)+  return '\ncache_loader: module ' .. modname .. ' not found'+end++--- The `package.loaders` loader for libs+---@param modname string module name+---@return string|function+---@private+function Cache.loader_lib(modname)+  local start = uv.hrtime()+  local modpath = M.find(modname, { patterns = jit.os:find('Windows') and { '.dll' } or { '.so' } })+  ---@type function?, string?+  if modpath then+    -- Making function name in Lua 5.1 (see src/loadlib.c:mkfuncname) is+    -- a) strip prefix up to and including the first dash, if any+    -- b) replace all dots by underscores+    -- c) prepend ""luaopen_""+    -- So ""foo-bar.baz"" should result in ""luaopen_bar_baz""+    local dash = modname:find('-', 1, true)+    local funcname = dash and modname:sub(dash + 1) or modname+    local chunk, err = package.loadlib(modpath, 'luaopen_' .. funcname:gsub('%.', '_'))+    M.track('loader_lib', start)+    return chunk or error(err)+  end+  M.track('loader_lib', start)+  return '\ncache_loader_lib: module ' .. modname .. ' not found'+end++--- `loadfile` using the cache+---@param filename? string+---@param mode? ""b""|""t""|""bt""+---@param env? table+---@return function?, string?  error_message+---@private+-- luacheck: ignore 312+function Cache.loadfile(filename, mode, env)+  local start = uv.hrtime()+  filename = Cache.normalize(filename)+  mode = nil -- ignore mode, since we byte-compile the lua source files+  local chunk, err = M.load(filename, { mode = mode, env = env })+  M.track('loadfile', start)+  return chunk, err+end++--- Checks whether two cache hashes are the same based on:+--- * file size+--- * mtime in seconds+--- * mtime in nanoseconds+---@param h1 CacheHash+---@param h2 CacheHash+---@private+function Cache.eq(h1, h2)+  return h1+    and h2+    and h1.size == h2.size+    and h1.mtime.sec == h2.mtime.sec+    and h1.mtime.nsec == h2.mtime.nsec+end++--- Loads the given module path using the cache+---@param modpath string+---@param opts? {hash?: CacheHash, mode?: ""b""|""t""|""bt"", env?:table} (table|nil) Options for loading the module:+---    - hash: (table) the hash of the file to load if it is already known. (defaults to `vim.loop.fs_stat({modpath})`)+---    - mode: (string) the mode to load the module with. ""b""|""t""|""bt"" (defaults to `nil`)+---    - env: (table) the environment to load the module in. (defaults to `nil`)+---@see |luaL_loadfile()|+---@return function?, string? error_message+function M.load(modpath, opts)","used by lazy, so I don't think it's a good idea to make this private",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22634,1137120895,2023-03-15T13:57:57Z,runtime/doc/lua.txt,"@@ -2203,6 +2203,27 @@ add({filetypes})                                          *vim.filetype.add()*       ��� {filetypes}  (table) A table containing new filetype maps (see                      example). +get_option({filetype}, {option})                   *vim.filetype.get_option()*","Related vim todo for reference: https://github.com/vim/vim/blob/e764d1b4219e6615a04df1c3a6a5c0210a0a7dac/runtime/doc/todo.txt#L1036-L1038```Add options_default() / options_restore() to set several options to Vimdefaults for a plugin. Comments from Zyx, 2017 May 10.Perhaps use a vimcontext / endvimcontext command block.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/22668,1137158921,2023-03-15T14:19:31Z,runtime/lua/vim/loader.lua,"@@ -0,0 +1,525 @@+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class ModuleFindOpts+---@field all? boolean Search for all matches (defaults to `false`)+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)","Typo here. Also does ""patterns"" here mean ""Lua patterns""? Given that Vim has its own ""pattern"" concept, it might be good to be explicit.```suggestion---@field patterns? string[] Lua patterns to use (defaults to `{""/init.lua"", "".lua""}`)```",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1137165243,2023-03-15T14:22:58Z,runtime/lua/vim/loader.lua,"@@ -0,0 +1,525 @@+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class ModuleFindOpts+---@field all? boolean Search for all matches (defaults to `false`)+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)",Not lua patterns and also not vim patterns.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/22668,1137171893,2023-03-15T14:26:42Z,runtime/lua/vim/loader.lua,"@@ -0,0 +1,525 @@+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class ModuleFindOpts+---@field all? boolean Search for all matches (defaults to `false`)+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)","So glob patterns then? Or just plain strings? The term ""patterns"" is ambiguous in Vim precisely because of how many different pattern ""schemes"" are in use.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22668,1137183765,2023-03-15T14:33:07Z,runtime/lua/vim/loader.lua,"@@ -0,0 +1,525 @@+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class ModuleFindOpts+---@field all? boolean Search for all matches (defaults to `false`)+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)","In the Lua context, though, it's usually (and should always be) used for ""Lua patterns"" (aka ""we already have regex at home"").",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1137187346,2023-03-15T14:35:02Z,runtime/lua/vim/loader.lua,"@@ -0,0 +1,525 @@+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class ModuleFindOpts+---@field all? boolean Search for all matches (defaults to `false`)+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)",Those aren't lua patterns. They're just strings that are added to the basename of the lua module.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/22668,1137196580,2023-03-15T14:39:57Z,runtime/lua/vim/loader.lua,"@@ -0,0 +1,525 @@+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class ModuleFindOpts+---@field all? boolean Search for all matches (defaults to `false`)+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)","The name itself is fine to me, as long as the docstring is explicit about the semantics.>They're just strings that are added to the basename of the lua module.This is useful information to include in the docstring. As a user of this API this is exactly what I would want to know.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22634,1137820648,2023-03-15T22:03:34Z,runtime/lua/vim/filetype/options.lua,"@@ -0,0 +1,122 @@+local api = vim.api++local M = {}++local function noautocmd(f)+  local ei = vim.o.eventignore+  vim.o.eventignore = 'all'+  f()+  vim.o.eventignore = ei+end++local function get_ftplugin_runtime(filetype)+  return api.nvim__get_runtime({+    string.format('ftplugin/%s.vim', filetype),+    string.format('ftplugin/%s_*.vim', filetype),+    string.format('ftplugin/%s/*.vim', filetype),+    string.format('ftplugin/%s.lua', filetype),+    string.format('ftplugin/%s_*.lua', filetype),+    string.format('ftplugin/%s/*.lua', filetype),+  }, true, {}) --[[@as string[] ]]+end++-- Keep track of ftplugin files+local ftplugin_cache = {} ---@type table<string,table<string,integer>>++-- Keep track of total number of FileType autocmds+local ft_autocmd_num ---@type integer?++-- Keep track of filetype options+local ft_option_cache = {} ---@type table<string,table<string,any>>++--- @param path string+--- @return integer+local function hash(path)+  local mtime0 = vim.loop.fs_stat(path).mtime+  return mtime0.sec * 1000000000 + mtime0.nsec+end++--- Only update the cache on changes to the number of FileType autocmds+--- and changes to any ftplugin/ file. This isn't guaranteed to catch everything+--- but should be good enough.+--- @param filetype string+local function update_ft_option_cache(filetype)+  local new_ftautos = #api.nvim_get_autocmds({ event = 'FileType' })+  if new_ftautos ~= ft_autocmd_num then+    -- invalidate+    ft_option_cache[filetype] = nil+    ft_autocmd_num = new_ftautos+  end++  local files = get_ftplugin_runtime(filetype)++  ftplugin_cache[filetype] = ftplugin_cache[filetype] or {}++  if #files ~= #vim.tbl_keys(ftplugin_cache[filetype]) then+    -- invalidate+    ft_option_cache[filetype] = nil+    ftplugin_cache[filetype] = {}+  end++  for _, f in ipairs(files) do+    -- VIMRUNTIME should be static so shouldn't need to worry about it changing+    if not vim.startswith(f, vim.env.VIMRUNTIME) then+      local mtime = hash(f)+      if ftplugin_cache[filetype][f] ~= mtime then+        -- invalidate+        ft_option_cache[filetype] = nil+        ftplugin_cache[filetype][f] = mtime+      end+    end+  end+end++--- @private+--- @param filetype string Filetype+--- @param option string Option name+--- @return string|integer|boolean+local function get_option(filetype, option)+  -- Some filetypes might not set 'commentstring' so we may end up+  -- returning 'commentstring' for another filetype if the buffer is re-used.+  local buf = api.nvim_create_buf(false, true)++  -- Prevent syntax/ from being loaded+  vim.b[buf].ts_highlight = true++  -- Change the filetype without triggering any autocmds+  noautocmd(function()+    vim.bo[buf].filetype = filetype+  end)++  -- Trigger the FileType autocmd in ftplugin.vim+  api.nvim_buf_call(buf, function()+    -- TODO(lewis6991): should we just execute filetypeplugin or all of FileType?+    -- Cache is only coherent for ftplugin but users might want to configure filetypes in their+    -- config.via basic FileType autocmds.+    -- api.nvim_exec_autocmds('FileType', { group = 'filetypeplugin', buffer = buf })+    api.nvim_exec_autocmds('FileType', { buffer = buf })+  end)++  local ret = vim.bo[buf][option] ---@type string|integer|boolean++  api.nvim_buf_delete(buf, {})","> Wrapping it in vim.schedule did the trick for me. Both of the exec_autocmds seem to work thenThe problem is, we can't predict what will be in a `FileType` autocmd. For example, I had `vim.cmd.normal'gx'` which triggered a similar warning. So we will need to document this shouldn't be used in expr keymaps (though it might work).",
5160701,seblj,https://api.github.com/repos/neovim/neovim/pulls/22634,1137824942,2023-03-15T22:09:34Z,runtime/lua/vim/filetype/options.lua,"@@ -0,0 +1,122 @@+local api = vim.api++local M = {}++local function noautocmd(f)+  local ei = vim.o.eventignore+  vim.o.eventignore = 'all'+  f()+  vim.o.eventignore = ei+end++local function get_ftplugin_runtime(filetype)+  return api.nvim__get_runtime({+    string.format('ftplugin/%s.vim', filetype),+    string.format('ftplugin/%s_*.vim', filetype),+    string.format('ftplugin/%s/*.vim', filetype),+    string.format('ftplugin/%s.lua', filetype),+    string.format('ftplugin/%s_*.lua', filetype),+    string.format('ftplugin/%s/*.lua', filetype),+  }, true, {}) --[[@as string[] ]]+end++-- Keep track of ftplugin files+local ftplugin_cache = {} ---@type table<string,table<string,integer>>++-- Keep track of total number of FileType autocmds+local ft_autocmd_num ---@type integer?++-- Keep track of filetype options+local ft_option_cache = {} ---@type table<string,table<string,any>>++--- @param path string+--- @return integer+local function hash(path)+  local mtime0 = vim.loop.fs_stat(path).mtime+  return mtime0.sec * 1000000000 + mtime0.nsec+end++--- Only update the cache on changes to the number of FileType autocmds+--- and changes to any ftplugin/ file. This isn't guaranteed to catch everything+--- but should be good enough.+--- @param filetype string+local function update_ft_option_cache(filetype)+  local new_ftautos = #api.nvim_get_autocmds({ event = 'FileType' })+  if new_ftautos ~= ft_autocmd_num then+    -- invalidate+    ft_option_cache[filetype] = nil+    ft_autocmd_num = new_ftautos+  end++  local files = get_ftplugin_runtime(filetype)++  ftplugin_cache[filetype] = ftplugin_cache[filetype] or {}++  if #files ~= #vim.tbl_keys(ftplugin_cache[filetype]) then+    -- invalidate+    ft_option_cache[filetype] = nil+    ftplugin_cache[filetype] = {}+  end++  for _, f in ipairs(files) do+    -- VIMRUNTIME should be static so shouldn't need to worry about it changing+    if not vim.startswith(f, vim.env.VIMRUNTIME) then+      local mtime = hash(f)+      if ftplugin_cache[filetype][f] ~= mtime then+        -- invalidate+        ft_option_cache[filetype] = nil+        ftplugin_cache[filetype][f] = mtime+      end+    end+  end+end++--- @private+--- @param filetype string Filetype+--- @param option string Option name+--- @return string|integer|boolean+local function get_option(filetype, option)+  -- Some filetypes might not set 'commentstring' so we may end up+  -- returning 'commentstring' for another filetype if the buffer is re-used.+  local buf = api.nvim_create_buf(false, true)++  -- Prevent syntax/ from being loaded+  vim.b[buf].ts_highlight = true++  -- Change the filetype without triggering any autocmds+  noautocmd(function()+    vim.bo[buf].filetype = filetype+  end)++  -- Trigger the FileType autocmd in ftplugin.vim+  api.nvim_buf_call(buf, function()+    -- TODO(lewis6991): should we just execute filetypeplugin or all of FileType?+    -- Cache is only coherent for ftplugin but users might want to configure filetypes in their+    -- config.via basic FileType autocmds.+    -- api.nvim_exec_autocmds('FileType', { group = 'filetypeplugin', buffer = buf })+    api.nvim_exec_autocmds('FileType', { buffer = buf })+  end)++  local ret = vim.bo[buf][option] ---@type string|integer|boolean++  api.nvim_buf_delete(buf, {})","> > Wrapping it in vim.schedule did the trick for me. Both of the exec_autocmds seem to work then> > The problem is, we can't predict what will be in a `FileType` autocmd. For example, I had `vim.cmd.normal'gx'` which triggered a similar warning.> > So we will need to document this shouldn't be used in expr keymaps (though it might work).Ah okay, will switch to the replace_termcodes variant���� thanks!",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22634,1137829471,2023-03-15T22:16:32Z,runtime/lua/vim/filetype/options.lua,"@@ -0,0 +1,122 @@+local api = vim.api++local M = {}++local function noautocmd(f)+  local ei = vim.o.eventignore+  vim.o.eventignore = 'all'+  f()+  vim.o.eventignore = ei+end++local function get_ftplugin_runtime(filetype)+  return api.nvim__get_runtime({+    string.format('ftplugin/%s.vim', filetype),+    string.format('ftplugin/%s_*.vim', filetype),+    string.format('ftplugin/%s/*.vim', filetype),+    string.format('ftplugin/%s.lua', filetype),+    string.format('ftplugin/%s_*.lua', filetype),+    string.format('ftplugin/%s/*.lua', filetype),+  }, true, {}) --[[@as string[] ]]+end++-- Keep track of ftplugin files+local ftplugin_cache = {} ---@type table<string,table<string,integer>>++-- Keep track of total number of FileType autocmds+local ft_autocmd_num ---@type integer?++-- Keep track of filetype options+local ft_option_cache = {} ---@type table<string,table<string,any>>++--- @param path string+--- @return integer+local function hash(path)+  local mtime0 = vim.loop.fs_stat(path).mtime+  return mtime0.sec * 1000000000 + mtime0.nsec+end++--- Only update the cache on changes to the number of FileType autocmds+--- and changes to any ftplugin/ file. This isn't guaranteed to catch everything+--- but should be good enough.+--- @param filetype string+local function update_ft_option_cache(filetype)+  local new_ftautos = #api.nvim_get_autocmds({ event = 'FileType' })+  if new_ftautos ~= ft_autocmd_num then+    -- invalidate+    ft_option_cache[filetype] = nil+    ft_autocmd_num = new_ftautos+  end++  local files = get_ftplugin_runtime(filetype)++  ftplugin_cache[filetype] = ftplugin_cache[filetype] or {}++  if #files ~= #vim.tbl_keys(ftplugin_cache[filetype]) then+    -- invalidate+    ft_option_cache[filetype] = nil+    ftplugin_cache[filetype] = {}+  end++  for _, f in ipairs(files) do+    -- VIMRUNTIME should be static so shouldn't need to worry about it changing+    if not vim.startswith(f, vim.env.VIMRUNTIME) then+      local mtime = hash(f)+      if ftplugin_cache[filetype][f] ~= mtime then+        -- invalidate+        ft_option_cache[filetype] = nil+        ftplugin_cache[filetype][f] = mtime+      end+    end+  end+end++--- @private+--- @param filetype string Filetype+--- @param option string Option name+--- @return string|integer|boolean+local function get_option(filetype, option)+  -- Some filetypes might not set 'commentstring' so we may end up+  -- returning 'commentstring' for another filetype if the buffer is re-used.+  local buf = api.nvim_create_buf(false, true)++  -- Prevent syntax/ from being loaded+  vim.b[buf].ts_highlight = true++  -- Change the filetype without triggering any autocmds+  noautocmd(function()+    vim.bo[buf].filetype = filetype+  end)++  -- Trigger the FileType autocmd in ftplugin.vim+  api.nvim_buf_call(buf, function()+    -- TODO(lewis6991): should we just execute filetypeplugin or all of FileType?+    -- Cache is only coherent for ftplugin but users might want to configure filetypes in their+    -- config.via basic FileType autocmds.+    -- api.nvim_exec_autocmds('FileType', { group = 'filetypeplugin', buffer = buf })+    api.nvim_exec_autocmds('FileType', { buffer = buf })+  end)++  local ret = vim.bo[buf][option] ---@type string|integer|boolean++  api.nvim_buf_delete(buf, {})","@justinmk (and @bfredl) do you think it would be reasonable to override `textlock` and `ex_normal_lock` within `get_option()` because ""we know what we're doing"" (���) .`eval_map_expr()` has this:```c  // Forbid changing text or using "":normal"" to avoid most of the bad side  // effects.  Also restore the cursor position.  textlock++;  ex_normal_lock++;```Which makes sense in the general case, but here would it be ok it bypass this? Especially since the mapping isn't really running in the scratch buffer. Maybe we can allow dummy buffers to bypass these checks (#22681)?Otherwise, we can just document the restriction.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/19032,1138947021,2023-03-16T16:04:18Z,src/nvim/api/vimscript.c,"@@ -45,13 +45,33 @@ /// @see |nvim_cmd()| /// /// @param src      Vimscript code-/// @param output   Capture and return all (non-error, non-shell |:!|) output+/// @param opts  Optional parameters.+///           - output: (boolean, default false) Whether to capture and return+///                     all (non-error, non-shell |:!|) output. /// @param[out] err Error details (Vim error), if any-/// @return Output (non-error, non-shell |:!|) if `output` is true,-///         else empty string.-String nvim_exec(uint64_t channel_id, String src, Boolean output, Error *err)-  FUNC_API_SINCE(7)+/// @return Dictionary containing information about execution, with these keys:+///       - output: (string) Output if `opts.output` is true, empty string+///                 otherwise.+Dictionary nvim_exec2(uint64_t channel_id, String src, Dict(exec_opts) *opts, Error *err)+  FUNC_API_SINCE(11) {+  Dictionary result = ARRAY_DICT_INIT;+  PUT(result, ""output"", STRING_OBJ(exec_impl(channel_id, src, opts, err)));","Try this, I think this is why you're getting the memory leak. I believe you shouldn't return any allocated data when you're setting an error? And the allocation comes from `PUT`, which copies the `""output""` string.```suggestion  String output = exec_impl(channel_id, src, opts, err);  if (ERROR_SET(err)) {    return result;  }  PUT(result, ""output"", STRING_OBJ(output));```",
24854248,echasnovski,https://api.github.com/repos/neovim/neovim/pulls/19032,1139004720,2023-03-16T16:24:57Z,src/nvim/api/vimscript.c,"@@ -45,13 +45,33 @@ /// @see |nvim_cmd()| /// /// @param src      Vimscript code-/// @param output   Capture and return all (non-error, non-shell |:!|) output+/// @param opts  Optional parameters.+///           - output: (boolean, default false) Whether to capture and return+///                     all (non-error, non-shell |:!|) output. /// @param[out] err Error details (Vim error), if any-/// @return Output (non-error, non-shell |:!|) if `output` is true,-///         else empty string.-String nvim_exec(uint64_t channel_id, String src, Boolean output, Error *err)-  FUNC_API_SINCE(7)+/// @return Dictionary containing information about execution, with these keys:+///       - output: (string) Output if `opts.output` is true, empty string+///                 otherwise.+Dictionary nvim_exec2(uint64_t channel_id, String src, Dict(exec_opts) *opts, Error *err)+  FUNC_API_SINCE(11) {+  Dictionary result = ARRAY_DICT_INIT;+  PUT(result, ""output"", STRING_OBJ(exec_impl(channel_id, src, opts, err)));","Thanks! I feel yet to often like a blind kitten here.Force-pushed this. All tests pass similarly locally: one `FAILED   test/functional/core/log_spec.lua @ 30: log messages are formatted with name or test id`.@zeertzjq, could you, please, make the memory leak check again? Or how do I do it locally without bothering you? ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22701,1140094849,2023-03-17T11:06:19Z,runtime/doc/api.txt,"@@ -656,8 +656,9 @@ nvim_call_atomic({calls})                                 *nvim_call_atomic()* nvim_chan_send({chan}, {data})                              *nvim_chan_send()*     Send data to channel `id`. For a job, it writes it to the stdin of the     process. For the stdio channel |channel-stdio|, it writes to Nvim's-    stdout. For an internal terminal instance (|nvim_open_term()|) it writes-    directly to terminal output. See |channel-bytes| for more information.+    stdout. In the case of an internal terminal instance (|nvim_open_term()|)","""For => In the case"" is a random stylistic change that increases verbosity. Don't want to encourage this.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22701,1140097329,2023-03-17T11:08:29Z,runtime/doc/api.txt,"@@ -1863,7 +1864,7 @@ nvim_parse_cmd({str}, {opts})                               *nvim_parse_cmd()*           ��� filter: (dictionary) |:filter|.             ��� pattern: (string) Filter pattern. Empty string if there is no               filter.-            ��� force: (boolean) Whether filter is inverted or not.+            ��� force: (boolean) Whether the filter is inverted or not.","This is a good change. The `:help dev-doc` guidance against articles is only for the first part of e.g. parameter descriptions and return-value descriptions where ""A ..."" and ""The ..."" tend to add limitless noise to the descriptions.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22701,1140102300,2023-03-17T11:13:49Z,runtime/doc/api.txt,"@@ -1884,7 +1885,7 @@ nvim_parse_cmd({str}, {opts})                               *nvim_parse_cmd()*           ��� verbose: (integer) |:verbose|. -1 when omitted.           ��� vertical: (boolean) |:vertical|.           ��� split: (string) Split modifier string, is an empty string when-            there's no split modifier. If there is a split modifier it can be+            there's no split modifier. If there is a split modifier, it can be","It's certainly not in ""API reference mode"". You should distinguish the parts that are (concise) prose, e.g., in top-level module descriptions and examples, and those that are simply lists for reference. The latter needs to be as terse as possible for layout reasons (good layout is also important for good documentation!), while the former have more room for grammatical changes _if_ they make the text less ambiguous.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22701,1140102917,2023-03-17T11:14:33Z,runtime/doc/api.txt,"@@ -1884,7 +1885,7 @@ nvim_parse_cmd({str}, {opts})                               *nvim_parse_cmd()*           ��� verbose: (integer) |:verbose|. -1 when omitted.           ��� vertical: (boolean) |:vertical|.           ��� split: (string) Split modifier string, is an empty string when-            there's no split modifier. If there is a split modifier it can be+            there's no split modifier. If there is a split modifier, it can be","Both ways are correct, but the docs are currently written in ""comma free"" style and it's a stylistic choice.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22690,1140193784,2023-03-17T12:47:36Z,src/nvim/buffer.c,"@@ -4127,6 +4128,7 @@ void buf_signcols_del_check(buf_T *buf, linenr_T line1, linenr_T line2) void buf_signcols_add_check(buf_T *buf, sign_entry_T *added) {   if (!buf->b_signcols.valid) {+    invalidate_statuscol(NULL, buf);","So the reason that this works now is that when `'signcolumn' == ""no""`(which you would set the option to when implementing a sign column through `'statuscolumn'`), we early return here:https://github.com/neovim/neovim/blob/86c164d2a14382adfb388a66699828df6c623102/src/nvim/option.c#L5518-L5523Which in turn means that `buf_signcols()` never gets called and thus `b->signcols.valid` is never validated, meaning that `buf_signcols_add/del_check()` always return early and thus always invalidate the statuscolumn in this PR.I guess we could add a `*wp->w_p_stc != NUL` check to make sure that `win_signcol_configured()` doesn't return early so that `b->signcols.valid` is validated.Then I think we should indeed invalidate whenever `v->signcols.valid` is set to `false`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22707,1140198774,2023-03-17T12:52:56Z,test/functional/lua/version_spec.lua,"@@ -1,186 +1,150 @@ local helpers = require('test.functional.helpers')(after_each) local clear = helpers.clear local eq = helpers.eq+local ok = helpers.ok local exec_lua = helpers.exec_lua local matches = helpers.matches local pcall_err = helpers.pcall_err -local version = require('vim.version')--local function quote_empty(s)-  return tostring(s) == '' and '""""' or tostring(s)+local function v(ver)+  return vim.version.version(ver) end  describe('version', function()+   it('package', function()     clear()     eq({ major = 42, minor = 3, patch = 99 }, exec_lua(""return vim.version.parse('v42.3.99')""))   end) +  describe('lazy semver version', function()+    local tests = {+      ['v1.2.3'] = { major = 1, minor = 2, patch = 3 },+      ['v1.2'] = { major = 1, minor = 2, patch = 0 },+      ['v1.2.3-prerelease'] = { major = 1, minor = 2, patch = 3, prerelease = 'prerelease' },+      ['v1.2-prerelease'] = { major = 1, minor = 2, patch = 0, prerelease = 'prerelease' },+      ['v1.2.3-prerelease+build'] = { major = 1, minor = 2, patch = 3, prerelease = 'prerelease', build = ""build"" },+      ['1.2.3+build'] = { major = 1, minor = 2, patch = 3, build = 'build' },+    }+    for input, output in pairs(tests) do+      it('parses ' .. input, function()+        eq(output, v(input))+      end)+    end+  end)++  describe('lazy semver range', function()+    local tests = {+      ['1.2.3'] = { from = { 1, 2, 3 }, to = { 1, 2, 4 } },+      ['1.2'] = { from = { 1, 2, 0 }, to = { 1, 3, 0 } },+      ['=1.2.3'] = { from = { 1, 2, 3 }, to = { 1, 2, 4 } },+      ['>1.2.3'] = { from = { 1, 2, 4 } },+      ['>=1.2.3'] = { from = { 1, 2, 3 } },+      ['~1.2.3'] = { from = { 1, 2, 3 }, to = { 1, 3, 0 } },+      ['^1.2.3'] = { from = { 1, 2, 3 }, to = { 2, 0, 0 } },+      ['^0.2.3'] = { from = { 0, 2, 3 }, to = { 0, 3, 0 } },+      ['^0.0.1'] = { from = { 0, 0, 1 }, to = { 0, 0, 2 } },+      ['^1.2'] = { from = { 1, 2, 0 }, to = { 2, 0, 0 } },+      ['~1.2'] = { from = { 1, 2, 0 }, to = { 1, 3, 0 } },+      ['~1'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['^1'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['1.*'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['1'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['1.x'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['1.2.x'] = { from = { 1, 2, 0 }, to = { 1, 3, 0 } },+      ['1.2.*'] = { from = { 1, 2, 0 }, to = { 1, 3, 0 } },+      ['*'] = { from = { 0, 0, 0 } },+      ['1.2 - 2.3.0'] = { from = { 1, 2, 0 }, to = { 2, 3, 0 } },+      ['1.2.3 - 2.3.4'] = { from = { 1, 2, 3 }, to = { 2, 3, 4 } },+      ['1.2.3 - 2'] = { from = { 1, 2, 3 }, to = { 3, 0, 0 } },+    }+    for input, output in pairs(tests) do+      output.from = v(output.from)+      output.to = output.to and v(output.to)++      local range = vim.version.range(input)+      it('parses ' .. input, function()+        eq(output, range)+      end)++      it('[from] in range ' .. input, function()+        assert(range:matches(output.from))+      end)++      it('[from-1] not in range ' .. input, function()+        local lower = vim.deepcopy(range.from)+        lower.major = lower.major - 1+        assert(not range:matches(lower))+      end)++      it('[to] not in range ' .. input .. ' to:' .. tostring(range and range.to), function()+        if range.to then+          assert(not (range.to < range.to))+          assert(not range:matches(range.to))+        end+      end)+    end++    it(""handles prerelease"", function()+      assert(not vim.version.range('1.2.3'):matches('1.2.3-alpha'))+      assert(vim.version.range('1.2.3-alpha'):matches('1.2.3-alpha'))+      assert(not vim.version.range('1.2.3-alpha'):matches('1.2.3-beta'))+    end)+  end)++  describe('lazy semver order', function()+    it('is correct', function()+      assert(v('v1.2.3') == v('1.2.3'))+      assert(not (v('v1.2.3') < v('1.2.3')))+      assert(v('v1.2.3') > v('1.2.3-prerelease'))+      assert(v('v1.2.3-alpha') < v('1.2.3-beta'))+      assert(v('v1.2.3-prerelease') < v('1.2.3'))+      assert(v('v1.2.3') >= v('1.2.3'))+      assert(v('v1.2.3') >= v('1.0.3'))+      assert(v('v1.2.3') >= v('1.2.2'))+      assert(v('v1.2.3') > v('1.2.2'))+      assert(v('v1.2.3') > v('1.0.3'))+      eq(vim.version.last({ v('1.2.3'), v('2.0.0') }), v('2.0.0'))+      eq(vim.version.last({ v('2.0.0'), v('1.2.3') }), v('2.0.0'))+    end)+  end)+   describe('cmp()', function()     local testcases = {-      {-        desc = '(v1 < v2)',-        v1 = 'v0.0.99',-        v2 = 'v9.0.0',-        want = -1,-      },-      {-        desc = '(v1 < v2)',-        v1 = 'v0.4.0',-        v2 = 'v0.9.99',-        want = -1,-      },-      {-        desc = '(v1 < v2)',-        v1 = 'v0.2.8',-        v2 = 'v1.0.9',-        want = -1,-      },-      {-        desc = '(v1 == v2)',-        v1 = 'v0.0.0',-        v2 = 'v0.0.0',-        want = 0,-      },-      {-        desc = '(v1 > v2)',-        v1 = 'v9.0.0',-        v2 = 'v0.9.0',-        want = 1,-      },-      {-        desc = '(v1 > v2)',-        v1 = 'v0.9.0',-        v2 = 'v0.0.0',-        want = 1,-      },-      {-        desc = '(v1 > v2)',-        v1 = 'v0.0.9',-        v2 = 'v0.0.0',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v1 has prerelease',-        v1 = 'v1.0.0-alpha',-        v2 = 'v1.0.0',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v2 has prerelease',-        v1 = '1.0.0',-        v2 = '1.0.0-alpha',-        want = 1,-      },-      {-        desc = '(v1 > v2) when v1 has a higher number identifier',-        v1 = '1.0.0-2',-        v2 = '1.0.0-1',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v2 has a higher number identifier',-        v1 = '1.0.0-2',-        v2 = '1.0.0-9',-        want = -1,-      },-      {-        desc = '(v1 < v2) when v2 has more identifiers',-        v1 = '1.0.0-2',-        v2 = '1.0.0-2.0',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v1 has more identifiers',-        v1 = '1.0.0-2.0',-        v2 = '1.0.0-2',-        want = 1,-      },-      {-        desc = '(v1 == v2) when v2 has same numeric identifiers',-        v1 = '1.0.0-2.0',-        v2 = '1.0.0-2.0',-        want = 0,-      },-      {-        desc = '(v1 == v2) when v2 has same alphabet identifiers',-        v1 = '1.0.0-alpha',-        v2 = '1.0.0-alpha',-        want = 0,-      },-      {-        desc = '(v1 < v2) when v2 has an alphabet identifier with higher ASCII sort order',-        v1 = '1.0.0-alpha',-        v2 = '1.0.0-beta',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v1 has an alphabet identifier with higher ASCII sort order',-        v1 = '1.0.0-beta',-        v2 = '1.0.0-alpha',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v2 has prerelease and number identifer',-        v1 = '1.0.0-alpha',-        v2 = '1.0.0-alpha.1',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v1 has prerelease and number identifer',-        v1 = '1.0.0-alpha.1',-        v2 = '1.0.0-alpha',-        want = 1,-      },-      {-        desc = '(v1 > v2) when v1 has an additional alphabet identifier',-        v1 = '1.0.0-alpha.beta',-        v2 = '1.0.0-alpha',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v2 has an additional alphabet identifier',-        v1 = '1.0.0-alpha',-        v2 = '1.0.0-alpha.beta',-        want = -1,-      },-      {-        desc = '(v1 < v2) when v2 has an a first alphabet identifier with higher precedence',-        v1 = '1.0.0-alpha.beta',-        v2 = '1.0.0-beta',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v1 has an a first alphabet identifier with higher precedence',-        v1 = '1.0.0-beta',-        v2 = '1.0.0-alpha.beta',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v2 has an additional number identifer',-        v1 = '1.0.0-beta',-        v2 = '1.0.0-beta.2',-        want = -1,-      },-      {-        desc = '(v1 < v2) when v2 has same first alphabet identifier but has a higher number identifer',-        v1 = '1.0.0-beta.2',-        v2 = '1.0.0-beta.11',-        want = -1,-      },-      {-        desc = '(v1 < v2) when v2 has higher alphabet precedence',-        v1 = '1.0.0-beta.11',-        v2 = '1.0.0-rc.1',-        want = -1,-      },+      { v1 = 'v0.0.99',          v2 = 'v9.0.0',           want = -1, },+      { v1 = 'v0.4.0',           v2 = 'v0.9.99',          want = -1, },+      { v1 = 'v0.2.8',           v2 = 'v1.0.9',           want = -1, },+      { v1 = 'v0.0.0',           v2 = 'v0.0.0',           want = 0, },+      { v1 = 'v9.0.0',           v2 = 'v0.9.0',           want = 1, },+      { v1 = 'v0.9.0',           v2 = 'v0.0.0',           want = 1, },+      { v1 = 'v0.0.9',           v2 = 'v0.0.0',           want = 1, },+      { v1 = 'v1.0.0-alpha',     v2 = 'v1.0.0',           want = -1, },+      { v1 = '1.0.0',            v2 = '1.0.0-alpha',      want = 1, },+      { v1 = '1.0.0-2',          v2 = '1.0.0-1',          want = 1, },+      { v1 = '1.0.0-2',          v2 = '1.0.0-9',          want = -1, },+      { v1 = '1.0.0-2',          v2 = '1.0.0-2.0',        want = -1, },+      { v1 = '1.0.0-2.0',        v2 = '1.0.0-2',          want = 1, },+      { v1 = '1.0.0-2.0',        v2 = '1.0.0-2.0',        want = 0, },+      { v1 = '1.0.0-alpha',      v2 = '1.0.0-alpha',      want = 0, },+      { v1 = '1.0.0-alpha',      v2 = '1.0.0-beta',       want = -1, },+      { v1 = '1.0.0-beta',       v2 = '1.0.0-alpha',      want = 1, },+      { v1 = '1.0.0-alpha',      v2 = '1.0.0-alpha.1',    want = -1, },+      { v1 = '1.0.0-alpha.1',    v2 = '1.0.0-alpha',      want = 1, },+      { v1 = '1.0.0-alpha.beta', v2 = '1.0.0-alpha',      want = 1, },+      { v1 = '1.0.0-alpha',      v2 = '1.0.0-alpha.beta', want = -1, },+      { v1 = '1.0.0-alpha.beta', v2 = '1.0.0-beta',       want = -1, },+      { v1 = '1.0.0-beta',       v2 = '1.0.0-alpha.beta', want = 1, },+      { v1 = '1.0.0-beta',       v2 = '1.0.0-beta.2',     want = -1, },+      -- TODO+      -- { v1 = '1.0.0-beta.2',     v2 = '1.0.0-beta.11',    want = -1, },","@folke IIUC https://semver.org/ , this should be:     1.0.0-beta.11 > 1.0.0-beta.2but I think lazy currently treats this as `<` ? https://github.com/neovim/neovim/pull/22736",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22707,1140365251,2023-03-17T15:13:56Z,test/functional/lua/version_spec.lua,"@@ -1,186 +1,150 @@ local helpers = require('test.functional.helpers')(after_each) local clear = helpers.clear local eq = helpers.eq+local ok = helpers.ok local exec_lua = helpers.exec_lua local matches = helpers.matches local pcall_err = helpers.pcall_err -local version = require('vim.version')--local function quote_empty(s)-  return tostring(s) == '' and '""""' or tostring(s)+local function v(ver)+  return vim.version.version(ver) end  describe('version', function()+   it('package', function()     clear()     eq({ major = 42, minor = 3, patch = 99 }, exec_lua(""return vim.version.parse('v42.3.99')""))   end) +  describe('lazy semver version', function()+    local tests = {+      ['v1.2.3'] = { major = 1, minor = 2, patch = 3 },+      ['v1.2'] = { major = 1, minor = 2, patch = 0 },+      ['v1.2.3-prerelease'] = { major = 1, minor = 2, patch = 3, prerelease = 'prerelease' },+      ['v1.2-prerelease'] = { major = 1, minor = 2, patch = 0, prerelease = 'prerelease' },+      ['v1.2.3-prerelease+build'] = { major = 1, minor = 2, patch = 3, prerelease = 'prerelease', build = ""build"" },+      ['1.2.3+build'] = { major = 1, minor = 2, patch = 3, build = 'build' },+    }+    for input, output in pairs(tests) do+      it('parses ' .. input, function()+        eq(output, v(input))+      end)+    end+  end)++  describe('lazy semver range', function()+    local tests = {+      ['1.2.3'] = { from = { 1, 2, 3 }, to = { 1, 2, 4 } },+      ['1.2'] = { from = { 1, 2, 0 }, to = { 1, 3, 0 } },+      ['=1.2.3'] = { from = { 1, 2, 3 }, to = { 1, 2, 4 } },+      ['>1.2.3'] = { from = { 1, 2, 4 } },+      ['>=1.2.3'] = { from = { 1, 2, 3 } },+      ['~1.2.3'] = { from = { 1, 2, 3 }, to = { 1, 3, 0 } },+      ['^1.2.3'] = { from = { 1, 2, 3 }, to = { 2, 0, 0 } },+      ['^0.2.3'] = { from = { 0, 2, 3 }, to = { 0, 3, 0 } },+      ['^0.0.1'] = { from = { 0, 0, 1 }, to = { 0, 0, 2 } },+      ['^1.2'] = { from = { 1, 2, 0 }, to = { 2, 0, 0 } },+      ['~1.2'] = { from = { 1, 2, 0 }, to = { 1, 3, 0 } },+      ['~1'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['^1'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['1.*'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['1'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['1.x'] = { from = { 1, 0, 0 }, to = { 2, 0, 0 } },+      ['1.2.x'] = { from = { 1, 2, 0 }, to = { 1, 3, 0 } },+      ['1.2.*'] = { from = { 1, 2, 0 }, to = { 1, 3, 0 } },+      ['*'] = { from = { 0, 0, 0 } },+      ['1.2 - 2.3.0'] = { from = { 1, 2, 0 }, to = { 2, 3, 0 } },+      ['1.2.3 - 2.3.4'] = { from = { 1, 2, 3 }, to = { 2, 3, 4 } },+      ['1.2.3 - 2'] = { from = { 1, 2, 3 }, to = { 3, 0, 0 } },+    }+    for input, output in pairs(tests) do+      output.from = v(output.from)+      output.to = output.to and v(output.to)++      local range = vim.version.range(input)+      it('parses ' .. input, function()+        eq(output, range)+      end)++      it('[from] in range ' .. input, function()+        assert(range:matches(output.from))+      end)++      it('[from-1] not in range ' .. input, function()+        local lower = vim.deepcopy(range.from)+        lower.major = lower.major - 1+        assert(not range:matches(lower))+      end)++      it('[to] not in range ' .. input .. ' to:' .. tostring(range and range.to), function()+        if range.to then+          assert(not (range.to < range.to))+          assert(not range:matches(range.to))+        end+      end)+    end++    it(""handles prerelease"", function()+      assert(not vim.version.range('1.2.3'):matches('1.2.3-alpha'))+      assert(vim.version.range('1.2.3-alpha'):matches('1.2.3-alpha'))+      assert(not vim.version.range('1.2.3-alpha'):matches('1.2.3-beta'))+    end)+  end)++  describe('lazy semver order', function()+    it('is correct', function()+      assert(v('v1.2.3') == v('1.2.3'))+      assert(not (v('v1.2.3') < v('1.2.3')))+      assert(v('v1.2.3') > v('1.2.3-prerelease'))+      assert(v('v1.2.3-alpha') < v('1.2.3-beta'))+      assert(v('v1.2.3-prerelease') < v('1.2.3'))+      assert(v('v1.2.3') >= v('1.2.3'))+      assert(v('v1.2.3') >= v('1.0.3'))+      assert(v('v1.2.3') >= v('1.2.2'))+      assert(v('v1.2.3') > v('1.2.2'))+      assert(v('v1.2.3') > v('1.0.3'))+      eq(vim.version.last({ v('1.2.3'), v('2.0.0') }), v('2.0.0'))+      eq(vim.version.last({ v('2.0.0'), v('1.2.3') }), v('2.0.0'))+    end)+  end)+   describe('cmp()', function()     local testcases = {-      {-        desc = '(v1 < v2)',-        v1 = 'v0.0.99',-        v2 = 'v9.0.0',-        want = -1,-      },-      {-        desc = '(v1 < v2)',-        v1 = 'v0.4.0',-        v2 = 'v0.9.99',-        want = -1,-      },-      {-        desc = '(v1 < v2)',-        v1 = 'v0.2.8',-        v2 = 'v1.0.9',-        want = -1,-      },-      {-        desc = '(v1 == v2)',-        v1 = 'v0.0.0',-        v2 = 'v0.0.0',-        want = 0,-      },-      {-        desc = '(v1 > v2)',-        v1 = 'v9.0.0',-        v2 = 'v0.9.0',-        want = 1,-      },-      {-        desc = '(v1 > v2)',-        v1 = 'v0.9.0',-        v2 = 'v0.0.0',-        want = 1,-      },-      {-        desc = '(v1 > v2)',-        v1 = 'v0.0.9',-        v2 = 'v0.0.0',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v1 has prerelease',-        v1 = 'v1.0.0-alpha',-        v2 = 'v1.0.0',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v2 has prerelease',-        v1 = '1.0.0',-        v2 = '1.0.0-alpha',-        want = 1,-      },-      {-        desc = '(v1 > v2) when v1 has a higher number identifier',-        v1 = '1.0.0-2',-        v2 = '1.0.0-1',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v2 has a higher number identifier',-        v1 = '1.0.0-2',-        v2 = '1.0.0-9',-        want = -1,-      },-      {-        desc = '(v1 < v2) when v2 has more identifiers',-        v1 = '1.0.0-2',-        v2 = '1.0.0-2.0',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v1 has more identifiers',-        v1 = '1.0.0-2.0',-        v2 = '1.0.0-2',-        want = 1,-      },-      {-        desc = '(v1 == v2) when v2 has same numeric identifiers',-        v1 = '1.0.0-2.0',-        v2 = '1.0.0-2.0',-        want = 0,-      },-      {-        desc = '(v1 == v2) when v2 has same alphabet identifiers',-        v1 = '1.0.0-alpha',-        v2 = '1.0.0-alpha',-        want = 0,-      },-      {-        desc = '(v1 < v2) when v2 has an alphabet identifier with higher ASCII sort order',-        v1 = '1.0.0-alpha',-        v2 = '1.0.0-beta',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v1 has an alphabet identifier with higher ASCII sort order',-        v1 = '1.0.0-beta',-        v2 = '1.0.0-alpha',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v2 has prerelease and number identifer',-        v1 = '1.0.0-alpha',-        v2 = '1.0.0-alpha.1',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v1 has prerelease and number identifer',-        v1 = '1.0.0-alpha.1',-        v2 = '1.0.0-alpha',-        want = 1,-      },-      {-        desc = '(v1 > v2) when v1 has an additional alphabet identifier',-        v1 = '1.0.0-alpha.beta',-        v2 = '1.0.0-alpha',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v2 has an additional alphabet identifier',-        v1 = '1.0.0-alpha',-        v2 = '1.0.0-alpha.beta',-        want = -1,-      },-      {-        desc = '(v1 < v2) when v2 has an a first alphabet identifier with higher precedence',-        v1 = '1.0.0-alpha.beta',-        v2 = '1.0.0-beta',-        want = -1,-      },-      {-        desc = '(v1 > v2) when v1 has an a first alphabet identifier with higher precedence',-        v1 = '1.0.0-beta',-        v2 = '1.0.0-alpha.beta',-        want = 1,-      },-      {-        desc = '(v1 < v2) when v2 has an additional number identifer',-        v1 = '1.0.0-beta',-        v2 = '1.0.0-beta.2',-        want = -1,-      },-      {-        desc = '(v1 < v2) when v2 has same first alphabet identifier but has a higher number identifer',-        v1 = '1.0.0-beta.2',-        v2 = '1.0.0-beta.11',-        want = -1,-      },-      {-        desc = '(v1 < v2) when v2 has higher alphabet precedence',-        v1 = '1.0.0-beta.11',-        v2 = '1.0.0-rc.1',-        want = -1,-      },+      { v1 = 'v0.0.99',          v2 = 'v9.0.0',           want = -1, },+      { v1 = 'v0.4.0',           v2 = 'v0.9.99',          want = -1, },+      { v1 = 'v0.2.8',           v2 = 'v1.0.9',           want = -1, },+      { v1 = 'v0.0.0',           v2 = 'v0.0.0',           want = 0, },+      { v1 = 'v9.0.0',           v2 = 'v0.9.0',           want = 1, },+      { v1 = 'v0.9.0',           v2 = 'v0.0.0',           want = 1, },+      { v1 = 'v0.0.9',           v2 = 'v0.0.0',           want = 1, },+      { v1 = 'v1.0.0-alpha',     v2 = 'v1.0.0',           want = -1, },+      { v1 = '1.0.0',            v2 = '1.0.0-alpha',      want = 1, },+      { v1 = '1.0.0-2',          v2 = '1.0.0-1',          want = 1, },+      { v1 = '1.0.0-2',          v2 = '1.0.0-9',          want = -1, },+      { v1 = '1.0.0-2',          v2 = '1.0.0-2.0',        want = -1, },+      { v1 = '1.0.0-2.0',        v2 = '1.0.0-2',          want = 1, },+      { v1 = '1.0.0-2.0',        v2 = '1.0.0-2.0',        want = 0, },+      { v1 = '1.0.0-alpha',      v2 = '1.0.0-alpha',      want = 0, },+      { v1 = '1.0.0-alpha',      v2 = '1.0.0-beta',       want = -1, },+      { v1 = '1.0.0-beta',       v2 = '1.0.0-alpha',      want = 1, },+      { v1 = '1.0.0-alpha',      v2 = '1.0.0-alpha.1',    want = -1, },+      { v1 = '1.0.0-alpha.1',    v2 = '1.0.0-alpha',      want = 1, },+      { v1 = '1.0.0-alpha.beta', v2 = '1.0.0-alpha',      want = 1, },+      { v1 = '1.0.0-alpha',      v2 = '1.0.0-alpha.beta', want = -1, },+      { v1 = '1.0.0-alpha.beta', v2 = '1.0.0-beta',       want = -1, },+      { v1 = '1.0.0-beta',       v2 = '1.0.0-alpha.beta', want = 1, },+      { v1 = '1.0.0-beta',       v2 = '1.0.0-beta.2',     want = -1, },+      -- TODO+      -- { v1 = '1.0.0-beta.2',     v2 = '1.0.0-beta.11',    want = -1, },","I remember now. For lazy's use-case that doesn't really matter, since if you want to get the latest version, you always get the latest stable without including pre-releases.In Semver ranges, you can only use pre-release versions when they are explicitly specified.But could still be useful for others though, so good to fix that and to be spec compliant",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22723,1141012697,2023-03-18T12:44:15Z,src/nvim/drawscreen.c,"@@ -1394,8 +1395,11 @@ static void win_update(win_T *wp, DecorProviders *providers)   if (type >= UPD_NOT_VALID) {     // TODO(bfredl): should only be implied for CLEAR, not NOT_VALID!",You can remove this TODO. after the latest refactors it no longer makes sense.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/22693,1141221137,2023-03-19T00:12:30Z,src/nvim/highlight_group.c,"@@ -1521,6 +1522,228 @@ static void highlight_list_one(const int id)   } } +static void hlgroup2dict(Dictionary *dict, HlGroup *sgp, bool use_hex, Arena *arena)+{+  Dictionary hl = *dict;+  if (sgp->sg_link > 0) {+    hl = arena_dict(arena, 1);+    char *link = hl_table[sgp->sg_link - 1].sg_name;+    PUT_C(hl, ""link"", STRING_OBJ(cstr_as_string(link)));+  } else {+    hl = arena_dict(arena, HLATTRS_DICT_SIZE);+    HlAttrs ae = syn_attr2entry(sgp->sg_attr);+    int mask = ae.rgb_ae_attr;++    // Ordered by `:h nvim_set_hl`+    char hexbuf[8];+    if (ae.rgb_fg_color != -1) {+      if (use_hex) {+        PUT_C(hl, ""fg"",+              STRING_OBJ(cstr_as_string(xstrdup(coloridx_to_name(sgp->sg_rgb_fg_idx, sgp->sg_rgb_fg,+                                                                 hexbuf)))));+      } else {+        PUT_C(hl, ""fg"", INTEGER_OBJ(ae.rgb_fg_color));+      }+    }++    if (ae.rgb_bg_color != -1) {+      if (use_hex) {+        PUT_C(hl, ""bg"",+              STRING_OBJ(cstr_as_string(xstrdup(coloridx_to_name(sgp->sg_rgb_bg_idx, sgp->sg_rgb_bg,+                                                                 hexbuf)))));+      } else {+        PUT_C(hl, ""bg"", INTEGER_OBJ(ae.rgb_bg_color));+      }+    }++    if (ae.rgb_sp_color != -1) {+      if (use_hex) {+        PUT_C(hl, ""sp"",+              STRING_OBJ(cstr_as_string(xstrdup(coloridx_to_name(sgp->sg_rgb_sp_idx, sgp->sg_rgb_sp,+                                                                 hexbuf)))));+      } else {+        PUT_C(hl, ""sp"", INTEGER_OBJ(ae.rgb_sp_color));+      }+    }++    if (ae.hl_blend > -1) {+      PUT_C(hl, ""blend"", INTEGER_OBJ(ae.hl_blend));+    }++    if (mask & HL_BOLD) {+      PUT_C(hl, ""bold"", BOOLEAN_OBJ(true));+    }++    if (mask & HL_STANDOUT) {+      PUT_C(hl, ""standout"", BOOLEAN_OBJ(true));+    }++    switch (mask & HL_UNDERLINE_MASK) {+    case HL_UNDERLINE:+      PUT_C(hl, ""underline"", BOOLEAN_OBJ(true));+      break;++    case HL_UNDERCURL:+      PUT_C(hl, ""undercurl"", BOOLEAN_OBJ(true));+      break;++    case HL_UNDERDOUBLE:+      PUT_C(hl, ""underdouble"", BOOLEAN_OBJ(true));+      break;++    case HL_UNDERDOTTED:+      PUT_C(hl, ""underdotted"", BOOLEAN_OBJ(true));+      break;++    case HL_UNDERDASHED:+      PUT_C(hl, ""underdashed"", BOOLEAN_OBJ(true));+      break;+    }++    if (mask & HL_STRIKETHROUGH) {+      PUT_C(hl, ""strikethrough"", BOOLEAN_OBJ(true));+    }++    if (mask & HL_ITALIC) {+      PUT_C(hl, ""italic"", BOOLEAN_OBJ(true));+    }++    if (mask & HL_INVERSE) {+      PUT_C(hl, ""reverse"", BOOLEAN_OBJ(true));+    }++    if (mask & HL_NOCOMBINE) {+      PUT_C(hl, ""nocombine"", BOOLEAN_OBJ(true));+    }++    mask = ae.cterm_ae_attr;++    if (ae.cterm_fg_color != 0) {+      PUT_C(hl, ""ctermfg"", INTEGER_OBJ(ae.cterm_fg_color - 1));+    }++    if (ae.cterm_bg_color != 0) {+      PUT_C(hl, ""ctermbg"", INTEGER_OBJ(ae.cterm_bg_color - 1));+    }++    if (!(mask & HL_UNDERLINE_MASK) && ae.cterm_ae_attr != 0) {+      // Ordered by `:h highlight-cterm`+      Dictionary cterm = arena_dict(arena, HLATTRS_DICT_SIZE);+      mask = ae.cterm_ae_attr;+      if (mask & HL_BOLD) {+        PUT_C(cterm, ""bold"", BOOLEAN_OBJ(true));+      }++      switch (mask & HL_UNDERLINE_MASK) {+      case HL_UNDERLINE:+        PUT_C(cterm, ""underline"", BOOLEAN_OBJ(true));+        break;++      case HL_UNDERCURL:+        PUT_C(cterm, ""undercurl"", BOOLEAN_OBJ(true));+        break;++      case HL_UNDERDOUBLE:+        PUT_C(cterm, ""underdouble"", BOOLEAN_OBJ(true));+        break;++      case HL_UNDERDOTTED:+        PUT_C(cterm, ""underdotted"", BOOLEAN_OBJ(true));+        break;++      case HL_UNDERDASHED:+        PUT_C(cterm, ""underdashed"", BOOLEAN_OBJ(true));+        break;+      }++      if (mask & HL_STRIKETHROUGH) {+        PUT_C(cterm, ""strikethrough"", BOOLEAN_OBJ(true));+      }++      if (mask & HL_INVERSE) {+        PUT_C(cterm, ""reverse"", BOOLEAN_OBJ(true));  // inverse = reverse+      }++      if (mask & HL_ITALIC) {+        PUT_C(cterm, ""italic"", BOOLEAN_OBJ(true));+      }++      if (mask & HL_STANDOUT) {+        PUT_C(cterm, ""standout"", BOOLEAN_OBJ(true));+      }++      if (mask & HL_ALTFONT) {+        PUT_C(cterm, ""altfont"", BOOLEAN_OBJ(true));+      }++      if (mask & HL_NOCOMBINE) {+        PUT_C(cterm, ""nocombine"", BOOLEAN_OBJ(true));+      }",It seems that there is a lot of code duplication between this branch and `hlattrs2dict()` in highlight.c. I guess it's better to add a `use_hex` argument to `hlattrs2dict()` and just call that function twice for rgb and cterm here.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22728,1141419630,2023-03-19T17:01:18Z,runtime/doc/options.txt,"@@ -5235,9 +5235,11 @@ A jump table for the options with a short description can be found at |Q_op|. 							*shell-powershell* 	To use PowerShell: > 		let &shell = executable('pwsh') ? 'pwsh' : 'powershell'-		let &shellcmdflag = '-NoLogo -NoProfile -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;'-		let &shellredir = '2>&1 | Out-File -Encoding UTF8 %s; exit $LastExitCode'-		let &shellpipe = '2>&1 | Out-File -Encoding UTF8 %s; exit $LastExitCode'+		let &shellcmdflag = '-NoLogo -ExecutionPolicy RemoteSigned -Command '+		let &shellcmdflag .= '[Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.UTF8Encoding]::new();'",The `.=` makes it look more complicated. It's ok if the line is a bit long.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22728,1141420415,2023-03-19T17:07:32Z,runtime/doc/options.txt,"@@ -5268,8 +5268,8 @@ A jump table for the options with a short description can be found at |Q_op|. 	The name of the temporary file can be represented by ""%s"" if necessary","Does the defaults list on line 5269 need to be updated? Looks like `src/nvim/options.lua` only has these two:```'shellpipe' 'sp'	string	(default ""| tee"" or ""2>&1| tee"")```",
32037751,3N4N,https://api.github.com/repos/neovim/neovim/pulls/22728,1141422633,2023-03-19T17:21:22Z,runtime/doc/options.txt,"@@ -5268,8 +5268,8 @@ A jump table for the options with a short description can be found at |Q_op|. 	The name of the temporary file can be represented by ""%s"" if necessary","I am confused as to how `options.lua` works (by which I mean I haven't looked into it at all).  It says, if non-windows, shellpipe will be ""| tee"", but in Linux with bash, I get shellpipe ""2>&1| tee"".  That's why I didn't know if I should change the default values in the doc.What I _can_ say is we can remove the previous cmd default: "">%s 2>&1"".  But I don't know if we can remove "">"", ""|& tee"".  Should I remove only the previous-cmd default and keep the rest? or remove all but the two listed in `options.lua`?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22728,1141442861,2023-03-19T18:38:13Z,runtime/doc/options.txt,"@@ -5268,8 +5268,8 @@ A jump table for the options with a short description can be found at |Q_op|. 	The name of the temporary file can be represented by ""%s"" if necessary",Oh I see we have special handling for 'shellpipe': https://github.com/neovim/neovim/blob/86c164d2a14382adfb388a66699828df6c623102/src/nvim/option.c#L629-L643> Should I remove only the previous-cmd default and keep the rest?Yes,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22707,1141507798,2023-03-20T00:07:33Z,runtime/doc/lua.txt,"@@ -2574,4 +2585,22 @@ parse({version}, {opts})                                 *vim.version.parse()*         (table|nil) parsed_version Parsed version table or `nil` if `version`         is invalid. +range({spec})                                            *vim.version.range()*+    Parameters: ~+      ��� {spec}  (string)++Range:matches({self}, {version})                 *vim.version.Range:matches()*","Yeah. I'm still not sure if we want `vim.version.range` in any form, because ranges are not part of https://semver.org/ : they are a parallel quasi-spec which I guess is specified by https://devhints.io/semver and/or https://github.com/npm/node-semver#ranges ? ",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/22693,1141899933,2023-03-20T10:19:56Z,src/nvim/api/vim.c,"@@ -119,6 +119,28 @@ Integer nvim_get_hl_id_by_name(String name)   return syn_check_group(name.data, name.size); } +/// Gets highlight groups+///+/// @note Unlike the `:highlight` command which list all the current highlight",```suggestion/// @note Unlike the `:highlight` command which lists all the current highlight```,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22693,1142056354,2023-03-20T12:43:17Z,runtime/doc/api.txt,"@@ -923,6 +923,26 @@ nvim_get_current_win()                                *nvim_get_current_win()*     Return: ~         Window handle +nvim_get_hl({ns_id}, {*val})                                   *nvim_get_hl()*+    Gets highlight groups++    Note:+        Unlike the `:highlight` command which lists all the current highlight+        groups that have attributes set in human readable format, this+        function returns a table of all current highlight groups in a machine+        readable format (i.e. can be directly fed to nvim_set_hl)++    Parameters: ~+      ��� {ns_id}  Get highlight groups using namespace ns_id+                 |nvim_get_namespaces()|. Use 0 to get global highlight groups+                 |:highlight|.+      ��� {val}    Options dict:+                 ��� name: (string) Get a highlight definition by name.+                 ��� id: (integer) Get a highlight definition by id.+                 ��� hex: (boolean, default false) shows colors in RGB hex+                   representation instead of decimal.","How do you manipulate a colorscheme with the string form? I've only ever manipulated using the integer form (as above).I think you're confusing types with number bases. A number can be represented as any base, it just happens that Lua's `print` uses base 10. What's more useful is separating the RGB components.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22693,1142208203,2023-03-20T14:29:05Z,runtime/doc/api.txt,"@@ -923,6 +923,26 @@ nvim_get_current_win()                                *nvim_get_current_win()*     Return: ~         Window handle +nvim_get_hl({ns_id}, {*val})                                   *nvim_get_hl()*+    Gets highlight groups++    Note:+        Unlike the `:highlight` command which lists all the current highlight+        groups that have attributes set in human readable format, this+        function returns a table of all current highlight groups in a machine+        readable format (i.e. can be directly fed to nvim_set_hl)++    Parameters: ~+      ��� {ns_id}  Get highlight groups using namespace ns_id+                 |nvim_get_namespaces()|. Use 0 to get global highlight groups+                 |:highlight|.+      ��� {val}    Options dict:+                 ��� name: (string) Get a highlight definition by name.+                 ��� id: (integer) Get a highlight definition by id.+                 ��� hex: (boolean, default false) shows colors in RGB hex+                   representation instead of decimal.","Now that we have `bit` guaranteed in the lua stdlib, we can add further (pure-lua) helper functions to split a 24-bit integer into three 8-bit integers and vice versa. It doesn't need to be present in the language-independent API-interface.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1142291024,2023-03-20T15:21:10Z,runtime/lua/vim/loader.lua,"@@ -0,0 +1,528 @@+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class ModuleFindOpts+---@field all? boolean Search for all matches (defaults to `false`)+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---@field paths? string[] Extra paths to search for modname++---@class ModuleInfo+---@field modpath string Path of the module+---@field modname string Name of the module+---@field stat? uv_fs_t File stat of the module path++M.VERSION = 3+M.path = vim.fn.stdpath('cache') .. '/luac'+M.enabled = false+---@type table<string, {total:number, time:number, [string]:number?}?>+M.stats = {+  find = { total = 0, time = 0, not_found = 0 },+}++---@class Loader+---@field _rtp string[]+---@field _rtp_pure string[]+---@field _rtp_key string+local Loader = {+  ---@type table<string, table<string,ModuleInfo>>+  _indexed = {},+  ---@type table<string, string[]>+  _topmods = {},+  _loadfile = loadfile,+}++--- Tracks the time spent in a function+---@private+function M._track(stat, start)+  M.stats[stat] = M.stats[stat] or { total = 0, time = 0 }","I currently show those stats in the Lazy debug ui, but that's not that important.I'll localize `stats` and will for now add it to `M._inspect()`, which is already private. If that method would be removed at some point, then no big deal. I'll then just remove the debug output from the lazy ui.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22668,1142325377,2023-03-20T15:40:52Z,runtime/lua/vim/loader.lua,"@@ -0,0 +1,528 @@+local uv = vim.loop++local M = {}++---@alias CacheHash {mtime: {sec:number, nsec:number}, size:number}+---@alias CacheEntry {hash:CacheHash, chunk:string}++---@class ModuleFindOpts+---@field all? boolean Search for all matches (defaults to `false`)+---@field rtp? boolean Search for modname in the runtime path (defaults to `true`)+---@field patterns? string[] Paterns to use (defaults to `{""/init.lua"", "".lua""}`)+---@field paths? string[] Extra paths to search for modname++---@class ModuleInfo+---@field modpath string Path of the module+---@field modname string Name of the module+---@field stat? uv_fs_t File stat of the module path++M.VERSION = 3+M.path = vim.fn.stdpath('cache') .. '/luac'+M.enabled = false+---@type table<string, {total:number, time:number, [string]:number?}?>+M.stats = {+  find = { total = 0, time = 0, not_found = 0 },+}++---@class Loader+---@field _rtp string[]+---@field _rtp_pure string[]+---@field _rtp_key string+local Loader = {+  ---@type table<string, table<string,ModuleInfo>>+  _indexed = {},+  ---@type table<string, string[]>+  _topmods = {},+  _loadfile = loadfile,+}++--- Tracks the time spent in a function+---@private+function M._track(stat, start)+  M.stats[stat] = M.stats[stat] or { total = 0, time = 0 }","I'm not sure the stats are even that relevant for a `checkhealth`. I mostly added them for performance testing when I was still working on the code.As a reference, this is the lazy debug interface:![image](https://user-images.githubusercontent.com/292349/226391505-dca533ba-8eb7-46a9-89e0-1bef147d9c06.png)`vim.loader._inspect()` prints something similar in messages. But again, not something a regular Neovim user would ever need to use/see.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/22747,1143576449,2023-03-21T15:30:11Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -203,7 +288,14 @@ function M.on_publish_diagnostics(_, result, ctx, config)     vim.diagnostic.config(config, namespace)   end -  vim.diagnostic.set(namespace, bufnr, diagnostic_lsp_to_vim(diagnostics, bufnr, client_id))+  -- Do not report diagnostics with tags as a normal diagnostics.+  -- Instead, just highlight them. See:+  -- https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticTag+  -- and https://github.com/microsoft/pyright/issues/1118#issuecomment-835528161+  local diags, tagged_diags = filter_tagged(diagnostics)++  vim.diagnostic.set(namespace, bufnr, diagnostic_lsp_to_vim(diags, bufnr, client_id))+  highlight_tagged_diagnostics(bufnr, client_id, namespace_aux, tagged_diags)","Do you think it's worth doing the conversion and filtering in one pass, to avoid a copy operation?Not sure about the performance impact, but some language servers on bigger project can easily report 1000+ diagnostics.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22747,1143587424,2023-03-21T15:37:25Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -203,7 +288,14 @@ function M.on_publish_diagnostics(_, result, ctx, config)     vim.diagnostic.config(config, namespace)   end -  vim.diagnostic.set(namespace, bufnr, diagnostic_lsp_to_vim(diagnostics, bufnr, client_id))+  -- Do not report diagnostics with tags as a normal diagnostics.+  -- Instead, just highlight them. See:+  -- https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#diagnosticTag+  -- and https://github.com/microsoft/pyright/issues/1118#issuecomment-835528161+  local diags, tagged_diags = filter_tagged(diagnostics)++  vim.diagnostic.set(namespace, bufnr, diagnostic_lsp_to_vim(diags, bufnr, client_id))+  highlight_tagged_diagnostics(bufnr, client_id, namespace_aux, tagged_diags)",Maybe it'll be better to mutate the original list and remove tagged diagnostics from it.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22693,1144566815,2023-03-22T10:27:01Z,src/nvim/highlight.c,"@@ -830,7 +830,8 @@ Dictionary hl_get_attr_by_id(Integer attr_id, Boolean rgb, Arena *arena, Error * /// @param[in/out] hl Dictionary with pre-allocated space for HLATTRS_DICT_SIZE elements /// @param[in] aep data to convert /// @param use_rgb use 'gui*' settings if true, else resorts to 'cterm*'-void hlattrs2dict(Dictionary *dict, HlAttrs ae, bool use_rgb)+/// @param nvim_get_hl function is being used by nvim_get_hl","reusing a public symbol (`nvim_get_hl`) as a local variable is also an anti-pattern. It seems to make color keys shorter, so something that indicates that would be suitable.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22693,1144570938,2023-03-22T10:29:52Z,src/nvim/highlight.c,"@@ -887,32 +888,56 @@ void hlattrs2dict(Dictionary *dict, HlAttrs ae, bool use_rgb)   }    if (use_rgb) {-    if (mask & HL_FG_INDEXED) {-      PUT_C(hl, ""fg_indexed"", BOOLEAN_OBJ(true));-    }+    if (nvim_get_hl) {+      if (ae.rgb_fg_color != -1) {+        PUT_C(hl, ""fg"", INTEGER_OBJ(ae.rgb_fg_color));","We can get rid of excessive duplication and branching by using `short_keys ? ""fg"" : ""foreground""` inline (assuming the new param name).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22741,1144677650,2023-03-22T11:52:37Z,runtime/doc/api.txt,"@@ -1949,12 +1949,35 @@ nvim_get_option_info({name})                          *nvim_get_option_info()*     ��� commalist: List of comma separated values     ��� flaglist: List of single char flags +    The last set information applies to the local value in the current buffer+    or window if it is available, otherwise the global value information is+    returned.+     Parameters: ~       ��� {name}  Option name      Return: ~         Option Information +nvim_get_option_info_ex({name}, {*opts})           *nvim_get_option_info_ex()*+    Gets the option information for one option from arbitrary buffer or window++    This function is similar to nvim_get_option_info except that it accepts an+    additional options table {opts}, allowing to specify option scope, buffer+    number or window used for retrieving the last set location information.++    Parameters: ~+      ��� {name}  Option name+      ��� {opts}  Optional parameters+                ��� scope: One of ""global"" or ""local"". Analogous to |:setglobal|+                  and |:setlocal|, respectively.+                ��� win: |window-ID|. Used for getting window local options.+                ��� buf: Buffer number. Used for getting buffer local options.+                  Implies {scope} is ""local"".++    Return: ~+        Option Information","This is a full replacement for `nvim_get_option_info`, right? So let's move the docs for `nvim_get_option_info` here, and deprecate `nvim_get_option_info`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22741,1144683311,2023-03-22T11:58:29Z,test/functional/api/vim_spec.lua,"@@ -2878,6 +2892,111 @@ describe('API', function()     end)   end) +  describe('nvim_get_option_info_ex', function()+    local fname+    local bufs+    local wins++    before_each(function()+      fname = tmpname()+      write_file(fname, [[+        setglobal completeopt=menu      ""  1, global+        setglobal completefunc=myfunc   ""  2, buffer-local+        setglobal concealcursor=n       ""  3, window-local+        setglobal dictionary=mydict     ""  4, global-local (buffer)+        setglobal showbreak=aaa         ""  5, global-local (window)+        setlocal  wildoptions=pum       ""  6, global+        setlocal  spelloptions=camel    ""  7, buffer-local+        setlocal  signcolumn=yes        ""  8, window-local+        setlocal  formatprg=myprg       ""  9, global-local (buffer)+        setlocal  virtualedit=block     "" 10, global-local (window)+      ]])++      exec_lua 'vim.cmd.vsplit()'+      meths.create_buf(false, false)++      bufs = meths.list_bufs()+      wins = meths.list_wins()++      meths.win_set_buf(wins[1].id, bufs[1].id)+      meths.win_set_buf(wins[2].id, bufs[2].id)++      meths.set_current_win(wins[2].id)+      meths.exec('source ' .. fname, false)++      meths.set_current_win(wins[1].id)+    end)++    after_each(function()+      os.remove(fname)+    end)++    it('should return option information', function()+      eq(meths.get_option_info('completeopt'),    meths.get_option_info_ex('completeopt',   {}))+      eq(meths.get_option_info('completefunc'),   meths.get_option_info_ex('completefunc',  {}))+      eq(meths.get_option_info('concealcursor'),  meths.get_option_info_ex('concealcursor', {}))+      eq(meths.get_option_info('dictionary'),     meths.get_option_info_ex('dictionary',    {}))+      eq(meths.get_option_info('showbreak'),      meths.get_option_info_ex('showbreak',     {}))+      eq(meths.get_option_info('wildoptions'),    meths.get_option_info_ex('wildoptions',   {}))+      eq(meths.get_option_info('spelloptions'),   meths.get_option_info_ex('spelloptions',  {}))+      eq(meths.get_option_info('signcolumn'),     meths.get_option_info_ex('signcolumn',    {}))+      eq(meths.get_option_info('formatprg'),      meths.get_option_info_ex('formatprg',     {}))+      eq(meths.get_option_info('virtualedit'),    meths.get_option_info_ex('virtualedit',   {}))+    end)++    describe('last set', function()+      it('should point to the global value if set', function()+        local info = meths.get_option_info_ex('completefunc', {scope = 'global'})+        eq(2, info.last_set_linenr)+        eq(1, info.last_set_sid)+      end)++      it('should fall back to the global value if buffer local value is not set', function()+        local info = meths.get_option_info_ex('completefunc', {buf = bufs[2].id})+        eq(2, info.last_set_linenr)+        eq(1, info.last_set_sid)+      end)++      it('should point to the buffer local value if set', function()+        local info = meths.get_option_info_ex('spelloptions', {buf = bufs[2].id})+        eq(7, info.last_set_linenr)+        eq(1, info.last_set_sid)+      end)++      it('should default to the local value for the current buffer', function()+        local info = meths.get_option_info_ex('spelloptions', {})+        eq(0, info.last_set_linenr)+        eq(0, info.last_set_sid)+        meths.set_current_win(wins[2].id)+        info = meths.get_option_info_ex('spelloptions', {})+        eq(7, info.last_set_linenr)+        eq(1, info.last_set_sid)+      end)++      it('should fall back to the global value if window local value is not set', function()","nit: ""should"" is never needed in the test names. These names are getting really long so might as well drop it.```suggestion      it('falls back to global value if window-local value not set', function()```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22741,1144695205,2023-03-22T12:03:46Z,src/nvim/api/options.c,"@@ -309,15 +309,55 @@ Dictionary nvim_get_all_options_info(Error *err) ///     - commalist: List of comma separated values ///     - flaglist: List of single char flags ///+/// The last set information applies to the local value in the current buffer+/// or window if it is available, otherwise the global value information is+/// returned. /// /// @param          name Option name /// @param[out] err Error details, if any /// @return         Option Information Dictionary nvim_get_option_info(String name, Error *err)   FUNC_API_SINCE(7) {-  return get_vimoption(name, err);+  return get_vimoption(name, curbuf, curwin, err); }++/// Gets the option information for one option from arbitrary buffer or window+///+/// This function is similar to @ref nvim_get_option_info except that it+/// accepts an additional options table {opts}, allowing to specify option+/// scope, buffer number or window used for retrieving the last set location+/// information.+///+/// @param name      Option name+/// @param opts      Optional parameters+///                  - scope: One of ""global"" or ""local"". Analogous to+///                  |:setglobal| and |:setlocal|, respectively.+///                  - win: |window-ID|. Used for getting window local options.+///                  - buf: Buffer number. Used for getting buffer local options.+///                         Implies {scope} is ""local"".+/// @param[out] err Error details, if any+/// @return         Option Information",Does it also return the value? Seems worthwhile to be able to deprecate all of:```nvim_get_option()                                                     nvim_get_option_info()  nvim_get_option_value()nvim_win_get_option*nvim_buf_get_option*```,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22741,1147477348,2023-03-24T11:47:52Z,src/nvim/api/options.c,"@@ -309,15 +309,55 @@ Dictionary nvim_get_all_options_info(Error *err) ///     - commalist: List of comma separated values ///     - flaglist: List of single char flags ///+/// The last set information applies to the local value in the current buffer+/// or window if it is available, otherwise the global value information is+/// returned. /// /// @param          name Option name /// @param[out] err Error details, if any /// @return         Option Information Dictionary nvim_get_option_info(String name, Error *err)   FUNC_API_SINCE(7) {-  return get_vimoption(name, err);+  return get_vimoption(name, curbuf, curwin, err); }++/// Gets the option information for one option from arbitrary buffer or window+///+/// This function is similar to @ref nvim_get_option_info except that it+/// accepts an additional options table {opts}, allowing to specify option+/// scope, buffer number or window used for retrieving the last set location+/// information.+///+/// @param name      Option name+/// @param opts      Optional parameters+///                  - scope: One of ""global"" or ""local"". Analogous to+///                  |:setglobal| and |:setlocal|, respectively.+///                  - win: |window-ID|. Used for getting window local options.+///                  - buf: Buffer number. Used for getting buffer local options.+///                         Implies {scope} is ""local"".+/// @param[out] err Error details, if any+/// @return         Option Information","`nvim_get_option`, `nvim_win_get_option` and `nvim_buf_get_option` already have a plan to be deprecated.I think this should be separate from `nvim_get_option_value`, for the main reason I want the return types to be different for each.",
545480,cryptomilk,https://api.github.com/repos/neovim/neovim/pulls/22780,1148350599,2023-03-25T10:56:47Z,src/nvim/eval.c,"@@ -6816,20 +6816,20 @@ char *set_cmdarg(exarg_T *eap, char *oldarg)   }    if (eap->force_ff != 0) {-    snprintf(newval + strlen(newval), newval_len, "" ++ff=%s"",+    snprintf(newval + strlen(newval), newval_len - strlen(newval), "" ++ff=%s"",","Line 6837 doesn't append but overwrites, should it append? The STRCPY also looks bad.",
24854248,echasnovski,https://api.github.com/repos/neovim/neovim/pulls/19032,1148361366,2023-03-25T12:28:32Z,src/nvim/context.c,"@@ -271,8 +272,10 @@ static inline void ctx_save_funcs(Context *ctx, bool scriptonly)       size_t cmd_len = sizeof(""func! "") + strlen(name);       char *cmd = xmalloc(cmd_len);       snprintf(cmd, cmd_len, ""func! %s"", name);-      String func_body = nvim_exec(VIML_INTERNAL_CALL, cstr_as_string(cmd),-                                   true, &err);+      Dict(exec_opts) opts = { 0 };+      opts.output = BOOLEAN_OBJ(true);+      String func_body = exec_impl(VIML_INTERNAL_CALL, cstr_as_string(cmd),","Short answer: I tried but couldn't do it. This worked, so decided to use it.Long answer: I didn't manage to write proper C code to get `output` field from `nvim_exec2()` dictionary output.Code for `nvim_exec()` was like this:```cString nvim_exec(uint64_t channel_id, String src, Boolean output, Error *err)  FUNC_API_SINCE(7)  FUNC_API_DEPRECATED_SINCE(11){  Dict(exec_opts) opts = { 0 };  opts.output = BOOLEAN_OBJ(output);  Dictionary exec2_output = nvim_exec2(channel_id, src, &opts, err);  for (size_t i = 0; i < exec2_output.size; i++) {    if (strequal(exec2_output.items[i].key.data, ""output"")) {      return exec2_output.items[i].value.data.string;    }  }  return (String)STRING_INIT;}```I thought this should essentially be `return nvim_exec2(src, { output = output }).output` but it always returned empty string (while same `nvim_exec2()` call does return non-empty string). There seems to also be some potential memory leak, so Bjorn suggested to write a helper while leaving `nvim_exec2()` to construct output dictionary.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22784,1148430011,2023-03-25T20:41:41Z,runtime/lua/vim/treesitter/query_linter.lua,"@@ -0,0 +1,146 @@+local namespace = vim.api.nvim_create_namespace('vim.treesitter.query_linter')+-- those node names exist for every language+local MAGIC_NODE_NAMES = { '_', 'ERROR' }++local M = {}+local lints = {}++local function show_lints(buf, lints)+  local diagnostics = vim.tbl_map(function(lint)+    return {+      lnum = lint.range[1],+      end_lnum = lint.range[3],+      col = lint.range[2],+      end_col = lint.range[4],+      severity = vim.diagnostic.ERROR,+      message = lint.message,+    }+  end, lints)+  vim.diagnostic.set(namespace, buf, diagnostics)+end++local function add_lint_for_node(node, buf, error_type, complete_message)+  local node_text = vim.treesitter.get_node_text(node, buf):gsub('\n', ' ')+  local error_text = complete_message or error_type .. ': ' .. node_text+  local error_range = { node:range() }+  table.insert(+    lints[buf],+    { type = error_type, range = error_range, message = error_text, node_text = node_text }+  )+end++local function table_contains(predicate, table)+  for _, elt in pairs(table) do+    if predicate(elt) then+      return true+    end+  end+  return false+end++local function guess_query_lang(buf, _)+  local filename = vim.api.nvim_buf_get_name(buf)+  if filename ~= '' then+    local ok, query_lang = pcall(vim.fn.fnamemodify, filename, ':p:h:t')+    return ok and query_lang+  end+end++local function normalize_opts(buf, opts)+  opts = opts or {}+  opts.langs = opts.langs or guess_query_lang+  if type(opts.langs) == 'function' then+    opts.langs = opts.langs(buf, opts)+  end+  if type(opts.langs) ~= 'table' then+    opts.langs = { opts.langs }+  end+  opts.lints = vim.tbl_extend('keep', opts.lints or {}, {+    top_level_query = true,+    fields = true,+    nodes = true,+    syntax_error = true,+  })+  return opts+end++local lint_query = [[+  (program [(named_node) (list) (grouping)] @toplevel-query)+  (named_node+    name: _ @named_node)+  (anonymous_node+    name: _ @anonymous_node)+  (field_definition+    name: (identifier) @field)+  (ERROR) @error+]]",this is a actual query file in nvim-treesitter/playground thought it is merely just a private implementation: https://github.com/nvim-treesitter/playground/blob/master/queries/query/query-linter-queries.scm,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/22747,1148743323,2023-03-27T03:11:31Z,runtime/lua/vim/diagnostic.lua,"@@ -12,6 +12,9 @@ M.severity = {  vim.tbl_add_reverse_lookup(M.severity) +api.nvim_set_hl(0, 'DiagnosticDeprecated', { link = '@lsp.mod.deprecated', default = true })",Can we instead link to a generic `Deprecated` highlight group so that `vim.diagnostic` remains completely ignorant of LSP/semantic tokens? That highlight group could in turn link to `@lsp.mod.deprecated` (or vice versa).,
6927259,mliszcz,https://api.github.com/repos/neovim/neovim/pulls/22741,1149286922,2023-03-27T13:59:00Z,src/nvim/api/options.c,"@@ -309,15 +309,55 @@ Dictionary nvim_get_all_options_info(Error *err) ///     - commalist: List of comma separated values ///     - flaglist: List of single char flags ///+/// The last set information applies to the local value in the current buffer+/// or window if it is available, otherwise the global value information is+/// returned. /// /// @param          name Option name /// @param[out] err Error details, if any /// @return         Option Information Dictionary nvim_get_option_info(String name, Error *err)   FUNC_API_SINCE(7) {-  return get_vimoption(name, err);+  return get_vimoption(name, curbuf, curwin, err);","Since `nvim_get_option_info` is deprecated now, I changed it back to the old behavior - it always uses the global value.",
6927259,mliszcz,https://api.github.com/repos/neovim/neovim/pulls/22741,1149293308,2023-03-27T14:02:34Z,runtime/doc/api.txt,"@@ -1949,12 +1949,35 @@ nvim_get_option_info({name})                          *nvim_get_option_info()*     ��� commalist: List of comma separated values     ��� flaglist: List of single char flags +    The last set information applies to the local value in the current buffer+    or window if it is available, otherwise the global value information is+    returned.+     Parameters: ~       ��� {name}  Option name      Return: ~         Option Information +nvim_get_option_info_ex({name}, {*opts})           *nvim_get_option_info_ex()*+    Gets the option information for one option from arbitrary buffer or window++    This function is similar to nvim_get_option_info except that it accepts an+    additional options table {opts}, allowing to specify option scope, buffer+    number or window used for retrieving the last set location information.++    Parameters: ~+      ��� {name}  Option name+      ��� {opts}  Optional parameters+                ��� scope: One of ""global"" or ""local"". Analogous to |:setglobal|+                  and |:setlocal|, respectively.+                ��� win: |window-ID|. Used for getting window local options.+                ��� buf: Buffer number. Used for getting buffer local options.+                  Implies {scope} is ""local"".++    Return: ~+        Option Information",Done. I also moved `nvim_get_option_info` to `deprecated.c` and mentioned it in `deprecated.txt`.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22778,1149476058,2023-03-27T16:04:54Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","Well, looks like a fast path for `extmark_set`? Don't know if the performance is relevant, or if it's just kept for convenience (in which case it'd make sense to deprecate it in favor of a Lua API wrapper (which already exists in the form of `vim.highlight.range()`).In any case, I think `nvim_set_hl` is the stronger precedent here.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22778,1149536346,2023-03-27T16:48:22Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","Indeed; ignore my suggestion then.(Really, the proper thing to do would be to deprecate `nvim_buf_get_extmarks` and write a new one, which would use `opts` fields for optional filtering.)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22778,1149673832,2023-03-27T18:56:40Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","`nvim_buf_add_highlight` could just be deprecated already. `nvim_buf_add_highlight_electric_boogaloo` already exists, it is called `nvim_buf_set_extmark` (plus any language specific wrapper, as needed/wanted).",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22778,1149688271,2023-03-27T19:10:53Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","Honestly I don't really have one. Just thought it would be ""nice to have"" and not really cost us anything since `0` is unused anyway.I might make some debug tasks negligibly easier.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1150363243,2023-03-28T10:18:29Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces",One reason for adding a `0 -> anonymous namespaces` mapping is that one can already requests marks from a named namespace by inspecting `nvim_get_namespaces()`. If you then know that you're not interested in the marks set by the named namespaces you might want to inspect the anonymous namespaces. If we only have `-1 -> all namespaces` you would then have to filter out all the marks belonging to a named namespace yourself.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22778,1150377268,2023-03-28T10:31:14Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","It's very low cost to add and maintains some kind of consistency with `nvim_set_hl`.I think your argument is true though. You might loop over `nvim_buf_get_namespaces` and only conditionally look at some namespaces as you might specifically exclude some (e.g. foldsigns.nvim excludes gitsigns extmarks), but then you still might want to look at the anonymous marks.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22778,1150445357,2023-03-28T11:28:45Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","currently `nvim_buf_add_highlight` allocates `(((uint32_t)1) << 31) - 1` as the number for the anonymous namespace _singularis_ (the internal number can never be zero, because reasons). It will be fine with `nvim_buf_get_extmark` accessing that namespace individually with the same parameter value. ""anonymous namespaces"" in plural sounds like a red herring. That is something which might be done using some stuffed away helper function, if it is useful for debugging etc. ""namespaces group"" as a concept I don't belong in the API (at least not with just this single thing as a motivation)",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1150463203,2023-03-28T11:42:42Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","Yeah the red herring exists because those namespaces were not really accessible until now except by the caller. I think it's fine to leave ""anonymous namespaces"" out of the `nvim_buf_get_extmark` API. Simply getting all marks through `-1` is enough here. Perhaps there should be a `nvim_get_namespace_ids()` that maps from id to name instead so that it can list unnamed namespaces as well?",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1150481414,2023-03-28T11:56:00Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","Yeah why do we have unnamed namespaces in the first place? But since we do, I think the `get_namespaces` API should have mapped from id -> name such that it could actually list all the namespaces.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22778,1150499434,2023-03-28T12:09:06Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","> How come? The namespaces do exist, they just have no name and thus not returned by nvim_get_namespaces. It's useful to be able to segment these from marks in named namespaces.Again: the concept of **the group of all anonymous namespaces** is not a core concept. Nowhere in `nvim_create_namespace` is it mentioned that all namespaces created with an empty string is somehow to be collated together.> How would one handle the above use case of needing to filter out specific namespaces? Simply getting all the marks isn't ideal.Getting **all anonymous namespaces** will already group together namespaces from **unrelated plugins**. Simply getting all namespaces in not a big jump from that conceptually. You will need to do similar work in post-processing to understand what is going on.A general discussion about negative filtering is one that could be had (which that can filter out more meaningful patterns as well) . but I would rather like that be broken out to a separate issue. The singular anonymous namespace already handles the case for API completeness and compatibility with nvim_buf_add_highlight, which is all that is needed for this PR. (by itself a concept that should be deprecated, but it is a per-existing concept and thus needs to be supported) > Perhaps there should be a nvim_get_namespace_ids() that maps from id to name instead so that it can list unnamed namespaces as well?Yep, an issue with another API function should be solved separately, not cluttering the API of this one.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1150537703,2023-03-28T12:34:41Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","> github loading of comments seems to be broken, I always see more messages than the one I responded to after the fact...Yeah same here.> This was meant to be a direct response to the discussion about namespaces, not anything about types.> A general discussion about negative filtering is one that could be had (which that can filter out more meaningful patterns as well) . but I would rather like that be broken out to a separate issue. Alright I thought the above pertained to the filtering by extmark type, which I do think warrants some discussion/feedback. I.e. I only later realized that `number/line/cursorline_hl_group` are the counterparts of `:sign num/line/culhl`. I grouped them under `""highlight""` extmarks. I think the fact that these are part of the legacy sign API is irrelevant for extmarks?",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22778,1150586015,2023-03-28T13:09:15Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","> Getting all anonymous namespaces will already group together namespaces from unrelated plugins. Simply getting all namespaces in not a big jump from that conceptually. You will need to do similar work in post-processing to understand what is going on.With the described usecase, that's exactly what's wanted. Named namespaces will have already been processed.We don't want to then fetch them all again (creating potentially hundreds of Lua tables), especially when this code is done in on_line events.> A general discussion about negative filtering is one that could be had (which that can filter out more meaningful patterns as well) . but I would rather like that be broken out to a separate issue. The singular anonymous namespace already handles the case for API completeness and compatibility with nvim_buf_add_highlight, which is all that is needed for this PR. (by itself a concept that should be deprecated, but it is a per-existing concept and thus needs to be supported)Well such discussion could have an impact on the design of this API, so it is relevant to discuss here. Also, the PR also introduces a filter option which makes such discussion even more relevant.I think we want something more general than negative filtering. We want access to all marks that isn't just ""all or single ns"".  It seems the best solution is replacing `nvim_get_namespaces` with something that actually returns the anonymous namespaces so one can do:```luafor ns, name in pairs(vim.api.nvim_get_namespaces2) do  -- anonymous: name == ''  ...  for _, mark in ipairs(vim.api.nvim_get_extmarks(buf, ns, ...) do    ...  endend  ```",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1150619122,2023-03-28T13:31:48Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces",I agree that it is unfortunate that `nvim_get_namespaces` doesn't return the unnamed ones but what would `nvim_get_namespaces2` actually allow you to do/avoid to do that you can't do with a list of all extmarks (`ns_id == -1` here)? A namespace id -> name mapping is useless in and of itself without actually inspecting the marks within it right?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22778,1150645145,2023-03-28T13:48:43Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","> With the described usecase, that's exactly what's wanted. Named namespaces will have already been processed.We don't want to then fetch them all again (creating potentially hundreds of Lua tables), especially when this code is done in on_line events.Sure, the idea was we either fetch all namespaces at once (which sounded like what your plugin wanted, as you do after all process all marks, but doesn't work for some reason, which is fine), or all namespaces individually, even the unnamed ones in the latter case (which is why I already agreed to nvim_get_namespaces is incomplete).Currently all valid namespaces (except for the singular anonymous one) form a continuous range of id numbers. But I don't think we ever document this as a stable guarantee, so either we need to do so (strongly), or introduce this new function which returns all valid id:s.",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22784,1150697758,2023-03-28T14:17:06Z,runtime/lua/vim/treesitter/query_linter.lua,"@@ -0,0 +1,146 @@+local namespace = vim.api.nvim_create_namespace('vim.treesitter.query_linter')+-- those node names exist for every language+local MAGIC_NODE_NAMES = { '_', 'ERROR' }",YES_WE_DO:https://github.com/neovim/neovim/blob/bad218cd6413dd60a1ed9907f882fbf2e92515f1/runtime/lua/man.lua#L3 https://github.com/neovim/neovim/blob/bad218cd6413dd60a1ed9907f882fbf2e92515f1/runtime/lua/vim/uri.lua#L22https://github.com/neovim/neovim/blob/bad218cd6413dd60a1ed9907f882fbf2e92515f1/runtime/lua/vim/uri.lua#L80https://github.com/neovim/neovim/blob/bad218cd6413dd60a1ed9907f882fbf2e92515f1/runtime/lua/vim/health.lua#L46https://github.com/neovim/neovim/blob/bad218cd6413dd60a1ed9907f882fbf2e92515f1/runtime/lua/vim/treesitter/query.lua#L93https://github.com/neovim/neovim/blob/bad218cd6413dd60a1ed9907f882fbf2e92515f1/runtime/lua/vim/lsp/diagnostic.lua#L14Or at least there is precedent.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22784,1150702863,2023-03-28T14:20:23Z,runtime/lua/vim/treesitter/query_linter.lua,"@@ -0,0 +1,146 @@+local namespace = vim.api.nvim_create_namespace('vim.treesitter.query_linter')+-- those node names exist for every language+local MAGIC_NODE_NAMES = { '_', 'ERROR' }++local M = {}+local lints = {}++local function show_lints(buf, lints)+  local diagnostics = vim.tbl_map(function(lint)+    return {+      lnum = lint.range[1],+      end_lnum = lint.range[3],+      col = lint.range[2],+      end_col = lint.range[4],+      severity = vim.diagnostic.ERROR,+      message = lint.message,+    }+  end, lints)+  vim.diagnostic.set(namespace, buf, diagnostics)+end++local function add_lint_for_node(node, buf, error_type, complete_message)+  local node_text = vim.treesitter.get_node_text(node, buf):gsub('\n', ' ')+  local error_text = complete_message or error_type .. ': ' .. node_text+  local error_range = { node:range() }+  table.insert(+    lints[buf],+    { type = error_type, range = error_range, message = error_text, node_text = node_text }+  )+end++local function table_contains(predicate, table)",this file uses both this and `vim.tbl_contains`. This is a dynamic version with a function predicate instead of a value. Semantics is the same (but I should swap parameters),
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22784,1150709091,2023-03-28T14:24:40Z,runtime/lua/vim/treesitter/query_linter.lua,"@@ -0,0 +1,146 @@+local namespace = vim.api.nvim_create_namespace('vim.treesitter.query_linter')+-- those node names exist for every language+local MAGIC_NODE_NAMES = { '_', 'ERROR' }++local M = {}+local lints = {}++local function show_lints(buf, lints)+  local diagnostics = vim.tbl_map(function(lint)+    return {+      lnum = lint.range[1],+      end_lnum = lint.range[3],+      col = lint.range[2],+      end_col = lint.range[4],+      severity = vim.diagnostic.ERROR,+      message = lint.message,+    }+  end, lints)+  vim.diagnostic.set(namespace, buf, diagnostics)+end++local function add_lint_for_node(node, buf, error_type, complete_message)+  local node_text = vim.treesitter.get_node_text(node, buf):gsub('\n', ' ')+  local error_text = complete_message or error_type .. ': ' .. node_text+  local error_range = { node:range() }+  table.insert(+    lints[buf],+    { type = error_type, range = error_range, message = error_text, node_text = node_text }+  )+end++local function table_contains(predicate, table)",Would it make sense to extend `vim.tbl_contains` to also accept a predicate? (similar to `vim.tbl_filter`),
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1150835118,2023-03-28T15:51:55Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces","> Currently all valid namespaces (except for the singular anonymous one) form a continuous range of id numbers.Right, then I guess a `ns_id -> name get_namespaces2()` could simply be replaced by a while loop:```lualocal nsmap = {}for k, v in pairs(vim.api.nvim_get_namespaces()) do  nsmap[v] = kendlocal ns = 1while true do  local ignore  if nsmap[ns] then -- named namespace    ignore = nsmap[ns]:find(""ignorepattern"")  else -- unnamed namespace    ignore = false  end  if not ignore then    local ok, marks = pcall(vim.api.nvim_buf_get_extmarks, 0, ns, 0, -1, {})    if not ok then -- ns > next_namespace_id      break    end    vim.print(marks, nsmap[ns] or '""""')  end  ns = ns + 1end```",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1151263377,2023-03-28T23:53:00Z,src/nvim/api/extmark.c,"@@ -63,6 +64,7 @@ Integer nvim_create_namespace(String name)   if (name.size > 0) {     String name_alloc = copy_string(name, NULL);     map_put(String, handle_T)(&namespace_ids, name_alloc, id);+    map_put(handle_T, String)(&namespaces, id, name_alloc);",Would `realloc`ating a `String *namespaces` array be preferred over adding a new hash table+type (since the id's could simply be used as the array index)?EDIT: The same holds for the augroup maps though which is where I copied this pattern from. I wrongly assumed the augroup id's might not have been contiguous > 1 when I wrote this comment. The question stands for both namespace and augroup id -> name maps then I guess.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1151283635,2023-03-29T00:40:16Z,runtime/doc/api.txt,"@@ -2563,7 +2563,8 @@ nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})      Parameters: ~       ��� {buffer}  Buffer handle, or 0 for current buffer-      ��� {ns_id}   Namespace id from |nvim_create_namespace()|+      ��� {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all+                  namespaces",Not sure the above would actually be more efficient than getting all marks at once and filtering those though. `next_namespace_id` can get quite large.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/22798,1151327527,2023-03-29T02:25:42Z,src/nvim/mouse.c,"@@ -1259,6 +1259,11 @@ int jump_to_mouse(int flags, bool *inclusive, int which_button)       col -= curwin->w_grid.col_offset;     } +    if (col < 0 && curwin->w_leftcol > 0) {+      curwin->w_leftcol = MAX(0, curwin->w_leftcol + col);+      leftcol_changed();+    }+","I think the following change can also achieve the same purpose as this, but is more consistent as it also scrolls when dragging into the number column:```diffdiff --git a/src/nvim/mouse.c b/src/nvim/mouse.cindex 95fe4d70d..768611974 100644--- a/src/nvim/mouse.c+++ b/src/nvim/mouse.c@@ -1422,9 +1422,6 @@ bool mouse_comp_pos(win_T *win, int *rowp, int *colp, linenr_T *lnump)   if (!retval) {     // Compute the column without wrapping.     int off = win_col_off(win) - win_col_off2(win);-    if (col < off) {-      col = off;-    }     col += row * (win->w_width_inner - off);     // add skip column (for long wrapping line)     col += win->w_skipcol;```However this can also cause clicking on the number column to scroll the text, and `mouse_comp_pos()` is called in some other places where this may not make sense.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22784,1151582497,2023-03-29T08:35:42Z,runtime/lua/vim/treesitter/query_linter.lua,"@@ -0,0 +1,153 @@+local namespace = vim.api.nvim_create_namespace('vim.treesitter.query_linter')+-- those node names exist for every language+local BUILT_IN_NODE_NAMES = { '_', 'ERROR' }++local M = {}++---@private+--- Adds a diagnostic for node in the query buffer+local function add_lint_for_node(diagnostics, node, buf, lint, lang)+  local node_text = vim.treesitter.get_node_text(node, buf):gsub('\n', ' ')+  local message = lint .. ': ' .. node_text+  local error_range = { node:range() }+  table.insert(diagnostics, {+    lnum = error_range[1],+    end_lnum = error_range[3],+    col = error_range[2],+    end_col = error_range[4],+    severity = vim.diagnostic.ERROR,+    message = message,+    source = lang,+  })+end++---@private+--- like vim.tbl_contains but works with function predicate+local function table_contains(predicate, table)+  for _, elt in pairs(table) do+    if predicate(elt) then+      return true+    end+  end+  return false+end++---@private+--- Determines the target language of a query file by its path: <lang>/<query_type>.scm+local function guess_query_lang(buf, _)+  local filename = vim.api.nvim_buf_get_name(buf)+  if filename ~= '' then+    local ok, query_lang = pcall(vim.fn.fnamemodify, filename, ':p:h:t')+    return ok and query_lang+  end+end++---@private+local function normalize_opts(buf, opts)+  opts = opts or {}+  opts.langs = opts.langs or guess_query_lang+  if type(opts.langs) == 'function' then+    opts.langs = opts.langs(buf, opts)+  end+  if type(opts.langs) ~= 'table' then+    opts.langs = { opts.langs }+  end+  return opts+end++local lint_query = [[+  (program [(named_node) (list) (grouping)] @toplevel)+  (named_node+    name: _ @node.named)+  (anonymous_node+    name: _ @node.anonymous)+  (field_definition+    name: (identifier) @field)+  (ERROR) @error+]]++--- Determines diagnostics for a buffer containing tree-sitter queries (|treesitter-query|).+--- For runtime query files that target installed tree-sitter parsers, this function will use+--- tree-sitter API to determine admissible identifiers to describe nodes of those parsers and+--- verifies that top-level s-expressions can be loaded in isolation by Neovim to debug errors+--- in runtime query files. The found diagnostics are reported using |diagnostic-api|.+--- @param buf integer Buffer to lint+--- @param opts nil|table Options for linting+--- - langs nil|string|string[]|function One or more parsers which the current queries target (see+--        |treesitter-parsers) or a function that determines the list of parsers given `buf`,","```suggestion--        |treesitter-parsers|) or a function that determines the list of parsers given `buf`,```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22643,1152041556,2023-03-29T14:32:22Z,runtime/lua/vim/treesitter/language.lua,"@@ -6,8 +6,22 @@ local M = {} ---@type table<string,string> local ft_to_lang = {} ----@param filetype string----@return string|nil+--- Get the filetypes associated with {lang}.+--- @param lang string Name of parser+--- @return string[] filetypes+function M.get_filetypes(lang)","Can this be simplified with `vim.tbl_add_reverse_lookup`?(Or maybe just create a second reverse lookup table in `register ` -- now that the tables are no longer directly exposed, that should be safe?)",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22784,1152551888,2023-03-29T22:34:02Z,runtime/lua/vim/treesitter/query_linter.lua,"@@ -0,0 +1,153 @@+local namespace = vim.api.nvim_create_namespace('vim.treesitter.query_linter')+-- those node names exist for every language+local BUILT_IN_NODE_NAMES = { '_', 'ERROR' }++local M = {}++---@private+--- Adds a diagnostic for node in the query buffer+local function add_lint_for_node(diagnostics, node, buf, lint, lang)+  local node_text = vim.treesitter.get_node_text(node, buf):gsub('\n', ' ')+  local message = lint .. ': ' .. node_text+  local error_range = { node:range() }+  table.insert(diagnostics, {+    lnum = error_range[1],+    end_lnum = error_range[3],+    col = error_range[2],+    end_col = error_range[4],+    severity = vim.diagnostic.ERROR,+    message = message,+    source = lang,+  })+end++---@private+--- like vim.tbl_contains but works with function predicate+local function table_contains(predicate, table)+  for _, elt in pairs(table) do",duplicate of other thread,X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22813,1152611435,2023-03-30T00:17:06Z,src/nvim/autocmd.c,"@@ -2758,3 +2758,32 @@ void do_autocmd_focusgained(bool gained)    recursive = false; }++void do_filetype_autocmd(buf_T *buf, bool force)+{+  static bool recursive = false;++  if (recursive && !force) {+    return;  // disallow recursion+  }++  char **varp = &buf->b_p_ft;+  int secure_save = secure;++  // Reset the secure flag, since the value of 'filetype' has+  // been checked to be safe.+  secure = 0;++  recursive = true;+  did_filetype = true;+  // Only pass true for ""force"" when it is true or+  // used recursively, to avoid endless recurrence.+  apply_autocmds(EVENT_FILETYPE, buf->b_p_ft, buf->b_fname, force, buf);+  recursive = false;",Why? Shouldn't matter as long as it's after the autocmd call. It's set in the same place it was before with `ft_recursive`.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22784,1152888574,2023-03-30T08:05:54Z,runtime/lua/vim/treesitter/query_linter.lua,"@@ -0,0 +1,146 @@+local namespace = vim.api.nvim_create_namespace('vim.treesitter.query_linter')+-- those node names exist for every language+local MAGIC_NODE_NAMES = { '_', 'ERROR' }++local M = {}+local lints = {}++local function show_lints(buf, lints)+  local diagnostics = vim.tbl_map(function(lint)+    return {+      lnum = lint.range[1],+      end_lnum = lint.range[3],+      col = lint.range[2],+      end_col = lint.range[4],+      severity = vim.diagnostic.ERROR,+      message = lint.message,+    }+  end, lints)+  vim.diagnostic.set(namespace, buf, diagnostics)+end++local function add_lint_for_node(node, buf, error_type, complete_message)+  local node_text = vim.treesitter.get_node_text(node, buf):gsub('\n', ' ')+  local error_text = complete_message or error_type .. ': ' .. node_text+  local error_range = { node:range() }+  table.insert(+    lints[buf],+    { type = error_type, range = error_range, message = error_text, node_text = node_text }+  )+end++local function table_contains(predicate, table)",Maybe add a  `todo` comment for this function along the lines of https://github.com/neovim/neovim/pull/22784#discussion_r1150756969; this can be handled in a followup refactor PR where we can discuss the best approach. No need to hold up this PR with it.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22784,1153050972,2023-03-30T10:21:33Z,runtime/doc/treesitter.txt,"@@ -947,6 +947,31 @@ set({lang}, {query_name}, {text})                 *vim.treesitter.query.set()*       ��� {text}        (string) Query text (unparsed).  +==============================================================================+Lua module: vim.treesitter.query_linter          *lua-treesitter-query_linter*++clear({buf})                             *vim.treesitter.query_linter.clear()*+    Clears diagnostics of the query linter for a given buffer++    Parameters: ~+      ��� {buf}  integer Buffer to clear diagnostics++lint({buf}, {opts})                       *vim.treesitter.query_linter.lint()*+    Determines diagnostics for a buffer containing tree-sitter queries+    (|treesitter-query|). For runtime query files that target installed+    tree-sitter parsers, this function will use tree-sitter API to determine+    admissible identifiers to describe nodes of those parsers and verifies+    that top-level s-expressions can be loaded in isolation by Neovim to debug+    errors in runtime query files. The found diagnostics are reported using+    |diagnostic-api|.++    Parameters: ~+      ��� {buf}   integer Buffer to lint+      ��� {opts}  nil|table Options for linting+                ��� langs nil|string|string[]|function One or more parsers which","Main motivation was to have the default behavior to dynamically detect language from path somehow fit into the signature and let the user do similar things (also detect tree-sitte-<lang>, or set languages for emca) but we can leave that for latter. ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22747,1153077419,2023-03-30T10:47:05Z,runtime/lua/vim/diagnostic.lua,"@@ -12,6 +12,9 @@ M.severity = {  vim.tbl_add_reverse_lookup(M.severity) +api.nvim_set_hl(0, 'DiagnosticDeprecated', { link = '@lsp.mod.deprecated', default = true })","No��strong opinion either way; as long as the name stays, any later change to how it's set or what it defaults to will not be breaking, so I don't see a good reason to delay this.",
22454918,akinsho,https://api.github.com/repos/neovim/neovim/pulls/22835,1154262159,2023-03-31T09:41:22Z,runtime/lua/vim/diagnostic.lua,"@@ -753,7 +753,7 @@ end ---@field message string ---@field source nil|string ---@field code nil|string----@field _tags { deprecated: boolean, unnecessary: boolean}+---@field tags { deprecated: boolean, unnecessary: boolean}","@lewis6991 just to be clear rather than renaming things to `tags`, I should change references to `tags` to be `_tags`?",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22834,1154315883,2023-03-31T10:37:54Z,runtime/lua/vim/loader.lua,"@@ -41,6 +43,16 @@ local Loader = {   }, } +--- @param path string+--- @return CacheHash+--- @private+function Loader.get_hash(path)+  if not Loader._hashes[path] then+    Loader._hashes[path] = uv.fs_stat(path) --[[@as CacheHash]]","Just a remark here, that we should never cache hashes for non-existing files. So the code as is is good, since it will be `nil` and getting the hash again will always redo an `fs_stat`. We need to keep doing it this way, or otherwise lazy will not be able to bootstrap properly in some cases.TLDR: all good :)",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22834,1154317678,2023-03-31T10:39:56Z,runtime/lua/vim/loader.lua,"@@ -170,20 +192,6 @@ function Loader.loader_lib(modname)   return '\ncache_loader_lib: module ' .. modname .. ' not found' end ---- `loadfile` using the cache----@param filename? string----@param mode? ""b""|""t""|""bt""----@param env? table----@param hash? CacheHash----@return function?, string?  error_message----@private--- luacheck: ignore 312-function Loader.loadfile(filename, mode, env, hash)","LuaJIT does support the mode and env parameters. See https://luajit.org/extensions.htmlI'm actually using the `env` parameter in my personal configs to show virtual text where errors happened and with print statements when running a lua file.The `env` parameter is useful when you want to sandbox or override the globals object when loading a lua module.Removing this would break compatibility with LuaJIT, which is not something I think we want...",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22834,1154323199,2023-03-31T10:46:20Z,runtime/lua/vim/loader.lua,"@@ -337,14 +340,17 @@ function M.find(modname, opts)   return results end ---- Resets the topmods cache for the path, or all the paths+--- Resets the cache for the path, or all the paths --- if path is nil. ---@param path string? path to reset function M.reset(path)   if path then-    Loader._indexed[normalize(path)] = nil+    path = normalize(path)+    Loader._indexed[path] = nil+    Loader._hashes[path] = nil","This is not ideal, since `vim.loader.reset` expects a path on the rtp.It's pretty much impossible to know all the lua mdules that would need to be cleared this way.So either loop over all the hashes and clear those that start with the `path` parameter, or just always clear all hashes even when a `path` was given.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/22834,1154362544,2023-03-31T11:30:09Z,runtime/lua/vim/loader.lua,"@@ -141,7 +165,7 @@ end function Loader.loader(modname)   local ret = M.find(modname)[1]   if ret then-    local chunk, err = Loader.load(ret.modpath, { hash = ret.stat })+    local chunk, err = loadfile(ret.modpath)","ok, no big deal.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22778,1154738176,2023-03-31T17:41:24Z,src/nvim/api/extmark.c,"@@ -184,10 +190,45 @@ static Array extmark_to_array(const ExtmarkInfo *extmark, bool id, bool add_dict       PUT(dict, ""virt_lines_leftcol"", BOOLEAN_OBJ(virt_lines_leftcol));     } -    if (decor->hl_id || kv_size(decor->virt_text) || decor->ui_watched) {+    if (decor->sign_text) {+      PUT(dict, ""sign_text"", STRING_OBJ(cstr_to_string(decor->sign_text)));+    }++    // uncrustify:off++    struct { const char *name; const int val; } hls[] = {+      { ""sign_hl_group""      , decor->sign_hl_id       },+      { ""number_hl_group""    , decor->number_hl_id     },+      { ""line_hl_group""      , decor->line_hl_id       },+      { ""cursorline_hl_group"", decor->cursorline_hl_id },+      { NULL, 0 },+    };++    // uncrustify:on++    for (int j = 0; hls[j].name && hls[j].val; j++) {+      if (hls[j].val) {+        String name = cstr_to_string((const char *)syn_id2name(hls[j].val));","I don't mind either, we're discussing this because of @bfredl's original concern:> hl ids are already an exposed concept (and accepted when setting extmarks) , so just returning the hl_id without converting to string is fine.If @bfredl thinks this flag is useful I'm fine with adding it but if we rather just want to change the output of the details array unconditionally(and thus deprecate) I think we should postpone that and just go with the hl group names for now.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22843,1155034098,2023-04-01T01:22:48Z,src/nvim/drawscreen.c,"@@ -2681,6 +2681,11 @@ void status_redraw_buf(buf_T *buf)       redraw_later(wp, UPD_VALID);     }   }+  // Redraw the ruler if it is in the command line and was not marked for redraw above+  if (p_ru && one_nonfloat() && !curwin->w_status_height && !curwin->w_redr_status) {",I'm not sure these conditions are too exclusive or not exclusive enough for what's necessary but the issue here is that `redrawstatus` is responsible for redrawing the ruler but `status_redraw_buf()` only checks for the statusline.It also seems to me that the above statusline conditions should be kept in sync with `status_redraw_all()` and `redraw_buf_status_later()`. They are not identical currently.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22843,1155094592,2023-04-01T11:05:51Z,src/nvim/drawscreen.c,"@@ -2681,6 +2681,11 @@ void status_redraw_buf(buf_T *buf)       redraw_later(wp, UPD_VALID);     }   }+  // Redraw the ruler if it is in the command line and was not marked for redraw above+  if (p_ru && one_nonfloat() && !curwin->w_status_height && !curwin->w_redr_status) {","at least, `one_nonfloat()` should be removed from here. with laststatus=0 this could happen for a lower split window. `!curwin->w_status_height` is enough to check for this condition.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/22851,1155112822,2023-04-01T13:40:18Z,src/nvim/api/command.c,"@@ -1161,12 +1161,12 @@ void create_user_command(uint64_t channel_id, String name, Object command, Dict(   }    if (opts->complete.type == kObjectTypeLuaRef) {-    compl = EXPAND_USER_LUA;-    compl_luaref = api_new_luaref(opts->complete.data.luaref);+    comp = EXPAND_USER_LUA;+    comp_luaref = api_new_luaref(opts->complete.data.luaref);   } else if (opts->complete.type == kObjectTypeString) {     VALIDATE_S(OK == parse_compl_arg(opts->complete.data.string.data,-                                     (int)opts->complete.data.string.size, &compl, &argt,-                                     &compl_arg),+                                     (int)opts->complete.data.string.size, &comp, &argt,","```suggestion                                     (int)opts->complete.data.string.size, &context, &argt,```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/22851,1155112830,2023-04-01T13:40:26Z,src/nvim/api/command.c,"@@ -1204,19 +1204,19 @@ void create_user_command(uint64_t channel_id, String name, Object command, Dict(   }    WITH_SCRIPT_CONTEXT(channel_id, {-    if (uc_add_command(name.data, name.size, rep, argt, def, flags, compl, compl_arg, compl_luaref,+    if (uc_add_command(name.data, name.size, rep, argt, def, flags, comp, comp_arg, comp_luaref,","```suggestion    if (uc_add_command(name.data, name.size, rep, argt, def, flags, context, comp_arg, comp_luaref,```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22860,1155335441,2023-04-02T15:51:24Z,runtime/lua/vim/filetype.lua,"@@ -2626,6 +2626,12 @@ function M.match(args)         contents = M.getlines(bufnr)       end     end++    -- If there is only one big line, limit it to a reasonable upper bound","There can be more than one unreasonably long line, you know ;)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22871,1155856803,2023-04-03T11:51:28Z,runtime/lua/vim/filetype/detect.lua,"@@ -473,12 +473,12 @@ function M.fs(bufnr)   if vim.g.filetype_fs then     return vim.g.filetype_fs   end-  local line = nextnonblank(bufnr, 1)-  if findany(line, { '^%s*%.?%( ', '^%s*\\G? ', '^\\$', '^%s*: %S' }) then-    return 'forth'-  else-    return 'fsharp'+  for _, line in ipairs(getlines(bufnr, 1, 100)) do+    if matchregex(line, ""^[:(\\\\] "") then",@smjonas let me know if that can be turned into a Lua pattern.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/22871,1155960766,2023-04-03T13:25:09Z,runtime/lua/vim/filetype/detect.lua,"@@ -473,12 +473,12 @@ function M.fs(bufnr)   if vim.g.filetype_fs then     return vim.g.filetype_fs   end-  local line = nextnonblank(bufnr, 1)-  if findany(line, { '^%s*%.?%( ', '^%s*\\G? ', '^\\$', '^%s*: %S' }) then-    return 'forth'-  else-    return 'fsharp'+  for _, line in ipairs(getlines(bufnr, 1, 100)) do+    if matchregex(line, ""^[:(\\\\] "") then","Except that two backslashes also work in Lua, or only one backslash when using long brackets.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22876,1156918888,2023-04-04T08:37:12Z,runtime/lua/vim/treesitter/highlighter.lua,"@@ -236,7 +236,8 @@ local function on_line_impl(self, buf, line, is_spell_nav)         break       end -      local start_row, start_col, end_row, end_col = node:range()+      local range = metadata[capture] and metadata[capture].range or { node:range() }+      local start_row, start_col, end_row, end_col = unpack(range)","Better to use `vim.treesitter.get_range(node, bufnr, metadata)`",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/22883,1157514515,2023-04-04T16:44:25Z,runtime/doc/diagnostic.txt,"@@ -464,7 +464,10 @@ get({bufnr}, {opts})                                    *vim.diagnostic.get()*                  ��� namespace: (number) Limit diagnostics to the given                    namespace.                  ��� lnum: (number) Limit diagnostics to the given line number.+                 ��� col: (number) Limit diagnsotics to the given column number.                  ��� severity: See |diagnostic-severity|.+                 ��� original: (boolean) if true the diagnostic use lsp orignial+                   format.","I don't think we need this new field at all. There is already the `user_data` field, you can check if `user_data.lsp` exists.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/22859,1158278483,2023-04-05T09:40:15Z,src/nvim/api/vim.c,"@@ -2149,6 +2164,31 @@ Dictionary nvim_eval_statusline(String str, Dict(eval_statusline) *opts, Error *         fillchar = fillchar_status(&attr, wp);       }     }+    if (use_statuscol) {+      HlPriId line = { 0 };+      HlPriId cul  = { 0 };+      HlPriId num  = { 0 };+      linenr_T lnum = (linenr_T)get_vim_var_nr(VV_LNUM);+      int num_signs = buf_get_signattrs(wp->w_buffer, lnum, sattrs, &num, &line, &cul);+      decor_redraw_signs(wp->w_buffer, lnum - 1, &num_signs, sattrs, &num, &line, &cul);++      statuscol.sattrs = sattrs;+      statuscol.foldinfo = fold_info(wp, lnum);+      statuscol.use_cul = wp->w_p_cul && lnum == wp->w_cursorline+                          && (wp->w_p_culopt_flags & CULOPT_NBR);+      statuscol.sign_cul_id = statuscol.use_cul ? cul.hl_id : 0;+      if (num.hl_id) {+        statuscol.num_attr = num.hl_id;",Then it could be a separate `num_hl_id` field. we don't need to play attribute golf within a singleton struct.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22894,1158489163,2023-04-05T13:01:38Z,runtime/doc/lua.txt,"@@ -1738,6 +1738,33 @@ pesc({s})                                                         *vim.pesc()*     See also: ~       ��� https://github.com/rxi/lume +ringbuf({size})                                                *vim.ringbuf()*+    Create a ring buffer limited to a maximal number of items. Once the buffer+    is full, adding a new entry overrides the oldest entry.+>++    local ringbuf = vim.ringbuf(4)+    ringbuf.add(""a"")+    ringbuf.add(""b"")+    ringbuf.add(""c"")+    ringbuf.add(""d"")+    ringbuf.add(""e"")      -- overrides ""a""+    print(ringbuf.poll()) -- returns ""b""+    print(ringbuf.poll()) -- returns ""c""","Personally I would go the class based approach here, mostly because:- it's more conventional Lua -  makes it less opaque which is good for inspection/debugging.- creates less funcrefs```lua local ringbuf = vim.ringbuf(4) ringbuf:add(""a"") ringbuf:add(""b"") ringbuf:add(""c"") ringbuf:add(""d"") ringbuf:add(""e"")      -- overrides ""a"" print(ringbuf:poll()) -- returns ""b"" print(ringbuf:poll()) -- returns ""c""``````luafunction ringbuf:add(item)    self._items[self._idx_write] = item    self._idx_write = (self._idx_write + 1) % self._size    if self._idx_write == self._idx_read then      self._idx_read = (self._idx_read + 1) % self._size    end  end```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/22894,1158498978,2023-04-05T13:10:16Z,runtime/doc/lua.txt,"@@ -1738,6 +1738,33 @@ pesc({s})                                                         *vim.pesc()*     See also: ~       ��� https://github.com/rxi/lume +ringbuf({size})                                                *vim.ringbuf()*+    Create a ring buffer limited to a maximal number of items. Once the buffer+    is full, adding a new entry overrides the oldest entry.+>++    local ringbuf = vim.ringbuf(4)+    ringbuf.add(""a"")+    ringbuf.add(""b"")+    ringbuf.add(""c"")+    ringbuf.add(""d"")+    ringbuf.add(""e"")      -- overrides ""a""+    print(ringbuf.poll()) -- returns ""b""+    print(ringbuf.poll()) -- returns ""c""","That thought also crossed my mind. I had the impression that the function/closure pattern is currently more common in the codebase but I don't mind changing it.Depending on the outcome, maybe worth noting in https://github.com/neovim/neovim/issues/16810",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22894,1158507610,2023-04-05T13:17:23Z,runtime/doc/lua.txt,"@@ -1738,6 +1738,33 @@ pesc({s})                                                         *vim.pesc()*     See also: ~       ��� https://github.com/rxi/lume +ringbuf({size})                                                *vim.ringbuf()*+    Create a ring buffer limited to a maximal number of items. Once the buffer+    is full, adding a new entry overrides the oldest entry.+>++    local ringbuf = vim.ringbuf(4)+    ringbuf.add(""a"")+    ringbuf.add(""b"")+    ringbuf.add(""c"")+    ringbuf.add(""d"")+    ringbuf.add(""e"")      -- overrides ""a""+    print(ringbuf.poll()) -- returns ""b""+    print(ringbuf.poll()) -- returns ""c""",My impression is that we are using both depending on the context. Both libuv and ts bindings use the class style. Other ts classes use it too (langtree and highlighter). There are pros/cons to each.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22915,1160553668,2023-04-07T08:52:05Z,runtime/lua/vim/health.lua,"@@ -1,23 +1,48 @@ local M = {} +---@deprecated function M.report_start(msg)-  vim.fn['health#report_start'](msg)+  vim.deprecate('vim.health.report_start()', 'vim.health.start()', '0.10')+  vim.fn['health#start'](msg)",```suggestion  M.start(msg)```and similarly below,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22915,1160554022,2023-04-07T08:52:37Z,runtime/autoload/health.vim,"@@ -60,6 +60,11 @@ function! s:collect_output(output)   let s:output += split(a:output, ""\n"", 1) endfunction +"" Starts a new report.+function! health#start(name) abort+  call s:collect_output(printf(""\n%s ~"", a:name))+endfunction+ "" Starts a new report. function! health#report_start(name) abort","As these are already deprecated, we should not add new shims here; just add a deprecation message pointing to `v:lua.vim.health` -- and ideally just use that instead of the vimscript implementation, which can be removed?",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22784,1160837293,2023-04-07T17:04:28Z,runtime/ftplugin/query.lua,"@@ -2,5 +2,21 @@ -- Language:	Tree-sitter query -- Last Change:	2022 Mar 29 +if vim.b.did_ftplugin == 1 then+  return+end++local buf = vim.api.nvim_get_current_buf()+if vim.g.query_lint_on and #vim.g.query_lint_on > 0 then+  vim.api.nvim_create_autocmd(vim.g.query_lint_on or { 'BufWrite' }, {","```suggestion  vim.treesitter.start()  vim.api.nvim_create_autocmd(vim.g.query_lint_on or { 'BufWrite' }, {```If we spin up a parser, might as well use it for highlighting (since the default legacy lisp syntax highlighting is pretty much useless here).",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22784,1160842590,2023-04-07T17:14:31Z,runtime/lua/vim/treesitter/playground.lua,"@@ -270,6 +270,7 @@ function M.inspect_tree(opts)   vim.bo[b].buftype = 'nofile'   vim.bo[b].bufhidden = 'wipe'   vim.bo[b].filetype = 'query'+  vim.bo[b].query_lint_on = {} -- disable query linter","This won't work, since `query_lint_on` is a global variable(!)If we want to be able to disable the linting conditionally -- which we absolutely do, in this case, we need to have an additional buffer variable that can be checked in the autocommand before starting the linter.",
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/22969,1161315799,2023-04-09T17:15:32Z,cmake.deps/CMakeLists.txt,"@@ -12,12 +12,15 @@ list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"" ""${PROJECT_SOURCE_DI include(CheckCCompilerFlag) include(Util) +set(CMAKE_FIND_FRAMEWORK ""LAST"" CACHE STRING ""How find_* commands choose between macOS Frameworks and unix-style package components."")+ set(DEPS_CMAKE_ARGS   -D CMAKE_C_COMPILER=${CMAKE_C_COMPILER}   -D CMAKE_C_STANDARD=99   -D CMAKE_GENERATOR=${CMAKE_GENERATOR}   -D CMAKE_GENERATOR_PLATFORM=${CMAKE_GENERATOR_PLATFORM}-  -D CMAKE_POSITION_INDEPENDENT_CODE=ON)+  -D CMAKE_POSITION_INDEPENDENT_CODE=ON+  -D CMAKE_FIND_FRAMEWORK=${CMAKE_FIND_FRAMEWORK})",Just realised we need to keep this to make sure our setting of `CMAKE_FIND_FRAMEWORK` propagates to any dependent builds.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/22967,1161361024,2023-04-10T00:26:34Z,src/nvim/drawline.c,"@@ -2967,16 +2967,17 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange,         wlv.need_showbreak = true;       }       if (statuscol.draw) {-        if (wlv.row == startrow + wlv.filler_lines + 1-            || wlv.row == startrow + wlv.filler_lines) {-          // Re-evaluate 'statuscolumn' for the first wrapped row and non filler line-          statuscol.textp = NULL;-        } else if (statuscol.textp) {+        if (wlv.row == startrow + wlv.filler_lines) {+          statuscol.textp = NULL;  // re-evaluate for first non-filler line+        } else if (vim_strchr(p_cpo, CPO_NUMCOL) && wlv.row > startrow + wlv.filler_lines) {+          statuscol.draw = false;  // don't draw status column if ""n"" is in 'cpo'","But that would not even be possible, unless if we don't pad the statuscolumn with whitespace for wrapped lines and `cpo+=n`.Currently a shorter returned string would simply be padded to the maximum statuscolumn width, nullifying `cpo+=n`:https://github.com/neovim/neovim/blob/d52cc668c736ef6ca7ee3655a7eb7fe6475afadc/src/nvim/drawline.c#L684-L688",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22784,1161678099,2023-04-10T12:22:59Z,runtime/ftplugin/query.lua,"@@ -2,5 +2,29 @@ -- Language:	Tree-sitter query -- Last Change:	2022 Mar 29 +if vim.b.did_ftplugin == 1 then+  return+end++-- use treesitter over syntax+vim.treesitter.start()++-- query linter+local buf = vim.api.nvim_get_current_buf()+local query_lint_on = vim.b[buf].query_lint_on+  or vim.g.query_lint_on+  or { 'BufWrite', 'InsertLeave', 'TextChanged', 'BufEnter' }",Sorry to ask again. I didn't understand whether you referred to `BufEnter` or `TextChanged`. What should I set the list to?,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/22784,1163002024,2023-04-11T15:34:54Z,runtime/lua/vim/treesitter.lua,"@@ -506,6 +506,26 @@ function M.inspect_tree(opts)   require('vim.treesitter.playground').inspect_tree(opts) end +--- Determines diagnostics for a buffer containing treesitter queries (|treesitter-query|).+--- For runtime query files that target installed treesitter parsers, this function will use+--- treesitter API to determine admissible identifiers to describe nodes of those parsers and+--- verifies that top-level s-expressions can be loaded in isolation by Neovim to debug errors+--- in runtime query files. The found diagnostics are reported using |diagnostic-api|.+--- @param buf integer Buffer to lint+--- @param opts nil|table Options for linting+--- - langs nil|string|string[] One or more parsers which the current queries target (see |treesitter-parsers|)+---   or a function that determines the list of parsers given `buf`, `opts`. By default the query parser is determined+---   using the containing folder of the query buffer (`<lang>/<query_type>.scm`, e.g. `cpp` for `cpp/highlights.scm`)+function M.query_linter_lint(buf, opts)+  require('vim.treesitter._query_linter').lint(buf, opts)+end++--- Clears diagnostics of the query linter for a given buffer+--- @param buf integer Buffer to clear diagnostics+function M.query_linter_clear(buf)+  require('vim.treesitter._query_linter').clear(buf)+end","I suggest moving these to `vim/treesitter/query.lua` and renaming to `lint`. Does `clear` need to be a separate function? Why not a ""keyword argument"" in the `opts` table?```vim.treesitter.query.lint(buf, {})vim.treesitter.query.lint(buf, {clear = true})```",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/23007,1163009851,2023-04-11T15:41:33Z,runtime/lua/provider/node/health.lua,"@@ -0,0 +1,106 @@+local health = vim.health++local iswin = vim.loop.os_uname().sysname == 'Windows_NT'++local M = {}++function M.check()+  health.start('Node.js provider (optional)')++  if health.provider_disabled('node') then+    return+  end++  if+      not vim.fn.executable('node') == 1+      or (vim.fn.executable('npm') == 0 and vim.fn.executable('yarn') == 0 and vim.fn.executable('pnpm') == 0)+  then+    health.warn(+      '`node` and `npm` (or `yarn`, `pnpm`) must be in $PATH.',+      'Install Node.js and verify that `node` and `npm` (or `yarn`, `pnpm`) commands work.'+    )+    return+  end++  -- local node_v = vim.fn.split(system({'node', '-v'}), ""\n"")[1] or ''+  local ok, node_v = health.cmd_ok({ 'node', '-v' })+  health.info('Node.js: ' .. node_v)+  if not ok or vim.version.lt(node_v, '6.0.0') then+    health.warn('Nvim node.js host does not support Node ' .. node_v)+    -- Skip further checks, they are nonsense if nodejs is too old.+    return+  end+  if vim.fn['provider#node#can_inspect']() == 0 then+    health.warn(+      'node.js on this system does not support --inspect-brk so $NVIM_NODE_HOST_DEBUG is ignored.'+    )+  end++  local node_detect_table = vim.fn['provider#node#Detect']()+  local host = node_detect_table[1]+  if host:find('^%s*$') then+    health.warn('Missing ""neovim"" npm (or yarn, pnpm) package.', {+      'Run in shell: npm install -g neovim',+      'Run in shell (if you use yarn): yarn global add neovim',+      'Run in shell (if you use pnpm): pnpm install -g neovim',+      'You may disable this provider (and warning) by adding `let g:loaded_node_provider = 0` to your init.vim',+    })+    return+  end+  health.info('Nvim node.js host: ' .. host)++  local manager = 'npm'+  if vim.fn.executable('yarn') == 1 then+    manager = 'yarn'+  elseif vim.fn.executable('pnpm') == 1 then+    manager = 'pnpm'+  end++  local latest_npm_cmd = (+      iswin and 'cmd /c ' .. manager .. ' info neovim --json' or manager .. ' info neovim --json'+      )+  local ok, latest_npm = health.cmd_ok(vim.split(latest_npm_cmd, "" ""))+  if not ok or latest_npm:find('^%s$') then+    health.error(+      'Failed to run: ' .. latest_npm_cmd,+      { ""Make sure you're connected to the internet."", 'Are you behind a firewall or proxy?' }+    )+    return+  end++  local pcall_ok, output = pcall(vim.json.decode, latest_npm)+  local pkg_data+  if pcall_ok then+    pkg_data = output+  else+    return 'error: ' .. latest_npm+  end","I know I wrote this, but rereading it I think this can be simplified to```suggestion  local pcall_ok, pkg_data = pcall(vim.json.decode, latest_npm)  if not pcall_ok then    return 'error: ' .. latest_npm  end```",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/23007,1163066812,2023-04-11T16:28:06Z,runtime/lua/provider/python/health.lua,"@@ -0,0 +1,490 @@+local health = vim.health++local iswin = vim.loop.os_uname().sysname == 'Windows_NT'++local M = {}++local function is(path, ty)+  if not path then+    return false+  end+  local stat = vim.loop.fs_stat(path)+  if not stat then+    return false+  end+  return stat.type == ty+end++-- Resolves Python executable path by invoking and checking `sys.executable`.+local function python_exepath(invocation)+  local python = vim.fn.fnameescape(invocation)+  local out = vim.fn.system(python .. ' -c ""import sys; sys.stdout.write(sys.executable)""')+  assert(vim.v.shell_error == 0, out)+  return vim.fs.normalize(vim.trim(out))+end++local function is_blank(v)+  return v:find('^%s*$') ~= nil+end++-- Check if pyenv is available and a valid pyenv root can be found, then return+-- their respective paths. If either of those is invalid, return two empty+-- strings, effectively ignoring pyenv.+local function check_for_pyenv()+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))++  if is_blank(pyenv_path) then+    return { '', '' }+  end++  health.info('pyenv: Path: ' .. pyenv_path)++  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''++  if is_blank(pyenv_root) then+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')+  end++  if not is(pyenv_root, 'directory') then+    local message = string.format(+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',+      pyenv_root+    )+    health.warn(message)+    return { '', '' }+  end++  health.info('pyenv: Root: ' .. pyenv_root)++  return { pyenv_path, pyenv_root }+end++-- Check the Python interpreter's usability.+local function check_bin(bin)+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then+    health.error('""' .. bin .. '"" was not found.')+    return false+  elseif vim.fn.executable(bin) ~= 1 then+    health.error('""' .. bin .. '"" is not executable.')+    return false+  end+  return true+end++-- Fetch the contents of a URL.+local function download(url)+  local has_curl = vim.fn.executable('curl') == 1+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })+    if rc ~= 0 then+      return 'curl error with ' .. url .. ': ' .. rc+    else+      return out+    end+  elseif vim.fn.executable('python') == 1 then+    local script = ""try:\n\+          from urllib.request import urlopen\n\+          except ImportError:\n\+          from urllib2 import urlopen\n\+          response = urlopen('"" .. url .. ""')\n\+          print(response.read().decode('utf8'))\n""+    local out, rc = health.system({ 'python', '-c', script })+    if is_blank(out) and rc ~= 0 then+      return 'python urllib.request error: ' .. rc+    else+      return out+    end+  end++  local message = 'missing `curl` '++  if has_curl then+    message = message .. '(with HTTPS support) '+  end+  message = message .. 'and `python`, cannot make web request'++  return message+end+++-- Get the latest Nvim Python client (pynvim) version from PyPI.+local function latest_pypi_version()+  local pypi_version = 'unable to get pypi response'+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')+  if not is_blank(pypi_response) then+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)+    local pypi_data+    if pcall_ok then+      pypi_data = output+    else+      return 'error: ' .. pypi_response+    end",```suggestion    if not pcall_ok then      return 'error: ' .. pypi_response    end    local pypi_data = output```just a tiny nit,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/23007,1163110989,2023-04-11T17:10:50Z,runtime/lua/provider/python/health.lua,"@@ -0,0 +1,490 @@+local health = vim.health++local iswin = vim.loop.os_uname().sysname == 'Windows_NT'++local M = {}++local function is(path, ty)+  if not path then+    return false+  end+  local stat = vim.loop.fs_stat(path)+  if not stat then+    return false+  end+  return stat.type == ty+end++-- Resolves Python executable path by invoking and checking `sys.executable`.+local function python_exepath(invocation)+  local python = vim.fn.fnameescape(invocation)+  local out = vim.fn.system(python .. ' -c ""import sys; sys.stdout.write(sys.executable)""')+  assert(vim.v.shell_error == 0, out)+  return vim.fs.normalize(vim.trim(out))+end++local function is_blank(v)+  return v:find('^%s*$') ~= nil+end++-- Check if pyenv is available and a valid pyenv root can be found, then return+-- their respective paths. If either of those is invalid, return two empty+-- strings, effectively ignoring pyenv.+local function check_for_pyenv()+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))++  if is_blank(pyenv_path) then+    return { '', '' }+  end++  health.info('pyenv: Path: ' .. pyenv_path)++  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''++  if is_blank(pyenv_root) then+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')+  end++  if not is(pyenv_root, 'directory') then+    local message = string.format(+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',+      pyenv_root+    )+    health.warn(message)+    return { '', '' }+  end++  health.info('pyenv: Root: ' .. pyenv_root)++  return { pyenv_path, pyenv_root }+end++-- Check the Python interpreter's usability.+local function check_bin(bin)+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then+    health.error('""' .. bin .. '"" was not found.')+    return false+  elseif vim.fn.executable(bin) ~= 1 then+    health.error('""' .. bin .. '"" is not executable.')+    return false+  end+  return true+end++-- Fetch the contents of a URL.+local function download(url)+  local has_curl = vim.fn.executable('curl') == 1+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })+    if rc ~= 0 then+      return 'curl error with ' .. url .. ': ' .. rc+    else+      return out+    end+  elseif vim.fn.executable('python') == 1 then+    local script = ""try:\n\+          from urllib.request import urlopen\n\+          except ImportError:\n\+          from urllib2 import urlopen\n\+          response = urlopen('"" .. url .. ""')\n\+          print(response.read().decode('utf8'))\n""+    local out, rc = health.system({ 'python', '-c', script })+    if is_blank(out) and rc ~= 0 then+      return 'python urllib.request error: ' .. rc+    else+      return out+    end+  end++  local message = 'missing `curl` '++  if has_curl then+    message = message .. '(with HTTPS support) '+  end+  message = message .. 'and `python`, cannot make web request'++  return message+end+++-- Get the latest Nvim Python client (pynvim) version from PyPI.+local function latest_pypi_version()+  local pypi_version = 'unable to get pypi response'+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')+  if not is_blank(pypi_response) then+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)+    local pypi_data+    if pcall_ok then+      pypi_data = output+    else+      return 'error: ' .. pypi_response+    end++    local pypi_element = pypi_data['info'] or {}+    pypi_version = pypi_element['version'] or 'unable to parse'+  end+  return pypi_version+end++local function is_bad_response(s)+  local lower = s:lower()+  return vim.startswith(lower, 'unable')+      or vim.startswith(lower, 'error')+      or vim.startswith(lower, 'outdated')+end+++-- Get version information using the specified interpreter.  The interpreter is+-- used directly in case breaking changes were introduced since the last time+-- Nvim's Python client was updated.+--+-- Returns: {+--     {python executable version},+--     {current nvim version},+--     {current pypi nvim status},+--     {installed version status}+-- }+local function version_info(python)+  local pypi_version = latest_pypi_version()++  local python_version, rc = health.system({+    python,+    '-c',+    'import sys; print(""."".join(str(x) for x in sys.version_info[:3]))',+  })++  if rc ~= 0 or is_blank(python_version) then+    python_version = 'unable to parse ' .. python .. ' response'+  end++  local nvim_path, rc = health.system({+    python,+    '-c',+    'import sys; sys.path = [p for p in sys.path if p != """"]; import neovim; print(neovim.__file__)',+  })+  if rc ~= 0 or is_blank(nvim_path) then+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }+  end++  -- Assuming that multiple versions of a package are installed, sort them+  -- numerically in descending order.+  local function compare(metapath1, metapath2)+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\+]])+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\+]])+    if a == b then+      return 0+    elseif a > b then+      return 1+    else+      return -1+    end+  end++  -- Try to get neovim.VERSION (added in 0.1.11dev).+  local nvim_version, rc = health.system({+    python,+    '-c',+    'from neovim import VERSION as v; print(""{}.{}.{}{}"".format(v.major, v.minor, v.patch, v.prerelease))',+  }, { stderr = true, ignore_error = true })+  if rc ~= 0 or is_blank(nvim_version) then+    nvim_version = 'unable to find pynvim module version'+    local base = vim.fs.basename(nvim_path)+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))+    metas = table.sort(metas, compare)++    if metas and next(metas) ~= nil then+      for line in io.lines(metas[1]) do+        local version = line:match('^Version: (%S+)')+        if version then+          nvim_version = version+          break+        end+      end+    end+  end++  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])+  local version_status = 'unknown; ' .. nvim_path_base+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then+    if vim.version.lt(nvim_version, pypi_version) then+      version_status = 'outdated; from ' .. nvim_path_base+    else+      version_status = 'up to date'+    end+  end++  return { python_version, nvim_version, pypi_version, version_status }+end++function M.check()+  health.start('Python 3 provider (optional)')++  local pyname = 'python3'+  local python_exe = ''+  local virtual_env = os.getenv('VIRTUAL_ENV')+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''+  local host_prog_var = pyname .. '_host_prog'+  local python_multiple = {}++  if health.provider_disabled(pyname) then+    return+  end++  local pyenv_table = check_for_pyenv()+  local pyenv = pyenv_table[1]+  local pyenv_root = pyenv_table[2]++  if vim.g[host_prog_var] then+    local message = string.format('Using: g:%s = ""%s""', host_prog_var, vim.g[host_prog_var])+    health.info(message)+  end++  local python_table = vim.fn['provider#pythonx#Detect'](3)+  pyname = python_table[1]+  local pythonx_warnings = python_table[2]++  if is_blank(pyname) then+    health.warn(+      'No Python executable found that can `import neovim`. '+      .. 'Using the first available executable for diagnostics.'+    )+  elseif vim.g[host_prog_var] then+    python_exe = pyname+  end++  -- No Python executable could `import neovim`, or host_prog_var was used.+  if not is_blank(pythonx_warnings) then+    health.warn(pythonx_warnings, {+      'See :help provider-python for more information.',+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',+    })+  elseif not is_blank(pyname) and is_blank(python_exe) then+    if not vim.g[host_prog_var] then+      local message = string.format(+        '`g:%s` is not set. Searching for %s in the environment.',+        host_prog_var,+        pyname+      )+      health.info(message)+    end++    if not is_blank(pyenv) then+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })+      if is_blank(python_exe) then+        health.warn('pyenv could not find ' .. pyname .. '.')+      end+    end++    if is_blank(python_exe) then+      python_exe = vim.fn.exepath(pyname)++      if os.getenv('PATH') then+        local path_sep = iswin and ';' or ':'+        local paths = vim.split(os.getenv('PATH') or '', path_sep)++        for _, path in ipairs(paths) do+          local path_bin = vim.fs.normalize(path .. '/' .. pyname)+          if+              path_bin ~= vim.fs.normalize(python_exe)+              and vim.tbl_contains(python_multiple, path_bin)+              and vim.fn.executable(path_bin) == 1+          then+            python_multiple[#python_multiple + 1] = path_bin+          end+        end++        if vim.tbl_count(python_multiple) > 0 then+          -- This is worth noting since the user may install something+          -- that changes $PATH, like homebrew.+          local message = string.format('Multiple %s executables found. Set `g:%s` to avoid surprises.', pyname,+            host_prog_var)+          health.info(message)+        end++        if python_exe:find('shims') then","Original pattern was `\<shims\>`, which matches at word boundaries.I dunno much about python, so idk if ignoring it makes any difference :shrug: ",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23040,1164034750,2023-04-12T12:03:58Z,runtime/doc/lua.txt,"@@ -1797,16 +1810,31 @@ tbl_add_reverse_lookup({o})                     *vim.tbl_add_reverse_lookup()*     Return: ~         (table) o -tbl_contains({t}, {value})                                *vim.tbl_contains()*-    Checks if a list-like (vector) table contains `value`.+tbl_contains({t}, {value}, {opts})                        *vim.tbl_contains()*+    Checks if a table contains a given key, specified either directly or via a+    predicate that is checked for each key.++    Example: >lua++      vim.tbl_contains({ 'a', { 'b', 'c' } }, function(v)+        return vim.deep_equal(v, { 'b', 'c' })+      end, { predicate = true })+      -- true+<      Parameters: ~       ��� {t}      (table) Table to check-      ��� {value}  any Value to compare+      ��� {value}  any Value to compare or predicate function reference+      ��� {opts}   (table|nil) Keyword arguments |kwargs|:+                 ��� predicate: (boolean) `value` is a function reference to be+                   checked (default false)      Return: ~         (boolean) `true` if `t` contains `value` +    See also: ~+      ��� |vim.list_contains()| for checking keys in list-like tables",```suggestion      ��� |vim.list_contains()| for checking values in list-like tables```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23040,1164035136,2023-04-12T12:04:13Z,runtime/doc/news.txt,"@@ -30,15 +30,17 @@ CHANGED FEATURES                                                 *news-changed*  The following changes to existing APIs or features add new behavior. +��� |vim.tbl_contains()| now works for general tables and allows specifying a+  predicate function that is checked for each key. (Use |vim.list_contains()|",```suggestion  predicate function that is checked for each values. (Use |vim.list_contains()|```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23040,1164035502,2023-04-12T12:04:26Z,runtime/doc/news.txt,"@@ -30,15 +30,17 @@ CHANGED FEATURES                                                 *news-changed*  The following changes to existing APIs or features add new behavior. +��� |vim.tbl_contains()| now works for general tables and allows specifying a+  predicate function that is checked for each key. (Use |vim.list_contains()|+  for checking list-like tables (integer keys without gaps) for literal keys.)",```suggestion  for checking list-like tables (integer keys without gaps) for literal values.)```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23040,1164036017,2023-04-12T12:04:50Z,runtime/lua/vim/shared.lua,"@@ -252,12 +252,53 @@ function vim.tbl_filter(func, t)   return rettab end ---- Checks if a list-like (vector) table contains `value`.+--- Checks if a table contains a given key, specified either directly or via+--- a predicate that is checked for each key.+---+--- Example:+--- <pre>lua+---  vim.tbl_contains({ 'a', { 'b', 'c' } }, function(v)+---    return vim.deep_equal(v, { 'b', 'c' })+---  end, { predicate = true })+---  -- true+--- </pre>+---+---@see |vim.list_contains()| for checking keys in list-like tables",```suggestion---@see |vim.list_contains()| for checking values in list-like tables```,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/22894,1164090288,2023-04-12T12:50:59Z,runtime/doc/lua.txt,"@@ -1738,6 +1738,33 @@ pesc({s})                                                         *vim.pesc()*     See also: ~       ��� https://github.com/rxi/lume +ringbuf({size})                                                *vim.ringbuf()*+    Create a ring buffer limited to a maximal number of items. Once the buffer+    is full, adding a new entry overrides the oldest entry.+>++    local ringbuf = vim.ringbuf(4)+    ringbuf.add(""a"")+    ringbuf.add(""b"")+    ringbuf.add(""c"")+    ringbuf.add(""d"")+    ringbuf.add(""e"")      -- overrides ""a""+    print(ringbuf.poll()) -- returns ""b""+    print(ringbuf.poll()) -- returns ""c""","Is there a way to convert this to class style while still keeping the lua-ls generic type parameter working?class generics are still very limited: https://github.com/LuaLS/lua-language-server/issues/1861I was trying something like:```lua---@class vim.Ringbuf<T>---@field private items T[]--- ...---@type vim.Ringbuf<T>local ringbuf = {  items = {},  idx_read = 0,  idx_write = 0,  size = size + 1,}return setmetatable(ringbuf, { __index = Ringbuf })```But the `T` in both `---@field private items T[]` and `---@type vim.Ringbuf<T>` is undefined",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22894,1164097559,2023-04-12T12:56:31Z,runtime/doc/lua.txt,"@@ -1738,6 +1738,33 @@ pesc({s})                                                         *vim.pesc()*     See also: ~       ��� https://github.com/rxi/lume +ringbuf({size})                                                *vim.ringbuf()*+    Create a ring buffer limited to a maximal number of items. Once the buffer+    is full, adding a new entry overrides the oldest entry.+>++    local ringbuf = vim.ringbuf(4)+    ringbuf.add(""a"")+    ringbuf.add(""b"")+    ringbuf.add(""c"")+    ringbuf.add(""d"")+    ringbuf.add(""e"")      -- overrides ""a""+    print(ringbuf.poll()) -- returns ""b""+    print(ringbuf.poll()) -- returns ""c""",Generics in lua ls don't work properly atm. There's a big tracking issue for them.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23029,1164143302,2023-04-12T13:32:29Z,runtime/lua/vim/Iter.lua,"@@ -0,0 +1,332 @@+--- Iterator implementation.++---@class Iter+---@field fn function+---@field head ?number+---@field tail ?number+local Iter = {}++Iter.__index = Iter++Iter.__call = function(self)+  return self:next()+end++--- Add a filter/map step to the iterator.+---+--- Example:+--- <pre>+--- > local it = vim.iter({ 1, 2, 3, 4 }):filter_map(function(i, v)+--- >   if v % 2 == 0 then+--- >     return i, v * 3+--- >   end+--- > end)+--- > it:collect()+--- { 6, 12 }+--- </pre>+---+---@param f function(...):any Mapping function. Takes all values returned from the previous stage+---                            in the pipeline as arguments and returns a new value. Nil values+---                            returned from `f` are filtered from the output.+---@return Iter+function Iter.filter_map(self, f)","That is how I did it originally. Some languages like Rust and OCaml have `filter`, `map`, and `filter_map`, but those languages are allowed to have `None` values within a list. In Lua, we cannot have `nil` values in the middle of a table, so any `nil` value returned by `map` would have to be filtered out (returning `nil` is the signal that the iterator is empty). With that constraint, `map` already becomes `filter_map`.I then combined `filter` and `filter_map` to reduce the API surface area, but we could add it back if it's useful. But note that `:filter(predicate)` is just `:filter_map(function(...) if predicate(...) return ... end)`. Useful to reduce boilerplate, but it doesn't add anything unique.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23029,1165999001,2023-04-13T20:34:00Z,runtime/doc/lua.txt,"@@ -2773,4 +2808,367 @@ range({spec})                                            *vim.version.range()*     See also: ~       ��� # https://github.com/npm/node-semver#ranges ++==============================================================================+Lua module: iter                                                    *lua-iter*++Iter:all({self}, {pred})                                          *Iter:all()*+    Return true if all of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:any({self}, {pred})                                          *Iter:any()*+    Return true if any of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:collect({self}, {opts})                                  *Iter:collect()*+    Drain the iterator into a table.++    The final stage in the iterator pipeline must return 1 or 2 values. If+    only one value is returned, or if two values are returned and the first+    value is a number, an ""array-like"" table is returned. Otherwise, the first+    return value is used as the table key and the second return value as the+    table value.++    Example: >lua++     local it1 = vim.iter(string.gmatch('100 20 50', 'd+')):filter_map(tonumber)+     it1:collect()+     -- { 100, 20, 50 }++     local it2 = vim.iter(string.gmatch('100 20 50', 'd+')):filter_map(tonumber)+     it2:collect({ sort = true })+     -- { 20, 50, 100 }+<++    Parameters: ~+      ��� {opts}  ?table Optional arguments:+                ��� sort (boolean|function): If true, sort the resulting table+                  before returning. If a function is provided, that function+                  is used as the comparator function to |table.sort()|.++    Return: ~+        (table)++Iter:enumerate({self})                                      *Iter:enumerate()*+    Add an iterator stage that returns the current iterator count as well as+    the iterator value.++    Example: >lua++     local it = vim.iter(vim.gsplit('abc', '')):enumerate()+     it:next()+     -- 1   'a'+     it:next()+     -- 2   'b'+     it:next()+     -- 3   'c'+<++    Return: ~+        Iter++Iter:filter({self}, {f})                                       *Iter:filter()*+    Add a filter step to the iterator pipeline.++    Example: >lua++     local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)+<++    Parameters: ~+      ��� {f}  function(...):bool Takes all values returned from the previous+             stage in the pipeline and returns false or nil if the current+             iterator element should be removed.++    Return: ~+        Iter++Iter:filter_map({self}, {f})                               *Iter:filter_map()*+    Add a filter/map step to the iterator pipeline.++    Example: >lua++     local it = vim.iter({ 1, 2, 3, 4 }):filter_map(function(v)+       if v % 2 == 0 then+         return v * 3+       end+     end)+     it:collect()+     -- { 6, 12 }+<++    Parameters: ~+      ��� {f}  function(...):any Mapping function. Takes all values returned+             from the previous stage in the pipeline as arguments and returns+             one or more new values, which are used in the next pipeline+             stage. Nil return values returned are filtered from the output.++    Return: ~+        Iter++Iter:find({self}, {f})                                           *Iter:find()*+    Find the first value in the iterator that satisfies the given predicate.++    Advances the iterator. Returns nil and drains the iterator if no value is+    found.++    Examples: >lua++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(12)+     -- 12++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(20)+     -- nil++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(function(v) return v % 4 == 0 end)+     -- 12+<++    Return: ~+        any++Iter:foreach({self}, {f})                                     *Iter:foreach()*","We should be consistent either way though, so either all functions should use `singleword` style or all should use `snake_case` style. I changed everything to use `singleword` style in 8a93df0cf9f6210f3c0a1ad506b936c9b9ff0316 as that is ""more Lua"", but if the Bikeshed Brigade comes to a consensus on `snake_case` I'll change them all back (I don't feel strongly about it either way, as long as we're consistent).",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23029,1166676531,2023-04-14T10:44:04Z,runtime/lua/vim/Iter.lua,"@@ -0,0 +1,332 @@+--- Iterator implementation.++---@class Iter+---@field fn function+---@field head ?number+---@field tail ?number+local Iter = {}++Iter.__index = Iter++Iter.__call = function(self)+  return self:next()+end++--- Add a filter/map step to the iterator.+---+--- Example:+--- <pre>+--- > local it = vim.iter({ 1, 2, 3, 4 }):filter_map(function(i, v)+--- >   if v % 2 == 0 then+--- >     return i, v * 3+--- >   end+--- > end)+--- > it:collect()+--- { 6, 12 }+--- </pre>+---+---@param f function(...):any Mapping function. Takes all values returned from the previous stage+---                            in the pipeline as arguments and returns a new value. Nil values+---                            returned from `f` are filtered from the output.+---@return Iter+function Iter.filter_map(self, f)","> In Lua, we cannot have nil values in the middle of a table,That's not strictly speaking correct; `{ 1, 2, nil, 4 }` is a perfectly valid table (and array); just not a valid list(-like table). ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23029,1166775545,2023-04-14T12:27:12Z,runtime/doc/lua.txt,"@@ -2773,4 +2808,367 @@ range({spec})                                            *vim.version.range()*     See also: ~       ��� # https://github.com/npm/node-semver#ranges ++==============================================================================+Lua module: iter                                                    *lua-iter*++Iter:all({self}, {pred})                                          *Iter:all()*+    Return true if all of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:any({self}, {pred})                                          *Iter:any()*+    Return true if any of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:collect({self}, {opts})                                  *Iter:collect()*+    Drain the iterator into a table.++    The final stage in the iterator pipeline must return 1 or 2 values. If+    only one value is returned, or if two values are returned and the first+    value is a number, an ""array-like"" table is returned. Otherwise, the first+    return value is used as the table key and the second return value as the+    table value.++    Example: >lua++     local it1 = vim.iter(string.gmatch('100 20 50', 'd+')):filter_map(tonumber)+     it1:collect()+     -- { 100, 20, 50 }++     local it2 = vim.iter(string.gmatch('100 20 50', 'd+')):filter_map(tonumber)+     it2:collect({ sort = true })+     -- { 20, 50, 100 }+<++    Parameters: ~+      ��� {opts}  ?table Optional arguments:+                ��� sort (boolean|function): If true, sort the resulting table+                  before returning. If a function is provided, that function+                  is used as the comparator function to |table.sort()|.++    Return: ~+        (table)++Iter:enumerate({self})                                      *Iter:enumerate()*+    Add an iterator stage that returns the current iterator count as well as+    the iterator value.++    Example: >lua++     local it = vim.iter(vim.gsplit('abc', '')):enumerate()+     it:next()+     -- 1   'a'+     it:next()+     -- 2   'b'+     it:next()+     -- 3   'c'+<++    Return: ~+        Iter++Iter:filter({self}, {f})                                       *Iter:filter()*+    Add a filter step to the iterator pipeline.++    Example: >lua++     local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)+<++    Parameters: ~+      ��� {f}  function(...):bool Takes all values returned from the previous+             stage in the pipeline and returns false or nil if the current+             iterator element should be removed.++    Return: ~+        Iter++Iter:filter_map({self}, {f})                               *Iter:filter_map()*+    Add a filter/map step to the iterator pipeline.++    Example: >lua++     local it = vim.iter({ 1, 2, 3, 4 }):filter_map(function(v)+       if v % 2 == 0 then+         return v * 3+       end+     end)+     it:collect()+     -- { 6, 12 }+<++    Parameters: ~+      ��� {f}  function(...):any Mapping function. Takes all values returned+             from the previous stage in the pipeline as arguments and returns+             one or more new values, which are used in the next pipeline+             stage. Nil return values returned are filtered from the output.++    Return: ~+        Iter++Iter:find({self}, {f})                                           *Iter:find()*+    Find the first value in the iterator that satisfies the given predicate.++    Advances the iterator. Returns nil and drains the iterator if no value is+    found.++    Examples: >lua++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(12)+     -- 12++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(20)+     -- nil++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(function(v) return v % 4 == 0 end)+     -- 12+<++    Return: ~+        any++Iter:foreach({self}, {f})                                     *Iter:foreach()*","My vote is for noodle case, for the following reason: we use snake case specifically for `verb_noun` idioms, and none of these functions have this ""complex syntax"" -- they're simple terms (like `foreach`, which is indeed a builtin keyword in some languages).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23029,1166805726,2023-04-14T12:58:29Z,runtime/doc/lua.txt,"@@ -2773,4 +2870,367 @@ range({spec})                                            *vim.version.range()*     See also: ~       ��� # https://github.com/npm/node-semver#ranges ++==============================================================================+Lua module: iter                                                    *lua-iter*++Iter:all({self}, {pred})                                          *Iter:all()*+    Return true if all of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:any({self}, {pred})                                          *Iter:any()*+    Return true if any of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:collect({self}, {opts})                                  *Iter:collect()*+    Drain the iterator into a table.++    The final stage in the iterator pipeline must return 1 or 2 values. If+    only one value is returned, or if two values are returned and the first+    value is a number, an ""array-like"" table is returned. Otherwise, the first+    return value is used as the table key and the second return value as the+    table value.++    Example: >lua++     local it1 = vim.iter(string.gmatch('100 20 50', 'd+')):filtermap(tonumber)+     it1:collect()+     -- { 100, 20, 50 }++     local it2 = vim.iter(string.gmatch('100 20 50', 'd+')):filtermap(tonumber)+     it2:collect({ sort = true })+     -- { 20, 50, 100 }+<++    Parameters: ~+      ��� {opts}  ?table Optional arguments:+                ��� sort (boolean|function): If true, sort the resulting table+                  before returning. If a function is provided, that function+                  is used as the comparator function to |table.sort()|.++    Return: ~+        (table)++Iter:enumerate({self})                                      *Iter:enumerate()*+    Add an iterator stage that returns the current iterator count as well as+    the iterator value.++    Example: >lua++     local it = vim.iter(vim.gsplit('abc', '')):enumerate()+     it:next()+     -- 1   'a'+     it:next()+     -- 2   'b'+     it:next()+     -- 3   'c'+<++    Return: ~+        Iter++Iter:filter({self}, {f})                                       *Iter:filter()*+    Add a filter step to the iterator pipeline.++    Example: >lua++     local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)+<++    Parameters: ~+      ��� {f}  function(...):bool Takes all values returned from the previous+             stage in the pipeline and returns false or nil if the current+             iterator element should be removed.++    Return: ~+        Iter++Iter:filtermap({self}, {f})                                 *Iter:filtermap()*+    Add a map and filter step to the iterator pipeline.++    Example: >lua++     local it = vim.iter({ 1, 2, 3, 4 }):filtermap(function(v)+       if v % 2 == 0 then+         return v * 3+       end+     end)+     it:collect()+     -- { 6, 12 }+<++    Parameters: ~+      ��� {f}  function(...):any Mapping function. Takes all values returned+             from the previous stage in the pipeline as arguments and returns+             one or more new values, which are used in the next pipeline+             stage. Nil return values returned are filtered from the output.++    Return: ~+        Iter++Iter:find({self}, {f})                                           *Iter:find()*+    Find the first value in the iterator that satisfies the given predicate.++    Advances the iterator. Returns nil and drains the iterator if no value is+    found.++    Examples: >lua++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(12)+     -- 12++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(20)+     -- nil++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(function(v) return v % 4 == 0 end)+     -- 12+<++    Return: ~+        any++Iter:foreach({self}, {f})                                     *Iter:foreach()*+    Call a function once for each item in the pipeline.++    This is used for functions which have side effects. To modify the values+    in the iterator, use |Iter:filtermap()|.++    This function drains the iterator.++    Parameters: ~+      ��� {f}  function(...) Function to execute for each item in the pipeline.+             Takes all of the values returned by the previous stage in the+             pipeline as arguments.++Iter:last({self})                                                *Iter:last()*+    Return the last item in the iterator.++    Drains the iterator.++    Example: >lua++     local it = vim.iter(vim.gsplit('abcdefg', ''))+     it:last()+     -- 'g'++     local it = vim.iter({ 3, 6, 9, 12, 15 })+     it:last()+     -- 15+<++    Return: ~+        any++Iter:next({self})                                                *Iter:next()*+    Return the next value from the iterator.++    Example: >lua++     local it = vim.iter(string.gmatch('1 2 3', 'd+')):filtermap(tonumber)+     it:next()+     -- 1+     it:next()+     -- 2+     it:next()+     -- 3+<++    Return: ~+        any++Iter:nextback({self})                                        *Iter:nextback()*","> On a related note, `revnext` (""reverse next"") or `endnext` might be better -- unless `nextback` is already an established term in iteratorland -- as ""back"" isn't used anywhere when talking about iterators here.""back"" is a standard term in at least [Rust](https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#tymethod.next_back) and [C++](https://en.cppreference.com/w/cpp/container/vector/back).> Alternatively, isn't that just `:rev():next()`? Do we need a separate function for this?No, it's not quite the same. `:rev()` will reverse the order of the table. One may want to remove a value from the end of the list without reversing the order of the list.",X
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22784,1166835491,2023-04-14T13:26:56Z,runtime/lua/vim/treesitter.lua,"@@ -506,6 +506,26 @@ function M.inspect_tree(opts)   require('vim.treesitter.playground').inspect_tree(opts) end +--- Determines diagnostics for a buffer containing treesitter queries (|treesitter-query|).+--- For runtime query files that target installed treesitter parsers, this function will use+--- treesitter API to determine admissible identifiers to describe nodes of those parsers and+--- verifies that top-level s-expressions can be loaded in isolation by Neovim to debug errors+--- in runtime query files. The found diagnostics are reported using |diagnostic-api|.+--- @param buf integer Buffer to lint+--- @param opts nil|table Options for linting+--- - langs nil|string|string[] One or more parsers which the current queries target (see |treesitter-parsers|)+---   or a function that determines the list of parsers given `buf`, `opts`. By default the query parser is determined+---   using the containing folder of the query buffer (`<lang>/<query_type>.scm`, e.g. `cpp` for `cpp/highlights.scm`)+function M.query_linter_lint(buf, opts)+  require('vim.treesitter._query_linter').lint(buf, opts)+end++--- Clears diagnostics of the query linter for a given buffer+--- @param buf integer Buffer to clear diagnostics+function M.query_linter_clear(buf)+  require('vim.treesitter._query_linter').clear(buf)+end","No, I think @gpanders suggestion is fine (we have a similar pattern for creating autocommand groups). If in doubt, keep it simple :)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23029,1167067295,2023-04-14T16:46:32Z,runtime/doc/lua.txt,"@@ -1653,6 +1670,51 @@ endswith({s}, {suffix})                                       *vim.endswith()*     Return: ~         (boolean) `true` if `suffix` is a suffix of `s` +filter({src}, {f})                                              *vim.filter()*","The existing functions have the arguments swapped: `tbl_map(fn, table)`. Is there a reason to change that pattern?I like trailing functions because of the syntax, but it's common to have the function first and the iterable second. Python:```class filter(object) |  filter(function or None, iterable) --> filter object |   |  Return an iterator yielding those items of iterable for which function(item) |  is true. If function is None, return the items that are true.```Haskell:```Data.List filter :: (a -> Bool) -> [a] -> [a]```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23029,1167076041,2023-04-14T16:54:30Z,runtime/doc/lua.txt,"@@ -2817,4 +2914,367 @@ range({spec})                                            *vim.version.range()*     See also: ~       ��� # https://github.com/npm/node-semver#ranges ++==============================================================================+Lua module: iter                                                    *lua-iter*++Iter:all({self}, {pred})                                          *Iter:all()*+    Return true if all of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:any({self}, {pred})                                          *Iter:any()*+    Return true if any of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:collect({self}, {opts})                                  *Iter:collect()*+    Drain the iterator into a table.++    The final stage in the iterator pipeline must return 1 or 2 values. If+    only one value is returned, or if two values are returned and the first+    value is a number, an ""array-like"" table is returned. Otherwise, the first+    return value is used as the table key and the second return value as the+    table value.++    Example: >lua++     local it1 = vim.iter(string.gmatch('100 20 50', 'd+')):filtermap(tonumber)+     it1:collect()+     -- { 100, 20, 50 }++     local it2 = vim.iter(string.gmatch('100 20 50', 'd+')):filtermap(tonumber)+     it2:collect({ sort = true })+     -- { 20, 50, 100 }+<++    Parameters: ~+      ��� {opts}  ?table Optional arguments:+                ��� sort (boolean|function): If true, sort the resulting table+                  before returning. If a function is provided, that function+                  is used as the comparator function to |table.sort()|.",Is this worth adding given that the resulting table can easily be passed to `table.sort()` ?Asking because it seems to diverge a bit from the overall pattern,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23029,1167212239,2023-04-14T19:31:33Z,runtime/doc/lua.txt,"@@ -2817,4 +2914,367 @@ range({spec})                                            *vim.version.range()*     See also: ~       ��� # https://github.com/npm/node-semver#ranges ++==============================================================================+Lua module: iter                                                    *lua-iter*++Iter:all({self}, {pred})                                          *Iter:all()*+    Return true if all of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:any({self}, {pred})                                          *Iter:any()*+    Return true if any of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:collect({self}, {opts})                                  *Iter:collect()*+    Drain the iterator into a table.++    The final stage in the iterator pipeline must return 1 or 2 values. If+    only one value is returned, or if two values are returned and the first+    value is a number, an ""array-like"" table is returned. Otherwise, the first+    return value is used as the table key and the second return value as the+    table value.++    Example: >lua++     local it1 = vim.iter(string.gmatch('100 20 50', 'd+')):filtermap(tonumber)+     it1:collect()+     -- { 100, 20, 50 }++     local it2 = vim.iter(string.gmatch('100 20 50', 'd+')):filtermap(tonumber)+     it2:collect({ sort = true })+     -- { 20, 50, 100 }+<++    Parameters: ~+      ��� {opts}  ?table Optional arguments:+                ��� sort (boolean|function): If true, sort the resulting table+                  before returning. If a function is provided, that function+                  is used as the comparator function to |table.sort()|.++    Return: ~+        (table)++Iter:enumerate({self})                                      *Iter:enumerate()*+    Add an iterator stage that returns the current iterator count as well as+    the iterator value.++    Example: >lua++     local it = vim.iter(vim.gsplit('abc', '')):enumerate()+     it:next()+     -- 1   'a'+     it:next()+     -- 2   'b'+     it:next()+     -- 3   'c'+<++    Return: ~+        Iter++Iter:filter({self}, {f})                                       *Iter:filter()*+    Add a filter step to the iterator pipeline.++    Example: >lua++     local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)+<++    Parameters: ~+      ��� {f}  function(...):bool Takes all values returned from the previous+             stage in the pipeline and returns false or nil if the current+             iterator element should be removed.++    Return: ~+        Iter++Iter:filtermap({self}, {f})                                 *Iter:filtermap()*+    Add a map and filter step to the iterator pipeline.++    Example: >lua++     local it = vim.iter({ 1, 2, 3, 4 }):filtermap(function(v)+       if v % 2 == 0 then+         return v * 3+       end+     end)+     it:collect()+     -- { 6, 12 }+<++    Parameters: ~+      ��� {f}  function(...):any Mapping function. Takes all values returned+             from the previous stage in the pipeline as arguments and returns+             one or more new values, which are used in the next pipeline+             stage. Nil return values returned are filtered from the output.++    Return: ~+        Iter++Iter:find({self}, {f})                                           *Iter:find()*+    Find the first value in the iterator that satisfies the given predicate.++    Advances the iterator. Returns nil and drains the iterator if no value is+    found.++    Examples: >lua++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(12)+     -- 12++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(20)+     -- nil++     local it = vim.iter({ 3, 6, 9, 12 })+     it:find(function(v) return v % 4 == 0 end)+     -- 12+<++    Return: ~+        any++Iter:foreach({self}, {f})                                     *Iter:foreach()*+    Call a function once for each item in the pipeline.++    This is used for functions which have side effects. To modify the values+    in the iterator, use |Iter:filtermap()|.++    This function drains the iterator.++    Parameters: ~+      ��� {f}  function(...) Function to execute for each item in the pipeline.+             Takes all of the values returned by the previous stage in the+             pipeline as arguments.++Iter:last({self})                                                *Iter:last()*+    Return the last item in the iterator.++    Drains the iterator.++    Example: >lua++     local it = vim.iter(vim.gsplit('abcdefg', ''))+     it:last()+     -- 'g'++     local it = vim.iter({ 3, 6, 9, 12, 15 })+     it:last()+     -- 15+<++    Return: ~+        any++Iter:next({self})                                                *Iter:next()*+    Return the next value from the iterator.++    Example: >lua++     local it = vim.iter(string.gmatch('1 2 3', 'd+')):filtermap(tonumber)+     it:next()+     -- 1+     it:next()+     -- 2+     it:next()+     -- 3+<++    Return: ~+        any++Iter:nextback({self})                                        *Iter:nextback()*+    Return the next value from the end of the iterator.++    Only supported for iterators on tables.++    Example: >lua++     local it = vim.iter({1, 2, 3, 4})+     it:nextback()+     -- 4+     it:nextback()+     -- 3+<++    Return: ~+        any++Iter:nth({self}, {n})                                             *Iter:nth()*+    Return the nth value in the iterator.++    This function advances the iterator.++    Example: >lua++     local it = vim.iter({ 3, 6, 9, 12 })+     it:nth(2)+     -- 6+     it:nth(2)+     -- 12+<++    Parameters: ~+      ��� {n}  (number) The index of the value to return.++    Return: ~+        any++Iter:nthback({self}, {n})                                     *Iter:nthback()*+    Return the nth value from the end of the iterator.++    This function advances the iterator.++    Only supported for iterators on tables.++    Example: >lua++     local it = vim.iter({ 3, 6, 9, 12 })+     it:nthback(2)+     -- 9+     it:nthback(2)+     -- 3+<++    Parameters: ~+      ��� {n}  (number) The index of the value to return.++    Return: ~+        any++Iter:peek({self})                                                *Iter:peek()*+    Peek at the next value in the iterator without consuming it.++    Only iterators on tables can be peeked.++    Example: >lua++     local it = vim.iter({ 3, 6, 9, 12 })+     it:peek()+     -- 3+     it:peek()+     -- 3+     it:next()+     -- 3+<++    Return: ~+        any++Iter:peekback({self})                                        *Iter:peekback()*+    Return the next value from the end of the iterator without consuming it.++    Only supported for iterators on tables.++    Example: >lua++     local it = vim.iter({1, 2, 3, 4})+     it:peekback()+     -- 4+     it:peekback()+     -- 4+     it:nextback()+     -- 4+<++    Return: ~+        any++Iter:rev({self})                                                  *Iter:rev()*+    Reverse an iterator.++    Only iterators on tables can be reversed.++    Example: >lua++     local it = vim.iter({ 3, 6, 9, 12 }):rev()+     it:collect()+     -- { 12, 9, 6, 3 }+<++    Return: ~+        Iter++Iter:rfind({self}, {f})                                         *Iter:rfind()*+    Find the first value in the iterator that satisfies the given predicate,+    starting from the end.++    Advances the iterator. Returns nil and drains the iterator if no value is+    found.++    Only supported for iterators on tables.++    Examples: >lua++     local it = vim.iter({ 1, 2, 3, 2, 1 }):enumerate()+     it:rfind(1)+     -- 5   1+     it:rfind(1)+     -- 1   1+<++    Return: ~+        any++    See also: ~+      ��� Iter.find++Iter:skip({self}, {n})                                           *Iter:skip()*",`skipback` is useful for creating a slice.```lua-- Remove the first 6 elements and the last 3 elementsvim.iter(t):skip(6):skipback(3)```This could replace `vim.list_slice`.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23029,1167244229,2023-04-14T20:19:14Z,runtime/doc/lua.txt,"@@ -2817,4 +2914,367 @@ range({spec})                                            *vim.version.range()*     See also: ~       ��� # https://github.com/npm/node-semver#ranges ++==============================================================================+Lua module: iter                                                    *lua-iter*++Iter:all({self}, {pred})                                          *Iter:all()*+    Return true if all of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:any({self}, {pred})                                          *Iter:any()*+    Return true if any of the items in the iterator match the given predicate.++    Parameters: ~+      ��� {pred}  function(...):bool Predicate function. Takes all values+                returned from the previous stage in the pipeline as arguments+                and returns true if the predicate matches.++Iter:collect({self}, {opts})                                  *Iter:collect()*",">If it's restricted to return a table I'd tend to go with :totable, same as https://luafun.github.io/reducing.html#fun.totable, but for stdlib I think something that is more generally useful would be warrantedBecause tables are so central in Lua, and because conversion to a table is slightly different implementation wise for list-like tables, map-like tables, and function iterators (for both performance and semantics reasons), I think having a dedicated `totable` makes sense. For a more generic interface, we have `fold`.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23029,1167439824,2023-04-15T08:31:49Z,runtime/lua/vim/iter.lua,"@@ -0,0 +1,770 @@+--- Iterator implementation.++---@class Iter+---@field next function Return the next value in the iterator+---@field _table ?table Underlying table data (table iterators only)+---@field _head ?number Index to the front of a table iterator (table iterators only)+---@field _tail ?number Index to the end of a table iterator (table iterators only)+local Iter = {}+Iter.__index = Iter+Iter.__call = function(self)+  return self:next()+end++--- Special case implementations for iterators on list-like tables.+local ListIter = {}+ListIter.__index = setmetatable(ListIter, Iter)+ListIter.__call = function(self)+  return self:next()+end++--- Special case implementations for iterators on map-like tables.+local MapIter = {}+MapIter.__index = setmetatable(MapIter, Iter)+MapIter.__call = function(self)+  return self:next()+end++---@private+local function unpack(t)+  if type(t) == 'table' then+    return _G.unpack(t)+  end+  return t+end++---@private+local function pack(...)+  if select('#', ...) > 1 then+    return { ... }+  end+  return ...+end++--- Add a filter step to the iterator pipeline.+---+--- Example:+--- <pre>lua+--- local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)+--- </pre>+---+---@param f function(...):bool Takes all values returned from the previous stage in the pipeline and+---                            returns false or nil if the current iterator element should be+---                            removed.+---@return Iter+function Iter.filter(self, f)+  local next = self.next+  self.next = function(this)+    while true do+      local args = pack(next(this))+      if args == nil then+        break+      end+      if f(unpack(args)) then+        return unpack(args)+      end",```suggestion      local unpacked = unpack(args)      if f(unpacked) then        return unpacked      end```Would avoid duplicate `unpack` calls. Same for a couple of the other functions. (Or is there special arg passing semantics with Lua that I'm missing?),
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23029,1167485249,2023-04-15T12:08:39Z,runtime/lua/vim/iter.lua,"@@ -0,0 +1,770 @@+--- Iterator implementation.++---@class Iter+---@field next function Return the next value in the iterator+---@field _table ?table Underlying table data (table iterators only)+---@field _head ?number Index to the front of a table iterator (table iterators only)+---@field _tail ?number Index to the end of a table iterator (table iterators only)+local Iter = {}+Iter.__index = Iter+Iter.__call = function(self)+  return self:next()+end++--- Special case implementations for iterators on list-like tables.+local ListIter = {}+ListIter.__index = setmetatable(ListIter, Iter)+ListIter.__call = function(self)+  return self:next()+end++--- Special case implementations for iterators on map-like tables.+local MapIter = {}+MapIter.__index = setmetatable(MapIter, Iter)+MapIter.__call = function(self)+  return self:next()+end++---@private+local function unpack(t)+  if type(t) == 'table' then+    return _G.unpack(t)+  end+  return t+end++---@private+local function pack(...)+  if select('#', ...) > 1 then+    return { ... }+  end+  return ...+end++--- Add a filter step to the iterator pipeline.+---+--- Example:+--- <pre>lua+--- local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)+--- </pre>+---+---@param f function(...):bool Takes all values returned from the previous stage in the pipeline and+---                            returns false or nil if the current iterator element should be+---                            removed.+---@return Iter+function Iter.filter(self, f)+  local next = self.next+  self.next = function(this)+    while true do+      local args = pack(next(this))+      if args == nil then+        break+      end+      if f(unpack(args)) then+        return unpack(args)+      end","The pack/unpack dance is necessary because we don���t know how many args the iterator function might return.```lua local unpacked = unpack(args)```will drop all but the first value.We could avoid duplicate unpacking through a helper function maybe, though I���m not sure if that���s better from a performance perspective (I���m not sure how expensive unpack is versus another function call)",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23196,1171277268,2023-04-19T12:38:55Z,src/nvim/option.c,"@@ -1996,6 +1996,414 @@ static void apply_optionset_autocmd(int opt_idx, long opt_flags, long oldval, lo   reset_v_option_vars(); } +/// Ensure that options set to p_force_on cannot be disabled.+static const char *did_set_force_on(int *doskip)+{+  if (p_force_on == false) {+    p_force_on = true;+    *doskip = true;+    return e_unsupportedoption;+  }+  return NULL;+}++/// Ensure that options set to p_force_off cannot be enabled.+static const char *did_set_force_off(int *doskip)+{+  if (p_force_off == true) {+    p_force_off = false;+    *doskip = true;+    return e_unsupportedoption;+  }+  return NULL;+}++/// Process the updated 'langremap' option value.+static void did_set_langremap(void)+{+  // 'langremap' -> !'langnoremap'+  p_lnr = !p_lrm;+}++/// Process the updated 'langnoremap' option value.+static void did_set_langnoremap(void)+{+  // 'langnoremap' -> !'langremap'+  p_lrm = !p_lnr;+}++/// Process the updated 'undofile' option value.+static void did_set_undofile(int opt_flags)+{+  // Only take action when the option was set. When reset we do not+  // delete the undo file, the option may be set again without making+  // any changes in between.+  if (curbuf->b_p_udf || p_udf) {+    uint8_t hash[UNDO_HASH_SIZE];++    FOR_ALL_BUFFERS(bp) {+      // When 'undofile' is set globally: for every buffer, otherwise+      // only for the current buffer: Try to read in the undofile,+      // if one exists, the buffer wasn't changed and the buffer was+      // loaded+      if ((curbuf == bp+           || (opt_flags & OPT_GLOBAL) || opt_flags == 0)+          && !bufIsChanged(bp) && bp->b_ml.ml_mfp != NULL) {+        u_compute_hash(bp, hash);+        u_read_undo(NULL, hash, bp->b_fname);+      }+    }+  }+}++/// Process the updated 'readonly' option value.+static void did_set_readonly(int opt_flags)+{+  // when 'readonly' is reset globally, also reset readonlymode+  if (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0) {+    readonlymode = false;+  }++  // when 'readonly' is set may give W10 again+  if (curbuf->b_p_ro) {+    curbuf->b_did_warn = false;+  }++  redraw_titles();+}++/// Process the updated 'modifiable' option value.+static char *did_set_modifiable(void)+{+  // when 'modifiable' is changed, redraw the window title+  redraw_titles();++  return NULL;+}++/// Process the updated 'endoffile' or 'endofline' or 'fixendofline' or 'bomb'+/// option value.+static void did_set_eof_eol_fixeol_bomb(void)+{+  // redraw the window title and tab page text+  redraw_titles();+}++/// Process the updated 'binary' option value.+static void did_set_binary(int opt_flags, long old_value)+{+  // when 'bin' is set also set some other options+  set_options_bin((int)old_value, curbuf->b_p_bin, opt_flags);+  redraw_titles();+}++/// Process the updated 'buflisted' option value.+static void did_set_buflisted(long old_value)+{+  // when 'buflisted' changes, trigger autocommands+  if (old_value != curbuf->b_p_bl) {+    // when 'buflisted' changes, trigger autocommands","```suggestion  // when 'buflisted' changes, trigger autocommands  if (old_value != curbuf->b_p_bl) {```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/22894,1171312207,2023-04-19T13:07:22Z,runtime/doc/lua.txt,"@@ -1738,6 +1738,33 @@ pesc({s})                                                         *vim.pesc()*     See also: ~       ��� https://github.com/rxi/lume +ringbuf({size})                                                *vim.ringbuf()*+    Create a ring buffer limited to a maximal number of items. Once the buffer+    is full, adding a new entry overrides the oldest entry.+>++    local ringbuf = vim.ringbuf(4)+    ringbuf.add(""a"")+    ringbuf.add(""b"")+    ringbuf.add(""c"")+    ringbuf.add(""d"")+    ringbuf.add(""e"")      -- overrides ""a""+    print(ringbuf.poll()) -- returns ""b""+    print(ringbuf.poll()) -- returns ""c""",Changed it to class style.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22894,1171319302,2023-04-19T13:12:23Z,runtime/lua/vim/shared.lua,"@@ -989,4 +989,88 @@ function vim.map(f, src, ...)   return vim.iter(src, ...):map(f):totable() end +do+  ---@class vim.Ringbuf<T>+  ---@field private items table[]+  ---@field private idx_read integer+  ---@field private idx_write integer+  ---@field private size integer",Should we underscore these field names to signify they are unstable? Or do we want to make them a part of the contract?```suggestion  ---@class vim.Ringbuf<T>  ---@field private _items table[]  ---@field private _idx_read integer  ---@field private _idx_write integer  ---@field private _size integer```,X
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/23214,1172710986,2023-04-20T14:48:56Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -551,7 +551,7 @@ local function add_injection(t, tree_index, pattern, lang, combined, ranges)     t[tree_index][lang][pattern] = { combined = combined, regions = {} }   end -  table.insert(t[tree_index][lang][pattern].regions, ranges)+  t[tree_index][lang][pattern].regions[#t[tree_index][lang][pattern].regions + 1] = ranges",This could work if the performance benefit is worth it (IDK that it is).```suggestion  local regions = t[tree_index][lang][pattern].regions  regions[#regions + 1] = ranges```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23029,1173275061,2023-04-21T03:44:29Z,runtime/lua/vim/shared.lua,"@@ -884,4 +884,109 @@ function vim.defaulttable(create)   }) end +--- Create an Iter |lua-iter| object from a table or iterator.+---+--- The input value can be a table  or a function iterator (see |luaref-in|).+---+--- This function wraps the input value into an interface which allows chaining+--- multiple pipeline stages in an efficient manner. Each pipeline stage+--- receives as input the output values from the prior stage. The values used in+--- the first stage of the pipeline depend on the type passed to this function:+---+--- - List tables pass only the value of each element+--- - Non-list tables pass both the key and value of each element+--- - Function iterators pass all of the values returned by their respective+---   function+---+--- Examples:+--- <pre>lua+--- local it = vim.iter({ 1, 2, 3, 4, 5 })+--- it:map(function(v)+---   return v * 3+--- end)+--- it:rev()+--- it:skip(2)+--- it:totable()+--- -- { 9, 6, 3 }+---+--- vim.iter(ipairs({ 1, 2, 3, 4, 5 })):map(function(i, v)+---   if i > 2 then return v end+--- end):totable()+--- -- { 3, 4, 5 }+---+--- local it = vim.iter(vim.gsplit('1,2,3,4,5', ','))+--- it:map(function(s) return tonumber(s) end)+--- for i, d in it:enumerate() do+---   print(string.format(""Column %d is %d"", i, d))+--- end+--- -- Column 1 is 1+--- -- Column 2 is 2+--- -- Column 3 is 3+--- -- Column 4 is 4+--- -- Column 5 is 5+---+--- vim.iter({ a = 1, b = 2, c = 3, z = 26 }):any(function(k, v)+---   return k == 'z'+--- end)+--- -- true+--- </pre>+---+---@see |lua-iter|+---+---@param src table|function Table or iterator.+---@return Iter @|lua-iter|+function vim.iter(src, ...)","I think these top-level functions should live on `vim.iter`. Because other than the `vim.tbl_xx` things (which will be deprecated), we don't have much precedent there. Putting these on `vim.inter` helps discovery and anyone worried about verbosity can do `local it = vim.iter`.",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/23214,1173333428,2023-04-21T06:00:44Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -551,7 +551,7 @@ local function add_injection(t, tree_index, pattern, lang, combined, ranges)     t[tree_index][lang][pattern] = { combined = combined, regions = {} }   end -  table.insert(t[tree_index][lang][pattern].regions, ranges)+  t[tree_index][lang][pattern].regions[#t[tree_index][lang][pattern].regions + 1] = ranges",A single call to table.insert is not worth the change. So I reverted. The time of creation of the temporary variable is equivalent to the time of the call. So there's no point here,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22784,1173539766,2023-04-21T09:13:44Z,runtime/doc/news.txt,"@@ -38,6 +38,14 @@ The following new APIs or features were added. ��� |vim.iter()| provides a generic iterator interface for tables and Lua iterators |luaref-in|. +��� Added automatic linting of treesitter query files (see |ft-query-plugin|).+  Automatic linting can be turned off via >vim+    autocmd FileType *.scm let b:lint_on = []","I'll test. (But this autocommand was wrong in any case, `*.scm` is not a valid FileType pattern.)",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23225,1173572497,2023-04-21T09:46:01Z,test/functional/ex_cmds/excmd_spec.lua,"@@ -28,6 +28,11 @@ describe('Ex cmds', function()     assert_alive()   end) +  it('check that and execute works', function()","```suggestion  it('listing long user command does not crash', function()```",
117116764,aarondill,https://api.github.com/repos/neovim/neovim/pulls/23229,1173661800,2023-04-21T11:30:05Z,runtime/doc/lua.txt,"@@ -733,17 +733,222 @@ VIM.JSON                                                            *lua-json*  The *vim.json* module provides encoding and decoding of Lua objects to and from JSON-encoded strings. Supports |vim.NIL| and |vim.empty_dict()|.+This module is provided by `openresty/lua-cjson`. See+https://github.com/openresty/lua-cjson for more documentation. -vim.json.encode({obj})                                       *vim.json.encode*+encode({obj})                                              *vim.json.encode()*     Encodes (or ""packs"") Lua object {obj} as JSON in a Lua string. -vim.json.decode({str}[, {opts}])                             *vim.json.decode*+decode({str}[, {opts}])                                    *vim.json.decode()*     Decodes (or ""unpacks"") the JSON-encoded {str} to a Lua object.      {opts} is a table with the key `luanil = { object: bool, array: bool }`     that controls whether `null` in JSON objects or arrays should be converted     to Lua `nil` instead of `vim.NIL`. +new()                                                         *vim.json.new()*+    Creates and returns a new `json` object, which is seperate from the+    global `vim.json`. Can be used to safely configure the options on your+    object and ensure safe parsing and encoding.++The following methods change the configuration of the json object. ~+The current settings are always returned. A particular setting is only ~+changed when the argument is provided (non-nil). ~++NOTE: These are global changes! Be careful with them or else create a new+object with |vim.json.new()|++                                     *vim.json.encode_empty_table_as_object()*+encode_empty_table_as_object([{enable}])+    Default: `false`+    Parameters: ~+      ��� {enable} (boolean / `""on""` / `""off""`) Whether to include array_mt+        metatable.++    Return: ~+      Current value: {enable}++    Change the default behavior when encoding an empty Lua table.++    `true` - empty Lua tables are encoded as empty JSON Objects (`{}`).+    `false` - empty Lua tables are encoded as empty JSON Arrays (`[]`).++   {enable} is either a boolean or a string (`""on""`, `""off""`).++                                       *vim.json.decode_array_with_array_mt()*","these functions are necessary for the use of the vim.json module, otherwise, hoops must be jumped through in order to avoid issues (ie, placing otherwise useless properties on a table.)Another (better) option would be to allow a configuration object to be passed to encode and decode, and in fact I almost attempted that, but I don't know C.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23254,1173947640,2023-04-21T16:09:25Z,runtime/lua/vim/iter.lua,"@@ -18,10 +18,13 @@ ListIter.__call = function(self)   return self:next() end +--- Packed tables use this as their metatable+local packedmt = {}+ ---@private local function unpack(t)-  if type(t) == 'table' and t.__n ~= nil then-    return _G.unpack(t, 1, t.__n)+  if getmetatable(t) == packedmt then+    return _G.unpack(t)","Yes, we do need to support holes because a function in the iterator pipeline could return multiple values, one of which is `nil`. I'm thinking about the best way to handle this though.The current implementation (without this PR) already handles this because the `__n` tag doubles as the length indicator. However, when the iterator is serialized into a table we strip the `__n` tags. I'm wondering if we should leave those in.Basically, consider the following scenario:```luavim.iter({1, 2, 3}):map(function(v)  return v, nil, v*vend):totable()```What should this return?Status quo has the whole table, but the `__n` tag is removed:```lua{ { 1, [3] = 1 }, { 2, [3] = 4 }, { 3, [3] = 9 } }```I'm wondering if we should rename `__n` to just `n` and leave it in the resulting table, which preserves full information on the table data, but then adds an extra field that may surprise users:```lua{ { n = 3, 1, [3] = 1 }, { n = 3, 2, [3] = 4 }, { n = 3, 3, [3] = 9 } }```Or we just leave holes in the returned table and say that users need to be able to deal with that situation if they are using an iterator function that returns `nil` values (they can always use `table.maxn` or `pairs` as well of course). This is the direction I'm leaning in personally.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/23257,1174215449,2023-04-21T23:02:42Z,.github/workflows/release.yml,"@@ -71,18 +41,40 @@ jobs:       - name: Install dependencies         run: |           apt-get update-          apt-get install -y build-essential cmake gettext locales ninja-build pkg-config unzip+          apt-get install -y build-essential cmake gettext ninja-build unzip       - if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name != 'nightly')         run: CC=gcc-10 make appimage-latest       - if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name == 'nightly')         run: CC=gcc-10 make appimage-nightly+      - if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name != 'nightly')+        run: printf 'NVIM_BUILD_TYPE=Release\n' >> $GITHUB_ENV+      - if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name == 'nightly')+        run: printf 'NVIM_BUILD_TYPE=RelWithDebInfo\n' >> $GITHUB_ENV       - uses: actions/upload-artifact@v3         with:           name: appimage           path: |             build/bin/nvim.appimage             build/bin/nvim.appimage.zsync           retention-days: 1+      - name: Build release+        id: build+        run: |+          make distclean","Nothing works. Packaging tar and the appimage fails. Packaging appimage and then tar will make the Release type not work, as the appimage is always built with RelWithDebInfo. The only realistic way I can resolve this without `make distclean` is to eliminate or heavily refactor `script/genappimage.sh` to try to make sense whatever is written there.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23229,1174309034,2023-04-22T06:37:49Z,runtime/doc/lua.txt,"@@ -733,17 +733,222 @@ VIM.JSON                                                            *lua-json*  The *vim.json* module provides encoding and decoding of Lua objects to and from JSON-encoded strings. Supports |vim.NIL| and |vim.empty_dict()|.+This module is provided by `openresty/lua-cjson`. See+https://github.com/openresty/lua-cjson for more documentation. -vim.json.encode({obj})                                       *vim.json.encode*+encode({obj})                                              *vim.json.encode()*     Encodes (or ""packs"") Lua object {obj} as JSON in a Lua string. -vim.json.decode({str}[, {opts}])                             *vim.json.decode*+decode({str}[, {opts}])                                    *vim.json.decode()*     Decodes (or ""unpacks"") the JSON-encoded {str} to a Lua object.      {opts} is a table with the key `luanil = { object: bool, array: bool }`     that controls whether `null` in JSON objects or arrays should be converted     to Lua `nil` instead of `vim.NIL`. +new()                                                         *vim.json.new()*+    Creates and returns a new `json` object, which is seperate from the+    global `vim.json`. Can be used to safely configure the options on your+    object and ensure safe parsing and encoding.++The following methods change the configuration of the json object. ~+The current settings are always returned. A particular setting is only ~+changed when the argument is provided (non-nil). ~++NOTE: These are global changes! Be careful with them or else create a new+object with |vim.json.new()|++                                     *vim.json.encode_empty_table_as_object()*+encode_empty_table_as_object([{enable}])+    Default: `false`+    Parameters: ~+      ��� {enable} (boolean / `""on""` / `""off""`) Whether to include array_mt+        metatable.++    Return: ~+      Current value: {enable}++    Change the default behavior when encoding an empty Lua table.++    `true` - empty Lua tables are encoded as empty JSON Objects (`{}`).+    `false` - empty Lua tables are encoded as empty JSON Arrays (`[]`).++   {enable} is either a boolean or a string (`""on""`, `""off""`).++                                       *vim.json.decode_array_with_array_mt()*","> these functions are necessary for the use of the vim.json module, otherwise, hoops must be jumped through in order to avoid issues (ie, placing otherwise useless properties on a table.)I use `vim.json` in my plugins just fine without these options. Could you explain your use-case where they are necessary?This https://github.com/codota/tabnine-nvim/issues/65 issue here to me is actually an indication that we should _remove_ these functions.Letting users change the behavior of the _global_ `vim.json` is just asking for trouble as any plugin can break the behavior of neovim itself (e.g LSP) or other plugins.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23257,1174358856,2023-04-22T10:04:54Z,.github/workflows/release.yml,"@@ -71,18 +41,39 @@ jobs:       - name: Install dependencies         run: |           apt-get update-          apt-get install -y build-essential cmake gettext locales ninja-build pkg-config unzip+          apt-get install -y build-essential cmake gettext ninja-build unzip       - if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name != 'nightly')         run: CC=gcc-10 make appimage-latest       - if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name == 'nightly')         run: CC=gcc-10 make appimage-nightly+      - if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name != 'nightly')+        run: printf 'NVIM_BUILD_TYPE=Release\n' >> $GITHUB_ENV+      - if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.tag_name == 'nightly')+        run: printf 'NVIM_BUILD_TYPE=RelWithDebInfo\n' >> $GITHUB_ENV","Out of interest, why this conditional? Why not always build `RelWithDebInfo`?",
117116764,aarondill,https://api.github.com/repos/neovim/neovim/pulls/23229,1174518544,2023-04-23T06:38:07Z,runtime/doc/lua.txt,"@@ -733,17 +733,222 @@ VIM.JSON                                                            *lua-json*  The *vim.json* module provides encoding and decoding of Lua objects to and from JSON-encoded strings. Supports |vim.NIL| and |vim.empty_dict()|.+This module is provided by `openresty/lua-cjson`. See+https://github.com/openresty/lua-cjson for more documentation. -vim.json.encode({obj})                                       *vim.json.encode*+encode({obj})                                              *vim.json.encode()*     Encodes (or ""packs"") Lua object {obj} as JSON in a Lua string. -vim.json.decode({str}[, {opts}])                             *vim.json.decode*+decode({str}[, {opts}])                                    *vim.json.decode()*     Decodes (or ""unpacks"") the JSON-encoded {str} to a Lua object.      {opts} is a table with the key `luanil = { object: bool, array: bool }`     that controls whether `null` in JSON objects or arrays should be converted     to Lua `nil` instead of `vim.NIL`. +new()                                                         *vim.json.new()*+    Creates and returns a new `json` object, which is seperate from the+    global `vim.json`. Can be used to safely configure the options on your+    object and ensure safe parsing and encoding.++The following methods change the configuration of the json object. ~+The current settings are always returned. A particular setting is only ~+changed when the argument is provided (non-nil). ~++NOTE: These are global changes! Be careful with them or else create a new+object with |vim.json.new()|++                                     *vim.json.encode_empty_table_as_object()*+encode_empty_table_as_object([{enable}])+    Default: `false`+    Parameters: ~+      ��� {enable} (boolean / `""on""` / `""off""`) Whether to include array_mt+        metatable.++    Return: ~+      Current value: {enable}++    Change the default behavior when encoding an empty Lua table.++    `true` - empty Lua tables are encoded as empty JSON Objects (`{}`).+    `false` - empty Lua tables are encoded as empty JSON Arrays (`[]`).++   {enable} is either a boolean or a string (`""on""`, `""off""`).++                                       *vim.json.decode_array_with_array_mt()*","the use case is encoding of values without knowing their contents. If you are expecting an object, but you're given an empty table, you should be able to ensure that your receiver can understand what you pass to it. *Most* internal neovim processes don't need usage of `vim.json`, however, a major use case of this is LSPs, DAPs, and formatters/linters (do these work directly on the file?), which are supposed to work regardless of the client. If an object is expected by the recipient (which can't always be changed), but an table is empty (especially an issue with dynamic objects/state), then it will be encoded differently, which the recipient might not be capable of handling.Additionally, several of these methods can greatly affect performance and memory usage while encoding/decoding, and certain options (such as `encode_number_precision`, `decode_invalid_numbers`, and `*_max_depth`) can **greatly** affect output, and in the last case, can even completely eliminate output. Some of these options are impossible to work around without knowing *extremely* well the structure of the data, such as the `max_depth` settings, for which, to circumvent, one would have to split the table at a maximum depth recursively (likely splitting into an array of unknown length), then encode each part and attempt to splice the text back together correctly. This would be an extremely complicated situation, which is easily solvable by setting `encode_max_depth` to a larger value. The reverse would also be true, but likely even harder, as it would require (program) understanding of the json structure to split the text, essentially creating a JSON parser in order to *parse JSON* using the built in `vim.json`. While this is a particularly unusual situation (requiring a depth of >100), it is not impossible, and given a dynamic object or an externalsource, might be necessary. Provided the option is already there and present in the code base, I'm much more in favor of exporting it in *some manner* (whether through `vim.json.new()` or else a confit option to `vim.json.{encode,decode}`).",
117116764,aarondill,https://api.github.com/repos/neovim/neovim/pulls/23229,1174537546,2023-04-23T08:42:36Z,runtime/doc/lua.txt,"@@ -733,17 +733,222 @@ VIM.JSON                                                            *lua-json*  The *vim.json* module provides encoding and decoding of Lua objects to and from JSON-encoded strings. Supports |vim.NIL| and |vim.empty_dict()|.+This module is provided by `openresty/lua-cjson`. See+https://github.com/openresty/lua-cjson for more documentation. -vim.json.encode({obj})                                       *vim.json.encode*+encode({obj})                                              *vim.json.encode()*     Encodes (or ""packs"") Lua object {obj} as JSON in a Lua string. -vim.json.decode({str}[, {opts}])                             *vim.json.decode*+decode({str}[, {opts}])                                    *vim.json.decode()*     Decodes (or ""unpacks"") the JSON-encoded {str} to a Lua object.      {opts} is a table with the key `luanil = { object: bool, array: bool }`     that controls whether `null` in JSON objects or arrays should be converted     to Lua `nil` instead of `vim.NIL`. +new()                                                         *vim.json.new()*+    Creates and returns a new `json` object, which is seperate from the+    global `vim.json`. Can be used to safely configure the options on your+    object and ensure safe parsing and encoding.++The following methods change the configuration of the json object. ~+The current settings are always returned. A particular setting is only ~+changed when the argument is provided (non-nil). ~++NOTE: These are global changes! Be careful with them or else create a new+object with |vim.json.new()|++                                     *vim.json.encode_empty_table_as_object()*+encode_empty_table_as_object([{enable}])+    Default: `false`+    Parameters: ~+      ��� {enable} (boolean / `""on""` / `""off""`) Whether to include array_mt+        metatable.++    Return: ~+      Current value: {enable}++    Change the default behavior when encoding an empty Lua table.++    `true` - empty Lua tables are encoded as empty JSON Objects (`{}`).+    `false` - empty Lua tables are encoded as empty JSON Arrays (`[]`).++   {enable} is either a boolean or a string (`""on""`, `""off""`).++                                       *vim.json.decode_array_with_array_mt()*","ah, yes. Specifically, `array_mt` (and related) can likely be removed with no consequence. in the case of decoding and re-encoding, if `vim.json` returns `vim.empty_dict()` (which can be re-serialized), then it's useless. I thought (falsely?) @mfussenegger was asking the relevance of *all* of these options.",
82267684,uga-rosa,https://api.github.com/repos/neovim/neovim/pulls/23281,1174545330,2023-04-23T09:31:49Z,test/functional/vimscript/special_vars_spec.lua,"@@ -130,6 +130,12 @@ describe('Special values', function()     eq(""v:false"", eval('"""" . v:false'))   end) +  it('work with ?? (falsy operator)', function()+    eq(true, eval('v:true ?? 42'))+    eq(42, eval('v:false ?? 42'))+    eq(42, eval('v:null ?? 42'))+  end)+",Other tests for falsy operator can be found here. Wouldn't it be better to put them all in the same place?https://github.com/neovim/neovim/blob/3ac952d4e27f4e2454332a730310316fe13fd4a3/test/old/testdir/test_expr.vim#L64-L87,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23285,1174570473,2023-04-23T12:17:50Z,runtime/doc/change.txt,"@@ -427,6 +427,12 @@ Note similarly, when 'nrformats' includes ""bin"", binary numbers with a leading '0x' or '0X' can be interpreted as hexadecimal rather than binary since '0b' are valid hexadecimal digits. +When the number under the cursor is too big to fit into 32 or 64 bit+(depending on how Vim was build), it will be rounded off to the nearest number+that can be represented, and the addition/subtraction is skipped.  E.g. with+64 bit support using CTRL-X on 18446744073709551616 results in+18446744073709551615.  Same for larger numbers, such as 18446744073709551618.+","```suggestionWhen the number under the cursor is too big to fit into 64 bit, it will be rounded off to the nearest numberthat can be represented, and the addition/subtraction is skipped.  E.g. using CTRL-X on 18446744073709551616 results in18446744073709551615.  Same for larger numbers, such as 18446744073709551618.```Like so?",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/23285,1174570674,2023-04-23T12:19:02Z,runtime/doc/change.txt,"@@ -427,6 +427,12 @@ Note similarly, when 'nrformats' includes ""bin"", binary numbers with a leading '0x' or '0X' can be interpreted as hexadecimal rather than binary since '0b' are valid hexadecimal digits. +When the number under the cursor is too big to fit into 32 or 64 bit+(depending on how Vim was build), it will be rounded off to the nearest number+that can be represented, and the addition/subtraction is skipped.  E.g. with+64 bit support using CTRL-X on 18446744073709551616 results in+18446744073709551615.  Same for larger numbers, such as 18446744073709551618.+",Looks good to me! :+1: Maybe `bit` -> `bits` if I'm allowed to be pedantic :innocent:,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22784,1175573432,2023-04-24T17:10:09Z,runtime/lua/vim/treesitter/_query_linter.lua,"@@ -57,21 +65,23 @@ local function guess_query_lang(buf)   end end ----@private----@param buf (integer)----@param opts (QueryLinterOpts|QueryLinterNormalizedOpts|nil)----@return (QueryLinterNormalizedOpts)+--- @private+--- @param buf integer+--- @param opts QueryLinterOpts|QueryLinterNormalizedOpts|nil+--- @return QueryLinterNormalizedOpts local function normalize_opts(buf, opts)   opts = opts or {}   if not opts.langs then     opts.langs = guess_query_lang(buf)   end+   if type(opts.langs) ~= 'table' then+    --- @diagnostic disable-next-line:assign-type-mismatch     opts.langs = { opts.langs }   end -  ---@cast opts QueryLinterNormalizedOpts-  opts.langs = opts.langs or { nil }","Ooops, need to fix that. Forgot what was necessary to have nil entries in list-like tables. Will replace that with explict logic.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/23258,1175948993,2023-04-25T02:24:07Z,src/nvim/mouse.c,"@@ -212,22 +212,30 @@ static int get_fpos_of_mouse(pos_T *mpos)   if (wp == NULL) {     return IN_UNKNOWN;   }+  int winrow = row;++  // compute the position in the buffer line from the posn on the screen+  bool below_buffer = mouse_comp_pos(wp, &row, &col, &mpos->lnum);++  if (!below_buffer && *wp->w_p_stc != NUL && mouse_col < win_col_off(wp)) {+    return MOUSE_STATUSCOL;+  }    // winpos and height may change in win_enter()!-  if (row + wp->w_winbar_height >= wp->w_height) {  // In (or below) status line+  if (mouse_row + wp->w_winbar_height >= wp->w_height) {  // In (or below) status line",Mistake. I moved the `mouse_comp_pos()` call up to use its result in the statuscolumn comparison. After which the original `row/col` are no longer valid for the other comparisons.Fixed now to use the intermediate `winrow/col`.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22784,1176263670,2023-04-25T09:37:17Z,runtime/ftplugin/query.lua,"@@ -2,5 +2,29 @@ -- Language:	Tree-sitter query -- Last Change:	2022 Mar 29 +if vim.b.did_ftplugin == 1 then+  return+end++-- Do not set vim.b.did_ftplugin = 1 to allow loading of ftplugin/lisp.vim++-- use treesitter over syntax+vim.treesitter.start()++-- query linter+local buf = vim.api.nvim_get_current_buf()+local query_lint_on = vim.b.lint_on or { 'InsertLeave', 'CursorHoldI', 'BufEnter' }",For now maybe just add `BufWritePre` to the existing list?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22784,1176334033,2023-04-25T10:41:20Z,runtime/ftplugin/query.lua,"@@ -2,5 +2,29 @@ -- Language:	Tree-sitter query -- Last Change:	2022 Mar 29 +if vim.b.did_ftplugin == 1 then+  return+end++-- Do not set vim.b.did_ftplugin = 1 to allow loading of ftplugin/lisp.vim++-- use treesitter over syntax+vim.treesitter.start()++-- query linter+local buf = vim.api.nvim_get_current_buf()+local query_lint_on = vim.b.lint_on or { 'InsertLeave', 'CursorHoldI', 'BufEnter' }","Let's keep the list short for now; we can always add more events later (which is easier than removing events).More important is to get the interface right (buffer vs. global variables); my preference is still 1. a global variable for the events (none disables globally)2. a buffer variable for skipping linting (for the tree, primarily -- we don't even have to expose it for now and treat it as an implementation detail for that purpose only)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23301,1176564079,2023-04-25T14:00:20Z,runtime/lua/editorconfig.lua,"@@ -157,7 +157,7 @@ local function parse_line(line)       return glob, nil, nil     end -    local key, val = line:match('^%s*([^:= ][^:=]-)%s*[:=]%s*(.-)%s*$')+    local key, val = line:match('^%s*([^:= ][^:=]-)%s*[:=]%s*([^#;%s]+).*$')","If a value includes spaces that should be an error instead of silently ignoring it.For example, with this pattern the following works just fine:```[*.c]indent_style = space tab```This will be parsed as `indent_style = space` and the `tab` is just ignored. But this is an invalid value, and should be treated as such.```suggestion    local key, val = line:match('^%s*([^:= ][^:=]-)%s*[:=]%s*([^#;]+).*$')```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23297,1178520246,2023-04-27T00:45:55Z,src/nvim/ex_docmd.c,"@@ -1284,8 +1284,8 @@ void set_cmd_dflall_range(exarg_T *eap)   case ADDR_NONE:   case ADDR_UNSIGNED:   case ADDR_QUICKFIX:-    iemsg(_(""INTERNAL: Cannot use EX_DFLALL ""-            ""with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX""));+    *errormsg = _(""INTERNAL: Cannot use EX_DFLALL ""+                  ""with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX"");",Don't pass along internal error message. Just keep this `iemsg()`.,
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/23375,1180561596,2023-04-28T15:39:53Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -94,15 +95,34 @@ end --- ---@private ---@return STTokenRange[]-local function tokens_to_ranges(data, bufnr, client)+local function tokens_to_ranges(data, bufnr, client, request)   local legend = client.server_capabilities.semanticTokensProvider.legend   local token_types = legend.tokenTypes   local token_modifiers = legend.tokenModifiers   local ranges = {} +  local start = uv.hrtime()+  local ns_to_ms = 0.000001+  local co = coroutine.running()+   local line   local start_char = 0   for i = 1, #data, 5 do",It's part of the LSP semantic token spec. Every 5 values in the array relate to a token.,
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/23320,1180596098,2023-04-28T16:16:43Z,src/nvim/move.c,"@@ -1691,27 +2102,68 @@ void scroll_cursor_bot(int min_scroll, int set_topbot) /// void scroll_cursor_halfway(bool atend, bool prefer_above) {-  int above = 0;-  int topfill = 0;-  int below = 0;-  lineoff_T loff;-  lineoff_T boff;   linenr_T old_topline = curwin->w_topline;--  loff.lnum = boff.lnum = curwin->w_cursor.lnum;+  lineoff_T loff = { .lnum = curwin->w_cursor.lnum };+  lineoff_T boff = { .lnum = curwin->w_cursor.lnum };   (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);   int used = plines_win_nofill(curwin, loff.lnum, true);   loff.fill = 0;   boff.fill = 0;   linenr_T topline = loff.lnum;+  colnr_T skipcol = 0;+  bool set_skipcol = false;++  int half_height = 0;+  bool smooth_scroll = false;+  if (curwin->w_p_sms && curwin->w_p_wrap) {+    // 'smoothscroll' and 'wrap' are set+    smooth_scroll = true;+    half_height = (curwin->w_height - used) / 2;+    used = 0;+  } +  int topfill = 0;   while (topline > 1) {+    // If using smoothscroll, we can precisely scroll to the+    // exact point where the cursor is halfway down the screen.+    if (smooth_scroll) {+      topline_back_winheight(curwin, &loff, false);+      if (loff.height == MAXCOL) {+        break;+      } else {+        used += loff.height;+      }+      if (used > half_height) {+        if (used - loff.height < half_height) {+          int plines_offset = used - half_height;+          loff.height -= plines_offset;+          used = half_height;++          topline = loff.lnum;+          topfill = loff.fill;+          skipcol = skipcol_from_plines(curwin, plines_offset);+          set_skipcol = true;+        }+        break;+      }+      topline = loff.lnum;+      topfill = loff.fill;+      continue;+    }++    // If not using smoothscroll, we have to iteratively find how many+    // lines to scroll down to roughly fit the cursor.+    // This may not be right in the middle if the lines' physical height >+    // 1 (e.g. 'wrap' is on).+",Do you want me to change the linebreak to stay compatible with vim? I may have changed the linebreak some other comments as well. I thought we allowed/preferred longer lines.I guess the point is being able to `patch` without conflicts? I did everything by hand because most of it doesn't apply cleanly anyways because of ifdefs/formatting...,
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/23375,1180808886,2023-04-28T20:48:10Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -94,15 +95,34 @@ end --- ---@private ---@return STTokenRange[]-local function tokens_to_ranges(data, bufnr, client)+local function tokens_to_ranges(data, bufnr, client, request)   local legend = client.server_capabilities.semanticTokensProvider.legend   local token_types = legend.tokenTypes   local token_modifiers = legend.tokenModifiers   local ranges = {} +  local start = uv.hrtime()+  local ns_to_ms = 0.000001+  local co = coroutine.running()+   local line   local start_char = 0   for i = 1, #data, 5 do+    local elapsed_ms = (uv.hrtime() - start) * ns_to_ms","It depends on how long the loop takes to run. This is highly dependent on your machine and the types of tokens that are returned. Turning the bitfield for modifiers into the list of modifier names is not a constant operation so each token takes a variable amount of instructions.That said, here are some stats I gathered on my M1 Pro Macbook Pro. All stats are taken with a release build, using the rust file from the issue I linked in the description.Without the coroutine/yielding, here's how long it takes my machine to simply process the whole token array into a highlight range list:```93.688166 ms to process 17602 tokens (0.005323 ms/token)116.935833 ms to process 17603 tokens (0.006643 ms/token)108.793209 ms to process 17604 tokens (0.006180 ms/token)117.514709 ms to process 17604 tokens (0.006675 ms/token)116.531417 ms to process 17604 tokens (0.006620 ms/token)110.875750 ms to process 17605 tokens (0.006298 ms/token)113.007000 ms to process 17605 tokens (0.006419 ms/token)```I was just typing a few characters to feel the lag and get additional token responses sent. Each line above was a full token response from the server.With that same file, I re-enabled the yield-every-5-ms logic and recorded the number of iterations it completed per wakeup:```completed 305 tokens for this loop iterationcompleted 465 tokens for this loop iterationcompleted 1045 tokens for this loop iterationcompleted 1091 tokens for this loop iterationcompleted 1100 tokens for this loop iterationcompleted 997 tokens for this loop iterationcompleted 880 tokens for this loop iterationcompleted 675 tokens for this loop iterationcompleted 773 tokens for this loop iterationcompleted 1081 tokens for this loop iterationcompleted 1081 tokens for this loop iterationcompleted 1085 tokens for this loop iterationcompleted 1054 tokens for this loop iterationcompleted 872 tokens for this loop iterationcompleted 890 tokens for this loop iterationcompleted 790 tokens for this loop iterationcompleted 453 tokens for this loop iterationcompleted 958 tokens for this loop iterationcompleted 1080 tokens for this loop iteration19 yields to process response```This was for _one_ response from the server.I think the sensitivity to input lag varies from person to person, but for the sake of demonstration, lets say we shoot for 60fps, which most people can agree is very responsive. This means that only ~16.7ms can be spent doing work between handling an input key and drawing it to the screen. That's for _everything_ it has to do (since we do all our work on the main thread).Yielding every 5 ms seems like a good compromise to leave a lot of headroom for neovim to do other stuff per loop iteration. We could go higher, but we start to crowd out the available time for that other stuff before the input latency becomes noticeable.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/23375,1180840000,2023-04-28T21:45:23Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -94,15 +95,34 @@ end --- ---@private ---@return STTokenRange[]-local function tokens_to_ranges(data, bufnr, client)+local function tokens_to_ranges(data, bufnr, client, request)   local legend = client.server_capabilities.semanticTokensProvider.legend   local token_types = legend.tokenTypes   local token_modifiers = legend.tokenModifiers   local ranges = {} +  local start = uv.hrtime()+  local ns_to_ms = 0.000001+  local co = coroutine.running()+   local line   local start_char = 0   for i = 1, #data, 5 do+    local elapsed_ms = (uv.hrtime() - start) * ns_to_ms","Yes, I did qualify with: ""assuming we don't abandon"".Anyway, good work. I plan on doing something very similar with treesitter.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/23320,1180866549,2023-04-28T22:48:22Z,src/nvim/move.c,"@@ -1691,27 +2102,68 @@ void scroll_cursor_bot(int min_scroll, int set_topbot) /// void scroll_cursor_halfway(bool atend, bool prefer_above) {-  int above = 0;-  int topfill = 0;-  int below = 0;-  lineoff_T loff;-  lineoff_T boff;   linenr_T old_topline = curwin->w_topline;--  loff.lnum = boff.lnum = curwin->w_cursor.lnum;+  lineoff_T loff = { .lnum = curwin->w_cursor.lnum };+  lineoff_T boff = { .lnum = curwin->w_cursor.lnum };   (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);   int used = plines_win_nofill(curwin, loff.lnum, true);   loff.fill = 0;   boff.fill = 0;   linenr_T topline = loff.lnum;+  colnr_T skipcol = 0;+  bool set_skipcol = false;++  int half_height = 0;+  bool smooth_scroll = false;+  if (curwin->w_p_sms && curwin->w_p_wrap) {+    // 'smoothscroll' and 'wrap' are set+    smooth_scroll = true;+    half_height = (curwin->w_height - used) / 2;+    used = 0;+  } +  int topfill = 0;   while (topline > 1) {+    // If using smoothscroll, we can precisely scroll to the+    // exact point where the cursor is halfway down the screen.+    if (smooth_scroll) {+      topline_back_winheight(curwin, &loff, false);+      if (loff.height == MAXCOL) {+        break;+      } else {+        used += loff.height;+      }+      if (used > half_height) {+        if (used - loff.height < half_height) {+          int plines_offset = used - half_height;+          loff.height -= plines_offset;+          used = half_height;++          topline = loff.lnum;+          topfill = loff.fill;+          skipcol = skipcol_from_plines(curwin, plines_offset);+          set_skipcol = true;+        }+        break;+      }+      topline = loff.lnum;+      topfill = loff.fill;+      continue;+    }++    // If not using smoothscroll, we have to iteratively find how many+    // lines to scroll down to roughly fit the cursor.+    // This may not be right in the middle if the lines' physical height >+    // 1 (e.g. 'wrap' is on).+","> No, I added it intentionally because the position of the linebreak changed. The existing comment has the latest linebreak position.I meant that this comment was originally added in a smoothscroll patch, so it was unexpected to already have in our code. Hence why I missed it and it ended up duplicated.(You added it in an unrelated patch that happened to change the linebreak.)",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/22784,1181092919,2023-04-29T15:27:38Z,runtime/lua/vim/loader.lua,"@@ -253,7 +253,7 @@ function Loader.load(modpath, opts)   local entry = Loader.read(modpath)   if entry and Loader.eq(entry.hash, hash) then     -- found in cache and up to date-    chunk, err = load(entry.chunk --[[@as string]], '@' .. modpath, opts.mode, opts.env)+    chunk, err = load(entry.chunk, --[[@as string]] '@' .. modpath, opts.mode, opts.env)","I added two empty lines, so that `-` would parse as bullet list in vimdoc for clason changes suggested above.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/23410,1181266291,2023-04-30T17:26:23Z,cmake/FindLpeg.cmake,"@@ -10,5 +10,5 @@ ubuntu() find_package_handle_standard_args(Lpeg DEFAULT_MSG LPEG_LIBRARY) mark_as_advanced(LPEG_LIBRARY) -add_library(lpeg INTERFACE)-target_link_libraries(lpeg INTERFACE ${LPEG_LIBRARY})+add_library(lpeg UNKNOWN IMPORTED)","should we add a one line summary or something in a comment here? (`git blame` is a thing, but a comment that something is different from other library targets to work around a cmake heisenissue would be good)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23401,1181396896,2023-05-01T05:22:30Z,runtime/lua/vim/ui.lua,"@@ -104,4 +104,45 @@ function M.input(opts, on_confirm)   end end +--- Opens a URI by sending it to the system's default handler.+--- This function utilizes `xdg-open`, `wslview`, or `open` commands depending on+--- the operating system to open the provided URI.+---+---+---@param uri string Uri to be opened+---   TODO: uri should accept vim.uri.Uri",```suggestion```There is currently no `vim.uri.Uri` class. I think this can be removed for now.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23401,1181398055,2023-05-01T05:27:10Z,runtime/lua/vim/ui.lua,"@@ -104,4 +104,45 @@ function M.input(opts, on_confirm)   end end +--- Opens a URI by sending it to the system's default handler.+--- This function utilizes `xdg-open`, `wslview`, or `open` commands depending on+--- the operating system to open the provided URI.+---+---+---@param uri string Uri to be opened+---   TODO: uri should accept vim.uri.Uri+---+--- Example:+--- <pre>lua+--- vim.ui.open_uri(""https://neovim.io/"")+---+--- vim.ui.open_uri(""/path/to/file"")+--- </pre>+function M.open_uri(uri)+  local cmd++  local sysname = vim.loop.os_uname().sysname++  if sysname == 'Darwin' then+    cmd = 'open'+  elseif sysname:match('windows') then+    cmd = 'wslview'+  else -- Assume linux+    cmd = 'xdg-open'+  end++  local ret = vim.fn.jobstart({","Could this return the `ret` and maybe have a second `opts` parameter with `quiet` to surpress the message? Then it could be used in https://github.com/neovim/neovim/blob/02d5a678fbf4ed36b4896010a051f136d587e779/runtime/lua/vim/lsp/handlers.lua#L571-L580I'm not sure about the opts/quiet, maybe it's fine to always have the error notification.",
40532058,mrshmllow,https://api.github.com/repos/neovim/neovim/pulls/23401,1181422134,2023-05-01T06:44:08Z,runtime/lua/vim/ui.lua,"@@ -104,4 +104,45 @@ function M.input(opts, on_confirm)   end end +--- Opens a URI by sending it to the system's default handler.+--- This function utilizes `xdg-open`, `wslview`, or `open` commands depending on+--- the operating system to open the provided URI.+---+---+---@param uri string Uri to be opened+---   TODO: uri should accept vim.uri.Uri","@justinmk is accepting a Uri class really that important? There are no actions performed on it and all the handlers deal with parsing the ""uri"" themselves.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23429,1181970469,2023-05-01T23:42:44Z,src/nvim/generators/gen_vimvim.lua,"@@ -112,12 +112,13 @@ for _, au in ipairs(auevents.events) do     w(' ' .. au)   end end-for au, _ in pairs(auevents.aliases) do+for au, alias in pairs(auevents.aliases) do   if not auevents.nvim_specific[au] then","I think this condition should also be removed as it doesn't do anything, and the `au` variable above can be changed to `_`.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/23461,1183605341,2023-05-03T12:13:27Z,runtime/lua/vim/net.lua,"@@ -0,0 +1,364 @@+local M = {}++---@private Function to create method arguments. Method defaults to GET.+---@param method string|nil Http method.+---@return string[]+local function createMethodArgs(method)+  method = method and method:upper() or 'GET'++  if method == 'HEAD' then+    return { '--head' }+  elseif method == 'GET' then+    return { '--get' }+  end++  return {+    '--request',+    method,+  }+end++---@private --- Creates a table of curl command arguments based on the provided URL and options.+---@param url string The request URL.+---@param opts table Keyword arguments:+---             - method string|nil Http method.+---             - follow_redirects boolean|nil Follow redirects.+---             - data string|table|nil Data to send with the request. If a table, it will be JSON+---             encoded.+---             - headers table<string, string>|nil Headers to set on the request+---             - download_location string|nil Where to download a file if applicable.+---+---@return string[] args Curl command.+local function createCurlArgs(url, opts)+  vim.validate({+    opts = { opts, 'table', true },+  })++  local args = {+    'curl',++    -- Blocks progress bars and other non-parsable things+    -- TODO: Allow stderr+    '--no-progress-meter',+  }++  -- Set http method.+  vim.list_extend(args, createMethodArgs(opts.method))++  -- Follow redirects by default.+  if opts.follow_redirects or opts.follow_redirects == nil then+    table.insert(args, '--location')+  end++  if opts.data ~= nil then+    if type(opts.data) == 'table' then+      vim.list_extend(args, {+        -- Let curl do some extra stuff for JSON+        '--json',+        vim.json.encode(opts.data),+      })+    else+      vim.list_extend(args, {+        -- Otherwise, just pass the string as data+        -- --data-raw does not give @ any special meaning+        '--data-raw',+        opts.data,+      })+    end+  end++  if opts.headers ~= nil then+    for key, value in pairs(opts.headers) do+      vim.list_extend(args, {+        '--header',+        key .. ': ' .. value,+      })+    end+  end++  if opts.download_location == nil then+    -- Write additonal request metadata after the body.+    vim.list_extend(args, {+      '--write-out',+      '\\nBEGIN_HEADERS\\n%{header_json}\\n%{json}',+    })+  else+    -- Write body contents to file.+    vim.list_extend(args, {+      '--output',+      opts.download_location,+    })+  end++  -- Finally, insert the request url.+  table.insert(args, url)++  return args+end++--- @private Processes a list of data received from buffered stdout and returns a table with response data.+--- @param data string[] Data recieved from stdout.+--- @return table Response A table containing processed response data.+local function process_stdout(data)+  local cache = {}++  local extra = {}++  extra = vim.json.decode(data[#data])++  -- Remove `json`+  table.remove(data, #data)++  -- This makes our life so much easier+  local began_headers_at++  -- In the vast majority of cases, BEGAN_HEADERS is near the end of the list.+  -- We can loop backwards to gain some perf+  for i = #data, 1, -1 do+    if data[i] == 'BEGIN_HEADERS' then+      began_headers_at = i+      break+    end+  end++  table.remove(data, began_headers_at)++  local status = extra.http_code and tonumber(extra.http_code) or nil+  extra.method = extra.method:upper()++  ---@private+  local function read_headers()+    if began_headers_at ~= nil and cache.headers == nil then+      local header_string = table.concat(data, nil, began_headers_at, #data)++      cache.headers = vim.json.decode(header_string)+    end++    return cache.headers+  end++  ---@private+  local function read_body()+    -- check cache, return nil if method is HEAD+    if cache.body == nil and extra.method ~= 'HEAD' then+      local body = table.concat(data, '\n', 1, began_headers_at - 1)++      cache.body = body+    end++    return cache.body+  end++  return {+    headers = read_headers,+    body = read_body,+    json = function(opts)+      return vim.json.decode(read_body(), opts and opts or {})+    end,+    method = extra.method,+    status = status,+    ok = status and (status >= 200 and status <= 299) or false,+    size = extra.size_download and tonumber(extra.size_download) or nil,+    http_version = extra.http_version and tonumber(extra.http_version) or nil,+    _raw_write_out = extra,+  }+end++--- Asynchronously make HTTP requests.+---+---@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status+---@see |job-control|+---@see man://curl+---+---@param url string The request URL.+---@param opts table|nil Optional keyword arguments:+---             - method string|nil HTTP method to use. Defaults to GET.+---             - headers table|nil A table of key-value headers.+---             - follow_redirects boolean|nil Whether to follow redirects. Defaults to true.+---             - data string|table|nil Data to send with the request. If a table, it will be+---             JSON-encoded. vim.net does not currently support form encoding.+---+---             - on_complete fun(response: table)|nil Callback function when request is+---             completed successfully. The response has the following keys:+---                 - ok boolean Whether the request was successful (status within 2XX range).+---                 - headers fun(): table<string, string> Function returning a table of response headers.+---                 - body fun(): string|nil Function returning response body. If method was HEAD,+---                 this is nil.+---                 - json fun(opts: table|nil): table Read the body as JSON. Optionally accepts+---                 opts from |vim.json.decode|. Will throw errors if body is not JSON-decodable.+---                 - method string The http method used in the most recent HTTP request.+---                 - status number The numerical response code.+---                 - size number The total amount of bytes that were downloaded. This+---                 is the size of the body/data that was transferred, excluding headers.+---                 - http_version number HTTP version used in the request.+---             - on_err fun(err: string[])|nil An optional function recieving a `stderr_buffered` string[] of curl+---             stderr. Without providing this function, |fetch()| will automatically raise an error+---             to the user. See |on_stderr| and `stderr_buffered`.+---@return number jobid A job id.+---+--- Example:+--- <pre>lua+--- -- GET a url+--- vim.net.fetch(""https://example.com/api/data"", {+---   on_complete = function (response)+---     -- Lets read the response!+---+---     if response.ok then+---       -- Read response body+---       local body = response.body()+---     else+---   end+--- })+---+--- -- POST to a url, sending a table as JSON and providing an authorization header+--- vim.net.fetch(""https://example.com/api/data"", {+---   method = ""POST"",+---   data = {+---     key = value+---   },+---   headers = {+---     Authorization = ""Bearer "" .. token+---   },+---   on_complete = function (response)+---     -- Lets read the response!+---+---     if response.ok then+---       -- Read JSON response+---       local table = response.json()+---     else+---+---     -- What went wrong?+---     vim.print(response.status)+---   end+--- })+--- </pre>+function M.fetch(url, opts)+  vim.validate({+    opts = { opts, 'table', true },+  })++  opts = opts or {}++  -- Ensure that we dont download to a file in fetch()+  opts.download_location = nil++  local args = createCurlArgs(url, opts)++  local out = {}++  if opts._dry then+    return args+  end++  local job = vim.fn.jobstart(args, {","Is there a reason you are using vim.fn.jobstart over vim.loop.spawn?I think we plan to eventually deprecate a replace `jobstart` with `vim.spawn.loop` wrapper.One of the main limitations of `jobstart` is that since it's implemented in the `eval` layer, it cannot handle any strings with NULL bytes.",
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/23461,1184364846,2023-05-03T22:33:55Z,runtime/doc/lua.txt,"@@ -3349,4 +3349,133 @@ totable({f}, {...})                                       *vim.iter.totable()*     Return: ~         (table) ++==============================================================================+Lua module: net                                                      *lua-net*++download({url}, {path}, {opts})                           *vim.net.download()*+    Asynchronously download a file. To read the response metadata, such as+    headers and body, use |vim.net.fetch()|.++    Shares a few options with |vim.net.fetch()|, but not all of them.++    Example: >lua++     vim.net.download(""https://.../path/file"", ""~/.cache/download/location"", {+       on_complete = function ()+         vim.notify(""File Downloaded"", vim.log.levels.INFO)+       end+     })+<++    Parameters: ~+      ��� {url}   (string) url+      ��� {path}  (string) A download path, can be relative.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� method string|nil HTTP method to use. Defaults to GET.+                ��� headers table<string, string>|nil A table of key-value+                  headers.+                ��� follow_redirects boolean|nil Will follow redirects by","Can we name the options match https://fetch.spec.whatwg.org/#request-class?- `follow_redirects -> redirect=""follow""`- `data -> body`",
40532058,mrshmllow,https://api.github.com/repos/neovim/neovim/pulls/23461,1184370567,2023-05-03T22:38:06Z,runtime/doc/lua.txt,"@@ -3349,4 +3349,133 @@ totable({f}, {...})                                       *vim.iter.totable()*     Return: ~         (table) ++==============================================================================+Lua module: net                                                      *lua-net*++download({url}, {path}, {opts})                           *vim.net.download()*+    Asynchronously download a file. To read the response metadata, such as+    headers and body, use |vim.net.fetch()|.++    Shares a few options with |vim.net.fetch()|, but not all of them.++    Example: >lua++     vim.net.download(""https://.../path/file"", ""~/.cache/download/location"", {+       on_complete = function ()+         vim.notify(""File Downloaded"", vim.log.levels.INFO)+       end+     })+<++    Parameters: ~+      ��� {url}   (string) url+      ��� {path}  (string) A download path, can be relative.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� method string|nil HTTP method to use. Defaults to GET.+                ��� headers table<string, string>|nil A table of key-value+                  headers.+                ��� follow_redirects boolean|nil Will follow redirects by","> - `follow_redirects -> redirect=""follow""`When naming this, I specifically chose to make it a boolean.Until there is a way to error on redirect the other value simply has no meaning.> - `data -> body`Yeah, probably.",
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/23461,1184674921,2023-05-04T08:02:19Z,runtime/doc/lua.txt,"@@ -3349,4 +3349,194 @@ totable({f}, {...})                                       *vim.iter.totable()*     Return: ~         (table) ++==============================================================================+Lua module: net                                                      *lua-net*++download({url}, {path}, {opts})                           *vim.net.download()*+    Asynchronously download a file. To read the response metadata, such as+    headers and body, use |vim.net.fetch()|.++    Please carefully note the option differences with |vim.net.fetch()|,+    notably `redirect`.++    Example: >lua++     vim.net.download(""https://.../path/file"", ""~/.cache/download/location"", {+       on_complete = function ()+         vim.notify(""File Downloaded"", vim.log.levels.INFO)+       end+     })+<++    Parameters: ~+      ��� {url}   (string) url+      ��� {path}  (string) A download path, can be relative.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� method string|nil HTTP method to use. Defaults to GET.+                ��� headers HeaderTable | table<string, string | string[]> | nil Headers to set on+                  the request+                ��� redirect string|nil Redirect mode. Defaults to ""follow"".+                  Possible values are:+                  ��� ""follow"": Follow all redirects incurred when fetching a+                    resource.+                  ��� ""none"": Ignores redirect status.++                ��� data string|table|nil Data to send with the request. If a+                  table, it will be JSON encoded. vim.net does not currently+                  support form encoding.+                ��� on_complete fun()|nil Callback function when download+                  successfully completed.+                ��� on_err fun(err: string[])|nil An optional function recieving+                  a `stderr_buffered` string[] of curl stderr. Without+                  providing this function, |vim.net.download()| will+                  automatically raise an error to the user. See |on_stderr|+                  and `stderr_buffered`.++    Return: ~+        (number) jobid A job id. See |job-control|.++    See also: ~+      ��� |vim.net.fetch()|+      ��� |job-control|+      ��� man://curl++fetch({url}, {opts})                                         *vim.net.fetch()*+    Asynchronously make HTTP requests.++    Please carefully note the option differences with |vim.net.download()|,+    notably `redirect`.++    Example: >lua++     -- GET a url+     vim.net.fetch(""https://example.com/api/data"", {+       on_complete = function (response)+         -- Lets read the response!++         if response.ok then+           -- Read response text+           local body = response.text()+         else+       end+     })++     -- POST to a url, sending a table as JSON and providing an authorization header+     vim.net.fetch(""https://example.com/api/data"", {+       method = ""POST"",+       data = {+         key = value+       },+       headers = {+         Authorization = ""Bearer "" .. token+       },+       on_complete = function (response)+         -- Lets read the response!++         if response.ok then+           -- Read JSON response+           local table = response.json()+         else++         -- What went wrong?+         vim.print(response.status)+       end+     })+<++    Parameters: ~+      ��� {url}   (string) The request URL.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� method string|nil HTTP method to use. Defaults to GET.+                ��� headers HeaderTable | table<string, string | string[]> | nil Headers to set on+                  the request+                ��� redirect string|nil Redirect mode. Defaults to ""follow"".+                  Possible values are:+                  ��� ""follow"": Follow all redirects incurred when fetching a+                    resource.+                  ��� ""error"": Throw an error using on_err or vim.notify when+                    status is 3XX.++                ��� data string|table|nil Data to send with the request. If a+                  table, it will be JSON-encoded. vim.net does not currently+                  support form encoding.+                ��� on_complete fun(response: table)|nil Callback function when+                  request is completed successfully. The response has the+                  following keys:+                  ��� ok boolean Whether the request was successful (status+                    within 2XX range).+                  ��� headers fun(): HeaderTable Function returning a HeaderTable of response headers.+                  ��� text fun(): string|nil Function returning response body.+                    If method was HEAD, this is nil.+                  ��� json fun(opts: table|nil): table|nil Read the body as+                    JSON. Optionally accepts opts from |vim.json.decode|. Will+                    throw errors if body is not JSON-decodable. Nil if method+                    is HEAD.+                  ��� method string The http method used in the most recent HTTP+                    request.+                  ��� status number The numerical response code.+                  ��� size number The total amount of bytes that were+                    downloaded. This is the size of the body/data that was+                    transferred, excluding headers.+                  ��� http_version number HTTP version used in the request.++                ��� on_err fun(err: string[])|nil Function recieving a+                  `stderr_buffered` string[] of error. err is either curl+                  stderr or internal fetch() error. Without providing this+                  function, |vim.net.fetch()| will automatically raise the+                  error to the user. See |on_stderr| and `stderr_buffered`.++    Return: ~+        (number) jobid A job id.++    See also: ~+      ��� |vim.net.download()|+      ��� https://developer.mozilla.org/en-US/docs/Web/HTTP/Status+      ��� |job-control|+      ��� man://curl++HeaderTable:append({self}, {key}, {value})              *HeaderTable:append()*+    Append value to header.++    Parameters: ~+      ��� {self}  +      ��� {key}   (string) Non case-sensitive header name.++HeaderTable:get({self}, {key})                             *HeaderTable:get()*+    Get header values.++    Parameters: ~+      ��� {self}  +      ��� {key}   (string) Non case-sensitive header name.++    Return: ~+        string[]",majority of the headers have single value. I'd expect `:get()` to return the `string` like how it's actually transported in the http header. Most http library's Headers interface does that. ����,
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/23461,1184989177,2023-05-04T13:06:55Z,runtime/doc/lua.txt,"@@ -3349,4 +3349,194 @@ totable({f}, {...})                                       *vim.iter.totable()*     Return: ~         (table) ++==============================================================================+Lua module: net                                                      *lua-net*++download({url}, {path}, {opts})                           *vim.net.download()*+    Asynchronously download a file. To read the response metadata, such as+    headers and body, use |vim.net.fetch()|.++    Please carefully note the option differences with |vim.net.fetch()|,+    notably `redirect`.++    Example: >lua++     vim.net.download(""https://.../path/file"", ""~/.cache/download/location"", {+       on_complete = function ()+         vim.notify(""File Downloaded"", vim.log.levels.INFO)+       end+     })+<++    Parameters: ~+      ��� {url}   (string) url+      ��� {path}  (string) A download path, can be relative.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� method string|nil HTTP method to use. Defaults to GET.+                ��� headers HeaderTable | table<string, string | string[]> | nil Headers to set on+                  the request+                ��� redirect string|nil Redirect mode. Defaults to ""follow"".+                  Possible values are:+                  ��� ""follow"": Follow all redirects incurred when fetching a+                    resource.+                  ��� ""none"": Ignores redirect status.++                ��� data string|table|nil Data to send with the request. If a+                  table, it will be JSON encoded. vim.net does not currently+                  support form encoding.+                ��� on_complete fun()|nil Callback function when download+                  successfully completed.+                ��� on_err fun(err: string[])|nil An optional function recieving+                  a `stderr_buffered` string[] of curl stderr. Without+                  providing this function, |vim.net.download()| will+                  automatically raise an error to the user. See |on_stderr|+                  and `stderr_buffered`.++    Return: ~+        (number) jobid A job id. See |job-control|.++    See also: ~+      ��� |vim.net.fetch()|+      ��� |job-control|+      ��� man://curl++fetch({url}, {opts})                                         *vim.net.fetch()*+    Asynchronously make HTTP requests.++    Please carefully note the option differences with |vim.net.download()|,+    notably `redirect`.++    Example: >lua++     -- GET a url+     vim.net.fetch(""https://example.com/api/data"", {+       on_complete = function (response)+         -- Lets read the response!++         if response.ok then+           -- Read response text+           local body = response.text()+         else+       end+     })++     -- POST to a url, sending a table as JSON and providing an authorization header+     vim.net.fetch(""https://example.com/api/data"", {+       method = ""POST"",+       data = {+         key = value+       },+       headers = {+         Authorization = ""Bearer "" .. token+       },+       on_complete = function (response)+         -- Lets read the response!++         if response.ok then+           -- Read JSON response+           local table = response.json()+         else++         -- What went wrong?+         vim.print(response.status)+       end+     })+<++    Parameters: ~+      ��� {url}   (string) The request URL.+      ��� {opts}  (table|nil) Optional keyword arguments:+                ��� method string|nil HTTP method to use. Defaults to GET.+                ��� headers HeaderTable | table<string, string | string[]> | nil Headers to set on+                  the request+                ��� redirect string|nil Redirect mode. Defaults to ""follow"".+                  Possible values are:+                  ��� ""follow"": Follow all redirects incurred when fetching a+                    resource.+                  ��� ""error"": Throw an error using on_err or vim.notify when+                    status is 3XX.++                ��� data string|table|nil Data to send with the request. If a+                  table, it will be JSON-encoded. vim.net does not currently+                  support form encoding.+                ��� on_complete fun(response: table)|nil Callback function when+                  request is completed successfully. The response has the+                  following keys:+                  ��� ok boolean Whether the request was successful (status+                    within 2XX range).+                  ��� headers fun(): HeaderTable Function returning a HeaderTable of response headers.+                  ��� text fun(): string|nil Function returning response body.+                    If method was HEAD, this is nil.+                  ��� json fun(opts: table|nil): table|nil Read the body as+                    JSON. Optionally accepts opts from |vim.json.decode|. Will+                    throw errors if body is not JSON-decodable. Nil if method+                    is HEAD.+                  ��� method string The http method used in the most recent HTTP+                    request.+                  ��� status number The numerical response code.+                  ��� size number The total amount of bytes that were+                    downloaded. This is the size of the body/data that was+                    transferred, excluding headers.+                  ��� http_version number HTTP version used in the request.++                ��� on_err fun(err: string[])|nil Function recieving a+                  `stderr_buffered` string[] of error. err is either curl+                  stderr or internal fetch() error. Without providing this+                  function, |vim.net.fetch()| will automatically raise the+                  error to the user. See |on_stderr| and `stderr_buffered`.++    Return: ~+        (number) jobid A job id.++    See also: ~+      ��� |vim.net.download()|+      ��� https://developer.mozilla.org/en-US/docs/Web/HTTP/Status+      ��� |job-control|+      ��� man://curl++HeaderTable:append({self}, {key}, {value})              *HeaderTable:append()*+    Append value to header.++    Parameters: ~+      ��� {self}  +      ��� {key}   (string) Non case-sensitive header name.++HeaderTable:get({self}, {key})                             *HeaderTable:get()*+    Get header values.++    Parameters: ~+      ��� {self}  +      ��� {key}   (string) Non case-sensitive header name.++    Return: ~+        string[]","That's a bad api design tho. Return type should be consistent, it shouldn't return `string` or `string[]`.For example,Python has a `get_all` that always returns `string[]` and `get` that always returns `string`.Javascript has `get` that always returns `string` and `getSetCookie` always returns `string[]`.Golang has `get` that always returns `string`.Of course, they can also return `null` / `nil` / equivalent.",
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/23461,1185927205,2023-05-05T10:17:47Z,runtime/lua/vim/net.lua,"@@ -0,0 +1,533 @@+local M = {}++---@class HeaderTable+---@field private _storage table<string, string[]>+local HeaderTable = {}+HeaderTable.__index = HeaderTable++---@private+function HeaderTable.new(input_table)+  local instance = setmetatable({ _storage = {} }, HeaderTable)+  if input_table then+    instance:_from_table(input_table)+  end+  return instance+end++---@private+function HeaderTable:_normalize_key(key)+  return key:lower()+end++---@private+function HeaderTable:_from_table(input_table)+  for key, value in pairs(input_table) do+    local normalized_key = self:_normalize_key(key)+    if type(value) == 'string' then+      self._storage[normalized_key] = { value }+    elseif type(value) == 'table' then+      self._storage[normalized_key] = value+    else+      vim.notify('Invalid value type for key: ' .. key, vim.log.levels.ERROR)+    end+  end+end++---Set value of header.+---@param self HeaderTable HeaderTable Instance.+---@param value string[] | string Header value.+---@param key string Non case-sensitive header name.+function HeaderTable:set(key, value)+  local normalized_key = self:_normalize_key(key)+  if type(value) == 'string' then+    self._storage[normalized_key] = { value }+  elseif type(value) == 'table' then+    self._storage[normalized_key] = value+  else+    vim.notify('Invalid value type for key: ' .. key, vim.log.levels.ERROR)+  end+end++---Append value to header.+---@param self HeaderTable HeaderTable Instance.+---@param key string Non case-sensitive header name.+function HeaderTable:append(key, value)+  local normalized_key = self:_normalize_key(key)+  if self._storage[normalized_key] then+    table.insert(self._storage[normalized_key], value)+  else+    self._storage[normalized_key] = { value }+  end+end++---Get header values.+---@param self HeaderTable HeaderTable Instance.+---@param key string Non case-sensitive header name.+---@return string[] | string | nil","That's a bad api design tho. Return type should be consistent, it shouldn't return `string` or `string[]`.For example,Python:- `get` returns `string` -https://docs.python.org/3/library/email.message.html#email.message.EmailMessage.get- `get_all` returns `string[]` - https://docs.python.org/3/library/email.message.html#email.message.EmailMessage.get_allJavascript:- `get` returns `string` - https://developer.mozilla.org/en-US/docs/Web/API/Headers/get- `getSetCookie` returns `string[]` - https://developer.mozilla.org/en-US/docs/Web/API/Headers/getSetCookieGolang:- `get` returns `string` - https://pkg.go.dev/net/http#Header.Get- `values` returns `string[]` - https://pkg.go.dev/net/http#Header.Values Rust:- `get` returns `string` - https://docs.rs/http/latest/http/header/struct.HeaderMap.html#method.get- `get_all` returns `string` - https://docs.rs/http/latest/http/header/struct.HeaderMap.html#method.get_all",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23461,1185942861,2023-05-05T10:36:59Z,runtime/lua/vim/net.lua,"@@ -0,0 +1,533 @@+local M = {}++---@class HeaderTable+---@field private _storage table<string, string[]>+local HeaderTable = {}","This looks a lot like a [multimap](https://en.m.wikipedia.org/wiki/Multimap).  Maybe worth having this as `vim.multimap` or `vim.multidict`, similar to `vim.defaulttable` - instead of exposing a specialised HeaderTableIf it's even required. Maybe using `defaulttable` would be good enough too?",
40532058,mrshmllow,https://api.github.com/repos/neovim/neovim/pulls/23461,1185965965,2023-05-05T11:06:37Z,runtime/lua/vim/net.lua,"@@ -0,0 +1,533 @@+local M = {}++---@class HeaderTable+---@field private _storage table<string, string[]>+local HeaderTable = {}","the requirements are a multimap data structure with case-insensitive operations, and header concatenation (multiple values returned in `get()` are seperated by "", ""). Either `vim.multimap` includes that as an option or the `HeaderTable` stays as a wrapper.",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/23500,1186646175,2023-05-06T06:16:51Z,runtime/lua/vim/_watch.lua,"@@ -97,6 +97,29 @@ local function poll_internal(path, opts, callback, watches)   watches = watches or {     is_dir = true,   }+  watches.cancel = function()+    if watches.children then+      for _, w in pairs(watches.children) do+        w.cancel()+      end+    end+    if watches.handle then+      stop(watches.handle)+    end+  end++  if not watches.is_dir and opts.include_patterns then+    local matches = false+    for _, pattern in ipairs(opts.include_patterns) do",```suggestion    local matches = vim.iter(opts.include_patterns):any(function(pattern)        return path:match(pattern) )```,
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/23500,1186646566,2023-05-06T06:19:57Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -264,15 +264,27 @@ function M.register(reg, ctx)     end   end -  local watching = {}-  for _, w in ipairs(watch_regs) do-    if not watching[w.base_dir] then-      watching[w.base_dir] = true-      table.insert(-        cancels[client_id][reg.id],-        M._watchfunc(w.base_dir, { uvflags = { recursive = true } }, callback(w.base_dir))-      )+  for base_dir, watches in pairs(watch_regs) do+    local include_patterns = {}+    for _, w in ipairs(watches) do+      for _, p in ipairs(w.pattern) do+        table.insert(include_patterns, p)",```suggestion        include_patterns[#include_patterns + 1] =  p```,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/23490,1186717082,2023-05-06T16:19:02Z,cmake.deps/cmake/BuildLpeg.cmake,"@@ -1,4 +1,18 @@-list(APPEND LPEG_CMAKE_ARGS ""-DCMAKE_C_FLAGS:STRING=${DEPS_INCLUDE_FLAGS}"")+set(LPEG_INCLUDE_FLAGS ${DEPS_INCLUDE_FLAGS})++if(NOT USE_BUNDLED_LUAJIT AND NOT USE_BUNDLED_LUA)+  find_package(Luajit)+  if(LUAJIT_FOUND)+    string(CONCAT LPEG_INCLUDE_FLAGS ${DEPS_INCLUDE_FLAGS} "" -I${LUAJIT_INCLUDE_DIR}"")+  else()+    find_package(Lua 5.1)+    if(LUA_FOUND)+      string(CONCAT LPEG_INCLUDE_FLAGS ${DEPS_INCLUDE_FLAGS} "" -I${LUA_INCLUDE_DIR}"")+    endif()+  endif()+endif()++list(APPEND LPEG_CMAKE_ARGS -DCMAKE_C_FLAGS:STRING=${LPEG_INCLUDE_FLAGS})",Don't think the `STRING` is needed```suggestionlist(APPEND LPEG_CMAKE_ARGS -DCMAKE_C_FLAGS=${LPEG_INCLUDE_FLAGS})```,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/23514,1186828557,2023-05-07T10:47:18Z,src/nvim/CMakeLists.txt,"@@ -798,6 +798,10 @@ install(DIRECTORY ${BINARY_LIB_DIR}   DESTINATION ${CMAKE_INSTALL_LIBDIR}/nvim/   USE_SOURCE_PERMISSIONS) +install(DIRECTORY ${LUAJIT_RUNTIME}","Why? The main build is supposed to be independent of where luajit is, whether it's from the system or bundled.",
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/23558,1189126746,2023-05-09T20:59:57Z,test/functional/legacy/scroll_opt_spec.lua,"@@ -589,14 +589,7 @@ describe('smoothscroll', function()     -- Vim prefers to do so if we are scrolling a few lines only.     exec(""call setline(1, ['one', 'two', 'Line' .. (' with lots of text'->repeat(10)) .. ' end', 'four'])"")     feed('3Gztj')-    screen:expect([[-      <<<th lots of text with lots of text wit|-      h lots of text with lots of text with lo|-      ts of text with lots of text with lots o|-      f text with lots of text end            |-      ^four                                    |-                                              |-    ]])+    screen:expect_unchanged()","After changing the order of the tests before this, this now triggers an assert in screen.lua����:```test/functional/helpers.lua:244: test/functional/ui/screen.lua:656: _handle_grid_cursor_goto failed  payload: { ""grid_cursor_goto"", { 1, -5, 0 } }  error:   test/functional/ui/screen.lua:790: assertion failed!```https://github.com/neovim/neovim/blob/4e5061dba765df2a74ac4a8182f6e7fe21da125d/test/functional/ui/screen.lua#L790What is the significance of that assert @bfredl? Can it be that it is harmless here?",
40792180,smjonas,https://api.github.com/repos/neovim/neovim/pulls/23578,1190461797,2023-05-10T23:02:11Z,runtime/lua/vim/filetype/detect.lua,"@@ -1322,6 +1322,28 @@ function M.txt(bufnr)   end end +function M.typ(bufnr)+  if vim.g.filetype_typ then+    return vim.g.filetype_typ+  end++  local lines = table.concat(getlines(bufnr, 1, 200))",That won't work (only when the pattern is at the beginning of the string due to the `^`). Use `ipairs` to iterate over all lines instead (see other detection functions).,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/23606,1193710918,2023-05-15T11:36:27Z,runtime/lua/vim/treesitter/query.lua,"@@ -382,6 +382,36 @@ local predicate_handlers = {      return string_set[node_text]   end,++  ['has-ancestor?'] = function(match, _, _, predicate)+    local node = match[predicate[2]]+    if not node then+      return true+    end++    local ancestor_types = { unpack(predicate, 3) }+    node = node:parent()+    while node do+      if vim.tbl_contains(ancestor_types, node:type()) then","Just passing by, but can't this be made a lot faster by turning the `ancestor_type` into a map ?Something along those line:```luafor _, ty in ipairs(ancestor_types) do  map[ty] = trueend```And then use it directly here:```suggestion      if map[node:type()] then```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23606,1193718209,2023-05-15T11:43:44Z,runtime/lua/vim/treesitter/query.lua,"@@ -382,6 +382,36 @@ local predicate_handlers = {      return string_set[node_text]   end,++  ['has-ancestor?'] = function(match, _, _, predicate)+    local node = match[predicate[2]]+    if not node then+      return true+    end++    local ancestor_types = { unpack(predicate, 3) }+    node = node:parent()+    while node do+      if vim.tbl_contains(ancestor_types, node:type()) then+        return true+      end+      node = node:parent()+    end+    return false+  end,++  ['has-parent?'] = function(match, _, _, predicate)+    local node = match[predicate[2]]+    if not node then+      return true+    end++    local ancestor_types = { unpack(predicate, 3) }+    if vim.tbl_contains(ancestor_types, node:parent():type()) then","Not sure it's worth it here, as we're only doing this once (should be `list_contains`, though)?",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/23638,1193781226,2023-05-15T12:42:14Z,runtime/lua/vim/fs.lua,"@@ -73,10 +73,14 @@ function M.basename(file) end  ---@private-local function join_paths(...)+---@param ... string+---@return string+function M._join_paths(...)","No reason, it's worth adding. `lsp/log.lua` duplicates this somewhat. `join_paths` doesn't handle backslashes like `lsp/log.lua` does, not sure if it needs to.",X
31730729,luukvbaal,https://api.github.com/repos/neovim/neovim/pulls/23657,1196500289,2023-05-17T13:13:49Z,src/nvim/insexpand.c,"@@ -1960,6 +1961,16 @@ static bool set_ctrl_x_mode(const int c)   return retval; } +// Restore extmarks, should be called if the original text is restored.+static void ins_compl_undo_extmark(void)+{+  u_header_T *uhp = curbuf->b_u_curhead ? curbuf->b_u_curhead : curbuf->b_u_newhead;","Yeah not sure if it is feasible to manipulate the undo headers in such a way that it will always restore the extmarks properly, and not undo previous changes. Might be better to make a snapshot of all the extmarks and restore them along with the original text or something.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23670,1197828153,2023-05-18T13:28:03Z,src/nvim/api/options.c,"@@ -343,6 +343,7 @@ Dictionary nvim_get_option_info2(String name, Dict(option) *opts, Error *err)  /// Sets the global value of an option. ///+/// @deprecated",ideally these should move to `api/deprecated.c`,
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/23670,1197854049,2023-05-18T13:48:56Z,src/nvim/api/options.c,"@@ -343,6 +343,7 @@ Dictionary nvim_get_option_info2(String name, Dict(option) *opts, Error *err)  /// Sets the global value of an option. ///+/// @deprecated","Should we make functions like `access_option_value_for` non-static then, since those are needed by the deprecated functions?",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/23670,1197856902,2023-05-18T13:51:26Z,src/nvim/api/options.c,"@@ -343,6 +343,7 @@ Dictionary nvim_get_option_info2(String name, Dict(option) *opts, Error *err)  /// Sets the global value of an option. ///+/// @deprecated",Is `access_option_value_for` needed for anything else? If not then move to deprecated.c. Ideally we should eliminate these.,
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/23670,1197857709,2023-05-18T13:52:07Z,src/nvim/api/options.c,"@@ -343,6 +343,7 @@ Dictionary nvim_get_option_info2(String name, Dict(option) *opts, Error *err)  /// Sets the global value of an option. ///+/// @deprecated","> Is `access_option_value_for` needed for anything else? If not then move to deprecated.c. Ideally we should eliminate these.Yes, it's needed for `nvim_(get|set)_option_value`",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23670,1197859482,2023-05-18T13:53:38Z,src/nvim/api/options.c,"@@ -343,6 +343,7 @@ Dictionary nvim_get_option_info2(String name, Dict(option) *opts, Error *err)  /// Sets the global value of an option. ///+/// @deprecated",Which deprecated API uses it? I can only see it being used by new APIs.,
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/23670,1197861522,2023-05-18T13:55:19Z,src/nvim/api/options.c,"@@ -343,6 +343,7 @@ Dictionary nvim_get_option_info2(String name, Dict(option) *opts, Error *err)  /// Sets the global value of an option. ///+/// @deprecated",> Which deprecated API is it used by? I can only see it being used by new APIs.It's used by `set_option_to` which itself is deprecated since it's only used by other deprecated functions,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23615,1198376029,2023-05-18T22:55:07Z,test/busted/outputHandlers/nvim.lua,"@@ -1,10 +1,13 @@ local pretty = require 'pl.pretty' local global_helpers = require('test.helpers') --- Colors are disabled by default. #15610 local colors = setmetatable({}, {__index = function() return function(s) return s == nil and '' or tostring(s) end end}) if os.getenv ""TEST_COLORS"" then",Could default to true here if it's undefined. That avoids needing to change `cmake/RunTests.cmake`. That also keeps the semantics in one place.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23681,1199033299,2023-05-19T14:31:34Z,runtime/lua/vim/lsp/dynamic.lua,"@@ -0,0 +1,115 @@+local wf = require('vim.lsp._watchfiles')++--- @class lsp.DocumentFilter+--- @field language? string+--- @field scheme? string+--- @field pattern? string++--- @alias lsp.DocumentSelector lsp.DocumentFilter[]++--- @class lsp.Registration+--- @field id string+--- @field method string+--- @field registerOptions? any | lsp.StaticRegistrationOptions | lsp.TextDocumentRegistrationOptions++--- @alias lsp.RegistrationParams {registrations: lsp.Registration[]}++--- @class lsp.StaticRegistrationOptions+--- @field id? string++--- @class lsp.TextDocumentRegistrationOptions+--- @field documentSelector? lsp.DocumentSelector++--- @class lsp.Unregistration+--- @field id string+--- @field method string++--- @alias lsp.UnregistrationParams {unregisterations: lsp.Unregistration[]}++--- @class lsp.DynamicCapabilities+--- @field capabilities table<string, lsp.Registration[]>+local M = {}++function M.new()+  return setmetatable({ capabilities = {} }, { __index = M })+end++--- @param registrations lsp.Registration[]+function M:register(registrations)+  -- remove duplicates+  self:unregister(registrations)+  for _, reg in ipairs(registrations) do+    local method = reg.method+    if not self.capabilities[method] then+      self.capabilities[method] = {}+    end+    table.insert(self.capabilities[method], reg)+  end+end++--- @param unregisterations lsp.Unregistration[]+function M:unregister(unregisterations)+  for _, unreg in ipairs(unregisterations) do+    local method = unreg.method+    if not self.capabilities[method] then+      return+    end+    local id = unreg.id+    for i, reg in ipairs(self.capabilities[method]) do+      if reg.id == id then+        table.remove(self.capabilities[method], i)+        break+      end+    end+  end+end++--- @param method string+--- @param opts? {bufnr?: number}+function M:get(method, opts)+  opts = opts or {}+  opts.bufnr = opts.bufnr or vim.api.nvim_get_current_buf()+  for _, reg in ipairs(self.capabilities[method] or {}) do+    if not reg.registerOptions then+      return {}+    end+    local documentSelector = reg.registerOptions.documentSelector+    if not documentSelector then+      return reg.registerOptions+    end+    if M.match(opts.bufnr, documentSelector) then+      return reg.registerOptions+    end+  end+end++--- @param method string+--- @param opts? {bufnr?: number}+function M:supports(method, opts)+  return self:get(method, opts) ~= nil+end++--- @param bufnr number+--- @param documentSelector lsp.DocumentSelector+function M.match(bufnr, documentSelector)+  local ft = vim.api.nvim_buf_get_option(bufnr, 'filetype')",```suggestion  local ft = vim.bo[bufnr].filetype````nvim_buf_get_option` is about to be deprecated: https://github.com/neovim/neovim/pull/23670,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23681,1199034937,2023-05-19T14:33:11Z,runtime/lua/vim/lsp.lua,"@@ -6,6 +6,7 @@ local protocol = require('vim.lsp.protocol') local util = require('vim.lsp.util') local sync = require('vim.lsp.sync') local semantic_tokens = require('vim.lsp.semantic_tokens')+local dynamic = require('vim.lsp.dynamic')","I assume we want people to go through client.dynamic_capabilities, and not access vim.lsp.dynamic directly, so could you rename `dynamic.lua` to `_dynamic` and move the require call down to where it's used ( `dynamic_capabilities = require(""vim.lsp._dynamic"").new()` ) to make it lazy?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23685,1199597522,2023-05-20T11:04:46Z,test/functional/lua/fs_spec.lua,"@@ -266,6 +266,17 @@ describe('vim.fs', function()     end)   end) +  describe('joinpath()', function()+    it('works', function()+      eq('foo/bar/baz', exec_lua([[+        return vim.fs.joinpath('foo', 'bar', 'baz')+      ]], nvim_dir))+      eq('foo/bar/baz', exec_lua([[+        return vim.fs.joinpath('foo', '/bar/', '/baz')","Most path join implementations would return `/baz` for this input. E.g. https://docs.python.org/3/library/os.path.html#os.path.join : > If a segment is an absolute path (which on Windows requires both a drive and a root), then all previous segments are ignored and joining continues from the absolute path segment.We don't necessarily need to match that, but it raises the question: what will we do with `joinpath('c:/foo', 'c:/bar')` ? We have ""last full-path wins"" behavior only for Windows-style `c:/` absolute path args, but that's a special-case...",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/23670,1199724599,2023-05-21T08:52:34Z,src/nvim/api/deprecated.c,"@@ -522,3 +523,222 @@ Dictionary nvim_get_option_info(String name, Error *err) {   return get_vimoption(name, OPT_GLOBAL, curbuf, curwin, err); }++/// Sets the global value of an option.+///+/// @deprecated+/// @param channel_id+/// @param name     Option name+/// @param value    New option value+/// @param[out] err Error details, if any+void nvim_set_option(uint64_t channel_id, String name, Object value, Error *err)+  FUNC_API_SINCE(1)+{+  set_option_to(channel_id, NULL, SREQ_GLOBAL, name, value, err);+}++/// Gets the global value of an option.+///+/// @deprecated+/// @param name     Option name+/// @param[out] err Error details, if any+/// @return         Option value (global)+Object nvim_get_option(String name, Arena *arena, Error *err)+  FUNC_API_SINCE(1)+{+  return get_option_from(NULL, SREQ_GLOBAL, name, err);+}++/// Gets a buffer option value+///+/// @deprecated+/// @param buffer     Buffer handle, or 0 for current buffer+/// @param name       Option name+/// @param[out] err   Error details, if any+/// @return Option value+Object nvim_buf_get_option(Buffer buffer, String name, Arena *arena, Error *err)+  FUNC_API_SINCE(1)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return (Object)OBJECT_INIT;+  }++  return get_option_from(buf, SREQ_BUF, name, err);+}++/// Sets a buffer option value. Passing `nil` as value deletes the option (only+/// works if there's a global fallback)+///+/// @deprecated+/// @param channel_id+/// @param buffer     Buffer handle, or 0 for current buffer+/// @param name       Option name+/// @param value      Option value+/// @param[out] err   Error details, if any+void nvim_buf_set_option(uint64_t channel_id, Buffer buffer, String name, Object value, Error *err)+  FUNC_API_SINCE(1)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if (!buf) {+    return;+  }++  set_option_to(channel_id, buf, SREQ_BUF, name, value, err);+}++/// Gets a window option value+///+/// @deprecated+/// @param window   Window handle, or 0 for current window+/// @param name     Option name+/// @param[out] err Error details, if any+/// @return Option value+Object nvim_win_get_option(Window window, String name, Arena *arena, Error *err)+  FUNC_API_SINCE(1)+{+  win_T *win = find_window_by_handle(window, err);++  if (!win) {+    return (Object)OBJECT_INIT;+  }++  return get_option_from(win, SREQ_WIN, name, err);+}++/// Sets a window option value. Passing `nil` as value deletes the option (only+/// works if there's a global fallback)+///+/// @deprecated+/// @param channel_id+/// @param window   Window handle, or 0 for current window+/// @param name     Option name+/// @param value    Option value+/// @param[out] err Error details, if any+void nvim_win_set_option(uint64_t channel_id, Window window, String name, Object value, Error *err)+  FUNC_API_SINCE(1)+{+  win_T *win = find_window_by_handle(window, err);++  if (!win) {+    return;+  }++  set_option_to(channel_id, win, SREQ_WIN, name, value, err);+}++/// Gets the value of a global or local (buffer, window) option.+///+/// @param from If `type` is `SREQ_WIN` or `SREQ_BUF`, this must be a pointer+///        to the window or buffer.+/// @param type One of `SREQ_GLOBAL`, `SREQ_WIN` or `SREQ_BUF`+/// @param name The option name+/// @param[out] err Details of an error that may have occurred+/// @return the option value+static Object get_option_from(void *from, int type, String name, Error *err)+{+  Object rv = OBJECT_INIT;++  VALIDATE_S(name.size > 0, ""option name"", ""<empty>"", {+    return rv;+  });++  // Return values+  int64_t numval;+  char *stringval = NULL;++  int flags = get_option_value_strict(name.data, &numval, &stringval, type, from);+  VALIDATE_S(flags != 0, ""option name"", name.data, {+    return rv;+  });++  if (flags & SOPT_BOOL) {+    rv.type = kObjectTypeBoolean;+    rv.data.boolean = numval ? true : false;+  } else if (flags & SOPT_NUM) {+    rv.type = kObjectTypeInteger;+    rv.data.integer = numval;+  } else if (flags & SOPT_STRING) {+    if (!stringval) {+      api_set_error(err, kErrorTypeException, ""Failed to get option '%s'"", name.data);+      return rv;+    }+    rv.type = kObjectTypeString;+    rv.data.string.data = stringval;+    rv.data.string.size = strlen(stringval);+  } else {+    api_set_error(err, kErrorTypeException, ""Unknown type for option '%s'"", name.data);+  }++  return rv;+}++/// Sets the value of a global or local (buffer, window) option.+///+/// @param to If `type` is `SREQ_WIN` or `SREQ_BUF`, this must be a pointer+///        to the window or buffer.+/// @param type One of `SREQ_GLOBAL`, `SREQ_WIN` or `SREQ_BUF`+/// @param name The option name+/// @param[out] err Details of an error that may have occurred+void set_option_to(uint64_t channel_id, void *to, int type, String name, Object value, Error *err)","If this is needed for non-deprecated API, then it shouldn't be in deprecated.c, otherwise it should be static.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23694,1199726554,2023-05-21T09:04:59Z,runtime/doc/lsp.txt,"@@ -619,19 +619,44 @@ to the callback in the ""data"" table. The token fields are documented in Note: doing anything other than calling |vim.lsp.semantic_tokens.highlight_token()| is considered experimental. -Also the following |User| |autocommand|s are provided:++LspRequest                                                        *LspRequest*","for completeness these LspX events should also be listed in `:help events`, even if the full docs live here.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/23426,1200290846,2023-05-22T10:04:49Z,src/nvim/drawline.c,"@@ -1723,7 +1749,87 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange,         area_active = false;       } -      if (!wlv.n_extra) {+      if (has_decor && v >= 0) {",Can this whole block be factored into a function. `win_line()` is bad enough as it is.,
56817415,nullchilly,https://api.github.com/repos/neovim/neovim/pulls/23701,1200422487,2023-05-22T12:04:54Z,src/nvim/option.c,"@@ -3336,8 +3336,8 @@ void set_tty_background(const char *value)   if (starting) {     // Wait until after startup, so OptionSet is triggered.     do_cmdline_cmd((value[0] == 'l')-                   ? ""autocmd VimEnter * ++once ++nested set bg=light""-                   : ""autocmd VimEnter * ++once ++nested set bg=dark"");+                   ? ""autocmd VimEnter * ++once ++nested if &bg == '' | set bg=light | endif""",I personally can't reproduce the original issueDo you know how to write a test for this racing condition?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23401,1200518876,2023-05-22T13:27:49Z,runtime/lua/vim/ui.lua,"@@ -104,4 +104,49 @@ function M.input(opts, on_confirm)   end end +--- Opens a URI by sending it to the system's default handler.+--- This function utilizes `xdg-open`, `wslview` / `start`, or `open` commands+--- depending on the system to open the provided URI.+---+---+---@param uri string Uri to be opened+---+---@return string returns the string output of the command. See |system()|.+---+--- Example:+--- <pre>lua+--- vim.ui.open_uri(""https://neovim.io/"")+---+--- vim.ui.open_uri(""/path/to/file"")+--- </pre>+function M.open_uri(uri)+  local cmd++  if vim.fn.has(""wsl"") then+    cmd = ""wslview""+  elseif vim.fn.has(""mac"") then+    cmd = 'open'+  elseif vim.fn.has(""win32"") then+    cmd = ""start""+  else -- Assume linux+    cmd = 'xdg-open'","Should still check executable(xdg-open) as in https://github.com/folke/lazy.nvim/blob/6610b15dfd76f7992423916e2b87f031881d7b25/lua/lazy/util.lua#L13-L44 , else user could see a confusing error.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/23401,1200566051,2023-05-22T14:04:44Z,runtime/lua/vim/ui.lua,"@@ -104,4 +104,49 @@ function M.input(opts, on_confirm)   end end +--- Opens a URI by sending it to the system's default handler.+--- This function utilizes `xdg-open`, `wslview` / `start`, or `open` commands+--- depending on the system to open the provided URI.+---+---+---@param uri string Uri to be opened+---+---@return string returns the string output of the command. See |system()|.+---+--- Example:+--- <pre>lua+--- vim.ui.open_uri(""https://neovim.io/"")+---+--- vim.ui.open_uri(""/path/to/file"")+--- </pre>+function M.open_uri(uri)+  local cmd++  if vim.fn.has(""wsl"") then+    cmd = ""wslview""+  elseif vim.fn.has(""mac"") then+    cmd = 'open'+  elseif vim.fn.has(""win32"") then+    cmd = ""start""+  else -- Assume linux+    cmd = 'xdg-open'+  end++  local ret = vim.fn.system({","Better to use `jobstart` here. `vim.fn.system` sometimes fails for unknown reasons. See here for example https://github.com/folke/lazy.nvim/issues/18```lua  local ret = vim.fn.jobstart(cmd, { detach = true })  if ret <= 0 then    local msg = {      ""Failed to open uri"",      ret,      vim.inspect(cmd),    }    vim.notify(table.concat(msg, ""\n""), vim.log.levels.ERROR)  end```",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/23401,1200576418,2023-05-22T14:13:03Z,runtime/lua/vim/ui.lua,"@@ -104,4 +104,49 @@ function M.input(opts, on_confirm)   end end +--- Opens a URI by sending it to the system's default handler.+--- This function utilizes `xdg-open`, `wslview` / `start`, or `open` commands+--- depending on the system to open the provided URI.+---+---+---@param uri string Uri to be opened+---+---@return string returns the string output of the command. See |system()|.+---+--- Example:+--- <pre>lua+--- vim.ui.open_uri(""https://neovim.io/"")+---+--- vim.ui.open_uri(""/path/to/file"")+--- </pre>+function M.open_uri(uri)+  local cmd++  if vim.fn.has(""wsl"") then+    cmd = ""wslview""+  elseif vim.fn.has(""mac"") then+    cmd = 'open'+  elseif vim.fn.has(""win32"") then+    cmd = ""start""+  else -- Assume linux+    cmd = 'xdg-open'+  end++  local ret = vim.fn.system({","I accidentally requested changes, but these are obviously more suggestions",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/23711,1201932934,2023-05-23T09:43:37Z,runtime/doc/news.txt,"@@ -30,6 +30,8 @@ The following changes may require adaptations in user config or plugins.     set mousemodel=popup     set keymodel=startsel,stopsel <+��� |CursorMoved| autocommand now triggers on the next main loop iteration rather+  than immediately when switching windows. This is more compatible with Vim.","When the cursor is moved to a different window, `CursorMoved` will only be triggered **after** I move the cursor within the new window, right? i.e. it will no longer be triggered as soon as I enter the window? The aforementioned ""setting up highlights and some other visual elements"" should happen as soon as I enter the window, hence why I think `WinEnter` will be necessary - because `CursorMoved` would no longer be useful for detecting when the active window changes.",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/23711,1202012174,2023-05-23T10:20:39Z,runtime/doc/news.txt,"@@ -30,6 +30,8 @@ The following changes may require adaptations in user config or plugins.     set mousemodel=popup     set keymodel=startsel,stopsel <+��� |CursorMoved| autocommand now triggers on the next main loop iteration rather+  than immediately when switching windows. This is more compatible with Vim.","I think the documentation changes from the latest pushes helped in clarifying this point. Suppose that I have this autocommand:```vimautocmd CursorMoved * call SetupHighlights()```I want SetupHighlights to be called1 - When I change the cursor's position within the current window2 - When I move the cursor to a different windowAfter this PR, 2 will no longer occur **immediately**, only when Neovim resumes the main loop. The difference is, if I have:```vimfunction! Foo()  call MoveCursorToAnotherWindow()  call DoSomething()endfunction```Upon calling Foo(), SetupHighlights() would not be triggered after MoveCursorToAnotherWindow() because `CursorMoved` is not triggered immediately. `CursorMoved` will only be fired at the end of Foo(), when Neovim would go back to the main loop. In other words, it's still possible to detect active window changes with `CursorMoved`, but the event will no longer be fired immediately. Is that correct? If it is, I suppose `WinEnter` is not needed for the highlights use-case.The new text is clearer, but it has a typo. It says ""back the main loop"", but it should be ""back to the main loop"" or ""back in the main loop"".",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/23736,1204633540,2023-05-24T18:54:00Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,176 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- [ ] resolve stuff+-- ]]++local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++function M.save(hints, bufnr, client_id, version)+  if not hints then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  -- To reduce flicker, preserve old resolved hints until new ones are resolved.++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #hints+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = version+    return+  end++  for _, hint in ipairs(hints) do+    local lnum = hint.position.line+    table.insert(new_hints_by_lnum[lnum], hint)+  end++  for lnum, _ in pairs(hints_by_lnum) do+    if not next(new_hints_by_lnum[lnum]) then+      hints_by_lnum[lnum] = nil+    end+  end++  local countdown = function()+    num_unprocessed = num_unprocessed - 1+    if num_unprocessed == 0 then+      bufstate.version = version+      vim.cmd('redraw!')+    end+  end++  local redraw = false+  for lnum, new_line_hints in pairs(new_hints_by_lnum) do+    local num_unresolved = 0+    for _, hint in pairs(new_line_hints) do+      if not hint.command then+        num_unresolved = num_unresolved + 1+      end+    end+    local current_line_hints = hints_by_lnum[lnum]+    if not next(current_line_hints or {}) then+      hints_by_lnum[lnum] = new_line_hints+      redraw = true+    end+    for _, hint in pairs(new_line_hints) do+      if hint.command then+        countdown()+      else+        client.request('inlayHint/resolve', hint, function(_, result)+          if result and result.command then+            hint.command = result.command+          end+          num_unresolved = num_unresolved - 1+          if num_unresolved == 0 and current_line_hints then+            hints_by_lnum[lnum] = new_line_hints+          end+          countdown()+        end)","It looks like you're attempting to resolve `command` properties of hints here, but it doesn't seem like the result is actually used anywhere. We could save quite a bit of time (and this code would be quite a bit simpler) if we simply didn't attempt to resolve anything.In any case, I think you're looking for `command` in the wrong place. [According to the spec](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlayHintLabelPart), the `command` property is actually part of an `InlayHintLabelPart` which exists as a list of items on the `label` property of the hint.",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/23736,1204970804,2023-05-25T04:06:23Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,222 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+---@param hints lsp.InlayHint[]|nil (table) of lenses to store+---@param bufnr integer+---@param client_id integer+---@param version integer+function M.save(hints, bufnr, client_id, version)+  if not hints then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  -- To reduce flicker, preserve old resolved hints until new ones are resolved.++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #hints+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = version+    return+  end++  for _, hint in ipairs(hints) do+    local lnum = hint.position.line+    table.insert(new_hints_by_lnum[lnum], hint)+  end++  for lnum, _ in pairs(hints_by_lnum) do+    if not next(new_hints_by_lnum[lnum]) then+      hints_by_lnum[lnum] = nil+    end+  end++  local countdown = function()+    num_unprocessed = num_unprocessed - 1+    if num_unprocessed == 0 then+      bufstate.version = version+      vim.cmd('redraw!')+    end+  end++  local redraw = false+  for lnum, new_line_hints in pairs(new_hints_by_lnum) do+    local num_unresolved = 0+    for _, hint in pairs(new_line_hints) do+      if type(hint.label) == 'table' and not hint.label.command then+        num_unresolved = num_unresolved + 1+      end+    end+    local current_line_hints = hints_by_lnum[lnum]+    if not next(current_line_hints or {}) then+      hints_by_lnum[lnum] = new_line_hints+      redraw = true+    end+    for _, hint in pairs(new_line_hints) do+      if type(hint.label) == 'table' and hint.label.command then+        countdown()+      else+        client.request('inlayHint/resolve', hint, function(_, result)+          if result and type(result.label) == 'table' and result.label.command then+            hint.label.command = result.label.command+          end+          num_unresolved = num_unresolved - 1+          if num_unresolved == 0 and current_line_hints then+            hints_by_lnum[lnum] = new_line_hints+          end+          countdown()+        end)+      end+    end+  end+  if redraw then+    vim.cmd('redraw!')+  end+end++--- |lsp-handler| for the method `textDocument/inlayHint`+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  M.save(result, ctx.bufnr, ctx.client_id, ctx.version)+end++--- Refresh the inlay hints for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- Example:+--- <pre>vim+---   autocmd BufEnter,InsertLeave,BufWritePost <buffer> lua vim.lsp.inlay_hint.refresh()+--- </pre>+---+function M.refresh()+  local params = {+    textDocument = util.make_text_document_params(),+    range = {+      start = { line = 0, character = 0 },+      ['end'] = { line = vim.api.nvim_buf_line_count(0), character = 0 },+    },+  }+  vim.lsp.buf_request(0, 'textDocument/inlayHint', params)+end++---@private+local function resolve_bufnr(bufnr)+  return bufnr == 0 and api.nvim_get_current_buf() or bufnr+end++--- Clear the hints+---+---@param client_id integer|nil filter by client_id. All clients if nil+---@param bufnr integer|nil filter by buffer. All buffers if nil+function M.clear(client_id, bufnr)+  local buffers = bufnr and { resolve_bufnr(bufnr) } or vim.tbl_keys(hint_cache_by_buf)+  for _, iter_bufnr in pairs(buffers) do+    local bufstate = hint_cache_by_buf[iter_bufnr]+    local client_lens = (bufstate or {}).client_hint or {}+    local client_ids = client_id and { client_id } or vim.tbl_keys(client_lens)+    for _, iter_client_id in pairs(client_ids) do+      if bufstate then+        bufstate.client_hint[iter_client_id] = {}+      end+    end+  end+  vim.cmd('redraw!')+end++local namespace = api.nvim_create_namespace('vim_lsp_inlayhint')++api.nvim_set_decoration_provider(namespace, {+  on_win = function(_, _, bufnr, topline, botline)+    local bufstate = hint_cache_by_buf[bufnr]+    if not bufstate then+      return+    end++    if bufstate.version ~= vim.lsp.util.buf_versions[bufnr] then+      return+    end+    local hints_by_client = bufstate.client_hint+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)++    for i = topline, botline do+      for _, hints_by_lnum in pairs(hints_by_client) do+        local line_hints = hints_by_lnum[i] or {}+        for _, hint in pairs(line_hints) do+          local text",tip: for a `list-like` table use `iparis` not `pairs` .,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23736,1205095681,2023-05-25T07:17:58Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,239 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local handlers = require('vim.lsp.handlers')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+---@param hints lsp.InlayHint[]|nil (table) of lenses to store+---@param bufnr integer+---@param client_id integer+---@param version integer+function M.save(hints, bufnr, client_id, version)+  if not hints then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  -- To reduce flicker, preserve old resolved hints until new ones are resolved.++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #hints+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = version+    return+  end++  for _, hint in ipairs(hints) do+    local lnum = hint.position.line+    new_hints_by_lnum[lnum][#new_hints_by_lnum[lnum] + 1] = hint+  end++  for lnum, _ in pairs(hints_by_lnum) do+    if not next(new_hints_by_lnum[lnum]) then+      hints_by_lnum[lnum] = nil+    end+  end++  local countdown = function()+    num_unprocessed = num_unprocessed - 1+    if num_unprocessed == 0 then+      bufstate.version = version+      vim.cmd('redraw!')+    end+  end++  local redraw = false+  for lnum, new_line_hints in pairs(new_hints_by_lnum) do+    local num_unresolved = 0+    for _, hint in pairs(new_line_hints) do+      if not hint._resolved then+        num_unresolved = num_unresolved + 1+      end+    end+    local current_line_hints = hints_by_lnum[lnum]+    if not next(current_line_hints or {}) then+      hints_by_lnum[lnum] = new_line_hints+      redraw = true+    end+    for _, hint in pairs(new_line_hints) do+      if hint._resolved then+        countdown()+      else+        client.request('inlayHint/resolve', hint, function(err, result)+          if err then+            hint._resolved = false+            return+          end+          if result then+            hint.kind = result.kind and result.kind or hint.kind+            hint.textEdits = result.textEdits and result.textEdits or hint.textEdits+            hint.label = result.label and result.label or hint.label+          end+          hint._resolved = true+          num_unresolved = num_unresolved - 1+          if num_unresolved == 0 and current_line_hints then+            hints_by_lnum[lnum] = new_line_hints+          end+          countdown()+        end)+      end+    end+  end+  if redraw then+    vim.cmd('redraw!')+  end+end++--- |lsp-handler| for the method `textDocument/inlayHint`+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  M.save(result, ctx.bufnr, ctx.client_id, ctx.version)+end++---@private+local function resolve_bufnr(bufnr)+  return bufnr == 0 and api.nvim_get_current_buf() or bufnr+end++--- Refresh the inlay hints for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- Example:+--- <pre>vim+---   autocmd BufEnter,InsertLeave,BufWritePost <buffer> lua vim.lsp.inlay_hint.refresh()+--- </pre>+---+function M.refresh(bufnr)+  bufnr = resolve_bufnr(bufnr or 0)+  local params = {+    textDocument = util.make_text_document_params(bufnr),+    range = {+      start = { line = 0, character = 0 },+      ['end'] = { line = api.nvim_buf_line_count(bufnr), character = 0 },+    },+  }+  vim.lsp.buf_request(bufnr, 'textDocument/inlayHint', params)+end++--- |lsp-handler| for the method `workspace/inlayHint/refresh`+---@see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_inlayHint_refresh+handlers['workspace/inlayHint/refresh'] = function(err, _, ctx)+  if err then+    return vim.NIL+  end++  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(ctx.client_id)) do+    M.refresh(bufnr)+  end++  return vim.NIL+end","Could you move this to the `handlers.lua` ? Doing this in a separate module breaks the existing pattern (and if the imports weren't lazy, it would cause cyclic issues)And I think it may be worth checking if the buffers are active in any window. Otherwise this could have a big performance impact if you've a lot of buffers open and it immediately refreshes all of them incluing resolve.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23736,1205098930,2023-05-25T07:21:04Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,239 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local handlers = require('vim.lsp.handlers')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+---@param hints lsp.InlayHint[]|nil (table) of lenses to store+---@param bufnr integer+---@param client_id integer+---@param version integer+function M.save(hints, bufnr, client_id, version)","```suggestionfunction M.set(hints, bufnr, client_id, version)```See `:h dev-naming`. I know this was taken from codelens, but the name unfortunately doesn't match usual naming conventions.Or maybe even remove this and inline it into `on_inlayhint`. Not sure if we need two APIs to set the hints",
36493671,p00f,https://api.github.com/repos/neovim/neovim/pulls/23736,1205109763,2023-05-25T07:31:26Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,239 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local handlers = require('vim.lsp.handlers')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+---@param hints lsp.InlayHint[]|nil (table) of lenses to store+---@param bufnr integer+---@param client_id integer+---@param version integer+function M.save(hints, bufnr, client_id, version)+  if not hints then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  -- To reduce flicker, preserve old resolved hints until new ones are resolved.++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #hints+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = version+    return+  end++  for _, hint in ipairs(hints) do+    local lnum = hint.position.line+    new_hints_by_lnum[lnum][#new_hints_by_lnum[lnum] + 1] = hint+  end++  for lnum, _ in pairs(hints_by_lnum) do+    if not next(new_hints_by_lnum[lnum]) then+      hints_by_lnum[lnum] = nil+    end+  end++  local countdown = function()+    num_unprocessed = num_unprocessed - 1+    if num_unprocessed == 0 then+      bufstate.version = version+      vim.cmd('redraw!')+    end+  end++  local redraw = false+  for lnum, new_line_hints in pairs(new_hints_by_lnum) do+    local num_unresolved = 0+    for _, hint in pairs(new_line_hints) do+      if not hint._resolved then+        num_unresolved = num_unresolved + 1+      end+    end+    local current_line_hints = hints_by_lnum[lnum]+    if not next(current_line_hints or {}) then+      hints_by_lnum[lnum] = new_line_hints+      redraw = true+    end+    for _, hint in pairs(new_line_hints) do+      if hint._resolved then+        countdown()+      else+        client.request('inlayHint/resolve', hint, function(err, result)+          if err then+            hint._resolved = false+            return+          end+          if result then+            hint.kind = result.kind and result.kind or hint.kind+            hint.textEdits = result.textEdits and result.textEdits or hint.textEdits+            hint.label = result.label and result.label or hint.label+          end+          hint._resolved = true+          num_unresolved = num_unresolved - 1+          if num_unresolved == 0 and current_line_hints then+            hints_by_lnum[lnum] = new_line_hints+          end+          countdown()+        end)+      end+    end+  end+  if redraw then+    vim.cmd('redraw!')+  end+end++--- |lsp-handler| for the method `textDocument/inlayHint`+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  M.save(result, ctx.bufnr, ctx.client_id, ctx.version)+end++---@private+local function resolve_bufnr(bufnr)+  return bufnr == 0 and api.nvim_get_current_buf() or bufnr+end++--- Refresh the inlay hints for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- Example:+--- <pre>vim+---   autocmd BufEnter,InsertLeave,BufWritePost <buffer> lua vim.lsp.inlay_hint.refresh()+--- </pre>+---+function M.refresh(bufnr)+  bufnr = resolve_bufnr(bufnr or 0)+  local params = {+    textDocument = util.make_text_document_params(bufnr),+    range = {+      start = { line = 0, character = 0 },+      ['end'] = { line = api.nvim_buf_line_count(bufnr), character = 0 },+    },+  }+  vim.lsp.buf_request(bufnr, 'textDocument/inlayHint', params)+end++--- |lsp-handler| for the method `workspace/inlayHint/refresh`+---@see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_inlayHint_refresh+handlers['workspace/inlayHint/refresh'] = function(err, _, ctx)+  if err then+    return vim.NIL+  end++  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(ctx.client_id)) do+    M.refresh(bufnr)+  end++  return vim.NIL+end","> Could you move this to the handlers.lua ? Doing this in a separate module breaks the existing pattern (and if the imports weren't lazy, it would cause cyclic issues)semantic tokens does this and none of the refresh ones are in handlers.lua so i did this, I'll move it �������� > And I think it may be worth checking if the buffers are active in any window. Otherwise this could have a big performance impact if you've a lot of buffers open and it immediately refreshes all of them incluing resolve.will do",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23736,1205124728,2023-05-25T07:45:27Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,239 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local handlers = require('vim.lsp.handlers')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+---@param hints lsp.InlayHint[]|nil (table) of lenses to store+---@param bufnr integer+---@param client_id integer+---@param version integer+function M.save(hints, bufnr, client_id, version)+  if not hints then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  -- To reduce flicker, preserve old resolved hints until new ones are resolved.++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #hints+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = version+    return+  end++  for _, hint in ipairs(hints) do+    local lnum = hint.position.line+    new_hints_by_lnum[lnum][#new_hints_by_lnum[lnum] + 1] = hint+  end++  for lnum, _ in pairs(hints_by_lnum) do+    if not next(new_hints_by_lnum[lnum]) then+      hints_by_lnum[lnum] = nil+    end+  end++  local countdown = function()+    num_unprocessed = num_unprocessed - 1+    if num_unprocessed == 0 then+      bufstate.version = version+      vim.cmd('redraw!')+    end+  end++  local redraw = false+  for lnum, new_line_hints in pairs(new_hints_by_lnum) do+    local num_unresolved = 0+    for _, hint in pairs(new_line_hints) do+      if not hint._resolved then+        num_unresolved = num_unresolved + 1+      end+    end+    local current_line_hints = hints_by_lnum[lnum]+    if not next(current_line_hints or {}) then+      hints_by_lnum[lnum] = new_line_hints+      redraw = true+    end+    for _, hint in pairs(new_line_hints) do+      if hint._resolved then+        countdown()+      else+        client.request('inlayHint/resolve', hint, function(err, result)+          if err then+            hint._resolved = false+            return+          end+          if result then+            hint.kind = result.kind and result.kind or hint.kind+            hint.textEdits = result.textEdits and result.textEdits or hint.textEdits+            hint.label = result.label and result.label or hint.label+          end+          hint._resolved = true+          num_unresolved = num_unresolved - 1+          if num_unresolved == 0 and current_line_hints then+            hints_by_lnum[lnum] = new_line_hints+          end+          countdown()+        end)+      end+    end+  end+  if redraw then+    vim.cmd('redraw!')+  end+end++--- |lsp-handler| for the method `textDocument/inlayHint`+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  M.save(result, ctx.bufnr, ctx.client_id, ctx.version)+end++---@private+local function resolve_bufnr(bufnr)+  return bufnr == 0 and api.nvim_get_current_buf() or bufnr+end++--- Refresh the inlay hints for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- Example:+--- <pre>vim+---   autocmd BufEnter,InsertLeave,BufWritePost <buffer> lua vim.lsp.inlay_hint.refresh()+--- </pre>+---+function M.refresh(bufnr)+  bufnr = resolve_bufnr(bufnr or 0)+  local params = {+    textDocument = util.make_text_document_params(bufnr),+    range = {+      start = { line = 0, character = 0 },+      ['end'] = { line = api.nvim_buf_line_count(bufnr), character = 0 },+    },+  }+  vim.lsp.buf_request(bufnr, 'textDocument/inlayHint', params)+end++--- |lsp-handler| for the method `workspace/inlayHint/refresh`+---@see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_inlayHint_refresh+handlers['workspace/inlayHint/refresh'] = function(err, _, ctx)+  if err then+    return vim.NIL+  end++  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(ctx.client_id)) do+    M.refresh(bufnr)+  end++  return vim.NIL+end","> semantic tokens does this and none of the refresh ones are in handlers.lua so i did this, I'll move itOh right. I suspect it does it because it also accesses some internals of the semantic token module.That weakens my point a bit. I'll leave it up to you.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/23750,1205182477,2023-05-25T08:33:49Z,scripts/lsp_types.lua,"@@ -0,0 +1,166 @@+--[[+Generates lua-ls annotations for lsp+USAGE:+nvim -V1 -es --clean +""lua require('scripts.lsp_types').gen('./lsp.json', 'runtime/lua/vim/lsp/generated_types.lua')""",Maybe change this to vim/lsp/types/protocol.luaAnd add a big comment on top that this is autogenerated with the command to regenerate them,
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/23736,1205317992,2023-05-25T10:28:32Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,222 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+---@param hints lsp.InlayHint[]|nil (table) of lenses to store+---@param bufnr integer+---@param client_id integer+---@param version integer+function M.save(hints, bufnr, client_id, version)+  if not hints then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  -- To reduce flicker, preserve old resolved hints until new ones are resolved.++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #hints+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = version+    return+  end++  for _, hint in ipairs(hints) do+    local lnum = hint.position.line+    table.insert(new_hints_by_lnum[lnum], hint)","Kindly refrain from making such stylistic suggestions without proper basis for it. Subjective discussions about style like these are distracting from other more important issues, not to mention it's also mildly annoying.1. If it makes a performance difference, show some (any) numbers for this concrete suggestion (i.e., a benchmark that shows that the code in question is noticeably faster after that change).2. If we care about the style, we should add it to a style guide and make it objective (""only use table.insert for nested tables"").3. Otherwise, let the PR author do what they like.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/23736,1205458274,2023-05-25T12:39:37Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,243 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- |lsp-handler| for the method `textDocument/inlayHint`+--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  local bufnr = ctx.bufnr","Right here, you could return if `util.buf_version[bufnr] ~= bufnr`. This can really help performance when the buffer changes while the response is being calculated by the server for a request from a previous version. The decoration provider doesn't use hints if the version doesn't match anyway, so why process the response? This is part of what I was talking about in the other comment.In the semantic tokens module, I tracked the most recent ""active"" request's version, but here we've added the associated version directly to the context. When a response arrives, the semantic token module only processes it if it's still valid and I think the same thing would work here.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/23736,1205461367,2023-05-25T12:42:20Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,253 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- |lsp-handler| for the method `textDocument/inlayHint`+--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  local bufnr = ctx.bufnr+  local client_id = ctx.client_id+  local version = ctx.version+  if not result then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  -- To reduce flicker, preserve old resolved hints until new ones are resolved.++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #result+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = version+    return+  end++  for _, hint in ipairs(result) do+    local lnum = hint.position.line+    table.insert(new_hints_by_lnum[lnum], hint)+  end++  for lnum, _ in pairs(hints_by_lnum) do+    if not next(new_hints_by_lnum[lnum]) then+      hints_by_lnum[lnum] = nil+    end+  end++  local countdown = function()+    num_unprocessed = num_unprocessed - 1+    if num_unprocessed == 0 then+      bufstate.version = version+      vim.cmd('redraw!')+    end+  end++  local redraw = false+  for lnum, new_line_hints in pairs(new_hints_by_lnum) do+    local num_unresolved = 0+    for _, hint in pairs(new_line_hints) do+      if not hint._resolved then+        num_unresolved = num_unresolved + 1+      end+    end+    local current_line_hints = hints_by_lnum[lnum]+    if not next(current_line_hints or {}) then+      hints_by_lnum[lnum] = new_line_hints+      redraw = true+    end+    for _, hint in pairs(new_line_hints) do+      if client.supports_method('inlayHint/resolve') then+        if hint._resolved then+          countdown()+        else+          client.request('inlayHint/resolve', hint, function(resolve_err, resolve_result)","Inside the callback, you should probably do the same thing. If the buffer version has changed, there's no point in processing this response any longer. Just return immediately. ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23751,1205596383,2023-05-25T14:22:07Z,runtime/lua/vim/diagnostic.lua,"@@ -132,8 +136,12 @@ local function prefix_source(diagnostics)   end, diagnostics) end ----@private-local function reformat_diagnostics(format, diagnostics)+--- Returns a copy of the diagnostics with their message reformatted.+---+---@param format string A formatting string.+---@param diagnostics table List of diagnostics |diagnostic-structure|.+---@return table[] diagnostics |diagnostic-structure|.+M.reformat_diagnostics = function (format, diagnostics)","If(!) this is exposed, it needs a more descriptive name following established naming guidelines.(It also needs a more descriptive description -- ""formatted"" _how_?)",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/23736,1205618613,2023-05-25T14:37:43Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,262 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++--- |lsp-handler| for the method `textDocument/inlayHint`+--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  local bufnr = ctx.bufnr+  local version = ctx.version+  if util.buf_versions[bufnr] ~= version then+    return+  end+  local client_id = ctx.client_id+  if not result then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  bufstate.version = version+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  -- To reduce flicker, preserve old resolved hints until new ones are resolved.++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #result+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    return+  end++  for _, hint in ipairs(result) do+    local lnum = hint.position.line+    table.insert(new_hints_by_lnum[lnum], hint)+  end++  for lnum, _ in pairs(hints_by_lnum) do+    if not next(new_hints_by_lnum[lnum]) then+      hints_by_lnum[lnum] = nil+    end+  end++  local countdown = function()+    num_unprocessed = num_unprocessed - 1+    if num_unprocessed == 0 then+      api.nvim__buf_redraw_range(bufnr, 0, -1)+    end+  end++  local redraw = false+  for lnum, new_line_hints in pairs(new_hints_by_lnum) do+    local num_unresolved = 0+    for _, hint in pairs(new_line_hints) do+      if not hint._resolved then+        num_unresolved = num_unresolved + 1+      end+    end+    local current_line_hints = hints_by_lnum[lnum]+    if not next(current_line_hints or {}) then+      hints_by_lnum[lnum] = new_line_hints+      redraw = true+    end+    for _, hint in pairs(new_line_hints) do+      if client.supports_method('inlayHint/resolve') then+        if hint._resolved then","is there a way to tell on the hint whether it even _needs_ resolving? Could save quite a bit of LSP chatter if we don't actually need anything on the hint that is unresolved. Which raises the same question I had earlier - are we actually using any of the resolved information from the hints, currently?If we had a way to know whether ""this hint has some additional information we could use that isn't here yet, let's resolve it"" ... that would be great! Looks like this PR always sends a resolve request for every single hint, but we don't use the resolved results at all.This would also make the hints available to the decoration provider _immediately_ instead of waiting for the resolve result to arrive, which I still think you should do (eg, update the cache with the new result unconditionally here, but simply update the existing one when the resolve comes in).",
629908,hrsh7th,https://api.github.com/repos/neovim/neovim/pulls/23750,1205705876,2023-05-25T15:40:30Z,runtime/lua/vim/lsp/types/protocol.lua,,"I just chose the `lsp.***.***` style like `---@class LSP.CompletionList.itemDefaults` in my Lua utility.The benefit of this style is that can be used the partial types on userland.If we choose the `Anonym` style, I think `lsp.Anonym` is better.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/23657,1206505528,2023-05-26T09:41:04Z,src/nvim/insexpand.c,"@@ -2528,6 +2533,15 @@ static void ins_compl_add_dict(dict_T *dict)   } } +/// Save extmarks in ""compl_orig_text"" so that they may be restored when the+/// completion is cancelled, or the original text is completed.+static void save_orig_extmarks(void)+{+  compl_orig_extmarks = extmark_get(curbuf, 0, curwin->w_cursor.lnum - 1, compl_col,","this copies and restores both ends of a paired extmark which is not what we want (this is going to make a bigger difference later, with proper extranges).Instead I'd suggest refactoring `u_extmark_copy` into two parts: a smaller part which just pushes `ExtmarkUndoObject` into a `extmark_undo_vec_t *` taken as a pointer, and a wrapper which does the ` u_force_get_undo_header` part. (or perhaps, just move that to the call site, as there only is one)Then we can make sure that the same underlying rules for saving/storing extmarks is the same as undo, even though we are not using undo headers here.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23736,1206562093,2023-05-26T10:27:21Z,runtime/lua/vim/lsp.lua,"@@ -2260,6 +2267,22 @@ function lsp.buf_get_clients(bufnr)   return result end +--- Toggle inlay hints for a buffer+---+--- @param bufnr (integer|nil): Buffer handle, or nil for current+function lsp.buf_inlay_hint_toggle(bufnr)","Sorry for the back and forth, but could you remove this again from this PR. We can follow up on these things later in dedicated PRs.I think the APIs will need some more discussions as there's quite a few choices to make. (Do we really want a mix of `buf_inlay_hint_*` and `inlay_hints.<xy>`. Do we mirror diagnostics with `.show()`, `.hide()`, `.enable()`, `.disable()`, or something else. Just to mention a few points)I'd like to keep the scope of this PR small, unless somebody thinks these things will impact the API of the functions that are being added here (`refresh()`, `clear()` and `on_inlayhint()`)(And it's a bit tedious to review a PR that keeps growing in scope, so I'd ask others to not treat this PR as a wishlist for things to add in addition, but maybe create an issue where we can track these things. Unless of course the feature would impact the design of what's being added here)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23736,1206574335,2023-05-26T10:37:30Z,runtime/lua/vim/lsp.lua,"@@ -2260,6 +2267,22 @@ function lsp.buf_get_clients(bufnr)   return result end +--- Toggle inlay hints for a buffer+---+--- @param bufnr (integer|nil): Buffer handle, or nil for current+function lsp.buf_inlay_hint_toggle(bufnr)","My original comment was mostly for lack of documentation.I agree that a generic/consistent API for such ""code overlays"" is preferable. (But I do think the ""toggle"" use case is prevalent enough for it to be part of such -- including for diagnostics! -- so users are not forced to write wrappers around `show()`/`hide()` over and over again...)",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/23736,1206732020,2023-05-26T12:49:37Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,224 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++M.disabled_buffers = {}++local namespace = api.nvim_create_namespace('vim_lsp_inlayhint')++--- |lsp-handler| for the method `textDocument/inlayHint`+--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  local bufnr = ctx.bufnr+  if util.buf_versions[bufnr] ~= ctx.version then+    return+  end+  local client_id = ctx.client_id+  if not result then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = ctx.version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        api.nvim_buf_clear_namespace(b, namespace, 0, -1)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        api.nvim_buf_clear_namespace(b, namespace, 0, -1)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #result+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = ctx.version+    api.nvim__buf_redraw_range(bufnr, 0, -1)+    return+  end++  local redraw = false++  for _, hint in ipairs(result) do+    local lnum = hint.position.line+    hint.position.character =+      util._get_line_byte_from_position(bufnr, hint.position, client.offset_encoding)+    table.insert(new_hints_by_lnum[lnum], hint)+  end++  for lnum, _ in pairs(hints_by_lnum) do+    if not next(new_hints_by_lnum[lnum]) then+      hints_by_lnum[lnum] = nil+    end+  end++  for lnum, new_line_hints in pairs(new_hints_by_lnum) do+    hints_by_lnum[lnum] = new_line_hints+    local current_line_hints = hints_by_lnum[lnum]+    if not next(current_line_hints or {}) then+      redraw = true+    end+  end++  bufstate.version = ctx.version+  if redraw then+    api.nvim__buf_redraw_range(bufnr, 0, -1)+  end+end","I _think_ you can make the entire body of this function only use one loop: updating the character offsets. The second part where you loop through the new hints twice looks like a remnant of the way it was done with resolve, but we aren't doing anything async anymore.After the character offset loop, I think you can just set the cache results for the buffer/client equal to that processed table. You could drop the `num_unprocessed` conditional near the top as well and unconditionally redraw at the end. This should help performance quite a bit. ",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/23736,1206819906,2023-05-26T13:51:37Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,219 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++-- [[+-- TODO:+-- [ ] only request for visible range+-- ]]+--+---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++local namespace = api.nvim_create_namespace('vim_lsp_inlayhint')++--- |lsp-handler| for the method `textDocument/inlayHint`+--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  local bufnr = ctx.bufnr+  if util.buf_versions[bufnr] ~= ctx.version then+    return+  end+  local client_id = ctx.client_id+  if not result then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = ctx.version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        api.nvim_buf_clear_namespace(b, namespace, 0, -1)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        api.nvim_buf_clear_namespace(b, namespace, 0, -1)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local hints_by_lnum = hints_by_client[client_id]+  local client = vim.lsp.get_client_by_id(client_id)++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #result+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = ctx.version+    api.nvim__buf_redraw_range(bufnr, 0, -1)+    return+  end++  local redraw = false++  for _, hint in ipairs(result) do+    local lnum = hint.position.line+    hint.position.character =+      util._get_line_byte_from_position(bufnr, hint.position, client.offset_encoding)+    table.insert(new_hints_by_lnum[lnum], hint)+  end","Probably not as vital for inlay hints (there should be a lot less of these than semantic tokens), but take a look at how I did this conversion there. If you cache the buffer contents once at the top and use `util._str_byteindex_enc()` for each line/char, it is a _massive_ speedup (like 10x in my testing).",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/23681,1207705760,2023-05-27T06:02:09Z,runtime/doc/news.txt,"@@ -36,6 +36,8 @@ ADDED FEATURES                                                     *news-added*  The following new APIs or features were added. +��� Dynamic registration of LSP capabilities+",```suggestion��� Dynamic registration of LSP capabilities. An implication of this change is that checking a client's `server_capabilities` is no longer a sufficient indicator to see if a server supports a feature. Instead use `client.supports_method(<method>)`. It considers both the dynamic capabilities and static `server_capabilities`.```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22846,1208056780,2023-05-27T16:37:38Z,runtime/doc/lua.txt,"@@ -447,29 +447,29 @@ Note that underscore-prefixed functions (e.g. ""_os_proc_children"") are internal/private and must not be used by plugins.  -------------------------------------------------------------------------------VIM.LOOP                                                   *lua-loop* *vim.loop*+VIM.UV                                                   *lua-loop* *vim.uv* -`vim.loop` exposes all features of the Nvim event-loop. This is a low-level+`vim.uv` exposes all features of the Nvim event-loop. This is a low-level API that provides functionality for networking, filesystem, and process management. Try this command to see available functions: >vim -    :lua print(vim.inspect(vim.loop))+    :lua print(vim.inspect(vim.uv)) <-Internally, `vim.loop` wraps the ""luv"" Lua bindings for the LibUV library;+Internally, `vim.uv` wraps the ""luv"" Lua bindings for the LibUV library; see |luv-intro| for a full reference manual.","With the name change, I think this paragraph should be rewritten along the lines of ""`vim.uv` exposes the ""luv"" Lua bindings for the libUV library that Nvim uses for networking, filesystem, and process management, see |luvref.txt|. In particular, it allows interacting with the main Nvim |luv-event-loop|.""(No need for the vimscript snippet, now that we have a full reference manual.)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/23771,1208548495,2023-05-28T13:20:57Z,src/nvim/eval/typval.h,"@@ -18,73 +18,9 @@ #include ""nvim/message.h"" #include ""nvim/types.h"" -#ifdef LOG_LIST_ACTIONS-# include ""nvim/memory.h""--extern ListLog *list_log_first;  ///< First list log chunk, NULL if missing-extern ListLog *list_log_last;  ///< Last list log chunk--static inline ListLog *list_log_alloc(const size_t size)-  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_WARN_UNUSED_RESULT;--/// Allocate a new log chunk and update globals-///-/// @param[in]  size  Number of entries in a new chunk.-///-/// @return [allocated] Newly allocated chunk.-static inline ListLog *list_log_new(const size_t size)-{-  ListLog *ret = xmalloc(offsetof(ListLog, entries)-                         + size * sizeof(ret->entries[0]));-  ret->size = 0;-  ret->capacity = size;-  ret->next = NULL;-  if (list_log_first == NULL) {-    list_log_first = ret;-  } else {-    list_log_last->next = ret;-  }-  list_log_last = ret;-  return ret;-}--static inline void list_log(const list_T *const l, const listitem_T *const li1,-                            const listitem_T *const li2, const char *const action)-  REAL_FATTR_ALWAYS_INLINE;--/// Add new entry to log-///-/// If last chunk was filled it uses twice as much memory to allocate the next-/// chunk.-///-/// @param[in]  l  List to which entry belongs.-/// @param[in]  li1  List item 1.-/// @param[in]  li2  List item 2, often used for integers and not list items.-/// @param[in]  action  Logged action.-static inline void list_log(const list_T *const l, const listitem_T *const li1,-                            const listitem_T *const li2, const char *const action)-{-  ListLog *tgt;-  if (list_log_first == NULL) {-    tgt = list_log_new(128);-  } else if (list_log_last->size == list_log_last->capacity) {-    tgt = list_log_new(list_log_last->capacity * 2);-  } else {-    tgt = list_log_last;-  }-  tgt->entries[tgt->size++] = (ListLogEntry) {-    .l = (uintptr_t)l,-    .li1 = (uintptr_t)li1,-    .li2 = (uintptr_t)li2,-    .len = (l == NULL ? 0 : l->lv_len),-    .action = action,-  };-}-#else-# define list_log(...)-# define list_write_log(...)-# define list_free_log()-#endif+#define list_log(...)",I think we should remove the individual `list_log` calls as well.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22846,1209989707,2023-05-30T09:18:56Z,runtime/doc/news.txt,"@@ -80,6 +80,9 @@ The following changes to existing APIs or features add new behavior. ��� The `workspace/didChangeWatchedFiles` LSP client capability is now enabled   by default. +��� `vim.loop` has been renamed to `vim.uv`. `vim.loop` will be deprecated and","I think this fits better under ""DEPRECATIONS"" -- no need to mention that it will be deprecated than (as it arguably already is).",
5160701,seblj,https://api.github.com/repos/neovim/neovim/pulls/23845,1210861547,2023-05-30T21:54:50Z,runtime/lua/vim/iter.lua,"@@ -51,6 +51,8 @@ --- In addition to the |vim.iter()| function, the |vim.iter| module provides --- convenience functions like |vim.iter.filter()| and |vim.iter.totable()|. +---@class IterMod","I just picked a name since `local Iter = {}` has `---@class Iter` and it is different from the module returned. It will probably be issues if there are two tables with the same classname, and it's wrong to say that the class `Iter`'s metamethod `__call` returns `Iter`. I am open to other names though",X
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/23681,1211130169,2023-05-31T06:07:20Z,runtime/doc/news.txt,"@@ -36,6 +36,7 @@ ADDED FEATURES                                                     *news-added*  The following new APIs or features were added. +��� Dynamic registration of LSP capabilities. An implication of this change is that checking a client's `server_capabilities` is no longer a sufficient indicator to see if a server supports a feature. Instead use `client.supports_method(<method>)`. It considers both the dynamic capabilities and static `server_capabilities`.","Thank you very much for working on this, it's really exciting! It would be good to have a good alternative to dynamically react to server capabilities though.For example, in order to conditionally add a mapping for `textDocument/hover`, I used to check server_capabilities in the `LspAttach` callback, and now I have to override the handler for `client/registerCapability`, and we actually need to do both to account for servers that don't support dynamic registration. Basically, this will lead to some duplication between LspAttach and the handler for `client/registerCapability`, similar to what you had to do for `lsp._set_defaults`.Personally, I think the duplication isn't too bad (can just create a shared function and call from both places), what's annoying is having to override the handler. It works, but I wonder if you have any plans/ideas on how to improve it?Thank you again!",X
32371757,jwhite510,https://api.github.com/repos/neovim/neovim/pulls/23611,1213108335,2023-06-01T12:52:06Z,src/nvim/linematch.c,"@@ -354,34 +335,67 @@ size_t linematch_nbuffers(const char **diff_blk, const int *diff_len, const size   size_t memsize_decisions = 0;   for (size_t i = 0; i < ndiffs; i++) {     assert(diff_len[i] >= 0);-    memsize *= i == 0 ? 2 : (size_t)(diff_len[i] + 1);+    memsize *= (size_t)(diff_len[i] + 1);     memsize_decisions += (size_t)diff_len[i];   }    // create the flattened path matrix   diffcmppath_T *diffcmppath = xmalloc(sizeof(diffcmppath_T) * memsize);","this is where it will crash, `memsize` gets much larger. any idea on a trigger to disable the grouping optimization when some limit is exceeded? something like ""if `memsize` gets larger than some value, disable the grouping optimization and use the space optimization""",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23827,1214217400,2023-06-02T10:47:43Z,runtime/doc/lua.txt,"@@ -1571,6 +1571,75 @@ schedule_wrap({cb})                                      *vim.schedule_wrap()*       ��� |vim.schedule()|       ��� |vim.in_fast_event()| +system({spec}, {on_exit})                                       *vim.system()*+    Run a system command++    Examples: >lua++      local on_exit = function(code, signal, stdout, stderr)+        print(code)+        print(signal)+        print(stdout)+        print(stderr)+      end++      -- Run asynchronously+      vim.system({'echo', 'hello'}, on_exit)+      vim.system({cmd = {'echo', 'hello'}}, on_exit)+      vim.system({cmd = 'echo', args = {'hello'}}, on_exit)",Nice shape! It's a good pattern for the callback to be the last arg because it tends to be lexically more noisy than other args.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23827,1214223424,2023-06-02T10:54:03Z,runtime/doc/lua.txt,"@@ -1571,6 +1571,75 @@ schedule_wrap({cb})                                      *vim.schedule_wrap()*       ��� |vim.schedule()|       ��� |vim.in_fast_event()| +system({spec}, {on_exit})                                       *vim.system()*+    Run a system command++    Examples: >lua++      local on_exit = function(code, signal, stdout, stderr)","- as @wsdjeg suggested, is the pid worth including as an arg?- probably worth passing these args as a dict (named `event` or `args`?) instead of order-sensitive parameters? that seems like a good pattern whenever we anticipate callbacks that have more than ~3 args",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23827,1215983199,2023-06-04T00:26:14Z,runtime/doc/lua.txt,"@@ -1571,6 +1571,75 @@ schedule_wrap({cb})                                      *vim.schedule_wrap()*       ��� |vim.schedule()|       ��� |vim.in_fast_event()| +system({spec}, {on_exit})                                       *vim.system()*+    Run a system command++    Examples: >lua++      local on_exit = function(code, signal, stdout, stderr)+        print(code)+        print(signal)+        print(stdout)+        print(stderr)+      end++      -- Run asynchronously+      vim.system({'echo', 'hello'}, on_exit)+      vim.system({cmd = {'echo', 'hello'}}, on_exit)+      vim.system({cmd = 'echo', args = {'hello'}}, on_exit)++      -- Run synchronously+      local obj = vim.system({'echo', 'hello'}):wait()+      -- { code = 0, signal = 0, stdout = 'hello', stderr = '' }+<++    See |uv.spawn()| for more details.++    Parameters: ~+      ��� {spec}     (string[]|SystemSpec) When passed as a string array, the+                   argument is interpreted as a command. Accepts the options:+                   ��� cmd: (string|string[]) command to execute+                   ��� args: (string[]) Command line arguments. Ignored when cmd+                     is a string[]+                   ��� cwd: (string) Set the current working directory for the+                     sub-process.+                   ��� env: table<string,string> Set environment variables for+                     the new process.+                   ��� stdin: (string|string[]|true) If `true`, then a pipe to+                     stdin is opened and can be written to via the `write()`+                     method to SystemObj.+                   ��� stdout: (function|false) when passed as a function must+                     have the signature fun(err: string, data: string) Pass+                     `false` to disable.+                   ��� stderr: (function|false) when passed as a function must","These are handlers so they should use the `on_` convention, no? That's also consistent with rather strongly-established tradition for e.g. `jobstart`, and unless there's strong reason to deviate we should strongly prefer to avoid unnecessary entropy.```suggestion                   ��� on_stdout: (function|false) when passed as a function must                     have the signature fun(err: string, data: string) Pass                     `false` to disable.                   ��� on_stderr: (function|false) when passed as a function must```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23827,1215984748,2023-06-04T00:28:50Z,runtime/lua/vim/_system.lua,"@@ -0,0 +1,360 @@+local uv = vim.loop++--- @class SystemSpec+--- @field cmd string|string[]+--- @field args? string[]+--- @field stdin string|string[]|true+--- @field stdout fun(err:string, data: string)|false+--- @field stderr fun(err:string, data: string)|false+--- @field cwd? string+--- @field env? table<string,string|number>+--- @field timeout? integer Timeout in ms+--- @field detached? boolean++--- @class SystemCompleted+--- @field code integer+--- @field signal integer+--- @field stdout? string+--- @field stderr? string++--- @class SystemState+--- @field handle uv_process_t+--- @field timer uv_timer_t+--- @field pid integer+--- @field timeout? integer+--- @field done boolean+--- @field stdin uv_stream_t?+--- @field stdout uv_stream_t?+--- @field stderr uv_stream_t?+--- @field cmd string+--- @field args? string[]+--- @field result? SystemCompleted++---@private+---@param state SystemState+local function close_handles(state)+  for _, handle in pairs({ state.handle, state.stdin, state.stdout, state.stderr }) do+    if not handle:is_closing() then+      handle:close()+    end+  end+end++--- @param cmd string+--- @param args string[]?+--- @return SystemCompleted+local function timeout_result(cmd, args)+  local cmd_str = cmd .. ' ' .. table.concat(args or {}, ' ')+  local err = string.format(""Command timed out: '%s'"", cmd_str)+  return { code = 0, signal = 2, stdout = '', stderr = err }+end++--- @class SystemObj+--- @field pid integer+--- @field private _state SystemState+--- @field wait fun(self: SystemObj, timeout?: integer): SystemCompleted+--- @field kill fun(self: SystemObj, signal: integer)+--- @field write fun(self: SystemObj, data?: string|string[])+--- @field is_closing fun(self: SystemObj): boolean?+local SystemObj = {}++--- @param state SystemState+--- @return SystemObj+local function new_systemobj(state)+  return setmetatable({+    pid = state.pid,+    _state = state,+  }, { __index = SystemObj })+end++--- @param signal integer+function SystemObj:kill(signal)+  local state = self._state+  state.handle:kill(signal)+  close_handles(state)+end++local MAX_TIMEOUT = 2 ^ 31++--- @param timeout? integer+--- @return SystemCompleted+function SystemObj:wait(timeout)+  local state = self._state++  vim.wait(timeout or state.timeout or MAX_TIMEOUT, function()+    return state.done+  end)++  if not state.done then+    self:kill(6) -- 'sigint'+    state.result = timeout_result(state.cmd, state.args)+  end++  return state.result+end++--- @param data string[]|string|nil+function SystemObj:write(data)+  local stdin = self._state.stdin++  if not stdin then+    error('stdin has not been opened on this object')+  end++  if type(data) == 'table' then+    for _, v in ipairs(data) do+      stdin:write(v)+      stdin:write('\n')+    end+  elseif type(data) == 'string' then+    stdin:write(data)+  elseif data == nil then+    -- Shutdown the write side of the duplex stream and then close the pipe.+    -- Note shutdown will wait for all the pending write requests to complete+    -- TODO(lewis6991): apparently shutdown doesn't behave this way.+    -- (https://github.com/neovim/neovim/pull/17620#discussion_r820775616)+    stdin:write('', function()+      stdin:shutdown(function()+        if stdin then+          stdin:close()+        end+      end)+    end)+  end+end++--- @return boolean+function SystemObj:is_closing()+  local handle = self._state.handle+  return handle == nil or handle:is_closing()+end++--- @param spec string[]|SystemSpec+--- @return SystemSpec+local function process_spec(spec)+  if spec[1] then+    local cmd = {} --- @type string[]+    for _, p in ipairs(spec) do+      cmd[#cmd + 1] = p+    end+    spec = vim.deepcopy(spec)+    spec.cmd = cmd+  end++  return spec+end++---@private+---@param output function|'false'+---@return uv_stream_t?+---@return function? Handler+local function setup_output(output)+  if output == nil then+    return assert(uv.new_pipe(false)), nil+  end++  if type(output) == 'function' then+    return assert(uv.new_pipe(false)), output+  end++  assert(output == false)+  return nil, nil+end++---@private+---@param input string|string[]|true|nil+---@return uv_stream_t?+---@return string|string[]?+local function setup_input(input)+  if not input then+    return+  end++  local towrite --- @type string|string[]?+  if type(input) == 'string' or type(input) == 'table' then+    towrite = input+  end++  return assert(uv.new_pipe(false)), towrite+end++--- @param cmd string|string[]+--- @param args? string[]+--- @return string Command+--- @return string[]? Arguments+local function setup_cmd(cmd, args)+  if type(cmd) == 'string' then+    cmd = { cmd }+    if args then+      vim.list_extend(cmd, args)+    end+  end++  return cmd[1], vim.list_slice(cmd, 2)+end++--- uv.spawn will completely overwrite the environment+--- when we just want to modify the existing one, so if env is provided+--- make sure to prepopulate it with the current env.+--- @param env table<string,string|number>+--- @return string[]?+local function setup_env(env)+  if not env then+    return+  end++  --- @type table<string,string>+  local env0 = vim.tbl_extend('force', vim.fn.environ(), env)++  local renv = {} --- @type string[]+  for k, v in pairs(env0) do+    renv[#renv + 1] = string.format('%s=%s', k, tostring(v))+  end++  return renv+end++--- @param stream uv_stream_t+--- @param bucket string[]+--- @return fun(err: string?, data: string?)+local function default_handler(stream, bucket)+  return function(err, data)+    if err then+      error(err)+    end+    if data ~= nil then+      bucket[#bucket + 1] = data+    else+      stream:read_stop()+      stream:close()+    end+  end+end++local M = {}++--- @param cmd string+--- @param opts uv.aliases.spawn_options+--- @param on_exit fun(code: integer, signal: integer)+--- @param on_error fun()+--- @return uv_process_t, integer+local function spawn(cmd, opts, on_exit, on_error)+  local handle, pid_or_err = uv.spawn(cmd, opts, on_exit)","If this doesn't use the internals of `jobstart` then we probably need special handling similar to `:help jobstart-env`. In particular, unsetting `$NVIM_LISTEN_ADDRESS` is important. The others could be a backlog item (i.e. not a blocker for this PR).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23891,1215992649,2023-06-04T00:37:41Z,runtime/doc/ui.txt,"@@ -379,6 +379,8 @@ numerical highlight ids to the actual attributes. 	enough to cover the remaining line, will be sent when the rest of the 	line should be cleared. +	`wrap` is a boolean indicating whether this line wraps to the next row.",It's ok to brain-dump whatever you can for now. We can always tighten it up later.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23587,1216072185,2023-06-04T02:29:55Z,src/nvim/autocmd.c,"@@ -1972,6 +1973,7 @@ static bool call_autocmd_callback(const AutoCmd *ac, const AutoPatCmd *apc)     PUT(data, ""match"", CSTR_TO_OBJ(autocmd_match));     PUT(data, ""file"", CSTR_TO_OBJ(autocmd_fname));     PUT(data, ""buf"", INTEGER_OBJ(autocmd_bufnr));+    PUT(data, ""winid"", INTEGER_OBJ(apc->arg_winid));","in sympathy with `buf` (just above this line) should this be named `win` ?```suggestion    PUT(data, ""win"", INTEGER_OBJ(apc->arg_winid));```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23788,1217270056,2023-06-04T23:38:47Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -1,152 +1,80 @@ local bit = require('bit')+local lpeg = require('lpeg') local watch = require('vim._watch') local protocol = require('vim.lsp.protocol')  local M = {}  ---@private----Parses the raw pattern into a number of Lua-native patterns.+---Parses the raw pattern into an |lpeg| pattern.","worth a brief comment explaining the motivation:> since LPeg natively supports alternatives (match ""this"" or ""that""), then we can output a single LPeg pattern from a glob instead of a number of Lua patterns",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23720,1217331784,2023-06-05T01:37:50Z,test/functional/ex_cmds/excmd_spec.lua,"@@ -50,4 +52,22 @@ describe('Ex cmds', function()     eq(2, funcs.exists(':defer'))     eq('defer', funcs.fullcommand('defer'))   end)++  it(':.! should pipe line buffer to &shell', function()","these tests would fit best in `test/functional/vimscript/system_spec.lua` , here: https://github.com/neovim/neovim/blob/28f1f65bb30768db3423dc6eb39b2d75dfaba326/test/functional/vimscript/system_spec.lua#L632",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/23891,1219120651,2023-06-06T07:55:17Z,src/nvim/msgpack_rpc/unpacker.c,"@@ -441,7 +441,7 @@ bool unpacker_parse_redraw(Unpacker *p)   case 14:     NEXT_TYPE(tok, MPACK_TOKEN_ARRAY);     int eventarrsize = (int)tok.length;-    if (eventarrsize != 4) {+    if (eventarrsize != 5) {","Currently there are none, i e it's fine if nvim 0.10 TUI only works with nvim server 0.10. It is something which needs to be formalized in the long run (as client-server setup becomes more featureful and common, and hard requirement for the 1.0 milestone)",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/23850,1219147951,2023-06-06T08:13:05Z,src/nvim/eval/vars.c,"@@ -766,84 +766,84 @@ static char *ex_let_option(char *arg, typval_T *const tv, const bool is_const,       || (endchars != NULL           && vim_strchr(endchars, (uint8_t)(*skipwhite(p))) == NULL)) {     emsg(_(e_letunexp));-  } else {-    varnumber_T n = 0;-    getoption_T opt_type;-    long numval;-    char *stringval = NULL;-    const char *s = NULL;-    bool failed = false;-    uint32_t opt_p_flags;-    char *tofree = NULL;--    const char c1 = *p;-    *p = NUL;+    return NULL;+  } -    opt_type = get_option_value(arg, &numval, &stringval, &opt_p_flags, scope);-    if (opt_type == gov_bool-        || opt_type == gov_number-        || opt_type == gov_hidden_bool-        || opt_type == gov_hidden_number) {-      // number, possibly hidden-      n = (long)tv_get_number(tv);-    }--    if ((opt_p_flags & P_FUNC) && tv_is_func(*tv)) {-      // If the option can be set to a function reference or a lambda-      // and the passed value is a function reference, then convert it to-      // the name (string) of the function reference.-      s = tofree = encode_tv2string(tv, NULL);-    } else if (tv->v_type != VAR_BOOL && tv->v_type != VAR_SPECIAL) {-      // Avoid setting a string option to the text ""v:false"" or similar.-      s = tv_get_string_chk(tv);-    }--    if (op != NULL && *op != '=') {-      if (((opt_type == gov_bool || opt_type == gov_number) && *op == '.')-          || (opt_type == gov_string && *op != '.')) {-        semsg(_(e_letwrong), op);-        failed = true;  // don't set the value-      } else {-        // number or bool-        if (opt_type == gov_number || opt_type == gov_bool) {-          switch (*op) {-          case '+':-            n = numval + n; break;-          case '-':-            n = numval - n; break;-          case '*':-            n = numval * n; break;-          case '/':-            n = num_divide(numval, n); break;-          case '%':-            n = num_modulus(numval, n); break;-          }-          s = NULL;-        } else if (opt_type == gov_string && stringval != NULL && s != NULL) {-          // string-          char *const oldstringval = stringval;-          stringval = concat_str(stringval, s);-          xfree(oldstringval);-          s = stringval;+  bool hidden;+  bool error;+  const char c1 = *p;+  *p = NUL;++  OptVal curval = get_option_value(arg, NULL, scope, &hidden);+  OptVal newval = tv_to_optval(tv, arg, scope, &error);++  // Ignore errors for num types+  if (newval.type != kOptValTypeNumber && newval.type != kOptValTypeBoolean && error) {+    goto end;+  }++  // Don't assume current and new values are of the same type in order to future-proof the code for+  // when an option can have multiple types.+  const bool is_num = ((curval.type == kOptValTypeNumber || curval.type == kOptValTypeBoolean)+                       && (newval.type == kOptValTypeNumber || newval.type == kOptValTypeBoolean));+  const bool is_string = curval.type == kOptValTypeString && newval.type == kOptValTypeString;++  if (op != NULL && *op != '=') {+    if (!hidden && ((is_num && *op == '.') || (is_string && *op != '.'))) {+      semsg(_(e_letwrong), op);+      goto end;","> It's general in the sense that `set_option_from_tv` doesn't use an operator and thus will have no operator, and `ex_let_option` can just handle the operator itself to set the value of the boolean flag that it passes to `tv_to_optval`.> > > What if there will type changes like the change between number and bool> > Wdym? That'll just be handled normally. If the current value is a bool, the new value will be too. Same for number option value.Actually, no, numeric types won't be changed. So if new value is number and old value is bool, new value will remain a number. Num and bool types are handled together in `tv_to_optval` anyway so that shouldn't be an exceptional case.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/22866,1219543059,2023-06-06T12:21:32Z,runtime/lua/vim/health.lua,"@@ -2,6 +2,40 @@ local M = {}  local s_output = {} +-- Fold a healthcheck section+function M.foldtext()+  local foldtext = vim.fn.foldtext()++  if vim.api.nvim_buf_get_name(0) ~= 'health://' then",`&filetype == 'checkhealth'` is probably more semantically correct?```suggestion  if vim.o.filetype ~= 'checkhealth' then```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23919,1219649166,2023-06-06T13:24:35Z,runtime/lua/vim/treesitter/dev.lua,"@@ -1,16 +1,16 @@ local api = vim.api ----@class TSPlaygroundModule+---@class TSDevModule local M = {} ----@class TSPlayground+---@class TSView","```suggestion---@class TSTreeView```This is specifically a view of the LanguageTree, not a generic view (e.g. of queries).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23937,1219684905,2023-06-06T13:44:36Z,runtime/lua/vim/fs.lua,"@@ -350,6 +350,9 @@ function M.normalize(path, opts)    path = path:gsub('\\', '/'):gsub('/+', '/') +  if path == '/' then+    return path+  end   return path:sub(-1) == '/' and path:sub(1, -2) or path",I actually suspect the correct fix to this issue is in this line. This line unconditionally removes the trailing `/` on a path. Even if it's the only character. We should fix it here instead of adding another special case.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/23827,1219827105,2023-06-06T15:08:31Z,runtime/lua/vim/_system.lua,"@@ -0,0 +1,360 @@+local uv = vim.loop++--- @class SystemSpec+--- @field cmd string|string[]+--- @field args? string[]+--- @field stdin string|string[]|true+--- @field stdout fun(err:string, data: string)|false+--- @field stderr fun(err:string, data: string)|false+--- @field cwd? string+--- @field env? table<string,string|number>+--- @field timeout? integer Timeout in ms+--- @field detached? boolean++--- @class SystemCompleted+--- @field code integer+--- @field signal integer+--- @field stdout? string+--- @field stderr? string++--- @class SystemState+--- @field handle uv_process_t+--- @field timer uv_timer_t+--- @field pid integer+--- @field timeout? integer+--- @field done boolean+--- @field stdin uv_stream_t?+--- @field stdout uv_stream_t?+--- @field stderr uv_stream_t?+--- @field cmd string+--- @field args? string[]+--- @field result? SystemCompleted++---@private+---@param state SystemState+local function close_handles(state)+  for _, handle in pairs({ state.handle, state.stdin, state.stdout, state.stderr }) do+    if not handle:is_closing() then+      handle:close()+    end+  end+end++--- @param cmd string+--- @param args string[]?+--- @return SystemCompleted+local function timeout_result(cmd, args)+  local cmd_str = cmd .. ' ' .. table.concat(args or {}, ' ')+  local err = string.format(""Command timed out: '%s'"", cmd_str)+  return { code = 0, signal = 2, stdout = '', stderr = err }+end++--- @class SystemObj+--- @field pid integer+--- @field private _state SystemState+--- @field wait fun(self: SystemObj, timeout?: integer): SystemCompleted+--- @field kill fun(self: SystemObj, signal: integer)+--- @field write fun(self: SystemObj, data?: string|string[])+--- @field is_closing fun(self: SystemObj): boolean?+local SystemObj = {}++--- @param state SystemState+--- @return SystemObj+local function new_systemobj(state)+  return setmetatable({+    pid = state.pid,+    _state = state,+  }, { __index = SystemObj })+end++--- @param signal integer+function SystemObj:kill(signal)+  local state = self._state+  state.handle:kill(signal)+  close_handles(state)+end++local MAX_TIMEOUT = 2 ^ 31++--- @param timeout? integer+--- @return SystemCompleted+function SystemObj:wait(timeout)+  local state = self._state++  vim.wait(timeout or state.timeout or MAX_TIMEOUT, function()+    return state.done+  end)++  if not state.done then+    self:kill(6) -- 'sigint'+    state.result = timeout_result(state.cmd, state.args)+  end++  return state.result+end++--- @param data string[]|string|nil+function SystemObj:write(data)+  local stdin = self._state.stdin++  if not stdin then+    error('stdin has not been opened on this object')+  end++  if type(data) == 'table' then+    for _, v in ipairs(data) do+      stdin:write(v)+      stdin:write('\n')+    end+  elseif type(data) == 'string' then+    stdin:write(data)+  elseif data == nil then+    -- Shutdown the write side of the duplex stream and then close the pipe.+    -- Note shutdown will wait for all the pending write requests to complete+    -- TODO(lewis6991): apparently shutdown doesn't behave this way.+    -- (https://github.com/neovim/neovim/pull/17620#discussion_r820775616)+    stdin:write('', function()+      stdin:shutdown(function()+        if stdin then+          stdin:close()+        end+      end)+    end)+  end+end++--- @return boolean+function SystemObj:is_closing()+  local handle = self._state.handle+  return handle == nil or handle:is_closing()+end++--- @param spec string[]|SystemSpec+--- @return SystemSpec+local function process_spec(spec)+  if spec[1] then+    local cmd = {} --- @type string[]+    for _, p in ipairs(spec) do+      cmd[#cmd + 1] = p+    end+    spec = vim.deepcopy(spec)+    spec.cmd = cmd+  end++  return spec+end++---@private+---@param output function|'false'+---@return uv_stream_t?+---@return function? Handler+local function setup_output(output)+  if output == nil then+    return assert(uv.new_pipe(false)), nil+  end++  if type(output) == 'function' then+    return assert(uv.new_pipe(false)), output+  end++  assert(output == false)+  return nil, nil+end++---@private+---@param input string|string[]|true|nil+---@return uv_stream_t?+---@return string|string[]?+local function setup_input(input)+  if not input then+    return+  end++  local towrite --- @type string|string[]?+  if type(input) == 'string' or type(input) == 'table' then+    towrite = input+  end++  return assert(uv.new_pipe(false)), towrite+end++--- @param cmd string|string[]+--- @param args? string[]+--- @return string Command+--- @return string[]? Arguments+local function setup_cmd(cmd, args)+  if type(cmd) == 'string' then+    cmd = { cmd }+    if args then+      vim.list_extend(cmd, args)+    end+  end++  return cmd[1], vim.list_slice(cmd, 2)+end++--- uv.spawn will completely overwrite the environment+--- when we just want to modify the existing one, so if env is provided+--- make sure to prepopulate it with the current env.+--- @param env table<string,string|number>+--- @return string[]?+local function setup_env(env)+  if not env then+    return+  end++  --- @type table<string,string>+  local env0 = vim.tbl_extend('force', vim.fn.environ(), env)++  local renv = {} --- @type string[]+  for k, v in pairs(env0) do+    renv[#renv + 1] = string.format('%s=%s', k, tostring(v))+  end++  return renv+end++--- @param stream uv_stream_t+--- @param bucket string[]+--- @return fun(err: string?, data: string?)+local function default_handler(stream, bucket)+  return function(err, data)+    if err then+      error(err)+    end+    if data ~= nil then+      bucket[#bucket + 1] = data+    else+      stream:read_stop()+      stream:close()+    end+  end+end++local M = {}++--- @param cmd string+--- @param opts uv.aliases.spawn_options+--- @param on_exit fun(code: integer, signal: integer)+--- @param on_error fun()+--- @return uv_process_t, integer+local function spawn(cmd, opts, on_exit, on_error)+  local handle, pid_or_err = uv.spawn(cmd, opts, on_exit)",What problem does this avoid? None of the users of `uv.spawn()` I've found handle this. Also `NVIM_LISTEN_ADDRESS` is deprecated?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23827,1219844722,2023-06-06T15:19:18Z,runtime/lua/vim/_system.lua,"@@ -0,0 +1,360 @@+local uv = vim.loop++--- @class SystemSpec+--- @field cmd string|string[]+--- @field args? string[]+--- @field stdin string|string[]|true+--- @field stdout fun(err:string, data: string)|false+--- @field stderr fun(err:string, data: string)|false+--- @field cwd? string+--- @field env? table<string,string|number>+--- @field timeout? integer Timeout in ms+--- @field detached? boolean++--- @class SystemCompleted+--- @field code integer+--- @field signal integer+--- @field stdout? string+--- @field stderr? string++--- @class SystemState+--- @field handle uv_process_t+--- @field timer uv_timer_t+--- @field pid integer+--- @field timeout? integer+--- @field done boolean+--- @field stdin uv_stream_t?+--- @field stdout uv_stream_t?+--- @field stderr uv_stream_t?+--- @field cmd string+--- @field args? string[]+--- @field result? SystemCompleted++---@private+---@param state SystemState+local function close_handles(state)+  for _, handle in pairs({ state.handle, state.stdin, state.stdout, state.stderr }) do+    if not handle:is_closing() then+      handle:close()+    end+  end+end++--- @param cmd string+--- @param args string[]?+--- @return SystemCompleted+local function timeout_result(cmd, args)+  local cmd_str = cmd .. ' ' .. table.concat(args or {}, ' ')+  local err = string.format(""Command timed out: '%s'"", cmd_str)+  return { code = 0, signal = 2, stdout = '', stderr = err }+end++--- @class SystemObj+--- @field pid integer+--- @field private _state SystemState+--- @field wait fun(self: SystemObj, timeout?: integer): SystemCompleted+--- @field kill fun(self: SystemObj, signal: integer)+--- @field write fun(self: SystemObj, data?: string|string[])+--- @field is_closing fun(self: SystemObj): boolean?+local SystemObj = {}++--- @param state SystemState+--- @return SystemObj+local function new_systemobj(state)+  return setmetatable({+    pid = state.pid,+    _state = state,+  }, { __index = SystemObj })+end++--- @param signal integer+function SystemObj:kill(signal)+  local state = self._state+  state.handle:kill(signal)+  close_handles(state)+end++local MAX_TIMEOUT = 2 ^ 31++--- @param timeout? integer+--- @return SystemCompleted+function SystemObj:wait(timeout)+  local state = self._state++  vim.wait(timeout or state.timeout or MAX_TIMEOUT, function()+    return state.done+  end)++  if not state.done then+    self:kill(6) -- 'sigint'+    state.result = timeout_result(state.cmd, state.args)+  end++  return state.result+end++--- @param data string[]|string|nil+function SystemObj:write(data)+  local stdin = self._state.stdin++  if not stdin then+    error('stdin has not been opened on this object')+  end++  if type(data) == 'table' then+    for _, v in ipairs(data) do+      stdin:write(v)+      stdin:write('\n')+    end+  elseif type(data) == 'string' then+    stdin:write(data)+  elseif data == nil then+    -- Shutdown the write side of the duplex stream and then close the pipe.+    -- Note shutdown will wait for all the pending write requests to complete+    -- TODO(lewis6991): apparently shutdown doesn't behave this way.+    -- (https://github.com/neovim/neovim/pull/17620#discussion_r820775616)+    stdin:write('', function()+      stdin:shutdown(function()+        if stdin then+          stdin:close()+        end+      end)+    end)+  end+end++--- @return boolean+function SystemObj:is_closing()+  local handle = self._state.handle+  return handle == nil or handle:is_closing()+end++--- @param spec string[]|SystemSpec+--- @return SystemSpec+local function process_spec(spec)+  if spec[1] then+    local cmd = {} --- @type string[]+    for _, p in ipairs(spec) do+      cmd[#cmd + 1] = p+    end+    spec = vim.deepcopy(spec)+    spec.cmd = cmd+  end++  return spec+end++---@private+---@param output function|'false'+---@return uv_stream_t?+---@return function? Handler+local function setup_output(output)+  if output == nil then+    return assert(uv.new_pipe(false)), nil+  end++  if type(output) == 'function' then+    return assert(uv.new_pipe(false)), output+  end++  assert(output == false)+  return nil, nil+end++---@private+---@param input string|string[]|true|nil+---@return uv_stream_t?+---@return string|string[]?+local function setup_input(input)+  if not input then+    return+  end++  local towrite --- @type string|string[]?+  if type(input) == 'string' or type(input) == 'table' then+    towrite = input+  end++  return assert(uv.new_pipe(false)), towrite+end++--- @param cmd string|string[]+--- @param args? string[]+--- @return string Command+--- @return string[]? Arguments+local function setup_cmd(cmd, args)+  if type(cmd) == 'string' then+    cmd = { cmd }+    if args then+      vim.list_extend(cmd, args)+    end+  end++  return cmd[1], vim.list_slice(cmd, 2)+end++--- uv.spawn will completely overwrite the environment+--- when we just want to modify the existing one, so if env is provided+--- make sure to prepopulate it with the current env.+--- @param env table<string,string|number>+--- @return string[]?+local function setup_env(env)+  if not env then+    return+  end++  --- @type table<string,string>+  local env0 = vim.tbl_extend('force', vim.fn.environ(), env)++  local renv = {} --- @type string[]+  for k, v in pairs(env0) do+    renv[#renv + 1] = string.format('%s=%s', k, tostring(v))+  end++  return renv+end++--- @param stream uv_stream_t+--- @param bucket string[]+--- @return fun(err: string?, data: string?)+local function default_handler(stream, bucket)+  return function(err, data)+    if err then+      error(err)+    end+    if data ~= nil then+      bucket[#bucket + 1] = data+    else+      stream:read_stop()+      stream:close()+    end+  end+end++local M = {}++--- @param cmd string+--- @param opts uv.aliases.spawn_options+--- @param on_exit fun(code: integer, signal: integer)+--- @param on_error fun()+--- @return uv_process_t, integer+local function spawn(cmd, opts, on_exit, on_error)+  local handle, pid_or_err = uv.spawn(cmd, opts, on_exit)","> None of the users of `uv.spawn()` I've found handle thisThis is something Nvim should handle itself. It's for robustness: - we don't want child processes accidentally taking a dependency on `$NVIM_LISTEN_ADDRESS` (which, yes, is deprecated, and explicitly should not be passed to child processes to further strengthen the contract and avoid confusion)- `$NVIM` should always be set on child processes, else it serves no purpose",
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/23850,1219868611,2023-06-06T15:30:56Z,runtime/doc/options.txt,"@@ -52,7 +52,7 @@ achieve special effects.  These options come in three forms: 			  'lines' 			Warning: This may have a lot of side effects. -						*:set-args* *E487* *E521*+					*:set-args* *E487* *E521* *E5383*","> Oh right. I guess the tag can be moved there then.As far as I can tell though, `api.txt` doesn't have any error codes because API errors are treated differently. Which I recall is why @bfredl told me to put the `E5383` error tag alongside the other ones in `:set` ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23827,1219880134,2023-06-06T15:38:05Z,runtime/doc/lua.txt,"@@ -1571,6 +1571,75 @@ schedule_wrap({cb})                                      *vim.schedule_wrap()*       ��� |vim.schedule()|       ��� |vim.in_fast_event()| +system({spec}, {on_exit})                                       *vim.system()*+    Run a system command++    Examples: >lua++      local on_exit = function(code, signal, stdout, stderr)","Since the args are no longer positional, this is a 2-way door.",
18519692,notomo,https://api.github.com/repos/neovim/neovim/pulls/23937,1220588431,2023-06-07T00:21:42Z,runtime/lua/vim/fs.lua,"@@ -350,6 +350,9 @@ function M.normalize(path, opts)    path = path:gsub('\\', '/'):gsub('/+', '/') +  if path == '/' then+    return path+  end   return path:sub(-1) == '/' and path:sub(1, -2) or path","Thanks for reviewing!> I actually suspect the correct fix to this issue is in this line. This line unconditionally removes the trailing / on a path. Even if it's the only character. We should fix it here instead of adding another special case.Does this mean the following?```diffdiff --git a/runtime/lua/vim/fs.lua b/runtime/lua/vim/fs.luaindex 28d090543..668cf80ab 100644--- a/runtime/lua/vim/fs.lua+++ b/runtime/lua/vim/fs.lua@@ -350,10 +350,7 @@ function M.normalize(path, opts)    path = path:gsub('\\', '/'):gsub('/+', '/') -  if path == '/' then-    return path-  end-  return path:sub(-1) == '/' and path:sub(1, -2) or path+  return path:sub(-1) == '/' and path ~= '/' and path:sub(1, -2) or path end  return M```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23850,1220591377,2023-06-07T00:25:56Z,src/nvim/option_defs.h,"@@ -1080,4 +1081,24 @@ typedef struct vimoption { // buffers.  Indicate this by setting ""var"" to VAR_WIN. #define VAR_WIN ((char *)-1) +// Option value type+typedef enum {+  kOptValTypeNil = 0,+  kOptValTypeBoolean,+  kOptValTypeNumber,+  kOptValTypeString,+} OptValType;","Could name this `kOpt*` instead of `kOptVal*`, there is no risk of ambiguity in the future.```ctypedef enum {  kOptTypeNil = 0,  kOptTypeBoolean,  kOptTypeNumber,  kOptTypeString,} OptType;```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23850,1220598984,2023-06-07T00:34:33Z,src/nvim/option_defs.h,"@@ -1080,4 +1081,24 @@ typedef struct vimoption { // buffers.  Indicate this by setting ""var"" to VAR_WIN. #define VAR_WIN ((char *)-1) +// Option value type+typedef enum {+  kOptValTypeNil = 0,+  kOptValTypeBoolean,+  kOptValTypeNumber,+  kOptValTypeString,+} OptValType;",Won't this lead to ambiguity if an option can have multiple types in future?,
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/23850,1220722206,2023-06-07T02:25:16Z,src/nvim/option_defs.h,"@@ -1080,4 +1081,24 @@ typedef struct vimoption { // buffers.  Indicate this by setting ""var"" to VAR_WIN. #define VAR_WIN ((char *)-1) +// Option value type+typedef enum {+  kOptValTypeNil = 0,+  kOptValTypeBoolean,+  kOptValTypeNumber,+  kOptValTypeString,+} OptValType;","Agree with zeertz. Also, the current naming scheme for OptVal types is more consistent with other enums with types.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/23925,1221140299,2023-06-07T08:24:39Z,cmake/GenerateVersion.cmake,"@@ -8,6 +8,9 @@ execute_process(   ERROR_QUIET   RESULT_VARIABLE RES) +# Extract build info: ""145-g0f9113907"" => ""g0f9113907""+string(REGEX REPLACE "".*\\-"" """" NVIM_VERSION_BUILD ""${GIT_TAG}"")","Pretty sure this needs to be after the `if(RES)` block, because I think it'll fail without a .git directory. Not on computer atm, but you can test by renaming .git to something else temporarily and build neovim.",
38540736,willothy,https://api.github.com/repos/neovim/neovim/pulls/23947,1221532955,2023-06-07T12:47:58Z,runtime/lua/vim/mouse.lua,"@@ -0,0 +1,56 @@+--- Event handling for `<MouseMove>`, allowing for multiple subscribers+---+--- Example:+---+--- ```lua+--- vim.mouse.subscribe(function(pos)+---  print('Mouse moved to ' .. pos.screenrow .. ', ' .. pos.screencol)+--- end)+--- ```+local M = {}++---@type fun(mouse: MouseInfo)[]+local subscribers = {}++local function handle()+  ---@class MouseInfo+  ---@field screenrow number Screen row+  ---@field screencol number Screen column+  ---@field winid number Window the cursor is over+  ---@field winrow number Row inside ""winid""+  ---@field wincol number Column inside ""winid""+  ---@field line number Line inside ""winid""+  ---@field column number Column inside ""winid""+  local mouse = vim.fn.getmousepos()++  for _, fn in ipairs(subscribers) do+    fn(mouse)+  end+end++---Subscribe the provided handler to the `<MouseMove>` event+---+---Handlers receive a table, equivalent to the result+---of `vim.fn.getmousepos()`:+---+---  - screenrow (number)+---  - screencol (number)+---  - winid (number)+---  - winrow (number)+---  - wincol (number)+---  - line (number)+---  - column (number)+---@param handler fun(mouse: MouseInfo)+function M.subscribe(handler)+  table.insert(subscribers, handler)+end++function M.setup()+  if vim.version().minor > 8 and vim.o.mousemoveevent then","Definitely was one of the things I wasn't sure about. And my bad, should've marked this as a draft.",
38540736,willothy,https://api.github.com/repos/neovim/neovim/pulls/23947,1222141511,2023-06-07T20:49:12Z,src/nvim/mouse.c,"@@ -246,6 +246,16 @@ static int get_fpos_of_mouse(pos_T *mpos)   return IN_BUFFER; } +void do_move_autocmd(int screenrow, int screencol) {+	Dictionary data = ARRAY_DICT_INIT;+	PUT(data, ""screenrow"", INTEGER_OBJ(screenrow));+	PUT(data, ""screencol"", INTEGER_OBJ(screencol));+	Object obj = DICTIONARY_OBJ(data);+	apply_autocmds_group(EVENT_MOUSEMOVED, NULL, NULL, false, AUGROUP_ALL, NULL, NULL, &obj);+	api_free_dictionary(data);","Could use input on this - I saw similar free calls used in other files, but not sure if this is actually the proper way to free these values or if freeing the Object and its underlying Dictionary will result in a double free.EDIT: Crashes when I free the obj, so I guess that is a double free haha.",X
38540736,willothy,https://api.github.com/repos/neovim/neovim/pulls/23947,1222245150,2023-06-07T22:28:43Z,src/nvim/mouse.c,"@@ -245,6 +246,16 @@ static int get_fpos_of_mouse(pos_T *mpos)   return IN_BUFFER; } +/// Execute mouse move autocmd.+static void do_move_autocmd(int screenrow, int screencol) {+	Dictionary data = ARRAY_DICT_INIT;+	PUT(data, ""screenrow"", INTEGER_OBJ(screenrow + 1));+	PUT(data, ""screencol"", INTEGER_OBJ(screencol + 1));+	Object obj = DICTIONARY_OBJ(data);+	apply_autocmds_group(EVENT_MOUSEMOVED, NULL, NULL, false, AUGROUP_ALL, NULL, NULL, &obj);+	api_free_dictionary(data);",Not sure if I should be calling `api_free_dictionary(data)` or `api_free_object(obj)` here,
16093815,nojnhuh,https://api.github.com/repos/neovim/neovim/pulls/23500,1222310377,2023-06-08T00:24:53Z,runtime/lua/vim/lsp/_watchfiles.lua,"@@ -107,6 +107,13 @@ local to_lsp_change_type = {   [watch.FileChangeType.Deleted] = protocol.FileChangeType.Deleted, } +--- Default excludes the same as VSCode's `files.watcherExclude` setting.+--- https://github.com/microsoft/vscode/blob/eef30e7165e19b33daa1e15e92fa34ff4a5df0d3/src/vs/workbench/contrib/files/browser/files.contribution.ts#L261+---@type Lpeg pattern+M._poll_exclude_pattern = parse('**/.git/{objects,subtree-cache}/**')","@folke I wonder if exposing a variable like this would make it possible to exclude additional patterns per language, like `target` for rust.",
30379873,carlocab,https://api.github.com/repos/neovim/neovim/pulls/23642,1222714375,2023-06-08T09:30:17Z,.github/workflows/test.yml,"@@ -38,7 +38,7 @@ jobs:       - name: Install dependencies         run: |           ./.github/scripts/install_deps.sh-          brew install stylua uncrustify+          brew install stylua",If you do```shexport HOMEBREW_NO_AUTO_UPDATE=1export HOMEBREW_NO_INSTALLED_DEPENDENTS_CHECK=1export HOMEBREW_NO_INSTALL_UPGRADE=1export HOMEBREW_NO_INSTALL_CLEANUP=1brew untap homebrew/core```this should substantially speed up your usage of `brew`.,
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/23736,1222856300,2023-06-08T10:42:47Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -0,0 +1,215 @@+local util = require('vim.lsp.util')+local log = require('vim.lsp.log')+local api = vim.api+local M = {}++---@class lsp.inlay_hint.bufstate+---@field version integer+---@field client_hint table<integer, table<integer, lsp.InlayHint[]>> client_id -> (lnum -> hints)++---@type table<integer, lsp.inlay_hint.bufstate>+local hint_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end,+})++local namespace = api.nvim_create_namespace('vim_lsp_inlayhint')++M.__explicit_buffers = {}++--- |lsp-handler| for the method `textDocument/inlayHint`+--- Store hints for a specific buffer and client+--- Resolves unresolved hints+---+function M.on_inlayhint(err, result, ctx, _)+  if err then+    local _ = log.error() and log.error('inlayhint', err)+    return+  end+  local bufnr = ctx.bufnr+  if util.buf_versions[bufnr] ~= ctx.version then+    return+  end+  local client_id = ctx.client_id+  if not result then+    return+  end+  local bufstate = hint_cache_by_buf[bufnr]+  if not bufstate then+    bufstate = {+      client_hint = vim.defaulttable(),+      version = ctx.version,+    }+    hint_cache_by_buf[bufnr] = bufstate+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        api.nvim_buf_clear_namespace(b, namespace, 0, -1)+        hint_cache_by_buf[b] = nil+      end,+      on_reload = function(_, b)+        api.nvim_buf_clear_namespace(b, namespace, 0, -1)+        hint_cache_by_buf[b] = nil+      end,+    })+  end+  local hints_by_client = bufstate.client_hint+  local client = vim.lsp.get_client_by_id(client_id)++  local new_hints_by_lnum = vim.defaulttable()+  local num_unprocessed = #result+  if num_unprocessed == 0 then+    hints_by_client[client_id] = {}+    bufstate.version = ctx.version+    api.nvim__buf_redraw_range(bufnr, 0, -1)+    return+  end++  local lines = api.nvim_buf_get_lines(bufnr, 0, -1, false)+  ---@private+  local function pos_to_byte(position)+    local col = position.character+    if col > 0 then+      local line = lines[position.line + 1] or ''+      local ok, convert_result+      ok, convert_result = pcall(util._str_byteindex_enc, line, col, client.offset_encoding)+      if ok then+        return convert_result+      end+      return math.min(#line, col)+    end+    return col+  end++  for _, hint in ipairs(result) do+    local lnum = hint.position.line+    hint.position.character = pos_to_byte(hint.position)+    table.insert(new_hints_by_lnum[lnum], hint)+  end++  hints_by_client[client_id] = new_hints_by_lnum+  bufstate.version = ctx.version+  api.nvim__buf_redraw_range(bufnr, 0, -1)+end++---@private+local function resolve_bufnr(bufnr)+  return bufnr == 0 and api.nvim_get_current_buf() or bufnr+end++--- Refresh inlay hints for a buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---@param opts (nil|table) Optional arguments+---  - bufnr (integer, default: 0): Buffer whose hints to refresh+---  - only_visible (boolean, default: false): Whether to only refresh hints for the visible regions of the buffer+---+--- Example:+--- <pre>vim+---   autocmd BufEnter,InsertLeave,BufWritePost <buffer> lua vim.lsp.inlay_hint.refresh()+--- </pre>+---+function M.refresh(opts)+  opts = opts or {}+  local bufnr = opts.bufnr or 0+  local only_visible = opts.only_visible or false+  bufnr = resolve_bufnr(bufnr)+  M.__explicit_buffers[bufnr] = true+  local buffer_windows = {}+  for _, winid in ipairs(api.nvim_list_wins()) do+    if api.nvim_win_get_buf(winid) == bufnr then+      table.insert(buffer_windows, winid)+    end+  end+  for _, window in ipairs(buffer_windows) do+    local first = vim.fn.line('w0', window)+    local last = vim.fn.line('w$', window)+    local params = {+      textDocument = util.make_text_document_params(bufnr),+      range = {+        start = { line = first - 1, character = 0 },+        ['end'] = { line = last, character = 0 },+      },+    }+    vim.lsp.buf_request(bufnr, 'textDocument/inlayHint', params)+  end+  if not only_visible then+    local params = {+      textDocument = util.make_text_document_params(bufnr),+      range = {+        start = { line = 0, character = 0 },+        ['end'] = { line = api.nvim_buf_line_count(bufnr), character = 0 },+      },+    }+    vim.lsp.buf_request(bufnr, 'textDocument/inlayHint', params)+  end+end++--- Clear inlay hints+---+---@param client_id integer|nil filter by client_id. All clients if nil+---@param bufnr integer|nil filter by buffer. All buffers if nil+function M.clear(client_id, bufnr)+  local buffers = bufnr and { resolve_bufnr(bufnr) } or vim.tbl_keys(hint_cache_by_buf)+  for _, iter_bufnr in ipairs(buffers) do+    M.__explicit_buffers[iter_bufnr] = false+    local bufstate = hint_cache_by_buf[iter_bufnr]","> inlay hints to be updated frequentlyI wonder if you do some change then undo / reundo many times(just for test) how it works. ?  Is it more useful to use `nvim_buf_attach` ` on_line` and `on_changedtick` for more detailed synchronization buffer data for inlay request? (just a thought) recently i use these instead of autocmd event on lspsaga /documentSymbol .works better than autocmd. be careful that callback run very frequently. so use delayed requests to avoid sending multiple requests or resending requests before the end, etc skills can make it better . if now codes works fine nvm ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23947,1223081203,2023-06-08T13:56:45Z,src/nvim/mouse.c,"@@ -245,6 +246,16 @@ static int get_fpos_of_mouse(pos_T *mpos)   return IN_BUFFER; } +/// Execute mouse move autocmd.+static void do_move_autocmd(int screenrow, int screencol) {+	Dictionary data = ARRAY_DICT_INIT;+	PUT(data, ""screenrow"", INTEGER_OBJ(screenrow + 1));+	PUT(data, ""screencol"", INTEGER_OBJ(screencol + 1));+	Object obj = DICTIONARY_OBJ(data);+	apply_autocmds_group(EVENT_MOUSEMOVED, NULL, NULL, false, AUGROUP_ALL, NULL, NULL, &obj);+	api_free_dictionary(data);","`api_free_object` , else you need to do `api_free_dictionary(data.dictionary)`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23958,1223093408,2023-06-08T14:04:51Z,runtime/doc/news.txt,"@@ -142,6 +144,9 @@ release.   - |nvim_win_get_option()|	Use |nvim_get_option_value()| instead.   - |nvim_win_set_option()|	Use |nvim_set_option_value()| instead. +��� vim.lsp functions:+  - |vim.lsp.util.get_progress_messages()|	Use |vim.lsp.status()| instead.",also `deprecated.txt` ?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23961,1223621050,2023-06-08T22:54:24Z,runtime/lua/vim/filetype/detect.lua,"@@ -1459,6 +1459,7 @@ local patterns_hashbang = {   ['gforth\\>'] = { 'forth', { vim_regex = true } },   ['icon\\>'] = { 'icon', { vim_regex = true } },   guile = 'scheme',+  ['nix-shell'] = 'nix',",keep forgetting that these are patterns...locally this seems to suffice!,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/23968,1225634124,2023-06-10T22:42:40Z,contrib/flake.nix,"@@ -7,13 +7,50 @@   };    outputs = { self, nixpkgs, flake-utils }:+    let+      inherit (builtins)+        elemAt+        foldl'+        mapAttrs+        match+        readFile+        ;+      inherit (nixpkgs.lib)+        const+        flip+        pipe+        remove+        splitString+        toLower+        ;+    in     {       overlay = final: prev: { -        neovim = final.neovim-unwrapped.overrideAttrs (oa: rec {+        neovim = (final.neovim-unwrapped.override {","@dundargoc feel free to flat out say no but I wonder if we could make the deps.txt file more easily consumable by packagers, like json format , seems like that could work with native cmake https://stackoverflow.com/questions/46703437/cmakelists-parse-file.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/23968,1225644748,2023-06-10T23:11:03Z,contrib/flake.nix,"@@ -7,13 +7,50 @@   };    outputs = { self, nixpkgs, flake-utils }:+    let+      inherit (builtins)+        elemAt+        foldl'+        mapAttrs+        match+        readFile+        ;+      inherit (nixpkgs.lib)+        const+        flip+        pipe+        remove+        splitString+        toLower+        ;+    in     {       overlay = final: prev: { -        neovim = final.neovim-unwrapped.overrideAttrs (oa: rec {+        neovim = (final.neovim-unwrapped.override {","We'd need to bump minimum cmake version to 3.19. Not a flat out no, I just want to emphasize this is a big version requirement spike and that we'd need to convince people who will have opinions about this why this is needed.",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/23977,1225647827,2023-06-10T23:38:52Z,runtime/doc/options.txt,"@@ -5662,6 +5662,8 @@ A jump table for the options with a short description can be found at |Q_op|. 	line in the window wraps part of it may not be visible, as if it is 	above the window. ""<<<"" is displayed at the start of the first line, 	highlighted with |hl-NonText|.+	You may also want to add ""lastline"" to the 'display' option to show as+	much of the last line as possible.","well, technically this is already the default for nvim :innocent: ",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/23981,1225736029,2023-06-11T07:39:35Z,runtime/lua/vim/lsp.lua,"@@ -1509,24 +1509,28 @@ function lsp.start_client(config)         { method = method, client_id = client_id, bufnr = bufnr, params = params }       )     end, function(request_id)-      local request = client.requests[request_id]-      request.type = 'complete'-      nvim_exec_autocmds('LspRequest', {-        buffer = bufnr,-        modeline = false,-        data = { client_id = client_id, request_id = request_id, request = request },-      })-      client.requests[request_id] = nil+      if vim.fn.bufexists(bufnr) == 1 then","instead of check many times just check once like. if buffer not valid request.type is `invalid` then other check is no need.  not sure this. see other people's opinions```luaif not  vim.api.nvim_buf_is_valid(bufnr) then        local request = client.requests[request_id]        request.type = 'invalid'        nvim_exec_autocmds('LspRequest', {          buffer = bufnr,          modeline = false,          data = { client_id = client_id, request_id = request_id, request = request },        })      endend```",
2134196,110y,https://api.github.com/repos/neovim/neovim/pulls/23981,1225738870,2023-06-11T07:57:53Z,runtime/lua/vim/lsp.lua,"@@ -1509,24 +1509,28 @@ function lsp.start_client(config)         { method = method, client_id = client_id, bufnr = bufnr, params = params }       )     end, function(request_id)-      local request = client.requests[request_id]-      request.type = 'complete'-      nvim_exec_autocmds('LspRequest', {-        buffer = bufnr,-        modeline = false,-        data = { client_id = client_id, request_id = request_id, request = request },-      })-      client.requests[request_id] = nil+      if vim.fn.bufexists(bufnr) == 1 then",@glepnir Thank you for reviewing! I just replaced `vim.fn.bufexists` with `vim.api.nvim_buf_is_valid` at this time (and tweaked `if` statements to make it avoid only `nvim_exec_autocmds` when the buffer is no longer valid).> see other people's opinions����,
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/23984,1225774207,2023-06-11T10:49:42Z,runtime/lua/vim/lsp/_inlay_hint.lua,"@@ -149,26 +149,78 @@ end  --- Clear inlay hints -------@param client_id integer|nil filter by client_id. All clients if nil----@param bufnr integer|nil filter by buffer. All buffers if nil+---@param bufnr (integer|nil) Buffer handle, or nil for current ---@private-function M.clear(client_id, bufnr)-  local buffers = bufnr and { resolve_bufnr(bufnr) } or vim.tbl_keys(hint_cache_by_buf)-  for _, iter_bufnr in ipairs(buffers) do-    M.__explicit_buffers[iter_bufnr] = false-    local bufstate = hint_cache_by_buf[iter_bufnr]-    local client_lens = (bufstate or {}).client_hint or {}-    local client_ids = client_id and { client_id } or vim.tbl_keys(client_lens)-    for _, iter_client_id in ipairs(client_ids) do-      if bufstate then-        bufstate.client_hint[iter_client_id] = {}-      end+local function clear(bufnr)+  bufnr = resolve_bufnr(bufnr or 0)+  local bufstate = hint_cache_by_buf[bufnr]+  local client_lens = (bufstate or {}).client_hint or {}+  local client_ids = vim.tbl_keys(client_lens)+  for _, iter_client_id in ipairs(client_ids) do+    if bufstate then+      bufstate.client_hint[iter_client_id] = {}     end-    api.nvim_buf_clear_namespace(iter_bufnr, namespace, 0, -1)   end+  api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)   vim.cmd('redraw!') end +---@private+local function reset_timer(reset_bufnr)+  local timer = M.__buffers[reset_bufnr].timer+  if timer then+    M.__buffers[reset_bufnr].timer = nil+    if not timer:is_closing() then+      timer:stop()+      timer:close()+    end+  end+end++---@private+local function make_request(request_bufnr)+  reset_timer(request_bufnr)+  M.refresh({ bufnr = request_bufnr })+end++---@private+function M.enable(bufnr)+  bufnr = resolve_bufnr(bufnr or 0)+  if not (M.__buffers[bufnr] and M.__buffers[bufnr].enabled) then+    M.__buffers[bufnr] = { enabled = true, timer = nil }+    M.refresh({ bufnr = bufnr })+    api.nvim_buf_attach(bufnr, true, {+      on_lines = function(_, cb_bufnr)+        if not M.__buffers[cb_bufnr].enabled then+          return true+        end+        reset_timer(cb_bufnr)","not sure is the good way create timer for each buffer ,  and in `on_lines`  callback has `changedtick` param you can use  pass to request like `make_request(cb_bufnr, changedtick)`,  and when  lsp request callback running check `nvim_get_buf_chagnetick` make a compare. `if before_changetick < nvim_get_buf_changetick` do defer reqeust again.   some undo/redo also increase `changetick` and also some change without text chang also increase `changtick` .  this is my thought  and I do it on documentsymbol request . it combine 1000ms change to one request .  https://github.com/nvimdev/lspsaga.nvim/blob/3546dca5560b6868612acc567f6f3c07cf61c076/lua/lspsaga/symbol/init.lua#L25",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/23968,1225815683,2023-06-11T13:37:46Z,contrib/flake.nix,"@@ -7,13 +7,50 @@   };    outputs = { self, nixpkgs, flake-utils }:+    let+      inherit (builtins)+        elemAt+        foldl'+        mapAttrs+        match+        readFile+        ;+      inherit (nixpkgs.lib)+        const+        flip+        pipe+        remove+        splitString+        toLower+        ;+    in     {       overlay = final: prev: { -        neovim = final.neovim-unwrapped.overrideAttrs (oa: rec {+        neovim = (final.neovim-unwrapped.override {",Any roadblock to do that ? even ubuntu has 3.24 https://packages.ubuntu.com/kinetic/cmake. I will merge this without it since cmake upgrade seems like a big deal.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/23968,1225900368,2023-06-11T19:07:09Z,contrib/flake.nix,"@@ -7,13 +7,50 @@   };    outputs = { self, nixpkgs, flake-utils }:+    let+      inherit (builtins)+        elemAt+        foldl'+        mapAttrs+        match+        readFile+        ;+      inherit (nixpkgs.lib)+        const+        flip+        pipe+        remove+        splitString+        toLower+        ;+    in     {       overlay = final: prev: { -        neovim = final.neovim-unwrapped.overrideAttrs (oa: rec {+        neovim = (final.neovim-unwrapped.override {","That is a good idea. Makes it easier to refer to. @dundargoc If you have the time, you could open it with a list of features such a bump would buy us (which can be extended later)?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23984,1225924616,2023-06-11T21:01:50Z,runtime/doc/lsp.txt,"@@ -699,6 +699,24 @@ buf_detach_client({bufnr}, {client_id})          *vim.lsp.buf_detach_client()*       ��� {bufnr}      (integer) Buffer handle, or 0 for current       ��� {client_id}  (integer) Client id +buf_inlay_hint_disable({bufnr})             *vim.lsp.buf_inlay_hint_disable()*+    Disable inlay hints for a buffer++    Parameters: ~+      ��� {bufnr}  (integer|nil) Buffer handle, or nil for current++buf_inlay_hint_enable({bufnr})               *vim.lsp.buf_inlay_hint_enable()*","- This can take an `enable` parameter, then you don't need the `_disable()` variant.- Won't be long before someone asks for a getter (`is_enabled`), right? So if we add that now, then we also don't need `toggle()`. Because toggle is just `enable(!is_enabled())`",
36493671,p00f,https://api.github.com/repos/neovim/neovim/pulls/23984,1226038984,2023-06-12T03:01:22Z,runtime/doc/lsp.txt,"@@ -699,6 +699,24 @@ buf_detach_client({bufnr}, {client_id})          *vim.lsp.buf_detach_client()*       ��� {bufnr}      (integer) Buffer handle, or 0 for current       ��� {client_id}  (integer) Client id +buf_inlay_hint_disable({bufnr})             *vim.lsp.buf_inlay_hint_disable()*+    Disable inlay hints for a buffer++    Parameters: ~+      ��� {bufnr}  (integer|nil) Buffer handle, or nil for current++buf_inlay_hint_enable({bufnr})               *vim.lsp.buf_inlay_hint_enable()*","What if we don't add a getter and make it so that it toggles by default if there is no `enable` parameter, and enables/disables if there is?",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/24025,1231460201,2023-06-15T19:40:23Z,test/old/testdir/test_filetype.vim,"@@ -40,6 +40,30 @@ func Test_other_type()   filetype off endfunc +"" If $XDG_CONFIG_HOME is set return ""fname"" expanded in a list.+"" Otherwise return an empty list.+func WhenConfigHome(fname)","These new functions are script-local in the patch (I guess if we wanted to be super pedantic, they should also be `abort`, as that's what `:def` functions do, but it probably doesn't matter)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24045,1233141678,2023-06-17T22:20:57Z,src/nvim/option_defs.h,"@@ -1047,20 +1044,44 @@ typedef enum {   PV_MAXVAL = 0xffff,  // to avoid warnings for value out of range } idopt_T; +// Option value type+typedef enum {+  kOptValTypeNil = 0,+  kOptValTypeBoolean,+  kOptValTypeNumber,+  kOptValTypeString,+  // This represents the amount of option value types and must be kept at the end of the enum+  kOptValTypeCount","very common pattern in the codebase, don't need a long explanation```suggestion  kOptValTypeCount  // Must be last.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23138,1233876146,2023-06-19T10:43:00Z,MAINTAIN.md,"@@ -60,6 +60,32 @@ has a major bug: Neovim automation includes a [backport bot](https://github.com/zeebe-io/backport-action). Trigger the action by labeling a PR with `backport release-X.Y`. See `.github/workflows/backport.yml`. +Deprecating and removing features+---------------------------------++Neovim inherits many features and design decisions from Vim, not all of which+align with the goals of this project. It is sometimes desired or necessary to+remove existing features, or refactor parts of the code that would change+user's workflow. In these cases, a deprecation policy is needed to properly+inform users of the change.++In general, when a feature is slated to be removed it should:++1. Be marked deprecated in the _next_ release+  - This includes a note in the release notes (include a ""Deprecation Warning""+    section just below ""Breaking Changes"")+  - Lua features can use `vim.deprecate()`","We can be more specific here. For features where we know the planned removal version, that should be specified in the vim.deprecate() call.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24087,1236780052,2023-06-21T10:40:13Z,runtime/doc/lsp.txt,"@@ -243,59 +239,24 @@ For |lsp-response|, each |lsp-handler| has this signature: >                                     current document version to check if the                                     response is ""stale"".                                     See also |b:changedtick|.+                                    For |lsp-notification|: omitted.         {config}    (table)-                        Configuration for the handler.--                        Each handler can define its own configuration table-                        that allows users to customize the behavior of a-                        particular handler.--                        To configure a particular |lsp-handler|, see:-                            |lsp-handler-configuration|---    Returns: ~-        The |lsp-handler| can respond by returning two values: `result, err`-        Where `err` must be shaped like an RPC error:-            `{ code, message, data? }`--        You can use |vim.lsp.rpc.rpc_response_error()| to create this object.--For |lsp-notification|, each |lsp-handler| has this signature: >","Notification handler is very similar to the request case, so it's probably more helpful to combine their docs than split them.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/24087,1236800450,2023-06-21T10:59:54Z,runtime/doc/lsp.txt,"@@ -243,59 +239,24 @@ For |lsp-response|, each |lsp-handler| has this signature: >                                     current document version to check if the                                     response is ""stale"".                                     See also |b:changedtick|.+                                    For |lsp-notification|: omitted.         {config}    (table)-                        Configuration for the handler.--                        Each handler can define its own configuration table-                        that allows users to customize the behavior of a-                        particular handler.--                        To configure a particular |lsp-handler|, see:-                            |lsp-handler-configuration|---    Returns: ~-        The |lsp-handler| can respond by returning two values: `result, err`-        Where `err` must be shaped like an RPC error:-            `{ code, message, data? }`--        You can use |vim.lsp.rpc.rpc_response_error()| to create this object.--For |lsp-notification|, each |lsp-handler| has this signature: >","I think this is generally incorrect, there are no handlers for notifications.Notifications are fire-and-forget, the server doesn't send a response for them. See https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notificationMessageThe method also doesn't take a handler:https://github.com/neovim/neovim/blob/e27377e33e029a9c2efb282d4c4e51effd76dd88/runtime/lua/vim/lsp.lua#L1588-L1593https://github.com/neovim/neovim/blob/e27377e33e029a9c2efb282d4c4e51effd76dd88/runtime/lua/vim/lsp/rpc.lua#L272-L278",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24087,1236869855,2023-06-21T11:47:12Z,runtime/doc/lsp.txt,"@@ -243,59 +239,24 @@ For |lsp-response|, each |lsp-handler| has this signature: >                                     current document version to check if the                                     response is ""stale"".                                     See also |b:changedtick|.+                                    For |lsp-notification|: omitted.         {config}    (table)-                        Configuration for the handler.--                        Each handler can define its own configuration table-                        that allows users to customize the behavior of a-                        particular handler.--                        To configure a particular |lsp-handler|, see:-                            |lsp-handler-configuration|---    Returns: ~-        The |lsp-handler| can respond by returning two values: `result, err`-        Where `err` must be shaped like an RPC error:-            `{ code, message, data? }`--        You can use |vim.lsp.rpc.rpc_response_error()| to create this object.--For |lsp-notification|, each |lsp-handler| has this signature: >","> The method also doesn't take a handler:Yeah I was wondering about that :) So the doc should just be removed, right?What is implied by these tests?: https://github.com/neovim/neovim/blob/e27377e33e029a9c2efb282d4c4e51effd76dd88/test/functional/plugin/lsp_spec.lua#L281That's just testing for the message, not a handler of any sort?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24087,1238167907,2023-06-22T08:13:08Z,runtime/doc/eval.txt,"@@ -39,7 +39,7 @@ List		An ordered sequence of items, see |List| for details.  Dictionary	An associative, unordered array: Each entry has a key and a 		value. |Dictionary|-		Examples:+		Examples: >","> Is it just the lack of empty line? (We can add one after the closing tag, of course, for extra cake.)that's part of it, but also just the closing `<` is unnecessary most of the time so it's noise.otoh the `}` motion should probably handle ""conceal"" intellligently.> I've been religious about adding them to Nvim docs I touch, on principle as well as because sometimes that fixes (HTML) rendering issues.parser should handle it except in the middle of a list ���� ",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/24108,1238452068,2023-06-22T12:23:21Z,runtime/lua/vim/lsp.lua,"@@ -2270,9 +2270,9 @@ end  --- Implements 'omnifunc' compatible LSP completion. -------@see |complete-functions|----@see |complete-items|----@see |CompleteDone|+---@see help `|complete-functions|`+---@see help `|complete-items|`+---@see help `|CompleteDone|`","We could instead disable it in the config:```diffdiff --git a/contrib/luarc.json b/contrib/luarc.jsonindex ebad0581b..31126e421 100644--- a/contrib/luarc.json+++ b/contrib/luarc.json@@ -11,10 +11,13 @@           ""after_each"",           ""setup"",           ""teardown"",           ""finally"",           ""lfs""+        ],+        ""disable"": [+          ""luadoc-miss-see-name""         ]     },     ""workspace"": {         ""library"": [             ""runtime/lua"",```",
13142418,wsdjeg,https://api.github.com/repos/neovim/neovim/pulls/24115,1238526862,2023-06-22T13:25:41Z,runtime/lua/vim/_editor.lua,"@@ -568,14 +568,20 @@ end --- ---@param msg string Content of the notification to show to the user. ---@param level integer|nil One of the values from |vim.log.levels|.----@param opts table|nil Optional parameters. Unused by default.+---@param opts table|nil Options:+---   - history: (boolean) if true, add to |message-history|. function vim.notify(msg, level, opts) -- luacheck: no unused args+  opts = opts or {}","hi, @glepnir thanks for reviewing, but I do not know how to use `vim.validate`, I just read the `:h vim.validate`, it only shows how to check the type of argv, for example:```function vim.notify(msg, level, opts) -- luacheck: no unused args   vim.validate(         opts = {opts, 't'}   )```but I do not know how to check the type of `opts.history` in vim.validate. ",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/24108,1239562159,2023-06-23T09:01:36Z,contrib/luarc.json,"@@ -13,6 +13,13 @@           ""teardown"",           ""finally"",           ""lfs""+        ],+        ""disable"": [+          ""luadoc-miss-see-name"",+          ""duplicate-doc-field"",+          ""undefined-doc-name"",+          ""undefined-field"",+          ""param-type-mismatch""",use `userdata` instead of `uv_timer_t` remove this label.,
82267684,uga-rosa,https://api.github.com/repos/neovim/neovim/pulls/24144,1240973927,2023-06-24T23:58:19Z,runtime/doc/diagnostic.txt,"@@ -53,6 +53,9 @@ indicated with (+):     code: The diagnostic code     user_data: Arbitrary data plugins or users can add +In the return value of |vim.diagnostic.get()|, keys `bufnr`, `end_lnum`,","The text is long and there are not enough line breaks.```diffdiff --git a/runtime/doc/diagnostic.txt b/runtime/doc/diagnostic.txtindex b12a506..9dd4206 100644--- a/runtime/doc/diagnostic.txt+++ b/runtime/doc/diagnostic.txt@@ -53,9 +53,6 @@ indicated with (+):     code: The diagnostic code     user_data: Arbitrary data plugins or users can add-In the return value of |vim.diagnostic.get()|, keys `bufnr`, `end_lnum`,-`end_col`, and `severity` are guaranteed to be present.- Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based rows and columns). |api-indexing|@@ -481,7 +478,7 @@ get({bufnr}, {opts})                                    *vim.diagnostic.get()*                  ��� severity: See |diagnostic-severity|.     Return: ~-        Diagnostic [] table A list of diagnostic items |diagnostic-structure|.+        Diagnostic [] table A list of diagnostic items |diagnostic-structure|. Keys `bufnr` , `end_lnum` , `end_col` , and `severity` are guaranteed to be present. get_namespace({namespace})                    *vim.diagnostic.get_namespace()*     Get namespace metadata.diff --git a/runtime/lua/vim/diagnostic.lua b/runtime/lua/vim/diagnostic.luaindex 0d1d01b..093bfb6 100644--- a/runtime/lua/vim/diagnostic.lua+++ b/runtime/lua/vim/diagnostic.lua@@ -767,7 +767,7 @@ end ---                        - namespace: (number) Limit diagnostics to the given namespace. ---                        - lnum: (number) Limit diagnostics to the given line number. ---                        - severity: See |diagnostic-severity|.----@return Diagnostic[] table A list of diagnostic items |diagnostic-structure|.+---@return Diagnostic[] table A list of diagnostic items |diagnostic-structure|. Keys `bufnr`, `end_lnum`, `end_col`, and `severity` are guaranteed to be present. function M.get(bufnr, opts)   vim.validate({     bufnr = { bufnr, 'n', true },```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24116,1241179504,2023-06-25T13:36:31Z,runtime/doc/digraph.txt,"@@ -169,1311 +169,1312 @@ The rouble sign was added in 2014 as 0x20bd.  Vim supports the digraphs =R and =P for this.  Note that R= and P= are other characters.  						*digraph-table* *digraph-table-mbyte*-char  digraph	hex	dec	official name ~-^@	NU	0x00	  0	NULL (NUL)",TODO: lines following `column_heading` (`foo ~`) perhaps should be treated as true columnar data (thus in HTML rendered as `<table>`). But `column_heading` is abused in many places so would need to clean those up.,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24116,1241180060,2023-06-25T13:38:02Z,runtime/doc/editing.txt,"@@ -1245,8 +1245,8 @@ If you want to always use "":confirm"", set the 'confirm' option. 			|:diffsplit|, |:diffpatch|, |:pedit|, |:redir|, 			|:source|, |:update|, |:visual|, |:vsplit|, 			and |:qall| if 'confirm' is set.-			{only in Win32 GUI, in console `browse edit` works-			if the FileExplorer autocommand group exists}+			Note: only in Win32 GUI; in console `:browse edit`+			works if the FileExplorer autocommand group exists.","The `{only in blah}` stuff is no longer supported because that parses as an invalid `argument`. There were only a few remaining cases, anyway.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24046,1241202125,2023-06-25T14:23:27Z,runtime/doc/lsp.txt,"@@ -1697,14 +1700,15 @@ convert_signature_help_to_markdown_lines({signature_help}, {ft}, {triggers})     Converts `textDocument/SignatureHelp` response to markdown lines.      Parameters: ~-      ��� {signature_help}  Response of `textDocument/SignatureHelp`-      ��� {ft}              optional filetype that will be use as the `lang` for-                          the label markdown code block-      ��� {triggers}        optional list of trigger characters from the lsp+      ��� {signature_help}  (table) Response of `textDocument/SignatureHelp`+      ��� {ft}              (string|nil) filetype that will be use as the `lang`+                          for the label markdown code block+      ��� {triggers}        (table|nil) list of trigger characters from the lsp                           server. used to better determine parameter offsets      Return: ~-        (list) of lines of converted markdown.+        (table|nil) table list of lines of converted markdown.",```suggestion        (table|nil) list of lines of converted markdown.```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24148,1241217233,2023-06-25T15:06:51Z,runtime/queries/lua/highlights.scm,"@@ -216,7 +243,5 @@  (string) @string @spell -(escape_sequence) @string.escape-","Thanks; I added this here and meant to downstream it back (but forgot; the queries here only target master, so I removed deprecated functions as injection targets). I didn't mean to remove it here.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24116,1241219917,2023-06-25T15:20:39Z,runtime/doc/lsp.txt,"@@ -154,16 +154,17 @@ The `vim.lsp.buf_���` functions perform operations for all LSP clients attached to the given buffer. |lsp-buf|  LSP request/response handlers are implemented as Lua functions (see-|lsp-handler|). The |vim.lsp.handlers| table defines default handlers used-when creating a new client. Keys are LSP method names: >vim--    :lua print(vim.inspect(vim.tbl_keys(vim.lsp.handlers)))-<+|lsp-handler|).                                                                   *lsp-method* -Methods are the names of requests and notifications as defined by the LSP-specification. These LSP requests/notifications are defined by default in the-Nvim LSP client (but depends on server support):+Requests and notifications defined by the LSP specification are referred to as+""LSP methods"". The Nvim LSP client provides default handlers in the global+|vim.lsp.handlers| table, you can list them with this command: >vim++    :lua vim.print(vim.tbl_keys(vim.lsp.handlers))","minor note: this can also be done with `:=vim.tbl_keys(vim.lsp.handlers)` (and similarly elsewhere). but that might be _too_ much syntactic sugar for the docs, and could mess up the syntax highlighting.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23228,1241238331,2023-06-25T16:59:27Z,test/functional/terminal/buffer_spec.lua,"@@ -498,3 +498,17 @@ if is_os('win') then     end)   end) end++describe('termopen()', function()",����   looks like we don't have an existing describe() for termopen(). However that function will be deprecated so perhaps this should test `nvim_open_term` directly.,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/23228,1241239613,2023-06-25T17:04:56Z,src/nvim/api/vim.c,"@@ -951,12 +951,18 @@ Buffer nvim_create_buf(Boolean listed, Boolean scratch, Error *err) /// @return Channel id, or 0 on error Integer nvim_open_term(Buffer buffer, DictionaryOf(LuaRef) opts, Error *err)   FUNC_API_SINCE(7)+  FUNC_API_CHECK_TEXTLOCK_ALLOW_CMDWIN {   buf_T *buf = find_buffer_by_handle(buffer, err);   if (!buf) {     return 0;   } +  if (cmdwin_type != 0 && buf == curbuf) {+    api_set_error(err, kErrorTypeException, ""%s"", _(e_cmdwin));","It's allowed in the cmdwin, as long as you don't try to open a terminal in the cmdwin's buffer.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23228,1241281406,2023-06-25T20:26:06Z,src/nvim/generators/c_grammar.lua,"@@ -47,7 +47,8 @@ local c_proto = Ct(   (fill * Cg((P('FUNC_API_NOEXPORT') * Cc(true)), 'noexport') ^ -1) *   (fill * Cg((P('FUNC_API_REMOTE_ONLY') * Cc(true)), 'remote_only') ^ -1) *   (fill * Cg((P('FUNC_API_LUA_ONLY') * Cc(true)), 'lua_only') ^ -1) *-  (fill * Cg((P('FUNC_API_CHECK_TEXTLOCK') * Cc(true)), 'check_textlock') ^ -1) *+  (fill * (Cg(P('FUNC_API_CHECK_TEXTLOCK_ALLOW_CMDWIN') * Cc(true), 'check_textlock_allow_cmdwin') ++           Cg(P('FUNC_API_CHECK_TEXTLOCK') * Cc(true), 'check_textlock')) ^ -1) *","PR looks fine. Seem a bit weird to have textlock and cmdwin coupled, but the approach in your PR doesn't look like tech debt, it's easy to revisit it later.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23586,1242156976,2023-06-26T13:00:40Z,runtime/doc/lua.txt,"@@ -3351,4 +3351,91 @@ totable({f}, {...})                                       *vim.iter.totable()*     Return: ~         (table) ++==============================================================================+Lua module: net                                                      *lua-net*++fetch({url}, {opts})                                         *vim.net.fetch()*+    Perform an asyncronous network request.++    Example: >lua+    vim.net.fetch(""https://example.com/api/get"", {+      on_complete = function (response)","```suggestion      on_result = function (response)```or `on_done`. Looks like [nodejs](https://nodejs.org/api/net.html#netcreateconnectionoptions-connectlistener) calls this `on_end` , are there other conventions?",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/22481,1243528096,2023-06-27T10:38:27Z,runtime/doc/treesitter.txt,"@@ -292,7 +292,39 @@ The following directives are built in:         Example: >query             ((identifier) @constant (#offset! @constant 0 1 0 -1)) <+    `gsub!`                                          *treesitter-directive-gsub!*","It would be good if we could steer our directives so they are as digestible as possible by other TS implementations (for the very long term), so I'd prefer if there was a way to not include this.The others added here should be safe.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/22481,1243967264,2023-06-27T15:42:31Z,runtime/doc/treesitter.txt,"@@ -292,7 +292,39 @@ The following directives are built in:         Example: >query             ((identifier) @constant (#offset! @constant 0 1 0 -1)) <+    `gsub!`                                          *treesitter-directive-gsub!*","> Yes, eventually, and replace with something that covers a subset. I thought we talked about this?Not that I recall (or at least I don't recall such a strong conclusion). In any case, since the mere (even undocumented) presence of the directive has side effects (an error if a user/plugin tries to register the same directive), I feel strongly that the choice should be all-or-nothing here. Given that there's already precedent with `#lua-match!` and directives are explicitly documented as ""downstream responsibility"" by tree-sitter, my vote would be to keep it in (and possibly replace it in the same far future PR that replaces `#lua-match!`, given that both rely on Lua patterns).",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/23947,1246250054,2023-06-29T07:46:24Z,src/nvim/mouse.c,"@@ -398,6 +436,8 @@ bool do_mouse(oparg_T *oap, int c, int dir, long count, bool fixindent)   // ""d<MOUSE>""), or it is the middle button that is held down, ignore   // drag/release events.   if (!is_click && which_button == MOUSE_MIDDLE) {+    // Execute the MouseMoved autocmd for middleclick-drag",```suggestion    // Execute the MouseMove autocmd for middleclick-drag```,
38540736,willothy,https://api.github.com/repos/neovim/neovim/pulls/23947,1246286703,2023-06-29T08:16:59Z,runtime/doc/autocmd.txt,"@@ -1131,6 +1131,33 @@ WinResized			After a window in the current tab page changed 				Same behavior as |WinScrolled| for the 				pattern, triggering and recursiveness. ++							*MouseMove*+MouseMove			After the mouse is moved. Similar to the `<MouseMove>`+				mapping.++				Unlike the `<MouseMove>` mapping, it also triggers when+				dragging.++				|v:event| is set with information about the mouse position,+				which can be used like this: >","Ah, I see. Would this mean that the data would only be accessible from Lua, and not Vimscript? I'll look into setting v:event for future reference. Thanks!",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/24191,1246468111,2023-06-29T10:59:16Z,runtime/syntax/synload.vim,"@@ -48,8 +48,10 @@ fun! s:SynSet()     "" load each in sequence.  Skip empty entries.     for name in split(s, '\.')       if !empty(name)-        exe ""runtime! syntax/"" . name . "".vim syntax/"" . name . ""/*.vim""-        exe ""runtime! syntax/"" . name . "".lua syntax/"" . name . ""/*.lua""+        exe printf(+          \ ""runtime! syntax/%s.vim syntax/%s/*.vim  syntax/%s.lua syntax/%s/*.lua"",+          \ name, name, name, name+          \ )",Yes I believe so. Any pattern passed to `:runtime` will source vim files first.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24191,1247832974,2023-06-30T12:56:23Z,src/nvim/runtime.c,"@@ -269,9 +269,25 @@ void set_context_in_runtime_cmd(expand_T *xp, const char *arg)   xp->xp_pattern = (char *)arg; } -static void source_callback(char *fname, void *cookie)+static void source_callback(int num_fnames, char **fnames, void *cookie) {-  (void)do_source(fname, false, DOSO_NONE, cookie);+  for (int i = 0; i < num_fnames; i++) {+    if (str_ends_with(fnames[i], "".vim"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }++  for (int i = 0; i < num_fnames; i++) {+    if (str_ends_with(fnames[i], "".lua"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }++  for (int i = 0; i < num_fnames; i++) {+    if (!str_ends_with(fnames[i], "".vim"") && !str_ends_with(fnames[i], "".lua"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }","This may change behavior if someone uses `:runtime!` to load alphabetically-sorted files (e.g. `00_foo.lua`, `10_foo.vim`, `20_foo.lua`, `30_foo.vim`). Not sure if anyone is using this with multiple extensions in the same pattern though.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24191,1247843234,2023-06-30T13:06:59Z,src/nvim/runtime.c,"@@ -269,9 +269,25 @@ void set_context_in_runtime_cmd(expand_T *xp, const char *arg)   xp->xp_pattern = (char *)arg; } -static void source_callback(char *fname, void *cookie)+static void source_callback(int num_fnames, char **fnames, void *cookie) {-  (void)do_source(fname, false, DOSO_NONE, cookie);+  for (int i = 0; i < num_fnames; i++) {+    if (str_ends_with(fnames[i], "".vim"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }++  for (int i = 0; i < num_fnames; i++) {+    if (str_ends_with(fnames[i], "".lua"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }++  for (int i = 0; i < num_fnames; i++) {+    if (!str_ends_with(fnames[i], "".vim"") && !str_ends_with(fnames[i], "".lua"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }","I think this behavior change needs to be documented at `:h :runtime`. Although the old behavior is not used in Nvim itself, it possible that one may use it for some other purposes. To achieve the old behavior one has to expand the pattern and the source the files one by one.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24191,1247845802,2023-06-30T13:09:19Z,src/nvim/runtime.c,"@@ -269,9 +269,25 @@ void set_context_in_runtime_cmd(expand_T *xp, const char *arg)   xp->xp_pattern = (char *)arg; } -static void source_callback(char *fname, void *cookie)+static void source_callback(int num_fnames, char **fnames, void *cookie) {-  (void)do_source(fname, false, DOSO_NONE, cookie);+  for (int i = 0; i < num_fnames; i++) {+    if (str_ends_with(fnames[i], "".vim"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }++  for (int i = 0; i < num_fnames; i++) {+    if (str_ends_with(fnames[i], "".lua"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }++  for (int i = 0; i < num_fnames; i++) {+    if (!str_ends_with(fnames[i], "".vim"") && !str_ends_with(fnames[i], "".lua"")) {+      (void)do_source(fnames[i], false, DOSO_NONE, cookie);+    }+  }","In any case, we should decide and unambiguously document the order. (Which this PR is already improving.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24222,1248925179,2023-07-01T18:44:24Z,runtime/lua/vim/treesitter/_fold.lua,"@@ -147,6 +147,22 @@ local function normalise_erow(bufnr, erow)   return math.min(erow or max_erow, max_erow) end +---@type table<string, Query|false|nil>+--- `false` if query was not found+local queries = {}++---@return Query|nil+local function get_query(lang)","This looks like [another case](https://github.com/neovim/neovim/blob/ff8e3c6039d50bdbc5b19ac468b77567cb79d04a/runtime/lua/vim/diagnostic.lua#L387) that could benefit from a generalized ""memoize"" / LRU mechanism.  #23233Can you add a comment here like:```lua-- TODO: use generalized memoize / LRU. #23233```",
19489738,tomtomjhj,https://api.github.com/repos/neovim/neovim/pulls/24222,1249128841,2023-07-02T02:44:21Z,runtime/lua/vim/treesitter/_fold.lua,"@@ -147,6 +147,23 @@ local function normalise_erow(bufnr, erow)   return math.min(erow or max_erow, max_erow) end +---@type table<string, Query|false|nil>+--- `false` if query was not found+local queries = {}++-- TODO: use generalized memoize / LRU. #23233+---@return Query|nil+local function get_query(lang)+  local query = queries[lang]+  if query == false then+    return nil+  elseif query == nil then+    query = ts.query.get(lang, 'folds')","No, it isn't. https://github.com/neovim/neovim/blob/54807231c03495d6a322885d3ae7061e47cac490/runtime/lua/vim/treesitter/query.lua#L210-L221`explicit_queries` only stores queries set by `vim.treesitter.query.set()`, and `get_files` and `read_query_files` don't do caching either.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/24226,1249309424,2023-07-02T07:23:47Z,runtime/lua/vim/lsp.lua,"@@ -2090,13 +2090,14 @@ api.nvim_create_autocmd('VimLeavePre', { ---@param bufnr (integer) Buffer handle, or 0 for current. ---@param method (string) LSP method name ---@param params table|nil Parameters to send to the server----@param handler lsp-handler|nil See |lsp-handler|",Can we keep the more concrete type here? There is a `@class` or `@alias` definition for lsp-handler,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/24222,1249348424,2023-07-02T08:21:18Z,runtime/lua/vim/treesitter/_fold.lua,"@@ -147,6 +147,23 @@ local function normalise_erow(bufnr, erow)   return math.min(erow or max_erow, max_erow) end +---@type table<string, Query|false|nil>+--- `false` if query was not found+local queries = {}++-- TODO: use generalized memoize / LRU. #23233+---@return Query|nil+local function get_query(lang)+  local query = queries[lang]+  if query == false then+    return nil+  elseif query == nil then+    query = ts.query.get(lang, 'folds')",Ah we cache the parsing (https://github.com/neovim/neovim/blob/54807231c03495d6a322885d3ae7061e47cac490/runtime/lua/vim/treesitter/query.lua#L251) but not the file reading.Would it be possible to add the same parsing caching to file reading via a weak table?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24182,1249394085,2023-07-02T09:44:59Z,src/nvim/window.c,"@@ -1027,9 +1027,11 @@ void ui_ext_win_position(win_T *wp, bool validate)   } } -void ui_ext_win_viewport(win_T *wp)+void ui_ext_win_viewport(win_T *wp, bool allow_updated)","would it make senes to use the `validate` pattern found in many other display functions (including `win_ui_flush` which calls this)? Or are the semantics not similar enough?```suggestionvoid ui_ext_win_viewport(win_T *wp, bool validate)```",
9946255,fredizzimo,https://api.github.com/repos/neovim/neovim/pulls/24182,1250402600,2023-07-03T07:37:08Z,src/nvim/window.c,"@@ -1027,9 +1027,11 @@ void ui_ext_win_position(win_T *wp, bool validate)   } } -void ui_ext_win_viewport(win_T *wp)+void ui_ext_win_viewport(win_T *wp, bool allow_updated)","It is unfortunately required. `win_viewport` has the dual duty of indicating the row and column, and that is allowed to happen without calling `redraw_later` In those cases `v_viewport_invalid` is set and `ui_ext_win_viewport` is called directly from `UIFlush` and can happen basically everywhere.So, if the check `allow_updated` is not there, we are back to square one, `win_viewport` gets sent with a flush, while the actual screen is still dirty.My first approach was actually to remove `win_viewport` from `UIFlush`, but then there will be no feedback when only the `curcolumn` or `curow` are updated. The next approach was to call `win_view_port` unconditionally after `win_update`, but some tests are still failing with that, and it also sounds extremely risky, since it's been called from so many places before, even outside the `update_screen`",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24191,1250667885,2023-07-03T10:33:45Z,runtime/doc/starting.txt,"@@ -506,12 +506,12 @@ accordingly, proceeding as follows:  10. Load the plugin scripts.					*load-plugins* 	This does the same as the command: >-		:runtime! plugin/**/*.vim-		:runtime! plugin/**/*.lua+		:runtime! plugin/**/*.\(vim\|lua\) <	The result is that all directories in 'runtimepath' will be searched 	for the ""plugin"" sub-directory and all files ending in "".vim"" or 	"".lua"" will be sourced (in alphabetical order per directory),-	also in subdirectories. First ""*.vim"" are sourced, then ""*.lua"" files.+	also in subdirectories. First ""*.vim"" are sourced, then ""*.lua"" files,+	per directory.","As written, this kinda contradicts the sentence in `repeat.txt` -- here it sounds like ""all vim files, then all lua files""?I'd recommend writing one (longer) sentence and just copy-pasting it in both places, to make sure they're consistent.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24191,1250719299,2023-07-03T11:12:07Z,runtime/doc/repeat.txt,"@@ -231,6 +231,10 @@ For writing a Vim script, see chapter 41 of the user manual |usr_41.txt|. 				:runtime plugin/**/*.vim <			would source the first file only. +			For each {file} pattern, if a file has both a `.vim`+			and `.lua` extensions, the `.vim` version will take+			priority and be sourced first.","```suggestion			For each {file} pattern, if both `.vim` and `.lua`			files match in a directory, the `.vim` files take			priority and are sourced first.```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24191,1250761519,2023-07-03T11:46:53Z,runtime/doc/repeat.txt,"@@ -231,6 +231,10 @@ For writing a Vim script, see chapter 41 of the user manual |usr_41.txt|. 				:runtime plugin/**/*.vim <			would source the first file only. +			For each {file} pattern, if a file has both a `.vim`+			and `.lua` extensions, the `.vim` version will take+			priority and be sourced first.","How about this```suggestion			For each {file} pattern, if a multiple matches differ			only in extension, the `.vim` one takes the highest			priority, the `.lua` one lower, and the others lowest.```""both a ... extensions"" is a bit strange, isn't it?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/21677,1253009154,2023-07-05T12:06:19Z,runtime/doc/vim_diff.txt,"@@ -119,10 +119,11 @@ of these in your config by simply removing the mapping, e.g. "":unmap Y"". 	nnoremap <C-L> <Cmd>nohlsearch<Bar>diffupdate<Bar>normal! <C-L><CR> 	inoremap <C-U> <C-G>u<C-U> 	inoremap <C-W> <C-G>u<C-W>-	xnoremap * y/\V<C-R>""<CR>-	xnoremap # y?\V<C-R>""<CR> 	nnoremap & :&&<CR> <+Default mappings composed of Lua code are not listed above. Use "":map"" to see+the |map-listing|.","For cases where listing the exact mapping is too much, we can link to the defaults explicitly here. It's useful to have a single place where all the default mappings are linked from.```|v_#-default||v_star-default|```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24128,1253354256,2023-07-05T16:25:08Z,runtime/lua/vim/lsp.lua,"@@ -607,6 +608,20 @@ do         })       end     end++    vim.schedule(function()+      nvim_exec_autocmds('LspRequest', {","That's definitely contrary to the semantics of notifications. Should at least be documented.Also should call out `data.request.method` in the docs, if it isn't already, especially the docs related to this PR.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/24128,1253358124,2023-07-05T16:28:32Z,runtime/lua/vim/lsp.lua,"@@ -607,6 +608,20 @@ do         })       end     end++    vim.schedule(function()+      nvim_exec_autocmds('LspRequest', {","If notifications currently don't emit a `LspRequest` event I'd be inclined to introduce a new `LspNotify` or `LspNotification` autocmd. Requests and notifications are semantically different in the protocol and I guess in how the events behave as well. Notifications don't have the state transition because you cannot cancel a notification, so by adding a new trigger here we'd invalidate part of the documented `LspRequest` behavior. That would then happen in https://github.com/neovim/neovim/blob/f771d6247147b393238fe57065a96fb5e9635358/runtime/lua/vim/lsp.lua#L1572-L1577@justinmk is that okay with you?",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/24128,1253371946,2023-07-05T16:42:52Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -216,7 +245,123 @@ function M.on_publish_diagnostics(_, result, ctx, config)   end    client_id = get_client_id(client_id)-  local namespace = M.get_namespace(client_id)+  local namespace = M.get_namespace(client_id, false)++  if config then+    for _, opt in pairs(config) do+      if type(opt) == 'table' then+        if not opt.severity and opt.severity_limit then+          opt.severity = { min = severity_lsp_to_vim(opt.severity_limit) }+        end+      end+    end++    -- Persist configuration to ensure buffer reloads use the same+    -- configuration. To make lsp.with configuration work (See :help+    -- lsp-handler-configuration)+    vim.diagnostic.config(config, namespace)+  end++  vim.diagnostic.set(namespace, bufnr, diagnostic_lsp_to_vim(diagnostics, bufnr, client_id))+end++---@private+local function resolve_bufnr(bufnr)+  return bufnr > 0 and bufnr or api.nvim_get_current_buf()+end++--- Refresh diagnostics for a buffer+---+---@param opts (nil|table) Optional arguments+---  - bufnr (integer, default: 0): Buffer whose hints to refresh+---  - only_visible (boolean, default: false): Whether to only refresh diagnostics for the visible regions of the buffer+---+---@private+local function refresh(opts)+  opts = opts or {}+  local bufnr = resolve_bufnr(opts.bufnr or 0)+  local only_visible = opts.only_visible or false+  local buffer_windows = {}+  for _, winid in ipairs(api.nvim_list_wins()) do+    if api.nvim_win_get_buf(winid) == bufnr then+      table.insert(buffer_windows, winid)+    end+  end+  for _, window in ipairs(buffer_windows) do+    local first = vim.fn.line('w0', window)+    local last = vim.fn.line('w$', window)+    local params = {+      textDocument = util.make_text_document_params(bufnr),+      range = {+        start = { line = first - 1, character = 0 },+        ['end'] = { line = last, character = 0 },+      },+    }+    vim.lsp.buf_request(bufnr, 'textDocument/diagnostic', params)+  end","```suggestion  for _, winid in ipairs(api.nvim_list_wins()) do    if api.nvim_win_get_buf(winid) == bufnr then      local first = vim.fn.line('w0', window)      local last = vim.fn.line('w$', window)      local params = {        textDocument = util.make_text_document_params(bufnr),        range = {          start = { line = first - 1, character = 0 },          ['end'] = { line = last, character = 0 },        },      }      vim.lsp.buf_request(bufnr, 'textDocument/diagnostic', params)    end  end```Looks like the intermediate `buffer_windows` table is not needed?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/23029,1254148238,2023-07-06T09:00:12Z,runtime/doc/lua.txt,"@@ -1740,6 +1818,26 @@ list_slice({list}, {start}, {finish})                       *vim.list_slice()*     Return: ~         (list) Copy of table sliced from start to finish (inclusive) +map({f}, {src}, {...})                                             *vim.map()*","@gpanders any objection to changing this signature so that the function is the last param? That is generally the pattern we should strive for, because the function is usually the biggest part of a call (lexically).    map({src}, {f})Though if the variadic `...` arg is needed then this can't change. Is the variadic arg part of `{src}` ?",
21057514,sandersantema,https://api.github.com/repos/neovim/neovim/pulls/23029,1254448616,2023-07-06T13:31:59Z,runtime/doc/lua.txt,"@@ -1740,6 +1818,26 @@ list_slice({list}, {start}, {finish})                       *vim.list_slice()*     Return: ~         (list) Copy of table sliced from start to finish (inclusive) +map({f}, {src}, {...})                                             *vim.map()*","Just to chime in with another consideration, consistency with the map function in other languages, wikipedia has a comparison [here](https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison). As you can see from that list most commonly map takes a function as its first argument and `Iter:map` does so itself too. So if consistency is of importance I'd not switch these around.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/23029,1254582140,2023-07-06T15:11:22Z,runtime/doc/lua.txt,"@@ -1740,6 +1818,26 @@ list_slice({list}, {start}, {finish})                       *vim.list_slice()*     Return: ~         (list) Copy of table sliced from start to finish (inclusive) +map({f}, {src}, {...})                                             *vim.map()*","> @gpanders any objection to changing this signature so that the function is the last param? That is generally the pattern we should strive for, because the function is usually the biggest part of a call (lexically).> > ```> map({src}, {f})> ```> > Though if the variadic `...` arg is needed then this can't change. Is the variadic arg part of `{src}` ?@mfussenegger and I [discussed this as well](https://github.com/neovim/neovim/pull/23029#discussion_r1167067295). I also prefer trailing function for stylistic reasons, but as you pointed out we need the variadic params in order for this to work properly (a Lua function iterator uses multiple values to maintain its state. For example, the `pairs()` function actually returns 3 values, `:h luaref-in`).",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24236,1257262032,2023-07-08T12:57:28Z,src/nvim/api/window.c,"@@ -462,3 +464,105 @@ void nvim_win_set_hl_ns(Window window, Integer ns_id, Error *err)   win->w_hl_needs_update = true;   redraw_later(win, UPD_NOT_VALID); }++/// Counts the number of screen lines occupied by a range of text in a given window.+/// Works for lines that are off-screen and takes folds into account.+///+/// Diff filler or virtual lines above a line are counted as a part of that line,+/// unless the line is on ""start_row"" and ""start_vcol"" is specified.+///+/// Diff filler or virtual lines below the last line are only added to the result+/// if ""end_row"" is omitted.+///+/// Line indexing is similar to |nvim_buf_get_text()|.+///+/// @param window  Window handle, or 0 for current window.+/// @param opts    Optional parameters:+///                - start_row: Line index where the range starts, 0-based inclusive.+///                             When omitted start at the very top.+///                - end_row: Line index where the range ends, 0-based inclusive.+///                           When omitted end at the very bottom.+///                - start_vcol: Virtual column on ""start_row"" where the range starts,+///                              0-based, rounded down to full screen lines.+///                              When omitted count the whole line.+///                - end_vcol: Virtual column on ""end_row"" where the range ends,+///                            0-based, rounded up to full screen lines.+///                            When omitted count the whole line.+/// @return  The number of screen lines that the range of text occupy.+///+/// @see |virtcol()| for text width.+Integer nvim_win_text_height(Window window, Dict(win_text_height) *opts, Error *err)","I'd rather change the return value type to `Object`, because naming Dictionary keys is hard.",X
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24191,1257365390,2023-07-08T21:25:38Z,src/nvim/runtime.c,"@@ -1156,17 +1168,15 @@ void load_plugins(void) {   if (p_lpl) {     char *rtp_copy = p_rtp;-    char *const plugin_pattern_vim = ""plugin/**/*.vim"";  // NOLINT-    char *const plugin_pattern_lua = ""plugin/**/*.lua"";  // NOLINT+    char *const plugin_pattern = ""plugin/**/*.\\(vim\\|lua\\)"";  // NOLINT","```suggestion    char *const plugin_pattern = ""plugin/**/*.{vim,lua}"";  // NOLINT```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/24128,1259207523,2023-07-11T05:33:17Z,runtime/lua/vim/lsp.lua,"@@ -1573,7 +1591,23 @@ function lsp.start_client(config)     if method ~= 'textDocument/didChange' then       changetracking.flush(client)     end-    return rpc.notify(method, params)++    local result = rpc.notify(method, params)++    vim.schedule(function()+      nvim_exec_autocmds('LspNotify', {+        modeline = false,+        data = {+          request = {+            method = method,+            params = params,+            result = result,+          },+        },","I'm aware this is modelled after `LspRequest` but I'm not sure if there's much value in the extra `request` nesting.What do you think of having `method`, `params` and `result` directly under `data` ?Actually, I'd probably remove `result` and instead only invoke the autocmd if it's true (false indicates the client stopped, so in a way there was no notification)`result` is also a bit missleading, as notifications themselves have no result.This will also need docs similar to how `LspRequest` is documented",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/24191,1259519428,2023-07-11T10:09:52Z,src/nvim/runtime.c,"@@ -1156,17 +1168,15 @@ void load_plugins(void) {   if (p_lpl) {     char *rtp_copy = p_rtp;-    char *const plugin_pattern_vim = ""plugin/**/*.vim"";  // NOLINT-    char *const plugin_pattern_lua = ""plugin/**/*.lua"";  // NOLINT+    char *const plugin_pattern = ""plugin/**/*.\\(vim\\|lua\\)"";  // NOLINT",I've updated the change so the code doesn't rely on suffix patterns and the vim and lua case now has a specialized path.,
54458,catlee,https://api.github.com/repos/neovim/neovim/pulls/24128,1260011455,2023-07-11T16:56:19Z,runtime/lua/vim/lsp.lua,"@@ -1573,7 +1591,23 @@ function lsp.start_client(config)     if method ~= 'textDocument/didChange' then       changetracking.flush(client)     end-    return rpc.notify(method, params)++    local result = rpc.notify(method, params)++    vim.schedule(function()+      nvim_exec_autocmds('LspNotify', {+        modeline = false,+        data = {+          request = {+            method = method,+            params = params,+            result = result,+          },+        },","Sounds good.How does this look?```luadata = {  client_id = client.id,  method = method,  params = params,}```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/24128,1260110931,2023-07-11T18:16:10Z,runtime/lua/vim/lsp.lua,"@@ -1573,7 +1591,23 @@ function lsp.start_client(config)     if method ~= 'textDocument/didChange' then       changetracking.flush(client)     end-    return rpc.notify(method, params)++    local result = rpc.notify(method, params)++    vim.schedule(function()+      nvim_exec_autocmds('LspNotify', {+        modeline = false,+        data = {+          request = {+            method = method,+            params = params,+            result = result,+          },+        },","Looks good to me. Would passing along the full client also work?```data = {  client = client,  method = method,  params = params,}```If it's limited to primitive value it's also fine to go with the client_id. In case the client works it's probably more convenient to have access to it.  ",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/24128,1260211440,2023-07-11T19:52:43Z,runtime/lua/vim/lsp.lua,"@@ -1573,7 +1591,23 @@ function lsp.start_client(config)     if method ~= 'textDocument/didChange' then       changetracking.flush(client)     end-    return rpc.notify(method, params)++    local result = rpc.notify(method, params)++    vim.schedule(function()+      nvim_exec_autocmds('LspNotify', {+        modeline = false,+        data = {+          request = {+            method = method,+            params = params,+            result = result,+          },+        },","Hmm, ok, maybe there _were_ reasons we couldn't pass the full client. I remember it had something to do with not being able to serialize the client table since it contains a `userdata` type. But for some reason I thought that had either been resolved or was a non-issue (apparently that is not the case).",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/24128,1261190004,2023-07-12T13:34:26Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -161,7 +111,7 @@ end ---@param bufnr (integer) Buffer handle, or 0 for current ---@private local function clear(bufnr)-  bufnr = resolve_bufnr(bufnr)+  bufnr = bufnr or api.nvim_get_current_buf()",These changes also change semantics as they don't handle the bufnr = 0 case. I suspect that's not intentional?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24350,1264485028,2023-07-15T15:54:03Z,runtime/doc/news.txt,"@@ -51,6 +51,16 @@ The following changes may require adaptations in user config or plugins.   ��� `vim.json.null` is redundant with `vim.NIL`.   ��� `vim.json.array_mt` (and related) is redundant with `vim.empty_dict()`. +��� Removed some Vim 5.0<= option compatibilities:+  ��� |'backspace'| no longer supports number values. Instead:+    ��� for `backspace=0` set `backspace=` (empty)+    ��� for `backspace=1` set `backspace=indent,eol`+    ��� for `backspace=2` set `backspace=indent,eol,start` (default behavior in Nvim)+    ��� for `backspace=3` set `backspace=indent,eol,nostop`+  ��� paths in |'backupdir'|, |'path'| and |'cdpath'| can no longer be separated with+    spaces.","```suggestion  ��� paths in |'backupdir'|, |'path'| and |'cdpath'| can no longer be separated with    spaces (but paths themselves may contain spaces now).```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24350,1264528926,2023-07-15T18:56:08Z,runtime/doc/vim_diff.txt,"@@ -623,10 +623,17 @@ Highlight groups: Options:   *'aleph'* *'al'*   antialias+  |'backspace'| no longer supports number values. Instead:+    - for `backspace=0` set `backspace=` (empty)+    - for `backspace=1` set `backspace=indent,eol`+    - for `backspace=2` set `backspace=indent,eol,start` (default behavior in Nvim)+    - for `backspace=3` set `backspace=indent,eol,nostop`   *'balloondelay'* *'bdlay'*   *'ballooneval'* *'beval'* *'noballooneval'* *'nobeval'*   *'balloonexpr'* *'bexpr'*+  |'backupdir'|: paths can no longer be separated with spaces.",bars `|...|` are not needed to link to options.```suggestion  'backupdir': paths can no longer be separated with spaces.```,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24236,1264583266,2023-07-15T23:23:44Z,src/nvim/api/window.c,"@@ -462,3 +464,104 @@ void nvim_win_set_hl_ns(Window window, Integer ns_id, Error *err)   win->w_hl_needs_update = true;   redraw_later(win, UPD_NOT_VALID); }++/// Computes the number of screen lines occupied by a range of text in a given window.+/// Works for off-screen text and takes folds into account.+///+/// Diff filler or virtual lines above a line are counted as a part of that line,+/// unless the line is on ""start_row"" and ""start_vcol"" is specified.+///+/// Diff filler or virtual lines below the last buffer line are counted in the result+/// when ""end_row"" is omitted.+///+/// Line indexing is similar to |nvim_buf_get_text()|.+///+/// @param window  Window handle, or 0 for current window.+/// @param opts    Optional parameters:+///                - start_row: Starting line index, 0-based inclusive.+///                             When omitted start at the very top.+///                - end_row: Ending line index, 0-based inclusive.+///                           When omitted end at the very bottom.+///                - start_vcol: Starting virtual column index on ""start_row"",+///                              0-based inclusive, rounded down to full screen lines.+///                              When omitted include the whole line.+///                - end_vcol: Ending virtual column index on ""end_row"",+///                            0-based exclusive, rounded up to full screen lines.+///                            When omitted include the whole line.+/// @return  The number of screen lines that the range of text occupy.+///+/// @see |virtcol()| for text width.+Object nvim_win_text_height(Window window, Dict(win_text_height) *opts, Error *err)","Thinking about this more, I don't think Object helps us with forward-compatibility. Although technically we might not violate `:help api-contract` because we won't need to change the formal signature, if we return a new kind of result, it will still break clients expecting to ""unbox"" an int.And given the `..._height` suffix of the function, potential for other kinds of results is limited. So I guess this return type should be `Integer`.",X
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/24363,1264653947,2023-07-16T10:09:58Z,runtime/doc/lua.txt,"@@ -2871,6 +2814,72 @@ parents({start})                                            *vim.fs.parents()*         (function) Iterator  +==============================================================================+Lua module: highlight                                          *lua-highlight*+++Nvim includes a function for highlighting a selection on yank.++To enable it, add the following to your `init.vim` : >vim+    au TextYankPost * silent! lua vim.highlight.on_yank()+<++You can customize the highlight group and the duration of the highlight+via: >vim+    au TextYankPost * silent! lua vim.highlight.on_yank {higroup=""IncSearch"", timeout=150}+<++If you want to exclude visual selections from highlighting on yank, use: >vim+    au TextYankPost * silent! lua vim.highlight.on_yank {on_visual=false}+<++See https://github.com/machakann/vim-highlightedyank for example","Thank god, this is a pain to handle in doxygen.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24377,1265412980,2023-07-17T14:01:43Z,scripts/lsp_types.lua,"@@ -17,12 +17,12 @@ local function tofile(fname, text) end  function M.gen(opt)-  if vim.loop.fs_stat('./lsp.json') then+  if vim.uv.fs_stat('./lsp.json') then     vim.fn.delete('./lsp.json')   end   vim.fn.system({     'curl',-    'https://raw.githubusercontent.com/microsoft/lsprotocol/main/generator/lsp.json',+    'https://raw.githubusercontent.com/microsoft/lsprotocol/2023.0.0a2/generator/lsp.json',","the use-case of this script is ""I want to update to latest LSP spec"". with this change, that now requires editing this part of the script.this could perhaps be a parameter that defaults to `main`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24363,1265451630,2023-07-17T14:27:21Z,runtime/doc/lua.txt,"@@ -1888,28 +1983,28 @@ ringbuf({size})                                                *vim.ringbuf()*     Return: ~         (table) -Ringbuf:clear({self})                                        *Ringbuf:clear()*+vim.Ringbuf:clear()                                          *Ringbuf:clear()*","> Either:> > * `vim.ringbuf` goes in its own module> * We remove `vim.` from all functionsThe first option sounds much lower cost, for this one case. But does that mean all ""classes"" need to have dedicated modules? I hope not...",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24363,1265479360,2023-07-17T14:45:50Z,runtime/doc/lua.txt,"@@ -621,151 +601,207 @@ vim.highlight.priorities                            *vim.highlight.priorities*         ��� `user`: `200`, used for user-triggered highlights such as LSP document           symbols or `on_yank` autocommands --------------------------------------------------------------------------------VIM.REGEX                                                          *lua-regex*+vim.highlight.on_yank({opts})                        *vim.highlight.on_yank()*+    Highlight the yanked text++    Parameters: ~+      ��� {opts}  (table|nil) Optional parameters+                ��� higroup highlight group for yanked region (default+                  ""IncSearch"")+                ��� timeout time in ms before highlight is cleared (default 150)+                ��� on_macro highlight when executing macro (default false)+                ��� on_visual highlight when yanking visual selection (default+                  true)+                ��� event event structure (default vim.v.event)+                ��� priority integer priority (default+                  |vim.highlight.priorities|`.user`)++                                                       *vim.highlight.range()*+vim.highlight.range({bufnr}, {ns}, {higroup}, {start}, {finish}, {opts})+    Apply highlight group to range of text.++    Parameters: ~+      ��� {bufnr}    (integer) Buffer number to apply highlighting to+      ��� {ns}       (integer) Namespace to add highlight to+      ��� {higroup}  (string) Highlight group to use for highlighting+      ��� {start}    integer[]|string Start of region as a (line, column) tuple+                   or string accepted by |getpos()|+      ��� {finish}   integer[]|string End of region as a (line, column) tuple or+                   string accepted by |getpos()|+      ��� {opts}     (table|nil) Optional parameters+                   ��� regtype type of range (see |setreg()|, default charwise)+                   ��� inclusive boolean indicating whether the range is+                     end-inclusive (default false)+                   ��� priority number indicating priority of highlight (default+                     priorities.user)+++==============================================================================+VIM.REGEX                                                          *vim.regex*+  Vim regexes can be used directly from Lua. Currently they only allow matching within a single line. + vim.regex({re})                                                  *vim.regex()*     Parse the Vim regex {re} and return a regex object. Regexes are ""magic""     and case-sensitive by default, regardless of 'magic' and 'ignorecase'.     They can be controlled with flags, see |/magic| and |/ignorecase|. -Methods on the regex object:+    Parameters: ~+      ��� {re}  (string) -regex:match_str({str})                                     *regex:match_str()*-    Match the string against the regex. If the string should match the regex-    precisely, surround the regex with `^` and `$`. If the was a match, the-    byte indices for the beginning and end of the match is returned. When-    there is no match, `nil` is returned. As any integer is truth-y,-    `regex:match()` can be directly used as a condition in an if-statement.+    Return: ~+        vim.regex -regex:match_line({bufnr}, {line_idx} [, {start}, {end}])  *regex:match_line()*+                                                          *regex:match_line()*+vim.regex:match_line({bufnr}, {line_idx}, {start}, {end_})     Match line {line_idx} (zero-based) in buffer {bufnr}. If {start} and {end}     are supplied, match only this byte index range. Otherwise see     |regex:match_str()|. If {start} is used, then the returned byte indices     will be relative {start}. --------------------------------------------------------------------------------VIM.LPEG                                                            *lua-lpeg*+    Parameters: ~+      ��� {bufnr}     (integer)+      ��� {line_idx}  (integer)+      ��� {start}     (integer|nil)+      ��� {end_}      (integer|nil) -                                                             *vim.lpeg* *vim.re*-The Lpeg library for parsing expression grammars is being included as-`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/). In addition, its regex-like-interface is available as `vim.re` (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).+vim.regex:match_str({str})                                 *regex:match_str()*+    Match the string against the regex. If the string should match the regex+    precisely, surround the regex with `^` and `$` . If the was a match, the byte indices for the beginning and end of the+    match is returned. When there is no match, `nil` is returned. As any integer is truth-y, `regex:match()` can be directly used as a condition in an if-statement. --------------------------------------------------------------------------------VIM.DIFF                                                            *lua-diff*+    Parameters: ~+      ��� {str}   (string)+++==============================================================================+VIM.DIFF                                                            *vim.diff*  vim.diff({a}, {b}, {opts})                                        *vim.diff()*     Run diff on strings {a} and {b}. Any indices returned by this function,     either directly or via callback arguments, are 1-based.      Examples: >lua-        vim.diff('a\n', 'b\nc\n')-        -- =>-        -- @@ -1 +1,2 @@-        -- -a-        -- +b-        -- +c--        vim.diff('a\n', 'b\nc\n', {result_type = 'indices'})-        -- =>-        -- {-        --   {1, 1, 1, 2}-        -- }-<-    Parameters: ~-      ��� {a}      First string to compare-      ��� {b}      Second string to compare-      ��� {opts}   Optional parameters:-                 ��� `on_hunk` (callback):-                   Invoked for each hunk in the diff. Return a negative number-                   to cancel the callback for any remaining hunks.-                   Args:-                   ��� `start_a` (integer): Start line of hunk in {a}.-                   ��� `count_a` (integer): Hunk size in {a}.-                   ��� `start_b` (integer): Start line of hunk in {b}.-                   ��� `count_b` (integer): Hunk size in {b}.-                 ��� `result_type` (string): Form of the returned diff:-                   ��� ""unified"": (default) String in unified format.-                   ��� ""indices"": Array of hunk locations.-                   Note: This option is ignored if `on_hunk` is used.-                 ��� `linematch` (boolean|integer): Run linematch on the resulting hunks-                   from xdiff. When integer, only hunks upto this size in-                   lines are run through linematch. Requires `result_type = indices`,-                   ignored otherwise.-                 ��� `algorithm` (string):-                   Diff algorithm to use. Values:-                   ��� ""myers""      the default algorithm-                   ��� ""minimal""    spend extra time to generate the-                                  smallest possible diff-                   ��� ""patience""   patience diff algorithm-                   ��� ""histogram""  histogram diff algorithm-                 ��� `ctxlen` (integer): Context length-                 ��� `interhunkctxlen` (integer):-                   Inter hunk context length-                 ��� `ignore_whitespace` (boolean):-                   Ignore whitespace-                 ��� `ignore_whitespace_change` (boolean):-                   Ignore whitespace change-                 ��� `ignore_whitespace_change_at_eol` (boolean)-                   Ignore whitespace change at end-of-line.-                 ��� `ignore_cr_at_eol` (boolean)-                   Ignore carriage return at end-of-line-                 ��� `ignore_blank_lines` (boolean)-                   Ignore blank lines-                 ��� `indent_heuristic` (boolean):-                   Use the indent heuristic for the internal-                   diff library.--    Return: ~-        See {opts.result_type}. nil if {opts.on_hunk} is given. --------------------------------------------------------------------------------VIM.MPACK                                                          *lua-mpack*+         vim.diff('a\n', 'b\nc\n')+         -- =>+         -- @ -1 +1,2 @+         -- -a","is the extra indentation intentional or accidental? oh, it's because the old text wasn't auto-generated, right?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24363,1265497702,2023-07-17T14:59:23Z,runtime/lua/vim/_options.lua,,Nice change. `_meta.lua` was a somewhat opaque name for this. And probably too generic; options is a big enough topic for its own module.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/24363,1265506478,2023-07-17T15:04:28Z,runtime/lua/vim/_options.lua,,I was potentially going to follow this up with another rename `vimscript.lua` or `bridge.lua` and pull in all the other bridge components that are scattered about.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/24385,1266566326,2023-07-18T10:18:34Z,runtime/lua/vim/lsp.lua,"@@ -2048,7 +2048,7 @@ end ---@private ---@deprecated function lsp.get_active_clients(filter)-  -- TODO: add vim.deprecate call after 0.10 is out for removal in 0.12+  vim.deprecate('vim.lsp.get_active_cients', 'vim.lsp.get_clients', '0.12')",This will be very disruptive for downstream users.The `@deprecated` annotation should signal enough.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24387,1266802714,2023-07-18T13:46:53Z,runtime/lua/vim/loader.lua,"@@ -21,7 +21,10 @@ local M = {}  ---@alias LoaderStats table<string, {total:number, time:number, [string]:number?}?> +---@nodoc M.path = vim.fn.stdpath('cache') .. '/luac'++---@nodoc","Let's mention `@nodoc` at `:help dev-lua-doc`. Also `@meta` . We don't need a complete list there, but the custom or unusual ones are worth mentioning.",
6236829,haolian9,https://api.github.com/repos/neovim/neovim/pulls/24390,1267426205,2023-07-19T00:58:02Z,src/nvim/api/window.c,"@@ -439,6 +439,24 @@ Object nvim_win_call(Window window, LuaRef fun, Error *err)   return res; } +/// Gets a window's highlight namespace. A value of -1 is returned when+/// nvim_win_set_hl_ns has not been called for the window (or was called with+/// a namespace of -1).+///+/// @param window Window handle, or 0 for current window+/// @param[out] err Error details, if any+/// @return Namespace id, or -1+Integer nvim_win_get_hl_ns(Window window, Error *err)+  FUNC_API_SINCE(12)+{+  win_T *win = find_window_by_handle(window, err);+  if (!win) {+    return 0;","wow thanks for working on! (though i failed to find any discussions on that issus from the dev team, are the demands in that issue even valid? anyway)IMHO `return 0` has an ambiguous meaning: zero could be the global ns in other apis, and `win->w_ns_hl` could be zero(? nvim_win_set_hl_ns(winid, 0)` works with no error on my side), but here it represents 'window not found'.",
541289,dstein64,https://api.github.com/repos/neovim/neovim/pulls/24390,1267471086,2023-07-19T02:41:45Z,src/nvim/api/window.c,"@@ -439,6 +439,24 @@ Object nvim_win_call(Window window, LuaRef fun, Error *err)   return res; } +/// Gets a window's highlight namespace. A value of -1 is returned when+/// nvim_win_set_hl_ns has not been called for the window (or was called with+/// a namespace of -1).+///+/// @param window Window handle, or 0 for current window+/// @param[out] err Error details, if any+/// @return Namespace id, or -1+Integer nvim_win_get_hl_ns(Window window, Error *err)+  FUNC_API_SINCE(12)+{+  win_T *win = find_window_by_handle(window, err);+  if (!win) {+    return 0;","An error will result from the call to `find_window_by_handle`. For example, an error is thrown when I call `:echo nvim_win_get_hl_ns(999999)`:```E5555: API call: Invalid window id: 9999990```In the case of an error, it seems the return value loses its relevance. In this case, using `-1` would have a similar problem, as `nvim_win_set_hl_ns` also takes `-1` as a valid input value.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/24390,1268280072,2023-07-19T15:51:17Z,runtime/doc/api.txt,"@@ -976,6 +976,12 @@ nvim_get_hl_id_by_name({name})                      *nvim_get_hl_id_by_name()*      similar to |hlID()|, but allocates a new ID if not present. +nvim_get_hl_ns()                                            *nvim_get_hl_ns()*",I don't understand why highlight namespaces exist at all. Couldn't we just use regular namespaces for highlights? If so perhaps we can retrofit this somehow and deprecate window namespaces?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24394,1268297550,2023-07-19T16:06:04Z,runtime/lua/vim/fs.lua,"@@ -142,16 +143,16 @@ function M.dir(path, opts)   end) end ---- Find files or directories in the given path.+--- Find any items in the given path.","Sure, but I'm not sure that pattern is something I want to see all over the docs. The `{foo}` thing really stands out, and it can get noisy compared to codespans.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24411,1271271059,2023-07-22T09:00:11Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -130,9 +115,17 @@ local function clear(bufnr)   api.nvim__buf_redraw_range(bufnr, 0, -1) end -local function make_request(request_bufnr)-  reset_timer(request_bufnr)-  util._refresh('textDocument/inlayHint', { bufnr = request_bufnr })+--- Disable inlay hints for a buffer+---@param bufnr (integer) Buffer handle, or 0 for current+local function disable(bufnr)+  if bufnr == nil or bufnr == 0 then","That function is local to `lsp.lua`, though, and duplicated (in a simplified form) in `codelens.lua`. Could be refactored to a (`@private`) `util.lua` function in a followup PR.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/24407,1272247889,2023-07-24T13:14:39Z,runtime/syntax/editorconfig.vim,"@@ -1,15 +1,19 @@+"" Vim syntax file+"" Language:     EditorConfig+"" Maintainer:   Gregory Anders <greg@gpanders.com>","Do we want to keep the ""maintainer"" paradigm for syntax/runtime files which are fully owned by Neovim (instead of ported from Vim)?Personally I think I'd rather this file be ""owned"" by the project/organization, particularly considering that EditorConfig is a builtin, first class feature of Neovim (opposed to other syntax files, which are a ""best effort"" thing).cc @clason @seandewar (<-- runtime/funtime team)```suggestion```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24424,1272449414,2023-07-24T15:48:57Z,runtime/lua/vim/_meta/builtin.lua,"@@ -118,6 +118,52 @@ function vim.stricmp(a, b) end --- @param use_utf16? any function vim.str_byteindex(str, index, use_utf16) end +--- Returns a list of each character's starting byte position in the string",```suggestion--- Gets a list of byte positions of each char in the given UTF-8 encoded string.```,
62502207,MariaSolOs,https://api.github.com/repos/neovim/neovim/pulls/24469,1273850599,2023-07-25T17:05:29Z,runtime/lua/vim/lsp/inlay_hint.lua,"@@ -136,24 +138,27 @@ local function enable(bufnr)   end   local bufstate = bufstates[bufnr]   if not bufstate then-    bufstates[bufnr] = { applied = {} }-    bufstates[bufnr].autocmd_id = api.nvim_create_autocmd('LspNotify', {+    bufstates[bufnr] = { applied = {}, enabled = true }+    api.nvim_create_autocmd('LspNotify', {       buffer = bufnr,       callback = function(opts)-        if opts.data.method ~= 'textDocument/didChange' then+        if+          opts.data.method ~= 'textDocument/didChange'+          and opts.data.method ~= 'textDocumen/didOpen'",Typo:```suggestion          and opts.data.method ~= 'textDocument/didOpen'```,
62502207,MariaSolOs,https://api.github.com/repos/neovim/neovim/pulls/24469,1274037560,2023-07-25T19:58:41Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -416,38 +415,46 @@ function M._enable(bufnr)     bufnr = api.nvim_get_current_buf()   end -  if _autocmd_ids[bufnr] then-    return+  if not bufstates[bufnr] then+    bufstates[bufnr] = { enabled = true }++    api.nvim_create_autocmd('LspNotify', {+      buffer = bufnr,+      callback = function(opts)+        if+          opts.data.method ~= 'textDocument/didChange'+          and opts.data.method ~= 'textDocument/didOpen'",It would be nice to be able to use the LSP method names as patterns for the autocommand...,
546312,lambdalisue,https://api.github.com/repos/neovim/neovim/pulls/24399,1274444847,2023-07-26T06:41:58Z,src/nvim/msgpack_rpc/channel.c,"@@ -321,26 +321,31 @@ static void parse_msgpack(Channel *channel)       }       arena_mem_free(arena_finish(&p->arena));     } else if (p->type == kMessageTypeResponse) {-      ChannelCallFrame *frame = kv_last(channel->rpc.call_stack);-      if (p->request_id != frame->request_id) {-        char buf[256];-        snprintf(buf, sizeof(buf),-                 ""ch %"" PRIu64 "" returned a response with an unknown request ""-                 ""id. Ensure the client is properly synchronized"",-                 channel->id);-        chan_close_with_error(channel, buf, LOGLVL_ERR);-      }-      frame->returned = true;-      frame->errored = (p->error.type != kObjectTypeNil);--      if (frame->errored) {-        frame->result = p->error;-        // TODO(bfredl): p->result should not even be decoded-        // api_free_object(p->result);-      } else {-        frame->result = p->result;+      // Find the corresponding frame of the response+      for (size_t i = 0; i < kv_size(channel->rpc.call_stack); i++) {+        ChannelCallFrame *frame = kv_Z(channel->rpc.call_stack, i);+        if (p->request_id != frame->request_id) {+          continue;+        }+        frame->returned = true;+        frame->errored = (p->error.type != kObjectTypeNil);+        if (frame->errored) {+          frame->result = p->error;+          // TODO(bfredl): p->result should not even be decoded+          // api_free_object(p->result);+        } else {+          frame->result = p->result;+        }+        frame->result_mem = arena_finish(&p->arena);+        goto end;       }-      frame->result_mem = arena_finish(&p->arena);+      // No corresponding frame found for the response+      char buf[256];+      snprintf(buf, sizeof(buf),+                ""ch %"" PRIu64 "" returned a response with an unknown request ""+                ""id %"" PRIu32 "". Ensure the client is properly synchronized"",+                channel->id, p->request_id);+      chan_close_with_error(channel, buf, LOGLVL_ERR);",I think we should just ignore this case while it is likely caused by duplicated messages. What do you think?,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24399,1274892253,2023-07-26T12:35:47Z,src/nvim/msgpack_rpc/channel.c,"@@ -321,26 +321,31 @@ static void parse_msgpack(Channel *channel)       }       arena_mem_free(arena_finish(&p->arena));     } else if (p->type == kMessageTypeResponse) {-      ChannelCallFrame *frame = kv_last(channel->rpc.call_stack);-      if (p->request_id != frame->request_id) {-        char buf[256];-        snprintf(buf, sizeof(buf),-                 ""ch %"" PRIu64 "" returned a response with an unknown request ""-                 ""id. Ensure the client is properly synchronized"",-                 channel->id);-        chan_close_with_error(channel, buf, LOGLVL_ERR);-      }-      frame->returned = true;-      frame->errored = (p->error.type != kObjectTypeNil);--      if (frame->errored) {-        frame->result = p->error;-        // TODO(bfredl): p->result should not even be decoded-        // api_free_object(p->result);-      } else {-        frame->result = p->result;+      // Find the corresponding frame of the response+      for (size_t i = 0; i < kv_size(channel->rpc.call_stack); i++) {+        ChannelCallFrame *frame = kv_Z(channel->rpc.call_stack, i);+        if (p->request_id != frame->request_id) {+          continue;+        }+        frame->returned = true;+        frame->errored = (p->error.type != kObjectTypeNil);+        if (frame->errored) {+          frame->result = p->error;+          // TODO(bfredl): p->result should not even be decoded+          // api_free_object(p->result);+        } else {+          frame->result = p->result;+        }+        frame->result_mem = arena_finish(&p->arena);+        goto end;       }-      frame->result_mem = arena_finish(&p->arena);+      // No corresponding frame found for the response+      char buf[256];+      snprintf(buf, sizeof(buf),+                ""ch %"" PRIu64 "" returned a response with an unknown request ""+                ""id %"" PRIu32 "". Ensure the client is properly synchronized"",+                channel->id, p->request_id);+      chan_close_with_error(channel, buf, LOGLVL_ERR);",Why are messages being duplicated? Should we not at least _log_ such a case (perhaps at WARN level)? Silently ignoring problems leads to very difficult bugs.,X
54458,catlee,https://api.github.com/repos/neovim/neovim/pulls/24469,1274906739,2023-07-26T12:46:55Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -416,38 +415,46 @@ function M._enable(bufnr)     bufnr = api.nvim_get_current_buf()   end -  if _autocmd_ids[bufnr] then-    return+  if not bufstates[bufnr] then+    bufstates[bufnr] = { enabled = true }++    api.nvim_create_autocmd('LspNotify', {+      buffer = bufnr,+      callback = function(opts)+        if+          opts.data.method ~= 'textDocument/didChange'+          and opts.data.method ~= 'textDocument/didOpen'","Yeah, unfortunately patterns can't be used with buffer local autocmds:https://neovim.io/doc/user/api.html#api-autocmd",
546312,lambdalisue,https://api.github.com/repos/neovim/neovim/pulls/24399,1274915341,2023-07-26T12:53:59Z,src/nvim/msgpack_rpc/channel.c,"@@ -321,26 +321,31 @@ static void parse_msgpack(Channel *channel)       }       arena_mem_free(arena_finish(&p->arena));     } else if (p->type == kMessageTypeResponse) {-      ChannelCallFrame *frame = kv_last(channel->rpc.call_stack);-      if (p->request_id != frame->request_id) {-        char buf[256];-        snprintf(buf, sizeof(buf),-                 ""ch %"" PRIu64 "" returned a response with an unknown request ""-                 ""id. Ensure the client is properly synchronized"",-                 channel->id);-        chan_close_with_error(channel, buf, LOGLVL_ERR);-      }-      frame->returned = true;-      frame->errored = (p->error.type != kObjectTypeNil);--      if (frame->errored) {-        frame->result = p->error;-        // TODO(bfredl): p->result should not even be decoded-        // api_free_object(p->result);-      } else {-        frame->result = p->result;+      // Find the corresponding frame of the response+      for (size_t i = 0; i < kv_size(channel->rpc.call_stack); i++) {+        ChannelCallFrame *frame = kv_Z(channel->rpc.call_stack, i);+        if (p->request_id != frame->request_id) {+          continue;+        }+        frame->returned = true;+        frame->errored = (p->error.type != kObjectTypeNil);+        if (frame->errored) {+          frame->result = p->error;+          // TODO(bfredl): p->result should not even be decoded+          // api_free_object(p->result);+        } else {+          frame->result = p->result;+        }+        frame->result_mem = arena_finish(&p->arena);+        goto end;       }-      frame->result_mem = arena_finish(&p->arena);+      // No corresponding frame found for the response+      char buf[256];+      snprintf(buf, sizeof(buf),+                ""ch %"" PRIu64 "" returned a response with an unknown request ""+                ""id %"" PRIu32 "". Ensure the client is properly synchronized"",+                channel->id, p->request_id);+      chan_close_with_error(channel, buf, LOGLVL_ERR);","> Why are messages being duplicated? Should we not at least log such a case (perhaps at WARN level)? Silently ignoring problems leads to very difficult bugs.Totally agree. Yes, I said ""just ignore"" but I didn't mean just ignore, of course ���� ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24491,1275097433,2023-07-26T14:52:17Z,runtime/lua/vim/loader.lua,"@@ -27,13 +27,25 @@ M.path = vim.fn.stdpath('cache') .. '/luac' ---@nodoc M.enabled = false +---@nodoc+M.charmap = {","That is interesting, but then maybe we should expose these existing uri_encode/uri_decode functions and use those instead: https://github.com/neovim/neovim/blob/ccf328172bac2b02f9bd19fa58e105958514a28a/runtime/lua/vim/uri.lua#L19> Use the same percent-encoding that is done for URLs, but modified to encode a different set of ""reserved"" characters.Why is it necessary to have different reserved chars? This prevents using `uri.uri_encode`.",
8385547,ateoi,https://api.github.com/repos/neovim/neovim/pulls/24289,1275417375,2023-07-26T19:47:48Z,src/nvim/undo.c,"@@ -1615,20 +1615,26 @@ void u_read_undo(char *name, const uint8_t *hash, const char *orig_name FUNC_ATT   // Now that we have read the undo info successfully, free the current undo   // info and use the info from the file.   u_blockfree(curbuf);-  curbuf->b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx];-  curbuf->b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx];-  curbuf->b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx];-  curbuf->b_u_line_ptr = line_ptr;-  curbuf->b_u_line_lnum = line_lnum;-  curbuf->b_u_line_colnr = line_colnr;-  curbuf->b_u_numhead = num_head;-  curbuf->b_u_seq_last = seq_last;-  curbuf->b_u_seq_cur = seq_cur;-  curbuf->b_u_time_cur = seq_time;-  curbuf->b_u_save_nr_last = last_save_nr;-  curbuf->b_u_save_nr_cur = last_save_nr;--  curbuf->b_u_synced = true;+  u_state_T undostate = {+    .buf = curbuf,+    .save_b_u_synced = true,+    .save_b_u_time_cur = seq_time,+    .save_b_u_seq_cur = seq_cur,+    .save_b_u_seq_last = seq_last,+    .save_b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx],+    .save_b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx],+    .save_b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx],+    .save_b_u_numhead = num_head,+    .save_b_u_line_ptr = line_ptr,+    .save_b_u_line_lnum = line_lnum,+    .save_b_u_line_colnr = line_colnr,+    .save_b_p_ul = curbuf->b_p_ul,+    .save_b_changed = curbuf->b_changed,+    .save_changedtick = buf_get_changedtick(curbuf),+    .save_b_u_save_nr_cur = last_save_nr,+    .save_b_u_save_nr_last = last_save_nr,+  };+  u_restore_state(&undostate);","> The `save_*` prefix on each field seems redundant?Agree. And if we remove the prefix, we could use it to replace the `b_u_*` loose fields from `file_buffer`.https://github.com/neovim/neovim/blob/ccf328172bac2b02f9bd19fa58e105958514a28a/src/nvim/buffer_defs.h#L568-L583",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24493,1275543641,2023-07-26T22:29:47Z,runtime/doc/builtin.txt,"@@ -4730,7 +4309,8 @@ keytrans({string})					*keytrans()* 			""\<C-Home>""->keytrans()  <							*len()* *E701*",These tags seem to belong to the wrong function,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24465,1275642584,2023-07-27T01:46:08Z,src/nvim/main.c,"@@ -921,6 +921,10 @@ static void remote_request(mparm_T *params, int remote_args, char *server_addr,       os_errmsg(connect_error);       os_errmsg(""\n"");       os_exit(1);+    } else if (strequal(server_addr, os_getenv(""NVIM""))) {+      os_errmsg(""Cannot attach UI of :terminal child to its parent. (Unset $NVIM to skip this check)"");",Lint failure because this message is too long.Also should this message be translated? @justinmk,X
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/24289,1277240212,2023-07-28T08:03:19Z,src/nvim/undo.c,"@@ -1615,20 +1615,26 @@ void u_read_undo(char *name, const uint8_t *hash, const char *orig_name FUNC_ATT   // Now that we have read the undo info successfully, free the current undo   // info and use the info from the file.   u_blockfree(curbuf);-  curbuf->b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx];-  curbuf->b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx];-  curbuf->b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx];-  curbuf->b_u_line_ptr = line_ptr;-  curbuf->b_u_line_lnum = line_lnum;-  curbuf->b_u_line_colnr = line_colnr;-  curbuf->b_u_numhead = num_head;-  curbuf->b_u_seq_last = seq_last;-  curbuf->b_u_seq_cur = seq_cur;-  curbuf->b_u_time_cur = seq_time;-  curbuf->b_u_save_nr_last = last_save_nr;-  curbuf->b_u_save_nr_cur = last_save_nr;--  curbuf->b_u_synced = true;+  u_state_T undostate = {+    .buf = curbuf,+    .save_b_u_synced = true,+    .save_b_u_time_cur = seq_time,+    .save_b_u_seq_cur = seq_cur,+    .save_b_u_seq_last = seq_last,+    .save_b_u_newhead = new_idx < 0 ? NULL : uhp_table[new_idx],+    .save_b_u_oldhead = old_idx < 0 ? NULL : uhp_table[old_idx],+    .save_b_u_curhead = cur_idx < 0 ? NULL : uhp_table[cur_idx],+    .save_b_u_numhead = num_head,+    .save_b_u_line_ptr = line_ptr,+    .save_b_u_line_lnum = line_lnum,+    .save_b_u_line_colnr = line_colnr,+    .save_b_p_ul = curbuf->b_p_ul,+    .save_b_changed = curbuf->b_changed,+    .save_changedtick = buf_get_changedtick(curbuf),+    .save_b_u_save_nr_cur = last_save_nr,+    .save_b_u_save_nr_last = last_save_nr,+  };+  u_restore_state(&undostate);","> > The `save_*` prefix on each field seems redundant?> > Agree. And if we remove the prefix, we could use it to replace the `b_u_*` loose fields from `file_buffer`.> > https://github.com/neovim/neovim/blob/ccf328172bac2b02f9bd19fa58e105958514a28a/src/nvim/buffer_defs.h#L568-L583I like that idea a lot. Do you plan on making a PR for it?",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/24493,1277361838,2023-07-28T10:04:53Z,runtime/doc/lua.txt,"@@ -294,78 +294,6 @@ arguments separated by "" "" (space) instead of ""\t"" (tab).         :luafile script.lua         :luafile % <--==============================================================================-luaeval()                                                 *lua-eval* *luaeval()*","I did think about that, but there are quite a few chatty descriptions anyway, e.g. `searchpair()`, `searchcount()`, `setqflist()`,Additionally, it would be great if we could eventually generate `lua.txt` by removing most/all the static sections. It's 80% generated atm.",
45028928,tmillr,https://api.github.com/repos/neovim/neovim/pulls/24491,1277563616,2023-07-28T13:44:13Z,runtime/lua/vim/loader.lua,"@@ -27,13 +27,25 @@ M.path = vim.fn.stdpath('cache') .. '/luac' ---@nodoc M.enabled = false +---@nodoc+M.charmap = {",> Why is it necessary to have different reserved chars? This prevents using `uri.uri_encode`.Oh I didn't see that function. I suppose that should probably be used along with the `rfc2396` pattern. The only real downside I can think of would be somewhat longer filenames due to encoding more chars; idk if that would cause or lead to any issues in-practice...probably not?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24506,1277703262,2023-07-28T15:31:58Z,runtime/doc/builtin.txt,"@@ -361,39 +371,41 @@ atan({expr})							*atan()* 		the range [-pi/2, +pi/2] radians, as a |Float|. 		{expr} must evaluate to a |Float| or a |Number|. 		Returns 0.0 if {expr} is not a |Float| or a |Number|.-		Examples: >+		Examples: >vim 			:echo atan(100)-<			1.560797 >+<			1.560797 >vim 			:echo atan(-4.01) <			-1.326405 -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			Compute()->atan()+<  atan2({expr1}, {expr2})					*atan2()* 		Return the arc tangent of {expr1} / {expr2}, measured in 		radians, as a |Float| in the range [-pi, pi]. 		{expr1} and {expr2} must evaluate to a |Float| or a |Number|. 		Returns 0.0 if {expr1} or {expr2} is not a |Float| or a 		|Number|.-		Examples: >+		Examples: >vim 			:echo atan2(-1, 1)-<			-0.785398 >+<			-0.785398 >vim 			:echo atan2(1, -1) <			2.356194 -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			Compute()->atan2(1)+<  blob2list({blob})					*blob2list()* 		Return a List containing the number value of each byte in Blob-		{blob}.  Examples: >+		{blob}.  Examples: >vim 			blob2list(0z0102.0304)	returns [1, 2, 3, 4] 			blob2list(0z)		returns []","```suggestion			blob2list(0z0102.0304)	"" returns [1, 2, 3, 4]			blob2list(0z)           "" returns []```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24506,1277710280,2023-07-28T15:39:11Z,runtime/doc/builtin.txt,"@@ -4472,40 +4575,43 @@ lispindent({lnum})					*lispindent()* 		relevant.  {lnum} is used just like in |getline()|. 		When {lnum} is invalid, -1 is returned. -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			GetLnum()->lispindent()+<  list2blob({list})					*list2blob()* 		Return a Blob concatenating all the number values in {list}.-		Examples: >+		Examples: >vim 			list2blob([1, 2, 3, 4])	returns 0z01020304 			list2blob([])		returns 0z","```suggestion			list2blob([1, 2, 3, 4])	"" returns 0z01020304			list2blob([])		"" returns 0z```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24506,1277710551,2023-07-28T15:39:28Z,runtime/doc/builtin.txt,"@@ -4472,40 +4575,43 @@ lispindent({lnum})					*lispindent()* 		relevant.  {lnum} is used just like in |getline()|. 		When {lnum} is invalid, -1 is returned. -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			GetLnum()->lispindent()+<  list2blob({list})					*list2blob()* 		Return a Blob concatenating all the number values in {list}.-		Examples: >+		Examples: >vim 			list2blob([1, 2, 3, 4])	returns 0z01020304 			list2blob([])		returns 0z <		Returns an empty Blob on error.  If one of the numbers is 		negative or more than 255 error *E1239* is given.  		|blob2list()| does the opposite. -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			GetList()->list2blob()+<  list2str({list} [, {utf8}])				*list2str()* 		Convert each number in {list} to a character string can-		concatenate them all.  Examples: >+		concatenate them all.  Examples: >vim 			list2str([32])		returns "" "" 			list2str([65, 66, 67])	returns ""ABC""","```suggestion			list2str([32])		"" returns "" ""			list2str([65, 66, 67])	"" returns ""ABC""```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24506,1277710697,2023-07-28T15:39:39Z,runtime/doc/builtin.txt,"@@ -4472,40 +4575,43 @@ lispindent({lnum})					*lispindent()* 		relevant.  {lnum} is used just like in |getline()|. 		When {lnum} is invalid, -1 is returned. -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			GetLnum()->lispindent()+<  list2blob({list})					*list2blob()* 		Return a Blob concatenating all the number values in {list}.-		Examples: >+		Examples: >vim 			list2blob([1, 2, 3, 4])	returns 0z01020304 			list2blob([])		returns 0z <		Returns an empty Blob on error.  If one of the numbers is 		negative or more than 255 error *E1239* is given.  		|blob2list()| does the opposite. -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			GetList()->list2blob()+<  list2str({list} [, {utf8}])				*list2str()* 		Convert each number in {list} to a character string can-		concatenate them all.  Examples: >+		concatenate them all.  Examples: >vim 			list2str([32])		returns "" "" 			list2str([65, 66, 67])	returns ""ABC""-<		The same can be done (slowly) with: >+<		The same can be done (slowly) with: >vim 			join(map(list, {nr, val -> nr2char(val)}), '') <		|str2list()| does the opposite.  		UTF-8 encoding is always used, {utf8} option has no effect, 		and exists only for backwards-compatibility.-		With UTF-8 composing characters work as expected: >+		With UTF-8 composing characters work as expected: >vim 			list2str([97, 769])	returns ""a��""","```suggestion			list2str([97, 769])	"" returns ""a��""```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24506,1277714271,2023-07-28T15:43:07Z,runtime/doc/builtin.txt,"@@ -8081,28 +8253,30 @@ str2float({string} [, {quoted}])			*str2float()* 		The decimal point is always '.', no matter what the locale is 		set to.  A comma ends the number: ""12,345.67"" is converted to 		12.0.  You can strip out thousands separators with-		|substitute()|: >+		|substitute()|: >vim 			let f = str2float(substitute(text, ',', '', 'g')) < 		Returns 0.0 if the conversion fails. -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			let f = text->substitute(',', '', 'g')->str2float()+<  str2list({string} [, {utf8}])				*str2list()* 		Return a list containing the number values which represent-		each character in String {string}.  Examples: >+		each character in String {string}.  Examples: >vim 			str2list("" "")		returns [32] 			str2list(""ABC"")		returns [65, 66, 67]","```suggestion			str2list("" "")		"" returns [32]			str2list(""ABC"")		"" returns [65, 66, 67]```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/24506,1277714433,2023-07-28T15:43:18Z,runtime/doc/builtin.txt,"@@ -8081,28 +8253,30 @@ str2float({string} [, {quoted}])			*str2float()* 		The decimal point is always '.', no matter what the locale is 		set to.  A comma ends the number: ""12,345.67"" is converted to 		12.0.  You can strip out thousands separators with-		|substitute()|: >+		|substitute()|: >vim 			let f = str2float(substitute(text, ',', '', 'g')) < 		Returns 0.0 if the conversion fails. -		Can also be used as a |method|: >+		Can also be used as a |method|: >vim 			let f = text->substitute(',', '', 'g')->str2float()+<  str2list({string} [, {utf8}])				*str2list()* 		Return a list containing the number values which represent-		each character in String {string}.  Examples: >+		each character in String {string}.  Examples: >vim 			str2list("" "")		returns [32] 			str2list(""ABC"")		returns [65, 66, 67] <		|list2str()| does the opposite.  		UTF-8 encoding is always used, {utf8} option has no effect, 		and exists only for backwards-compatibility.-		With UTF-8 composing characters are handled properly: >+		With UTF-8 composing characters are handled properly: >vim 			str2list(""a��"")		returns [97, 769]","```suggestion			str2list(""a��"")		"" returns [97, 769]```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24504,1278152406,2023-07-28T23:01:48Z,runtime/lua/vim/lsp/protocol.lua,"@@ -318,6 +318,96 @@ for k, v in pairs(constants) do   protocol[k] = tbl end +--Lsp methods (based on version 3.18)+protocol.Methods = {+  Initialized = 'initialized',+  Exit = 'exit',+  ShutDown = 'shutdown',+  SetTrace = '$/setTrace',+  LogTrace = '$/logTrace',+  ClientRegisterCapability = 'client/registerCapability',","Do not use different casing than the actual protocol. That just creates useless differences.I guess we could use underscore for the slash. Or nested tables, which is what we do elsewhere, e.g. `protocol.make_client_capabilities()````suggestion  client_registerCapability = 'client/registerCapability',```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24504,1278152720,2023-07-28T23:02:41Z,runtime/lua/vim/lsp/protocol.lua,"@@ -318,6 +318,96 @@ for k, v in pairs(constants) do   protocol[k] = tbl end +--Lsp methods (based on version 3.18)+protocol.Methods = {+  Initialized = 'initialized',+  Exit = 'exit',+  ShutDown = 'shutdown',+  SetTrace = '$/setTrace',+  LogTrace = '$/logTrace',+  ClientRegisterCapability = 'client/registerCapability',+  ClientUnregisterCapability = 'client/unregisterCapability',+  LogMessage = 'window/logMessage',+  CancelRequest = '$/cancelRequest',+  ShowMessage = 'window/showMessage',+  ShowMessageRequest = 'window/showMesageRequest',+  TelemetryEvent = 'telemetry/event',+  DidOpen = 'textDocument/didOpen',+  DidClose = 'textDocument/didClose',+  WillSave = 'textDocument/willSave',+  WillSaveWaitUnitl = 'textDocument/willSaveWaitUntil',+  DidSave = 'textDocument/didSave',+  DidChange = 'textDocument/didChange',+  Hover = 'textDocument/hover',+  Rename = 'textDocument/rename',+  PrepareRename = 'textDocument/prepareRename',+  References = 'textDocument/references',+  Definition = 'textDocument/definition',+  TypeDefinition = 'textDocument/typeDefinition',+  Declaration = 'textDocument/declaration',","why aren't the namespaces included in the symbol names? Again this harms discoverability by adding useless differences.```suggestion  textDocument_declaration = 'textDocument/declaration',```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24491,1278165432,2023-07-28T23:10:08Z,runtime/lua/vim/loader.lua,"@@ -27,13 +27,25 @@ M.path = vim.fn.stdpath('cache') .. '/luac' ---@nodoc M.enabled = false +---@nodoc+M.charmap = {","> The only real downside I can think of would be somewhat longer filenames due to encoding more charsIf we are worried about that then we need a different approach altogether, like a compression function :) However, this does raise the point that we should raise an error/warning if a platform-specific path limit is exceeded. That could be a followup PR if it is out of scope here.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/24494,1278170450,2023-07-28T23:27:35Z,runtime/lua/vim/lsp/util.lua,"@@ -1105,7 +1111,31 @@ function M.make_floating_popup_options(width, height, opts)     or vim.fn.winline() - 1   local lines_below = vim.fn.winheight(0) - lines_above -  if lines_above < lines_below then+  local anchor_bias = opts.anchor_bias or 'auto'++  local anchor_below++  if anchor_bias == 'below' then+    if lines_below > lines_above then+      anchor_below = true+    else+      anchor_below = height <= lines_below+    end",ternary can be very concise without harming readability (often improves it).similar for other cases below.```suggestion    anchor_below = (lines_below > lines_above) and true or (height <= lines_below)```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24507,1278211495,2023-07-29T02:09:06Z,src/nvim/api/tabpage.c,"@@ -4,15 +4,51 @@ #include <stdbool.h> #include <stdlib.h> +#include ""nvim/api/private/converter.h"" #include ""nvim/api/private/defs.h"" #include ""nvim/api/private/helpers.h"" #include ""nvim/api/tabpage.h"" #include ""nvim/api/vim.h"" #include ""nvim/buffer_defs.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/typval_defs.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval/window.h"" #include ""nvim/globals.h"" #include ""nvim/memory.h"" #include ""nvim/window.h"" +/// Returns the layout of a tabpage as a tree-structured Dictionary",Now it's no longer a Dictionary.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24507,1278211579,2023-07-29T02:09:42Z,src/nvim/api/tabpage.c,"@@ -4,15 +4,51 @@ #include <stdbool.h> #include <stdlib.h> +#include ""nvim/api/private/converter.h"" #include ""nvim/api/private/defs.h"" #include ""nvim/api/private/helpers.h"" #include ""nvim/api/tabpage.h"" #include ""nvim/api/vim.h"" #include ""nvim/buffer_defs.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/typval_defs.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval/window.h"" #include ""nvim/globals.h"" #include ""nvim/memory.h"" #include ""nvim/window.h"" +/// Returns the layout of a tabpage as a tree-structured Dictionary+///+/// @param tabpage Tabpage handle, or 0 for the current tabpage+/// @param[out] err Error details, if any.+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)+  FUNC_API_SINCE(10)+{+  tabpage_T *tab;+  if (tabpage == 0) {+    tab = curtab;+  } else {+    tab = find_tab_by_handle(tabpage, err);+  }++  if (!tab) {+    return NIL;+  }++  list_T *fr_list = tv_list_alloc(2);++  get_framelayout(tab->tp_topframe, fr_list, true);++  typval_T rv = {+    .vval.v_list = fr_list,+    .v_type = VAR_LIST+  };++  return vim_to_object(&rv);",```suggestion  Array rv = vim_to_object(&list_tv).data.array;  tv_clear(&list_tv);  return rv;```,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/24507,1278211941,2023-07-29T02:11:18Z,src/nvim/api/tabpage.c,"@@ -4,15 +4,51 @@ #include <stdbool.h> #include <stdlib.h> +#include ""nvim/api/private/converter.h"" #include ""nvim/api/private/defs.h"" #include ""nvim/api/private/helpers.h"" #include ""nvim/api/tabpage.h"" #include ""nvim/api/vim.h"" #include ""nvim/buffer_defs.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/typval_defs.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval/window.h"" #include ""nvim/globals.h"" #include ""nvim/memory.h"" #include ""nvim/window.h"" +/// Returns the layout of a tabpage as a tree-structured Dictionary+///+/// @param tabpage Tabpage handle, or 0 for the current tabpage+/// @param[out] err Error details, if any.+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)+  FUNC_API_SINCE(10)+{+  tabpage_T *tab;+  if (tabpage == 0) {+    tab = curtab;+  } else {+    tab = find_tab_by_handle(tabpage, err);+  }++  if (!tab) {+    return NIL;+  }++  list_T *fr_list = tv_list_alloc(2);++  get_framelayout(tab->tp_topframe, fr_list, true);++  typval_T rv = {",```suggestion  typval_T list_tv = {```,
38540736,willothy,https://api.github.com/repos/neovim/neovim/pulls/24507,1278214208,2023-07-29T02:35:57Z,src/nvim/api/tabpage.c,"@@ -4,15 +4,51 @@ #include <stdbool.h> #include <stdlib.h> +#include ""nvim/api/private/converter.h"" #include ""nvim/api/private/defs.h"" #include ""nvim/api/private/helpers.h"" #include ""nvim/api/tabpage.h"" #include ""nvim/api/vim.h"" #include ""nvim/buffer_defs.h""+#include ""nvim/eval/typval.h""+#include ""nvim/eval/typval_defs.h""+#include ""nvim/eval/typval_encode.h""+#include ""nvim/eval/window.h"" #include ""nvim/globals.h"" #include ""nvim/memory.h"" #include ""nvim/window.h"" +/// Returns the layout of a tabpage as a tree-structured Dictionary+///+/// @param tabpage Tabpage handle, or 0 for the current tabpage+/// @param[out] err Error details, if any.+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)+  FUNC_API_SINCE(10)+{+  tabpage_T *tab;+  if (tabpage == 0) {+    tab = curtab;+  } else {+    tab = find_tab_by_handle(tabpage, err);+  }++  if (!tab) {+    return NIL;+  }++  list_T *fr_list = tv_list_alloc(2);++  get_framelayout(tab->tp_topframe, fr_list, true);++  typval_T rv = {+    .vval.v_list = fr_list,+    .v_type = VAR_LIST+  };++  return vim_to_object(&rv);","So to be clear, vim_to_object performs a copy  so the memory held by whatever it's converting from is no longer needed?",